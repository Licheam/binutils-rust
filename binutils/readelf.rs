#![allow(dead_code)]
#![allow(mutable_transmutes)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![feature(c_variadic)]
#![feature(extern_types)]
#![feature(label_break_value)]

#[macro_use]
extern crate c2rust_bitfields;
extern crate bfd_sys;
extern crate libctf_sys;
extern crate libiberty_sys;
extern crate zlib_sys;
extern crate libc;
pub mod src {
pub mod dwarf;
pub mod elfcomm;
pub mod unwind_ia64;
pub mod version;
} // mod src
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type internal_state;
    pub type bfd_sym_data_struct;
    pub type bfd_pef_xlib_data_struct;
    pub type bfd_pef_data_struct;
    pub type plugin_data_struct;
    pub type mach_o_fat_data_struct;
    pub type mach_o_data_struct;
    pub type netbsd_core_struct;
    pub type versados_data_struct;
    pub type cisco_core_struct;
    pub type osf_core_struct;
    pub type lynx_core_struct;
    pub type sgi_core_struct;
    pub type hppabsd_core_struct;
    pub type hpux_core_struct;
    pub type som_data_struct;
    pub type trad_core_struct;
    pub type sco5_core_struct;
    pub type sun_core_struct;
    pub type mmo_data_struct;
    pub type elf_obj_tdata;
    pub type tekhex_data_struct;
    pub type ihex_data_struct;
    pub type verilog_data_struct;
    pub type srec_data_struct;
    pub type ecoff_tdata;
    pub type xcoff_tdata;
    pub type pe_tdata;
    pub type coff_tdata;
    pub type artdata;
    pub type aout_data_struct;
    pub type bfd_link_hash_table;
    pub type bfd_link_order;
    pub type bfd_iovec;
    pub type bfd_link_info;
    pub type bfd_link_hash_entry;
    pub type flag_info;
    pub type _bfd_window_internal;
    pub type ctf_dict;
    pub type ctf_archive_internal;
    pub type ctf_dump_state;
    pub type ctf_next;
    fn __ctype_get_mb_cur_max() -> size_t;
    fn strtoul(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulong;
    static mut stdout: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn asprintf(
        __ptr: *mut *mut libc::c_char,
        __fmt: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn puts(__s: *const libc::c_char) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(
        __stream: *mut FILE,
        __off: libc::c_long,
        __whence: libc::c_int,
    ) -> libc::c_int;
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn rewind(__stream: *mut FILE);
    fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
    fn bindtextdomain(
        __domainname: *const libc::c_char,
        __dirname: *const libc::c_char,
    ) -> *mut libc::c_char;
    fn textdomain(__domainname: *const libc::c_char) -> *mut libc::c_char;
    fn dcngettext(
        __domainname: *const libc::c_char,
        __msgid1: *const libc::c_char,
        __msgid2: *const libc::c_char,
        __n: libc::c_ulong,
        __category: libc::c_int,
    ) -> *mut libc::c_char;
    fn dcgettext(
        __domainname: *const libc::c_char,
        __msgid: *const libc::c_char,
        __category: libc::c_int,
    ) -> *mut libc::c_char;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn exit(_: libc::c_int) -> !;
    static mut stderr: *mut FILE;
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strncat(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strnlen(__string: *const libc::c_char, __maxlen: size_t) -> size_t;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    fn stpcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn __errno_location() -> *mut libc::c_int;
    static mut optarg: *mut libc::c_char;
    static mut optind: libc::c_int;
    fn setlocale(
        __category: libc::c_int,
        __locale: *const libc::c_char,
    ) -> *mut libc::c_char;
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
    fn gmtime(__timer: *const time_t) -> *mut tm;
    fn inflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn inflateEnd(strm: z_streamp) -> libc::c_int;
    fn inflateReset(strm: z_streamp) -> libc::c_int;
    fn inflateInit_(
        strm: z_streamp,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
    fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const libc::c_char,
        __n: size_t,
        __p: *mut mbstate_t,
    ) -> size_t;
    fn print_version(_: *const libc::c_char);
    fn xmalloc(_: size_t) -> *mut libc::c_void;
    fn error(_: *const libc::c_char, _: ...);
    fn warn(_: *const libc::c_char, _: ...);
    static mut byte_put: Option::<
        unsafe extern "C" fn(*mut libc::c_uchar, elf_vma, libc::c_uint) -> (),
    >;
    fn byte_put_little_endian(_: *mut libc::c_uchar, _: elf_vma, _: libc::c_uint);
    fn byte_put_big_endian(_: *mut libc::c_uchar, _: elf_vma, _: libc::c_uint);
    static mut byte_get: Option::<
        unsafe extern "C" fn(*const libc::c_uchar, libc::c_uint) -> elf_vma,
    >;
    fn byte_get_signed(_: *const libc::c_uchar, _: libc::c_uint) -> elf_vma;
    fn byte_get_little_endian(_: *const libc::c_uchar, _: libc::c_uint) -> elf_vma;
    fn byte_get_big_endian(_: *const libc::c_uchar, _: libc::c_uint) -> elf_vma;
    fn adjust_relative_path(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn setup_archive(
        _: *mut archive_info,
        _: *const libc::c_char,
        _: *mut FILE,
        _: off_t,
        _: libc::c_int,
        _: libc::c_int,
    ) -> libc::c_int;
    fn release_archive(_: *mut archive_info);
    fn get_archive_member_name(
        _: *mut archive_info,
        _: *mut archive_info,
    ) -> *mut libc::c_char;
    fn get_archive_member_name_at(
        _: *mut archive_info,
        _: libc::c_ulong,
        _: *mut archive_info,
    ) -> *mut libc::c_char;
    fn make_qualified_name(
        _: *mut archive_info,
        _: *mut archive_info,
        _: *const libc::c_char,
    ) -> *mut libc::c_char;
    static mut debug_displays: [dwarf_section_display; 0];
    static mut first_separate_info: *mut separate_info;
    static mut eh_addr_size: libc::c_uint;
    static mut do_debug_info: libc::c_int;
    static mut do_debug_abbrevs: libc::c_int;
    static mut do_debug_lines: libc::c_int;
    static mut do_debug_pubnames: libc::c_int;
    static mut do_debug_pubtypes: libc::c_int;
    static mut do_debug_aranges: libc::c_int;
    static mut do_debug_ranges: libc::c_int;
    static mut do_debug_frames: libc::c_int;
    static mut do_debug_macinfo: libc::c_int;
    static mut do_debug_str: libc::c_int;
    static mut do_debug_str_offsets: libc::c_int;
    static mut do_debug_loc: libc::c_int;
    static mut do_gdb_index: libc::c_int;
    static mut do_trace_info: libc::c_int;
    static mut do_trace_abbrevs: libc::c_int;
    static mut do_trace_aranges: libc::c_int;
    static mut do_debug_addr: libc::c_int;
    static mut do_debug_cu_index: libc::c_int;
    static mut do_wide: libc::c_int;
    static mut do_debug_links: libc::c_int;
    static mut do_follow_links: libc::c_int;
    static mut do_checks: bool;
    static mut dwarf_cutoff_level: libc::c_int;
    static mut dwarf_start_die: libc::c_ulong;
    static mut dwarf_check: libc::c_int;
    fn init_dwarf_regnames_by_elf_machine_code(_: libc::c_uint);
    fn load_separate_debug_files(_: *mut libc::c_void, _: *const libc::c_char) -> bool;
    fn free_debug_memory();
    fn dwarf_select_sections_by_names(_: *const libc::c_char);
    fn dwarf_select_sections_by_letters(_: *const libc::c_char);
    fn dwarf_select_sections_all();
    fn find_cu_tu_set(_: *mut libc::c_void, _: libc::c_uint) -> *mut libc::c_uint;
    fn cmalloc(_: size_t, _: size_t) -> *mut libc::c_void;
    fn xcmalloc(_: size_t, _: size_t) -> *mut libc::c_void;
    fn read_leb128(
        _: *mut libc::c_uchar,
        _: *const libc::c_uchar,
        _: bool,
        _: *mut libc::c_uint,
        _: *mut libc::c_int,
    ) -> dwarf_vma;
    fn ctf_close(_: *mut ctf_archive_t);
    fn ctf_arc_bufopen(
        _: *const ctf_sect_t,
        _: *const ctf_sect_t,
        _: *const ctf_sect_t,
        _: *mut libc::c_int,
    ) -> *mut ctf_archive_t;
    fn ctf_arc_symsect_endianness(_: *mut ctf_archive_t, little_endian: libc::c_int);
    fn ctf_dict_open(
        _: *const ctf_archive_t,
        _: *const libc::c_char,
        _: *mut libc::c_int,
    ) -> *mut ctf_dict_t;
    fn ctf_dict_close(_: *mut ctf_dict_t);
    fn ctf_import(_: *mut ctf_dict_t, _: *mut ctf_dict_t) -> libc::c_int;
    fn ctf_errno(_: *mut ctf_dict_t) -> libc::c_int;
    fn ctf_errmsg(_: libc::c_int) -> *const libc::c_char;
    fn ctf_archive_iter(
        _: *const ctf_archive_t,
        _: Option::<ctf_archive_member_f>,
        _: *mut libc::c_void,
    ) -> libc::c_int;
    fn ctf_dump(
        _: *mut ctf_dict_t,
        state: *mut *mut ctf_dump_state_t,
        sect: ctf_sect_names_t,
        _: Option::<ctf_dump_decorate_f>,
        arg: *mut libc::c_void,
    ) -> *mut libc::c_char;
    fn ctf_errwarning_next(
        _: *mut ctf_dict_t,
        _: *mut *mut ctf_next_t,
        is_warning: *mut libc::c_int,
        errp: *mut libc::c_int,
    ) -> *mut libc::c_char;
    fn expandargv(_: *mut libc::c_int, _: *mut *mut *mut libc::c_char);
    fn cplus_demangle_name_to_style(name: *const libc::c_char) -> demangling_styles;
    fn cplus_demangle(
        mangled: *const libc::c_char,
        options_0: libc::c_int,
    ) -> *mut libc::c_char;
    fn cplus_demangle_set_style(style: demangling_styles) -> demangling_styles;
    fn getopt_long(
        argc: libc::c_int,
        argv: *const *mut libc::c_char,
        shortopts: *const libc::c_char,
        longopts: *const option,
        longind: *mut libc::c_int,
    ) -> libc::c_int;
    static _sch_istable: [libc::c_ushort; 256];
    fn unw_decode(
        _: *const libc::c_uchar,
        _: libc::c_int,
        _: *mut libc::c_void,
        _: *const libc::c_uchar,
    ) -> *const libc::c_uchar;
}
pub type size_t = libc::c_ulong;
pub type __uint16_t = libc::c_ushort;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: C2RustUnnamed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
    pub __wch: libc::c_uint,
    pub __wchb: [libc::c_char; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type off_t = __off_t;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type wchar_t = libc::c_int;
pub type __compar_fn_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
pub type Byte = libc::c_uchar;
pub type uInt = libc::c_uint;
pub type uLong = libc::c_ulong;
pub type Bytef = Byte;
pub type voidpf = *mut libc::c_void;
pub type alloc_func = Option::<unsafe extern "C" fn(voidpf, uInt, uInt) -> voidpf>;
pub type free_func = Option::<unsafe extern "C" fn(voidpf, voidpf) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct z_stream_s {
    pub next_in: *mut Bytef,
    pub avail_in: uInt,
    pub total_in: uLong,
    pub next_out: *mut Bytef,
    pub avail_out: uInt,
    pub total_out: uLong,
    pub msg: *mut libc::c_char,
    pub state: *mut internal_state,
    pub zalloc: alloc_func,
    pub zfree: free_func,
    pub opaque: voidpf,
    pub data_type: libc::c_int,
    pub adler: uLong,
    pub reserved: uLong,
}
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
pub type mbstate_t = __mbstate_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type bfd_int64_t = libc::c_long;
pub type bfd_uint64_t = libc::c_ulong;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd {
    pub filename: *const libc::c_char,
    pub xvec: *const bfd_target,
    pub iostream: *mut libc::c_void,
    pub iovec: *const bfd_iovec,
    pub lru_prev: *mut bfd,
    pub lru_next: *mut bfd,
    pub where_0: ufile_ptr,
    pub mtime: libc::c_long,
    pub id: libc::c_uint,
    pub flags: flagword,
    #[bitfield(name = "format", ty = "bfd_format", bits = "0..=2")]
    #[bitfield(name = "direction", ty = "bfd_direction", bits = "3..=4")]
    #[bitfield(name = "cacheable", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "target_defaulted", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "opened_once", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "mtime_set", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "no_export", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "output_has_begun", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "has_armap", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "is_thin_archive", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "no_element_cache", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "selective_search", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "is_linker_output", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "is_linker_input", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "plugin_format", ty = "bfd_plugin_format", bits = "17..=18")]
    #[bitfield(name = "lto_output", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "lto_slim_object", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "read_only", ty = "libc::c_uint", bits = "21..=21")]
    pub format_direction_cacheable_target_defaulted_opened_once_mtime_set_no_export_output_has_begun_has_armap_is_thin_archive_no_element_cache_selective_search_is_linker_output_is_linker_input_plugin_format_lto_output_lto_slim_object_read_only: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 5],
    pub plugin_dummy_bfd: *mut bfd,
    pub origin: ufile_ptr,
    pub proxy_origin: ufile_ptr,
    pub section_htab: bfd_hash_table,
    pub sections: *mut bfd_section,
    pub section_last: *mut bfd_section,
    pub section_count: libc::c_uint,
    pub archive_plugin_fd: libc::c_int,
    pub archive_plugin_fd_open_count: libc::c_uint,
    pub archive_pass: libc::c_int,
    pub start_address: bfd_vma,
    pub outsymbols: *mut *mut bfd_symbol,
    pub symcount: libc::c_uint,
    pub dynsymcount: libc::c_uint,
    pub arch_info: *const bfd_arch_info,
    pub size: ufile_ptr,
    pub arelt_data: *mut libc::c_void,
    pub my_archive: *mut bfd,
    pub archive_next: *mut bfd,
    pub archive_head: *mut bfd,
    pub nested_archives: *mut bfd,
    pub link: C2RustUnnamed_1,
    pub tdata: C2RustUnnamed_0,
    pub usrdata: *mut libc::c_void,
    pub memory: *mut libc::c_void,
    pub build_id: *const bfd_build_id,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_build_id {
    pub size: bfd_size_type,
    pub data: [bfd_byte; 1],
}
pub type bfd_byte = libc::c_uchar;
pub type bfd_size_type = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub aout_data: *mut aout_data_struct,
    pub aout_ar_data: *mut artdata,
    pub coff_obj_data: *mut coff_tdata,
    pub pe_obj_data: *mut pe_tdata,
    pub xcoff_obj_data: *mut xcoff_tdata,
    pub ecoff_obj_data: *mut ecoff_tdata,
    pub srec_data: *mut srec_data_struct,
    pub verilog_data: *mut verilog_data_struct,
    pub ihex_data: *mut ihex_data_struct,
    pub tekhex_data: *mut tekhex_data_struct,
    pub elf_obj_data: *mut elf_obj_tdata,
    pub mmo_data: *mut mmo_data_struct,
    pub sun_core_data: *mut sun_core_struct,
    pub sco5_core_data: *mut sco5_core_struct,
    pub trad_core_data: *mut trad_core_struct,
    pub som_data: *mut som_data_struct,
    pub hpux_core_data: *mut hpux_core_struct,
    pub hppabsd_core_data: *mut hppabsd_core_struct,
    pub sgi_core_data: *mut sgi_core_struct,
    pub lynx_core_data: *mut lynx_core_struct,
    pub osf_core_data: *mut osf_core_struct,
    pub cisco_core_data: *mut cisco_core_struct,
    pub versados_data: *mut versados_data_struct,
    pub netbsd_core_data: *mut netbsd_core_struct,
    pub mach_o_data: *mut mach_o_data_struct,
    pub mach_o_fat_data: *mut mach_o_fat_data_struct,
    pub plugin_data: *mut plugin_data_struct,
    pub pef_data: *mut bfd_pef_data_struct,
    pub pef_xlib_data: *mut bfd_pef_xlib_data_struct,
    pub sym_data: *mut bfd_sym_data_struct,
    pub any: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub next: *mut bfd,
    pub hash: *mut bfd_link_hash_table,
}
pub type ufile_ptr = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_arch_info {
    pub bits_per_word: libc::c_int,
    pub bits_per_address: libc::c_int,
    pub bits_per_byte: libc::c_int,
    pub arch: bfd_architecture,
    pub mach: libc::c_ulong,
    pub arch_name: *const libc::c_char,
    pub printable_name: *const libc::c_char,
    pub section_align_power: libc::c_uint,
    pub the_default: bool,
    pub compatible: Option::<
        unsafe extern "C" fn(
            *const bfd_arch_info,
            *const bfd_arch_info,
        ) -> *const bfd_arch_info,
    >,
    pub scan: Option::<
        unsafe extern "C" fn(*const bfd_arch_info, *const libc::c_char) -> bool,
    >,
    pub fill: Option::<
        unsafe extern "C" fn(bfd_size_type, bool, bool) -> *mut libc::c_void,
    >,
    pub next: *const bfd_arch_info,
    pub max_reloc_offset_into_insn: libc::c_int,
}
pub type bfd_architecture = libc::c_uint;
pub const bfd_arch_last: bfd_architecture = 88;
pub const bfd_arch_csky: bfd_architecture = 87;
pub const bfd_arch_nfp: bfd_architecture = 86;
pub const bfd_arch_pru: bfd_architecture = 85;
pub const bfd_arch_wasm32: bfd_architecture = 84;
pub const bfd_arch_visium: bfd_architecture = 83;
pub const bfd_arch_nios2: bfd_architecture = 82;
pub const bfd_arch_aarch64: bfd_architecture = 81;
pub const bfd_arch_tilegx: bfd_architecture = 80;
pub const bfd_arch_tilepro: bfd_architecture = 79;
pub const bfd_arch_microblaze: bfd_architecture = 78;
pub const bfd_arch_lm32: bfd_architecture = 77;
pub const bfd_arch_z80: bfd_architecture = 76;
pub const bfd_arch_xtensa: bfd_architecture = 75;
pub const bfd_arch_xgate: bfd_architecture = 74;
pub const bfd_arch_xc16x: bfd_architecture = 73;
pub const bfd_arch_msp430: bfd_architecture = 72;
pub const bfd_arch_xstormy16: bfd_architecture = 71;
pub const bfd_arch_mmix: bfd_architecture = 70;
pub const bfd_arch_score: bfd_architecture = 69;
pub const bfd_arch_s390: bfd_architecture = 68;
pub const bfd_arch_rx: bfd_architecture = 67;
pub const bfd_arch_rl78: bfd_architecture = 66;
pub const bfd_arch_riscv: bfd_architecture = 65;
pub const bfd_arch_cris: bfd_architecture = 64;
pub const bfd_arch_crx: bfd_architecture = 63;
pub const bfd_arch_cr16: bfd_architecture = 62;
pub const bfd_arch_bfin: bfd_architecture = 61;
pub const bfd_arch_avr: bfd_architecture = 60;
pub const bfd_arch_pj: bfd_architecture = 59;
pub const bfd_arch_mt: bfd_architecture = 58;
pub const bfd_arch_epiphany: bfd_architecture = 57;
pub const bfd_arch_bpf: bfd_architecture = 56;
pub const bfd_arch_iq2000: bfd_architecture = 55;
pub const bfd_arch_ip2k: bfd_architecture = 54;
pub const bfd_arch_ia64: bfd_architecture = 53;
pub const bfd_arch_metag: bfd_architecture = 52;
pub const bfd_arch_mep: bfd_architecture = 51;
pub const bfd_arch_mcore: bfd_architecture = 50;
pub const bfd_arch_ft32: bfd_architecture = 49;
pub const bfd_arch_moxie: bfd_architecture = 48;
pub const bfd_arch_frv: bfd_architecture = 47;
pub const bfd_arch_fr30: bfd_architecture = 46;
pub const bfd_arch_mn10300: bfd_architecture = 45;
pub const bfd_arch_mn10200: bfd_architecture = 44;
pub const bfd_arch_m32r: bfd_architecture = 43;
pub const bfd_arch_m32c: bfd_architecture = 42;
pub const bfd_arch_arc: bfd_architecture = 41;
pub const bfd_arch_v850_rh850: bfd_architecture = 40;
pub const bfd_arch_v850: bfd_architecture = 39;
pub const bfd_arch_tic6x: bfd_architecture = 38;
pub const bfd_arch_tic54x: bfd_architecture = 37;
pub const bfd_arch_tic4x: bfd_architecture = 36;
pub const bfd_arch_tic30: bfd_architecture = 35;
pub const bfd_arch_ns32k: bfd_architecture = 34;
pub const bfd_arch_nds32: bfd_architecture = 33;
pub const bfd_arch_arm: bfd_architecture = 32;
pub const bfd_arch_alpha: bfd_architecture = 31;
pub const bfd_arch_sh: bfd_architecture = 30;
pub const bfd_arch_z8k: bfd_architecture = 29;
pub const bfd_arch_s12z: bfd_architecture = 28;
pub const bfd_arch_m9s12xg: bfd_architecture = 27;
pub const bfd_arch_m9s12x: bfd_architecture = 26;
pub const bfd_arch_m68hc12: bfd_architecture = 25;
pub const bfd_arch_m68hc11: bfd_architecture = 24;
pub const bfd_arch_dlx: bfd_architecture = 23;
pub const bfd_arch_d30v: bfd_architecture = 22;
pub const bfd_arch_d10v: bfd_architecture = 21;
pub const bfd_arch_hppa: bfd_architecture = 20;
pub const bfd_arch_rs6000: bfd_architecture = 19;
pub const bfd_arch_powerpc: bfd_architecture = 18;
pub const bfd_arch_pdp11: bfd_architecture = 17;
pub const bfd_arch_h8300: bfd_architecture = 16;
pub const bfd_arch_pyramid: bfd_architecture = 15;
pub const bfd_arch_m98k: bfd_architecture = 14;
pub const bfd_arch_convex: bfd_architecture = 13;
pub const bfd_arch_romp: bfd_architecture = 12;
pub const bfd_arch_iamcu: bfd_architecture = 11;
pub const bfd_arch_k1om: bfd_architecture = 10;
pub const bfd_arch_l1om: bfd_architecture = 9;
pub const bfd_arch_i386: bfd_architecture = 8;
pub const bfd_arch_mips: bfd_architecture = 7;
pub const bfd_arch_spu: bfd_architecture = 6;
pub const bfd_arch_sparc: bfd_architecture = 5;
pub const bfd_arch_or1k: bfd_architecture = 4;
pub const bfd_arch_vax: bfd_architecture = 3;
pub const bfd_arch_m68k: bfd_architecture = 2;
pub const bfd_arch_obscure: bfd_architecture = 1;
pub const bfd_arch_unknown: bfd_architecture = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_symbol {
    pub the_bfd: *mut bfd,
    pub name: *const libc::c_char,
    pub value: symvalue,
    pub flags: flagword,
    pub section: *mut bfd_section,
    pub udata: C2RustUnnamed_2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
    pub p: *mut libc::c_void,
    pub i: bfd_vma,
}
pub type bfd_vma = libc::c_ulong;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_section {
    pub name: *const libc::c_char,
    pub id: libc::c_uint,
    pub section_id: libc::c_uint,
    pub index: libc::c_uint,
    pub next: *mut bfd_section,
    pub prev: *mut bfd_section,
    pub flags: flagword,
    #[bitfield(name = "user_set_vma", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "linker_mark", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "linker_has_input", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "gc_mark", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "compress_status", ty = "libc::c_uint", bits = "4..=5")]
    #[bitfield(name = "segment_mark", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "sec_info_type", ty = "libc::c_uint", bits = "7..=9")]
    #[bitfield(name = "use_rela_p", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "sec_flg0", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "sec_flg1", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "sec_flg2", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "sec_flg3", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "sec_flg4", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "sec_flg5", ty = "libc::c_uint", bits = "16..=16")]
    pub user_set_vma_linker_mark_linker_has_input_gc_mark_compress_status_segment_mark_sec_info_type_use_rela_p_sec_flg0_sec_flg1_sec_flg2_sec_flg3_sec_flg4_sec_flg5: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub vma: bfd_vma,
    pub lma: bfd_vma,
    pub size: bfd_size_type,
    pub rawsize: bfd_size_type,
    pub compressed_size: bfd_size_type,
    pub relax: *mut relax_table,
    pub relax_count: libc::c_int,
    pub output_offset: bfd_vma,
    pub output_section: *mut bfd_section,
    pub alignment_power: libc::c_uint,
    pub relocation: *mut reloc_cache_entry,
    pub orelocation: *mut *mut reloc_cache_entry,
    pub reloc_count: libc::c_uint,
    pub filepos: file_ptr,
    pub rel_filepos: file_ptr,
    pub line_filepos: file_ptr,
    pub userdata: *mut libc::c_void,
    pub contents: *mut libc::c_uchar,
    pub lineno: *mut alent,
    pub lineno_count: libc::c_uint,
    pub entsize: libc::c_uint,
    pub kept_section: *mut bfd_section,
    pub moving_line_filepos: file_ptr,
    pub target_index: libc::c_int,
    pub used_by_bfd: *mut libc::c_void,
    pub constructor_chain: *mut relent_chain,
    pub owner: *mut bfd,
    pub symbol: *mut bfd_symbol,
    pub symbol_ptr_ptr: *mut *mut bfd_symbol,
    pub map_head: C2RustUnnamed_3,
    pub map_tail: C2RustUnnamed_3,
    pub already_assigned: *mut bfd_section,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub link_order: *mut bfd_link_order,
    pub s: *mut bfd_section,
    pub linked_to_symbol_name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct relent_chain {
    pub relent: arelent,
    pub next: *mut relent_chain,
}
pub type arelent = reloc_cache_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct reloc_cache_entry {
    pub sym_ptr_ptr: *mut *mut bfd_symbol,
    pub address: bfd_size_type,
    pub addend: bfd_vma,
    pub howto: *const reloc_howto_type,
}
pub type reloc_howto_type = reloc_howto_struct;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct reloc_howto_struct {
    pub type_0: libc::c_uint,
    #[bitfield(name = "size", ty = "libc::c_uint", bits = "0..=2")]
    #[bitfield(name = "bitsize", ty = "libc::c_uint", bits = "3..=9")]
    #[bitfield(name = "rightshift", ty = "libc::c_uint", bits = "10..=15")]
    #[bitfield(name = "bitpos", ty = "libc::c_uint", bits = "16..=21")]
    #[bitfield(name = "complain_on_overflow", ty = "complain_overflow", bits = "22..=23")]
    #[bitfield(name = "negate", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "pc_relative", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "partial_inplace", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "pcrel_offset", ty = "libc::c_uint", bits = "27..=27")]
    pub size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [u8; 4],
    pub src_mask: bfd_vma,
    pub dst_mask: bfd_vma,
    pub special_function: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut arelent,
            *mut bfd_symbol,
            *mut libc::c_void,
            *mut asection,
            *mut bfd,
            *mut *mut libc::c_char,
        ) -> bfd_reloc_status_type,
    >,
    pub name: *const libc::c_char,
}
pub type asection = bfd_section;
pub type bfd_reloc_status_type = bfd_reloc_status;
pub type bfd_reloc_status = libc::c_uint;
pub const bfd_reloc_dangerous: bfd_reloc_status = 9;
pub const bfd_reloc_undefined: bfd_reloc_status = 8;
pub const bfd_reloc_other: bfd_reloc_status = 7;
pub const bfd_reloc_notsupported: bfd_reloc_status = 6;
pub const bfd_reloc_continue: bfd_reloc_status = 5;
pub const bfd_reloc_outofrange: bfd_reloc_status = 4;
pub const bfd_reloc_overflow: bfd_reloc_status = 3;
pub const bfd_reloc_ok: bfd_reloc_status = 2;
pub type complain_overflow = libc::c_uint;
pub const complain_overflow_unsigned: complain_overflow = 3;
pub const complain_overflow_signed: complain_overflow = 2;
pub const complain_overflow_bitfield: complain_overflow = 1;
pub const complain_overflow_dont: complain_overflow = 0;
pub type file_ptr = libc::c_long;
pub type alent = lineno_cache_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lineno_cache_entry {
    pub line_number: libc::c_uint,
    pub u: C2RustUnnamed_4,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub sym: *mut bfd_symbol,
    pub offset: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct relax_table {
    pub addr: bfd_vma,
    pub size: libc::c_int,
}
pub type flagword = libc::c_uint;
pub type symvalue = libc::c_ulong;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_hash_table {
    pub table: *mut *mut bfd_hash_entry,
    pub newfunc: Option::<
        unsafe extern "C" fn(
            *mut bfd_hash_entry,
            *mut bfd_hash_table,
            *const libc::c_char,
        ) -> *mut bfd_hash_entry,
    >,
    pub memory: *mut libc::c_void,
    pub size: libc::c_uint,
    pub count: libc::c_uint,
    pub entsize: libc::c_uint,
    #[bitfield(name = "frozen", ty = "libc::c_uint", bits = "0..=0")]
    pub frozen: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_hash_entry {
    pub next: *mut bfd_hash_entry,
    pub string: *const libc::c_char,
    pub hash: libc::c_ulong,
}
pub type bfd_plugin_format = libc::c_uint;
pub const bfd_plugin_no: bfd_plugin_format = 2;
pub const bfd_plugin_yes: bfd_plugin_format = 1;
pub const bfd_plugin_unknown: bfd_plugin_format = 0;
pub type bfd_direction = libc::c_uint;
pub const both_direction: bfd_direction = 3;
pub const write_direction: bfd_direction = 2;
pub const read_direction: bfd_direction = 1;
pub const no_direction: bfd_direction = 0;
pub type bfd_format = libc::c_uint;
pub const bfd_type_end: bfd_format = 4;
pub const bfd_core: bfd_format = 3;
pub const bfd_archive: bfd_format = 2;
pub const bfd_object: bfd_format = 1;
pub const bfd_unknown: bfd_format = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_target {
    pub name: *const libc::c_char,
    pub flavour: bfd_flavour,
    pub byteorder: bfd_endian,
    pub header_byteorder: bfd_endian,
    pub object_flags: flagword,
    pub section_flags: flagword,
    pub symbol_leading_char: libc::c_char,
    pub ar_pad_char: libc::c_char,
    pub ar_max_namelen: libc::c_uchar,
    pub match_priority: libc::c_uchar,
    pub keep_unused_section_symbols: bool,
    pub bfd_getx64: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t>,
    pub bfd_getx_signed_64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
    >,
    pub bfd_putx64: Option::<
        unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
    >,
    pub bfd_getx32: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_getx_signed_32: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_putx32: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_getx16: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_getx_signed_16: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_putx16: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_h_getx64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
    >,
    pub bfd_h_getx_signed_64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
    >,
    pub bfd_h_putx64: Option::<
        unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
    >,
    pub bfd_h_getx32: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_h_getx_signed_32: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_h_putx32: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_h_getx16: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_h_getx_signed_16: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_h_putx16: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub _bfd_check_format: [Option::<unsafe extern "C" fn(*mut bfd) -> bfd_cleanup>; 4],
    pub _bfd_set_format: [Option::<unsafe extern "C" fn(*mut bfd) -> bool>; 4],
    pub _bfd_write_contents: [Option::<unsafe extern "C" fn(*mut bfd) -> bool>; 4],
    pub _close_and_cleanup: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_free_cached_info: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _new_section_hook: Option::<unsafe extern "C" fn(*mut bfd, sec_ptr) -> bool>,
    pub _bfd_get_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut libc::c_void,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_get_section_contents_in_window: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut bfd_window,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_copy_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _bfd_merge_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_init_private_section_data: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut bfd,
            sec_ptr,
            *mut bfd_link_info,
        ) -> bool,
    >,
    pub _bfd_copy_private_section_data: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr, *mut bfd, sec_ptr) -> bool,
    >,
    pub _bfd_copy_private_symbol_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol, *mut bfd, *mut asymbol) -> bool,
    >,
    pub _bfd_copy_private_header_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _bfd_set_private_flags: Option::<
        unsafe extern "C" fn(*mut bfd, flagword) -> bool,
    >,
    pub _bfd_print_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
    >,
    pub _core_file_failing_command: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
    >,
    pub _core_file_failing_signal: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_int,
    >,
    pub _core_file_matches_executable_p: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _core_file_pid: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub _bfd_slurp_armap: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_slurp_extended_name_table: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_construct_extended_name_table: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut libc::c_char,
            *mut bfd_size_type,
            *mut *const libc::c_char,
        ) -> bool,
    >,
    pub _bfd_truncate_arname: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char, *mut libc::c_char) -> (),
    >,
    pub write_armap: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_uint,
            *mut orl,
            libc::c_uint,
            libc::c_int,
        ) -> bool,
    >,
    pub _bfd_read_ar_hdr_fn: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
    >,
    pub _bfd_write_ar_hdr_fn: Option::<unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool>,
    pub openr_next_archived_file: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
    >,
    pub _bfd_get_elt_at_index: Option::<
        unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
    >,
    pub _bfd_stat_arch_elt: Option::<
        unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
    >,
    pub _bfd_update_armap_timestamp: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_get_symtab_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_symtab: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut bfd_symbol) -> libc::c_long,
    >,
    pub _bfd_make_empty_symbol: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut bfd_symbol,
    >,
    pub _bfd_print_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            *mut bfd_symbol,
            bfd_print_symbol_type,
        ) -> (),
    >,
    pub _bfd_get_symbol_info: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_symbol, *mut symbol_info) -> (),
    >,
    pub _bfd_get_symbol_version_string: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_symbol,
            bool,
            *mut bool,
        ) -> *const libc::c_char,
    >,
    pub _bfd_is_local_label_name: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
    >,
    pub _bfd_is_target_special_symbol: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
    >,
    pub _get_lineno: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_symbol) -> *mut alent,
    >,
    pub _bfd_find_nearest_line: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut bfd_symbol,
            *mut bfd_section,
            bfd_vma,
            *mut *const libc::c_char,
            *mut *const libc::c_char,
            *mut libc::c_uint,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_find_line: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut bfd_symbol,
            *mut bfd_symbol,
            *mut *const libc::c_char,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_find_inliner_info: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *const libc::c_char,
            *mut *const libc::c_char,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_make_debug_symbol: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void, libc::c_ulong) -> *mut asymbol,
    >,
    pub _read_minisymbols: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bool,
            *mut *mut libc::c_void,
            *mut libc::c_uint,
        ) -> libc::c_long,
    >,
    pub _minisymbol_to_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bool,
            *const libc::c_void,
            *mut asymbol,
        ) -> *mut asymbol,
    >,
    pub _get_reloc_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
    >,
    pub _bfd_canonicalize_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut *mut arelent,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub _bfd_set_reloc: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr, *mut *mut arelent, libc::c_uint) -> (),
    >,
    pub reloc_type_lookup: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bfd_reloc_code_real_type,
        ) -> *const reloc_howto_type,
    >,
    pub reloc_name_lookup: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> *const reloc_howto_type,
    >,
    pub _bfd_set_arch_mach: Option::<
        unsafe extern "C" fn(*mut bfd, bfd_architecture, libc::c_ulong) -> bool,
    >,
    pub _bfd_set_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *const libc::c_void,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_sizeof_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
    >,
    pub _bfd_get_relocated_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_order,
            *mut bfd_byte,
            bool,
            *mut *mut bfd_symbol,
        ) -> *mut bfd_byte,
    >,
    pub _bfd_relax_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_section,
            *mut bfd_link_info,
            *mut bool,
        ) -> bool,
    >,
    pub _bfd_link_hash_table_create: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
    >,
    pub _bfd_link_add_symbols: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_link_just_syms: Option::<
        unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
    >,
    pub _bfd_copy_link_hash_symbol_type: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_hash_entry,
            *mut bfd_link_hash_entry,
        ) -> (),
    >,
    pub _bfd_final_link: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_link_split_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
    >,
    pub _bfd_link_check_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_gc_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_lookup_section_flags: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut flag_info, *mut asection) -> bool,
    >,
    pub _bfd_merge_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_is_group_section: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
    >,
    pub _bfd_group_name: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_section) -> *const libc::c_char,
    >,
    pub _bfd_discard_group: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
    >,
    pub _section_already_linked: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_define_common_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
        ) -> bool,
    >,
    pub _bfd_link_hide_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
        ) -> (),
    >,
    pub _bfd_define_start_stop: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut asection,
        ) -> *mut bfd_link_hash_entry,
    >,
    pub _bfd_get_dynamic_symtab_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_dynamic_symtab: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut bfd_symbol) -> libc::c_long,
    >,
    pub _bfd_get_synthetic_symtab: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_long,
            *mut *mut bfd_symbol,
            libc::c_long,
            *mut *mut bfd_symbol,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub _bfd_get_dynamic_reloc_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_dynamic_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut arelent,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub alternative_target: *const bfd_target,
    pub backend_data: *const libc::c_void,
}
pub type sec_ptr = *mut bfd_section;
pub type bfd_reloc_code_real_type = bfd_reloc_code_real;
pub type bfd_reloc_code_real = libc::c_uint;
pub const BFD_RELOC_UNUSED: bfd_reloc_code_real = 2383;
pub const BFD_RELOC_S12Z_OPR: bfd_reloc_code_real = 2382;
pub const BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4: bfd_reloc_code_real = 2381;
pub const BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4: bfd_reloc_code_real = 2380;
pub const BFD_RELOC_CKCORE_IRELATIVE: bfd_reloc_code_real = 2379;
pub const BFD_RELOC_CKCORE_CALLGRAPH: bfd_reloc_code_real = 2378;
pub const BFD_RELOC_CKCORE_NOJSRI: bfd_reloc_code_real = 2377;
pub const BFD_RELOC_CKCORE_PCREL_FLRW_IMM8BY4: bfd_reloc_code_real = 2376;
pub const BFD_RELOC_CKCORE_TLS_TPOFF32: bfd_reloc_code_real = 2375;
pub const BFD_RELOC_CKCORE_TLS_DTPOFF32: bfd_reloc_code_real = 2374;
pub const BFD_RELOC_CKCORE_TLS_DTPMOD32: bfd_reloc_code_real = 2373;
pub const BFD_RELOC_CKCORE_TLS_LDO32: bfd_reloc_code_real = 2372;
pub const BFD_RELOC_CKCORE_TLS_LDM32: bfd_reloc_code_real = 2371;
pub const BFD_RELOC_CKCORE_TLS_GD32: bfd_reloc_code_real = 2370;
pub const BFD_RELOC_CKCORE_TLS_IE32: bfd_reloc_code_real = 2369;
pub const BFD_RELOC_CKCORE_TLS_LE32: bfd_reloc_code_real = 2368;
pub const BFD_RELOC_CKCORE_PCREL_IMM7BY4: bfd_reloc_code_real = 2367;
pub const BFD_RELOC_CKCORE_PLT_IMM18BY4: bfd_reloc_code_real = 2366;
pub const BFD_RELOC_CKCORE_GOT_IMM18BY4: bfd_reloc_code_real = 2365;
pub const BFD_RELOC_CKCORE_GOTOFF_IMM18: bfd_reloc_code_real = 2364;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18BY4: bfd_reloc_code_real = 2363;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18BY2: bfd_reloc_code_real = 2362;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18: bfd_reloc_code_real = 2361;
pub const BFD_RELOC_CKCORE_PCREL_IMM18BY2: bfd_reloc_code_real = 2360;
pub const BFD_RELOC_CKCORE_DOFFSET_LO16: bfd_reloc_code_real = 2359;
pub const BFD_RELOC_CKCORE_TOFFSET_LO16: bfd_reloc_code_real = 2358;
pub const BFD_RELOC_CKCORE_PCREL_JSR_IMM26BY2: bfd_reloc_code_real = 2357;
pub const BFD_RELOC_CKCORE_ADDRPLT_LO16: bfd_reloc_code_real = 2356;
pub const BFD_RELOC_CKCORE_ADDRPLT_HI16: bfd_reloc_code_real = 2355;
pub const BFD_RELOC_CKCORE_ADDRGOT_LO16: bfd_reloc_code_real = 2354;
pub const BFD_RELOC_CKCORE_ADDRGOT_HI16: bfd_reloc_code_real = 2353;
pub const BFD_RELOC_CKCORE_PLT_LO16: bfd_reloc_code_real = 2352;
pub const BFD_RELOC_CKCORE_PLT_HI16: bfd_reloc_code_real = 2351;
pub const BFD_RELOC_CKCORE_PLT12: bfd_reloc_code_real = 2350;
pub const BFD_RELOC_CKCORE_GOT_LO16: bfd_reloc_code_real = 2349;
pub const BFD_RELOC_CKCORE_GOT_HI16: bfd_reloc_code_real = 2348;
pub const BFD_RELOC_CKCORE_GOT12: bfd_reloc_code_real = 2347;
pub const BFD_RELOC_CKCORE_GOTOFF_LO16: bfd_reloc_code_real = 2346;
pub const BFD_RELOC_CKCORE_GOTOFF_HI16: bfd_reloc_code_real = 2345;
pub const BFD_RELOC_CKCORE_GOTPC_LO16: bfd_reloc_code_real = 2344;
pub const BFD_RELOC_CKCORE_GOTPC_HI16: bfd_reloc_code_real = 2343;
pub const BFD_RELOC_CKCORE_ADDR_LO16: bfd_reloc_code_real = 2342;
pub const BFD_RELOC_CKCORE_ADDR_HI16: bfd_reloc_code_real = 2341;
pub const BFD_RELOC_CKCORE_PCREL_IMM10BY4: bfd_reloc_code_real = 2340;
pub const BFD_RELOC_CKCORE_PCREL_IMM10BY2: bfd_reloc_code_real = 2339;
pub const BFD_RELOC_CKCORE_PCREL_IMM16BY4: bfd_reloc_code_real = 2338;
pub const BFD_RELOC_CKCORE_PCREL_IMM16BY2: bfd_reloc_code_real = 2337;
pub const BFD_RELOC_CKCORE_PCREL_IMM26BY2: bfd_reloc_code_real = 2336;
pub const BFD_RELOC_CKCORE_ADDRPLT: bfd_reloc_code_real = 2335;
pub const BFD_RELOC_CKCORE_ADDRGOT: bfd_reloc_code_real = 2334;
pub const BFD_RELOC_CKCORE_PLT32: bfd_reloc_code_real = 2333;
pub const BFD_RELOC_CKCORE_GOT32: bfd_reloc_code_real = 2332;
pub const BFD_RELOC_CKCORE_GOTPC: bfd_reloc_code_real = 2331;
pub const BFD_RELOC_CKCORE_GOTOFF: bfd_reloc_code_real = 2330;
pub const BFD_RELOC_CKCORE_JUMP_SLOT: bfd_reloc_code_real = 2329;
pub const BFD_RELOC_CKCORE_GLOB_DAT: bfd_reloc_code_real = 2328;
pub const BFD_RELOC_CKCORE_COPY: bfd_reloc_code_real = 2327;
pub const BFD_RELOC_CKCORE_RELATIVE: bfd_reloc_code_real = 2326;
pub const BFD_RELOC_CKCORE_GNU_VTENTRY: bfd_reloc_code_real = 2325;
pub const BFD_RELOC_CKCORE_GNU_VTINHERIT: bfd_reloc_code_real = 2324;
pub const BFD_RELOC_CKCORE_PCREL_JSR_IMM11BY2: bfd_reloc_code_real = 2323;
pub const BFD_RELOC_CKCORE_PCREL32: bfd_reloc_code_real = 2322;
pub const BFD_RELOC_CKCORE_PCREL_IMM4BY2: bfd_reloc_code_real = 2321;
pub const BFD_RELOC_CKCORE_PCREL_IMM11BY2: bfd_reloc_code_real = 2320;
pub const BFD_RELOC_CKCORE_PCREL_IMM8BY4: bfd_reloc_code_real = 2319;
pub const BFD_RELOC_CKCORE_ADDR32: bfd_reloc_code_real = 2318;
pub const BFD_RELOC_CKCORE_NONE: bfd_reloc_code_real = 2317;
pub const BFD_RELOC_WASM32_PLT_SIG: bfd_reloc_code_real = 2316;
pub const BFD_RELOC_WASM32_INDEX: bfd_reloc_code_real = 2315;
pub const BFD_RELOC_WASM32_CODE_POINTER: bfd_reloc_code_real = 2314;
pub const BFD_RELOC_WASM32_COPY: bfd_reloc_code_real = 2313;
pub const BFD_RELOC_WASM32_ABS32_CODE: bfd_reloc_code_real = 2312;
pub const BFD_RELOC_WASM32_PLT_INDEX: bfd_reloc_code_real = 2311;
pub const BFD_RELOC_WASM32_LEB128_PLT: bfd_reloc_code_real = 2310;
pub const BFD_RELOC_WASM32_LEB128_GOT_CODE: bfd_reloc_code_real = 2309;
pub const BFD_RELOC_WASM32_LEB128_GOT: bfd_reloc_code_real = 2308;
pub const BFD_RELOC_WASM32_LEB128: bfd_reloc_code_real = 2307;
pub const BFD_RELOC_VISIUM_IM16_PCREL: bfd_reloc_code_real = 2306;
pub const BFD_RELOC_VISIUM_LO16_PCREL: bfd_reloc_code_real = 2305;
pub const BFD_RELOC_VISIUM_HI16_PCREL: bfd_reloc_code_real = 2304;
pub const BFD_RELOC_VISIUM_REL16: bfd_reloc_code_real = 2303;
pub const BFD_RELOC_VISIUM_IM16: bfd_reloc_code_real = 2302;
pub const BFD_RELOC_VISIUM_LO16: bfd_reloc_code_real = 2301;
pub const BFD_RELOC_VISIUM_HI16: bfd_reloc_code_real = 2300;
pub const BFD_RELOC_EPIPHANY_IMM8: bfd_reloc_code_real = 2299;
pub const BFD_RELOC_EPIPHANY_IMM11: bfd_reloc_code_real = 2298;
pub const BFD_RELOC_EPIPHANY_SIMM11: bfd_reloc_code_real = 2297;
pub const BFD_RELOC_EPIPHANY_LOW: bfd_reloc_code_real = 2296;
pub const BFD_RELOC_EPIPHANY_HIGH: bfd_reloc_code_real = 2295;
pub const BFD_RELOC_EPIPHANY_SIMM24: bfd_reloc_code_real = 2294;
pub const BFD_RELOC_EPIPHANY_SIMM8: bfd_reloc_code_real = 2293;
pub const BFD_RELOC_BPF_DISP32: bfd_reloc_code_real = 2292;
pub const BFD_RELOC_BPF_DISP16: bfd_reloc_code_real = 2291;
pub const BFD_RELOC_BPF_16: bfd_reloc_code_real = 2290;
pub const BFD_RELOC_BPF_32: bfd_reloc_code_real = 2289;
pub const BFD_RELOC_BPF_64: bfd_reloc_code_real = 2288;
pub const BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD: bfd_reloc_code_real = 2287;
pub const BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD: bfd_reloc_code_real = 2286;
pub const BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD: bfd_reloc_code_real = 2285;
pub const BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD: bfd_reloc_code_real = 2284;
pub const BFD_RELOC_TILEGX_TLS_IE_LOAD: bfd_reloc_code_real = 2283;
pub const BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD: bfd_reloc_code_real = 2282;
pub const BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD: bfd_reloc_code_real = 2281;
pub const BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD: bfd_reloc_code_real = 2280;
pub const BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD: bfd_reloc_code_real = 2279;
pub const BFD_RELOC_TILEGX_TLS_GD_CALL: bfd_reloc_code_real = 2278;
pub const BFD_RELOC_TILEGX_TLS_TPOFF32: bfd_reloc_code_real = 2277;
pub const BFD_RELOC_TILEGX_TLS_DTPOFF32: bfd_reloc_code_real = 2276;
pub const BFD_RELOC_TILEGX_TLS_DTPMOD32: bfd_reloc_code_real = 2275;
pub const BFD_RELOC_TILEGX_TLS_TPOFF64: bfd_reloc_code_real = 2274;
pub const BFD_RELOC_TILEGX_TLS_DTPOFF64: bfd_reloc_code_real = 2273;
pub const BFD_RELOC_TILEGX_TLS_DTPMOD64: bfd_reloc_code_real = 2272;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE: bfd_reloc_code_real = 2271;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE: bfd_reloc_code_real = 2270;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE: bfd_reloc_code_real = 2269;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE: bfd_reloc_code_real = 2268;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL: bfd_reloc_code_real = 2267;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL: bfd_reloc_code_real = 2266;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL: bfd_reloc_code_real = 2265;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL: bfd_reloc_code_real = 2264;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL: bfd_reloc_code_real = 2263;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL: bfd_reloc_code_real = 2262;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE: bfd_reloc_code_real = 2261;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE: bfd_reloc_code_real = 2260;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD: bfd_reloc_code_real = 2259;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD: bfd_reloc_code_real = 2258;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD: bfd_reloc_code_real = 2257;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD: bfd_reloc_code_real = 2256;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE: bfd_reloc_code_real = 2255;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE: bfd_reloc_code_real = 2254;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE: bfd_reloc_code_real = 2253;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE: bfd_reloc_code_real = 2252;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE: bfd_reloc_code_real = 2251;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE: bfd_reloc_code_real = 2250;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD: bfd_reloc_code_real = 2249;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD: bfd_reloc_code_real = 2248;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL: bfd_reloc_code_real = 2247;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL: bfd_reloc_code_real = 2246;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT: bfd_reloc_code_real = 2245;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT: bfd_reloc_code_real = 2244;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT: bfd_reloc_code_real = 2243;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT: bfd_reloc_code_real = 2242;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL: bfd_reloc_code_real = 2241;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL: bfd_reloc_code_real = 2240;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL: bfd_reloc_code_real = 2239;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL: bfd_reloc_code_real = 2238;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL: bfd_reloc_code_real = 2237;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL: bfd_reloc_code_real = 2236;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT: bfd_reloc_code_real = 2235;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT: bfd_reloc_code_real = 2234;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL: bfd_reloc_code_real = 2233;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL: bfd_reloc_code_real = 2232;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL: bfd_reloc_code_real = 2231;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL: bfd_reloc_code_real = 2230;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL: bfd_reloc_code_real = 2229;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL: bfd_reloc_code_real = 2228;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL: bfd_reloc_code_real = 2227;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL: bfd_reloc_code_real = 2226;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL: bfd_reloc_code_real = 2225;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL: bfd_reloc_code_real = 2224;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL: bfd_reloc_code_real = 2223;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL: bfd_reloc_code_real = 2222;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL: bfd_reloc_code_real = 2221;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL: bfd_reloc_code_real = 2220;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST: bfd_reloc_code_real = 2219;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST: bfd_reloc_code_real = 2218;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST: bfd_reloc_code_real = 2217;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST: bfd_reloc_code_real = 2216;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST: bfd_reloc_code_real = 2215;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST: bfd_reloc_code_real = 2214;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3: bfd_reloc_code_real = 2213;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3: bfd_reloc_code_real = 2212;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2: bfd_reloc_code_real = 2211;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2: bfd_reloc_code_real = 2210;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1: bfd_reloc_code_real = 2209;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1: bfd_reloc_code_real = 2208;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0: bfd_reloc_code_real = 2207;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0: bfd_reloc_code_real = 2206;
pub const BFD_RELOC_TILEGX_SHAMT_Y1: bfd_reloc_code_real = 2205;
pub const BFD_RELOC_TILEGX_SHAMT_Y0: bfd_reloc_code_real = 2204;
pub const BFD_RELOC_TILEGX_SHAMT_X1: bfd_reloc_code_real = 2203;
pub const BFD_RELOC_TILEGX_SHAMT_X0: bfd_reloc_code_real = 2202;
pub const BFD_RELOC_TILEGX_MMEND_X0: bfd_reloc_code_real = 2201;
pub const BFD_RELOC_TILEGX_MMSTART_X0: bfd_reloc_code_real = 2200;
pub const BFD_RELOC_TILEGX_MF_IMM14_X1: bfd_reloc_code_real = 2199;
pub const BFD_RELOC_TILEGX_MT_IMM14_X1: bfd_reloc_code_real = 2198;
pub const BFD_RELOC_TILEGX_DEST_IMM8_X1: bfd_reloc_code_real = 2197;
pub const BFD_RELOC_TILEGX_IMM8_Y1: bfd_reloc_code_real = 2196;
pub const BFD_RELOC_TILEGX_IMM8_X1: bfd_reloc_code_real = 2195;
pub const BFD_RELOC_TILEGX_IMM8_Y0: bfd_reloc_code_real = 2194;
pub const BFD_RELOC_TILEGX_IMM8_X0: bfd_reloc_code_real = 2193;
pub const BFD_RELOC_TILEGX_JUMPOFF_X1_PLT: bfd_reloc_code_real = 2192;
pub const BFD_RELOC_TILEGX_JUMPOFF_X1: bfd_reloc_code_real = 2191;
pub const BFD_RELOC_TILEGX_BROFF_X1: bfd_reloc_code_real = 2190;
pub const BFD_RELOC_TILEGX_RELATIVE: bfd_reloc_code_real = 2189;
pub const BFD_RELOC_TILEGX_JMP_SLOT: bfd_reloc_code_real = 2188;
pub const BFD_RELOC_TILEGX_GLOB_DAT: bfd_reloc_code_real = 2187;
pub const BFD_RELOC_TILEGX_COPY: bfd_reloc_code_real = 2186;
pub const BFD_RELOC_TILEGX_HW2_LAST: bfd_reloc_code_real = 2185;
pub const BFD_RELOC_TILEGX_HW1_LAST: bfd_reloc_code_real = 2184;
pub const BFD_RELOC_TILEGX_HW0_LAST: bfd_reloc_code_real = 2183;
pub const BFD_RELOC_TILEGX_HW3: bfd_reloc_code_real = 2182;
pub const BFD_RELOC_TILEGX_HW2: bfd_reloc_code_real = 2181;
pub const BFD_RELOC_TILEGX_HW1: bfd_reloc_code_real = 2180;
pub const BFD_RELOC_TILEGX_HW0: bfd_reloc_code_real = 2179;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA: bfd_reloc_code_real = 2178;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA: bfd_reloc_code_real = 2177;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI: bfd_reloc_code_real = 2176;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI: bfd_reloc_code_real = 2175;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO: bfd_reloc_code_real = 2174;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO: bfd_reloc_code_real = 2173;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE: bfd_reloc_code_real = 2172;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE: bfd_reloc_code_real = 2171;
pub const BFD_RELOC_TILEPRO_TLS_TPOFF32: bfd_reloc_code_real = 2170;
pub const BFD_RELOC_TILEPRO_TLS_DTPOFF32: bfd_reloc_code_real = 2169;
pub const BFD_RELOC_TILEPRO_TLS_DTPMOD32: bfd_reloc_code_real = 2168;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA: bfd_reloc_code_real = 2167;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA: bfd_reloc_code_real = 2166;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI: bfd_reloc_code_real = 2165;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI: bfd_reloc_code_real = 2164;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO: bfd_reloc_code_real = 2163;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO: bfd_reloc_code_real = 2162;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE: bfd_reloc_code_real = 2161;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE: bfd_reloc_code_real = 2160;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA: bfd_reloc_code_real = 2159;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA: bfd_reloc_code_real = 2158;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI: bfd_reloc_code_real = 2157;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI: bfd_reloc_code_real = 2156;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO: bfd_reloc_code_real = 2155;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO: bfd_reloc_code_real = 2154;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD: bfd_reloc_code_real = 2153;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD: bfd_reloc_code_real = 2152;
pub const BFD_RELOC_TILEPRO_TLS_IE_LOAD: bfd_reloc_code_real = 2151;
pub const BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD: bfd_reloc_code_real = 2150;
pub const BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD: bfd_reloc_code_real = 2149;
pub const BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD: bfd_reloc_code_real = 2148;
pub const BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD: bfd_reloc_code_real = 2147;
pub const BFD_RELOC_TILEPRO_TLS_GD_CALL: bfd_reloc_code_real = 2146;
pub const BFD_RELOC_TILEPRO_SHAMT_Y1: bfd_reloc_code_real = 2145;
pub const BFD_RELOC_TILEPRO_SHAMT_Y0: bfd_reloc_code_real = 2144;
pub const BFD_RELOC_TILEPRO_SHAMT_X1: bfd_reloc_code_real = 2143;
pub const BFD_RELOC_TILEPRO_SHAMT_X0: bfd_reloc_code_real = 2142;
pub const BFD_RELOC_TILEPRO_MMEND_X1: bfd_reloc_code_real = 2141;
pub const BFD_RELOC_TILEPRO_MMSTART_X1: bfd_reloc_code_real = 2140;
pub const BFD_RELOC_TILEPRO_MMEND_X0: bfd_reloc_code_real = 2139;
pub const BFD_RELOC_TILEPRO_MMSTART_X0: bfd_reloc_code_real = 2138;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA: bfd_reloc_code_real = 2137;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA: bfd_reloc_code_real = 2136;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI: bfd_reloc_code_real = 2135;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI: bfd_reloc_code_real = 2134;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO: bfd_reloc_code_real = 2133;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO: bfd_reloc_code_real = 2132;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT: bfd_reloc_code_real = 2131;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT: bfd_reloc_code_real = 2130;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL: bfd_reloc_code_real = 2129;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL: bfd_reloc_code_real = 2128;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL: bfd_reloc_code_real = 2127;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL: bfd_reloc_code_real = 2126;
pub const BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL: bfd_reloc_code_real = 2125;
pub const BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL: bfd_reloc_code_real = 2124;
pub const BFD_RELOC_TILEPRO_IMM16_X1_PCREL: bfd_reloc_code_real = 2123;
pub const BFD_RELOC_TILEPRO_IMM16_X0_PCREL: bfd_reloc_code_real = 2122;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HA: bfd_reloc_code_real = 2121;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HA: bfd_reloc_code_real = 2120;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HI: bfd_reloc_code_real = 2119;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HI: bfd_reloc_code_real = 2118;
pub const BFD_RELOC_TILEPRO_IMM16_X1_LO: bfd_reloc_code_real = 2117;
pub const BFD_RELOC_TILEPRO_IMM16_X0_LO: bfd_reloc_code_real = 2116;
pub const BFD_RELOC_TILEPRO_IMM16_X1: bfd_reloc_code_real = 2115;
pub const BFD_RELOC_TILEPRO_IMM16_X0: bfd_reloc_code_real = 2114;
pub const BFD_RELOC_TILEPRO_MF_IMM15_X1: bfd_reloc_code_real = 2113;
pub const BFD_RELOC_TILEPRO_MT_IMM15_X1: bfd_reloc_code_real = 2112;
pub const BFD_RELOC_TILEPRO_DEST_IMM8_X1: bfd_reloc_code_real = 2111;
pub const BFD_RELOC_TILEPRO_IMM8_Y1: bfd_reloc_code_real = 2110;
pub const BFD_RELOC_TILEPRO_IMM8_X1: bfd_reloc_code_real = 2109;
pub const BFD_RELOC_TILEPRO_IMM8_Y0: bfd_reloc_code_real = 2108;
pub const BFD_RELOC_TILEPRO_IMM8_X0: bfd_reloc_code_real = 2107;
pub const BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT: bfd_reloc_code_real = 2106;
pub const BFD_RELOC_TILEPRO_JOFFLONG_X1: bfd_reloc_code_real = 2105;
pub const BFD_RELOC_TILEPRO_BROFF_X1: bfd_reloc_code_real = 2104;
pub const BFD_RELOC_TILEPRO_RELATIVE: bfd_reloc_code_real = 2103;
pub const BFD_RELOC_TILEPRO_JMP_SLOT: bfd_reloc_code_real = 2102;
pub const BFD_RELOC_TILEPRO_GLOB_DAT: bfd_reloc_code_real = 2101;
pub const BFD_RELOC_TILEPRO_COPY: bfd_reloc_code_real = 2100;
pub const BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC: bfd_reloc_code_real = 2099;
pub const BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2098;
pub const BFD_RELOC_AARCH64_LD_GOT_LO12_NC: bfd_reloc_code_real = 2097;
pub const BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12_NC: bfd_reloc_code_real = 2096;
pub const BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12: bfd_reloc_code_real = 2095;
pub const BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC: bfd_reloc_code_real = 2094;
pub const BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12: bfd_reloc_code_real = 2093;
pub const BFD_RELOC_AARCH64_LDST_LO12: bfd_reloc_code_real = 2092;
pub const BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP: bfd_reloc_code_real = 2091;
pub const BFD_RELOC_AARCH64_RELOC_END: bfd_reloc_code_real = 2090;
pub const BFD_RELOC_AARCH64_IRELATIVE: bfd_reloc_code_real = 2089;
pub const BFD_RELOC_AARCH64_TLSDESC: bfd_reloc_code_real = 2088;
pub const BFD_RELOC_AARCH64_TLS_TPREL: bfd_reloc_code_real = 2087;
pub const BFD_RELOC_AARCH64_TLS_DTPREL: bfd_reloc_code_real = 2086;
pub const BFD_RELOC_AARCH64_TLS_DTPMOD: bfd_reloc_code_real = 2085;
pub const BFD_RELOC_AARCH64_RELATIVE: bfd_reloc_code_real = 2084;
pub const BFD_RELOC_AARCH64_JUMP_SLOT: bfd_reloc_code_real = 2083;
pub const BFD_RELOC_AARCH64_GLOB_DAT: bfd_reloc_code_real = 2082;
pub const BFD_RELOC_AARCH64_COPY: bfd_reloc_code_real = 2081;
pub const BFD_RELOC_AARCH64_TLSDESC_CALL: bfd_reloc_code_real = 2080;
pub const BFD_RELOC_AARCH64_TLSDESC_ADD: bfd_reloc_code_real = 2079;
pub const BFD_RELOC_AARCH64_TLSDESC_LDR: bfd_reloc_code_real = 2078;
pub const BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC: bfd_reloc_code_real = 2077;
pub const BFD_RELOC_AARCH64_TLSDESC_OFF_G1: bfd_reloc_code_real = 2076;
pub const BFD_RELOC_AARCH64_TLSDESC_ADD_LO12: bfd_reloc_code_real = 2075;
pub const BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC: bfd_reloc_code_real = 2074;
pub const BFD_RELOC_AARCH64_TLSDESC_LD64_LO12: bfd_reloc_code_real = 2073;
pub const BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21: bfd_reloc_code_real = 2072;
pub const BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21: bfd_reloc_code_real = 2071;
pub const BFD_RELOC_AARCH64_TLSDESC_LD_PREL19: bfd_reloc_code_real = 2070;
pub const BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12_NC: bfd_reloc_code_real = 2069;
pub const BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12: bfd_reloc_code_real = 2068;
pub const BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12_NC: bfd_reloc_code_real = 2067;
pub const BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12: bfd_reloc_code_real = 2066;
pub const BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12_NC: bfd_reloc_code_real = 2065;
pub const BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12: bfd_reloc_code_real = 2064;
pub const BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12_NC: bfd_reloc_code_real = 2063;
pub const BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12: bfd_reloc_code_real = 2062;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC: bfd_reloc_code_real = 2061;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12: bfd_reloc_code_real = 2060;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12: bfd_reloc_code_real = 2059;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC: bfd_reloc_code_real = 2058;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0: bfd_reloc_code_real = 2057;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC: bfd_reloc_code_real = 2056;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1: bfd_reloc_code_real = 2055;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2: bfd_reloc_code_real = 2054;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2: bfd_reloc_code_real = 2053;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC: bfd_reloc_code_real = 2052;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1: bfd_reloc_code_real = 2051;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC: bfd_reloc_code_real = 2050;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0: bfd_reloc_code_real = 2049;
pub const BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC: bfd_reloc_code_real = 2048;
pub const BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12: bfd_reloc_code_real = 2047;
pub const BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC: bfd_reloc_code_real = 2046;
pub const BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12: bfd_reloc_code_real = 2045;
pub const BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC: bfd_reloc_code_real = 2044;
pub const BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12: bfd_reloc_code_real = 2043;
pub const BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC: bfd_reloc_code_real = 2042;
pub const BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12: bfd_reloc_code_real = 2041;
pub const BFD_RELOC_AARCH64_TLSLD_ADR_PREL21: bfd_reloc_code_real = 2040;
pub const BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21: bfd_reloc_code_real = 2039;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC: bfd_reloc_code_real = 2038;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC: bfd_reloc_code_real = 2037;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12: bfd_reloc_code_real = 2036;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12: bfd_reloc_code_real = 2035;
pub const BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1: bfd_reloc_code_real = 2034;
pub const BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC: bfd_reloc_code_real = 2033;
pub const BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19: bfd_reloc_code_real = 2032;
pub const BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2031;
pub const BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2030;
pub const BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21: bfd_reloc_code_real = 2029;
pub const BFD_RELOC_AARCH64_TLSGD_MOVW_G1: bfd_reloc_code_real = 2028;
pub const BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC: bfd_reloc_code_real = 2027;
pub const BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC: bfd_reloc_code_real = 2026;
pub const BFD_RELOC_AARCH64_TLSGD_ADR_PREL21: bfd_reloc_code_real = 2025;
pub const BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21: bfd_reloc_code_real = 2024;
pub const BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15: bfd_reloc_code_real = 2023;
pub const BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14: bfd_reloc_code_real = 2022;
pub const BFD_RELOC_AARCH64_LD64_GOTOFF_LO15: bfd_reloc_code_real = 2021;
pub const BFD_RELOC_AARCH64_MOVW_GOTOFF_G1: bfd_reloc_code_real = 2020;
pub const BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC: bfd_reloc_code_real = 2019;
pub const BFD_RELOC_AARCH64_LD32_GOT_LO12_NC: bfd_reloc_code_real = 2018;
pub const BFD_RELOC_AARCH64_LD64_GOT_LO12_NC: bfd_reloc_code_real = 2017;
pub const BFD_RELOC_AARCH64_ADR_GOT_PAGE: bfd_reloc_code_real = 2016;
pub const BFD_RELOC_AARCH64_GOT_LD_PREL19: bfd_reloc_code_real = 2015;
pub const BFD_RELOC_AARCH64_LDST128_LO12: bfd_reloc_code_real = 2014;
pub const BFD_RELOC_AARCH64_LDST64_LO12: bfd_reloc_code_real = 2013;
pub const BFD_RELOC_AARCH64_LDST32_LO12: bfd_reloc_code_real = 2012;
pub const BFD_RELOC_AARCH64_LDST16_LO12: bfd_reloc_code_real = 2011;
pub const BFD_RELOC_AARCH64_CALL26: bfd_reloc_code_real = 2010;
pub const BFD_RELOC_AARCH64_JUMP26: bfd_reloc_code_real = 2009;
pub const BFD_RELOC_AARCH64_BRANCH19: bfd_reloc_code_real = 2008;
pub const BFD_RELOC_AARCH64_TSTBR14: bfd_reloc_code_real = 2007;
pub const BFD_RELOC_AARCH64_LDST8_LO12: bfd_reloc_code_real = 2006;
pub const BFD_RELOC_AARCH64_ADD_LO12: bfd_reloc_code_real = 2005;
pub const BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL: bfd_reloc_code_real = 2004;
pub const BFD_RELOC_AARCH64_ADR_HI21_PCREL: bfd_reloc_code_real = 2003;
pub const BFD_RELOC_AARCH64_ADR_LO21_PCREL: bfd_reloc_code_real = 2002;
pub const BFD_RELOC_AARCH64_LD_LO19_PCREL: bfd_reloc_code_real = 2001;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G3: bfd_reloc_code_real = 2000;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G2_NC: bfd_reloc_code_real = 1999;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G2: bfd_reloc_code_real = 1998;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G1_NC: bfd_reloc_code_real = 1997;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G1: bfd_reloc_code_real = 1996;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G0_NC: bfd_reloc_code_real = 1995;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G0: bfd_reloc_code_real = 1994;
pub const BFD_RELOC_AARCH64_MOVW_G2_S: bfd_reloc_code_real = 1993;
pub const BFD_RELOC_AARCH64_MOVW_G1_S: bfd_reloc_code_real = 1992;
pub const BFD_RELOC_AARCH64_MOVW_G0_S: bfd_reloc_code_real = 1991;
pub const BFD_RELOC_AARCH64_MOVW_G3: bfd_reloc_code_real = 1990;
pub const BFD_RELOC_AARCH64_MOVW_G2_NC: bfd_reloc_code_real = 1989;
pub const BFD_RELOC_AARCH64_MOVW_G2: bfd_reloc_code_real = 1988;
pub const BFD_RELOC_AARCH64_MOVW_G1_NC: bfd_reloc_code_real = 1987;
pub const BFD_RELOC_AARCH64_MOVW_G1: bfd_reloc_code_real = 1986;
pub const BFD_RELOC_AARCH64_MOVW_G0_NC: bfd_reloc_code_real = 1985;
pub const BFD_RELOC_AARCH64_MOVW_G0: bfd_reloc_code_real = 1984;
pub const BFD_RELOC_AARCH64_16_PCREL: bfd_reloc_code_real = 1983;
pub const BFD_RELOC_AARCH64_32_PCREL: bfd_reloc_code_real = 1982;
pub const BFD_RELOC_AARCH64_64_PCREL: bfd_reloc_code_real = 1981;
pub const BFD_RELOC_AARCH64_16: bfd_reloc_code_real = 1980;
pub const BFD_RELOC_AARCH64_32: bfd_reloc_code_real = 1979;
pub const BFD_RELOC_AARCH64_64: bfd_reloc_code_real = 1978;
pub const BFD_RELOC_AARCH64_NONE: bfd_reloc_code_real = 1977;
pub const BFD_RELOC_AARCH64_NULL: bfd_reloc_code_real = 1976;
pub const BFD_RELOC_AARCH64_RELOC_START: bfd_reloc_code_real = 1975;
pub const BFD_RELOC_MICROBLAZE_64_TEXTREL: bfd_reloc_code_real = 1974;
pub const BFD_RELOC_MICROBLAZE_64_TEXTPCREL: bfd_reloc_code_real = 1973;
pub const BFD_RELOC_MICROBLAZE_64_TLSTPREL: bfd_reloc_code_real = 1972;
pub const BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL: bfd_reloc_code_real = 1971;
pub const BFD_RELOC_MICROBLAZE_64_TLSDTPREL: bfd_reloc_code_real = 1970;
pub const BFD_RELOC_MICROBLAZE_32_TLSDTPREL: bfd_reloc_code_real = 1969;
pub const BFD_RELOC_MICROBLAZE_32_TLSDTPMOD: bfd_reloc_code_real = 1968;
pub const BFD_RELOC_MICROBLAZE_64_TLSLD: bfd_reloc_code_real = 1967;
pub const BFD_RELOC_MICROBLAZE_64_TLSGD: bfd_reloc_code_real = 1966;
pub const BFD_RELOC_MICROBLAZE_64_TLS: bfd_reloc_code_real = 1965;
pub const BFD_RELOC_MICROBLAZE_COPY: bfd_reloc_code_real = 1964;
pub const BFD_RELOC_MICROBLAZE_32_GOTOFF: bfd_reloc_code_real = 1963;
pub const BFD_RELOC_MICROBLAZE_64_GOTOFF: bfd_reloc_code_real = 1962;
pub const BFD_RELOC_MICROBLAZE_64_PLT: bfd_reloc_code_real = 1961;
pub const BFD_RELOC_MICROBLAZE_64_GOT: bfd_reloc_code_real = 1960;
pub const BFD_RELOC_MICROBLAZE_64_GOTPC: bfd_reloc_code_real = 1959;
pub const BFD_RELOC_MICROBLAZE_64_NONE: bfd_reloc_code_real = 1958;
pub const BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM: bfd_reloc_code_real = 1957;
pub const BFD_RELOC_MICROBLAZE_32_RWSDA: bfd_reloc_code_real = 1956;
pub const BFD_RELOC_MICROBLAZE_32_ROSDA: bfd_reloc_code_real = 1955;
pub const BFD_RELOC_MICROBLAZE_32_LO_PCREL: bfd_reloc_code_real = 1954;
pub const BFD_RELOC_MICROBLAZE_32_LO: bfd_reloc_code_real = 1953;
pub const BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT: bfd_reloc_code_real = 1952;
pub const BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12: bfd_reloc_code_real = 1951;
pub const BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21: bfd_reloc_code_real = 1950;
pub const BFD_RELOC_MACH_O_ARM64_ADDEND: bfd_reloc_code_real = 1949;
pub const BFD_RELOC_MACH_O_X86_64_TLV: bfd_reloc_code_real = 1948;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_4: bfd_reloc_code_real = 1947;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_2: bfd_reloc_code_real = 1946;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_1: bfd_reloc_code_real = 1945;
pub const BFD_RELOC_MACH_O_X86_64_GOT_LOAD: bfd_reloc_code_real = 1944;
pub const BFD_RELOC_MACH_O_X86_64_GOT: bfd_reloc_code_real = 1943;
pub const BFD_RELOC_MACH_O_X86_64_BRANCH8: bfd_reloc_code_real = 1942;
pub const BFD_RELOC_MACH_O_X86_64_BRANCH32: bfd_reloc_code_real = 1941;
pub const BFD_RELOC_MACH_O_SUBTRACTOR64: bfd_reloc_code_real = 1940;
pub const BFD_RELOC_MACH_O_SUBTRACTOR32: bfd_reloc_code_real = 1939;
pub const BFD_RELOC_MACH_O_PAIR: bfd_reloc_code_real = 1938;
pub const BFD_RELOC_MACH_O_LOCAL_SECTDIFF: bfd_reloc_code_real = 1937;
pub const BFD_RELOC_MACH_O_SECTDIFF: bfd_reloc_code_real = 1936;
pub const BFD_RELOC_LM32_RELATIVE: bfd_reloc_code_real = 1935;
pub const BFD_RELOC_LM32_JMP_SLOT: bfd_reloc_code_real = 1934;
pub const BFD_RELOC_LM32_GLOB_DAT: bfd_reloc_code_real = 1933;
pub const BFD_RELOC_LM32_COPY: bfd_reloc_code_real = 1932;
pub const BFD_RELOC_LM32_GOTOFF_LO16: bfd_reloc_code_real = 1931;
pub const BFD_RELOC_LM32_GOTOFF_HI16: bfd_reloc_code_real = 1930;
pub const BFD_RELOC_LM32_16_GOT: bfd_reloc_code_real = 1929;
pub const BFD_RELOC_LM32_BRANCH: bfd_reloc_code_real = 1928;
pub const BFD_RELOC_LM32_CALL: bfd_reloc_code_real = 1927;
pub const BFD_RELOC_Z8K_IMM4L: bfd_reloc_code_real = 1926;
pub const BFD_RELOC_Z8K_CALLR: bfd_reloc_code_real = 1925;
pub const BFD_RELOC_Z8K_DISP7: bfd_reloc_code_real = 1924;
pub const BFD_RELOC_Z80_16_BE: bfd_reloc_code_real = 1923;
pub const BFD_RELOC_Z80_WORD1: bfd_reloc_code_real = 1922;
pub const BFD_RELOC_Z80_WORD0: bfd_reloc_code_real = 1921;
pub const BFD_RELOC_Z80_BYTE3: bfd_reloc_code_real = 1920;
pub const BFD_RELOC_Z80_BYTE2: bfd_reloc_code_real = 1919;
pub const BFD_RELOC_Z80_BYTE1: bfd_reloc_code_real = 1918;
pub const BFD_RELOC_Z80_BYTE0: bfd_reloc_code_real = 1917;
pub const BFD_RELOC_Z80_DISP8: bfd_reloc_code_real = 1916;
pub const BFD_RELOC_XTENSA_NDIFF32: bfd_reloc_code_real = 1915;
pub const BFD_RELOC_XTENSA_NDIFF16: bfd_reloc_code_real = 1914;
pub const BFD_RELOC_XTENSA_NDIFF8: bfd_reloc_code_real = 1913;
pub const BFD_RELOC_XTENSA_PDIFF32: bfd_reloc_code_real = 1912;
pub const BFD_RELOC_XTENSA_PDIFF16: bfd_reloc_code_real = 1911;
pub const BFD_RELOC_XTENSA_PDIFF8: bfd_reloc_code_real = 1910;
pub const BFD_RELOC_XTENSA_TLS_CALL: bfd_reloc_code_real = 1909;
pub const BFD_RELOC_XTENSA_TLS_ARG: bfd_reloc_code_real = 1908;
pub const BFD_RELOC_XTENSA_TLS_FUNC: bfd_reloc_code_real = 1907;
pub const BFD_RELOC_XTENSA_TLS_TPOFF: bfd_reloc_code_real = 1906;
pub const BFD_RELOC_XTENSA_TLS_DTPOFF: bfd_reloc_code_real = 1905;
pub const BFD_RELOC_XTENSA_TLSDESC_ARG: bfd_reloc_code_real = 1904;
pub const BFD_RELOC_XTENSA_TLSDESC_FN: bfd_reloc_code_real = 1903;
pub const BFD_RELOC_XTENSA_ASM_SIMPLIFY: bfd_reloc_code_real = 1902;
pub const BFD_RELOC_XTENSA_ASM_EXPAND: bfd_reloc_code_real = 1901;
pub const BFD_RELOC_XTENSA_OP2: bfd_reloc_code_real = 1900;
pub const BFD_RELOC_XTENSA_OP1: bfd_reloc_code_real = 1899;
pub const BFD_RELOC_XTENSA_OP0: bfd_reloc_code_real = 1898;
pub const BFD_RELOC_XTENSA_SLOT14_ALT: bfd_reloc_code_real = 1897;
pub const BFD_RELOC_XTENSA_SLOT13_ALT: bfd_reloc_code_real = 1896;
pub const BFD_RELOC_XTENSA_SLOT12_ALT: bfd_reloc_code_real = 1895;
pub const BFD_RELOC_XTENSA_SLOT11_ALT: bfd_reloc_code_real = 1894;
pub const BFD_RELOC_XTENSA_SLOT10_ALT: bfd_reloc_code_real = 1893;
pub const BFD_RELOC_XTENSA_SLOT9_ALT: bfd_reloc_code_real = 1892;
pub const BFD_RELOC_XTENSA_SLOT8_ALT: bfd_reloc_code_real = 1891;
pub const BFD_RELOC_XTENSA_SLOT7_ALT: bfd_reloc_code_real = 1890;
pub const BFD_RELOC_XTENSA_SLOT6_ALT: bfd_reloc_code_real = 1889;
pub const BFD_RELOC_XTENSA_SLOT5_ALT: bfd_reloc_code_real = 1888;
pub const BFD_RELOC_XTENSA_SLOT4_ALT: bfd_reloc_code_real = 1887;
pub const BFD_RELOC_XTENSA_SLOT3_ALT: bfd_reloc_code_real = 1886;
pub const BFD_RELOC_XTENSA_SLOT2_ALT: bfd_reloc_code_real = 1885;
pub const BFD_RELOC_XTENSA_SLOT1_ALT: bfd_reloc_code_real = 1884;
pub const BFD_RELOC_XTENSA_SLOT0_ALT: bfd_reloc_code_real = 1883;
pub const BFD_RELOC_XTENSA_SLOT14_OP: bfd_reloc_code_real = 1882;
pub const BFD_RELOC_XTENSA_SLOT13_OP: bfd_reloc_code_real = 1881;
pub const BFD_RELOC_XTENSA_SLOT12_OP: bfd_reloc_code_real = 1880;
pub const BFD_RELOC_XTENSA_SLOT11_OP: bfd_reloc_code_real = 1879;
pub const BFD_RELOC_XTENSA_SLOT10_OP: bfd_reloc_code_real = 1878;
pub const BFD_RELOC_XTENSA_SLOT9_OP: bfd_reloc_code_real = 1877;
pub const BFD_RELOC_XTENSA_SLOT8_OP: bfd_reloc_code_real = 1876;
pub const BFD_RELOC_XTENSA_SLOT7_OP: bfd_reloc_code_real = 1875;
pub const BFD_RELOC_XTENSA_SLOT6_OP: bfd_reloc_code_real = 1874;
pub const BFD_RELOC_XTENSA_SLOT5_OP: bfd_reloc_code_real = 1873;
pub const BFD_RELOC_XTENSA_SLOT4_OP: bfd_reloc_code_real = 1872;
pub const BFD_RELOC_XTENSA_SLOT3_OP: bfd_reloc_code_real = 1871;
pub const BFD_RELOC_XTENSA_SLOT2_OP: bfd_reloc_code_real = 1870;
pub const BFD_RELOC_XTENSA_SLOT1_OP: bfd_reloc_code_real = 1869;
pub const BFD_RELOC_XTENSA_SLOT0_OP: bfd_reloc_code_real = 1868;
pub const BFD_RELOC_XTENSA_DIFF32: bfd_reloc_code_real = 1867;
pub const BFD_RELOC_XTENSA_DIFF16: bfd_reloc_code_real = 1866;
pub const BFD_RELOC_XTENSA_DIFF8: bfd_reloc_code_real = 1865;
pub const BFD_RELOC_XTENSA_PLT: bfd_reloc_code_real = 1864;
pub const BFD_RELOC_XTENSA_RELATIVE: bfd_reloc_code_real = 1863;
pub const BFD_RELOC_XTENSA_JMP_SLOT: bfd_reloc_code_real = 1862;
pub const BFD_RELOC_XTENSA_GLOB_DAT: bfd_reloc_code_real = 1861;
pub const BFD_RELOC_XTENSA_RTLD: bfd_reloc_code_real = 1860;
pub const BFD_RELOC_IQ2000_UHI16: bfd_reloc_code_real = 1859;
pub const BFD_RELOC_IQ2000_OFFSET_21: bfd_reloc_code_real = 1858;
pub const BFD_RELOC_IQ2000_OFFSET_16: bfd_reloc_code_real = 1857;
pub const BFD_RELOC_PRU_GNU_DIFF32_PMEM: bfd_reloc_code_real = 1856;
pub const BFD_RELOC_PRU_GNU_DIFF16_PMEM: bfd_reloc_code_real = 1855;
pub const BFD_RELOC_PRU_GNU_DIFF32: bfd_reloc_code_real = 1854;
pub const BFD_RELOC_PRU_GNU_DIFF16: bfd_reloc_code_real = 1853;
pub const BFD_RELOC_PRU_GNU_DIFF8: bfd_reloc_code_real = 1852;
pub const BFD_RELOC_PRU_16_PMEM: bfd_reloc_code_real = 1851;
pub const BFD_RELOC_PRU_32_PMEM: bfd_reloc_code_real = 1850;
pub const BFD_RELOC_PRU_U8_PCREL: bfd_reloc_code_real = 1849;
pub const BFD_RELOC_PRU_S10_PCREL: bfd_reloc_code_real = 1848;
pub const BFD_RELOC_PRU_LDI32: bfd_reloc_code_real = 1847;
pub const BFD_RELOC_PRU_U16_PMEMIMM: bfd_reloc_code_real = 1846;
pub const BFD_RELOC_PRU_U16: bfd_reloc_code_real = 1845;
pub const BFD_RELOC_NIOS2_R2_T1X1I6_2: bfd_reloc_code_real = 1844;
pub const BFD_RELOC_NIOS2_R2_T1X1I6: bfd_reloc_code_real = 1843;
pub const BFD_RELOC_NIOS2_R2_L5I4X1: bfd_reloc_code_real = 1842;
pub const BFD_RELOC_NIOS2_R2_F1I5_2: bfd_reloc_code_real = 1841;
pub const BFD_RELOC_NIOS2_R2_X2L5: bfd_reloc_code_real = 1840;
pub const BFD_RELOC_NIOS2_R2_X1I7_2: bfd_reloc_code_real = 1839;
pub const BFD_RELOC_NIOS2_R2_T2I4_2: bfd_reloc_code_real = 1838;
pub const BFD_RELOC_NIOS2_R2_T2I4_1: bfd_reloc_code_real = 1837;
pub const BFD_RELOC_NIOS2_R2_T2I4: bfd_reloc_code_real = 1836;
pub const BFD_RELOC_NIOS2_R2_T1I7_2: bfd_reloc_code_real = 1835;
pub const BFD_RELOC_NIOS2_R2_T1I7_1_PCREL: bfd_reloc_code_real = 1834;
pub const BFD_RELOC_NIOS2_R2_I10_1_PCREL: bfd_reloc_code_real = 1833;
pub const BFD_RELOC_NIOS2_R2_S12: bfd_reloc_code_real = 1832;
pub const BFD_RELOC_NIOS2_CALL_HA: bfd_reloc_code_real = 1831;
pub const BFD_RELOC_NIOS2_CALL_LO: bfd_reloc_code_real = 1830;
pub const BFD_RELOC_NIOS2_GOT_HA: bfd_reloc_code_real = 1829;
pub const BFD_RELOC_NIOS2_GOT_LO: bfd_reloc_code_real = 1828;
pub const BFD_RELOC_NIOS2_CALL26_NOAT: bfd_reloc_code_real = 1827;
pub const BFD_RELOC_NIOS2_GOTOFF: bfd_reloc_code_real = 1826;
pub const BFD_RELOC_NIOS2_RELATIVE: bfd_reloc_code_real = 1825;
pub const BFD_RELOC_NIOS2_JUMP_SLOT: bfd_reloc_code_real = 1824;
pub const BFD_RELOC_NIOS2_GLOB_DAT: bfd_reloc_code_real = 1823;
pub const BFD_RELOC_NIOS2_COPY: bfd_reloc_code_real = 1822;
pub const BFD_RELOC_NIOS2_TLS_TPREL: bfd_reloc_code_real = 1821;
pub const BFD_RELOC_NIOS2_TLS_DTPREL: bfd_reloc_code_real = 1820;
pub const BFD_RELOC_NIOS2_TLS_DTPMOD: bfd_reloc_code_real = 1819;
pub const BFD_RELOC_NIOS2_TLS_LE16: bfd_reloc_code_real = 1818;
pub const BFD_RELOC_NIOS2_TLS_IE16: bfd_reloc_code_real = 1817;
pub const BFD_RELOC_NIOS2_TLS_LDO16: bfd_reloc_code_real = 1816;
pub const BFD_RELOC_NIOS2_TLS_LDM16: bfd_reloc_code_real = 1815;
pub const BFD_RELOC_NIOS2_TLS_GD16: bfd_reloc_code_real = 1814;
pub const BFD_RELOC_NIOS2_PCREL_HA: bfd_reloc_code_real = 1813;
pub const BFD_RELOC_NIOS2_PCREL_LO: bfd_reloc_code_real = 1812;
pub const BFD_RELOC_NIOS2_GOTOFF_HA: bfd_reloc_code_real = 1811;
pub const BFD_RELOC_NIOS2_GOTOFF_LO: bfd_reloc_code_real = 1810;
pub const BFD_RELOC_NIOS2_CALL16: bfd_reloc_code_real = 1809;
pub const BFD_RELOC_NIOS2_GOT16: bfd_reloc_code_real = 1808;
pub const BFD_RELOC_NIOS2_ALIGN: bfd_reloc_code_real = 1807;
pub const BFD_RELOC_NIOS2_CALLR: bfd_reloc_code_real = 1806;
pub const BFD_RELOC_NIOS2_CJMP: bfd_reloc_code_real = 1805;
pub const BFD_RELOC_NIOS2_UJMP: bfd_reloc_code_real = 1804;
pub const BFD_RELOC_NIOS2_GPREL: bfd_reloc_code_real = 1803;
pub const BFD_RELOC_NIOS2_HIADJ16: bfd_reloc_code_real = 1802;
pub const BFD_RELOC_NIOS2_LO16: bfd_reloc_code_real = 1801;
pub const BFD_RELOC_NIOS2_HI16: bfd_reloc_code_real = 1800;
pub const BFD_RELOC_NIOS2_IMM8: bfd_reloc_code_real = 1799;
pub const BFD_RELOC_NIOS2_IMM6: bfd_reloc_code_real = 1798;
pub const BFD_RELOC_NIOS2_CACHE_OPX: bfd_reloc_code_real = 1797;
pub const BFD_RELOC_NIOS2_IMM5: bfd_reloc_code_real = 1796;
pub const BFD_RELOC_NIOS2_CALL26: bfd_reloc_code_real = 1795;
pub const BFD_RELOC_NIOS2_U16: bfd_reloc_code_real = 1794;
pub const BFD_RELOC_NIOS2_S16: bfd_reloc_code_real = 1793;
pub const BFD_RELOC_MSP430_SUB_ULEB128: bfd_reloc_code_real = 1792;
pub const BFD_RELOC_MSP430_SET_ULEB128: bfd_reloc_code_real = 1791;
pub const BFD_RELOC_MSP430_SYM_DIFF: bfd_reloc_code_real = 1790;
pub const BFD_RELOC_MSP430_PREL31: bfd_reloc_code_real = 1789;
pub const BFD_RELOC_MSP430_ABS_HI16: bfd_reloc_code_real = 1788;
pub const BFD_RELOC_MSP430X_ABS16: bfd_reloc_code_real = 1787;
pub const BFD_RELOC_MSP430X_PCR20_CALL: bfd_reloc_code_real = 1786;
pub const BFD_RELOC_MSP430X_PCR16: bfd_reloc_code_real = 1785;
pub const BFD_RELOC_MSP430X_ABS20_ADR_DST: bfd_reloc_code_real = 1784;
pub const BFD_RELOC_MSP430X_ABS20_ADR_SRC: bfd_reloc_code_real = 1783;
pub const BFD_RELOC_MSP430X_ABS20_EXT_ODST: bfd_reloc_code_real = 1782;
pub const BFD_RELOC_MSP430X_ABS20_EXT_DST: bfd_reloc_code_real = 1781;
pub const BFD_RELOC_MSP430X_ABS20_EXT_SRC: bfd_reloc_code_real = 1780;
pub const BFD_RELOC_MSP430X_PCR20_EXT_ODST: bfd_reloc_code_real = 1779;
pub const BFD_RELOC_MSP430X_PCR20_EXT_DST: bfd_reloc_code_real = 1778;
pub const BFD_RELOC_MSP430X_PCR20_EXT_SRC: bfd_reloc_code_real = 1777;
pub const BFD_RELOC_MSP430_ABS8: bfd_reloc_code_real = 1776;
pub const BFD_RELOC_MSP430_RL_PCREL: bfd_reloc_code_real = 1775;
pub const BFD_RELOC_MSP430_2X_PCREL: bfd_reloc_code_real = 1774;
pub const BFD_RELOC_MSP430_16_BYTE: bfd_reloc_code_real = 1773;
pub const BFD_RELOC_MSP430_16_PCREL_BYTE: bfd_reloc_code_real = 1772;
pub const BFD_RELOC_MSP430_16: bfd_reloc_code_real = 1771;
pub const BFD_RELOC_MSP430_16_PCREL: bfd_reloc_code_real = 1770;
pub const BFD_RELOC_MSP430_10_PCREL: bfd_reloc_code_real = 1769;
pub const BFD_RELOC_MT_PCINSN8: bfd_reloc_code_real = 1768;
pub const BFD_RELOC_MT_GNU_VTENTRY: bfd_reloc_code_real = 1767;
pub const BFD_RELOC_MT_GNU_VTINHERIT: bfd_reloc_code_real = 1766;
pub const BFD_RELOC_MT_LO16: bfd_reloc_code_real = 1765;
pub const BFD_RELOC_MT_HI16: bfd_reloc_code_real = 1764;
pub const BFD_RELOC_MT_PC16: bfd_reloc_code_real = 1763;
pub const BFD_RELOC_VAX_RELATIVE: bfd_reloc_code_real = 1762;
pub const BFD_RELOC_VAX_JMP_SLOT: bfd_reloc_code_real = 1761;
pub const BFD_RELOC_VAX_GLOB_DAT: bfd_reloc_code_real = 1760;
pub const BFD_RELOC_XC16X_SOF: bfd_reloc_code_real = 1759;
pub const BFD_RELOC_XC16X_SEG: bfd_reloc_code_real = 1758;
pub const BFD_RELOC_XC16X_POF: bfd_reloc_code_real = 1757;
pub const BFD_RELOC_XC16X_PAG: bfd_reloc_code_real = 1756;
pub const BFD_RELOC_RELC: bfd_reloc_code_real = 1755;
pub const BFD_RELOC_XSTORMY16_FPTR16: bfd_reloc_code_real = 1754;
pub const BFD_RELOC_XSTORMY16_24: bfd_reloc_code_real = 1753;
pub const BFD_RELOC_XSTORMY16_12: bfd_reloc_code_real = 1752;
pub const BFD_RELOC_XSTORMY16_REL_12: bfd_reloc_code_real = 1751;
pub const BFD_RELOC_H8_DISP32A16: bfd_reloc_code_real = 1750;
pub const BFD_RELOC_H8_DIR32A16: bfd_reloc_code_real = 1749;
pub const BFD_RELOC_H8_DIR24R8: bfd_reloc_code_real = 1748;
pub const BFD_RELOC_H8_DIR24A8: bfd_reloc_code_real = 1747;
pub const BFD_RELOC_H8_DIR16R8: bfd_reloc_code_real = 1746;
pub const BFD_RELOC_H8_DIR16A8: bfd_reloc_code_real = 1745;
pub const BFD_RELOC_OR1K_TLS_DTPMOD: bfd_reloc_code_real = 1744;
pub const BFD_RELOC_OR1K_TLS_DTPOFF: bfd_reloc_code_real = 1743;
pub const BFD_RELOC_OR1K_TLS_TPOFF: bfd_reloc_code_real = 1742;
pub const BFD_RELOC_OR1K_TLS_LE_SLO16: bfd_reloc_code_real = 1741;
pub const BFD_RELOC_OR1K_TLS_LE_LO16: bfd_reloc_code_real = 1740;
pub const BFD_RELOC_OR1K_TLS_LE_AHI16: bfd_reloc_code_real = 1739;
pub const BFD_RELOC_OR1K_TLS_LE_HI16: bfd_reloc_code_real = 1738;
pub const BFD_RELOC_OR1K_TLS_IE_LO13: bfd_reloc_code_real = 1737;
pub const BFD_RELOC_OR1K_TLS_IE_PG21: bfd_reloc_code_real = 1736;
pub const BFD_RELOC_OR1K_TLS_IE_LO16: bfd_reloc_code_real = 1735;
pub const BFD_RELOC_OR1K_TLS_IE_AHI16: bfd_reloc_code_real = 1734;
pub const BFD_RELOC_OR1K_TLS_IE_HI16: bfd_reloc_code_real = 1733;
pub const BFD_RELOC_OR1K_TLS_LDO_LO16: bfd_reloc_code_real = 1732;
pub const BFD_RELOC_OR1K_TLS_LDO_HI16: bfd_reloc_code_real = 1731;
pub const BFD_RELOC_OR1K_TLS_LDM_LO13: bfd_reloc_code_real = 1730;
pub const BFD_RELOC_OR1K_TLS_LDM_PG21: bfd_reloc_code_real = 1729;
pub const BFD_RELOC_OR1K_TLS_LDM_LO16: bfd_reloc_code_real = 1728;
pub const BFD_RELOC_OR1K_TLS_LDM_HI16: bfd_reloc_code_real = 1727;
pub const BFD_RELOC_OR1K_TLS_GD_LO13: bfd_reloc_code_real = 1726;
pub const BFD_RELOC_OR1K_TLS_GD_PG21: bfd_reloc_code_real = 1725;
pub const BFD_RELOC_OR1K_TLS_GD_LO16: bfd_reloc_code_real = 1724;
pub const BFD_RELOC_OR1K_TLS_GD_HI16: bfd_reloc_code_real = 1723;
pub const BFD_RELOC_OR1K_RELATIVE: bfd_reloc_code_real = 1722;
pub const BFD_RELOC_OR1K_JMP_SLOT: bfd_reloc_code_real = 1721;
pub const BFD_RELOC_OR1K_GLOB_DAT: bfd_reloc_code_real = 1720;
pub const BFD_RELOC_OR1K_COPY: bfd_reloc_code_real = 1719;
pub const BFD_RELOC_OR1K_GOTOFF_SLO16: bfd_reloc_code_real = 1718;
pub const BFD_RELOC_OR1K_PLTA26: bfd_reloc_code_real = 1717;
pub const BFD_RELOC_OR1K_PLT26: bfd_reloc_code_real = 1716;
pub const BFD_RELOC_OR1K_GOT_LO13: bfd_reloc_code_real = 1715;
pub const BFD_RELOC_OR1K_GOT_PG21: bfd_reloc_code_real = 1714;
pub const BFD_RELOC_OR1K_GOT16: bfd_reloc_code_real = 1713;
pub const BFD_RELOC_OR1K_GOT_AHI16: bfd_reloc_code_real = 1712;
pub const BFD_RELOC_OR1K_GOTPC_LO16: bfd_reloc_code_real = 1711;
pub const BFD_RELOC_OR1K_GOTPC_HI16: bfd_reloc_code_real = 1710;
pub const BFD_RELOC_OR1K_SLO13: bfd_reloc_code_real = 1709;
pub const BFD_RELOC_OR1K_LO13: bfd_reloc_code_real = 1708;
pub const BFD_RELOC_OR1K_PCREL_PG21: bfd_reloc_code_real = 1707;
pub const BFD_RELOC_OR1K_SLO16: bfd_reloc_code_real = 1706;
pub const BFD_RELOC_OR1K_REL_26: bfd_reloc_code_real = 1705;
pub const BFD_RELOC_CRIS_32_IE: bfd_reloc_code_real = 1704;
pub const BFD_RELOC_CRIS_DTPMOD: bfd_reloc_code_real = 1703;
pub const BFD_RELOC_CRIS_16_TPREL: bfd_reloc_code_real = 1702;
pub const BFD_RELOC_CRIS_32_TPREL: bfd_reloc_code_real = 1701;
pub const BFD_RELOC_CRIS_16_GOT_TPREL: bfd_reloc_code_real = 1700;
pub const BFD_RELOC_CRIS_32_GOT_TPREL: bfd_reloc_code_real = 1699;
pub const BFD_RELOC_CRIS_16_DTPREL: bfd_reloc_code_real = 1698;
pub const BFD_RELOC_CRIS_32_DTPREL: bfd_reloc_code_real = 1697;
pub const BFD_RELOC_CRIS_DTP: bfd_reloc_code_real = 1696;
pub const BFD_RELOC_CRIS_32_GD: bfd_reloc_code_real = 1695;
pub const BFD_RELOC_CRIS_16_GOT_GD: bfd_reloc_code_real = 1694;
pub const BFD_RELOC_CRIS_32_GOT_GD: bfd_reloc_code_real = 1693;
pub const BFD_RELOC_CRIS_32_PLT_PCREL: bfd_reloc_code_real = 1692;
pub const BFD_RELOC_CRIS_32_PLT_GOTREL: bfd_reloc_code_real = 1691;
pub const BFD_RELOC_CRIS_32_GOTREL: bfd_reloc_code_real = 1690;
pub const BFD_RELOC_CRIS_16_GOTPLT: bfd_reloc_code_real = 1689;
pub const BFD_RELOC_CRIS_32_GOTPLT: bfd_reloc_code_real = 1688;
pub const BFD_RELOC_CRIS_16_GOT: bfd_reloc_code_real = 1687;
pub const BFD_RELOC_CRIS_32_GOT: bfd_reloc_code_real = 1686;
pub const BFD_RELOC_CRIS_RELATIVE: bfd_reloc_code_real = 1685;
pub const BFD_RELOC_CRIS_JUMP_SLOT: bfd_reloc_code_real = 1684;
pub const BFD_RELOC_CRIS_GLOB_DAT: bfd_reloc_code_real = 1683;
pub const BFD_RELOC_CRIS_COPY: bfd_reloc_code_real = 1682;
pub const BFD_RELOC_CRIS_UNSIGNED_4: bfd_reloc_code_real = 1681;
pub const BFD_RELOC_CRIS_LAPCQ_OFFSET: bfd_reloc_code_real = 1680;
pub const BFD_RELOC_CRIS_UNSIGNED_16: bfd_reloc_code_real = 1679;
pub const BFD_RELOC_CRIS_SIGNED_16: bfd_reloc_code_real = 1678;
pub const BFD_RELOC_CRIS_UNSIGNED_8: bfd_reloc_code_real = 1677;
pub const BFD_RELOC_CRIS_SIGNED_8: bfd_reloc_code_real = 1676;
pub const BFD_RELOC_CRIS_UNSIGNED_6: bfd_reloc_code_real = 1675;
pub const BFD_RELOC_CRIS_SIGNED_6: bfd_reloc_code_real = 1674;
pub const BFD_RELOC_CRIS_UNSIGNED_5: bfd_reloc_code_real = 1673;
pub const BFD_RELOC_CRIS_BDISP8: bfd_reloc_code_real = 1672;
pub const BFD_RELOC_CRX_SWITCH32: bfd_reloc_code_real = 1671;
pub const BFD_RELOC_CRX_SWITCH16: bfd_reloc_code_real = 1670;
pub const BFD_RELOC_CRX_SWITCH8: bfd_reloc_code_real = 1669;
pub const BFD_RELOC_CRX_IMM32: bfd_reloc_code_real = 1668;
pub const BFD_RELOC_CRX_IMM16: bfd_reloc_code_real = 1667;
pub const BFD_RELOC_CRX_NUM32: bfd_reloc_code_real = 1666;
pub const BFD_RELOC_CRX_NUM16: bfd_reloc_code_real = 1665;
pub const BFD_RELOC_CRX_NUM8: bfd_reloc_code_real = 1664;
pub const BFD_RELOC_CRX_ABS32: bfd_reloc_code_real = 1663;
pub const BFD_RELOC_CRX_ABS16: bfd_reloc_code_real = 1662;
pub const BFD_RELOC_CRX_REGREL32: bfd_reloc_code_real = 1661;
pub const BFD_RELOC_CRX_REGREL28: bfd_reloc_code_real = 1660;
pub const BFD_RELOC_CRX_REGREL22: bfd_reloc_code_real = 1659;
pub const BFD_RELOC_CRX_REGREL12: bfd_reloc_code_real = 1658;
pub const BFD_RELOC_CRX_REL32: bfd_reloc_code_real = 1657;
pub const BFD_RELOC_CRX_REL24: bfd_reloc_code_real = 1656;
pub const BFD_RELOC_CRX_REL16: bfd_reloc_code_real = 1655;
pub const BFD_RELOC_CRX_REL8_CMP: bfd_reloc_code_real = 1654;
pub const BFD_RELOC_CRX_REL8: bfd_reloc_code_real = 1653;
pub const BFD_RELOC_CRX_REL4: bfd_reloc_code_real = 1652;
pub const BFD_RELOC_CR16_GLOB_DAT: bfd_reloc_code_real = 1651;
pub const BFD_RELOC_CR16_GOTC_REGREL20: bfd_reloc_code_real = 1650;
pub const BFD_RELOC_CR16_GOT_REGREL20: bfd_reloc_code_real = 1649;
pub const BFD_RELOC_CR16_SWITCH32: bfd_reloc_code_real = 1648;
pub const BFD_RELOC_CR16_SWITCH16: bfd_reloc_code_real = 1647;
pub const BFD_RELOC_CR16_SWITCH8: bfd_reloc_code_real = 1646;
pub const BFD_RELOC_CR16_DISP24a: bfd_reloc_code_real = 1645;
pub const BFD_RELOC_CR16_DISP24: bfd_reloc_code_real = 1644;
pub const BFD_RELOC_CR16_DISP20: bfd_reloc_code_real = 1643;
pub const BFD_RELOC_CR16_DISP16: bfd_reloc_code_real = 1642;
pub const BFD_RELOC_CR16_DISP8: bfd_reloc_code_real = 1641;
pub const BFD_RELOC_CR16_DISP4: bfd_reloc_code_real = 1640;
pub const BFD_RELOC_CR16_IMM32a: bfd_reloc_code_real = 1639;
pub const BFD_RELOC_CR16_IMM32: bfd_reloc_code_real = 1638;
pub const BFD_RELOC_CR16_IMM24: bfd_reloc_code_real = 1637;
pub const BFD_RELOC_CR16_IMM20: bfd_reloc_code_real = 1636;
pub const BFD_RELOC_CR16_IMM16: bfd_reloc_code_real = 1635;
pub const BFD_RELOC_CR16_IMM8: bfd_reloc_code_real = 1634;
pub const BFD_RELOC_CR16_IMM4: bfd_reloc_code_real = 1633;
pub const BFD_RELOC_CR16_ABS24: bfd_reloc_code_real = 1632;
pub const BFD_RELOC_CR16_ABS20: bfd_reloc_code_real = 1631;
pub const BFD_RELOC_CR16_REGREL20a: bfd_reloc_code_real = 1630;
pub const BFD_RELOC_CR16_REGREL20: bfd_reloc_code_real = 1629;
pub const BFD_RELOC_CR16_REGREL16: bfd_reloc_code_real = 1628;
pub const BFD_RELOC_CR16_REGREL14a: bfd_reloc_code_real = 1627;
pub const BFD_RELOC_CR16_REGREL14: bfd_reloc_code_real = 1626;
pub const BFD_RELOC_CR16_REGREL4a: bfd_reloc_code_real = 1625;
pub const BFD_RELOC_CR16_REGREL4: bfd_reloc_code_real = 1624;
pub const BFD_RELOC_CR16_REGREL0: bfd_reloc_code_real = 1623;
pub const BFD_RELOC_CR16_NUM32a: bfd_reloc_code_real = 1622;
pub const BFD_RELOC_CR16_NUM32: bfd_reloc_code_real = 1621;
pub const BFD_RELOC_CR16_NUM16: bfd_reloc_code_real = 1620;
pub const BFD_RELOC_CR16_NUM8: bfd_reloc_code_real = 1619;
pub const BFD_RELOC_S12Z_15_PCREL: bfd_reloc_code_real = 1618;
pub const BFD_RELOC_M68HC12_HI8XG: bfd_reloc_code_real = 1617;
pub const BFD_RELOC_M68HC12_LO8XG: bfd_reloc_code_real = 1616;
pub const BFD_RELOC_M68HC12_10_PCREL: bfd_reloc_code_real = 1615;
pub const BFD_RELOC_M68HC12_9_PCREL: bfd_reloc_code_real = 1614;
pub const BFD_RELOC_M68HC12_16B: bfd_reloc_code_real = 1613;
pub const BFD_RELOC_M68HC12_9B: bfd_reloc_code_real = 1612;
pub const BFD_RELOC_XGATE_IMM5: bfd_reloc_code_real = 1611;
pub const BFD_RELOC_XGATE_IMM4: bfd_reloc_code_real = 1610;
pub const BFD_RELOC_XGATE_IMM3: bfd_reloc_code_real = 1609;
pub const BFD_RELOC_XGATE_IMM8_HI: bfd_reloc_code_real = 1608;
pub const BFD_RELOC_XGATE_IMM8_LO: bfd_reloc_code_real = 1607;
pub const BFD_RELOC_XGATE_PCREL_10: bfd_reloc_code_real = 1606;
pub const BFD_RELOC_XGATE_PCREL_9: bfd_reloc_code_real = 1605;
pub const BFD_RELOC_XGATE_24: bfd_reloc_code_real = 1604;
pub const BFD_RELOC_XGATE_GPAGE: bfd_reloc_code_real = 1603;
pub const BFD_RELOC_XGATE_LO16: bfd_reloc_code_real = 1602;
pub const BFD_RELOC_XGATE_RL_GROUP: bfd_reloc_code_real = 1601;
pub const BFD_RELOC_XGATE_RL_JUMP: bfd_reloc_code_real = 1600;
pub const BFD_RELOC_M68HC12_5B: bfd_reloc_code_real = 1599;
pub const BFD_RELOC_M68HC11_24: bfd_reloc_code_real = 1598;
pub const BFD_RELOC_M68HC11_PAGE: bfd_reloc_code_real = 1597;
pub const BFD_RELOC_M68HC11_LO16: bfd_reloc_code_real = 1596;
pub const BFD_RELOC_M68HC11_RL_GROUP: bfd_reloc_code_real = 1595;
pub const BFD_RELOC_M68HC11_RL_JUMP: bfd_reloc_code_real = 1594;
pub const BFD_RELOC_M68HC11_3B: bfd_reloc_code_real = 1593;
pub const BFD_RELOC_M68HC11_LO8: bfd_reloc_code_real = 1592;
pub const BFD_RELOC_M68HC11_HI8: bfd_reloc_code_real = 1591;
pub const BFD_RELOC_IA64_LTOFF_DTPREL22: bfd_reloc_code_real = 1590;
pub const BFD_RELOC_IA64_DTPREL64LSB: bfd_reloc_code_real = 1589;
pub const BFD_RELOC_IA64_DTPREL64MSB: bfd_reloc_code_real = 1588;
pub const BFD_RELOC_IA64_DTPREL32LSB: bfd_reloc_code_real = 1587;
pub const BFD_RELOC_IA64_DTPREL32MSB: bfd_reloc_code_real = 1586;
pub const BFD_RELOC_IA64_DTPREL64I: bfd_reloc_code_real = 1585;
pub const BFD_RELOC_IA64_DTPREL22: bfd_reloc_code_real = 1584;
pub const BFD_RELOC_IA64_DTPREL14: bfd_reloc_code_real = 1583;
pub const BFD_RELOC_IA64_LTOFF_DTPMOD22: bfd_reloc_code_real = 1582;
pub const BFD_RELOC_IA64_DTPMOD64LSB: bfd_reloc_code_real = 1581;
pub const BFD_RELOC_IA64_DTPMOD64MSB: bfd_reloc_code_real = 1580;
pub const BFD_RELOC_IA64_LTOFF_TPREL22: bfd_reloc_code_real = 1579;
pub const BFD_RELOC_IA64_TPREL64LSB: bfd_reloc_code_real = 1578;
pub const BFD_RELOC_IA64_TPREL64MSB: bfd_reloc_code_real = 1577;
pub const BFD_RELOC_IA64_TPREL64I: bfd_reloc_code_real = 1576;
pub const BFD_RELOC_IA64_TPREL22: bfd_reloc_code_real = 1575;
pub const BFD_RELOC_IA64_TPREL14: bfd_reloc_code_real = 1574;
pub const BFD_RELOC_IA64_LDXMOV: bfd_reloc_code_real = 1573;
pub const BFD_RELOC_IA64_LTOFF22X: bfd_reloc_code_real = 1572;
pub const BFD_RELOC_IA64_COPY: bfd_reloc_code_real = 1571;
pub const BFD_RELOC_IA64_IPLTLSB: bfd_reloc_code_real = 1570;
pub const BFD_RELOC_IA64_IPLTMSB: bfd_reloc_code_real = 1569;
pub const BFD_RELOC_IA64_LTV64LSB: bfd_reloc_code_real = 1568;
pub const BFD_RELOC_IA64_LTV64MSB: bfd_reloc_code_real = 1567;
pub const BFD_RELOC_IA64_LTV32LSB: bfd_reloc_code_real = 1566;
pub const BFD_RELOC_IA64_LTV32MSB: bfd_reloc_code_real = 1565;
pub const BFD_RELOC_IA64_REL64LSB: bfd_reloc_code_real = 1564;
pub const BFD_RELOC_IA64_REL64MSB: bfd_reloc_code_real = 1563;
pub const BFD_RELOC_IA64_REL32LSB: bfd_reloc_code_real = 1562;
pub const BFD_RELOC_IA64_REL32MSB: bfd_reloc_code_real = 1561;
pub const BFD_RELOC_IA64_SECREL64LSB: bfd_reloc_code_real = 1560;
pub const BFD_RELOC_IA64_SECREL64MSB: bfd_reloc_code_real = 1559;
pub const BFD_RELOC_IA64_SECREL32LSB: bfd_reloc_code_real = 1558;
pub const BFD_RELOC_IA64_SECREL32MSB: bfd_reloc_code_real = 1557;
pub const BFD_RELOC_IA64_SEGREL64LSB: bfd_reloc_code_real = 1556;
pub const BFD_RELOC_IA64_SEGREL64MSB: bfd_reloc_code_real = 1555;
pub const BFD_RELOC_IA64_SEGREL32LSB: bfd_reloc_code_real = 1554;
pub const BFD_RELOC_IA64_SEGREL32MSB: bfd_reloc_code_real = 1553;
pub const BFD_RELOC_IA64_LTOFF_FPTR64LSB: bfd_reloc_code_real = 1552;
pub const BFD_RELOC_IA64_LTOFF_FPTR64MSB: bfd_reloc_code_real = 1551;
pub const BFD_RELOC_IA64_LTOFF_FPTR32LSB: bfd_reloc_code_real = 1550;
pub const BFD_RELOC_IA64_LTOFF_FPTR32MSB: bfd_reloc_code_real = 1549;
pub const BFD_RELOC_IA64_LTOFF_FPTR64I: bfd_reloc_code_real = 1548;
pub const BFD_RELOC_IA64_LTOFF_FPTR22: bfd_reloc_code_real = 1547;
pub const BFD_RELOC_IA64_PCREL64LSB: bfd_reloc_code_real = 1546;
pub const BFD_RELOC_IA64_PCREL64MSB: bfd_reloc_code_real = 1545;
pub const BFD_RELOC_IA64_PCREL32LSB: bfd_reloc_code_real = 1544;
pub const BFD_RELOC_IA64_PCREL32MSB: bfd_reloc_code_real = 1543;
pub const BFD_RELOC_IA64_PCREL64I: bfd_reloc_code_real = 1542;
pub const BFD_RELOC_IA64_PCREL60B: bfd_reloc_code_real = 1541;
pub const BFD_RELOC_IA64_PCREL22: bfd_reloc_code_real = 1540;
pub const BFD_RELOC_IA64_PCREL21F: bfd_reloc_code_real = 1539;
pub const BFD_RELOC_IA64_PCREL21M: bfd_reloc_code_real = 1538;
pub const BFD_RELOC_IA64_PCREL21BI: bfd_reloc_code_real = 1537;
pub const BFD_RELOC_IA64_PCREL21B: bfd_reloc_code_real = 1536;
pub const BFD_RELOC_IA64_FPTR64LSB: bfd_reloc_code_real = 1535;
pub const BFD_RELOC_IA64_FPTR64MSB: bfd_reloc_code_real = 1534;
pub const BFD_RELOC_IA64_FPTR32LSB: bfd_reloc_code_real = 1533;
pub const BFD_RELOC_IA64_FPTR32MSB: bfd_reloc_code_real = 1532;
pub const BFD_RELOC_IA64_FPTR64I: bfd_reloc_code_real = 1531;
pub const BFD_RELOC_IA64_PLTOFF64LSB: bfd_reloc_code_real = 1530;
pub const BFD_RELOC_IA64_PLTOFF64MSB: bfd_reloc_code_real = 1529;
pub const BFD_RELOC_IA64_PLTOFF64I: bfd_reloc_code_real = 1528;
pub const BFD_RELOC_IA64_PLTOFF22: bfd_reloc_code_real = 1527;
pub const BFD_RELOC_IA64_LTOFF64I: bfd_reloc_code_real = 1526;
pub const BFD_RELOC_IA64_LTOFF22: bfd_reloc_code_real = 1525;
pub const BFD_RELOC_IA64_GPREL64LSB: bfd_reloc_code_real = 1524;
pub const BFD_RELOC_IA64_GPREL64MSB: bfd_reloc_code_real = 1523;
pub const BFD_RELOC_IA64_GPREL32LSB: bfd_reloc_code_real = 1522;
pub const BFD_RELOC_IA64_GPREL32MSB: bfd_reloc_code_real = 1521;
pub const BFD_RELOC_IA64_GPREL64I: bfd_reloc_code_real = 1520;
pub const BFD_RELOC_IA64_GPREL22: bfd_reloc_code_real = 1519;
pub const BFD_RELOC_IA64_DIR64LSB: bfd_reloc_code_real = 1518;
pub const BFD_RELOC_IA64_DIR64MSB: bfd_reloc_code_real = 1517;
pub const BFD_RELOC_IA64_DIR32LSB: bfd_reloc_code_real = 1516;
pub const BFD_RELOC_IA64_DIR32MSB: bfd_reloc_code_real = 1515;
pub const BFD_RELOC_IA64_IMM64: bfd_reloc_code_real = 1514;
pub const BFD_RELOC_IA64_IMM22: bfd_reloc_code_real = 1513;
pub const BFD_RELOC_IA64_IMM14: bfd_reloc_code_real = 1512;
pub const BFD_RELOC_VTABLE_ENTRY: bfd_reloc_code_real = 1511;
pub const BFD_RELOC_VTABLE_INHERIT: bfd_reloc_code_real = 1510;
pub const BFD_RELOC_VPE4KMATH_INSN: bfd_reloc_code_real = 1509;
pub const BFD_RELOC_VPE4KMATH_DATA: bfd_reloc_code_real = 1508;
pub const BFD_RELOC_IP2K_FR_OFFSET: bfd_reloc_code_real = 1507;
pub const BFD_RELOC_IP2K_TEXT: bfd_reloc_code_real = 1506;
pub const BFD_RELOC_IP2K_PC_SKIP: bfd_reloc_code_real = 1505;
pub const BFD_RELOC_IP2K_HI8INSN: bfd_reloc_code_real = 1504;
pub const BFD_RELOC_IP2K_LO8INSN: bfd_reloc_code_real = 1503;
pub const BFD_RELOC_IP2K_EX8DATA: bfd_reloc_code_real = 1502;
pub const BFD_RELOC_IP2K_HI8DATA: bfd_reloc_code_real = 1501;
pub const BFD_RELOC_IP2K_LO8DATA: bfd_reloc_code_real = 1500;
pub const BFD_RELOC_IP2K_PAGE3: bfd_reloc_code_real = 1499;
pub const BFD_RELOC_IP2K_ADDR16CJP: bfd_reloc_code_real = 1498;
pub const BFD_RELOC_IP2K_BANK: bfd_reloc_code_real = 1497;
pub const BFD_RELOC_IP2K_FR9: bfd_reloc_code_real = 1496;
pub const BFD_RELOC_SCORE_DUMMY_HI16: bfd_reloc_code_real = 1495;
pub const BFD_RELOC_SCORE_CALL15: bfd_reloc_code_real = 1494;
pub const BFD_RELOC_SCORE_GOT_LO16: bfd_reloc_code_real = 1493;
pub const BFD_RELOC_SCORE_GOT15: bfd_reloc_code_real = 1492;
pub const BFD_RELOC_SCORE_BCMP: bfd_reloc_code_real = 1491;
pub const BFD_RELOC_SCORE16_BRANCH: bfd_reloc_code_real = 1490;
pub const BFD_RELOC_SCORE16_JMP: bfd_reloc_code_real = 1489;
pub const BFD_RELOC_SCORE_IMM32: bfd_reloc_code_real = 1488;
pub const BFD_RELOC_SCORE_IMM30: bfd_reloc_code_real = 1487;
pub const BFD_RELOC_SCORE_BRANCH: bfd_reloc_code_real = 1486;
pub const BFD_RELOC_SCORE_JMP: bfd_reloc_code_real = 1485;
pub const BFD_RELOC_SCORE_DUMMY2: bfd_reloc_code_real = 1484;
pub const BFD_RELOC_SCORE_GPREL15: bfd_reloc_code_real = 1483;
pub const BFD_RELOC_390_IRELATIVE: bfd_reloc_code_real = 1482;
pub const BFD_RELOC_390_TLS_GOTIE20: bfd_reloc_code_real = 1481;
pub const BFD_RELOC_390_GOTPLT20: bfd_reloc_code_real = 1480;
pub const BFD_RELOC_390_GOT20: bfd_reloc_code_real = 1479;
pub const BFD_RELOC_390_20: bfd_reloc_code_real = 1478;
pub const BFD_RELOC_390_TLS_TPOFF: bfd_reloc_code_real = 1477;
pub const BFD_RELOC_390_TLS_DTPOFF: bfd_reloc_code_real = 1476;
pub const BFD_RELOC_390_TLS_DTPMOD: bfd_reloc_code_real = 1475;
pub const BFD_RELOC_390_TLS_LDO64: bfd_reloc_code_real = 1474;
pub const BFD_RELOC_390_TLS_LDO32: bfd_reloc_code_real = 1473;
pub const BFD_RELOC_390_TLS_LE64: bfd_reloc_code_real = 1472;
pub const BFD_RELOC_390_TLS_LE32: bfd_reloc_code_real = 1471;
pub const BFD_RELOC_390_TLS_IEENT: bfd_reloc_code_real = 1470;
pub const BFD_RELOC_390_TLS_IE64: bfd_reloc_code_real = 1469;
pub const BFD_RELOC_390_TLS_IE32: bfd_reloc_code_real = 1468;
pub const BFD_RELOC_390_TLS_LDM64: bfd_reloc_code_real = 1467;
pub const BFD_RELOC_390_TLS_LDM32: bfd_reloc_code_real = 1466;
pub const BFD_RELOC_390_TLS_GOTIE64: bfd_reloc_code_real = 1465;
pub const BFD_RELOC_390_TLS_GOTIE32: bfd_reloc_code_real = 1464;
pub const BFD_RELOC_390_TLS_GOTIE12: bfd_reloc_code_real = 1463;
pub const BFD_RELOC_390_TLS_GD64: bfd_reloc_code_real = 1462;
pub const BFD_RELOC_390_TLS_GD32: bfd_reloc_code_real = 1461;
pub const BFD_RELOC_390_TLS_LDCALL: bfd_reloc_code_real = 1460;
pub const BFD_RELOC_390_TLS_GDCALL: bfd_reloc_code_real = 1459;
pub const BFD_RELOC_390_TLS_LOAD: bfd_reloc_code_real = 1458;
pub const BFD_RELOC_390_PLTOFF64: bfd_reloc_code_real = 1457;
pub const BFD_RELOC_390_PLTOFF32: bfd_reloc_code_real = 1456;
pub const BFD_RELOC_390_PLTOFF16: bfd_reloc_code_real = 1455;
pub const BFD_RELOC_390_GOTPLTENT: bfd_reloc_code_real = 1454;
pub const BFD_RELOC_390_GOTPLT64: bfd_reloc_code_real = 1453;
pub const BFD_RELOC_390_GOTPLT32: bfd_reloc_code_real = 1452;
pub const BFD_RELOC_390_GOTPLT16: bfd_reloc_code_real = 1451;
pub const BFD_RELOC_390_GOTPLT12: bfd_reloc_code_real = 1450;
pub const BFD_RELOC_390_GOTOFF64: bfd_reloc_code_real = 1449;
pub const BFD_RELOC_390_GOTENT: bfd_reloc_code_real = 1448;
pub const BFD_RELOC_390_PLT64: bfd_reloc_code_real = 1447;
pub const BFD_RELOC_390_GOT64: bfd_reloc_code_real = 1446;
pub const BFD_RELOC_390_GOTPCDBL: bfd_reloc_code_real = 1445;
pub const BFD_RELOC_390_PLT32DBL: bfd_reloc_code_real = 1444;
pub const BFD_RELOC_390_PC32DBL: bfd_reloc_code_real = 1443;
pub const BFD_RELOC_390_PLT24DBL: bfd_reloc_code_real = 1442;
pub const BFD_RELOC_390_PC24DBL: bfd_reloc_code_real = 1441;
pub const BFD_RELOC_390_PLT16DBL: bfd_reloc_code_real = 1440;
pub const BFD_RELOC_390_PC16DBL: bfd_reloc_code_real = 1439;
pub const BFD_RELOC_390_PLT12DBL: bfd_reloc_code_real = 1438;
pub const BFD_RELOC_390_PC12DBL: bfd_reloc_code_real = 1437;
pub const BFD_RELOC_390_GOT16: bfd_reloc_code_real = 1436;
pub const BFD_RELOC_390_GOTPC: bfd_reloc_code_real = 1435;
pub const BFD_RELOC_390_RELATIVE: bfd_reloc_code_real = 1434;
pub const BFD_RELOC_390_JMP_SLOT: bfd_reloc_code_real = 1433;
pub const BFD_RELOC_390_GLOB_DAT: bfd_reloc_code_real = 1432;
pub const BFD_RELOC_390_COPY: bfd_reloc_code_real = 1431;
pub const BFD_RELOC_390_PLT32: bfd_reloc_code_real = 1430;
pub const BFD_RELOC_390_GOT12: bfd_reloc_code_real = 1429;
pub const BFD_RELOC_390_12: bfd_reloc_code_real = 1428;
pub const BFD_RELOC_RX_RELAX: bfd_reloc_code_real = 1427;
pub const BFD_RELOC_RX_ABS16UL: bfd_reloc_code_real = 1426;
pub const BFD_RELOC_RX_ABS16UW: bfd_reloc_code_real = 1425;
pub const BFD_RELOC_RX_ABS16U: bfd_reloc_code_real = 1424;
pub const BFD_RELOC_RX_ABS32_REV: bfd_reloc_code_real = 1423;
pub const BFD_RELOC_RX_ABS32: bfd_reloc_code_real = 1422;
pub const BFD_RELOC_RX_ABS16_REV: bfd_reloc_code_real = 1421;
pub const BFD_RELOC_RX_ABS16: bfd_reloc_code_real = 1420;
pub const BFD_RELOC_RX_ABS8: bfd_reloc_code_real = 1419;
pub const BFD_RELOC_RX_OP_NEG: bfd_reloc_code_real = 1418;
pub const BFD_RELOC_RX_OP_SUBTRACT: bfd_reloc_code_real = 1417;
pub const BFD_RELOC_RX_SYM: bfd_reloc_code_real = 1416;
pub const BFD_RELOC_RX_GPRELL: bfd_reloc_code_real = 1415;
pub const BFD_RELOC_RX_GPRELW: bfd_reloc_code_real = 1414;
pub const BFD_RELOC_RX_GPRELB: bfd_reloc_code_real = 1413;
pub const BFD_RELOC_RX_DIFF: bfd_reloc_code_real = 1412;
pub const BFD_RELOC_RX_DIR3U_PCREL: bfd_reloc_code_real = 1411;
pub const BFD_RELOC_RX_24U: bfd_reloc_code_real = 1410;
pub const BFD_RELOC_RX_16U: bfd_reloc_code_real = 1409;
pub const BFD_RELOC_RX_8U: bfd_reloc_code_real = 1408;
pub const BFD_RELOC_RX_32_OP: bfd_reloc_code_real = 1407;
pub const BFD_RELOC_RX_24_OP: bfd_reloc_code_real = 1406;
pub const BFD_RELOC_RX_16_OP: bfd_reloc_code_real = 1405;
pub const BFD_RELOC_RX_NEG32: bfd_reloc_code_real = 1404;
pub const BFD_RELOC_RX_NEG24: bfd_reloc_code_real = 1403;
pub const BFD_RELOC_RX_NEG16: bfd_reloc_code_real = 1402;
pub const BFD_RELOC_RX_NEG8: bfd_reloc_code_real = 1401;
pub const BFD_RELOC_RL78_SADDR: bfd_reloc_code_real = 1400;
pub const BFD_RELOC_RL78_CODE: bfd_reloc_code_real = 1399;
pub const BFD_RELOC_RL78_LO16: bfd_reloc_code_real = 1398;
pub const BFD_RELOC_RL78_HI8: bfd_reloc_code_real = 1397;
pub const BFD_RELOC_RL78_HI16: bfd_reloc_code_real = 1396;
pub const BFD_RELOC_RL78_RELAX: bfd_reloc_code_real = 1395;
pub const BFD_RELOC_RL78_ABS16UL: bfd_reloc_code_real = 1394;
pub const BFD_RELOC_RL78_ABS16UW: bfd_reloc_code_real = 1393;
pub const BFD_RELOC_RL78_ABS16U: bfd_reloc_code_real = 1392;
pub const BFD_RELOC_RL78_ABS32_REV: bfd_reloc_code_real = 1391;
pub const BFD_RELOC_RL78_ABS32: bfd_reloc_code_real = 1390;
pub const BFD_RELOC_RL78_ABS16_REV: bfd_reloc_code_real = 1389;
pub const BFD_RELOC_RL78_ABS16: bfd_reloc_code_real = 1388;
pub const BFD_RELOC_RL78_ABS8: bfd_reloc_code_real = 1387;
pub const BFD_RELOC_RL78_OP_SHRA: bfd_reloc_code_real = 1386;
pub const BFD_RELOC_RL78_OP_AND: bfd_reloc_code_real = 1385;
pub const BFD_RELOC_RL78_OP_NEG: bfd_reloc_code_real = 1384;
pub const BFD_RELOC_RL78_OP_SUBTRACT: bfd_reloc_code_real = 1383;
pub const BFD_RELOC_RL78_SYM: bfd_reloc_code_real = 1382;
pub const BFD_RELOC_RL78_GPRELL: bfd_reloc_code_real = 1381;
pub const BFD_RELOC_RL78_GPRELW: bfd_reloc_code_real = 1380;
pub const BFD_RELOC_RL78_GPRELB: bfd_reloc_code_real = 1379;
pub const BFD_RELOC_RL78_DIFF: bfd_reloc_code_real = 1378;
pub const BFD_RELOC_RL78_DIR3U_PCREL: bfd_reloc_code_real = 1377;
pub const BFD_RELOC_RL78_24U: bfd_reloc_code_real = 1376;
pub const BFD_RELOC_RL78_16U: bfd_reloc_code_real = 1375;
pub const BFD_RELOC_RL78_8U: bfd_reloc_code_real = 1374;
pub const BFD_RELOC_RL78_32_OP: bfd_reloc_code_real = 1373;
pub const BFD_RELOC_RL78_24_OP: bfd_reloc_code_real = 1372;
pub const BFD_RELOC_RL78_16_OP: bfd_reloc_code_real = 1371;
pub const BFD_RELOC_RL78_NEG32: bfd_reloc_code_real = 1370;
pub const BFD_RELOC_RL78_NEG24: bfd_reloc_code_real = 1369;
pub const BFD_RELOC_RL78_NEG16: bfd_reloc_code_real = 1368;
pub const BFD_RELOC_RL78_NEG8: bfd_reloc_code_real = 1367;
pub const BFD_RELOC_RISCV_32_PCREL: bfd_reloc_code_real = 1366;
pub const BFD_RELOC_RISCV_SET32: bfd_reloc_code_real = 1365;
pub const BFD_RELOC_RISCV_SET16: bfd_reloc_code_real = 1364;
pub const BFD_RELOC_RISCV_SET8: bfd_reloc_code_real = 1363;
pub const BFD_RELOC_RISCV_SET6: bfd_reloc_code_real = 1362;
pub const BFD_RELOC_RISCV_SUB6: bfd_reloc_code_real = 1361;
pub const BFD_RELOC_RISCV_CFA: bfd_reloc_code_real = 1360;
pub const BFD_RELOC_RISCV_RELAX: bfd_reloc_code_real = 1359;
pub const BFD_RELOC_RISCV_TPREL_S: bfd_reloc_code_real = 1358;
pub const BFD_RELOC_RISCV_TPREL_I: bfd_reloc_code_real = 1357;
pub const BFD_RELOC_RISCV_GPREL_S: bfd_reloc_code_real = 1356;
pub const BFD_RELOC_RISCV_GPREL_I: bfd_reloc_code_real = 1355;
pub const BFD_RELOC_RISCV_RVC_LUI: bfd_reloc_code_real = 1354;
pub const BFD_RELOC_RISCV_RVC_JUMP: bfd_reloc_code_real = 1353;
pub const BFD_RELOC_RISCV_RVC_BRANCH: bfd_reloc_code_real = 1352;
pub const BFD_RELOC_RISCV_ALIGN: bfd_reloc_code_real = 1351;
pub const BFD_RELOC_RISCV_TLS_TPREL64: bfd_reloc_code_real = 1350;
pub const BFD_RELOC_RISCV_TLS_TPREL32: bfd_reloc_code_real = 1349;
pub const BFD_RELOC_RISCV_TLS_DTPREL64: bfd_reloc_code_real = 1348;
pub const BFD_RELOC_RISCV_TLS_DTPMOD64: bfd_reloc_code_real = 1347;
pub const BFD_RELOC_RISCV_TLS_DTPREL32: bfd_reloc_code_real = 1346;
pub const BFD_RELOC_RISCV_TLS_DTPMOD32: bfd_reloc_code_real = 1345;
pub const BFD_RELOC_RISCV_JMP: bfd_reloc_code_real = 1344;
pub const BFD_RELOC_RISCV_TLS_GD_HI20: bfd_reloc_code_real = 1343;
pub const BFD_RELOC_RISCV_TLS_GOT_HI20: bfd_reloc_code_real = 1342;
pub const BFD_RELOC_RISCV_GOT_HI20: bfd_reloc_code_real = 1341;
pub const BFD_RELOC_RISCV_SUB64: bfd_reloc_code_real = 1340;
pub const BFD_RELOC_RISCV_SUB32: bfd_reloc_code_real = 1339;
pub const BFD_RELOC_RISCV_SUB16: bfd_reloc_code_real = 1338;
pub const BFD_RELOC_RISCV_SUB8: bfd_reloc_code_real = 1337;
pub const BFD_RELOC_RISCV_ADD64: bfd_reloc_code_real = 1336;
pub const BFD_RELOC_RISCV_ADD32: bfd_reloc_code_real = 1335;
pub const BFD_RELOC_RISCV_ADD16: bfd_reloc_code_real = 1334;
pub const BFD_RELOC_RISCV_ADD8: bfd_reloc_code_real = 1333;
pub const BFD_RELOC_RISCV_CALL_PLT: bfd_reloc_code_real = 1332;
pub const BFD_RELOC_RISCV_CALL: bfd_reloc_code_real = 1331;
pub const BFD_RELOC_RISCV_TPREL_ADD: bfd_reloc_code_real = 1330;
pub const BFD_RELOC_RISCV_TPREL_LO12_S: bfd_reloc_code_real = 1329;
pub const BFD_RELOC_RISCV_TPREL_LO12_I: bfd_reloc_code_real = 1328;
pub const BFD_RELOC_RISCV_TPREL_HI20: bfd_reloc_code_real = 1327;
pub const BFD_RELOC_RISCV_GPREL12_S: bfd_reloc_code_real = 1326;
pub const BFD_RELOC_RISCV_GPREL12_I: bfd_reloc_code_real = 1325;
pub const BFD_RELOC_RISCV_LO12_S: bfd_reloc_code_real = 1324;
pub const BFD_RELOC_RISCV_LO12_I: bfd_reloc_code_real = 1323;
pub const BFD_RELOC_RISCV_PCREL_LO12_S: bfd_reloc_code_real = 1322;
pub const BFD_RELOC_RISCV_PCREL_LO12_I: bfd_reloc_code_real = 1321;
pub const BFD_RELOC_RISCV_PCREL_HI20: bfd_reloc_code_real = 1320;
pub const BFD_RELOC_RISCV_HI20: bfd_reloc_code_real = 1319;
pub const BFD_RELOC_AVR_PORT5: bfd_reloc_code_real = 1318;
pub const BFD_RELOC_AVR_PORT6: bfd_reloc_code_real = 1317;
pub const BFD_RELOC_AVR_LDS_STS_16: bfd_reloc_code_real = 1316;
pub const BFD_RELOC_AVR_DIFF32: bfd_reloc_code_real = 1315;
pub const BFD_RELOC_AVR_DIFF16: bfd_reloc_code_real = 1314;
pub const BFD_RELOC_AVR_DIFF8: bfd_reloc_code_real = 1313;
pub const BFD_RELOC_AVR_8_HLO: bfd_reloc_code_real = 1312;
pub const BFD_RELOC_AVR_8_HI: bfd_reloc_code_real = 1311;
pub const BFD_RELOC_AVR_8_LO: bfd_reloc_code_real = 1310;
pub const BFD_RELOC_AVR_6_ADIW: bfd_reloc_code_real = 1309;
pub const BFD_RELOC_AVR_6: bfd_reloc_code_real = 1308;
pub const BFD_RELOC_AVR_LDI: bfd_reloc_code_real = 1307;
pub const BFD_RELOC_AVR_CALL: bfd_reloc_code_real = 1306;
pub const BFD_RELOC_AVR_HH8_LDI_PM_NEG: bfd_reloc_code_real = 1305;
pub const BFD_RELOC_AVR_HI8_LDI_PM_NEG: bfd_reloc_code_real = 1304;
pub const BFD_RELOC_AVR_LO8_LDI_PM_NEG: bfd_reloc_code_real = 1303;
pub const BFD_RELOC_AVR_HH8_LDI_PM: bfd_reloc_code_real = 1302;
pub const BFD_RELOC_AVR_HI8_LDI_GS: bfd_reloc_code_real = 1301;
pub const BFD_RELOC_AVR_HI8_LDI_PM: bfd_reloc_code_real = 1300;
pub const BFD_RELOC_AVR_LO8_LDI_GS: bfd_reloc_code_real = 1299;
pub const BFD_RELOC_AVR_LO8_LDI_PM: bfd_reloc_code_real = 1298;
pub const BFD_RELOC_AVR_MS8_LDI_NEG: bfd_reloc_code_real = 1297;
pub const BFD_RELOC_AVR_HH8_LDI_NEG: bfd_reloc_code_real = 1296;
pub const BFD_RELOC_AVR_HI8_LDI_NEG: bfd_reloc_code_real = 1295;
pub const BFD_RELOC_AVR_LO8_LDI_NEG: bfd_reloc_code_real = 1294;
pub const BFD_RELOC_AVR_MS8_LDI: bfd_reloc_code_real = 1293;
pub const BFD_RELOC_AVR_HH8_LDI: bfd_reloc_code_real = 1292;
pub const BFD_RELOC_AVR_HI8_LDI: bfd_reloc_code_real = 1291;
pub const BFD_RELOC_AVR_LO8_LDI: bfd_reloc_code_real = 1290;
pub const BFD_RELOC_AVR_16_PM: bfd_reloc_code_real = 1289;
pub const BFD_RELOC_AVR_13_PCREL: bfd_reloc_code_real = 1288;
pub const BFD_RELOC_AVR_7_PCREL: bfd_reloc_code_real = 1287;
pub const BFD_RELOC_MMIX_LOCAL: bfd_reloc_code_real = 1286;
pub const BFD_RELOC_MMIX_BASE_PLUS_OFFSET: bfd_reloc_code_real = 1285;
pub const BFD_RELOC_MMIX_REG: bfd_reloc_code_real = 1284;
pub const BFD_RELOC_MMIX_REG_OR_BYTE: bfd_reloc_code_real = 1283;
pub const BFD_RELOC_MMIX_ADDR27: bfd_reloc_code_real = 1282;
pub const BFD_RELOC_MMIX_ADDR19: bfd_reloc_code_real = 1281;
pub const BFD_RELOC_MMIX_JMP_3: bfd_reloc_code_real = 1280;
pub const BFD_RELOC_MMIX_JMP_2: bfd_reloc_code_real = 1279;
pub const BFD_RELOC_MMIX_JMP_1: bfd_reloc_code_real = 1278;
pub const BFD_RELOC_MMIX_JMP: bfd_reloc_code_real = 1277;
pub const BFD_RELOC_MMIX_PUSHJ_STUBBABLE: bfd_reloc_code_real = 1276;
pub const BFD_RELOC_MMIX_PUSHJ_3: bfd_reloc_code_real = 1275;
pub const BFD_RELOC_MMIX_PUSHJ_2: bfd_reloc_code_real = 1274;
pub const BFD_RELOC_MMIX_PUSHJ_1: bfd_reloc_code_real = 1273;
pub const BFD_RELOC_MMIX_PUSHJ: bfd_reloc_code_real = 1272;
pub const BFD_RELOC_MMIX_CBRANCH_3: bfd_reloc_code_real = 1271;
pub const BFD_RELOC_MMIX_CBRANCH_2: bfd_reloc_code_real = 1270;
pub const BFD_RELOC_MMIX_CBRANCH_1: bfd_reloc_code_real = 1269;
pub const BFD_RELOC_MMIX_CBRANCH_J: bfd_reloc_code_real = 1268;
pub const BFD_RELOC_MMIX_CBRANCH: bfd_reloc_code_real = 1267;
pub const BFD_RELOC_MMIX_GETA_3: bfd_reloc_code_real = 1266;
pub const BFD_RELOC_MMIX_GETA_2: bfd_reloc_code_real = 1265;
pub const BFD_RELOC_MMIX_GETA_1: bfd_reloc_code_real = 1264;
pub const BFD_RELOC_MMIX_GETA: bfd_reloc_code_real = 1263;
pub const BFD_RELOC_METAG_TLS_LE_LO16: bfd_reloc_code_real = 1262;
pub const BFD_RELOC_METAG_TLS_LE_HI16: bfd_reloc_code_real = 1261;
pub const BFD_RELOC_METAG_TLS_LE: bfd_reloc_code_real = 1260;
pub const BFD_RELOC_METAG_TLS_DTPOFF: bfd_reloc_code_real = 1259;
pub const BFD_RELOC_METAG_TLS_DTPMOD: bfd_reloc_code_real = 1258;
pub const BFD_RELOC_METAG_TLS_TPOFF: bfd_reloc_code_real = 1257;
pub const BFD_RELOC_METAG_TLS_IENONPIC_LO16: bfd_reloc_code_real = 1256;
pub const BFD_RELOC_METAG_TLS_IENONPIC_HI16: bfd_reloc_code_real = 1255;
pub const BFD_RELOC_METAG_TLS_IENONPIC: bfd_reloc_code_real = 1254;
pub const BFD_RELOC_METAG_TLS_IE: bfd_reloc_code_real = 1253;
pub const BFD_RELOC_METAG_TLS_LDO: bfd_reloc_code_real = 1252;
pub const BFD_RELOC_METAG_TLS_LDO_LO16: bfd_reloc_code_real = 1251;
pub const BFD_RELOC_METAG_TLS_LDO_HI16: bfd_reloc_code_real = 1250;
pub const BFD_RELOC_METAG_TLS_LDM: bfd_reloc_code_real = 1249;
pub const BFD_RELOC_METAG_TLS_GD: bfd_reloc_code_real = 1248;
pub const BFD_RELOC_METAG_GLOB_DAT: bfd_reloc_code_real = 1247;
pub const BFD_RELOC_METAG_RELATIVE: bfd_reloc_code_real = 1246;
pub const BFD_RELOC_METAG_JMP_SLOT: bfd_reloc_code_real = 1245;
pub const BFD_RELOC_METAG_COPY: bfd_reloc_code_real = 1244;
pub const BFD_RELOC_METAG_PLT: bfd_reloc_code_real = 1243;
pub const BFD_RELOC_METAG_GOTOFF: bfd_reloc_code_real = 1242;
pub const BFD_RELOC_METAG_RELBRANCH_PLT: bfd_reloc_code_real = 1241;
pub const BFD_RELOC_METAG_LO16_PLT: bfd_reloc_code_real = 1240;
pub const BFD_RELOC_METAG_HI16_PLT: bfd_reloc_code_real = 1239;
pub const BFD_RELOC_METAG_LO16_GOTPC: bfd_reloc_code_real = 1238;
pub const BFD_RELOC_METAG_HI16_GOTPC: bfd_reloc_code_real = 1237;
pub const BFD_RELOC_METAG_GETSET_GOT: bfd_reloc_code_real = 1236;
pub const BFD_RELOC_METAG_GETSET_GOTOFF: bfd_reloc_code_real = 1235;
pub const BFD_RELOC_METAG_LO16_GOTOFF: bfd_reloc_code_real = 1234;
pub const BFD_RELOC_METAG_HI16_GOTOFF: bfd_reloc_code_real = 1233;
pub const BFD_RELOC_METAG_REL16: bfd_reloc_code_real = 1232;
pub const BFD_RELOC_METAG_REL8: bfd_reloc_code_real = 1231;
pub const BFD_RELOC_METAG_LOOG: bfd_reloc_code_real = 1230;
pub const BFD_RELOC_METAG_HIOG: bfd_reloc_code_real = 1229;
pub const BFD_RELOC_METAG_GETSETOFF: bfd_reloc_code_real = 1228;
pub const BFD_RELOC_METAG_RELBRANCH: bfd_reloc_code_real = 1227;
pub const BFD_RELOC_METAG_LOADDR16: bfd_reloc_code_real = 1226;
pub const BFD_RELOC_METAG_HIADDR16: bfd_reloc_code_real = 1225;
pub const BFD_RELOC_MEP_GNU_VTENTRY: bfd_reloc_code_real = 1224;
pub const BFD_RELOC_MEP_GNU_VTINHERIT: bfd_reloc_code_real = 1223;
pub const BFD_RELOC_MEP_ADDR24A4: bfd_reloc_code_real = 1222;
pub const BFD_RELOC_MEP_UIMM24: bfd_reloc_code_real = 1221;
pub const BFD_RELOC_MEP_TPREL7A4: bfd_reloc_code_real = 1220;
pub const BFD_RELOC_MEP_TPREL7A2: bfd_reloc_code_real = 1219;
pub const BFD_RELOC_MEP_TPREL7: bfd_reloc_code_real = 1218;
pub const BFD_RELOC_MEP_TPREL: bfd_reloc_code_real = 1217;
pub const BFD_RELOC_MEP_GPREL: bfd_reloc_code_real = 1216;
pub const BFD_RELOC_MEP_HI16S: bfd_reloc_code_real = 1215;
pub const BFD_RELOC_MEP_HI16U: bfd_reloc_code_real = 1214;
pub const BFD_RELOC_MEP_LOW16: bfd_reloc_code_real = 1213;
pub const BFD_RELOC_MEP_PCABS24A2: bfd_reloc_code_real = 1212;
pub const BFD_RELOC_MEP_PCREL24A2: bfd_reloc_code_real = 1211;
pub const BFD_RELOC_MEP_PCREL17A2: bfd_reloc_code_real = 1210;
pub const BFD_RELOC_MEP_PCREL12A2: bfd_reloc_code_real = 1209;
pub const BFD_RELOC_MEP_PCREL8A2: bfd_reloc_code_real = 1208;
pub const BFD_RELOC_MEP_32: bfd_reloc_code_real = 1207;
pub const BFD_RELOC_MEP_16: bfd_reloc_code_real = 1206;
pub const BFD_RELOC_MEP_8: bfd_reloc_code_real = 1205;
pub const BFD_RELOC_MCORE_RVA: bfd_reloc_code_real = 1204;
pub const BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2: bfd_reloc_code_real = 1203;
pub const BFD_RELOC_MCORE_PCREL_32: bfd_reloc_code_real = 1202;
pub const BFD_RELOC_MCORE_PCREL_IMM4BY2: bfd_reloc_code_real = 1201;
pub const BFD_RELOC_MCORE_PCREL_IMM11BY2: bfd_reloc_code_real = 1200;
pub const BFD_RELOC_MCORE_PCREL_IMM8BY4: bfd_reloc_code_real = 1199;
pub const BFD_RELOC_FR30_12_PCREL: bfd_reloc_code_real = 1198;
pub const BFD_RELOC_FR30_9_PCREL: bfd_reloc_code_real = 1197;
pub const BFD_RELOC_FR30_10_IN_8: bfd_reloc_code_real = 1196;
pub const BFD_RELOC_FR30_9_IN_8: bfd_reloc_code_real = 1195;
pub const BFD_RELOC_FR30_8_IN_8: bfd_reloc_code_real = 1194;
pub const BFD_RELOC_FR30_6_IN_4: bfd_reloc_code_real = 1193;
pub const BFD_RELOC_FR30_20: bfd_reloc_code_real = 1192;
pub const BFD_RELOC_FR30_48: bfd_reloc_code_real = 1191;
pub const BFD_RELOC_C6000_NOCMP: bfd_reloc_code_real = 1190;
pub const BFD_RELOC_C6000_FPHEAD: bfd_reloc_code_real = 1189;
pub const BFD_RELOC_C6000_ALIGN: bfd_reloc_code_real = 1188;
pub const BFD_RELOC_C6000_PCR_L16: bfd_reloc_code_real = 1187;
pub const BFD_RELOC_C6000_PCR_H16: bfd_reloc_code_real = 1186;
pub const BFD_RELOC_C6000_EHTYPE: bfd_reloc_code_real = 1185;
pub const BFD_RELOC_C6000_JUMP_SLOT: bfd_reloc_code_real = 1184;
pub const BFD_RELOC_C6000_COPY: bfd_reloc_code_real = 1183;
pub const BFD_RELOC_C6000_PREL31: bfd_reloc_code_real = 1182;
pub const BFD_RELOC_C6000_DSBT_INDEX: bfd_reloc_code_real = 1181;
pub const BFD_RELOC_C6000_SBR_GOT_H16_W: bfd_reloc_code_real = 1180;
pub const BFD_RELOC_C6000_SBR_GOT_L16_W: bfd_reloc_code_real = 1179;
pub const BFD_RELOC_C6000_SBR_GOT_U15_W: bfd_reloc_code_real = 1178;
pub const BFD_RELOC_C6000_SBR_H16_W: bfd_reloc_code_real = 1177;
pub const BFD_RELOC_C6000_SBR_H16_H: bfd_reloc_code_real = 1176;
pub const BFD_RELOC_C6000_SBR_H16_B: bfd_reloc_code_real = 1175;
pub const BFD_RELOC_C6000_SBR_L16_W: bfd_reloc_code_real = 1174;
pub const BFD_RELOC_C6000_SBR_L16_H: bfd_reloc_code_real = 1173;
pub const BFD_RELOC_C6000_SBR_L16_B: bfd_reloc_code_real = 1172;
pub const BFD_RELOC_C6000_SBR_S16: bfd_reloc_code_real = 1171;
pub const BFD_RELOC_C6000_SBR_U15_W: bfd_reloc_code_real = 1170;
pub const BFD_RELOC_C6000_SBR_U15_H: bfd_reloc_code_real = 1169;
pub const BFD_RELOC_C6000_SBR_U15_B: bfd_reloc_code_real = 1168;
pub const BFD_RELOC_C6000_ABS_H16: bfd_reloc_code_real = 1167;
pub const BFD_RELOC_C6000_ABS_L16: bfd_reloc_code_real = 1166;
pub const BFD_RELOC_C6000_ABS_S16: bfd_reloc_code_real = 1165;
pub const BFD_RELOC_C6000_PCR_S7: bfd_reloc_code_real = 1164;
pub const BFD_RELOC_C6000_PCR_S10: bfd_reloc_code_real = 1163;
pub const BFD_RELOC_C6000_PCR_S12: bfd_reloc_code_real = 1162;
pub const BFD_RELOC_C6000_PCR_S21: bfd_reloc_code_real = 1161;
pub const BFD_RELOC_TIC54X_MS7_OF_23: bfd_reloc_code_real = 1160;
pub const BFD_RELOC_TIC54X_16_OF_23: bfd_reloc_code_real = 1159;
pub const BFD_RELOC_TIC54X_23: bfd_reloc_code_real = 1158;
pub const BFD_RELOC_TIC54X_PARTMS9: bfd_reloc_code_real = 1157;
pub const BFD_RELOC_TIC54X_PARTLS7: bfd_reloc_code_real = 1156;
pub const BFD_RELOC_TIC30_LDP: bfd_reloc_code_real = 1155;
pub const BFD_RELOC_V850_DATA: bfd_reloc_code_real = 1154;
pub const BFD_RELOC_V850_CODE: bfd_reloc_code_real = 1153;
pub const BFD_RELOC_V850_32_GOTOFF: bfd_reloc_code_real = 1152;
pub const BFD_RELOC_V850_16_GOTOFF: bfd_reloc_code_real = 1151;
pub const BFD_RELOC_V850_RELATIVE: bfd_reloc_code_real = 1150;
pub const BFD_RELOC_V850_JMP_SLOT: bfd_reloc_code_real = 1149;
pub const BFD_RELOC_V850_GLOB_DAT: bfd_reloc_code_real = 1148;
pub const BFD_RELOC_V850_COPY: bfd_reloc_code_real = 1147;
pub const BFD_RELOC_V850_32_PLT_PCREL: bfd_reloc_code_real = 1146;
pub const BFD_RELOC_V850_22_PLT_PCREL: bfd_reloc_code_real = 1145;
pub const BFD_RELOC_V850_32_GOT: bfd_reloc_code_real = 1144;
pub const BFD_RELOC_V850_16_GOT: bfd_reloc_code_real = 1143;
pub const BFD_RELOC_V850_32_GOTPCREL: bfd_reloc_code_real = 1142;
pub const BFD_RELOC_V850_CALLT_15_16_OFFSET: bfd_reloc_code_real = 1141;
pub const BFD_RELOC_V850_LO16_S1: bfd_reloc_code_real = 1140;
pub const BFD_RELOC_V850_16_S1: bfd_reloc_code_real = 1139;
pub const BFD_RELOC_V850_16_SPLIT_OFFSET: bfd_reloc_code_real = 1138;
pub const BFD_RELOC_V850_32_ABS: bfd_reloc_code_real = 1137;
pub const BFD_RELOC_V850_32_PCREL: bfd_reloc_code_real = 1136;
pub const BFD_RELOC_V850_23: bfd_reloc_code_real = 1135;
pub const BFD_RELOC_V850_17_PCREL: bfd_reloc_code_real = 1134;
pub const BFD_RELOC_V850_16_PCREL: bfd_reloc_code_real = 1133;
pub const BFD_RELOC_V850_LO16_SPLIT_OFFSET: bfd_reloc_code_real = 1132;
pub const BFD_RELOC_V850_ALIGN: bfd_reloc_code_real = 1131;
pub const BFD_RELOC_V850_LONGJUMP: bfd_reloc_code_real = 1130;
pub const BFD_RELOC_V850_LONGCALL: bfd_reloc_code_real = 1129;
pub const BFD_RELOC_V850_CALLT_16_16_OFFSET: bfd_reloc_code_real = 1128;
pub const BFD_RELOC_V850_CALLT_6_7_OFFSET: bfd_reloc_code_real = 1127;
pub const BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET: bfd_reloc_code_real = 1126;
pub const BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET: bfd_reloc_code_real = 1125;
pub const BFD_RELOC_V850_TDA_4_4_OFFSET: bfd_reloc_code_real = 1124;
pub const BFD_RELOC_V850_TDA_4_5_OFFSET: bfd_reloc_code_real = 1123;
pub const BFD_RELOC_V850_TDA_16_16_OFFSET: bfd_reloc_code_real = 1122;
pub const BFD_RELOC_V850_TDA_7_7_OFFSET: bfd_reloc_code_real = 1121;
pub const BFD_RELOC_V850_TDA_7_8_OFFSET: bfd_reloc_code_real = 1120;
pub const BFD_RELOC_V850_TDA_6_8_OFFSET: bfd_reloc_code_real = 1119;
pub const BFD_RELOC_V850_ZDA_15_16_OFFSET: bfd_reloc_code_real = 1118;
pub const BFD_RELOC_V850_ZDA_16_16_OFFSET: bfd_reloc_code_real = 1117;
pub const BFD_RELOC_V850_SDA_15_16_OFFSET: bfd_reloc_code_real = 1116;
pub const BFD_RELOC_V850_SDA_16_16_OFFSET: bfd_reloc_code_real = 1115;
pub const BFD_RELOC_V850_22_PCREL: bfd_reloc_code_real = 1114;
pub const BFD_RELOC_V850_9_PCREL: bfd_reloc_code_real = 1113;
pub const BFD_RELOC_NDS32_LSI: bfd_reloc_code_real = 1112;
pub const BFD_RELOC_NDS32_GROUP: bfd_reloc_code_real = 1111;
pub const BFD_RELOC_NDS32_REMOVE: bfd_reloc_code_real = 1110;
pub const BFD_RELOC_NDS32_TLS_DESC_MEM: bfd_reloc_code_real = 1109;
pub const BFD_RELOC_NDS32_TLS_DESC_CALL: bfd_reloc_code_real = 1108;
pub const BFD_RELOC_NDS32_TLS_DESC_FUNC: bfd_reloc_code_real = 1107;
pub const BFD_RELOC_NDS32_TLS_DESC_ADD: bfd_reloc_code_real = 1106;
pub const BFD_RELOC_NDS32_TLS_DESC_SDA17S2: bfd_reloc_code_real = 1105;
pub const BFD_RELOC_NDS32_TLS_DESC_20: bfd_reloc_code_real = 1104;
pub const BFD_RELOC_NDS32_TLS_DESC_LO12: bfd_reloc_code_real = 1103;
pub const BFD_RELOC_NDS32_TLS_DESC_HI20: bfd_reloc_code_real = 1102;
pub const BFD_RELOC_NDS32_TLS_DESC: bfd_reloc_code_real = 1101;
pub const BFD_RELOC_NDS32_TLS_IEGP_LW: bfd_reloc_code_real = 1100;
pub const BFD_RELOC_NDS32_TLS_IEGP_LO12S2: bfd_reloc_code_real = 1099;
pub const BFD_RELOC_NDS32_TLS_IEGP_LO12: bfd_reloc_code_real = 1098;
pub const BFD_RELOC_NDS32_TLS_IEGP_HI20: bfd_reloc_code_real = 1097;
pub const BFD_RELOC_NDS32_TLS_IE_LO12S2: bfd_reloc_code_real = 1096;
pub const BFD_RELOC_NDS32_TLS_IE_LO12: bfd_reloc_code_real = 1095;
pub const BFD_RELOC_NDS32_TLS_IE_HI20: bfd_reloc_code_real = 1094;
pub const BFD_RELOC_NDS32_TLS_LE_LS: bfd_reloc_code_real = 1093;
pub const BFD_RELOC_NDS32_TLS_LE_ADD: bfd_reloc_code_real = 1092;
pub const BFD_RELOC_NDS32_TLS_LE_15S2: bfd_reloc_code_real = 1091;
pub const BFD_RELOC_NDS32_TLS_LE_15S1: bfd_reloc_code_real = 1090;
pub const BFD_RELOC_NDS32_TLS_LE_15S0: bfd_reloc_code_real = 1089;
pub const BFD_RELOC_NDS32_TLS_LE_20: bfd_reloc_code_real = 1088;
pub const BFD_RELOC_NDS32_TLS_LE_LO12: bfd_reloc_code_real = 1087;
pub const BFD_RELOC_NDS32_TLS_LE_HI20: bfd_reloc_code_real = 1086;
pub const BFD_RELOC_NDS32_GOTTPOFF: bfd_reloc_code_real = 1085;
pub const BFD_RELOC_NDS32_TPOFF: bfd_reloc_code_real = 1084;
pub const BFD_RELOC_NDS32_10IFCU_PCREL: bfd_reloc_code_real = 1083;
pub const BFD_RELOC_NDS32_17IFC_PCREL: bfd_reloc_code_real = 1082;
pub const BFD_RELOC_NDS32_TRAN: bfd_reloc_code_real = 1081;
pub const BFD_RELOC_NDS32_DATA: bfd_reloc_code_real = 1080;
pub const BFD_RELOC_NDS32_25_ABS: bfd_reloc_code_real = 1079;
pub const BFD_RELOC_NDS32_EMPTY: bfd_reloc_code_real = 1078;
pub const BFD_RELOC_NDS32_DIFF_ULEB128: bfd_reloc_code_real = 1077;
pub const BFD_RELOC_NDS32_DIFF32: bfd_reloc_code_real = 1076;
pub const BFD_RELOC_NDS32_DIFF16: bfd_reloc_code_real = 1075;
pub const BFD_RELOC_NDS32_DIFF8: bfd_reloc_code_real = 1074;
pub const BFD_RELOC_NDS32_SUBTRAHEND: bfd_reloc_code_real = 1073;
pub const BFD_RELOC_NDS32_MINUEND: bfd_reloc_code_real = 1072;
pub const BFD_RELOC_NDS32_RELAX_REGION_END: bfd_reloc_code_real = 1071;
pub const BFD_RELOC_NDS32_RELAX_REGION_BEGIN: bfd_reloc_code_real = 1070;
pub const BFD_RELOC_NDS32_PLTBLOCK: bfd_reloc_code_real = 1069;
pub const BFD_RELOC_NDS32_PTR_RESOLVED: bfd_reloc_code_real = 1068;
pub const BFD_RELOC_NDS32_PTR_COUNT: bfd_reloc_code_real = 1067;
pub const BFD_RELOC_NDS32_PTR: bfd_reloc_code_real = 1066;
pub const BFD_RELOC_NDS32_MULCALL_SUFF: bfd_reloc_code_real = 1065;
pub const BFD_RELOC_NDS32_PLT_GOT_SUFF: bfd_reloc_code_real = 1064;
pub const BFD_RELOC_NDS32_GOTOFF_SUFF: bfd_reloc_code_real = 1063;
pub const BFD_RELOC_NDS32_GOT_SUFF: bfd_reloc_code_real = 1062;
pub const BFD_RELOC_NDS32_RELAX_ENTRY: bfd_reloc_code_real = 1061;
pub const BFD_RELOC_NDS32_SDA_FP7U2_RELA: bfd_reloc_code_real = 1060;
pub const BFD_RELOC_NDS32_10_UPCREL: bfd_reloc_code_real = 1059;
pub const BFD_RELOC_NDS32_5: bfd_reloc_code_real = 1058;
pub const BFD_RELOC_NDS32_GOT17S2: bfd_reloc_code_real = 1057;
pub const BFD_RELOC_NDS32_GOT15S2: bfd_reloc_code_real = 1056;
pub const BFD_RELOC_NDS32_GOTOFF_LO19: bfd_reloc_code_real = 1055;
pub const BFD_RELOC_NDS32_GOTOFF_LO15: bfd_reloc_code_real = 1054;
pub const BFD_RELOC_NDS32_GOT_LO19: bfd_reloc_code_real = 1053;
pub const BFD_RELOC_NDS32_GOT_LO15: bfd_reloc_code_real = 1052;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO19: bfd_reloc_code_real = 1051;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO15: bfd_reloc_code_real = 1050;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO20: bfd_reloc_code_real = 1049;
pub const BFD_RELOC_NDS32_UPDATE_TA: bfd_reloc_code_real = 1048;
pub const BFD_RELOC_NDS32_DWARF2_LEB: bfd_reloc_code_real = 1047;
pub const BFD_RELOC_NDS32_DWARF2_OP2: bfd_reloc_code_real = 1046;
pub const BFD_RELOC_NDS32_DWARF2_OP1: bfd_reloc_code_real = 1045;
pub const BFD_RELOC_NDS32_LO12S2_SP: bfd_reloc_code_real = 1044;
pub const BFD_RELOC_NDS32_LO12S2_DP: bfd_reloc_code_real = 1043;
pub const BFD_RELOC_NDS32_SDA12S2_SP: bfd_reloc_code_real = 1042;
pub const BFD_RELOC_NDS32_SDA12S2_DP: bfd_reloc_code_real = 1041;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO12: bfd_reloc_code_real = 1040;
pub const BFD_RELOC_NDS32_PLT_GOTREL_HI20: bfd_reloc_code_real = 1039;
pub const BFD_RELOC_NDS32_PLTREL_LO12: bfd_reloc_code_real = 1038;
pub const BFD_RELOC_NDS32_PLTREL_HI20: bfd_reloc_code_real = 1037;
pub const BFD_RELOC_NDS32_LONGJUMP7: bfd_reloc_code_real = 1036;
pub const BFD_RELOC_NDS32_LONGJUMP6: bfd_reloc_code_real = 1035;
pub const BFD_RELOC_NDS32_LONGJUMP5: bfd_reloc_code_real = 1034;
pub const BFD_RELOC_NDS32_LONGJUMP4: bfd_reloc_code_real = 1033;
pub const BFD_RELOC_NDS32_LONGCALL6: bfd_reloc_code_real = 1032;
pub const BFD_RELOC_NDS32_LONGCALL5: bfd_reloc_code_real = 1031;
pub const BFD_RELOC_NDS32_LONGCALL4: bfd_reloc_code_real = 1030;
pub const BFD_RELOC_NDS32_25_FIXED: bfd_reloc_code_real = 1029;
pub const BFD_RELOC_NDS32_17_FIXED: bfd_reloc_code_real = 1028;
pub const BFD_RELOC_NDS32_15_FIXED: bfd_reloc_code_real = 1027;
pub const BFD_RELOC_NDS32_9_FIXED: bfd_reloc_code_real = 1026;
pub const BFD_RELOC_NDS32_LOADSTORE: bfd_reloc_code_real = 1025;
pub const BFD_RELOC_NDS32_LONGJUMP3: bfd_reloc_code_real = 1024;
pub const BFD_RELOC_NDS32_LONGJUMP2: bfd_reloc_code_real = 1023;
pub const BFD_RELOC_NDS32_LONGJUMP1: bfd_reloc_code_real = 1022;
pub const BFD_RELOC_NDS32_LONGCALL3: bfd_reloc_code_real = 1021;
pub const BFD_RELOC_NDS32_LONGCALL2: bfd_reloc_code_real = 1020;
pub const BFD_RELOC_NDS32_LONGCALL1: bfd_reloc_code_real = 1019;
pub const BFD_RELOC_NDS32_LABEL: bfd_reloc_code_real = 1018;
pub const BFD_RELOC_NDS32_INSN16: bfd_reloc_code_real = 1017;
pub const BFD_RELOC_NDS32_GOTPC_LO12: bfd_reloc_code_real = 1016;
pub const BFD_RELOC_NDS32_GOTPC_HI20: bfd_reloc_code_real = 1015;
pub const BFD_RELOC_NDS32_GOT_LO12: bfd_reloc_code_real = 1014;
pub const BFD_RELOC_NDS32_GOT_HI20: bfd_reloc_code_real = 1013;
pub const BFD_RELOC_NDS32_GOTPC20: bfd_reloc_code_real = 1012;
pub const BFD_RELOC_NDS32_GOTOFF_LO12: bfd_reloc_code_real = 1011;
pub const BFD_RELOC_NDS32_GOTOFF_HI20: bfd_reloc_code_real = 1010;
pub const BFD_RELOC_NDS32_GOTOFF: bfd_reloc_code_real = 1009;
pub const BFD_RELOC_NDS32_RELATIVE: bfd_reloc_code_real = 1008;
pub const BFD_RELOC_NDS32_JMP_SLOT: bfd_reloc_code_real = 1007;
pub const BFD_RELOC_NDS32_GLOB_DAT: bfd_reloc_code_real = 1006;
pub const BFD_RELOC_NDS32_COPY: bfd_reloc_code_real = 1005;
pub const BFD_RELOC_NDS32_25_PLTREL: bfd_reloc_code_real = 1004;
pub const BFD_RELOC_NDS32_9_PLTREL: bfd_reloc_code_real = 1003;
pub const BFD_RELOC_NDS32_GOT20: bfd_reloc_code_real = 1002;
pub const BFD_RELOC_NDS32_SDA19S0: bfd_reloc_code_real = 1001;
pub const BFD_RELOC_NDS32_SDA18S1: bfd_reloc_code_real = 1000;
pub const BFD_RELOC_NDS32_SDA17S2: bfd_reloc_code_real = 999;
pub const BFD_RELOC_NDS32_SDA16S3: bfd_reloc_code_real = 998;
pub const BFD_RELOC_NDS32_SDA15S0: bfd_reloc_code_real = 997;
pub const BFD_RELOC_NDS32_SDA15S1: bfd_reloc_code_real = 996;
pub const BFD_RELOC_NDS32_SDA15S2: bfd_reloc_code_real = 995;
pub const BFD_RELOC_NDS32_SDA15S3: bfd_reloc_code_real = 994;
pub const BFD_RELOC_NDS32_LO12S0_ORI: bfd_reloc_code_real = 993;
pub const BFD_RELOC_NDS32_LO12S0: bfd_reloc_code_real = 992;
pub const BFD_RELOC_NDS32_LO12S1: bfd_reloc_code_real = 991;
pub const BFD_RELOC_NDS32_LO12S2: bfd_reloc_code_real = 990;
pub const BFD_RELOC_NDS32_LO12S3: bfd_reloc_code_real = 989;
pub const BFD_RELOC_NDS32_HI20: bfd_reloc_code_real = 988;
pub const BFD_RELOC_NDS32_25_PCREL: bfd_reloc_code_real = 987;
pub const BFD_RELOC_NDS32_17_PCREL: bfd_reloc_code_real = 986;
pub const BFD_RELOC_NDS32_15_PCREL: bfd_reloc_code_real = 985;
pub const BFD_RELOC_NDS32_WORD_9_PCREL: bfd_reloc_code_real = 984;
pub const BFD_RELOC_NDS32_9_PCREL: bfd_reloc_code_real = 983;
pub const BFD_RELOC_NDS32_20: bfd_reloc_code_real = 982;
pub const BFD_RELOC_M32R_GOTPC_LO: bfd_reloc_code_real = 981;
pub const BFD_RELOC_M32R_GOTPC_HI_SLO: bfd_reloc_code_real = 980;
pub const BFD_RELOC_M32R_GOTPC_HI_ULO: bfd_reloc_code_real = 979;
pub const BFD_RELOC_M32R_GOT16_LO: bfd_reloc_code_real = 978;
pub const BFD_RELOC_M32R_GOT16_HI_SLO: bfd_reloc_code_real = 977;
pub const BFD_RELOC_M32R_GOT16_HI_ULO: bfd_reloc_code_real = 976;
pub const BFD_RELOC_M32R_GOTPC24: bfd_reloc_code_real = 975;
pub const BFD_RELOC_M32R_GOTOFF_LO: bfd_reloc_code_real = 974;
pub const BFD_RELOC_M32R_GOTOFF_HI_SLO: bfd_reloc_code_real = 973;
pub const BFD_RELOC_M32R_GOTOFF_HI_ULO: bfd_reloc_code_real = 972;
pub const BFD_RELOC_M32R_GOTOFF: bfd_reloc_code_real = 971;
pub const BFD_RELOC_M32R_RELATIVE: bfd_reloc_code_real = 970;
pub const BFD_RELOC_M32R_JMP_SLOT: bfd_reloc_code_real = 969;
pub const BFD_RELOC_M32R_GLOB_DAT: bfd_reloc_code_real = 968;
pub const BFD_RELOC_M32R_COPY: bfd_reloc_code_real = 967;
pub const BFD_RELOC_M32R_26_PLTREL: bfd_reloc_code_real = 966;
pub const BFD_RELOC_M32R_GOT24: bfd_reloc_code_real = 965;
pub const BFD_RELOC_M32R_SDA16: bfd_reloc_code_real = 964;
pub const BFD_RELOC_M32R_LO16: bfd_reloc_code_real = 963;
pub const BFD_RELOC_M32R_HI16_SLO: bfd_reloc_code_real = 962;
pub const BFD_RELOC_M32R_HI16_ULO: bfd_reloc_code_real = 961;
pub const BFD_RELOC_M32R_26_PCREL: bfd_reloc_code_real = 960;
pub const BFD_RELOC_M32R_18_PCREL: bfd_reloc_code_real = 959;
pub const BFD_RELOC_M32R_10_PCREL: bfd_reloc_code_real = 958;
pub const BFD_RELOC_M32R_24: bfd_reloc_code_real = 957;
pub const BFD_RELOC_M32C_RL_2ADDR: bfd_reloc_code_real = 956;
pub const BFD_RELOC_M32C_RL_1ADDR: bfd_reloc_code_real = 955;
pub const BFD_RELOC_M32C_RL_JUMP: bfd_reloc_code_real = 954;
pub const BFD_RELOC_M32C_HI8: bfd_reloc_code_real = 953;
pub const BFD_RELOC_DLX_JMP26: bfd_reloc_code_real = 952;
pub const BFD_RELOC_DLX_LO16: bfd_reloc_code_real = 951;
pub const BFD_RELOC_DLX_HI16_S: bfd_reloc_code_real = 950;
pub const BFD_RELOC_D30V_32_PCREL: bfd_reloc_code_real = 949;
pub const BFD_RELOC_D30V_32: bfd_reloc_code_real = 948;
pub const BFD_RELOC_D30V_21_PCREL_R: bfd_reloc_code_real = 947;
pub const BFD_RELOC_D30V_21_PCREL: bfd_reloc_code_real = 946;
pub const BFD_RELOC_D30V_21: bfd_reloc_code_real = 945;
pub const BFD_RELOC_D30V_15_PCREL_R: bfd_reloc_code_real = 944;
pub const BFD_RELOC_D30V_15_PCREL: bfd_reloc_code_real = 943;
pub const BFD_RELOC_D30V_15: bfd_reloc_code_real = 942;
pub const BFD_RELOC_D30V_9_PCREL_R: bfd_reloc_code_real = 941;
pub const BFD_RELOC_D30V_9_PCREL: bfd_reloc_code_real = 940;
pub const BFD_RELOC_D30V_6: bfd_reloc_code_real = 939;
pub const BFD_RELOC_D10V_18_PCREL: bfd_reloc_code_real = 938;
pub const BFD_RELOC_D10V_18: bfd_reloc_code_real = 937;
pub const BFD_RELOC_D10V_10_PCREL_L: bfd_reloc_code_real = 936;
pub const BFD_RELOC_D10V_10_PCREL_R: bfd_reloc_code_real = 935;
pub const BFD_ARELOC_BFIN_ADDR: bfd_reloc_code_real = 934;
pub const BFD_ARELOC_BFIN_HWPAGE: bfd_reloc_code_real = 933;
pub const BFD_ARELOC_BFIN_PAGE: bfd_reloc_code_real = 932;
pub const BFD_ARELOC_BFIN_COMP: bfd_reloc_code_real = 931;
pub const BFD_ARELOC_BFIN_NEG: bfd_reloc_code_real = 930;
pub const BFD_ARELOC_BFIN_LEN: bfd_reloc_code_real = 929;
pub const BFD_ARELOC_BFIN_LOR: bfd_reloc_code_real = 928;
pub const BFD_ARELOC_BFIN_LAND: bfd_reloc_code_real = 927;
pub const BFD_ARELOC_BFIN_XOR: bfd_reloc_code_real = 926;
pub const BFD_ARELOC_BFIN_OR: bfd_reloc_code_real = 925;
pub const BFD_ARELOC_BFIN_AND: bfd_reloc_code_real = 924;
pub const BFD_ARELOC_BFIN_RSHIFT: bfd_reloc_code_real = 923;
pub const BFD_ARELOC_BFIN_LSHIFT: bfd_reloc_code_real = 922;
pub const BFD_ARELOC_BFIN_MOD: bfd_reloc_code_real = 921;
pub const BFD_ARELOC_BFIN_DIV: bfd_reloc_code_real = 920;
pub const BFD_ARELOC_BFIN_MULT: bfd_reloc_code_real = 919;
pub const BFD_ARELOC_BFIN_SUB: bfd_reloc_code_real = 918;
pub const BFD_ARELOC_BFIN_ADD: bfd_reloc_code_real = 917;
pub const BFD_ARELOC_BFIN_CONST: bfd_reloc_code_real = 916;
pub const BFD_ARELOC_BFIN_PUSH: bfd_reloc_code_real = 915;
pub const BFD_RELOC_BFIN_PLTPC: bfd_reloc_code_real = 914;
pub const BFD_RELOC_BFIN_GOT: bfd_reloc_code_real = 913;
pub const BFD_RELOC_BFIN_GOTOFFLO: bfd_reloc_code_real = 912;
pub const BFD_RELOC_BFIN_GOTOFFHI: bfd_reloc_code_real = 911;
pub const BFD_RELOC_BFIN_GOTOFF17M4: bfd_reloc_code_real = 910;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO: bfd_reloc_code_real = 909;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI: bfd_reloc_code_real = 908;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4: bfd_reloc_code_real = 907;
pub const BFD_RELOC_BFIN_FUNCDESC_VALUE: bfd_reloc_code_real = 906;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTLO: bfd_reloc_code_real = 905;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTHI: bfd_reloc_code_real = 904;
pub const BFD_RELOC_BFIN_FUNCDESC_GOT17M4: bfd_reloc_code_real = 903;
pub const BFD_RELOC_BFIN_FUNCDESC: bfd_reloc_code_real = 902;
pub const BFD_RELOC_BFIN_GOTLO: bfd_reloc_code_real = 901;
pub const BFD_RELOC_BFIN_GOTHI: bfd_reloc_code_real = 900;
pub const BFD_RELOC_BFIN_GOT17M4: bfd_reloc_code_real = 899;
pub const BFD_RELOC_BFIN_24_PCREL_JUMP_L: bfd_reloc_code_real = 898;
pub const BFD_RELOC_BFIN_24_PCREL_CALL_X: bfd_reloc_code_real = 897;
pub const BFD_RELOC_BFIN_12_PCREL_JUMP_S: bfd_reloc_code_real = 896;
pub const BFD_RELOC_BFIN_12_PCREL_JUMP: bfd_reloc_code_real = 895;
pub const BFD_RELOC_BFIN_11_PCREL: bfd_reloc_code_real = 894;
pub const BFD_RELOC_BFIN_10_PCREL: bfd_reloc_code_real = 893;
pub const BFD_RELOC_BFIN_16_LOW: bfd_reloc_code_real = 892;
pub const BFD_RELOC_BFIN_5_PCREL: bfd_reloc_code_real = 891;
pub const BFD_RELOC_BFIN_4_PCREL: bfd_reloc_code_real = 890;
pub const BFD_RELOC_BFIN_16_HIGH: bfd_reloc_code_real = 889;
pub const BFD_RELOC_BFIN_16_IMM: bfd_reloc_code_real = 888;
pub const BFD_RELOC_ARC_JLI_SECTOFF: bfd_reloc_code_real = 887;
pub const BFD_RELOC_ARC_NPS_CMEM16: bfd_reloc_code_real = 886;
pub const BFD_RELOC_ARC_S21H_PCREL_PLT: bfd_reloc_code_real = 885;
pub const BFD_RELOC_ARC_S25W_PCREL_PLT: bfd_reloc_code_real = 884;
pub const BFD_RELOC_ARC_TLS_LE_32: bfd_reloc_code_real = 883;
pub const BFD_RELOC_ARC_TLS_LE_S9: bfd_reloc_code_real = 882;
pub const BFD_RELOC_ARC_TLS_DTPOFF_S9: bfd_reloc_code_real = 881;
pub const BFD_RELOC_ARC_TLS_DTPOFF: bfd_reloc_code_real = 880;
pub const BFD_RELOC_ARC_TLS_IE_GOT: bfd_reloc_code_real = 879;
pub const BFD_RELOC_ARC_TLS_GD_CALL: bfd_reloc_code_real = 878;
pub const BFD_RELOC_ARC_TLS_GD_LD: bfd_reloc_code_real = 877;
pub const BFD_RELOC_ARC_TLS_GD_GOT: bfd_reloc_code_real = 876;
pub const BFD_RELOC_ARC_TLS_TPOFF: bfd_reloc_code_real = 875;
pub const BFD_RELOC_ARC_TLS_DTPMOD: bfd_reloc_code_real = 874;
pub const BFD_RELOC_ARC_S25H_PCREL_PLT: bfd_reloc_code_real = 873;
pub const BFD_RELOC_ARC_S21W_PCREL_PLT: bfd_reloc_code_real = 872;
pub const BFD_RELOC_ARC_GOTPC: bfd_reloc_code_real = 871;
pub const BFD_RELOC_ARC_GOTOFF: bfd_reloc_code_real = 870;
pub const BFD_RELOC_ARC_RELATIVE: bfd_reloc_code_real = 869;
pub const BFD_RELOC_ARC_JMP_SLOT: bfd_reloc_code_real = 868;
pub const BFD_RELOC_ARC_GLOB_DAT: bfd_reloc_code_real = 867;
pub const BFD_RELOC_ARC_COPY: bfd_reloc_code_real = 866;
pub const BFD_RELOC_ARC_PLT32: bfd_reloc_code_real = 865;
pub const BFD_RELOC_ARC_GOTPC32: bfd_reloc_code_real = 864;
pub const BFD_RELOC_ARC_GOT32: bfd_reloc_code_real = 863;
pub const BFD_RELOC_ARC_PC32: bfd_reloc_code_real = 862;
pub const BFD_RELOC_ARC_32_PCREL: bfd_reloc_code_real = 861;
pub const BFD_RELOC_ARC_SDA16_ST2: bfd_reloc_code_real = 860;
pub const BFD_RELOC_ARC_SDA_12: bfd_reloc_code_real = 859;
pub const BFD_RELOC_ARC_SECTOFF_2: bfd_reloc_code_real = 858;
pub const BFD_RELOC_ARC_SECTOFF_1: bfd_reloc_code_real = 857;
pub const BFD_RELOC_ARC_SECTOFF_ME_2: bfd_reloc_code_real = 856;
pub const BFD_RELOC_ARC_SECTOFF_ME_1: bfd_reloc_code_real = 855;
pub const BFD_RELOC_AC_SECTOFF_S9_2: bfd_reloc_code_real = 854;
pub const BFD_RELOC_AC_SECTOFF_S9_1: bfd_reloc_code_real = 853;
pub const BFD_RELOC_AC_SECTOFF_S9: bfd_reloc_code_real = 852;
pub const BFD_RELOC_AC_SECTOFF_U8_2: bfd_reloc_code_real = 851;
pub const BFD_RELOC_AC_SECTOFF_U8_1: bfd_reloc_code_real = 850;
pub const BFD_RELOC_AC_SECTOFF_U8: bfd_reloc_code_real = 849;
pub const BFD_RELOC_ARC_W_ME: bfd_reloc_code_real = 848;
pub const BFD_RELOC_ARC_SDA32_ME: bfd_reloc_code_real = 847;
pub const BFD_RELOC_ARC_SECTOFF_ME: bfd_reloc_code_real = 846;
pub const BFD_RELOC_ARC_N32_ME: bfd_reloc_code_real = 845;
pub const BFD_RELOC_ARC_32_ME_S: bfd_reloc_code_real = 844;
pub const BFD_RELOC_ARC_32_ME: bfd_reloc_code_real = 843;
pub const BFD_RELOC_ARC_W: bfd_reloc_code_real = 842;
pub const BFD_RELOC_ARC_S13_PCREL: bfd_reloc_code_real = 841;
pub const BFD_RELOC_ARC_SDA16_LD2: bfd_reloc_code_real = 840;
pub const BFD_RELOC_ARC_SDA16_LD1: bfd_reloc_code_real = 839;
pub const BFD_RELOC_ARC_SDA16_LD: bfd_reloc_code_real = 838;
pub const BFD_RELOC_ARC_SDA_LDST2: bfd_reloc_code_real = 837;
pub const BFD_RELOC_ARC_SDA_LDST1: bfd_reloc_code_real = 836;
pub const BFD_RELOC_ARC_SDA_LDST: bfd_reloc_code_real = 835;
pub const BFD_RELOC_ARC_SDA32: bfd_reloc_code_real = 834;
pub const BFD_RELOC_ARC_S25W_PCREL: bfd_reloc_code_real = 833;
pub const BFD_RELOC_ARC_S25H_PCREL: bfd_reloc_code_real = 832;
pub const BFD_RELOC_ARC_S21W_PCREL: bfd_reloc_code_real = 831;
pub const BFD_RELOC_ARC_S21H_PCREL: bfd_reloc_code_real = 830;
pub const BFD_RELOC_ARC_SECTOFF: bfd_reloc_code_real = 829;
pub const BFD_RELOC_ARC_SDA: bfd_reloc_code_real = 828;
pub const BFD_RELOC_ARC_N32: bfd_reloc_code_real = 827;
pub const BFD_RELOC_ARC_N24: bfd_reloc_code_real = 826;
pub const BFD_RELOC_ARC_N16: bfd_reloc_code_real = 825;
pub const BFD_RELOC_ARC_N8: bfd_reloc_code_real = 824;
pub const BFD_RELOC_ARC_32: bfd_reloc_code_real = 823;
pub const BFD_RELOC_ARC_24: bfd_reloc_code_real = 822;
pub const BFD_RELOC_ARC_16: bfd_reloc_code_real = 821;
pub const BFD_RELOC_ARC_8: bfd_reloc_code_real = 820;
pub const BFD_RELOC_ARC_NONE: bfd_reloc_code_real = 819;
pub const BFD_RELOC_SH_FUNCDESC: bfd_reloc_code_real = 818;
pub const BFD_RELOC_SH_GOTOFFFUNCDESC20: bfd_reloc_code_real = 817;
pub const BFD_RELOC_SH_GOTOFFFUNCDESC: bfd_reloc_code_real = 816;
pub const BFD_RELOC_SH_GOTFUNCDESC20: bfd_reloc_code_real = 815;
pub const BFD_RELOC_SH_GOTFUNCDESC: bfd_reloc_code_real = 814;
pub const BFD_RELOC_SH_GOTOFF20: bfd_reloc_code_real = 813;
pub const BFD_RELOC_SH_GOT20: bfd_reloc_code_real = 812;
pub const BFD_RELOC_SH_TLS_TPOFF32: bfd_reloc_code_real = 811;
pub const BFD_RELOC_SH_TLS_DTPOFF32: bfd_reloc_code_real = 810;
pub const BFD_RELOC_SH_TLS_DTPMOD32: bfd_reloc_code_real = 809;
pub const BFD_RELOC_SH_TLS_LE_32: bfd_reloc_code_real = 808;
pub const BFD_RELOC_SH_TLS_IE_32: bfd_reloc_code_real = 807;
pub const BFD_RELOC_SH_TLS_LDO_32: bfd_reloc_code_real = 806;
pub const BFD_RELOC_SH_TLS_LD_32: bfd_reloc_code_real = 805;
pub const BFD_RELOC_SH_TLS_GD_32: bfd_reloc_code_real = 804;
pub const BFD_RELOC_SH_PT_16: bfd_reloc_code_real = 803;
pub const BFD_RELOC_SH_IMM_HI16_PCREL: bfd_reloc_code_real = 802;
pub const BFD_RELOC_SH_IMM_HI16: bfd_reloc_code_real = 801;
pub const BFD_RELOC_SH_IMM_MEDHI16_PCREL: bfd_reloc_code_real = 800;
pub const BFD_RELOC_SH_IMM_MEDHI16: bfd_reloc_code_real = 799;
pub const BFD_RELOC_SH_IMM_MEDLOW16_PCREL: bfd_reloc_code_real = 798;
pub const BFD_RELOC_SH_IMM_MEDLOW16: bfd_reloc_code_real = 797;
pub const BFD_RELOC_SH_IMM_LOW16_PCREL: bfd_reloc_code_real = 796;
pub const BFD_RELOC_SH_IMM_LOW16: bfd_reloc_code_real = 795;
pub const BFD_RELOC_SH_IMMU16: bfd_reloc_code_real = 794;
pub const BFD_RELOC_SH_IMMS16: bfd_reloc_code_real = 793;
pub const BFD_RELOC_SH_IMMS10BY8: bfd_reloc_code_real = 792;
pub const BFD_RELOC_SH_IMMS10BY4: bfd_reloc_code_real = 791;
pub const BFD_RELOC_SH_IMMS10BY2: bfd_reloc_code_real = 790;
pub const BFD_RELOC_SH_IMMS10: bfd_reloc_code_real = 789;
pub const BFD_RELOC_SH_IMMU6: bfd_reloc_code_real = 788;
pub const BFD_RELOC_SH_IMMS6BY32: bfd_reloc_code_real = 787;
pub const BFD_RELOC_SH_IMMS6: bfd_reloc_code_real = 786;
pub const BFD_RELOC_SH_IMMU5: bfd_reloc_code_real = 785;
pub const BFD_RELOC_SH_SHMEDIA_CODE: bfd_reloc_code_real = 784;
pub const BFD_RELOC_SH_GOTPLT32: bfd_reloc_code_real = 783;
pub const BFD_RELOC_SH_GOTPLT10BY8: bfd_reloc_code_real = 782;
pub const BFD_RELOC_SH_GOTPLT10BY4: bfd_reloc_code_real = 781;
pub const BFD_RELOC_SH_GOT10BY8: bfd_reloc_code_real = 780;
pub const BFD_RELOC_SH_GOT10BY4: bfd_reloc_code_real = 779;
pub const BFD_RELOC_SH_RELATIVE64: bfd_reloc_code_real = 778;
pub const BFD_RELOC_SH_JMP_SLOT64: bfd_reloc_code_real = 777;
pub const BFD_RELOC_SH_GLOB_DAT64: bfd_reloc_code_real = 776;
pub const BFD_RELOC_SH_COPY64: bfd_reloc_code_real = 775;
pub const BFD_RELOC_SH_GOTPC_HI16: bfd_reloc_code_real = 774;
pub const BFD_RELOC_SH_GOTPC_MEDHI16: bfd_reloc_code_real = 773;
pub const BFD_RELOC_SH_GOTPC_MEDLOW16: bfd_reloc_code_real = 772;
pub const BFD_RELOC_SH_GOTPC_LOW16: bfd_reloc_code_real = 771;
pub const BFD_RELOC_SH_GOTOFF_HI16: bfd_reloc_code_real = 770;
pub const BFD_RELOC_SH_GOTOFF_MEDHI16: bfd_reloc_code_real = 769;
pub const BFD_RELOC_SH_GOTOFF_MEDLOW16: bfd_reloc_code_real = 768;
pub const BFD_RELOC_SH_GOTOFF_LOW16: bfd_reloc_code_real = 767;
pub const BFD_RELOC_SH_PLT_HI16: bfd_reloc_code_real = 766;
pub const BFD_RELOC_SH_PLT_MEDHI16: bfd_reloc_code_real = 765;
pub const BFD_RELOC_SH_PLT_MEDLOW16: bfd_reloc_code_real = 764;
pub const BFD_RELOC_SH_PLT_LOW16: bfd_reloc_code_real = 763;
pub const BFD_RELOC_SH_GOTPLT_HI16: bfd_reloc_code_real = 762;
pub const BFD_RELOC_SH_GOTPLT_MEDHI16: bfd_reloc_code_real = 761;
pub const BFD_RELOC_SH_GOTPLT_MEDLOW16: bfd_reloc_code_real = 760;
pub const BFD_RELOC_SH_GOTPLT_LOW16: bfd_reloc_code_real = 759;
pub const BFD_RELOC_SH_GOT_HI16: bfd_reloc_code_real = 758;
pub const BFD_RELOC_SH_GOT_MEDHI16: bfd_reloc_code_real = 757;
pub const BFD_RELOC_SH_GOT_MEDLOW16: bfd_reloc_code_real = 756;
pub const BFD_RELOC_SH_GOT_LOW16: bfd_reloc_code_real = 755;
pub const BFD_RELOC_SH_GOTPC: bfd_reloc_code_real = 754;
pub const BFD_RELOC_SH_RELATIVE: bfd_reloc_code_real = 753;
pub const BFD_RELOC_SH_JMP_SLOT: bfd_reloc_code_real = 752;
pub const BFD_RELOC_SH_GLOB_DAT: bfd_reloc_code_real = 751;
pub const BFD_RELOC_SH_COPY: bfd_reloc_code_real = 750;
pub const BFD_RELOC_SH_LOOP_END: bfd_reloc_code_real = 749;
pub const BFD_RELOC_SH_LOOP_START: bfd_reloc_code_real = 748;
pub const BFD_RELOC_SH_LABEL: bfd_reloc_code_real = 747;
pub const BFD_RELOC_SH_DATA: bfd_reloc_code_real = 746;
pub const BFD_RELOC_SH_CODE: bfd_reloc_code_real = 745;
pub const BFD_RELOC_SH_ALIGN: bfd_reloc_code_real = 744;
pub const BFD_RELOC_SH_COUNT: bfd_reloc_code_real = 743;
pub const BFD_RELOC_SH_USES: bfd_reloc_code_real = 742;
pub const BFD_RELOC_SH_SWITCH32: bfd_reloc_code_real = 741;
pub const BFD_RELOC_SH_SWITCH16: bfd_reloc_code_real = 740;
pub const BFD_RELOC_SH_PCRELIMM8BY4: bfd_reloc_code_real = 739;
pub const BFD_RELOC_SH_PCRELIMM8BY2: bfd_reloc_code_real = 738;
pub const BFD_RELOC_SH_IMM8BY4: bfd_reloc_code_real = 737;
pub const BFD_RELOC_SH_IMM8BY2: bfd_reloc_code_real = 736;
pub const BFD_RELOC_SH_IMM8: bfd_reloc_code_real = 735;
pub const BFD_RELOC_SH_IMM4BY4: bfd_reloc_code_real = 734;
pub const BFD_RELOC_SH_IMM4BY2: bfd_reloc_code_real = 733;
pub const BFD_RELOC_SH_IMM4: bfd_reloc_code_real = 732;
pub const BFD_RELOC_SH_DISP20BY8: bfd_reloc_code_real = 731;
pub const BFD_RELOC_SH_DISP20: bfd_reloc_code_real = 730;
pub const BFD_RELOC_SH_DISP12BY8: bfd_reloc_code_real = 729;
pub const BFD_RELOC_SH_DISP12BY4: bfd_reloc_code_real = 728;
pub const BFD_RELOC_SH_DISP12BY2: bfd_reloc_code_real = 727;
pub const BFD_RELOC_SH_DISP12: bfd_reloc_code_real = 726;
pub const BFD_RELOC_SH_IMM3U: bfd_reloc_code_real = 725;
pub const BFD_RELOC_SH_IMM3: bfd_reloc_code_real = 724;
pub const BFD_RELOC_SH_PCDISP12BY2: bfd_reloc_code_real = 723;
pub const BFD_RELOC_SH_PCDISP8BY2: bfd_reloc_code_real = 722;
pub const BFD_RELOC_ARM_THUMB_SHIFT: bfd_reloc_code_real = 721;
pub const BFD_RELOC_ARM_THUMB_IMM: bfd_reloc_code_real = 720;
pub const BFD_RELOC_ARM_THUMB_ADD: bfd_reloc_code_real = 719;
pub const BFD_RELOC_ARM_HWLITERAL: bfd_reloc_code_real = 718;
pub const BFD_RELOC_ARM_T32_OFFSET_IMM: bfd_reloc_code_real = 717;
pub const BFD_RELOC_ARM_T32_OFFSET_U8: bfd_reloc_code_real = 716;
pub const BFD_RELOC_ARM_OFFSET_IMM8: bfd_reloc_code_real = 715;
pub const BFD_RELOC_ARM_IN_POOL: bfd_reloc_code_real = 714;
pub const BFD_RELOC_ARM_LITERAL: bfd_reloc_code_real = 713;
pub const BFD_RELOC_ARM_LDR_IMM: bfd_reloc_code_real = 712;
pub const BFD_RELOC_ARM_ADR_IMM: bfd_reloc_code_real = 711;
pub const BFD_RELOC_ARM_T32_VLDR_VSTR_OFF_IMM: bfd_reloc_code_real = 710;
pub const BFD_RELOC_ARM_T32_CP_OFF_IMM_S2: bfd_reloc_code_real = 709;
pub const BFD_RELOC_ARM_T32_CP_OFF_IMM: bfd_reloc_code_real = 708;
pub const BFD_RELOC_ARM_CP_OFF_IMM_S2: bfd_reloc_code_real = 707;
pub const BFD_RELOC_ARM_CP_OFF_IMM: bfd_reloc_code_real = 706;
pub const BFD_RELOC_ARM_MULTI: bfd_reloc_code_real = 705;
pub const BFD_RELOC_ARM_SWI: bfd_reloc_code_real = 704;
pub const BFD_RELOC_ARM_HVC: bfd_reloc_code_real = 703;
pub const BFD_RELOC_ARM_SMC: bfd_reloc_code_real = 702;
pub const BFD_RELOC_ARM_SHIFT_IMM: bfd_reloc_code_real = 701;
pub const BFD_RELOC_ARM_T32_ADD_PC12: bfd_reloc_code_real = 700;
pub const BFD_RELOC_ARM_T32_IMM12: bfd_reloc_code_real = 699;
pub const BFD_RELOC_ARM_T32_ADD_IMM: bfd_reloc_code_real = 698;
pub const BFD_RELOC_ARM_T32_IMMEDIATE: bfd_reloc_code_real = 697;
pub const BFD_RELOC_ARM_ADRL_IMMEDIATE: bfd_reloc_code_real = 696;
pub const BFD_RELOC_ARM_IMMEDIATE: bfd_reloc_code_real = 695;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC: bfd_reloc_code_real = 694;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC: bfd_reloc_code_real = 693;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC: bfd_reloc_code_real = 692;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC: bfd_reloc_code_real = 691;
pub const BFD_RELOC_ARM_IRELATIVE: bfd_reloc_code_real = 690;
pub const BFD_RELOC_ARM_V4BX: bfd_reloc_code_real = 689;
pub const BFD_RELOC_ARM_LDC_SB_G2: bfd_reloc_code_real = 688;
pub const BFD_RELOC_ARM_LDC_SB_G1: bfd_reloc_code_real = 687;
pub const BFD_RELOC_ARM_LDC_SB_G0: bfd_reloc_code_real = 686;
pub const BFD_RELOC_ARM_LDRS_SB_G2: bfd_reloc_code_real = 685;
pub const BFD_RELOC_ARM_LDRS_SB_G1: bfd_reloc_code_real = 684;
pub const BFD_RELOC_ARM_LDRS_SB_G0: bfd_reloc_code_real = 683;
pub const BFD_RELOC_ARM_LDR_SB_G2: bfd_reloc_code_real = 682;
pub const BFD_RELOC_ARM_LDR_SB_G1: bfd_reloc_code_real = 681;
pub const BFD_RELOC_ARM_LDR_SB_G0: bfd_reloc_code_real = 680;
pub const BFD_RELOC_ARM_ALU_SB_G2: bfd_reloc_code_real = 679;
pub const BFD_RELOC_ARM_ALU_SB_G1: bfd_reloc_code_real = 678;
pub const BFD_RELOC_ARM_ALU_SB_G1_NC: bfd_reloc_code_real = 677;
pub const BFD_RELOC_ARM_ALU_SB_G0: bfd_reloc_code_real = 676;
pub const BFD_RELOC_ARM_ALU_SB_G0_NC: bfd_reloc_code_real = 675;
pub const BFD_RELOC_ARM_LDC_PC_G2: bfd_reloc_code_real = 674;
pub const BFD_RELOC_ARM_LDC_PC_G1: bfd_reloc_code_real = 673;
pub const BFD_RELOC_ARM_LDC_PC_G0: bfd_reloc_code_real = 672;
pub const BFD_RELOC_ARM_LDRS_PC_G2: bfd_reloc_code_real = 671;
pub const BFD_RELOC_ARM_LDRS_PC_G1: bfd_reloc_code_real = 670;
pub const BFD_RELOC_ARM_LDRS_PC_G0: bfd_reloc_code_real = 669;
pub const BFD_RELOC_ARM_LDR_PC_G2: bfd_reloc_code_real = 668;
pub const BFD_RELOC_ARM_LDR_PC_G1: bfd_reloc_code_real = 667;
pub const BFD_RELOC_ARM_LDR_PC_G0: bfd_reloc_code_real = 666;
pub const BFD_RELOC_ARM_ALU_PC_G2: bfd_reloc_code_real = 665;
pub const BFD_RELOC_ARM_ALU_PC_G1: bfd_reloc_code_real = 664;
pub const BFD_RELOC_ARM_ALU_PC_G1_NC: bfd_reloc_code_real = 663;
pub const BFD_RELOC_ARM_ALU_PC_G0: bfd_reloc_code_real = 662;
pub const BFD_RELOC_ARM_ALU_PC_G0_NC: bfd_reloc_code_real = 661;
pub const BFD_RELOC_ARM_TLS_DESC: bfd_reloc_code_real = 660;
pub const BFD_RELOC_ARM_THM_TLS_DESCSEQ: bfd_reloc_code_real = 659;
pub const BFD_RELOC_ARM_TLS_DESCSEQ: bfd_reloc_code_real = 658;
pub const BFD_RELOC_ARM_THM_TLS_CALL: bfd_reloc_code_real = 657;
pub const BFD_RELOC_ARM_TLS_CALL: bfd_reloc_code_real = 656;
pub const BFD_RELOC_ARM_TLS_GOTDESC: bfd_reloc_code_real = 655;
pub const BFD_RELOC_ARM_TLS_LE32: bfd_reloc_code_real = 654;
pub const BFD_RELOC_ARM_TLS_IE32: bfd_reloc_code_real = 653;
pub const BFD_RELOC_ARM_TLS_TPOFF32: bfd_reloc_code_real = 652;
pub const BFD_RELOC_ARM_TLS_DTPMOD32: bfd_reloc_code_real = 651;
pub const BFD_RELOC_ARM_TLS_DTPOFF32: bfd_reloc_code_real = 650;
pub const BFD_RELOC_ARM_TLS_LDM32: bfd_reloc_code_real = 649;
pub const BFD_RELOC_ARM_TLS_LDO32: bfd_reloc_code_real = 648;
pub const BFD_RELOC_ARM_TLS_GD32: bfd_reloc_code_real = 647;
pub const BFD_RELOC_ARM_GOT_PREL: bfd_reloc_code_real = 646;
pub const BFD_RELOC_ARM_GOTPC: bfd_reloc_code_real = 645;
pub const BFD_RELOC_ARM_GOTOFF: bfd_reloc_code_real = 644;
pub const BFD_RELOC_ARM_RELATIVE: bfd_reloc_code_real = 643;
pub const BFD_RELOC_ARM_PLT32: bfd_reloc_code_real = 642;
pub const BFD_RELOC_ARM_GOT32: bfd_reloc_code_real = 641;
pub const BFD_RELOC_ARM_GLOB_DAT: bfd_reloc_code_real = 640;
pub const BFD_RELOC_ARM_JUMP_SLOT: bfd_reloc_code_real = 639;
pub const BFD_RELOC_ARM_TLS_IE32_FDPIC: bfd_reloc_code_real = 638;
pub const BFD_RELOC_ARM_TLS_LDM32_FDPIC: bfd_reloc_code_real = 637;
pub const BFD_RELOC_ARM_TLS_GD32_FDPIC: bfd_reloc_code_real = 636;
pub const BFD_RELOC_ARM_FUNCDESC_VALUE: bfd_reloc_code_real = 635;
pub const BFD_RELOC_ARM_FUNCDESC: bfd_reloc_code_real = 634;
pub const BFD_RELOC_ARM_GOTOFFFUNCDESC: bfd_reloc_code_real = 633;
pub const BFD_RELOC_ARM_GOTFUNCDESC: bfd_reloc_code_real = 632;
pub const BFD_RELOC_ARM_THUMB_MOVT_PCREL: bfd_reloc_code_real = 631;
pub const BFD_RELOC_ARM_THUMB_MOVW_PCREL: bfd_reloc_code_real = 630;
pub const BFD_RELOC_ARM_THUMB_MOVT: bfd_reloc_code_real = 629;
pub const BFD_RELOC_ARM_THUMB_MOVW: bfd_reloc_code_real = 628;
pub const BFD_RELOC_ARM_MOVT_PCREL: bfd_reloc_code_real = 627;
pub const BFD_RELOC_ARM_MOVW_PCREL: bfd_reloc_code_real = 626;
pub const BFD_RELOC_ARM_MOVT: bfd_reloc_code_real = 625;
pub const BFD_RELOC_ARM_MOVW: bfd_reloc_code_real = 624;
pub const BFD_RELOC_ARM_PREL31: bfd_reloc_code_real = 623;
pub const BFD_RELOC_ARM_TARGET2: bfd_reloc_code_real = 622;
pub const BFD_RELOC_ARM_SBREL32: bfd_reloc_code_real = 621;
pub const BFD_RELOC_ARM_ROSEGREL32: bfd_reloc_code_real = 620;
pub const BFD_RELOC_ARM_TARGET1: bfd_reloc_code_real = 619;
pub const BFD_RELOC_ARM_THUMB_OFFSET: bfd_reloc_code_real = 618;
pub const BFD_RELOC_ARM_OFFSET_IMM: bfd_reloc_code_real = 617;
pub const BFD_RELOC_THUMB_PCREL_BRANCH25: bfd_reloc_code_real = 616;
pub const BFD_RELOC_THUMB_PCREL_BRANCH23: bfd_reloc_code_real = 615;
pub const BFD_RELOC_THUMB_PCREL_BRANCH20: bfd_reloc_code_real = 614;
pub const BFD_RELOC_THUMB_PCREL_BRANCH12: bfd_reloc_code_real = 613;
pub const BFD_RELOC_THUMB_PCREL_BRANCH9: bfd_reloc_code_real = 612;
pub const BFD_RELOC_THUMB_PCREL_BRANCH7: bfd_reloc_code_real = 611;
pub const BFD_RELOC_ARM_THUMB_LOOP12: bfd_reloc_code_real = 610;
pub const BFD_RELOC_ARM_THUMB_BF19: bfd_reloc_code_real = 609;
pub const BFD_RELOC_ARM_THUMB_BF13: bfd_reloc_code_real = 608;
pub const BFD_RELOC_ARM_THUMB_BF17: bfd_reloc_code_real = 607;
pub const BFD_RELOC_THUMB_PCREL_BFCSEL: bfd_reloc_code_real = 606;
pub const BFD_RELOC_THUMB_PCREL_BRANCH5: bfd_reloc_code_real = 605;
pub const BFD_RELOC_ARM_PCREL_JUMP: bfd_reloc_code_real = 604;
pub const BFD_RELOC_ARM_PCREL_CALL: bfd_reloc_code_real = 603;
pub const BFD_RELOC_THUMB_PCREL_BLX: bfd_reloc_code_real = 602;
pub const BFD_RELOC_ARM_PCREL_BLX: bfd_reloc_code_real = 601;
pub const BFD_RELOC_ARM_PCREL_BRANCH: bfd_reloc_code_real = 600;
pub const BFD_RELOC_CTOR: bfd_reloc_code_real = 599;
pub const BFD_RELOC_I370_D12: bfd_reloc_code_real = 598;
pub const BFD_RELOC_PPC64_TLS_PCREL: bfd_reloc_code_real = 597;
pub const BFD_RELOC_PPC64_GOT_DTPREL_PCREL34: bfd_reloc_code_real = 596;
pub const BFD_RELOC_PPC64_GOT_TPREL_PCREL34: bfd_reloc_code_real = 595;
pub const BFD_RELOC_PPC64_GOT_TLSLD_PCREL34: bfd_reloc_code_real = 594;
pub const BFD_RELOC_PPC64_GOT_TLSGD_PCREL34: bfd_reloc_code_real = 593;
pub const BFD_RELOC_PPC64_DTPREL34: bfd_reloc_code_real = 592;
pub const BFD_RELOC_PPC64_TPREL34: bfd_reloc_code_real = 591;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHESTA: bfd_reloc_code_real = 590;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHEST: bfd_reloc_code_real = 589;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHERA: bfd_reloc_code_real = 588;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHER: bfd_reloc_code_real = 587;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHA: bfd_reloc_code_real = 586;
pub const BFD_RELOC_PPC64_DTPREL16_HIGH: bfd_reloc_code_real = 585;
pub const BFD_RELOC_PPC64_DTPREL16_LO_DS: bfd_reloc_code_real = 584;
pub const BFD_RELOC_PPC64_DTPREL16_DS: bfd_reloc_code_real = 583;
pub const BFD_RELOC_PPC64_TPREL16_HIGHESTA: bfd_reloc_code_real = 582;
pub const BFD_RELOC_PPC64_TPREL16_HIGHEST: bfd_reloc_code_real = 581;
pub const BFD_RELOC_PPC64_TPREL16_HIGHERA: bfd_reloc_code_real = 580;
pub const BFD_RELOC_PPC64_TPREL16_HIGHER: bfd_reloc_code_real = 579;
pub const BFD_RELOC_PPC64_TPREL16_HIGHA: bfd_reloc_code_real = 578;
pub const BFD_RELOC_PPC64_TPREL16_HIGH: bfd_reloc_code_real = 577;
pub const BFD_RELOC_PPC64_TPREL16_LO_DS: bfd_reloc_code_real = 576;
pub const BFD_RELOC_PPC64_TPREL16_DS: bfd_reloc_code_real = 575;
pub const BFD_RELOC_PPC64_TLSML: bfd_reloc_code_real = 574;
pub const BFD_RELOC_PPC64_TLSM: bfd_reloc_code_real = 573;
pub const BFD_RELOC_PPC64_TLSIE: bfd_reloc_code_real = 572;
pub const BFD_RELOC_PPC64_TLSLE: bfd_reloc_code_real = 571;
pub const BFD_RELOC_PPC64_TLSLD: bfd_reloc_code_real = 570;
pub const BFD_RELOC_PPC64_TLSGD: bfd_reloc_code_real = 569;
pub const BFD_RELOC_PPC_GOT_DTPREL16_HA: bfd_reloc_code_real = 568;
pub const BFD_RELOC_PPC_GOT_DTPREL16_HI: bfd_reloc_code_real = 567;
pub const BFD_RELOC_PPC_GOT_DTPREL16_LO: bfd_reloc_code_real = 566;
pub const BFD_RELOC_PPC_GOT_DTPREL16: bfd_reloc_code_real = 565;
pub const BFD_RELOC_PPC_GOT_TPREL16_HA: bfd_reloc_code_real = 564;
pub const BFD_RELOC_PPC_GOT_TPREL16_HI: bfd_reloc_code_real = 563;
pub const BFD_RELOC_PPC_GOT_TPREL16_LO: bfd_reloc_code_real = 562;
pub const BFD_RELOC_PPC_GOT_TPREL16: bfd_reloc_code_real = 561;
pub const BFD_RELOC_PPC_GOT_TLSLD16_HA: bfd_reloc_code_real = 560;
pub const BFD_RELOC_PPC_GOT_TLSLD16_HI: bfd_reloc_code_real = 559;
pub const BFD_RELOC_PPC_GOT_TLSLD16_LO: bfd_reloc_code_real = 558;
pub const BFD_RELOC_PPC_GOT_TLSLD16: bfd_reloc_code_real = 557;
pub const BFD_RELOC_PPC_GOT_TLSGD16_HA: bfd_reloc_code_real = 556;
pub const BFD_RELOC_PPC_GOT_TLSGD16_HI: bfd_reloc_code_real = 555;
pub const BFD_RELOC_PPC_GOT_TLSGD16_LO: bfd_reloc_code_real = 554;
pub const BFD_RELOC_PPC_GOT_TLSGD16: bfd_reloc_code_real = 553;
pub const BFD_RELOC_PPC_DTPREL: bfd_reloc_code_real = 552;
pub const BFD_RELOC_PPC_DTPREL16_HA: bfd_reloc_code_real = 551;
pub const BFD_RELOC_PPC_DTPREL16_HI: bfd_reloc_code_real = 550;
pub const BFD_RELOC_PPC_DTPREL16_LO: bfd_reloc_code_real = 549;
pub const BFD_RELOC_PPC_DTPREL16: bfd_reloc_code_real = 548;
pub const BFD_RELOC_PPC_TPREL: bfd_reloc_code_real = 547;
pub const BFD_RELOC_PPC_TPREL16_HA: bfd_reloc_code_real = 546;
pub const BFD_RELOC_PPC_TPREL16_HI: bfd_reloc_code_real = 545;
pub const BFD_RELOC_PPC_TPREL16_LO: bfd_reloc_code_real = 544;
pub const BFD_RELOC_PPC_TPREL16: bfd_reloc_code_real = 543;
pub const BFD_RELOC_PPC_DTPMOD: bfd_reloc_code_real = 542;
pub const BFD_RELOC_PPC_TLSML: bfd_reloc_code_real = 541;
pub const BFD_RELOC_PPC_TLSM: bfd_reloc_code_real = 540;
pub const BFD_RELOC_PPC_TLSIE: bfd_reloc_code_real = 539;
pub const BFD_RELOC_PPC_TLSLE: bfd_reloc_code_real = 538;
pub const BFD_RELOC_PPC_TLSLD: bfd_reloc_code_real = 537;
pub const BFD_RELOC_PPC_TLSGD: bfd_reloc_code_real = 536;
pub const BFD_RELOC_PPC_TLS: bfd_reloc_code_real = 535;
pub const BFD_RELOC_PPC64_PCREL28: bfd_reloc_code_real = 534;
pub const BFD_RELOC_PPC64_D28: bfd_reloc_code_real = 533;
pub const BFD_RELOC_PPC64_REL16_HIGHESTA34: bfd_reloc_code_real = 532;
pub const BFD_RELOC_PPC64_REL16_HIGHEST34: bfd_reloc_code_real = 531;
pub const BFD_RELOC_PPC64_REL16_HIGHERA34: bfd_reloc_code_real = 530;
pub const BFD_RELOC_PPC64_REL16_HIGHER34: bfd_reloc_code_real = 529;
pub const BFD_RELOC_PPC64_ADDR16_HIGHESTA34: bfd_reloc_code_real = 528;
pub const BFD_RELOC_PPC64_ADDR16_HIGHEST34: bfd_reloc_code_real = 527;
pub const BFD_RELOC_PPC64_ADDR16_HIGHERA34: bfd_reloc_code_real = 526;
pub const BFD_RELOC_PPC64_ADDR16_HIGHER34: bfd_reloc_code_real = 525;
pub const BFD_RELOC_PPC64_PLT_PCREL34: bfd_reloc_code_real = 524;
pub const BFD_RELOC_PPC64_GOT_PCREL34: bfd_reloc_code_real = 523;
pub const BFD_RELOC_PPC64_PCREL34: bfd_reloc_code_real = 522;
pub const BFD_RELOC_PPC64_D34_HA30: bfd_reloc_code_real = 521;
pub const BFD_RELOC_PPC64_D34_HI30: bfd_reloc_code_real = 520;
pub const BFD_RELOC_PPC64_D34_LO: bfd_reloc_code_real = 519;
pub const BFD_RELOC_PPC64_D34: bfd_reloc_code_real = 518;
pub const BFD_RELOC_PPC64_REL24_NOTOC: bfd_reloc_code_real = 517;
pub const BFD_RELOC_PPC64_ENTRY: bfd_reloc_code_real = 516;
pub const BFD_RELOC_PPC64_ADDR64_LOCAL: bfd_reloc_code_real = 515;
pub const BFD_RELOC_PPC64_REL16_HIGHESTA: bfd_reloc_code_real = 514;
pub const BFD_RELOC_PPC64_REL16_HIGHEST: bfd_reloc_code_real = 513;
pub const BFD_RELOC_PPC64_REL16_HIGHERA: bfd_reloc_code_real = 512;
pub const BFD_RELOC_PPC64_REL16_HIGHER: bfd_reloc_code_real = 511;
pub const BFD_RELOC_PPC64_REL16_HIGHA: bfd_reloc_code_real = 510;
pub const BFD_RELOC_PPC64_REL16_HIGH: bfd_reloc_code_real = 509;
pub const BFD_RELOC_PPC64_ADDR16_HIGHA: bfd_reloc_code_real = 508;
pub const BFD_RELOC_PPC64_ADDR16_HIGH: bfd_reloc_code_real = 507;
pub const BFD_RELOC_PPC64_PLTGOT16_LO_DS: bfd_reloc_code_real = 506;
pub const BFD_RELOC_PPC64_PLTGOT16_DS: bfd_reloc_code_real = 505;
pub const BFD_RELOC_PPC64_TOC16_LO_DS: bfd_reloc_code_real = 504;
pub const BFD_RELOC_PPC64_TOC16_DS: bfd_reloc_code_real = 503;
pub const BFD_RELOC_PPC64_SECTOFF_LO_DS: bfd_reloc_code_real = 502;
pub const BFD_RELOC_PPC64_SECTOFF_DS: bfd_reloc_code_real = 501;
pub const BFD_RELOC_PPC64_PLT16_LO_DS: bfd_reloc_code_real = 500;
pub const BFD_RELOC_PPC64_GOT16_LO_DS: bfd_reloc_code_real = 499;
pub const BFD_RELOC_PPC64_GOT16_DS: bfd_reloc_code_real = 498;
pub const BFD_RELOC_PPC64_ADDR16_LO_DS: bfd_reloc_code_real = 497;
pub const BFD_RELOC_PPC64_ADDR16_DS: bfd_reloc_code_real = 496;
pub const BFD_RELOC_PPC64_PLTGOT16_HA: bfd_reloc_code_real = 495;
pub const BFD_RELOC_PPC64_PLTGOT16_HI: bfd_reloc_code_real = 494;
pub const BFD_RELOC_PPC64_PLTGOT16_LO: bfd_reloc_code_real = 493;
pub const BFD_RELOC_PPC64_PLTGOT16: bfd_reloc_code_real = 492;
pub const BFD_RELOC_PPC64_TOC: bfd_reloc_code_real = 491;
pub const BFD_RELOC_PPC64_TOC16_HA: bfd_reloc_code_real = 490;
pub const BFD_RELOC_PPC64_TOC16_HI: bfd_reloc_code_real = 489;
pub const BFD_RELOC_PPC64_TOC16_LO: bfd_reloc_code_real = 488;
pub const BFD_RELOC_PPC64_HIGHEST_S: bfd_reloc_code_real = 487;
pub const BFD_RELOC_PPC64_HIGHEST: bfd_reloc_code_real = 486;
pub const BFD_RELOC_PPC64_HIGHER_S: bfd_reloc_code_real = 485;
pub const BFD_RELOC_PPC64_HIGHER: bfd_reloc_code_real = 484;
pub const BFD_RELOC_PPC_NEG: bfd_reloc_code_real = 483;
pub const BFD_RELOC_PPC_REL16DX_HA: bfd_reloc_code_real = 482;
pub const BFD_RELOC_PPC_16DX_HA: bfd_reloc_code_real = 481;
pub const BFD_RELOC_PPC_VLE_SDAREL_HA16D: bfd_reloc_code_real = 480;
pub const BFD_RELOC_PPC_VLE_SDAREL_HA16A: bfd_reloc_code_real = 479;
pub const BFD_RELOC_PPC_VLE_SDAREL_HI16D: bfd_reloc_code_real = 478;
pub const BFD_RELOC_PPC_VLE_SDAREL_HI16A: bfd_reloc_code_real = 477;
pub const BFD_RELOC_PPC_VLE_SDAREL_LO16D: bfd_reloc_code_real = 476;
pub const BFD_RELOC_PPC_VLE_SDAREL_LO16A: bfd_reloc_code_real = 475;
pub const BFD_RELOC_PPC_VLE_SDA21_LO: bfd_reloc_code_real = 474;
pub const BFD_RELOC_PPC_VLE_SDA21: bfd_reloc_code_real = 473;
pub const BFD_RELOC_PPC_VLE_HA16D: bfd_reloc_code_real = 472;
pub const BFD_RELOC_PPC_VLE_HA16A: bfd_reloc_code_real = 471;
pub const BFD_RELOC_PPC_VLE_HI16D: bfd_reloc_code_real = 470;
pub const BFD_RELOC_PPC_VLE_HI16A: bfd_reloc_code_real = 469;
pub const BFD_RELOC_PPC_VLE_LO16D: bfd_reloc_code_real = 468;
pub const BFD_RELOC_PPC_VLE_LO16A: bfd_reloc_code_real = 467;
pub const BFD_RELOC_PPC_VLE_REL24: bfd_reloc_code_real = 466;
pub const BFD_RELOC_PPC_VLE_REL15: bfd_reloc_code_real = 465;
pub const BFD_RELOC_PPC_VLE_REL8: bfd_reloc_code_real = 464;
pub const BFD_RELOC_PPC_EMB_RELSDA: bfd_reloc_code_real = 463;
pub const BFD_RELOC_PPC_EMB_BIT_FLD: bfd_reloc_code_real = 462;
pub const BFD_RELOC_PPC_EMB_RELST_HA: bfd_reloc_code_real = 461;
pub const BFD_RELOC_PPC_EMB_RELST_HI: bfd_reloc_code_real = 460;
pub const BFD_RELOC_PPC_EMB_RELST_LO: bfd_reloc_code_real = 459;
pub const BFD_RELOC_PPC_EMB_RELSEC16: bfd_reloc_code_real = 458;
pub const BFD_RELOC_PPC_EMB_MRKREF: bfd_reloc_code_real = 457;
pub const BFD_RELOC_PPC_EMB_SDA21: bfd_reloc_code_real = 456;
pub const BFD_RELOC_PPC_EMB_SDA2REL: bfd_reloc_code_real = 455;
pub const BFD_RELOC_PPC_EMB_SDA2I16: bfd_reloc_code_real = 454;
pub const BFD_RELOC_PPC_EMB_SDAI16: bfd_reloc_code_real = 453;
pub const BFD_RELOC_PPC_EMB_NADDR16_HA: bfd_reloc_code_real = 452;
pub const BFD_RELOC_PPC_EMB_NADDR16_HI: bfd_reloc_code_real = 451;
pub const BFD_RELOC_PPC_EMB_NADDR16_LO: bfd_reloc_code_real = 450;
pub const BFD_RELOC_PPC_EMB_NADDR16: bfd_reloc_code_real = 449;
pub const BFD_RELOC_PPC_EMB_NADDR32: bfd_reloc_code_real = 448;
pub const BFD_RELOC_PPC_LOCAL24PC: bfd_reloc_code_real = 447;
pub const BFD_RELOC_PPC_RELATIVE: bfd_reloc_code_real = 446;
pub const BFD_RELOC_PPC_JMP_SLOT: bfd_reloc_code_real = 445;
pub const BFD_RELOC_PPC_GLOB_DAT: bfd_reloc_code_real = 444;
pub const BFD_RELOC_PPC_COPY: bfd_reloc_code_real = 443;
pub const BFD_RELOC_PPC_BA16_BRNTAKEN: bfd_reloc_code_real = 442;
pub const BFD_RELOC_PPC_BA16_BRTAKEN: bfd_reloc_code_real = 441;
pub const BFD_RELOC_PPC_BA16: bfd_reloc_code_real = 440;
pub const BFD_RELOC_PPC_B16_BRNTAKEN: bfd_reloc_code_real = 439;
pub const BFD_RELOC_PPC_B16_BRTAKEN: bfd_reloc_code_real = 438;
pub const BFD_RELOC_PPC_B16: bfd_reloc_code_real = 437;
pub const BFD_RELOC_PPC_TOC16_HI: bfd_reloc_code_real = 436;
pub const BFD_RELOC_PPC_TOC16_LO: bfd_reloc_code_real = 435;
pub const BFD_RELOC_PPC_TOC16: bfd_reloc_code_real = 434;
pub const BFD_RELOC_PPC_BA26: bfd_reloc_code_real = 433;
pub const BFD_RELOC_PPC_B26: bfd_reloc_code_real = 432;
pub const BFD_RELOC_PJ_CODE_REL32: bfd_reloc_code_real = 431;
pub const BFD_RELOC_PJ_CODE_REL16: bfd_reloc_code_real = 430;
pub const BFD_RELOC_PJ_CODE_DIR32: bfd_reloc_code_real = 429;
pub const BFD_RELOC_PJ_CODE_DIR16: bfd_reloc_code_real = 428;
pub const BFD_RELOC_PJ_CODE_LO16: bfd_reloc_code_real = 427;
pub const BFD_RELOC_PJ_CODE_HI16: bfd_reloc_code_real = 426;
pub const BFD_RELOC_PDP11_DISP_6_PCREL: bfd_reloc_code_real = 425;
pub const BFD_RELOC_PDP11_DISP_8_PCREL: bfd_reloc_code_real = 424;
pub const BFD_RELOC_NS32K_DISP_32_PCREL: bfd_reloc_code_real = 423;
pub const BFD_RELOC_NS32K_DISP_16_PCREL: bfd_reloc_code_real = 422;
pub const BFD_RELOC_NS32K_DISP_8_PCREL: bfd_reloc_code_real = 421;
pub const BFD_RELOC_NS32K_DISP_32: bfd_reloc_code_real = 420;
pub const BFD_RELOC_NS32K_DISP_16: bfd_reloc_code_real = 419;
pub const BFD_RELOC_NS32K_DISP_8: bfd_reloc_code_real = 418;
pub const BFD_RELOC_NS32K_IMM_32_PCREL: bfd_reloc_code_real = 417;
pub const BFD_RELOC_NS32K_IMM_16_PCREL: bfd_reloc_code_real = 416;
pub const BFD_RELOC_NS32K_IMM_8_PCREL: bfd_reloc_code_real = 415;
pub const BFD_RELOC_NS32K_IMM_32: bfd_reloc_code_real = 414;
pub const BFD_RELOC_NS32K_IMM_16: bfd_reloc_code_real = 413;
pub const BFD_RELOC_NS32K_IMM_8: bfd_reloc_code_real = 412;
pub const BFD_RELOC_X86_64_REX_GOTPCRELX: bfd_reloc_code_real = 411;
pub const BFD_RELOC_X86_64_GOTPCRELX: bfd_reloc_code_real = 410;
pub const BFD_RELOC_X86_64_PLT32_BND: bfd_reloc_code_real = 409;
pub const BFD_RELOC_X86_64_PC32_BND: bfd_reloc_code_real = 408;
pub const BFD_RELOC_X86_64_IRELATIVE: bfd_reloc_code_real = 407;
pub const BFD_RELOC_X86_64_TLSDESC: bfd_reloc_code_real = 406;
pub const BFD_RELOC_X86_64_TLSDESC_CALL: bfd_reloc_code_real = 405;
pub const BFD_RELOC_X86_64_GOTPC32_TLSDESC: bfd_reloc_code_real = 404;
pub const BFD_RELOC_X86_64_PLTOFF64: bfd_reloc_code_real = 403;
pub const BFD_RELOC_X86_64_GOTPLT64: bfd_reloc_code_real = 402;
pub const BFD_RELOC_X86_64_GOTPC64: bfd_reloc_code_real = 401;
pub const BFD_RELOC_X86_64_GOTPCREL64: bfd_reloc_code_real = 400;
pub const BFD_RELOC_X86_64_GOT64: bfd_reloc_code_real = 399;
pub const BFD_RELOC_X86_64_GOTPC32: bfd_reloc_code_real = 398;
pub const BFD_RELOC_X86_64_GOTOFF64: bfd_reloc_code_real = 397;
pub const BFD_RELOC_X86_64_TPOFF32: bfd_reloc_code_real = 396;
pub const BFD_RELOC_X86_64_GOTTPOFF: bfd_reloc_code_real = 395;
pub const BFD_RELOC_X86_64_DTPOFF32: bfd_reloc_code_real = 394;
pub const BFD_RELOC_X86_64_TLSLD: bfd_reloc_code_real = 393;
pub const BFD_RELOC_X86_64_TLSGD: bfd_reloc_code_real = 392;
pub const BFD_RELOC_X86_64_TPOFF64: bfd_reloc_code_real = 391;
pub const BFD_RELOC_X86_64_DTPOFF64: bfd_reloc_code_real = 390;
pub const BFD_RELOC_X86_64_DTPMOD64: bfd_reloc_code_real = 389;
pub const BFD_RELOC_X86_64_32S: bfd_reloc_code_real = 388;
pub const BFD_RELOC_X86_64_GOTPCREL: bfd_reloc_code_real = 387;
pub const BFD_RELOC_X86_64_RELATIVE: bfd_reloc_code_real = 386;
pub const BFD_RELOC_X86_64_JUMP_SLOT: bfd_reloc_code_real = 385;
pub const BFD_RELOC_X86_64_GLOB_DAT: bfd_reloc_code_real = 384;
pub const BFD_RELOC_X86_64_COPY: bfd_reloc_code_real = 383;
pub const BFD_RELOC_X86_64_PLT32: bfd_reloc_code_real = 382;
pub const BFD_RELOC_X86_64_GOT32: bfd_reloc_code_real = 381;
pub const BFD_RELOC_386_GOT32X: bfd_reloc_code_real = 380;
pub const BFD_RELOC_386_IRELATIVE: bfd_reloc_code_real = 379;
pub const BFD_RELOC_386_TLS_DESC: bfd_reloc_code_real = 378;
pub const BFD_RELOC_386_TLS_DESC_CALL: bfd_reloc_code_real = 377;
pub const BFD_RELOC_386_TLS_GOTDESC: bfd_reloc_code_real = 376;
pub const BFD_RELOC_386_TLS_TPOFF32: bfd_reloc_code_real = 375;
pub const BFD_RELOC_386_TLS_DTPOFF32: bfd_reloc_code_real = 374;
pub const BFD_RELOC_386_TLS_DTPMOD32: bfd_reloc_code_real = 373;
pub const BFD_RELOC_386_TLS_LE_32: bfd_reloc_code_real = 372;
pub const BFD_RELOC_386_TLS_IE_32: bfd_reloc_code_real = 371;
pub const BFD_RELOC_386_TLS_LDO_32: bfd_reloc_code_real = 370;
pub const BFD_RELOC_386_TLS_LDM: bfd_reloc_code_real = 369;
pub const BFD_RELOC_386_TLS_GD: bfd_reloc_code_real = 368;
pub const BFD_RELOC_386_TLS_LE: bfd_reloc_code_real = 367;
pub const BFD_RELOC_386_TLS_GOTIE: bfd_reloc_code_real = 366;
pub const BFD_RELOC_386_TLS_IE: bfd_reloc_code_real = 365;
pub const BFD_RELOC_386_TLS_TPOFF: bfd_reloc_code_real = 364;
pub const BFD_RELOC_386_GOTPC: bfd_reloc_code_real = 363;
pub const BFD_RELOC_386_GOTOFF: bfd_reloc_code_real = 362;
pub const BFD_RELOC_386_RELATIVE: bfd_reloc_code_real = 361;
pub const BFD_RELOC_386_JUMP_SLOT: bfd_reloc_code_real = 360;
pub const BFD_RELOC_386_GLOB_DAT: bfd_reloc_code_real = 359;
pub const BFD_RELOC_386_COPY: bfd_reloc_code_real = 358;
pub const BFD_RELOC_386_PLT32: bfd_reloc_code_real = 357;
pub const BFD_RELOC_386_GOT32: bfd_reloc_code_real = 356;
pub const BFD_RELOC_MN10300_16_PCREL: bfd_reloc_code_real = 355;
pub const BFD_RELOC_MN10300_32_PCREL: bfd_reloc_code_real = 354;
pub const BFD_RELOC_MN10300_TLS_TPOFF: bfd_reloc_code_real = 353;
pub const BFD_RELOC_MN10300_TLS_DTPOFF: bfd_reloc_code_real = 352;
pub const BFD_RELOC_MN10300_TLS_DTPMOD: bfd_reloc_code_real = 351;
pub const BFD_RELOC_MN10300_TLS_LE: bfd_reloc_code_real = 350;
pub const BFD_RELOC_MN10300_TLS_IE: bfd_reloc_code_real = 349;
pub const BFD_RELOC_MN10300_TLS_GOTIE: bfd_reloc_code_real = 348;
pub const BFD_RELOC_MN10300_TLS_LDO: bfd_reloc_code_real = 347;
pub const BFD_RELOC_MN10300_TLS_LD: bfd_reloc_code_real = 346;
pub const BFD_RELOC_MN10300_TLS_GD: bfd_reloc_code_real = 345;
pub const BFD_RELOC_MN10300_ALIGN: bfd_reloc_code_real = 344;
pub const BFD_RELOC_MN10300_SYM_DIFF: bfd_reloc_code_real = 343;
pub const BFD_RELOC_MN10300_RELATIVE: bfd_reloc_code_real = 342;
pub const BFD_RELOC_MN10300_JMP_SLOT: bfd_reloc_code_real = 341;
pub const BFD_RELOC_MN10300_GLOB_DAT: bfd_reloc_code_real = 340;
pub const BFD_RELOC_MN10300_COPY: bfd_reloc_code_real = 339;
pub const BFD_RELOC_MN10300_GOT16: bfd_reloc_code_real = 338;
pub const BFD_RELOC_MN10300_GOT24: bfd_reloc_code_real = 337;
pub const BFD_RELOC_MN10300_GOT32: bfd_reloc_code_real = 336;
pub const BFD_RELOC_MN10300_GOTOFF24: bfd_reloc_code_real = 335;
pub const BFD_RELOC_FRV_TLSMOFF: bfd_reloc_code_real = 334;
pub const BFD_RELOC_FRV_TLSOFF_RELAX: bfd_reloc_code_real = 333;
pub const BFD_RELOC_FRV_GETTLSOFF_RELAX: bfd_reloc_code_real = 332;
pub const BFD_RELOC_FRV_TLSDESC_RELAX: bfd_reloc_code_real = 331;
pub const BFD_RELOC_FRV_TLSOFF: bfd_reloc_code_real = 330;
pub const BFD_RELOC_FRV_GOTTLSOFFLO: bfd_reloc_code_real = 329;
pub const BFD_RELOC_FRV_GOTTLSOFFHI: bfd_reloc_code_real = 328;
pub const BFD_RELOC_FRV_GOTTLSOFF12: bfd_reloc_code_real = 327;
pub const BFD_RELOC_FRV_TLSMOFFLO: bfd_reloc_code_real = 326;
pub const BFD_RELOC_FRV_TLSMOFFHI: bfd_reloc_code_real = 325;
pub const BFD_RELOC_FRV_TLSMOFF12: bfd_reloc_code_real = 324;
pub const BFD_RELOC_FRV_GOTTLSDESCLO: bfd_reloc_code_real = 323;
pub const BFD_RELOC_FRV_GOTTLSDESCHI: bfd_reloc_code_real = 322;
pub const BFD_RELOC_FRV_GOTTLSDESC12: bfd_reloc_code_real = 321;
pub const BFD_RELOC_FRV_TLSDESC_VALUE: bfd_reloc_code_real = 320;
pub const BFD_RELOC_FRV_GETTLSOFF: bfd_reloc_code_real = 319;
pub const BFD_RELOC_FRV_GOTOFFLO: bfd_reloc_code_real = 318;
pub const BFD_RELOC_FRV_GOTOFFHI: bfd_reloc_code_real = 317;
pub const BFD_RELOC_FRV_GOTOFF12: bfd_reloc_code_real = 316;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFFLO: bfd_reloc_code_real = 315;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFFHI: bfd_reloc_code_real = 314;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFF12: bfd_reloc_code_real = 313;
pub const BFD_RELOC_FRV_FUNCDESC_VALUE: bfd_reloc_code_real = 312;
pub const BFD_RELOC_FRV_FUNCDESC_GOTLO: bfd_reloc_code_real = 311;
pub const BFD_RELOC_FRV_FUNCDESC_GOTHI: bfd_reloc_code_real = 310;
pub const BFD_RELOC_FRV_FUNCDESC_GOT12: bfd_reloc_code_real = 309;
pub const BFD_RELOC_FRV_FUNCDESC: bfd_reloc_code_real = 308;
pub const BFD_RELOC_FRV_GOTLO: bfd_reloc_code_real = 307;
pub const BFD_RELOC_FRV_GOTHI: bfd_reloc_code_real = 306;
pub const BFD_RELOC_FRV_GOT12: bfd_reloc_code_real = 305;
pub const BFD_RELOC_FRV_GPRELLO: bfd_reloc_code_real = 304;
pub const BFD_RELOC_FRV_GPRELHI: bfd_reloc_code_real = 303;
pub const BFD_RELOC_FRV_GPREL32: bfd_reloc_code_real = 302;
pub const BFD_RELOC_FRV_GPRELU12: bfd_reloc_code_real = 301;
pub const BFD_RELOC_FRV_GPREL12: bfd_reloc_code_real = 300;
pub const BFD_RELOC_FRV_HI16: bfd_reloc_code_real = 299;
pub const BFD_RELOC_FRV_LO16: bfd_reloc_code_real = 298;
pub const BFD_RELOC_FRV_LABEL24: bfd_reloc_code_real = 297;
pub const BFD_RELOC_FRV_LABEL16: bfd_reloc_code_real = 296;
pub const BFD_RELOC_FT32_DIFF32: bfd_reloc_code_real = 295;
pub const BFD_RELOC_FT32_15: bfd_reloc_code_real = 294;
pub const BFD_RELOC_FT32_SC1: bfd_reloc_code_real = 293;
pub const BFD_RELOC_FT32_SC0: bfd_reloc_code_real = 292;
pub const BFD_RELOC_FT32_RELAX: bfd_reloc_code_real = 291;
pub const BFD_RELOC_FT32_18: bfd_reloc_code_real = 290;
pub const BFD_RELOC_FT32_17: bfd_reloc_code_real = 289;
pub const BFD_RELOC_FT32_20: bfd_reloc_code_real = 288;
pub const BFD_RELOC_FT32_10: bfd_reloc_code_real = 287;
pub const BFD_RELOC_MOXIE_10_PCREL: bfd_reloc_code_real = 286;
pub const BFD_RELOC_MIPS_JUMP_SLOT: bfd_reloc_code_real = 285;
pub const BFD_RELOC_MIPS_COPY: bfd_reloc_code_real = 284;
pub const BFD_RELOC_MIPS_EH: bfd_reloc_code_real = 283;
pub const BFD_RELOC_MICROMIPS_TLS_TPREL_LO16: bfd_reloc_code_real = 282;
pub const BFD_RELOC_MIPS_TLS_TPREL_LO16: bfd_reloc_code_real = 281;
pub const BFD_RELOC_MICROMIPS_TLS_TPREL_HI16: bfd_reloc_code_real = 280;
pub const BFD_RELOC_MIPS_TLS_TPREL_HI16: bfd_reloc_code_real = 279;
pub const BFD_RELOC_MIPS_TLS_TPREL64: bfd_reloc_code_real = 278;
pub const BFD_RELOC_MIPS_TLS_TPREL32: bfd_reloc_code_real = 277;
pub const BFD_RELOC_MICROMIPS_TLS_GOTTPREL: bfd_reloc_code_real = 276;
pub const BFD_RELOC_MIPS_TLS_GOTTPREL: bfd_reloc_code_real = 275;
pub const BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16: bfd_reloc_code_real = 274;
pub const BFD_RELOC_MIPS_TLS_DTPREL_LO16: bfd_reloc_code_real = 273;
pub const BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16: bfd_reloc_code_real = 272;
pub const BFD_RELOC_MIPS_TLS_DTPREL_HI16: bfd_reloc_code_real = 271;
pub const BFD_RELOC_MICROMIPS_TLS_LDM: bfd_reloc_code_real = 270;
pub const BFD_RELOC_MIPS_TLS_LDM: bfd_reloc_code_real = 269;
pub const BFD_RELOC_MICROMIPS_TLS_GD: bfd_reloc_code_real = 268;
pub const BFD_RELOC_MIPS_TLS_GD: bfd_reloc_code_real = 267;
pub const BFD_RELOC_MIPS_TLS_DTPREL64: bfd_reloc_code_real = 266;
pub const BFD_RELOC_MIPS_TLS_DTPMOD64: bfd_reloc_code_real = 265;
pub const BFD_RELOC_MIPS_TLS_DTPREL32: bfd_reloc_code_real = 264;
pub const BFD_RELOC_MIPS_TLS_DTPMOD32: bfd_reloc_code_real = 263;
pub const BFD_RELOC_MICROMIPS_JALR: bfd_reloc_code_real = 262;
pub const BFD_RELOC_MIPS_JALR: bfd_reloc_code_real = 261;
pub const BFD_RELOC_MIPS_RELGOT: bfd_reloc_code_real = 260;
pub const BFD_RELOC_MIPS_REL16: bfd_reloc_code_real = 259;
pub const BFD_RELOC_MICROMIPS_SCN_DISP: bfd_reloc_code_real = 258;
pub const BFD_RELOC_MIPS_SCN_DISP: bfd_reloc_code_real = 257;
pub const BFD_RELOC_MICROMIPS_HIGHER: bfd_reloc_code_real = 256;
pub const BFD_RELOC_MIPS_HIGHER: bfd_reloc_code_real = 255;
pub const BFD_RELOC_MICROMIPS_HIGHEST: bfd_reloc_code_real = 254;
pub const BFD_RELOC_MIPS_HIGHEST: bfd_reloc_code_real = 253;
pub const BFD_RELOC_MIPS_DELETE: bfd_reloc_code_real = 252;
pub const BFD_RELOC_MIPS_INSERT_B: bfd_reloc_code_real = 251;
pub const BFD_RELOC_MIPS_INSERT_A: bfd_reloc_code_real = 250;
pub const BFD_RELOC_MIPS_SHIFT6: bfd_reloc_code_real = 249;
pub const BFD_RELOC_MIPS_SHIFT5: bfd_reloc_code_real = 248;
pub const BFD_RELOC_MICROMIPS_GOT_DISP: bfd_reloc_code_real = 247;
pub const BFD_RELOC_MIPS_GOT_DISP: bfd_reloc_code_real = 246;
pub const BFD_RELOC_MICROMIPS_GOT_OFST: bfd_reloc_code_real = 245;
pub const BFD_RELOC_MIPS_GOT_OFST: bfd_reloc_code_real = 244;
pub const BFD_RELOC_MICROMIPS_GOT_PAGE: bfd_reloc_code_real = 243;
pub const BFD_RELOC_MIPS_GOT_PAGE: bfd_reloc_code_real = 242;
pub const BFD_RELOC_MICROMIPS_SUB: bfd_reloc_code_real = 241;
pub const BFD_RELOC_MIPS_SUB: bfd_reloc_code_real = 240;
pub const BFD_RELOC_MICROMIPS_CALL_LO16: bfd_reloc_code_real = 239;
pub const BFD_RELOC_MIPS_CALL_LO16: bfd_reloc_code_real = 238;
pub const BFD_RELOC_MICROMIPS_CALL_HI16: bfd_reloc_code_real = 237;
pub const BFD_RELOC_MIPS_CALL_HI16: bfd_reloc_code_real = 236;
pub const BFD_RELOC_MICROMIPS_GOT_LO16: bfd_reloc_code_real = 235;
pub const BFD_RELOC_MIPS_GOT_LO16: bfd_reloc_code_real = 234;
pub const BFD_RELOC_MICROMIPS_GOT_HI16: bfd_reloc_code_real = 233;
pub const BFD_RELOC_MIPS_GOT_HI16: bfd_reloc_code_real = 232;
pub const BFD_RELOC_MICROMIPS_CALL16: bfd_reloc_code_real = 231;
pub const BFD_RELOC_MIPS_CALL16: bfd_reloc_code_real = 230;
pub const BFD_RELOC_MICROMIPS_GOT16: bfd_reloc_code_real = 229;
pub const BFD_RELOC_MIPS_GOT16: bfd_reloc_code_real = 228;
pub const BFD_RELOC_MICROMIPS_LO16: bfd_reloc_code_real = 227;
pub const BFD_RELOC_MICROMIPS_HI16_S: bfd_reloc_code_real = 226;
pub const BFD_RELOC_MICROMIPS_HI16: bfd_reloc_code_real = 225;
pub const BFD_RELOC_MICROMIPS_GPREL16: bfd_reloc_code_real = 224;
pub const BFD_RELOC_MIPS_19_PCREL_S2: bfd_reloc_code_real = 223;
pub const BFD_RELOC_MIPS_18_PCREL_S3: bfd_reloc_code_real = 222;
pub const BFD_RELOC_MIPS_26_PCREL_S2: bfd_reloc_code_real = 221;
pub const BFD_RELOC_MIPS_21_PCREL_S2: bfd_reloc_code_real = 220;
pub const BFD_RELOC_MIPS16_16_PCREL_S1: bfd_reloc_code_real = 219;
pub const BFD_RELOC_MICROMIPS_16_PCREL_S1: bfd_reloc_code_real = 218;
pub const BFD_RELOC_MICROMIPS_10_PCREL_S1: bfd_reloc_code_real = 217;
pub const BFD_RELOC_MICROMIPS_7_PCREL_S1: bfd_reloc_code_real = 216;
pub const BFD_RELOC_MICROMIPS_LITERAL: bfd_reloc_code_real = 215;
pub const BFD_RELOC_MIPS_LITERAL: bfd_reloc_code_real = 214;
pub const BFD_RELOC_MIPS16_TLS_TPREL_LO16: bfd_reloc_code_real = 213;
pub const BFD_RELOC_MIPS16_TLS_TPREL_HI16: bfd_reloc_code_real = 212;
pub const BFD_RELOC_MIPS16_TLS_GOTTPREL: bfd_reloc_code_real = 211;
pub const BFD_RELOC_MIPS16_TLS_DTPREL_LO16: bfd_reloc_code_real = 210;
pub const BFD_RELOC_MIPS16_TLS_DTPREL_HI16: bfd_reloc_code_real = 209;
pub const BFD_RELOC_MIPS16_TLS_LDM: bfd_reloc_code_real = 208;
pub const BFD_RELOC_MIPS16_TLS_GD: bfd_reloc_code_real = 207;
pub const BFD_RELOC_MIPS16_LO16: bfd_reloc_code_real = 206;
pub const BFD_RELOC_MIPS16_HI16_S: bfd_reloc_code_real = 205;
pub const BFD_RELOC_MIPS16_HI16: bfd_reloc_code_real = 204;
pub const BFD_RELOC_MIPS16_CALL16: bfd_reloc_code_real = 203;
pub const BFD_RELOC_MIPS16_GOT16: bfd_reloc_code_real = 202;
pub const BFD_RELOC_LO16_PCREL: bfd_reloc_code_real = 201;
pub const BFD_RELOC_HI16_S_PCREL: bfd_reloc_code_real = 200;
pub const BFD_RELOC_HI16_PCREL: bfd_reloc_code_real = 199;
pub const BFD_RELOC_LO16: bfd_reloc_code_real = 198;
pub const BFD_RELOC_HI16_S: bfd_reloc_code_real = 197;
pub const BFD_RELOC_HI16: bfd_reloc_code_real = 196;
pub const BFD_RELOC_MIPS16_GPREL: bfd_reloc_code_real = 195;
pub const BFD_RELOC_MIPS16_JMP: bfd_reloc_code_real = 194;
pub const BFD_RELOC_MICROMIPS_JMP: bfd_reloc_code_real = 193;
pub const BFD_RELOC_MIPS_JMP: bfd_reloc_code_real = 192;
pub const BFD_RELOC_ALPHA_TPREL16: bfd_reloc_code_real = 191;
pub const BFD_RELOC_ALPHA_TPREL_LO16: bfd_reloc_code_real = 190;
pub const BFD_RELOC_ALPHA_TPREL_HI16: bfd_reloc_code_real = 189;
pub const BFD_RELOC_ALPHA_TPREL64: bfd_reloc_code_real = 188;
pub const BFD_RELOC_ALPHA_GOTTPREL16: bfd_reloc_code_real = 187;
pub const BFD_RELOC_ALPHA_DTPREL16: bfd_reloc_code_real = 186;
pub const BFD_RELOC_ALPHA_DTPREL_LO16: bfd_reloc_code_real = 185;
pub const BFD_RELOC_ALPHA_DTPREL_HI16: bfd_reloc_code_real = 184;
pub const BFD_RELOC_ALPHA_DTPREL64: bfd_reloc_code_real = 183;
pub const BFD_RELOC_ALPHA_GOTDTPREL16: bfd_reloc_code_real = 182;
pub const BFD_RELOC_ALPHA_DTPMOD64: bfd_reloc_code_real = 181;
pub const BFD_RELOC_ALPHA_TLSLDM: bfd_reloc_code_real = 180;
pub const BFD_RELOC_ALPHA_TLSGD: bfd_reloc_code_real = 179;
pub const BFD_RELOC_ALPHA_BOH: bfd_reloc_code_real = 178;
pub const BFD_RELOC_ALPHA_LDA: bfd_reloc_code_real = 177;
pub const BFD_RELOC_ALPHA_BSR: bfd_reloc_code_real = 176;
pub const BFD_RELOC_ALPHA_NOP: bfd_reloc_code_real = 175;
pub const BFD_RELOC_ALPHA_BRSGP: bfd_reloc_code_real = 174;
pub const BFD_RELOC_ALPHA_GPREL_LO16: bfd_reloc_code_real = 173;
pub const BFD_RELOC_ALPHA_GPREL_HI16: bfd_reloc_code_real = 172;
pub const BFD_RELOC_ALPHA_CODEADDR: bfd_reloc_code_real = 171;
pub const BFD_RELOC_ALPHA_LINKAGE: bfd_reloc_code_real = 170;
pub const BFD_RELOC_ALPHA_HINT: bfd_reloc_code_real = 169;
pub const BFD_RELOC_ALPHA_LITUSE: bfd_reloc_code_real = 168;
pub const BFD_RELOC_ALPHA_ELF_LITERAL: bfd_reloc_code_real = 167;
pub const BFD_RELOC_ALPHA_LITERAL: bfd_reloc_code_real = 166;
pub const BFD_RELOC_ALPHA_GPDISP: bfd_reloc_code_real = 165;
pub const BFD_RELOC_ALPHA_GPDISP_LO16: bfd_reloc_code_real = 164;
pub const BFD_RELOC_ALPHA_GPDISP_HI16: bfd_reloc_code_real = 163;
pub const BFD_RELOC_SPU_ADD_PIC: bfd_reloc_code_real = 162;
pub const BFD_RELOC_SPU_PPU64: bfd_reloc_code_real = 161;
pub const BFD_RELOC_SPU_PPU32: bfd_reloc_code_real = 160;
pub const BFD_RELOC_SPU_HI16: bfd_reloc_code_real = 159;
pub const BFD_RELOC_SPU_LO16: bfd_reloc_code_real = 158;
pub const BFD_RELOC_SPU_PCREL16: bfd_reloc_code_real = 157;
pub const BFD_RELOC_SPU_PCREL9b: bfd_reloc_code_real = 156;
pub const BFD_RELOC_SPU_PCREL9a: bfd_reloc_code_real = 155;
pub const BFD_RELOC_SPU_IMM18: bfd_reloc_code_real = 154;
pub const BFD_RELOC_SPU_IMM16W: bfd_reloc_code_real = 153;
pub const BFD_RELOC_SPU_IMM16: bfd_reloc_code_real = 152;
pub const BFD_RELOC_SPU_IMM10W: bfd_reloc_code_real = 151;
pub const BFD_RELOC_SPU_IMM10: bfd_reloc_code_real = 150;
pub const BFD_RELOC_SPU_IMM8: bfd_reloc_code_real = 149;
pub const BFD_RELOC_SPU_IMM7: bfd_reloc_code_real = 148;
pub const BFD_RELOC_SPARC_TLS_TPOFF64: bfd_reloc_code_real = 147;
pub const BFD_RELOC_SPARC_TLS_TPOFF32: bfd_reloc_code_real = 146;
pub const BFD_RELOC_SPARC_TLS_DTPOFF64: bfd_reloc_code_real = 145;
pub const BFD_RELOC_SPARC_TLS_DTPOFF32: bfd_reloc_code_real = 144;
pub const BFD_RELOC_SPARC_TLS_DTPMOD64: bfd_reloc_code_real = 143;
pub const BFD_RELOC_SPARC_TLS_DTPMOD32: bfd_reloc_code_real = 142;
pub const BFD_RELOC_SPARC_TLS_LE_LOX10: bfd_reloc_code_real = 141;
pub const BFD_RELOC_SPARC_TLS_LE_HIX22: bfd_reloc_code_real = 140;
pub const BFD_RELOC_SPARC_TLS_IE_ADD: bfd_reloc_code_real = 139;
pub const BFD_RELOC_SPARC_TLS_IE_LDX: bfd_reloc_code_real = 138;
pub const BFD_RELOC_SPARC_TLS_IE_LD: bfd_reloc_code_real = 137;
pub const BFD_RELOC_SPARC_TLS_IE_LO10: bfd_reloc_code_real = 136;
pub const BFD_RELOC_SPARC_TLS_IE_HI22: bfd_reloc_code_real = 135;
pub const BFD_RELOC_SPARC_TLS_LDO_ADD: bfd_reloc_code_real = 134;
pub const BFD_RELOC_SPARC_TLS_LDO_LOX10: bfd_reloc_code_real = 133;
pub const BFD_RELOC_SPARC_TLS_LDO_HIX22: bfd_reloc_code_real = 132;
pub const BFD_RELOC_SPARC_TLS_LDM_CALL: bfd_reloc_code_real = 131;
pub const BFD_RELOC_SPARC_TLS_LDM_ADD: bfd_reloc_code_real = 130;
pub const BFD_RELOC_SPARC_TLS_LDM_LO10: bfd_reloc_code_real = 129;
pub const BFD_RELOC_SPARC_TLS_LDM_HI22: bfd_reloc_code_real = 128;
pub const BFD_RELOC_SPARC_TLS_GD_CALL: bfd_reloc_code_real = 127;
pub const BFD_RELOC_SPARC_TLS_GD_ADD: bfd_reloc_code_real = 126;
pub const BFD_RELOC_SPARC_TLS_GD_LO10: bfd_reloc_code_real = 125;
pub const BFD_RELOC_SPARC_TLS_GD_HI22: bfd_reloc_code_real = 124;
pub const BFD_RELOC_SPARC_REV32: bfd_reloc_code_real = 123;
pub const BFD_RELOC_SPARC_WDISP10: bfd_reloc_code_real = 122;
pub const BFD_RELOC_SPARC_SIZE64: bfd_reloc_code_real = 121;
pub const BFD_RELOC_SPARC_SIZE32: bfd_reloc_code_real = 120;
pub const BFD_RELOC_SPARC_H34: bfd_reloc_code_real = 119;
pub const BFD_RELOC_SPARC_REGISTER: bfd_reloc_code_real = 118;
pub const BFD_RELOC_SPARC_L44: bfd_reloc_code_real = 117;
pub const BFD_RELOC_SPARC_M44: bfd_reloc_code_real = 116;
pub const BFD_RELOC_SPARC_H44: bfd_reloc_code_real = 115;
pub const BFD_RELOC_SPARC_LOX10: bfd_reloc_code_real = 114;
pub const BFD_RELOC_SPARC_HIX22: bfd_reloc_code_real = 113;
pub const BFD_RELOC_SPARC_PLT64: bfd_reloc_code_real = 112;
pub const BFD_RELOC_SPARC_PLT32: bfd_reloc_code_real = 111;
pub const BFD_RELOC_SPARC_5: bfd_reloc_code_real = 110;
pub const BFD_RELOC_SPARC_6: bfd_reloc_code_real = 109;
pub const BFD_RELOC_SPARC_7: bfd_reloc_code_real = 108;
pub const BFD_RELOC_SPARC_WDISP19: bfd_reloc_code_real = 107;
pub const BFD_RELOC_SPARC_WDISP16: bfd_reloc_code_real = 106;
pub const BFD_RELOC_SPARC_PC_LM22: bfd_reloc_code_real = 105;
pub const BFD_RELOC_SPARC_PC_HM10: bfd_reloc_code_real = 104;
pub const BFD_RELOC_SPARC_PC_HH22: bfd_reloc_code_real = 103;
pub const BFD_RELOC_SPARC_LM22: bfd_reloc_code_real = 102;
pub const BFD_RELOC_SPARC_HM10: bfd_reloc_code_real = 101;
pub const BFD_RELOC_SPARC_HH22: bfd_reloc_code_real = 100;
pub const BFD_RELOC_SPARC_OLO10: bfd_reloc_code_real = 99;
pub const BFD_RELOC_SPARC_11: bfd_reloc_code_real = 98;
pub const BFD_RELOC_SPARC_10: bfd_reloc_code_real = 97;
pub const BFD_RELOC_SPARC_BASE22: bfd_reloc_code_real = 96;
pub const BFD_RELOC_SPARC_BASE13: bfd_reloc_code_real = 95;
pub const BFD_RELOC_SPARC_IRELATIVE: bfd_reloc_code_real = 94;
pub const BFD_RELOC_SPARC_JMP_IREL: bfd_reloc_code_real = 93;
pub const BFD_RELOC_SPARC_GOTDATA_OP: bfd_reloc_code_real = 92;
pub const BFD_RELOC_SPARC_GOTDATA_OP_LOX10: bfd_reloc_code_real = 91;
pub const BFD_RELOC_SPARC_GOTDATA_OP_HIX22: bfd_reloc_code_real = 90;
pub const BFD_RELOC_SPARC_GOTDATA_LOX10: bfd_reloc_code_real = 89;
pub const BFD_RELOC_SPARC_GOTDATA_HIX22: bfd_reloc_code_real = 88;
pub const BFD_RELOC_SPARC_UA64: bfd_reloc_code_real = 87;
pub const BFD_RELOC_SPARC_UA32: bfd_reloc_code_real = 86;
pub const BFD_RELOC_SPARC_UA16: bfd_reloc_code_real = 85;
pub const BFD_RELOC_SPARC_RELATIVE: bfd_reloc_code_real = 84;
pub const BFD_RELOC_SPARC_JMP_SLOT: bfd_reloc_code_real = 83;
pub const BFD_RELOC_SPARC_GLOB_DAT: bfd_reloc_code_real = 82;
pub const BFD_RELOC_SPARC_COPY: bfd_reloc_code_real = 81;
pub const BFD_RELOC_SPARC_WPLT30: bfd_reloc_code_real = 80;
pub const BFD_RELOC_SPARC_PC22: bfd_reloc_code_real = 79;
pub const BFD_RELOC_SPARC_PC10: bfd_reloc_code_real = 78;
pub const BFD_RELOC_SPARC_GOT22: bfd_reloc_code_real = 77;
pub const BFD_RELOC_SPARC_GOT13: bfd_reloc_code_real = 76;
pub const BFD_RELOC_SPARC_GOT10: bfd_reloc_code_real = 75;
pub const BFD_RELOC_SPARC13: bfd_reloc_code_real = 74;
pub const BFD_RELOC_SPARC22: bfd_reloc_code_real = 73;
pub const BFD_RELOC_SPARC_WDISP22: bfd_reloc_code_real = 72;
pub const BFD_RELOC_NONE: bfd_reloc_code_real = 71;
pub const BFD_RELOC_GPREL32: bfd_reloc_code_real = 70;
pub const BFD_RELOC_GPREL16: bfd_reloc_code_real = 69;
pub const BFD_RELOC_LO10: bfd_reloc_code_real = 68;
pub const BFD_RELOC_HI22: bfd_reloc_code_real = 67;
pub const BFD_RELOC_23_PCREL_S2: bfd_reloc_code_real = 66;
pub const BFD_RELOC_16_PCREL_S2: bfd_reloc_code_real = 65;
pub const BFD_RELOC_32_PCREL_S2: bfd_reloc_code_real = 64;
pub const BFD_RELOC_8_FFnn: bfd_reloc_code_real = 63;
pub const BFD_RELOC_RVA: bfd_reloc_code_real = 62;
pub const BFD_RELOC_8_BASEREL: bfd_reloc_code_real = 61;
pub const BFD_RELOC_HI16_S_BASEREL: bfd_reloc_code_real = 60;
pub const BFD_RELOC_HI16_BASEREL: bfd_reloc_code_real = 59;
pub const BFD_RELOC_LO16_BASEREL: bfd_reloc_code_real = 58;
pub const BFD_RELOC_16_BASEREL: bfd_reloc_code_real = 57;
pub const BFD_RELOC_32_BASEREL: bfd_reloc_code_real = 56;
pub const BFD_RELOC_68K_TLS_LE8: bfd_reloc_code_real = 55;
pub const BFD_RELOC_68K_TLS_LE16: bfd_reloc_code_real = 54;
pub const BFD_RELOC_68K_TLS_LE32: bfd_reloc_code_real = 53;
pub const BFD_RELOC_68K_TLS_IE8: bfd_reloc_code_real = 52;
pub const BFD_RELOC_68K_TLS_IE16: bfd_reloc_code_real = 51;
pub const BFD_RELOC_68K_TLS_IE32: bfd_reloc_code_real = 50;
pub const BFD_RELOC_68K_TLS_LDO8: bfd_reloc_code_real = 49;
pub const BFD_RELOC_68K_TLS_LDO16: bfd_reloc_code_real = 48;
pub const BFD_RELOC_68K_TLS_LDO32: bfd_reloc_code_real = 47;
pub const BFD_RELOC_68K_TLS_LDM8: bfd_reloc_code_real = 46;
pub const BFD_RELOC_68K_TLS_LDM16: bfd_reloc_code_real = 45;
pub const BFD_RELOC_68K_TLS_LDM32: bfd_reloc_code_real = 44;
pub const BFD_RELOC_68K_TLS_GD8: bfd_reloc_code_real = 43;
pub const BFD_RELOC_68K_TLS_GD16: bfd_reloc_code_real = 42;
pub const BFD_RELOC_68K_TLS_GD32: bfd_reloc_code_real = 41;
pub const BFD_RELOC_68K_RELATIVE: bfd_reloc_code_real = 40;
pub const BFD_RELOC_68K_JMP_SLOT: bfd_reloc_code_real = 39;
pub const BFD_RELOC_68K_GLOB_DAT: bfd_reloc_code_real = 38;
pub const BFD_RELOC_SIZE64: bfd_reloc_code_real = 37;
pub const BFD_RELOC_SIZE32: bfd_reloc_code_real = 36;
pub const BFD_RELOC_8_PLTOFF: bfd_reloc_code_real = 35;
pub const BFD_RELOC_HI16_S_PLTOFF: bfd_reloc_code_real = 34;
pub const BFD_RELOC_HI16_PLTOFF: bfd_reloc_code_real = 33;
pub const BFD_RELOC_LO16_PLTOFF: bfd_reloc_code_real = 32;
pub const BFD_RELOC_16_PLTOFF: bfd_reloc_code_real = 31;
pub const BFD_RELOC_32_PLTOFF: bfd_reloc_code_real = 30;
pub const BFD_RELOC_64_PLTOFF: bfd_reloc_code_real = 29;
pub const BFD_RELOC_8_PLT_PCREL: bfd_reloc_code_real = 28;
pub const BFD_RELOC_16_PLT_PCREL: bfd_reloc_code_real = 27;
pub const BFD_RELOC_24_PLT_PCREL: bfd_reloc_code_real = 26;
pub const BFD_RELOC_32_PLT_PCREL: bfd_reloc_code_real = 25;
pub const BFD_RELOC_64_PLT_PCREL: bfd_reloc_code_real = 24;
pub const BFD_RELOC_8_GOTOFF: bfd_reloc_code_real = 23;
pub const BFD_RELOC_HI16_S_GOTOFF: bfd_reloc_code_real = 22;
pub const BFD_RELOC_HI16_GOTOFF: bfd_reloc_code_real = 21;
pub const BFD_RELOC_LO16_GOTOFF: bfd_reloc_code_real = 20;
pub const BFD_RELOC_16_GOTOFF: bfd_reloc_code_real = 19;
pub const BFD_RELOC_32_GOTOFF: bfd_reloc_code_real = 18;
pub const BFD_RELOC_8_GOT_PCREL: bfd_reloc_code_real = 17;
pub const BFD_RELOC_16_GOT_PCREL: bfd_reloc_code_real = 16;
pub const BFD_RELOC_32_GOT_PCREL: bfd_reloc_code_real = 15;
pub const BFD_RELOC_32_SECREL: bfd_reloc_code_real = 14;
pub const BFD_RELOC_8_PCREL: bfd_reloc_code_real = 13;
pub const BFD_RELOC_12_PCREL: bfd_reloc_code_real = 12;
pub const BFD_RELOC_16_PCREL: bfd_reloc_code_real = 11;
pub const BFD_RELOC_24_PCREL: bfd_reloc_code_real = 10;
pub const BFD_RELOC_32_PCREL: bfd_reloc_code_real = 9;
pub const BFD_RELOC_64_PCREL: bfd_reloc_code_real = 8;
pub const BFD_RELOC_8: bfd_reloc_code_real = 7;
pub const BFD_RELOC_14: bfd_reloc_code_real = 6;
pub const BFD_RELOC_16: bfd_reloc_code_real = 5;
pub const BFD_RELOC_24: bfd_reloc_code_real = 4;
pub const BFD_RELOC_26: bfd_reloc_code_real = 3;
pub const BFD_RELOC_32: bfd_reloc_code_real = 2;
pub const BFD_RELOC_64: bfd_reloc_code_real = 1;
pub const _dummy_first_bfd_reloc_code_real: bfd_reloc_code_real = 0;
pub type asymbol = bfd_symbol;
pub type symbol_info = _symbol_info;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _symbol_info {
    pub value: symvalue,
    pub type_0: libc::c_char,
    pub name: *const libc::c_char,
    pub stab_type: libc::c_uchar,
    pub stab_other: libc::c_char,
    pub stab_desc: libc::c_short,
    pub stab_name: *const libc::c_char,
}
pub type bfd_print_symbol_type = bfd_print_symbol;
pub type bfd_print_symbol = libc::c_uint;
pub const bfd_print_symbol_all: bfd_print_symbol = 2;
pub const bfd_print_symbol_more: bfd_print_symbol = 1;
pub const bfd_print_symbol_name: bfd_print_symbol = 0;
pub type symindex = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct orl {
    pub name: *mut *mut libc::c_char,
    pub u: C2RustUnnamed_5,
    pub namidx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub pos: file_ptr,
    pub abfd: *mut bfd,
}
pub type bfd_window = _bfd_window;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _bfd_window {
    pub data: *mut libc::c_void,
    pub size: bfd_size_type,
    pub i: *mut _bfd_window_internal,
}
pub type bfd_cleanup = Option::<unsafe extern "C" fn(*mut bfd) -> ()>;
pub type bfd_signed_vma = libc::c_long;
pub type bfd_endian = libc::c_uint;
pub const BFD_ENDIAN_UNKNOWN: bfd_endian = 2;
pub const BFD_ENDIAN_LITTLE: bfd_endian = 1;
pub const BFD_ENDIAN_BIG: bfd_endian = 0;
pub type bfd_flavour = libc::c_uint;
pub const bfd_target_sym_flavour: bfd_flavour = 20;
pub const bfd_target_pef_xlib_flavour: bfd_flavour = 19;
pub const bfd_target_pef_flavour: bfd_flavour = 18;
pub const bfd_target_mach_o_flavour: bfd_flavour = 17;
pub const bfd_target_mmo_flavour: bfd_flavour = 16;
pub const bfd_target_evax_flavour: bfd_flavour = 15;
pub const bfd_target_ovax_flavour: bfd_flavour = 14;
pub const bfd_target_msdos_flavour: bfd_flavour = 13;
pub const bfd_target_versados_flavour: bfd_flavour = 12;
pub const bfd_target_os9k_flavour: bfd_flavour = 11;
pub const bfd_target_som_flavour: bfd_flavour = 10;
pub const bfd_target_ihex_flavour: bfd_flavour = 9;
pub const bfd_target_verilog_flavour: bfd_flavour = 8;
pub const bfd_target_srec_flavour: bfd_flavour = 7;
pub const bfd_target_tekhex_flavour: bfd_flavour = 6;
pub const bfd_target_elf_flavour: bfd_flavour = 5;
pub const bfd_target_xcoff_flavour: bfd_flavour = 4;
pub const bfd_target_ecoff_flavour: bfd_flavour = 3;
pub const bfd_target_coff_flavour: bfd_flavour = 2;
pub const bfd_target_aout_flavour: bfd_flavour = 1;
pub const bfd_target_unknown_flavour: bfd_flavour = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ar_hdr {
    pub ar_name: [libc::c_char; 16],
    pub ar_date: [libc::c_char; 12],
    pub ar_uid: [libc::c_char; 6],
    pub ar_gid: [libc::c_char; 6],
    pub ar_mode: [libc::c_char; 8],
    pub ar_size: [libc::c_char; 10],
    pub ar_fmag: [libc::c_char; 2],
}
pub type elf_vma = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct archive_info {
    pub file_name: *mut libc::c_char,
    pub file: *mut FILE,
    pub index_num: elf_vma,
    pub index_array: *mut elf_vma,
    pub sym_table: *mut libc::c_char,
    pub sym_size: libc::c_ulong,
    pub longnames: *mut libc::c_char,
    pub longnames_size: libc::c_ulong,
    pub nested_member_origin: libc::c_ulong,
    pub next_arhdr_offset: libc::c_ulong,
    pub is_thin_archive: libc::c_int,
    pub uses_64bit_indices: libc::c_int,
    pub arhdr: ar_hdr,
}
pub type dwarf_vma = libc::c_ulong;
pub type dwarf_size_type = libc::c_ulong;
pub type dwarf_section_display_enum = libc::c_uint;
pub const max: dwarf_section_display_enum = 44;
pub const separate_debug_str: dwarf_section_display_enum = 43;
pub const debug_sup: dwarf_section_display_enum = 42;
pub const gnu_debugaltlink: dwarf_section_display_enum = 41;
pub const gnu_debuglink: dwarf_section_display_enum = 40;
pub const dwp_tu_index: dwarf_section_display_enum = 39;
pub const dwp_cu_index: dwarf_section_display_enum = 38;
pub const debug_addr: dwarf_section_display_enum = 37;
pub const str_index_dwo: dwarf_section_display_enum = 36;
pub const str_index: dwarf_section_display_enum = 35;
pub const str_dwo: dwarf_section_display_enum = 34;
pub const macinfo_dwo: dwarf_section_display_enum = 33;
pub const macro_dwo: dwarf_section_display_enum = 32;
pub const loc_dwo: dwarf_section_display_enum = 31;
pub const line_dwo: dwarf_section_display_enum = 30;
pub const types_dwo: dwarf_section_display_enum = 29;
pub const abbrev_dwo: dwarf_section_display_enum = 28;
pub const info_dwo: dwarf_section_display_enum = 27;
pub const trace_aranges: dwarf_section_display_enum = 26;
pub const trace_abbrev: dwarf_section_display_enum = 25;
pub const trace_info: dwarf_section_display_enum = 24;
pub const debug_names: dwarf_section_display_enum = 23;
pub const gdb_index: dwarf_section_display_enum = 22;
pub const weaknames: dwarf_section_display_enum = 21;
pub const types: dwarf_section_display_enum = 20;
pub const static_vars: dwarf_section_display_enum = 19;
pub const static_func: dwarf_section_display_enum = 18;
pub const rnglists: dwarf_section_display_enum = 17;
pub const ranges: dwarf_section_display_enum = 16;
pub const gnu_pubtypes: dwarf_section_display_enum = 15;
pub const pubtypes: dwarf_section_display_enum = 14;
pub const loclists: dwarf_section_display_enum = 13;
pub const loc: dwarf_section_display_enum = 12;
pub const line_str: dwarf_section_display_enum = 11;
pub const str: dwarf_section_display_enum = 10;
pub const macro_0: dwarf_section_display_enum = 9;
pub const macinfo: dwarf_section_display_enum = 8;
pub const eh_frame: dwarf_section_display_enum = 7;
pub const gnu_pubnames: dwarf_section_display_enum = 6;
pub const pubnames: dwarf_section_display_enum = 5;
pub const line: dwarf_section_display_enum = 4;
pub const info: dwarf_section_display_enum = 3;
pub const frame: dwarf_section_display_enum = 2;
pub const aranges: dwarf_section_display_enum = 1;
pub const abbrev: dwarf_section_display_enum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_section {
    pub uncompressed_name: *const libc::c_char,
    pub compressed_name: *const libc::c_char,
    pub name: *const libc::c_char,
    pub filename: *const libc::c_char,
    pub start: *mut libc::c_uchar,
    pub address: dwarf_vma,
    pub size: dwarf_size_type,
    pub abbrev_sec: dwarf_section_display_enum,
    pub reloc_info: *mut libc::c_void,
    pub num_relocs: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_section_display {
    pub section: dwarf_section,
    pub display: Option::<
        unsafe extern "C" fn(*mut dwarf_section, *mut libc::c_void) -> libc::c_int,
    >,
    pub enabled: *mut libc::c_int,
    pub relocate: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct separate_info {
    pub handle: *mut libc::c_void,
    pub filename: *const libc::c_char,
    pub next: *mut separate_info,
}
pub type Elf_Internal_Shdr = elf_internal_shdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_shdr {
    pub sh_name: libc::c_uint,
    pub sh_type: libc::c_uint,
    pub sh_flags: bfd_vma,
    pub sh_addr: bfd_vma,
    pub sh_offset: file_ptr,
    pub sh_size: bfd_size_type,
    pub sh_link: libc::c_uint,
    pub sh_info: libc::c_uint,
    pub sh_addralign: bfd_vma,
    pub sh_entsize: bfd_size_type,
    pub bfd_section: *mut asection,
    pub contents: *mut libc::c_uchar,
}
pub type Filedata = filedata;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct filedata {
    pub file_name: *const libc::c_char,
    pub is_separate: bool,
    pub handle: *mut FILE,
    pub file_size: bfd_size_type,
    pub file_header: Elf_Internal_Ehdr,
    pub archive_file_offset: libc::c_ulong,
    pub archive_file_size: libc::c_ulong,
    pub section_headers: *mut Elf_Internal_Shdr,
    pub program_headers: *mut Elf_Internal_Phdr,
    pub string_table: *mut libc::c_char,
    pub string_table_length: libc::c_ulong,
    pub dynamic_addr: libc::c_ulong,
    pub dynamic_size: bfd_size_type,
    pub dynamic_nent: size_t,
    pub dynamic_section: *mut Elf_Internal_Dyn,
    pub dynamic_strtab_section: *mut Elf_Internal_Shdr,
    pub dynamic_strings: *mut libc::c_char,
    pub dynamic_strings_length: libc::c_ulong,
    pub dynamic_symtab_section: *mut Elf_Internal_Shdr,
    pub num_dynamic_syms: libc::c_ulong,
    pub dynamic_symbols: *mut Elf_Internal_Sym,
    pub version_info: [bfd_vma; 16],
    pub dynamic_syminfo_nent: libc::c_uint,
    pub dynamic_syminfo: *mut Elf_Internal_Syminfo,
    pub dynamic_syminfo_offset: libc::c_ulong,
    pub nbuckets: bfd_size_type,
    pub nchains: bfd_size_type,
    pub buckets: *mut bfd_vma,
    pub chains: *mut bfd_vma,
    pub ngnubuckets: bfd_size_type,
    pub ngnuchains: bfd_size_type,
    pub gnubuckets: *mut bfd_vma,
    pub gnuchains: *mut bfd_vma,
    pub mipsxlat: *mut bfd_vma,
    pub gnusymidx: bfd_vma,
    pub program_interpreter: *mut libc::c_char,
    pub dynamic_info: [bfd_vma; 32],
    pub dynamic_info_DT_GNU_HASH: bfd_vma,
    pub dynamic_info_DT_MIPS_XHASH: bfd_vma,
    pub symtab_shndx_list: *mut elf_section_list,
    pub group_count: size_t,
    pub section_groups: *mut group,
    pub section_headers_groups: *mut *mut group,
    pub dump: dump_data,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dump_data {
    pub dump_sects: *mut dump_type,
    pub num_dump_sects: libc::c_uint,
}
pub type dump_type = libc::c_uchar;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct group {
    pub root: *mut group_list,
    pub group_index: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct group_list {
    pub next: *mut group_list,
    pub section_index: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_section_list {
    pub hdr: *mut Elf_Internal_Shdr,
    pub next: *mut elf_section_list,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_Internal_Syminfo {
    pub si_boundto: libc::c_ushort,
    pub si_flags: libc::c_ushort,
}
pub type Elf_Internal_Sym = elf_internal_sym;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_sym {
    pub st_value: bfd_vma,
    pub st_size: bfd_vma,
    pub st_name: libc::c_ulong,
    pub st_info: libc::c_uchar,
    pub st_other: libc::c_uchar,
    pub st_target_internal: libc::c_uchar,
    pub st_shndx: libc::c_uint,
}
pub type Elf_Internal_Dyn = elf_internal_dyn;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_dyn {
    pub d_tag: bfd_vma,
    pub d_un: C2RustUnnamed_6,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub d_val: bfd_vma,
    pub d_ptr: bfd_vma,
}
pub type Elf_Internal_Phdr = elf_internal_phdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_phdr {
    pub p_type: libc::c_ulong,
    pub p_flags: libc::c_ulong,
    pub p_offset: bfd_vma,
    pub p_vaddr: bfd_vma,
    pub p_paddr: bfd_vma,
    pub p_filesz: bfd_vma,
    pub p_memsz: bfd_vma,
    pub p_align: bfd_vma,
}
pub type Elf_Internal_Ehdr = elf_internal_ehdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_ehdr {
    pub e_ident: [libc::c_uchar; 16],
    pub e_entry: bfd_vma,
    pub e_phoff: bfd_size_type,
    pub e_shoff: bfd_size_type,
    pub e_version: libc::c_ulong,
    pub e_flags: libc::c_ulong,
    pub e_type: libc::c_ushort,
    pub e_machine: libc::c_ushort,
    pub e_ehsize: libc::c_uint,
    pub e_phentsize: libc::c_uint,
    pub e_phnum: libc::c_uint,
    pub e_shentsize: libc::c_uint,
    pub e_shnum: libc::c_uint,
    pub e_shstrndx: libc::c_uint,
}
pub type Elf_Internal_Rela = elf_internal_rela;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_rela {
    pub r_offset: bfd_vma,
    pub r_info: bfd_vma,
    pub r_addend: bfd_vma,
}
pub const _sch_isprint: C2RustUnnamed_27 = 16;
pub const _sch_iscntrl: C2RustUnnamed_27 = 2;
pub const R_H8_DIR16: elf_h8_reloc_type = 17;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Sym {
    pub st_name: [libc::c_uchar; 4],
    pub st_info: [libc::c_uchar; 1],
    pub st_other: [libc::c_uchar; 1],
    pub st_shndx: [libc::c_uchar; 2],
    pub st_value: [libc::c_uchar; 8],
    pub st_size: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Sym_Shndx {
    pub est_shndx: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_vmatoa_buf {
    pub place: [libc::c_char; 64],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Sym {
    pub st_name: [libc::c_uchar; 4],
    pub st_value: [libc::c_uchar; 4],
    pub st_size: [libc::c_uchar; 4],
    pub st_info: [libc::c_uchar; 1],
    pub st_other: [libc::c_uchar; 1],
    pub st_shndx: [libc::c_uchar; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Rel {
    pub r_offset: [libc::c_uchar; 8],
    pub r_info: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Rel {
    pub r_offset: [libc::c_uchar; 4],
    pub r_info: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Rela {
    pub r_offset: [libc::c_uchar; 8],
    pub r_info: [libc::c_uchar; 8],
    pub r_addend: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Rela {
    pub r_offset: [libc::c_uchar; 4],
    pub r_info: [libc::c_uchar; 4],
    pub r_addend: [libc::c_uchar; 4],
}
pub type Elf_Internal_Chdr = elf_internal_chdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_chdr {
    pub ch_type: libc::c_uint,
    pub ch_size: bfd_size_type,
    pub ch_addralign: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Chdr {
    pub ch_type: [libc::c_uchar; 4],
    pub ch_reserved: [libc::c_uchar; 4],
    pub ch_size: [libc::c_uchar; 8],
    pub ch_addralign: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Chdr {
    pub ch_type: [libc::c_uchar; 4],
    pub ch_size: [libc::c_uchar; 4],
    pub ch_addralign: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Shdr {
    pub sh_name: [libc::c_uchar; 4],
    pub sh_type: [libc::c_uchar; 4],
    pub sh_flags: [libc::c_uchar; 8],
    pub sh_addr: [libc::c_uchar; 8],
    pub sh_offset: [libc::c_uchar; 8],
    pub sh_size: [libc::c_uchar; 8],
    pub sh_link: [libc::c_uchar; 4],
    pub sh_info: [libc::c_uchar; 4],
    pub sh_addralign: [libc::c_uchar; 8],
    pub sh_entsize: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Shdr {
    pub sh_name: [libc::c_uchar; 4],
    pub sh_type: [libc::c_uchar; 4],
    pub sh_flags: [libc::c_uchar; 4],
    pub sh_addr: [libc::c_uchar; 4],
    pub sh_offset: [libc::c_uchar; 4],
    pub sh_size: [libc::c_uchar; 4],
    pub sh_link: [libc::c_uchar; 4],
    pub sh_info: [libc::c_uchar; 4],
    pub sh_addralign: [libc::c_uchar; 4],
    pub sh_entsize: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Ehdr {
    pub e_ident: [libc::c_uchar; 16],
    pub e_type: [libc::c_uchar; 2],
    pub e_machine: [libc::c_uchar; 2],
    pub e_version: [libc::c_uchar; 4],
    pub e_entry: [libc::c_uchar; 8],
    pub e_phoff: [libc::c_uchar; 8],
    pub e_shoff: [libc::c_uchar; 8],
    pub e_flags: [libc::c_uchar; 4],
    pub e_ehsize: [libc::c_uchar; 2],
    pub e_phentsize: [libc::c_uchar; 2],
    pub e_phnum: [libc::c_uchar; 2],
    pub e_shentsize: [libc::c_uchar; 2],
    pub e_shnum: [libc::c_uchar; 2],
    pub e_shstrndx: [libc::c_uchar; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Ehdr {
    pub e_ident: [libc::c_uchar; 16],
    pub e_type: [libc::c_uchar; 2],
    pub e_machine: [libc::c_uchar; 2],
    pub e_version: [libc::c_uchar; 4],
    pub e_entry: [libc::c_uchar; 4],
    pub e_phoff: [libc::c_uchar; 4],
    pub e_shoff: [libc::c_uchar; 4],
    pub e_flags: [libc::c_uchar; 4],
    pub e_ehsize: [libc::c_uchar; 2],
    pub e_phentsize: [libc::c_uchar; 2],
    pub e_phnum: [libc::c_uchar; 2],
    pub e_shentsize: [libc::c_uchar; 2],
    pub e_shnum: [libc::c_uchar; 2],
    pub e_shstrndx: [libc::c_uchar; 2],
}
pub type ctf_dict_t = ctf_dict;
pub type ctf_archive_t = ctf_archive_internal;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ctf_sect {
    pub cts_name: *const libc::c_char,
    pub cts_data: *const libc::c_void,
    pub cts_size: size_t,
    pub cts_entsize: size_t,
}
pub type ctf_sect_t = ctf_sect;
pub type ctf_sect_names = libc::c_uint;
pub const CTF_SECT_STR: ctf_sect_names = 6;
pub const CTF_SECT_TYPE: ctf_sect_names = 5;
pub const CTF_SECT_VAR: ctf_sect_names = 4;
pub const CTF_SECT_FUNCIDX: ctf_sect_names = 3;
pub const CTF_SECT_FUNC: ctf_sect_names = 3;
pub const CTF_SECT_OBJTIDX: ctf_sect_names = 2;
pub const CTF_SECT_OBJT: ctf_sect_names = 2;
pub const CTF_SECT_LABEL: ctf_sect_names = 1;
pub const CTF_SECT_HEADER: ctf_sect_names = 0;
pub type ctf_sect_names_t = ctf_sect_names;
pub type C2RustUnnamed_7 = libc::c_uint;
pub const ECTF_NONAME: C2RustUnnamed_7 = 1058;
pub const ECTF_INCOMPLETE: C2RustUnnamed_7 = 1057;
pub const ECTF_NEEDSBFD: C2RustUnnamed_7 = 1056;
pub const ECTF_FLAGS: C2RustUnnamed_7 = 1055;
pub const ECTF_NEXT_WRONGFP: C2RustUnnamed_7 = 1054;
pub const ECTF_NEXT_WRONGFUN: C2RustUnnamed_7 = 1053;
pub const ECTF_NEXT_END: C2RustUnnamed_7 = 1052;
pub const ECTF_NONREPRESENTABLE: C2RustUnnamed_7 = 1051;
pub const ECTF_INTERNAL: C2RustUnnamed_7 = 1050;
pub const ECTF_NOTYET: C2RustUnnamed_7 = 1049;
pub const ECTF_DUMPSECTCHANGED: C2RustUnnamed_7 = 1048;
pub const ECTF_DUMPSECTUNKNOWN: C2RustUnnamed_7 = 1047;
pub const ECTF_SLICEOVERFLOW: C2RustUnnamed_7 = 1046;
pub const ECTF_ARNNAME: C2RustUnnamed_7 = 1045;
pub const ECTF_ARCREATE: C2RustUnnamed_7 = 1044;
pub const ECTF_COMPRESS: C2RustUnnamed_7 = 1043;
pub const ECTF_OVERROLLBACK: C2RustUnnamed_7 = 1042;
pub const ECTF_CONFLICT: C2RustUnnamed_7 = 1041;
pub const ECTF_DUPLICATE: C2RustUnnamed_7 = 1040;
pub const ECTF_FULL: C2RustUnnamed_7 = 1039;
pub const ECTF_DTFULL: C2RustUnnamed_7 = 1038;
pub const ECTF_RDONLY: C2RustUnnamed_7 = 1037;
pub const ECTF_NOMEMBNAM: C2RustUnnamed_7 = 1036;
pub const ECTF_NOENUMNAM: C2RustUnnamed_7 = 1035;
pub const ECTF_NOTSUP: C2RustUnnamed_7 = 1034;
pub const ECTF_NOLABELDATA: C2RustUnnamed_7 = 1033;
pub const ECTF_NOLABEL: C2RustUnnamed_7 = 1032;
pub const ECTF_NOTYPEDAT: C2RustUnnamed_7 = 1031;
pub const ECTF_NOTDATA: C2RustUnnamed_7 = 1030;
pub const ECTF_NOFUNCDAT: C2RustUnnamed_7 = 1029;
pub const ECTF_NOTFUNC: C2RustUnnamed_7 = 1028;
pub const ECTF_SYNTAX: C2RustUnnamed_7 = 1027;
pub const ECTF_NOTYPE: C2RustUnnamed_7 = 1026;
pub const ECTF_NAMELEN: C2RustUnnamed_7 = 1025;
pub const ECTF_NOTREF: C2RustUnnamed_7 = 1024;
pub const ECTF_NOTARRAY: C2RustUnnamed_7 = 1023;
pub const ECTF_NOTINTFP: C2RustUnnamed_7 = 1022;
pub const ECTF_NOTSUE: C2RustUnnamed_7 = 1021;
pub const ECTF_NOTENUM: C2RustUnnamed_7 = 1020;
pub const ECTF_NOTSOU: C2RustUnnamed_7 = 1019;
pub const ECTF_BADID: C2RustUnnamed_7 = 1018;
pub const ECTF_BADNAME: C2RustUnnamed_7 = 1017;
pub const ECTF_STRTAB: C2RustUnnamed_7 = 1016;
pub const ECTF_DECOMPRESS: C2RustUnnamed_7 = 1015;
pub const ECTF_ZALLOC: C2RustUnnamed_7 = 1014;
pub const ECTF_LINKADDEDLATE: C2RustUnnamed_7 = 1013;
pub const ECTF_DMODEL: C2RustUnnamed_7 = 1012;
pub const ECTF_NOPARENT: C2RustUnnamed_7 = 1011;
pub const ECTF_NOSYMTAB: C2RustUnnamed_7 = 1010;
pub const ECTF_NOCTFBUF: C2RustUnnamed_7 = 1009;
pub const ECTF_NOCTFDATA: C2RustUnnamed_7 = 1008;
pub const ECTF_CORRUPT: C2RustUnnamed_7 = 1007;
pub const ECTF_STRBAD: C2RustUnnamed_7 = 1006;
pub const ECTF_SYMBAD: C2RustUnnamed_7 = 1005;
pub const ECTF_SYMTAB: C2RustUnnamed_7 = 1004;
pub const ECTF_BFD_AMBIGUOUS: C2RustUnnamed_7 = 1003;
pub const ECTF_CTFVERS: C2RustUnnamed_7 = 1002;
pub const ECTF_BFDERR: C2RustUnnamed_7 = 1001;
pub const ECTF_FMT: C2RustUnnamed_7 = 1000;
pub type ctf_archive_member_f = unsafe extern "C" fn(
    *mut ctf_dict_t,
    *const libc::c_char,
    *mut libc::c_void,
) -> libc::c_int;
pub type ctf_dump_decorate_f = unsafe extern "C" fn(
    ctf_sect_names_t,
    *mut libc::c_char,
    *mut libc::c_void,
) -> *mut libc::c_char;
pub type ctf_dump_state_t = ctf_dump_state;
pub type ctf_next_t = ctf_next;
pub type demangling_styles = libc::c_int;
pub const rust_demangling: demangling_styles = 131072;
pub const dlang_demangling: demangling_styles = 65536;
pub const gnat_demangling: demangling_styles = 32768;
pub const java_demangling: demangling_styles = 4;
pub const gnu_v3_demangling: demangling_styles = 16384;
pub const auto_demangling: demangling_styles = 256;
pub const unknown_demangling: demangling_styles = 0;
pub const no_demangling: demangling_styles = -1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Phdr {
    pub p_type: [libc::c_uchar; 4],
    pub p_offset: [libc::c_uchar; 4],
    pub p_vaddr: [libc::c_uchar; 4],
    pub p_paddr: [libc::c_uchar; 4],
    pub p_filesz: [libc::c_uchar; 4],
    pub p_memsz: [libc::c_uchar; 4],
    pub p_flags: [libc::c_uchar; 4],
    pub p_align: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Phdr {
    pub p_type: [libc::c_uchar; 4],
    pub p_flags: [libc::c_uchar; 4],
    pub p_offset: [libc::c_uchar; 8],
    pub p_vaddr: [libc::c_uchar; 8],
    pub p_paddr: [libc::c_uchar; 8],
    pub p_filesz: [libc::c_uchar; 8],
    pub p_memsz: [libc::c_uchar; 8],
    pub p_align: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Note {
    pub namesz: [libc::c_uchar; 4],
    pub descsz: [libc::c_uchar; 4],
    pub type_0: [libc::c_uchar; 4],
    pub name: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Dyn {
    pub d_tag: [libc::c_uchar; 4],
    pub d_un: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub d_val: [libc::c_uchar; 4],
    pub d_ptr: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Dyn {
    pub d_tag: [libc::c_uchar; 8],
    pub d_un: C2RustUnnamed_9,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_9 {
    pub d_val: [libc::c_uchar; 8],
    pub d_ptr: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verdef {
    pub vd_version: [libc::c_uchar; 2],
    pub vd_flags: [libc::c_uchar; 2],
    pub vd_ndx: [libc::c_uchar; 2],
    pub vd_cnt: [libc::c_uchar; 2],
    pub vd_hash: [libc::c_uchar; 4],
    pub vd_aux: [libc::c_uchar; 4],
    pub vd_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verdaux {
    pub vda_name: [libc::c_uchar; 4],
    pub vda_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verneed {
    pub vn_version: [libc::c_uchar; 2],
    pub vn_cnt: [libc::c_uchar; 2],
    pub vn_file: [libc::c_uchar; 4],
    pub vn_aux: [libc::c_uchar; 4],
    pub vn_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Vernaux {
    pub vna_hash: [libc::c_uchar; 4],
    pub vna_flags: [libc::c_uchar; 2],
    pub vna_other: [libc::c_uchar; 2],
    pub vna_name: [libc::c_uchar; 4],
    pub vna_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct Elf_External_Versym {
    pub vs_vers: [libc::c_uchar; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Syminfo {
    pub si_boundto: [libc::c_uchar; 2],
    pub si_flags: [libc::c_uchar; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_note {
    pub namesz: libc::c_ulong,
    pub descsz: libc::c_ulong,
    pub type_0: libc::c_ulong,
    pub namedata: *mut libc::c_char,
    pub descdata: *mut libc::c_char,
    pub descpos: bfd_vma,
}
pub type Elf_Internal_Note = elf_internal_note;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verdef {
    pub vd_version: libc::c_ushort,
    pub vd_flags: libc::c_ushort,
    pub vd_ndx: libc::c_ushort,
    pub vd_cnt: libc::c_ushort,
    pub vd_hash: libc::c_ulong,
    pub vd_aux: libc::c_ulong,
    pub vd_next: libc::c_ulong,
    pub vd_bfd: *mut bfd,
    pub vd_nodename: *const libc::c_char,
    pub vd_nextdef: *mut elf_internal_verdef,
    pub vd_auxptr: *mut elf_internal_verdaux,
    pub vd_exp_refno: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verdaux {
    pub vda_name: libc::c_ulong,
    pub vda_next: libc::c_ulong,
    pub vda_nodename: *const libc::c_char,
    pub vda_nextptr: *mut elf_internal_verdaux,
}
pub type Elf_Internal_Verdef = elf_internal_verdef;
pub type Elf_Internal_Verdaux = elf_internal_verdaux;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verneed {
    pub vn_version: libc::c_ushort,
    pub vn_cnt: libc::c_ushort,
    pub vn_file: libc::c_ulong,
    pub vn_aux: libc::c_ulong,
    pub vn_next: libc::c_ulong,
    pub vn_bfd: *mut bfd,
    pub vn_filename: *const libc::c_char,
    pub vn_auxptr: *mut elf_internal_vernaux,
    pub vn_nextref: *mut elf_internal_verneed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_vernaux {
    pub vna_hash: libc::c_ulong,
    pub vna_flags: libc::c_ushort,
    pub vna_other: libc::c_ushort,
    pub vna_name: libc::c_ulong,
    pub vna_next: libc::c_ulong,
    pub vna_nodename: *const libc::c_char,
    pub vna_nextptr: *mut elf_internal_vernaux,
}
pub type Elf_Internal_Verneed = elf_internal_verneed;
pub type Elf_Internal_Vernaux = elf_internal_vernaux;
pub type elf_h8_reloc_type = libc::c_uint;
pub const R_H8_max: elf_h8_reloc_type = 142;
pub const R_H8_OPscttop: elf_h8_reloc_type = 141;
pub const R_H8_OPlow: elf_h8_reloc_type = 140;
pub const R_H8_OPhigh: elf_h8_reloc_type = 139;
pub const R_H8_OPlword: elf_h8_reloc_type = 138;
pub const R_H8_OPhword: elf_h8_reloc_type = 137;
pub const R_H8_OPsctsize: elf_h8_reloc_type = 136;
pub const R_H8_OPshra: elf_h8_reloc_type = 135;
pub const R_H8_OPshla: elf_h8_reloc_type = 134;
pub const R_H8_OPdiv: elf_h8_reloc_type = 133;
pub const R_H8_OPmul: elf_h8_reloc_type = 132;
pub const R_H8_OPsub: elf_h8_reloc_type = 131;
pub const R_H8_OPadd: elf_h8_reloc_type = 130;
pub const R_H8_OPneg: elf_h8_reloc_type = 129;
pub const R_H8_SYM: elf_h8_reloc_type = 128;
pub const R_H8_ABS32A16: elf_h8_reloc_type = 127;
pub const R_H8_ABS32: elf_h8_reloc_type = 65;
pub const R_H8_DISP32A16: elf_h8_reloc_type = 64;
pub const R_H8_DIR32A16: elf_h8_reloc_type = 63;
pub const R_H8_DIR24R8: elf_h8_reloc_type = 62;
pub const R_H8_DIR24A8: elf_h8_reloc_type = 61;
pub const R_H8_DIR16R8: elf_h8_reloc_type = 60;
pub const R_H8_DIR16A8: elf_h8_reloc_type = 59;
pub const R_H8_LAST_INVALID_DIR_RELOC: elf_h8_reloc_type = 58;
pub const R_H8_FIRST_INVALID_DIR_RELOC: elf_h8_reloc_type = 34;
pub const R_H8_BPOS: elf_h8_reloc_type = 33;
pub const R_H8_PCREL8: elf_h8_reloc_type = 32;
pub const R_H8_PCREL16: elf_h8_reloc_type = 31;
pub const R_H8_DIR8Z_16: elf_h8_reloc_type = 30;
pub const R_H8_DIR8Z_20: elf_h8_reloc_type = 29;
pub const R_H8_DIR8Z_24: elf_h8_reloc_type = 28;
pub const R_H8_DIR8Z_28: elf_h8_reloc_type = 27;
pub const R_H8_DIR8Z_32: elf_h8_reloc_type = 26;
pub const R_H8_DIR8U: elf_h8_reloc_type = 25;
pub const R_H8_DIR8: elf_h8_reloc_type = 24;
pub const R_H8_DIR16S: elf_h8_reloc_type = 23;
pub const R_H8_DIR16S_20: elf_h8_reloc_type = 22;
pub const R_H8_DIR16S_24: elf_h8_reloc_type = 21;
pub const R_H8_DIR16S_28: elf_h8_reloc_type = 20;
pub const R_H8_DIR16S_32: elf_h8_reloc_type = 19;
pub const R_H8_DIR16U: elf_h8_reloc_type = 18;
pub const R_H8_DIR24U_16: elf_h8_reloc_type = 16;
pub const R_H8_DIR24U_20: elf_h8_reloc_type = 15;
pub const R_H8_DIR24U: elf_h8_reloc_type = 14;
pub const R_H8_DIR24_16: elf_h8_reloc_type = 13;
pub const R_H8_DIR24_20: elf_h8_reloc_type = 12;
pub const R_H8_DIR24: elf_h8_reloc_type = 11;
pub const R_H8_DIR32U_16: elf_h8_reloc_type = 10;
pub const R_H8_DIR32U_20: elf_h8_reloc_type = 9;
pub const R_H8_DIR32U_24: elf_h8_reloc_type = 8;
pub const R_H8_DIR32U_28: elf_h8_reloc_type = 7;
pub const R_H8_DIR32U: elf_h8_reloc_type = 6;
pub const R_H8_DIR32_16: elf_h8_reloc_type = 4;
pub const R_H8_DIR32_24: elf_h8_reloc_type = 3;
pub const R_H8_DIR32_28: elf_h8_reloc_type = 2;
pub const R_H8_DIR32: elf_h8_reloc_type = 1;
pub const R_H8_NONE: elf_h8_reloc_type = 0;
pub type C2RustUnnamed_10 = libc::c_uint;
pub const Tag_ARC_ATR_version: C2RustUnnamed_10 = 20;
pub const Tag_ARC_ISA_mpy_option: C2RustUnnamed_10 = 18;
pub const Tag_ARC_ISA_apex: C2RustUnnamed_10 = 17;
pub const Tag_ARC_ISA_config: C2RustUnnamed_10 = 16;
pub const Tag_ARC_ABI_double_size: C2RustUnnamed_10 = 15;
pub const Tag_ARC_ABI_exceptions: C2RustUnnamed_10 = 14;
pub const Tag_ARC_ABI_enumsize: C2RustUnnamed_10 = 13;
pub const Tag_ARC_ABI_tls: C2RustUnnamed_10 = 12;
pub const Tag_ARC_ABI_pic: C2RustUnnamed_10 = 11;
pub const Tag_ARC_ABI_sda: C2RustUnnamed_10 = 10;
pub const Tag_ARC_ABI_osver: C2RustUnnamed_10 = 9;
pub const Tag_ARC_ABI_rf16: C2RustUnnamed_10 = 8;
pub const Tag_ARC_CPU_name: C2RustUnnamed_10 = 7;
pub const Tag_ARC_CPU_variation: C2RustUnnamed_10 = 6;
pub const Tag_ARC_CPU_base: C2RustUnnamed_10 = 5;
pub const Tag_ARC_PCS_config: C2RustUnnamed_10 = 4;
pub type C2RustUnnamed_11 = libc::c_uint;
pub const Tag_CSKY_MAX: C2RustUnnamed_11 = 23;
pub const Tag_CSKY_FPU_HARDFP: C2RustUnnamed_11 = 22;
pub const Tag_CSKY_FPU_NUMBER_MODULE: C2RustUnnamed_11 = 21;
pub const Tag_CSKY_FPU_Exception: C2RustUnnamed_11 = 20;
pub const Tag_CSKY_FPU_DENORMAL: C2RustUnnamed_11 = 19;
pub const Tag_CSKY_FPU_ROUNDING: C2RustUnnamed_11 = 18;
pub const Tag_CSKY_FPU_ABI: C2RustUnnamed_11 = 17;
pub const Tag_CSKY_FPU_VERSION: C2RustUnnamed_11 = 16;
pub const Tag_CSKY_VDSP_VERSION: C2RustUnnamed_11 = 9;
pub const Tag_CSKY_DSP_VERSION: C2RustUnnamed_11 = 8;
pub const Tag_CSKY_ISA_EXT_FLAGS: C2RustUnnamed_11 = 7;
pub const Tag_CSKY_ISA_FLAGS: C2RustUnnamed_11 = 6;
pub const Tag_CSKY_CPU_NAME: C2RustUnnamed_11 = 5;
pub const Tag_CSKY_ARCH_NAME: C2RustUnnamed_11 = 4;
pub type C2RustUnnamed_12 = libc::c_uint;
pub const VAL_CSKY_DSP_VERSION_2: C2RustUnnamed_12 = 2;
pub const VAL_CSKY_DSP_VERSION_EXTENSION: C2RustUnnamed_12 = 1;
pub type C2RustUnnamed_13 = libc::c_uint;
pub const VAL_CSKY_FPU_VERSION_2: C2RustUnnamed_13 = 2;
pub const VAL_CSKY_FPU_VERSION_1: C2RustUnnamed_13 = 1;
pub type C2RustUnnamed_14 = libc::c_uint;
pub const VAL_CSKY_FPU_ABI_HARD: C2RustUnnamed_14 = 3;
pub const VAL_CSKY_FPU_ABI_SOFTFP: C2RustUnnamed_14 = 2;
pub const VAL_CSKY_FPU_ABI_SOFT: C2RustUnnamed_14 = 1;
pub type C2RustUnnamed_15 = libc::c_uint;
pub const VAL_CSKY_FPU_HARDFP_DOUBLE: C2RustUnnamed_15 = 4;
pub const VAL_CSKY_FPU_HARDFP_SINGLE: C2RustUnnamed_15 = 2;
pub const VAL_CSKY_FPU_HARDFP_HALF: C2RustUnnamed_15 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_VMS_IMAGE_FIXUP {
    pub fixup_offset: [libc::c_uchar; 8],
    pub type_0: [libc::c_uchar; 4],
    pub fixup_seg: [libc::c_uchar; 4],
    pub addend: [libc::c_uchar; 8],
    pub symvec_index: [libc::c_uchar; 4],
    pub data_type: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_VMS_IMAGE_RELA {
    pub rela_offset: [libc::c_uchar; 8],
    pub type_0: [libc::c_uchar; 4],
    pub rela_seg: [libc::c_uchar; 4],
    pub addend: [libc::c_uchar; 8],
    pub sym_offset: [libc::c_uchar; 8],
    pub sym_seg: [libc::c_uchar; 4],
    pub fill_1: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_VMS_Note {
    pub namesz: [libc::c_uchar; 8],
    pub descsz: [libc::c_uchar; 8],
    pub type_0: [libc::c_uchar; 8],
    pub name: [libc::c_char; 1],
}
pub type C2RustUnnamed_16 = libc::c_uint;
pub const Tag_GNU_M68K_ABI_FP: C2RustUnnamed_16 = 4;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_Lib {
    pub l_name: libc::c_ulong,
    pub l_time_stamp: libc::c_ulong,
    pub l_checksum: libc::c_ulong,
    pub l_version: libc::c_ulong,
    pub l_flags: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Lib {
    pub l_name: [libc::c_uchar; 4],
    pub l_time_stamp: [libc::c_uchar; 4],
    pub l_checksum: [libc::c_uchar; 4],
    pub l_version: [libc::c_uchar; 4],
    pub l_flags: [libc::c_uchar; 4],
}
pub type Elf32_Conflict = libc::c_ulong;
pub type Elf32_External_Conflict = [libc::c_uchar; 4];
pub type Elf64_External_Conflict = [libc::c_uchar; 8];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_RegInfo {
    pub ri_gprmask: uint32_t,
    pub ri_cprmask: [uint32_t; 4],
    pub ri_gp_value: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_RegInfo {
    pub ri_gprmask: [libc::c_uchar; 4],
    pub ri_cprmask: [[libc::c_uchar; 4]; 4],
    pub ri_gp_value: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Options {
    pub kind: [libc::c_uchar; 1],
    pub size: [libc::c_uchar; 1],
    pub section: [libc::c_uchar; 2],
    pub info: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_Internal_Options {
    pub kind: libc::c_uchar,
    pub size: libc::c_uchar,
    pub section: uint16_t,
    pub info: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_RegInfo {
    pub ri_gprmask: [libc::c_uchar; 4],
    pub ri_pad: [libc::c_uchar; 4],
    pub ri_cprmask: [[libc::c_uchar; 4]; 4],
    pub ri_gp_value: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Internal_RegInfo {
    pub ri_gprmask: uint32_t,
    pub ri_pad: uint32_t,
    pub ri_cprmask: [uint32_t; 4],
    pub ri_gp_value: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_ABIFlags_v0 {
    pub version: [libc::c_uchar; 2],
    pub isa_level: [libc::c_uchar; 1],
    pub isa_rev: [libc::c_uchar; 1],
    pub gpr_size: [libc::c_uchar; 1],
    pub cpr1_size: [libc::c_uchar; 1],
    pub cpr2_size: [libc::c_uchar; 1],
    pub fp_abi: [libc::c_uchar; 1],
    pub isa_ext: [libc::c_uchar; 4],
    pub ases: [libc::c_uchar; 4],
    pub flags1: [libc::c_uchar; 4],
    pub flags2: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_abiflags_v0 {
    pub version: libc::c_ushort,
    pub isa_level: libc::c_uchar,
    pub isa_rev: libc::c_uchar,
    pub gpr_size: libc::c_uchar,
    pub cpr1_size: libc::c_uchar,
    pub cpr2_size: libc::c_uchar,
    pub fp_abi: libc::c_uchar,
    pub isa_ext: libc::c_ulong,
    pub ases: libc::c_ulong,
    pub flags1: libc::c_ulong,
    pub flags2: libc::c_ulong,
}
pub type Elf_Internal_ABIFlags_v0 = elf_internal_abiflags_v0;
pub type C2RustUnnamed_17 = libc::c_uint;
pub const Tag_GNU_MIPS_ABI_MSA: C2RustUnnamed_17 = 8;
pub const Tag_GNU_MIPS_ABI_FP: C2RustUnnamed_17 = 4;
pub type C2RustUnnamed_18 = libc::c_uint;
pub const Val_GNU_MIPS_ABI_MSA_128: C2RustUnnamed_18 = 1;
pub const Val_GNU_MIPS_ABI_MSA_ANY: C2RustUnnamed_18 = 0;
pub const Val_GNU_MIPS_ABI_FP_NAN2008: C2RustUnnamed_18 = 8;
pub const Val_GNU_MIPS_ABI_FP_64A: C2RustUnnamed_18 = 7;
pub const Val_GNU_MIPS_ABI_FP_64: C2RustUnnamed_18 = 6;
pub const Val_GNU_MIPS_ABI_FP_XX: C2RustUnnamed_18 = 5;
pub const Val_GNU_MIPS_ABI_FP_OLD_64: C2RustUnnamed_18 = 4;
pub const Val_GNU_MIPS_ABI_FP_SOFT: C2RustUnnamed_18 = 3;
pub const Val_GNU_MIPS_ABI_FP_SINGLE: C2RustUnnamed_18 = 2;
pub const Val_GNU_MIPS_ABI_FP_DOUBLE: C2RustUnnamed_18 = 1;
pub const Val_GNU_MIPS_ABI_FP_ANY: C2RustUnnamed_18 = 0;
pub type C2RustUnnamed_19 = libc::c_uint;
pub const Tag_GNU_MSP430_Data_Region: C2RustUnnamed_19 = 4;
pub type C2RustUnnamed_20 = libc::c_uint;
pub const Val_GNU_MSP430_Data_Region_Any: C2RustUnnamed_20 = 2;
pub const Val_GNU_MSP430_Data_Region_Lower: C2RustUnnamed_20 = 1;
pub const Val_GNU_MSP430_Data_Region_NONE: C2RustUnnamed_20 = 0;
pub const OFBA_MSPABI_Val_Data_Model_RESTRICTED: C2RustUnnamed_20 = 3;
pub const OFBA_MSPABI_Val_Data_Model_LARGE: C2RustUnnamed_20 = 2;
pub const OFBA_MSPABI_Val_Data_Model_SMALL: C2RustUnnamed_20 = 1;
pub const OFBA_MSPABI_Val_Data_Model_NONE: C2RustUnnamed_20 = 0;
pub const OFBA_MSPABI_Val_Code_Model_LARGE: C2RustUnnamed_20 = 2;
pub const OFBA_MSPABI_Val_Code_Model_SMALL: C2RustUnnamed_20 = 1;
pub const OFBA_MSPABI_Val_Code_Model_NONE: C2RustUnnamed_20 = 0;
pub const OFBA_MSPABI_Val_ISA_MSP430X: C2RustUnnamed_20 = 2;
pub const OFBA_MSPABI_Val_ISA_MSP430: C2RustUnnamed_20 = 1;
pub const OFBA_MSPABI_Val_ISA_NONE: C2RustUnnamed_20 = 0;
pub type C2RustUnnamed_21 = libc::c_uint;
pub const Tag_GNU_Power_ABI_Struct_Return: C2RustUnnamed_21 = 12;
pub const Tag_GNU_Power_ABI_Vector: C2RustUnnamed_21 = 8;
pub const Tag_GNU_Power_ABI_FP: C2RustUnnamed_21 = 4;
pub type C2RustUnnamed_22 = libc::c_uint;
pub const Tag_RISCV_priv_spec_revision: C2RustUnnamed_22 = 12;
pub const Tag_RISCV_priv_spec_minor: C2RustUnnamed_22 = 10;
pub const Tag_RISCV_priv_spec: C2RustUnnamed_22 = 8;
pub const Tag_RISCV_unaligned_access: C2RustUnnamed_22 = 6;
pub const Tag_RISCV_arch: C2RustUnnamed_22 = 5;
pub const Tag_RISCV_stack_align: C2RustUnnamed_22 = 4;
pub type C2RustUnnamed_23 = libc::c_uint;
pub const Tag_GNU_S390_ABI_Vector: C2RustUnnamed_23 = 8;
pub type C2RustUnnamed_24 = libc::c_uint;
pub const Tag_GNU_Sparc_HWCAPS2: C2RustUnnamed_24 = 8;
pub const Tag_GNU_Sparc_HWCAPS: C2RustUnnamed_24 = 4;
pub type C2RustUnnamed_25 = libc::c_uint;
pub const Tag_C6XABI_last: C2RustUnnamed_25 = 68;
pub const Tag_ABI_conformance: C2RustUnnamed_25 = 67;
pub const Tag_ABI_compatibility: C2RustUnnamed_25 = 32;
pub const Tag_ABI_array_object_align_expected: C2RustUnnamed_25 = 20;
pub const Tag_ABI_array_object_alignment: C2RustUnnamed_25 = 18;
pub const Tag_ABI_PIC: C2RustUnnamed_25 = 16;
pub const Tag_ABI_PID: C2RustUnnamed_25 = 14;
pub const Tag_ABI_DSBT: C2RustUnnamed_25 = 12;
pub const Tag_ABI_stack_align_preserved: C2RustUnnamed_25 = 10;
pub const Tag_ABI_stack_align_needed: C2RustUnnamed_25 = 8;
pub const Tag_ABI_wchar_t: C2RustUnnamed_25 = 6;
pub const Tag_ISA: C2RustUnnamed_25 = 4;
pub type C2RustUnnamed_26 = libc::c_uint;
pub const C6XABI_Tag_ISA_C674X: C2RustUnnamed_26 = 8;
pub const C6XABI_Tag_ISA_C64XP: C2RustUnnamed_26 = 7;
pub const C6XABI_Tag_ISA_C64X: C2RustUnnamed_26 = 6;
pub const C6XABI_Tag_ISA_C67XP: C2RustUnnamed_26 = 4;
pub const C6XABI_Tag_ISA_C67X: C2RustUnnamed_26 = 3;
pub const C6XABI_Tag_ISA_C62X: C2RustUnnamed_26 = 1;
pub const C6XABI_Tag_ISA_none: C2RustUnnamed_26 = 0;
pub type v850_notes = libc::c_uint;
pub const V850_NOTE_MMU_INFO: v850_notes = 6;
pub const V850_NOTE_CACHE_INFO: v850_notes = 5;
pub const V850_NOTE_SIMD_INFO: v850_notes = 4;
pub const V850_NOTE_FPU_INFO: v850_notes = 3;
pub const V850_NOTE_DATA_SIZE: v850_notes = 2;
pub const V850_NOTE_ALIGNMENT: v850_notes = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct option {
    pub name: *const libc::c_char,
    pub has_arg: libc::c_int,
    pub flag: *mut libc::c_int,
    pub val: libc::c_int,
}
pub type C2RustUnnamed_27 = libc::c_uint;
pub const _sch_isbasic: C2RustUnnamed_27 = 3088;
pub const _sch_iscppsp: C2RustUnnamed_27 = 3072;
pub const _sch_isgraph: C2RustUnnamed_27 = 172;
pub const _sch_isidnum: C2RustUnnamed_27 = 516;
pub const _sch_isalnum: C2RustUnnamed_27 = 140;
pub const _sch_isalpha: C2RustUnnamed_27 = 136;
pub const _sch_isnvsp: C2RustUnnamed_27 = 2048;
pub const _sch_isvsp: C2RustUnnamed_27 = 1024;
pub const _sch_isidst: C2RustUnnamed_27 = 512;
pub const _sch_isxdigit: C2RustUnnamed_27 = 256;
pub const _sch_isupper: C2RustUnnamed_27 = 128;
pub const _sch_isspace: C2RustUnnamed_27 = 64;
pub const _sch_ispunct: C2RustUnnamed_27 = 32;
pub const _sch_islower: C2RustUnnamed_27 = 8;
pub const _sch_isdigit: C2RustUnnamed_27 = 4;
pub const _sch_isblank: C2RustUnnamed_27 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dump_list_entry {
    pub name: *mut libc::c_char,
    pub type_0: dump_type,
    pub next: *mut dump_list_entry,
}
pub type print_mode = libc::c_uint;
pub const OCTAL_5: print_mode = 11;
pub const OCTAL: print_mode = 10;
pub const LONG_HEX: print_mode = 9;
pub const FULL_HEX: print_mode = 8;
pub const PREFIX_HEX_5: print_mode = 7;
pub const PREFIX_HEX: print_mode = 6;
pub const UNSIGNED_5: print_mode = 5;
pub const UNSIGNED: print_mode = 4;
pub const DEC_5: print_mode = 3;
pub const DEC: print_mode = 2;
pub const HEX_5: print_mode = 1;
pub const HEX: print_mode = 0;
pub type versioned_symbol_info = libc::c_uint;
pub const symbol_public: versioned_symbol_info = 2;
pub const symbol_hidden: versioned_symbol_info = 1;
pub const symbol_undefined: versioned_symbol_info = 0;
pub type long_option_values = libc::c_uint;
pub const OPTION_SYM_BASE: long_option_values = 526;
pub const OPTION_NO_DEMANGLING: long_option_values = 525;
pub const OPTION_NO_RECURSE_LIMIT: long_option_values = 524;
pub const OPTION_RECURSE_LIMIT: long_option_values = 523;
pub const OPTION_WITH_SYMBOL_VERSIONS: long_option_values = 522;
pub const OPTION_CTF_STRINGS: long_option_values = 521;
pub const OPTION_CTF_SYMBOLS: long_option_values = 520;
pub const OPTION_CTF_PARENT: long_option_values = 519;
pub const OPTION_CTF_DUMP: long_option_values = 518;
pub const OPTION_DWARF_CHECK: long_option_values = 517;
pub const OPTION_DWARF_START: long_option_values = 516;
pub const OPTION_DWARF_DEPTH: long_option_values = 515;
pub const OPTION_LTO_SYMS: long_option_values = 514;
pub const OPTION_DYN_SYMS: long_option_values = 513;
pub const OPTION_DEBUG_DUMP: long_option_values = 512;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_28 {
    pub str_0: *const libc::c_char,
    pub len: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ia64_vms_dynfixup {
    pub needed_ident: bfd_vma,
    pub needed: bfd_vma,
    pub fixup_needed: bfd_vma,
    pub fixup_rela_cnt: bfd_vma,
    pub fixup_rela_off: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ia64_vms_dynimgrela {
    pub img_rela_cnt: bfd_vma,
    pub img_rela_off: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_29 {
    pub name: *const libc::c_char,
    pub reloc: libc::c_int,
    pub size: libc::c_int,
    pub rela: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct absaddr {
    pub section: libc::c_ushort,
    pub offset: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ia64_unw_table_entry {
    pub start: absaddr,
    pub end: absaddr,
    pub info: absaddr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ia64_unw_aux_info {
    pub table: *mut ia64_unw_table_entry,
    pub table_len: libc::c_ulong,
    pub info: *mut libc::c_uchar,
    pub info_size: libc::c_ulong,
    pub info_addr: bfd_vma,
    pub seg_base: bfd_vma,
    pub symtab: *mut Elf_Internal_Sym,
    pub nsyms: libc::c_ulong,
    pub funtab: *mut Elf_Internal_Sym,
    pub nfuns: libc::c_ulong,
    pub strtab: *mut libc::c_char,
    pub strtab_size: libc::c_ulong,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct hppa_unw_table_entry {
    pub start: absaddr,
    pub end: absaddr,
    #[bitfield(name = "Cannot_unwind", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "Millicode", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "Millicode_save_sr0", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "Region_description", ty = "libc::c_uint", bits = "3..=4")]
    #[bitfield(name = "reserved1", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "Entry_SR", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "Entry_FR", ty = "libc::c_uint", bits = "7..=10")]
    #[bitfield(name = "Entry_GR", ty = "libc::c_uint", bits = "11..=15")]
    #[bitfield(name = "Args_stored", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "Variable_Frame", ty = "libc::c_uint", bits = "17..=17")]
    #[bitfield(name = "Separate_Package_Body", ty = "libc::c_uint", bits = "18..=18")]
    #[bitfield(name = "Frame_Extension_Millicode", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "Stack_Overflow_Check", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "Two_Instruction_SP_Increment", ty = "libc::c_uint", bits = "21..=21")]
    #[bitfield(name = "Ada_Region", ty = "libc::c_uint", bits = "22..=22")]
    #[bitfield(name = "cxx_info", ty = "libc::c_uint", bits = "23..=23")]
    #[bitfield(name = "cxx_try_catch", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "sched_entry_seq", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "reserved2", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "Save_SP", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "Save_RP", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "Save_MRP_in_frame", ty = "libc::c_uint", bits = "29..=29")]
    #[bitfield(name = "extn_ptr_defined", ty = "libc::c_uint", bits = "30..=30")]
    #[bitfield(name = "Cleanup_defined", ty = "libc::c_uint", bits = "31..=31")]
    #[bitfield(name = "MPE_XL_interrupt_marker", ty = "libc::c_uint", bits = "32..=32")]
    #[bitfield(name = "HP_UX_interrupt_marker", ty = "libc::c_uint", bits = "33..=33")]
    #[bitfield(name = "Large_frame", ty = "libc::c_uint", bits = "34..=34")]
    #[bitfield(name = "Pseudo_SP_Set", ty = "libc::c_uint", bits = "35..=35")]
    #[bitfield(name = "reserved4", ty = "libc::c_uint", bits = "36..=36")]
    #[bitfield(name = "Total_frame_size", ty = "libc::c_uint", bits = "37..=63")]
    pub Cannot_unwind_Millicode_Millicode_save_sr0_Region_description_reserved1_Entry_SR_Entry_FR_Entry_GR_Args_stored_Variable_Frame_Separate_Package_Body_Frame_Extension_Millicode_Stack_Overflow_Check_Two_Instruction_SP_Increment_Ada_Region_cxx_info_cxx_try_catch_sched_entry_seq_reserved2_Save_SP_Save_RP_Save_MRP_in_frame_extn_ptr_defined_Cleanup_defined_MPE_XL_interrupt_marker_HP_UX_interrupt_marker_Large_frame_Pseudo_SP_Set_reserved4_Total_frame_size: [u8; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct hppa_unw_aux_info {
    pub table: *mut hppa_unw_table_entry,
    pub table_len: libc::c_ulong,
    pub seg_base: bfd_vma,
    pub symtab: *mut Elf_Internal_Sym,
    pub nsyms: libc::c_ulong,
    pub funtab: *mut Elf_Internal_Sym,
    pub nfuns: libc::c_ulong,
    pub strtab: *mut libc::c_char,
    pub strtab_size: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arm_section {
    pub data: *mut libc::c_uchar,
    pub sec: *mut Elf_Internal_Shdr,
    pub rela: *mut Elf_Internal_Rela,
    pub nrelas: libc::c_ulong,
    pub rel_type: libc::c_uint,
    pub next_rela: *mut Elf_Internal_Rela,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arm_unw_aux_info {
    pub filedata: *mut Filedata,
    pub symtab: *mut Elf_Internal_Sym,
    pub nsyms: libc::c_ulong,
    pub funtab: *mut Elf_Internal_Sym,
    pub nfuns: libc::c_ulong,
    pub strtab: *mut libc::c_char,
    pub strtab_size: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_30 {
    pub offset: libc::c_uint,
    pub reg: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unwind_handler {
    pub machtype: libc::c_uint,
    pub handler: Option::<unsafe extern "C" fn(*mut Filedata) -> bool>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_31 {
    pub bit: libc::c_long,
    pub str_0: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arm_attr_public_tag {
    pub tag: libc::c_uint,
    pub name: *const libc::c_char,
    pub type_0: libc::c_uint,
    pub table: *const *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct riscv_attr_tag_t {
    pub name: *const libc::c_char,
    pub tag: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_32 {
    pub name: *const libc::c_char,
    pub bit: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct build_attr_cache {
    pub filedata: *mut Filedata,
    pub strtab: *mut libc::c_char,
    pub strtablen: libc::c_ulong,
    pub symtab: *mut Elf_Internal_Sym,
    pub nsyms: libc::c_ulong,
}
#[inline]
unsafe extern "C" fn putchar(mut __c: libc::c_int) -> libc::c_int {
    return putc(__c, stdout);
}
#[inline]
unsafe extern "C" fn startswith(
    mut str_0: *const libc::c_char,
    mut prefix: *const libc::c_char,
) -> bool {
    return strncmp(str_0, prefix, strlen(prefix)) == 0 as libc::c_int;
}
#[no_mangle]
pub static mut program_name: *mut libc::c_char = b"readelf\0" as *const u8
    as *const libc::c_char as *mut libc::c_char;
#[no_mangle]
pub unsafe extern "C" fn load_debug_section(
    mut debug: dwarf_section_display_enum,
    mut data: *mut libc::c_void,
) -> bool {
    let mut section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(debug as isize))
        .section;
    let mut sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut filedata: *mut Filedata = data as *mut Filedata;
    if ((*filedata).section_headers).is_null() {
        return 0 as libc::c_int != 0;
    }
    if ((*filedata).string_table).is_null()
        && (*filedata).file_header.e_shstrndx != 0 as libc::c_int as libc::c_uint
        && (*filedata).file_header.e_shstrndx < (*filedata).file_header.e_shnum
    {
        let mut strs: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        strs = ((*filedata).section_headers)
            .offset((*filedata).file_header.e_shstrndx as isize);
        if !strs.is_null() && (*strs).sh_size != 0 as libc::c_int as libc::c_ulong {
            (*filedata)
                .string_table = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*strs).sh_offset as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                (*strs).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"string table\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut libc::c_char;
            (*filedata)
                .string_table_length = if !((*filedata).string_table).is_null() {
                (*strs).sh_size
            } else {
                0 as libc::c_int as libc::c_ulong
            };
        }
    }
    sec = find_section_in_set(filedata, (*section).uncompressed_name, section_subset);
    if !sec.is_null() {
        (*section).name = (*section).uncompressed_name;
    } else {
        sec = find_section_in_set(filedata, (*section).compressed_name, section_subset);
        if !sec.is_null() {
            (*section).name = (*section).compressed_name;
        }
    }
    if sec.is_null() {
        return 0 as libc::c_int != 0;
    }
    if !section_subset.is_null() {
        free_debug_section(debug);
    }
    return load_specific_debug_section(debug, sec, data);
}
#[no_mangle]
pub unsafe extern "C" fn free_debug_section(mut debug: dwarf_section_display_enum) {
    let mut section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(debug as isize))
        .section;
    if ((*section).start).is_null() {
        return;
    }
    free((*section).start as *mut libc::c_char as *mut libc::c_void);
    (*section).start = 0 as *mut libc::c_uchar;
    (*section).address = 0 as libc::c_int as dwarf_vma;
    (*section).size = 0 as libc::c_int as dwarf_size_type;
    free((*section).reloc_info);
    (*section).reloc_info = 0 as *mut libc::c_void;
    (*section).num_relocs = 0 as libc::c_int as libc::c_ulong;
}
#[no_mangle]
pub unsafe extern "C" fn close_debug_file(mut data: *mut libc::c_void) {
    free_filedata(data as *mut Filedata);
    close_file(data as *mut Filedata);
}
#[no_mangle]
pub unsafe extern "C" fn open_debug_file(
    mut pathname: *const libc::c_char,
) -> *mut libc::c_void {
    return open_file(pathname, 1 as libc::c_int != 0) as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn reloc_at(
    mut dsec: *mut dwarf_section,
    mut offset: dwarf_vma,
) -> bool {
    let mut relocs: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut rp: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    if dsec.is_null() || ((*dsec).reloc_info).is_null() {
        return 0 as libc::c_int != 0;
    }
    relocs = (*dsec).reloc_info as *mut Elf_Internal_Rela;
    rp = relocs;
    while rp < relocs.offset((*dsec).num_relocs as isize) {
        if (*rp).r_offset == offset {
            return 1 as libc::c_int != 0;
        }
        rp = rp.offset(1);
        rp;
    }
    return 0 as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn report_leb_status(
    mut status: libc::c_int,
    mut file: *const libc::c_char,
    mut lnum: libc::c_ulong,
) {
    if status & 1 as libc::c_int != 0 as libc::c_int {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"%s:%lu: end of data encountered whilst reading LEB\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            file,
            lnum,
        );
    } else if status & 2 as libc::c_int != 0 as libc::c_int {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"%s:%lu: read LEB value is too large to store in destination variable\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            file,
            lnum,
        );
    }
}
unsafe extern "C" fn elf_h8_reloc_type(mut rtype: libc::c_ulong) -> *const libc::c_char {
    match rtype {
        0 => return b"R_H8_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_H8_DIR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_H8_DIR32_28\0" as *const u8 as *const libc::c_char,
        3 => return b"R_H8_DIR32_24\0" as *const u8 as *const libc::c_char,
        4 => return b"R_H8_DIR32_16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_H8_DIR32U\0" as *const u8 as *const libc::c_char,
        7 => return b"R_H8_DIR32U_28\0" as *const u8 as *const libc::c_char,
        8 => return b"R_H8_DIR32U_24\0" as *const u8 as *const libc::c_char,
        9 => return b"R_H8_DIR32U_20\0" as *const u8 as *const libc::c_char,
        10 => return b"R_H8_DIR32U_16\0" as *const u8 as *const libc::c_char,
        11 => return b"R_H8_DIR24\0" as *const u8 as *const libc::c_char,
        12 => return b"R_H8_DIR24_20\0" as *const u8 as *const libc::c_char,
        13 => return b"R_H8_DIR24_16\0" as *const u8 as *const libc::c_char,
        14 => return b"R_H8_DIR24U\0" as *const u8 as *const libc::c_char,
        15 => return b"R_H8_DIR24U_20\0" as *const u8 as *const libc::c_char,
        16 => return b"R_H8_DIR24U_16\0" as *const u8 as *const libc::c_char,
        17 => return b"R_H8_DIR16\0" as *const u8 as *const libc::c_char,
        18 => return b"R_H8_DIR16U\0" as *const u8 as *const libc::c_char,
        19 => return b"R_H8_DIR16S_32\0" as *const u8 as *const libc::c_char,
        20 => return b"R_H8_DIR16S_28\0" as *const u8 as *const libc::c_char,
        21 => return b"R_H8_DIR16S_24\0" as *const u8 as *const libc::c_char,
        22 => return b"R_H8_DIR16S_20\0" as *const u8 as *const libc::c_char,
        23 => return b"R_H8_DIR16S\0" as *const u8 as *const libc::c_char,
        24 => return b"R_H8_DIR8\0" as *const u8 as *const libc::c_char,
        25 => return b"R_H8_DIR8U\0" as *const u8 as *const libc::c_char,
        26 => return b"R_H8_DIR8Z_32\0" as *const u8 as *const libc::c_char,
        27 => return b"R_H8_DIR8Z_28\0" as *const u8 as *const libc::c_char,
        28 => return b"R_H8_DIR8Z_24\0" as *const u8 as *const libc::c_char,
        29 => return b"R_H8_DIR8Z_20\0" as *const u8 as *const libc::c_char,
        30 => return b"R_H8_DIR8Z_16\0" as *const u8 as *const libc::c_char,
        31 => return b"R_H8_PCREL16\0" as *const u8 as *const libc::c_char,
        32 => return b"R_H8_PCREL8\0" as *const u8 as *const libc::c_char,
        33 => return b"R_H8_BPOS\0" as *const u8 as *const libc::c_char,
        59 => return b"R_H8_DIR16A8\0" as *const u8 as *const libc::c_char,
        60 => return b"R_H8_DIR16R8\0" as *const u8 as *const libc::c_char,
        61 => return b"R_H8_DIR24A8\0" as *const u8 as *const libc::c_char,
        62 => return b"R_H8_DIR24R8\0" as *const u8 as *const libc::c_char,
        63 => return b"R_H8_DIR32A16\0" as *const u8 as *const libc::c_char,
        64 => return b"R_H8_DISP32A16\0" as *const u8 as *const libc::c_char,
        65 => return b"R_H8_ABS32\0" as *const u8 as *const libc::c_char,
        127 => return b"R_H8_ABS32A16\0" as *const u8 as *const libc::c_char,
        128 => return b"R_H8_SYM\0" as *const u8 as *const libc::c_char,
        129 => return b"R_H8_OPneg\0" as *const u8 as *const libc::c_char,
        130 => return b"R_H8_OPadd\0" as *const u8 as *const libc::c_char,
        131 => return b"R_H8_OPsub\0" as *const u8 as *const libc::c_char,
        132 => return b"R_H8_OPmul\0" as *const u8 as *const libc::c_char,
        133 => return b"R_H8_OPdiv\0" as *const u8 as *const libc::c_char,
        134 => return b"R_H8_OPshla\0" as *const u8 as *const libc::c_char,
        135 => return b"R_H8_OPshra\0" as *const u8 as *const libc::c_char,
        136 => return b"R_H8_OPsctsize\0" as *const u8 as *const libc::c_char,
        137 => return b"R_H8_OPhword\0" as *const u8 as *const libc::c_char,
        138 => return b"R_H8_OPlword\0" as *const u8 as *const libc::c_char,
        139 => return b"R_H8_OPhigh\0" as *const u8 as *const libc::c_char,
        140 => return b"R_H8_OPlow\0" as *const u8 as *const libc::c_char,
        141 => return b"R_H8_OPscttop\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_aarch64_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_AARCH64_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_AARCH64_P32_ABS32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_AARCH64_P32_ABS16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_AARCH64_P32_PREL32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_AARCH64_P32_PREL16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_AARCH64_P32_MOVW_UABS_G0\0" as *const u8 as *const libc::c_char,
        6 => {
            return b"R_AARCH64_P32_MOVW_UABS_G0_NC\0" as *const u8 as *const libc::c_char;
        }
        7 => return b"R_AARCH64_P32_MOVW_UABS_G1\0" as *const u8 as *const libc::c_char,
        8 => return b"R_AARCH64_P32_MOVW_SABS_G0\0" as *const u8 as *const libc::c_char,
        9 => return b"R_AARCH64_P32_LD_PREL_LO19\0" as *const u8 as *const libc::c_char,
        10 => return b"R_AARCH64_P32_ADR_PREL_LO21\0" as *const u8 as *const libc::c_char,
        11 => {
            return b"R_AARCH64_P32_ADR_PREL_PG_HI21\0" as *const u8
                as *const libc::c_char;
        }
        12 => {
            return b"R_AARCH64_P32_ADD_ABS_LO12_NC\0" as *const u8 as *const libc::c_char;
        }
        13 => {
            return b"R_AARCH64_P32_LDST8_ABS_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        14 => {
            return b"R_AARCH64_P32_LDST16_ABS_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        15 => {
            return b"R_AARCH64_P32_LDST32_ABS_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        16 => {
            return b"R_AARCH64_P32_LDST64_ABS_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        17 => {
            return b"R_AARCH64_P32_LDST128_ABS_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        18 => return b"R_AARCH64_P32_TSTBR14\0" as *const u8 as *const libc::c_char,
        19 => return b"R_AARCH64_P32_CONDBR19\0" as *const u8 as *const libc::c_char,
        20 => return b"R_AARCH64_P32_JUMP26\0" as *const u8 as *const libc::c_char,
        21 => return b"R_AARCH64_P32_CALL26\0" as *const u8 as *const libc::c_char,
        22 => return b"R_AARCH64_P32_MOVW_PREL_G0\0" as *const u8 as *const libc::c_char,
        23 => {
            return b"R_AARCH64_P32_MOVW_PREL_G0_NC\0" as *const u8 as *const libc::c_char;
        }
        24 => return b"R_AARCH64_P32_MOVW_PREL_G1\0" as *const u8 as *const libc::c_char,
        25 => return b"R_AARCH64_P32_GOT_LD_PREL19\0" as *const u8 as *const libc::c_char,
        26 => return b"R_AARCH64_P32_ADR_GOT_PAGE\0" as *const u8 as *const libc::c_char,
        27 => {
            return b"R_AARCH64_P32_LD32_GOT_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        28 => {
            return b"R_AARCH64_P32_LD32_GOTPAGE_LO14\0" as *const u8
                as *const libc::c_char;
        }
        80 => {
            return b"R_AARCH64_P32_TLSGD_ADR_PREL21\0" as *const u8
                as *const libc::c_char;
        }
        81 => {
            return b"R_AARCH64_P32_TLSGD_ADR_PAGE21\0" as *const u8
                as *const libc::c_char;
        }
        82 => {
            return b"R_AARCH64_P32_TLSGD_ADD_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        83 => {
            return b"R_AARCH64_P32_TLSLD_ADR_PREL21\0" as *const u8
                as *const libc::c_char;
        }
        84 => {
            return b"R_AARCH64_P32_TLSLD_ADR_PAGE21\0" as *const u8
                as *const libc::c_char;
        }
        85 => {
            return b"R_AARCH64_P32_TLSLD_ADD_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        87 => {
            return b"R_AARCH64_P32_TLSLD_MOVW_DTPREL_G1\0" as *const u8
                as *const libc::c_char;
        }
        88 => {
            return b"R_AARCH64_P32_TLSLD_MOVW_DTPREL_G0\0" as *const u8
                as *const libc::c_char;
        }
        89 => {
            return b"R_AARCH64_P32_TLSLD_MOVW_DTPREL_G0_NC\0" as *const u8
                as *const libc::c_char;
        }
        90 => {
            return b"R_AARCH64_P32_TLSLD_ADD_DTPREL_HI12\0" as *const u8
                as *const libc::c_char;
        }
        91 => {
            return b"R_AARCH64_P32_TLSLD_ADD_DTPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        92 => {
            return b"R_AARCH64_P32_TLSLD_ADD_DTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        103 => {
            return b"R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21\0" as *const u8
                as *const libc::c_char;
        }
        104 => {
            return b"R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        105 => {
            return b"R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19\0" as *const u8
                as *const libc::c_char;
        }
        106 => {
            return b"R_AARCH64_P32_TLSLE_MOVW_TPREL_G1\0" as *const u8
                as *const libc::c_char;
        }
        107 => {
            return b"R_AARCH64_P32_TLSLE_MOVW_TPREL_G0\0" as *const u8
                as *const libc::c_char;
        }
        108 => {
            return b"R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC\0" as *const u8
                as *const libc::c_char;
        }
        109 => {
            return b"R_AARCH64_P32_TLSLE_ADD_TPREL_HI12\0" as *const u8
                as *const libc::c_char;
        }
        110 => {
            return b"R_AARCH64_P32_TLSLE_ADD_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        111 => {
            return b"R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        112 => {
            return b"R_AARCH64_P32_TLSLE_LDST8_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        113 => {
            return b"R_AARCH64_P32_TLSLE_LDST8_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        114 => {
            return b"R_AARCH64_P32_TLSLE_LDST16_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        115 => {
            return b"R_AARCH64_P32_TLSLE_LDST16_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        116 => {
            return b"R_AARCH64_P32_TLSLE_LDST32_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        117 => {
            return b"R_AARCH64_P32_TLSLE_LDST32_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        118 => {
            return b"R_AARCH64_P32_TLSLE_LDST64_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        119 => {
            return b"R_AARCH64_P32_TLSLE_LDST64_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        122 => {
            return b"R_AARCH64_P32_TLSDESC_LD_PREL19\0" as *const u8
                as *const libc::c_char;
        }
        123 => {
            return b"R_AARCH64_P32_TLSDESC_ADR_PREL21\0" as *const u8
                as *const libc::c_char;
        }
        124 => {
            return b"R_AARCH64_P32_TLSDESC_ADR_PAGE21\0" as *const u8
                as *const libc::c_char;
        }
        125 => {
            return b"R_AARCH64_P32_TLSDESC_LD32_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        126 => {
            return b"R_AARCH64_P32_TLSDESC_ADD_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        127 => return b"R_AARCH64_P32_TLSDESC_CALL\0" as *const u8 as *const libc::c_char,
        180 => return b"R_AARCH64_P32_COPY\0" as *const u8 as *const libc::c_char,
        181 => return b"R_AARCH64_P32_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        182 => return b"R_AARCH64_P32_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        183 => return b"R_AARCH64_P32_RELATIVE\0" as *const u8 as *const libc::c_char,
        184 => return b"R_AARCH64_P32_TLS_DTPMOD\0" as *const u8 as *const libc::c_char,
        185 => return b"R_AARCH64_P32_TLS_DTPREL\0" as *const u8 as *const libc::c_char,
        186 => return b"R_AARCH64_P32_TLS_TPREL\0" as *const u8 as *const libc::c_char,
        187 => return b"R_AARCH64_P32_TLSDESC\0" as *const u8 as *const libc::c_char,
        188 => return b"R_AARCH64_P32_IRELATIVE\0" as *const u8 as *const libc::c_char,
        256 => return b"R_AARCH64_NULL\0" as *const u8 as *const libc::c_char,
        257 => return b"R_AARCH64_ABS64\0" as *const u8 as *const libc::c_char,
        258 => return b"R_AARCH64_ABS32\0" as *const u8 as *const libc::c_char,
        259 => return b"R_AARCH64_ABS16\0" as *const u8 as *const libc::c_char,
        260 => return b"R_AARCH64_PREL64\0" as *const u8 as *const libc::c_char,
        261 => return b"R_AARCH64_PREL32\0" as *const u8 as *const libc::c_char,
        262 => return b"R_AARCH64_PREL16\0" as *const u8 as *const libc::c_char,
        263 => return b"R_AARCH64_MOVW_UABS_G0\0" as *const u8 as *const libc::c_char,
        264 => return b"R_AARCH64_MOVW_UABS_G0_NC\0" as *const u8 as *const libc::c_char,
        265 => return b"R_AARCH64_MOVW_UABS_G1\0" as *const u8 as *const libc::c_char,
        266 => return b"R_AARCH64_MOVW_UABS_G1_NC\0" as *const u8 as *const libc::c_char,
        267 => return b"R_AARCH64_MOVW_UABS_G2\0" as *const u8 as *const libc::c_char,
        268 => return b"R_AARCH64_MOVW_UABS_G2_NC\0" as *const u8 as *const libc::c_char,
        269 => return b"R_AARCH64_MOVW_UABS_G3\0" as *const u8 as *const libc::c_char,
        270 => return b"R_AARCH64_MOVW_SABS_G0\0" as *const u8 as *const libc::c_char,
        271 => return b"R_AARCH64_MOVW_SABS_G1\0" as *const u8 as *const libc::c_char,
        272 => return b"R_AARCH64_MOVW_SABS_G2\0" as *const u8 as *const libc::c_char,
        273 => return b"R_AARCH64_LD_PREL_LO19\0" as *const u8 as *const libc::c_char,
        274 => return b"R_AARCH64_ADR_PREL_LO21\0" as *const u8 as *const libc::c_char,
        275 => return b"R_AARCH64_ADR_PREL_PG_HI21\0" as *const u8 as *const libc::c_char,
        276 => {
            return b"R_AARCH64_ADR_PREL_PG_HI21_NC\0" as *const u8 as *const libc::c_char;
        }
        277 => return b"R_AARCH64_ADD_ABS_LO12_NC\0" as *const u8 as *const libc::c_char,
        278 => {
            return b"R_AARCH64_LDST8_ABS_LO12_NC\0" as *const u8 as *const libc::c_char;
        }
        279 => return b"R_AARCH64_TSTBR14\0" as *const u8 as *const libc::c_char,
        280 => return b"R_AARCH64_CONDBR19\0" as *const u8 as *const libc::c_char,
        282 => return b"R_AARCH64_JUMP26\0" as *const u8 as *const libc::c_char,
        283 => return b"R_AARCH64_CALL26\0" as *const u8 as *const libc::c_char,
        284 => {
            return b"R_AARCH64_LDST16_ABS_LO12_NC\0" as *const u8 as *const libc::c_char;
        }
        285 => {
            return b"R_AARCH64_LDST32_ABS_LO12_NC\0" as *const u8 as *const libc::c_char;
        }
        286 => {
            return b"R_AARCH64_LDST64_ABS_LO12_NC\0" as *const u8 as *const libc::c_char;
        }
        287 => return b"R_AARCH64_MOVW_PREL_G0\0" as *const u8 as *const libc::c_char,
        288 => return b"R_AARCH64_MOVW_PREL_G0_NC\0" as *const u8 as *const libc::c_char,
        289 => return b"R_AARCH64_MOVW_PREL_G1\0" as *const u8 as *const libc::c_char,
        290 => return b"R_AARCH64_MOVW_PREL_G1_NC\0" as *const u8 as *const libc::c_char,
        291 => return b"R_AARCH64_MOVW_PREL_G2\0" as *const u8 as *const libc::c_char,
        292 => return b"R_AARCH64_MOVW_PREL_G2_NC\0" as *const u8 as *const libc::c_char,
        293 => return b"R_AARCH64_MOVW_PREL_G3\0" as *const u8 as *const libc::c_char,
        299 => {
            return b"R_AARCH64_LDST128_ABS_LO12_NC\0" as *const u8 as *const libc::c_char;
        }
        300 => return b"R_AARCH64_MOVW_GOTOFF_G0\0" as *const u8 as *const libc::c_char,
        301 => {
            return b"R_AARCH64_MOVW_GOTOFF_G0_NC\0" as *const u8 as *const libc::c_char;
        }
        302 => return b"R_AARCH64_MOVW_GOTOFF_G1\0" as *const u8 as *const libc::c_char,
        303 => {
            return b"R_AARCH64_MOVW_GOTOFF_G1_NC\0" as *const u8 as *const libc::c_char;
        }
        304 => return b"R_AARCH64_MOVW_GOTOFF_G2\0" as *const u8 as *const libc::c_char,
        305 => {
            return b"R_AARCH64_MOVW_GOTOFF_G2_NC\0" as *const u8 as *const libc::c_char;
        }
        306 => return b"R_AARCH64_MOVW_GOTOFF_G3\0" as *const u8 as *const libc::c_char,
        307 => return b"R_AARCH64_GOTREL64\0" as *const u8 as *const libc::c_char,
        308 => return b"R_AARCH64_GOTREL32\0" as *const u8 as *const libc::c_char,
        309 => return b"R_AARCH64_GOT_LD_PREL19\0" as *const u8 as *const libc::c_char,
        310 => return b"R_AARCH64_LD64_GOTOFF_LO15\0" as *const u8 as *const libc::c_char,
        311 => return b"R_AARCH64_ADR_GOT_PAGE\0" as *const u8 as *const libc::c_char,
        312 => return b"R_AARCH64_LD64_GOT_LO12_NC\0" as *const u8 as *const libc::c_char,
        313 => {
            return b"R_AARCH64_LD64_GOTPAGE_LO15\0" as *const u8 as *const libc::c_char;
        }
        512 => return b"R_AARCH64_TLSGD_ADR_PREL21\0" as *const u8 as *const libc::c_char,
        513 => return b"R_AARCH64_TLSGD_ADR_PAGE21\0" as *const u8 as *const libc::c_char,
        514 => {
            return b"R_AARCH64_TLSGD_ADD_LO12_NC\0" as *const u8 as *const libc::c_char;
        }
        515 => return b"R_AARCH64_TLSGD_MOVW_G1\0" as *const u8 as *const libc::c_char,
        516 => return b"R_AARCH64_TLSGD_MOVW_G0_NC\0" as *const u8 as *const libc::c_char,
        517 => return b"R_AARCH64_TLSLD_ADR_PREL21\0" as *const u8 as *const libc::c_char,
        518 => return b"R_AARCH64_TLSLD_ADR_PAGE21\0" as *const u8 as *const libc::c_char,
        519 => {
            return b"R_AARCH64_TLSLD_ADD_LO12_NC\0" as *const u8 as *const libc::c_char;
        }
        520 => return b"R_AARCH64_TLSLD_MOVW_G1\0" as *const u8 as *const libc::c_char,
        521 => return b"R_AARCH64_TLSLD_MOVW_G0_NC\0" as *const u8 as *const libc::c_char,
        522 => return b"R_AARCH64_TLSLD_LD_PREL19\0" as *const u8 as *const libc::c_char,
        523 => {
            return b"R_AARCH64_TLSLD_MOVW_DTPREL_G2\0" as *const u8
                as *const libc::c_char;
        }
        524 => {
            return b"R_AARCH64_TLSLD_MOVW_DTPREL_G1\0" as *const u8
                as *const libc::c_char;
        }
        525 => {
            return b"R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC\0" as *const u8
                as *const libc::c_char;
        }
        526 => {
            return b"R_AARCH64_TLSLD_MOVW_DTPREL_G0\0" as *const u8
                as *const libc::c_char;
        }
        527 => {
            return b"R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC\0" as *const u8
                as *const libc::c_char;
        }
        528 => {
            return b"R_AARCH64_TLSLD_ADD_DTPREL_HI12\0" as *const u8
                as *const libc::c_char;
        }
        529 => {
            return b"R_AARCH64_TLSLD_ADD_DTPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        530 => {
            return b"R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        531 => {
            return b"R_AARCH64_TLSLD_LDST8_DTPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        532 => {
            return b"R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        533 => {
            return b"R_AARCH64_TLSLD_LDST16_DTPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        534 => {
            return b"R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        535 => {
            return b"R_AARCH64_TLSLD_LDST32_DTPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        536 => {
            return b"R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        537 => {
            return b"R_AARCH64_TLSLD_LDST64_DTPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        538 => {
            return b"R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        539 => {
            return b"R_AARCH64_TLSIE_MOVW_GOTTPREL_G1\0" as *const u8
                as *const libc::c_char;
        }
        540 => {
            return b"R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC\0" as *const u8
                as *const libc::c_char;
        }
        541 => {
            return b"R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21\0" as *const u8
                as *const libc::c_char;
        }
        542 => {
            return b"R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        543 => {
            return b"R_AARCH64_TLSIE_LD_GOTTPREL_PREL19\0" as *const u8
                as *const libc::c_char;
        }
        544 => {
            return b"R_AARCH64_TLSLE_MOVW_TPREL_G2\0" as *const u8 as *const libc::c_char;
        }
        545 => {
            return b"R_AARCH64_TLSLE_MOVW_TPREL_G1\0" as *const u8 as *const libc::c_char;
        }
        546 => {
            return b"R_AARCH64_TLSLE_MOVW_TPREL_G1_NC\0" as *const u8
                as *const libc::c_char;
        }
        547 => {
            return b"R_AARCH64_TLSLE_MOVW_TPREL_G0\0" as *const u8 as *const libc::c_char;
        }
        548 => {
            return b"R_AARCH64_TLSLE_MOVW_TPREL_G0_NC\0" as *const u8
                as *const libc::c_char;
        }
        549 => {
            return b"R_AARCH64_TLSLE_ADD_TPREL_HI12\0" as *const u8
                as *const libc::c_char;
        }
        550 => {
            return b"R_AARCH64_TLSLE_ADD_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        551 => {
            return b"R_AARCH64_TLSLE_ADD_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        552 => {
            return b"R_AARCH64_TLSLE_LDST8_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        553 => {
            return b"R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        554 => {
            return b"R_AARCH64_TLSLE_LDST16_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        555 => {
            return b"R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        556 => {
            return b"R_AARCH64_TLSLE_LDST32_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        557 => {
            return b"R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        558 => {
            return b"R_AARCH64_TLSLE_LDST64_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        559 => {
            return b"R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        560 => {
            return b"R_AARCH64_TLSDESC_LD_PREL19\0" as *const u8 as *const libc::c_char;
        }
        561 => {
            return b"R_AARCH64_TLSDESC_ADR_PREL21\0" as *const u8 as *const libc::c_char;
        }
        562 => {
            return b"R_AARCH64_TLSDESC_ADR_PAGE21\0" as *const u8 as *const libc::c_char;
        }
        563 => {
            return b"R_AARCH64_TLSDESC_LD64_LO12\0" as *const u8 as *const libc::c_char;
        }
        564 => return b"R_AARCH64_TLSDESC_ADD_LO12\0" as *const u8 as *const libc::c_char,
        565 => return b"R_AARCH64_TLSDESC_OFF_G1\0" as *const u8 as *const libc::c_char,
        566 => {
            return b"R_AARCH64_TLSDESC_OFF_G0_NC\0" as *const u8 as *const libc::c_char;
        }
        567 => return b"R_AARCH64_TLSDESC_LDR\0" as *const u8 as *const libc::c_char,
        568 => return b"R_AARCH64_TLSDESC_ADD\0" as *const u8 as *const libc::c_char,
        569 => return b"R_AARCH64_TLSDESC_CALL\0" as *const u8 as *const libc::c_char,
        570 => {
            return b"R_AARCH64_TLSLE_LDST128_TPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        571 => {
            return b"R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        572 => {
            return b"R_AARCH64_TLSLD_LDST128_DTPREL_LO12\0" as *const u8
                as *const libc::c_char;
        }
        573 => {
            return b"R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC\0" as *const u8
                as *const libc::c_char;
        }
        1024 => return b"R_AARCH64_COPY\0" as *const u8 as *const libc::c_char,
        1025 => return b"R_AARCH64_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        1026 => return b"R_AARCH64_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        1027 => return b"R_AARCH64_RELATIVE\0" as *const u8 as *const libc::c_char,
        1028 => return b"R_AARCH64_TLS_DTPMOD64\0" as *const u8 as *const libc::c_char,
        1029 => return b"R_AARCH64_TLS_DTPREL64\0" as *const u8 as *const libc::c_char,
        1030 => return b"R_AARCH64_TLS_TPREL64\0" as *const u8 as *const libc::c_char,
        1031 => return b"R_AARCH64_TLSDESC\0" as *const u8 as *const libc::c_char,
        1032 => return b"R_AARCH64_IRELATIVE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_alpha_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_ALPHA_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_ALPHA_REFLONG\0" as *const u8 as *const libc::c_char,
        2 => return b"R_ALPHA_REFQUAD\0" as *const u8 as *const libc::c_char,
        3 => return b"R_ALPHA_GPREL32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_ALPHA_LITERAL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_ALPHA_LITUSE\0" as *const u8 as *const libc::c_char,
        6 => return b"R_ALPHA_GPDISP\0" as *const u8 as *const libc::c_char,
        7 => return b"R_ALPHA_BRADDR\0" as *const u8 as *const libc::c_char,
        8 => return b"R_ALPHA_HINT\0" as *const u8 as *const libc::c_char,
        9 => return b"R_ALPHA_SREL16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_ALPHA_SREL32\0" as *const u8 as *const libc::c_char,
        11 => return b"R_ALPHA_SREL64\0" as *const u8 as *const libc::c_char,
        17 => return b"R_ALPHA_GPRELHIGH\0" as *const u8 as *const libc::c_char,
        18 => return b"R_ALPHA_GPRELLOW\0" as *const u8 as *const libc::c_char,
        19 => return b"R_ALPHA_GPREL16\0" as *const u8 as *const libc::c_char,
        24 => return b"R_ALPHA_COPY\0" as *const u8 as *const libc::c_char,
        25 => return b"R_ALPHA_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        26 => return b"R_ALPHA_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        27 => return b"R_ALPHA_RELATIVE\0" as *const u8 as *const libc::c_char,
        28 => return b"R_ALPHA_BRSGP\0" as *const u8 as *const libc::c_char,
        29 => return b"R_ALPHA_TLSGD\0" as *const u8 as *const libc::c_char,
        30 => return b"R_ALPHA_TLSLDM\0" as *const u8 as *const libc::c_char,
        31 => return b"R_ALPHA_DTPMOD64\0" as *const u8 as *const libc::c_char,
        32 => return b"R_ALPHA_GOTDTPREL\0" as *const u8 as *const libc::c_char,
        33 => return b"R_ALPHA_DTPREL64\0" as *const u8 as *const libc::c_char,
        34 => return b"R_ALPHA_DTPRELHI\0" as *const u8 as *const libc::c_char,
        35 => return b"R_ALPHA_DTPRELLO\0" as *const u8 as *const libc::c_char,
        36 => return b"R_ALPHA_DTPREL16\0" as *const u8 as *const libc::c_char,
        37 => return b"R_ALPHA_GOTTPREL\0" as *const u8 as *const libc::c_char,
        38 => return b"R_ALPHA_TPREL64\0" as *const u8 as *const libc::c_char,
        39 => return b"R_ALPHA_TPRELHI\0" as *const u8 as *const libc::c_char,
        40 => return b"R_ALPHA_TPRELLO\0" as *const u8 as *const libc::c_char,
        41 => return b"R_ALPHA_TPREL16\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_arc_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_ARC_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_ARC_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_ARC_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_ARC_24\0" as *const u8 as *const libc::c_char,
        4 => return b"R_ARC_32\0" as *const u8 as *const libc::c_char,
        8 => return b"R_ARC_N8\0" as *const u8 as *const libc::c_char,
        9 => return b"R_ARC_N16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_ARC_N24\0" as *const u8 as *const libc::c_char,
        11 => return b"R_ARC_N32\0" as *const u8 as *const libc::c_char,
        12 => return b"R_ARC_SDA\0" as *const u8 as *const libc::c_char,
        13 => return b"R_ARC_SECTOFF\0" as *const u8 as *const libc::c_char,
        14 => return b"R_ARC_S21H_PCREL\0" as *const u8 as *const libc::c_char,
        15 => return b"R_ARC_S21W_PCREL\0" as *const u8 as *const libc::c_char,
        16 => return b"R_ARC_S25H_PCREL\0" as *const u8 as *const libc::c_char,
        17 => return b"R_ARC_S25W_PCREL\0" as *const u8 as *const libc::c_char,
        18 => return b"R_ARC_SDA32\0" as *const u8 as *const libc::c_char,
        19 => return b"R_ARC_SDA_LDST\0" as *const u8 as *const libc::c_char,
        20 => return b"R_ARC_SDA_LDST1\0" as *const u8 as *const libc::c_char,
        21 => return b"R_ARC_SDA_LDST2\0" as *const u8 as *const libc::c_char,
        22 => return b"R_ARC_SDA16_LD\0" as *const u8 as *const libc::c_char,
        23 => return b"R_ARC_SDA16_LD1\0" as *const u8 as *const libc::c_char,
        24 => return b"R_ARC_SDA16_LD2\0" as *const u8 as *const libc::c_char,
        25 => return b"R_ARC_S13_PCREL\0" as *const u8 as *const libc::c_char,
        26 => return b"R_ARC_W\0" as *const u8 as *const libc::c_char,
        27 => return b"R_ARC_32_ME\0" as *const u8 as *const libc::c_char,
        105 => return b"R_ARC_32_ME_S\0" as *const u8 as *const libc::c_char,
        28 => return b"R_ARC_N32_ME\0" as *const u8 as *const libc::c_char,
        29 => return b"R_ARC_SECTOFF_ME\0" as *const u8 as *const libc::c_char,
        30 => return b"R_ARC_SDA32_ME\0" as *const u8 as *const libc::c_char,
        31 => return b"R_ARC_W_ME\0" as *const u8 as *const libc::c_char,
        35 => return b"R_AC_SECTOFF_U8\0" as *const u8 as *const libc::c_char,
        36 => return b"R_AC_SECTOFF_U8_1\0" as *const u8 as *const libc::c_char,
        37 => return b"R_AC_SECTOFF_U8_2\0" as *const u8 as *const libc::c_char,
        38 => return b"R_AC_SECTOFF_S9\0" as *const u8 as *const libc::c_char,
        39 => return b"R_AC_SECTOFF_S9_1\0" as *const u8 as *const libc::c_char,
        40 => return b"R_AC_SECTOFF_S9_2\0" as *const u8 as *const libc::c_char,
        41 => return b"R_ARC_SECTOFF_ME_1\0" as *const u8 as *const libc::c_char,
        42 => return b"R_ARC_SECTOFF_ME_2\0" as *const u8 as *const libc::c_char,
        43 => return b"R_ARC_SECTOFF_1\0" as *const u8 as *const libc::c_char,
        44 => return b"R_ARC_SECTOFF_2\0" as *const u8 as *const libc::c_char,
        45 => return b"R_ARC_SDA_12\0" as *const u8 as *const libc::c_char,
        48 => return b"R_ARC_SDA16_ST2\0" as *const u8 as *const libc::c_char,
        49 => return b"R_ARC_32_PCREL\0" as *const u8 as *const libc::c_char,
        50 => return b"R_ARC_PC32\0" as *const u8 as *const libc::c_char,
        59 => return b"R_ARC_GOT32\0" as *const u8 as *const libc::c_char,
        51 => return b"R_ARC_GOTPC32\0" as *const u8 as *const libc::c_char,
        52 => return b"R_ARC_PLT32\0" as *const u8 as *const libc::c_char,
        53 => return b"R_ARC_COPY\0" as *const u8 as *const libc::c_char,
        54 => return b"R_ARC_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        55 => return b"R_ARC_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        56 => return b"R_ARC_RELATIVE\0" as *const u8 as *const libc::c_char,
        57 => return b"R_ARC_GOTOFF\0" as *const u8 as *const libc::c_char,
        58 => return b"R_ARC_GOTPC\0" as *const u8 as *const libc::c_char,
        60 => return b"R_ARC_S21W_PCREL_PLT\0" as *const u8 as *const libc::c_char,
        61 => return b"R_ARC_S25H_PCREL_PLT\0" as *const u8 as *const libc::c_char,
        63 => return b"R_ARC_JLI_SECTOFF\0" as *const u8 as *const libc::c_char,
        66 => return b"R_ARC_TLS_DTPMOD\0" as *const u8 as *const libc::c_char,
        68 => return b"R_ARC_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
        69 => return b"R_ARC_TLS_GD_GOT\0" as *const u8 as *const libc::c_char,
        70 => return b"R_ARC_TLS_GD_LD\0" as *const u8 as *const libc::c_char,
        71 => return b"R_ARC_TLS_GD_CALL\0" as *const u8 as *const libc::c_char,
        72 => return b"R_ARC_TLS_IE_GOT\0" as *const u8 as *const libc::c_char,
        67 => return b"R_ARC_TLS_DTPOFF\0" as *const u8 as *const libc::c_char,
        73 => return b"R_ARC_TLS_DTPOFF_S9\0" as *const u8 as *const libc::c_char,
        74 => return b"R_ARC_TLS_LE_S9\0" as *const u8 as *const libc::c_char,
        75 => return b"R_ARC_TLS_LE_32\0" as *const u8 as *const libc::c_char,
        76 => return b"R_ARC_S25W_PCREL_PLT\0" as *const u8 as *const libc::c_char,
        77 => return b"R_ARC_S21H_PCREL_PLT\0" as *const u8 as *const libc::c_char,
        78 => return b"R_ARC_NPS_CMEM16\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_arm_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_ARM_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_ARM_PC24\0" as *const u8 as *const libc::c_char,
        2 => return b"R_ARM_ABS32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_ARM_REL32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_ARM_LDR_PC_G0\0" as *const u8 as *const libc::c_char,
        5 => return b"R_ARM_ABS16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_ARM_ABS12\0" as *const u8 as *const libc::c_char,
        7 => return b"R_ARM_THM_ABS5\0" as *const u8 as *const libc::c_char,
        8 => return b"R_ARM_ABS8\0" as *const u8 as *const libc::c_char,
        9 => return b"R_ARM_SBREL32\0" as *const u8 as *const libc::c_char,
        10 => return b"R_ARM_THM_CALL\0" as *const u8 as *const libc::c_char,
        11 => return b"R_ARM_THM_PC8\0" as *const u8 as *const libc::c_char,
        12 => return b"R_ARM_BREL_ADJ\0" as *const u8 as *const libc::c_char,
        13 => return b"R_ARM_TLS_DESC\0" as *const u8 as *const libc::c_char,
        14 => return b"R_ARM_THM_SWI8\0" as *const u8 as *const libc::c_char,
        15 => return b"R_ARM_XPC25\0" as *const u8 as *const libc::c_char,
        16 => return b"R_ARM_THM_XPC22\0" as *const u8 as *const libc::c_char,
        17 => return b"R_ARM_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        18 => return b"R_ARM_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
        19 => return b"R_ARM_TLS_TPOFF32\0" as *const u8 as *const libc::c_char,
        20 => return b"R_ARM_COPY\0" as *const u8 as *const libc::c_char,
        21 => return b"R_ARM_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        22 => return b"R_ARM_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        23 => return b"R_ARM_RELATIVE\0" as *const u8 as *const libc::c_char,
        24 => return b"R_ARM_GOTOFF32\0" as *const u8 as *const libc::c_char,
        25 => return b"R_ARM_BASE_PREL\0" as *const u8 as *const libc::c_char,
        26 => return b"R_ARM_GOT_BREL\0" as *const u8 as *const libc::c_char,
        27 => return b"R_ARM_PLT32\0" as *const u8 as *const libc::c_char,
        28 => return b"R_ARM_CALL\0" as *const u8 as *const libc::c_char,
        29 => return b"R_ARM_JUMP24\0" as *const u8 as *const libc::c_char,
        30 => return b"R_ARM_THM_JUMP24\0" as *const u8 as *const libc::c_char,
        31 => return b"R_ARM_BASE_ABS\0" as *const u8 as *const libc::c_char,
        32 => return b"R_ARM_ALU_PCREL7_0\0" as *const u8 as *const libc::c_char,
        33 => return b"R_ARM_ALU_PCREL15_8\0" as *const u8 as *const libc::c_char,
        34 => return b"R_ARM_ALU_PCREL23_15\0" as *const u8 as *const libc::c_char,
        35 => return b"R_ARM_LDR_SBREL_11_0\0" as *const u8 as *const libc::c_char,
        36 => return b"R_ARM_ALU_SBREL_19_12\0" as *const u8 as *const libc::c_char,
        37 => return b"R_ARM_ALU_SBREL_27_20\0" as *const u8 as *const libc::c_char,
        38 => return b"R_ARM_TARGET1\0" as *const u8 as *const libc::c_char,
        39 => return b"R_ARM_SBREL31\0" as *const u8 as *const libc::c_char,
        40 => return b"R_ARM_V4BX\0" as *const u8 as *const libc::c_char,
        41 => return b"R_ARM_TARGET2\0" as *const u8 as *const libc::c_char,
        42 => return b"R_ARM_PREL31\0" as *const u8 as *const libc::c_char,
        43 => return b"R_ARM_MOVW_ABS_NC\0" as *const u8 as *const libc::c_char,
        44 => return b"R_ARM_MOVT_ABS\0" as *const u8 as *const libc::c_char,
        45 => return b"R_ARM_MOVW_PREL_NC\0" as *const u8 as *const libc::c_char,
        46 => return b"R_ARM_MOVT_PREL\0" as *const u8 as *const libc::c_char,
        47 => return b"R_ARM_THM_MOVW_ABS_NC\0" as *const u8 as *const libc::c_char,
        48 => return b"R_ARM_THM_MOVT_ABS\0" as *const u8 as *const libc::c_char,
        49 => return b"R_ARM_THM_MOVW_PREL_NC\0" as *const u8 as *const libc::c_char,
        50 => return b"R_ARM_THM_MOVT_PREL\0" as *const u8 as *const libc::c_char,
        51 => return b"R_ARM_THM_JUMP19\0" as *const u8 as *const libc::c_char,
        52 => return b"R_ARM_THM_JUMP6\0" as *const u8 as *const libc::c_char,
        53 => return b"R_ARM_THM_ALU_PREL_11_0\0" as *const u8 as *const libc::c_char,
        54 => return b"R_ARM_THM_PC12\0" as *const u8 as *const libc::c_char,
        55 => return b"R_ARM_ABS32_NOI\0" as *const u8 as *const libc::c_char,
        56 => return b"R_ARM_REL32_NOI\0" as *const u8 as *const libc::c_char,
        57 => return b"R_ARM_ALU_PC_G0_NC\0" as *const u8 as *const libc::c_char,
        58 => return b"R_ARM_ALU_PC_G0\0" as *const u8 as *const libc::c_char,
        59 => return b"R_ARM_ALU_PC_G1_NC\0" as *const u8 as *const libc::c_char,
        60 => return b"R_ARM_ALU_PC_G1\0" as *const u8 as *const libc::c_char,
        61 => return b"R_ARM_ALU_PC_G2\0" as *const u8 as *const libc::c_char,
        62 => return b"R_ARM_LDR_PC_G1\0" as *const u8 as *const libc::c_char,
        63 => return b"R_ARM_LDR_PC_G2\0" as *const u8 as *const libc::c_char,
        64 => return b"R_ARM_LDRS_PC_G0\0" as *const u8 as *const libc::c_char,
        65 => return b"R_ARM_LDRS_PC_G1\0" as *const u8 as *const libc::c_char,
        66 => return b"R_ARM_LDRS_PC_G2\0" as *const u8 as *const libc::c_char,
        67 => return b"R_ARM_LDC_PC_G0\0" as *const u8 as *const libc::c_char,
        68 => return b"R_ARM_LDC_PC_G1\0" as *const u8 as *const libc::c_char,
        69 => return b"R_ARM_LDC_PC_G2\0" as *const u8 as *const libc::c_char,
        70 => return b"R_ARM_ALU_SB_G0_NC\0" as *const u8 as *const libc::c_char,
        71 => return b"R_ARM_ALU_SB_G0\0" as *const u8 as *const libc::c_char,
        72 => return b"R_ARM_ALU_SB_G1_NC\0" as *const u8 as *const libc::c_char,
        73 => return b"R_ARM_ALU_SB_G1\0" as *const u8 as *const libc::c_char,
        74 => return b"R_ARM_ALU_SB_G2\0" as *const u8 as *const libc::c_char,
        75 => return b"R_ARM_LDR_SB_G0\0" as *const u8 as *const libc::c_char,
        76 => return b"R_ARM_LDR_SB_G1\0" as *const u8 as *const libc::c_char,
        77 => return b"R_ARM_LDR_SB_G2\0" as *const u8 as *const libc::c_char,
        78 => return b"R_ARM_LDRS_SB_G0\0" as *const u8 as *const libc::c_char,
        79 => return b"R_ARM_LDRS_SB_G1\0" as *const u8 as *const libc::c_char,
        80 => return b"R_ARM_LDRS_SB_G2\0" as *const u8 as *const libc::c_char,
        81 => return b"R_ARM_LDC_SB_G0\0" as *const u8 as *const libc::c_char,
        82 => return b"R_ARM_LDC_SB_G1\0" as *const u8 as *const libc::c_char,
        83 => return b"R_ARM_LDC_SB_G2\0" as *const u8 as *const libc::c_char,
        84 => return b"R_ARM_MOVW_BREL_NC\0" as *const u8 as *const libc::c_char,
        85 => return b"R_ARM_MOVT_BREL\0" as *const u8 as *const libc::c_char,
        86 => return b"R_ARM_MOVW_BREL\0" as *const u8 as *const libc::c_char,
        87 => return b"R_ARM_THM_MOVW_BREL_NC\0" as *const u8 as *const libc::c_char,
        88 => return b"R_ARM_THM_MOVT_BREL\0" as *const u8 as *const libc::c_char,
        89 => return b"R_ARM_THM_MOVW_BREL\0" as *const u8 as *const libc::c_char,
        90 => return b"R_ARM_TLS_GOTDESC\0" as *const u8 as *const libc::c_char,
        91 => return b"R_ARM_TLS_CALL\0" as *const u8 as *const libc::c_char,
        92 => return b"R_ARM_TLS_DESCSEQ\0" as *const u8 as *const libc::c_char,
        93 => return b"R_ARM_THM_TLS_CALL\0" as *const u8 as *const libc::c_char,
        94 => return b"R_ARM_PLT32_ABS\0" as *const u8 as *const libc::c_char,
        95 => return b"R_ARM_GOT_ABS\0" as *const u8 as *const libc::c_char,
        96 => return b"R_ARM_GOT_PREL\0" as *const u8 as *const libc::c_char,
        97 => return b"R_ARM_GOT_BREL12\0" as *const u8 as *const libc::c_char,
        98 => return b"R_ARM_GOTOFF12\0" as *const u8 as *const libc::c_char,
        99 => return b"R_ARM_GOTRELAX\0" as *const u8 as *const libc::c_char,
        100 => return b"R_ARM_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        101 => return b"R_ARM_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        102 => return b"R_ARM_THM_JUMP11\0" as *const u8 as *const libc::c_char,
        103 => return b"R_ARM_THM_JUMP8\0" as *const u8 as *const libc::c_char,
        104 => return b"R_ARM_TLS_GD32\0" as *const u8 as *const libc::c_char,
        105 => return b"R_ARM_TLS_LDM32\0" as *const u8 as *const libc::c_char,
        106 => return b"R_ARM_TLS_LDO32\0" as *const u8 as *const libc::c_char,
        107 => return b"R_ARM_TLS_IE32\0" as *const u8 as *const libc::c_char,
        108 => return b"R_ARM_TLS_LE32\0" as *const u8 as *const libc::c_char,
        109 => return b"R_ARM_TLS_LDO12\0" as *const u8 as *const libc::c_char,
        110 => return b"R_ARM_TLS_LE12\0" as *const u8 as *const libc::c_char,
        111 => return b"R_ARM_TLS_IE12GP\0" as *const u8 as *const libc::c_char,
        128 => return b"R_ARM_ME_TOO\0" as *const u8 as *const libc::c_char,
        129 => return b"R_ARM_THM_TLS_DESCSEQ\0" as *const u8 as *const libc::c_char,
        132 => return b"R_ARM_THM_ALU_ABS_G0_NC\0" as *const u8 as *const libc::c_char,
        133 => return b"R_ARM_THM_ALU_ABS_G1_NC\0" as *const u8 as *const libc::c_char,
        134 => return b"R_ARM_THM_ALU_ABS_G2_NC\0" as *const u8 as *const libc::c_char,
        135 => return b"R_ARM_THM_ALU_ABS_G3_NC\0" as *const u8 as *const libc::c_char,
        136 => return b"R_ARM_THM_BF16\0" as *const u8 as *const libc::c_char,
        137 => return b"R_ARM_THM_BF12\0" as *const u8 as *const libc::c_char,
        138 => return b"R_ARM_THM_BF18\0" as *const u8 as *const libc::c_char,
        160 => return b"R_ARM_IRELATIVE\0" as *const u8 as *const libc::c_char,
        161 => return b"R_ARM_GOTFUNCDESC\0" as *const u8 as *const libc::c_char,
        162 => return b"R_ARM_GOTOFFFUNCDESC\0" as *const u8 as *const libc::c_char,
        163 => return b"R_ARM_FUNCDESC\0" as *const u8 as *const libc::c_char,
        164 => return b"R_ARM_FUNCDESC_VALUE\0" as *const u8 as *const libc::c_char,
        165 => return b"R_ARM_TLS_GD32_FDPIC\0" as *const u8 as *const libc::c_char,
        166 => return b"R_ARM_TLS_LDM32_FDPIC\0" as *const u8 as *const libc::c_char,
        167 => return b"R_ARM_TLS_IE32_FDPIC\0" as *const u8 as *const libc::c_char,
        249 => return b"R_ARM_RXPC25\0" as *const u8 as *const libc::c_char,
        250 => return b"R_ARM_RSBREL32\0" as *const u8 as *const libc::c_char,
        251 => return b"R_ARM_THM_RPC22\0" as *const u8 as *const libc::c_char,
        252 => return b"R_ARM_RREL32\0" as *const u8 as *const libc::c_char,
        253 => return b"R_ARM_RABS32\0" as *const u8 as *const libc::c_char,
        254 => return b"R_ARM_RPC24\0" as *const u8 as *const libc::c_char,
        255 => return b"R_ARM_RBASE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_avr_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_AVR_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_AVR_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_AVR_7_PCREL\0" as *const u8 as *const libc::c_char,
        3 => return b"R_AVR_13_PCREL\0" as *const u8 as *const libc::c_char,
        4 => return b"R_AVR_16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_AVR_16_PM\0" as *const u8 as *const libc::c_char,
        6 => return b"R_AVR_LO8_LDI\0" as *const u8 as *const libc::c_char,
        7 => return b"R_AVR_HI8_LDI\0" as *const u8 as *const libc::c_char,
        8 => return b"R_AVR_HH8_LDI\0" as *const u8 as *const libc::c_char,
        9 => return b"R_AVR_LO8_LDI_NEG\0" as *const u8 as *const libc::c_char,
        10 => return b"R_AVR_HI8_LDI_NEG\0" as *const u8 as *const libc::c_char,
        11 => return b"R_AVR_HH8_LDI_NEG\0" as *const u8 as *const libc::c_char,
        12 => return b"R_AVR_LO8_LDI_PM\0" as *const u8 as *const libc::c_char,
        13 => return b"R_AVR_HI8_LDI_PM\0" as *const u8 as *const libc::c_char,
        14 => return b"R_AVR_HH8_LDI_PM\0" as *const u8 as *const libc::c_char,
        15 => return b"R_AVR_LO8_LDI_PM_NEG\0" as *const u8 as *const libc::c_char,
        16 => return b"R_AVR_HI8_LDI_PM_NEG\0" as *const u8 as *const libc::c_char,
        17 => return b"R_AVR_HH8_LDI_PM_NEG\0" as *const u8 as *const libc::c_char,
        18 => return b"R_AVR_CALL\0" as *const u8 as *const libc::c_char,
        19 => return b"R_AVR_LDI\0" as *const u8 as *const libc::c_char,
        20 => return b"R_AVR_6\0" as *const u8 as *const libc::c_char,
        21 => return b"R_AVR_6_ADIW\0" as *const u8 as *const libc::c_char,
        22 => return b"R_AVR_MS8_LDI\0" as *const u8 as *const libc::c_char,
        23 => return b"R_AVR_MS8_LDI_NEG\0" as *const u8 as *const libc::c_char,
        24 => return b"R_AVR_LO8_LDI_GS\0" as *const u8 as *const libc::c_char,
        25 => return b"R_AVR_HI8_LDI_GS\0" as *const u8 as *const libc::c_char,
        26 => return b"R_AVR_8\0" as *const u8 as *const libc::c_char,
        27 => return b"R_AVR_8_LO8\0" as *const u8 as *const libc::c_char,
        28 => return b"R_AVR_8_HI8\0" as *const u8 as *const libc::c_char,
        29 => return b"R_AVR_8_HLO8\0" as *const u8 as *const libc::c_char,
        30 => return b"R_AVR_DIFF8\0" as *const u8 as *const libc::c_char,
        31 => return b"R_AVR_DIFF16\0" as *const u8 as *const libc::c_char,
        32 => return b"R_AVR_DIFF32\0" as *const u8 as *const libc::c_char,
        33 => return b"R_AVR_LDS_STS_16\0" as *const u8 as *const libc::c_char,
        34 => return b"R_AVR_PORT6\0" as *const u8 as *const libc::c_char,
        35 => return b"R_AVR_PORT5\0" as *const u8 as *const libc::c_char,
        36 => return b"R_AVR_32_PCREL\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_bfin_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_BFIN_UNUSED0\0" as *const u8 as *const libc::c_char,
        1 => return b"R_BFIN_PCREL5M2\0" as *const u8 as *const libc::c_char,
        2 => return b"R_BFIN_UNUSED1\0" as *const u8 as *const libc::c_char,
        3 => return b"R_BFIN_PCREL10\0" as *const u8 as *const libc::c_char,
        4 => return b"R_BFIN_PCREL12_JUMP\0" as *const u8 as *const libc::c_char,
        5 => return b"R_BFIN_RIMM16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_BFIN_LUIMM16\0" as *const u8 as *const libc::c_char,
        7 => return b"R_BFIN_HUIMM16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_BFIN_PCREL12_JUMP_S\0" as *const u8 as *const libc::c_char,
        9 => return b"R_BFIN_PCREL24_JUMP_X\0" as *const u8 as *const libc::c_char,
        10 => return b"R_BFIN_PCREL24\0" as *const u8 as *const libc::c_char,
        11 => return b"R_BFIN_UNUSEDB\0" as *const u8 as *const libc::c_char,
        12 => return b"R_BFIN_UNUSEDC\0" as *const u8 as *const libc::c_char,
        13 => return b"R_BFIN_PCREL24_JUMP_L\0" as *const u8 as *const libc::c_char,
        14 => return b"R_BFIN_PCREL24_CALL_X\0" as *const u8 as *const libc::c_char,
        15 => return b"R_BFIN_VAR_EQ_SYMB\0" as *const u8 as *const libc::c_char,
        16 => return b"R_BFIN_BYTE_DATA\0" as *const u8 as *const libc::c_char,
        17 => return b"R_BFIN_BYTE2_DATA\0" as *const u8 as *const libc::c_char,
        18 => return b"R_BFIN_BYTE4_DATA\0" as *const u8 as *const libc::c_char,
        19 => return b"R_BFIN_PCREL11\0" as *const u8 as *const libc::c_char,
        20 => return b"R_BFIN_GOT17M4\0" as *const u8 as *const libc::c_char,
        21 => return b"R_BFIN_GOTHI\0" as *const u8 as *const libc::c_char,
        22 => return b"R_BFIN_GOTLO\0" as *const u8 as *const libc::c_char,
        23 => return b"R_BFIN_FUNCDESC\0" as *const u8 as *const libc::c_char,
        24 => return b"R_BFIN_FUNCDESC_GOT17M4\0" as *const u8 as *const libc::c_char,
        25 => return b"R_BFIN_FUNCDESC_GOTHI\0" as *const u8 as *const libc::c_char,
        26 => return b"R_BFIN_FUNCDESC_GOTLO\0" as *const u8 as *const libc::c_char,
        27 => return b"R_BFIN_FUNCDESC_VALUE\0" as *const u8 as *const libc::c_char,
        28 => return b"R_BFIN_FUNCDESC_GOTOFF17M4\0" as *const u8 as *const libc::c_char,
        29 => return b"R_BFIN_FUNCDESC_GOTOFFHI\0" as *const u8 as *const libc::c_char,
        30 => return b"R_BFIN_FUNCDESC_GOTOFFLO\0" as *const u8 as *const libc::c_char,
        31 => return b"R_BFIN_GOTOFF17M4\0" as *const u8 as *const libc::c_char,
        32 => return b"R_BFIN_GOTOFFHI\0" as *const u8 as *const libc::c_char,
        33 => return b"R_BFIN_GOTOFFLO\0" as *const u8 as *const libc::c_char,
        224 => return b"R_BFIN_PUSH\0" as *const u8 as *const libc::c_char,
        225 => return b"R_BFIN_CONST\0" as *const u8 as *const libc::c_char,
        226 => return b"R_BFIN_ADD\0" as *const u8 as *const libc::c_char,
        227 => return b"R_BFIN_SUB\0" as *const u8 as *const libc::c_char,
        228 => return b"R_BFIN_MULT\0" as *const u8 as *const libc::c_char,
        229 => return b"R_BFIN_DIV\0" as *const u8 as *const libc::c_char,
        230 => return b"R_BFIN_MOD\0" as *const u8 as *const libc::c_char,
        231 => return b"R_BFIN_LSHIFT\0" as *const u8 as *const libc::c_char,
        232 => return b"R_BFIN_RSHIFT\0" as *const u8 as *const libc::c_char,
        233 => return b"R_BFIN_AND\0" as *const u8 as *const libc::c_char,
        234 => return b"R_BFIN_OR\0" as *const u8 as *const libc::c_char,
        235 => return b"R_BFIN_XOR\0" as *const u8 as *const libc::c_char,
        236 => return b"R_BFIN_LAND\0" as *const u8 as *const libc::c_char,
        237 => return b"R_BFIN_LOR\0" as *const u8 as *const libc::c_char,
        238 => return b"R_BFIN_LEN\0" as *const u8 as *const libc::c_char,
        239 => return b"R_BFIN_NEG\0" as *const u8 as *const libc::c_char,
        240 => return b"R_BFIN_COMP\0" as *const u8 as *const libc::c_char,
        241 => return b"R_BFIN_PAGE\0" as *const u8 as *const libc::c_char,
        242 => return b"R_BFIN_HWPAGE\0" as *const u8 as *const libc::c_char,
        243 => return b"R_BFIN_ADDR\0" as *const u8 as *const libc::c_char,
        64 => return b"R_BFIN_PLTPC\0" as *const u8 as *const libc::c_char,
        65 => return b"R_BFIN_GOT\0" as *const u8 as *const libc::c_char,
        66 => return b"R_BFIN_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        67 => return b"R_BFIN_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_cr16_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_CR16_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_CR16_NUM8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_CR16_NUM16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_CR16_NUM32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_CR16_NUM32a\0" as *const u8 as *const libc::c_char,
        5 => return b"R_CR16_REGREL4\0" as *const u8 as *const libc::c_char,
        6 => return b"R_CR16_REGREL4a\0" as *const u8 as *const libc::c_char,
        7 => return b"R_CR16_REGREL14\0" as *const u8 as *const libc::c_char,
        8 => return b"R_CR16_REGREL14a\0" as *const u8 as *const libc::c_char,
        9 => return b"R_CR16_REGREL16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_CR16_REGREL20\0" as *const u8 as *const libc::c_char,
        11 => return b"R_CR16_REGREL20a\0" as *const u8 as *const libc::c_char,
        12 => return b"R_CR16_ABS20\0" as *const u8 as *const libc::c_char,
        13 => return b"R_CR16_ABS24\0" as *const u8 as *const libc::c_char,
        14 => return b"R_CR16_IMM4\0" as *const u8 as *const libc::c_char,
        15 => return b"R_CR16_IMM8\0" as *const u8 as *const libc::c_char,
        16 => return b"R_CR16_IMM16\0" as *const u8 as *const libc::c_char,
        17 => return b"R_CR16_IMM20\0" as *const u8 as *const libc::c_char,
        18 => return b"R_CR16_IMM24\0" as *const u8 as *const libc::c_char,
        19 => return b"R_CR16_IMM32\0" as *const u8 as *const libc::c_char,
        20 => return b"R_CR16_IMM32a\0" as *const u8 as *const libc::c_char,
        21 => return b"R_CR16_DISP4\0" as *const u8 as *const libc::c_char,
        22 => return b"R_CR16_DISP8\0" as *const u8 as *const libc::c_char,
        23 => return b"R_CR16_DISP16\0" as *const u8 as *const libc::c_char,
        24 => return b"R_CR16_DISP24\0" as *const u8 as *const libc::c_char,
        25 => return b"R_CR16_DISP24a\0" as *const u8 as *const libc::c_char,
        26 => return b"R_CR16_SWITCH8\0" as *const u8 as *const libc::c_char,
        27 => return b"R_CR16_SWITCH16\0" as *const u8 as *const libc::c_char,
        28 => return b"R_CR16_SWITCH32\0" as *const u8 as *const libc::c_char,
        29 => return b"R_CR16_GOT_REGREL20\0" as *const u8 as *const libc::c_char,
        30 => return b"R_CR16_GOTC_REGREL20\0" as *const u8 as *const libc::c_char,
        31 => return b"R_CR16_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_cris_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_CRIS_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_CRIS_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_CRIS_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_CRIS_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_CRIS_8_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_CRIS_16_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_CRIS_32_PCREL\0" as *const u8 as *const libc::c_char,
        7 => return b"R_CRIS_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        8 => return b"R_CRIS_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        9 => return b"R_CRIS_COPY\0" as *const u8 as *const libc::c_char,
        10 => return b"R_CRIS_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        11 => return b"R_CRIS_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_CRIS_RELATIVE\0" as *const u8 as *const libc::c_char,
        13 => return b"R_CRIS_16_GOT\0" as *const u8 as *const libc::c_char,
        14 => return b"R_CRIS_32_GOT\0" as *const u8 as *const libc::c_char,
        15 => return b"R_CRIS_16_GOTPLT\0" as *const u8 as *const libc::c_char,
        16 => return b"R_CRIS_32_GOTPLT\0" as *const u8 as *const libc::c_char,
        17 => return b"R_CRIS_32_GOTREL\0" as *const u8 as *const libc::c_char,
        18 => return b"R_CRIS_32_PLT_GOTREL\0" as *const u8 as *const libc::c_char,
        19 => return b"R_CRIS_32_PLT_PCREL\0" as *const u8 as *const libc::c_char,
        20 => return b"R_CRIS_32_GOT_GD\0" as *const u8 as *const libc::c_char,
        21 => return b"R_CRIS_16_GOT_GD\0" as *const u8 as *const libc::c_char,
        22 => return b"R_CRIS_32_GD\0" as *const u8 as *const libc::c_char,
        23 => return b"R_CRIS_DTP\0" as *const u8 as *const libc::c_char,
        24 => return b"R_CRIS_32_DTPREL\0" as *const u8 as *const libc::c_char,
        25 => return b"R_CRIS_16_DTPREL\0" as *const u8 as *const libc::c_char,
        26 => return b"R_CRIS_32_GOT_TPREL\0" as *const u8 as *const libc::c_char,
        27 => return b"R_CRIS_16_GOT_TPREL\0" as *const u8 as *const libc::c_char,
        28 => return b"R_CRIS_32_TPREL\0" as *const u8 as *const libc::c_char,
        29 => return b"R_CRIS_16_TPREL\0" as *const u8 as *const libc::c_char,
        30 => return b"R_CRIS_DTPMOD\0" as *const u8 as *const libc::c_char,
        31 => return b"R_CRIS_32_IE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_crx_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_CRX_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_CRX_REL4\0" as *const u8 as *const libc::c_char,
        2 => return b"R_CRX_REL8\0" as *const u8 as *const libc::c_char,
        3 => return b"R_CRX_REL8_CMP\0" as *const u8 as *const libc::c_char,
        4 => return b"R_CRX_REL16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_CRX_REL24\0" as *const u8 as *const libc::c_char,
        6 => return b"R_CRX_REL32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_CRX_REGREL12\0" as *const u8 as *const libc::c_char,
        8 => return b"R_CRX_REGREL22\0" as *const u8 as *const libc::c_char,
        9 => return b"R_CRX_REGREL28\0" as *const u8 as *const libc::c_char,
        10 => return b"R_CRX_REGREL32\0" as *const u8 as *const libc::c_char,
        11 => return b"R_CRX_ABS16\0" as *const u8 as *const libc::c_char,
        12 => return b"R_CRX_ABS32\0" as *const u8 as *const libc::c_char,
        13 => return b"R_CRX_NUM8\0" as *const u8 as *const libc::c_char,
        14 => return b"R_CRX_NUM16\0" as *const u8 as *const libc::c_char,
        15 => return b"R_CRX_NUM32\0" as *const u8 as *const libc::c_char,
        16 => return b"R_CRX_IMM16\0" as *const u8 as *const libc::c_char,
        17 => return b"R_CRX_IMM32\0" as *const u8 as *const libc::c_char,
        18 => return b"R_CRX_SWITCH8\0" as *const u8 as *const libc::c_char,
        19 => return b"R_CRX_SWITCH16\0" as *const u8 as *const libc::c_char,
        20 => return b"R_CRX_SWITCH32\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_csky_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_CKCORE_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_CKCORE_ADDR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_CKCORE_PCREL_IMM8BY4\0" as *const u8 as *const libc::c_char,
        3 => return b"R_CKCORE_PCREL_IMM11BY2\0" as *const u8 as *const libc::c_char,
        4 => return b"R_CKCORE_PCREL_IMM4BY2\0" as *const u8 as *const libc::c_char,
        5 => return b"R_CKCORE_PCREL32\0" as *const u8 as *const libc::c_char,
        6 => return b"R_CKCORE_PCREL_JSR_IMM11BY2\0" as *const u8 as *const libc::c_char,
        7 => return b"R_CKCORE_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        8 => return b"R_CKCORE_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        9 => return b"R_CKCORE_RELATIVE\0" as *const u8 as *const libc::c_char,
        10 => return b"R_CKCORE_COPY\0" as *const u8 as *const libc::c_char,
        11 => return b"R_CKCORE_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_CKCORE_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        13 => return b"R_CKCORE_GOTOFF\0" as *const u8 as *const libc::c_char,
        14 => return b"R_CKCORE_GOTPC\0" as *const u8 as *const libc::c_char,
        15 => return b"R_CKCORE_GOT32\0" as *const u8 as *const libc::c_char,
        16 => return b"R_CKCORE_PLT32\0" as *const u8 as *const libc::c_char,
        17 => return b"R_CKCORE_ADDRGOT\0" as *const u8 as *const libc::c_char,
        18 => return b"R_CKCORE_ADDRPLT\0" as *const u8 as *const libc::c_char,
        19 => return b"R_CKCORE_PCREL_IMM26BY2\0" as *const u8 as *const libc::c_char,
        20 => return b"R_CKCORE_PCREL_IMM16BY2\0" as *const u8 as *const libc::c_char,
        21 => return b"R_CKCORE_PCREL_IMM16BY4\0" as *const u8 as *const libc::c_char,
        22 => return b"R_CKCORE_PCREL_IMM10BY2\0" as *const u8 as *const libc::c_char,
        23 => return b"R_CKCORE_PCREL_IMM10BY4\0" as *const u8 as *const libc::c_char,
        24 => return b"R_CKCORE_ADDR_HI16\0" as *const u8 as *const libc::c_char,
        25 => return b"R_CKCORE_ADDR_LO16\0" as *const u8 as *const libc::c_char,
        26 => return b"R_CKCORE_GOTPC_HI16\0" as *const u8 as *const libc::c_char,
        27 => return b"R_CKCORE_GOTPC_LO16\0" as *const u8 as *const libc::c_char,
        28 => return b"R_CKCORE_GOTOFF_HI16\0" as *const u8 as *const libc::c_char,
        29 => return b"R_CKCORE_GOTOFF_LO16\0" as *const u8 as *const libc::c_char,
        30 => return b"R_CKCORE_GOT12\0" as *const u8 as *const libc::c_char,
        31 => return b"R_CKCORE_GOT_HI16\0" as *const u8 as *const libc::c_char,
        32 => return b"R_CKCORE_GOT_LO16\0" as *const u8 as *const libc::c_char,
        33 => return b"R_CKCORE_PLT12\0" as *const u8 as *const libc::c_char,
        34 => return b"R_CKCORE_PLT_HI16\0" as *const u8 as *const libc::c_char,
        35 => return b"R_CKCORE_PLT_LO16\0" as *const u8 as *const libc::c_char,
        36 => return b"R_CKCORE_ADDRGOT_HI16\0" as *const u8 as *const libc::c_char,
        37 => return b"R_CKCORE_ADDRGOT_LO16\0" as *const u8 as *const libc::c_char,
        38 => return b"R_CKCORE_ADDRPLT_HI16\0" as *const u8 as *const libc::c_char,
        39 => return b"R_CKCORE_ADDRPLT_LO16\0" as *const u8 as *const libc::c_char,
        40 => return b"R_CKCORE_PCREL_JSR_IMM26BY2\0" as *const u8 as *const libc::c_char,
        41 => return b"R_CKCORE_TOFFSET_LO16\0" as *const u8 as *const libc::c_char,
        42 => return b"R_CKCORE_DOFFSET_LO16\0" as *const u8 as *const libc::c_char,
        43 => return b"R_CKCORE_PCREL_IMM18BY2\0" as *const u8 as *const libc::c_char,
        44 => return b"R_CKCORE_DOFFSET_IMM18\0" as *const u8 as *const libc::c_char,
        45 => return b"R_CKCORE_DOFFSET_IMM18BY2\0" as *const u8 as *const libc::c_char,
        46 => return b"R_CKCORE_DOFFSET_IMM18BY4\0" as *const u8 as *const libc::c_char,
        47 => return b"R_CKCORE_GOTOFF_IMM18\0" as *const u8 as *const libc::c_char,
        48 => return b"R_CKCORE_GOT_IMM18BY4\0" as *const u8 as *const libc::c_char,
        49 => return b"R_CKCORE_PLT_IMM18BY4\0" as *const u8 as *const libc::c_char,
        50 => return b"R_CKCORE_PCREL_IMM7BY4\0" as *const u8 as *const libc::c_char,
        51 => return b"R_CKCORE_TLS_LE32\0" as *const u8 as *const libc::c_char,
        52 => return b"R_CKCORE_TLS_IE32\0" as *const u8 as *const libc::c_char,
        53 => return b"R_CKCORE_TLS_GD32\0" as *const u8 as *const libc::c_char,
        54 => return b"R_CKCORE_TLS_LDM32\0" as *const u8 as *const libc::c_char,
        55 => return b"R_CKCORE_TLS_LDO32\0" as *const u8 as *const libc::c_char,
        56 => return b"R_CKCORE_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        57 => return b"R_CKCORE_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
        58 => return b"R_CKCORE_TLS_TPOFF32\0" as *const u8 as *const libc::c_char,
        59 => return b"R_CKCORE_PCREL_FLRW_IMM8BY4\0" as *const u8 as *const libc::c_char,
        60 => return b"R_CKCORE_NOJSRI\0" as *const u8 as *const libc::c_char,
        61 => return b"R_CKCORE_CALLGRAPH\0" as *const u8 as *const libc::c_char,
        62 => return b"R_CKCORE_IRELATIVE\0" as *const u8 as *const libc::c_char,
        63 => {
            return b"R_CKCORE_PCREL_BLOOP_IMM4BY4\0" as *const u8 as *const libc::c_char;
        }
        64 => {
            return b"R_CKCORE_PCREL_BLOOP_IMM12BY4\0" as *const u8 as *const libc::c_char;
        }
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_d10v_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_D10V_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_D10V_10_PCREL_R\0" as *const u8 as *const libc::c_char,
        2 => return b"R_D10V_10_PCREL_L\0" as *const u8 as *const libc::c_char,
        3 => return b"R_D10V_16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_D10V_18\0" as *const u8 as *const libc::c_char,
        5 => return b"R_D10V_18_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_D10V_32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_D10V_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        8 => return b"R_D10V_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_d30v_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_D30V_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_D30V_6\0" as *const u8 as *const libc::c_char,
        2 => return b"R_D30V_9_PCREL\0" as *const u8 as *const libc::c_char,
        3 => return b"R_D30V_9_PCREL_R\0" as *const u8 as *const libc::c_char,
        4 => return b"R_D30V_15\0" as *const u8 as *const libc::c_char,
        5 => return b"R_D30V_15_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_D30V_15_PCREL_R\0" as *const u8 as *const libc::c_char,
        7 => return b"R_D30V_21\0" as *const u8 as *const libc::c_char,
        8 => return b"R_D30V_21_PCREL\0" as *const u8 as *const libc::c_char,
        9 => return b"R_D30V_21_PCREL_R\0" as *const u8 as *const libc::c_char,
        10 => return b"R_D30V_32\0" as *const u8 as *const libc::c_char,
        11 => return b"R_D30V_32_PCREL\0" as *const u8 as *const libc::c_char,
        12 => return b"R_D30V_32_NORMAL\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_dlx_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_DLX_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_DLX_RELOC_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_DLX_RELOC_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_DLX_RELOC_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_DLX_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        5 => return b"R_DLX_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        6 => return b"R_DLX_RELOC_16_HI\0" as *const u8 as *const libc::c_char,
        7 => return b"R_DLX_RELOC_16_LO\0" as *const u8 as *const libc::c_char,
        8 => return b"R_DLX_RELOC_16_PCREL\0" as *const u8 as *const libc::c_char,
        9 => return b"R_DLX_RELOC_26_PCREL\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_bpf_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_BPF_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_BPF_INSN_64\0" as *const u8 as *const libc::c_char,
        2 => return b"R_BPF_INSN_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_BPF_INSN_16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_BPF_INSN_DISP16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_BPF_DATA_8_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_BPF_DATA_16_PCREL\0" as *const u8 as *const libc::c_char,
        7 => return b"R_BPF_DATA_32_PCREL\0" as *const u8 as *const libc::c_char,
        8 => return b"R_BPF_DATA_8\0" as *const u8 as *const libc::c_char,
        9 => return b"R_BPF_DATA_16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_BPF_INSN_DISP32\0" as *const u8 as *const libc::c_char,
        11 => return b"R_BPF_DATA_32\0" as *const u8 as *const libc::c_char,
        12 => return b"R_BPF_DATA_64\0" as *const u8 as *const libc::c_char,
        13 => return b"R_BPF_DATA_64_PCREL\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_epiphany_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_EPIPHANY_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_EPIPHANY_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_EPIPHANY_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_EPIPHANY_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_EPIPHANY_8_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_EPIPHANY_16_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_EPIPHANY_32_PCREL\0" as *const u8 as *const libc::c_char,
        7 => return b"R_EPIPHANY_SIMM8\0" as *const u8 as *const libc::c_char,
        8 => return b"R_EPIPHANY_SIMM24\0" as *const u8 as *const libc::c_char,
        9 => return b"R_EPIPHANY_HIGH\0" as *const u8 as *const libc::c_char,
        10 => return b"R_EPIPHANY_LOW\0" as *const u8 as *const libc::c_char,
        11 => return b"R_EPIPHANY_SIMM11\0" as *const u8 as *const libc::c_char,
        12 => return b"R_EPIPHANY_IMM11\0" as *const u8 as *const libc::c_char,
        13 => return b"R_EPIPHANY_IMM8\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_fr30_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_FR30_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_FR30_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_FR30_20\0" as *const u8 as *const libc::c_char,
        3 => return b"R_FR30_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_FR30_48\0" as *const u8 as *const libc::c_char,
        5 => return b"R_FR30_6_IN_4\0" as *const u8 as *const libc::c_char,
        6 => return b"R_FR30_8_IN_8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_FR30_9_IN_8\0" as *const u8 as *const libc::c_char,
        8 => return b"R_FR30_10_IN_8\0" as *const u8 as *const libc::c_char,
        9 => return b"R_FR30_9_PCREL\0" as *const u8 as *const libc::c_char,
        10 => return b"R_FR30_12_PCREL\0" as *const u8 as *const libc::c_char,
        11 => return b"R_FR30_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_FR30_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_frv_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_FRV_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_FRV_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_FRV_LABEL16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_FRV_LABEL24\0" as *const u8 as *const libc::c_char,
        4 => return b"R_FRV_LO16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_FRV_HI16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_FRV_GPREL12\0" as *const u8 as *const libc::c_char,
        7 => return b"R_FRV_GPRELU12\0" as *const u8 as *const libc::c_char,
        8 => return b"R_FRV_GPREL32\0" as *const u8 as *const libc::c_char,
        9 => return b"R_FRV_GPRELHI\0" as *const u8 as *const libc::c_char,
        10 => return b"R_FRV_GPRELLO\0" as *const u8 as *const libc::c_char,
        11 => return b"R_FRV_GOT12\0" as *const u8 as *const libc::c_char,
        12 => return b"R_FRV_GOTHI\0" as *const u8 as *const libc::c_char,
        13 => return b"R_FRV_GOTLO\0" as *const u8 as *const libc::c_char,
        14 => return b"R_FRV_FUNCDESC\0" as *const u8 as *const libc::c_char,
        15 => return b"R_FRV_FUNCDESC_GOT12\0" as *const u8 as *const libc::c_char,
        16 => return b"R_FRV_FUNCDESC_GOTHI\0" as *const u8 as *const libc::c_char,
        17 => return b"R_FRV_FUNCDESC_GOTLO\0" as *const u8 as *const libc::c_char,
        18 => return b"R_FRV_FUNCDESC_VALUE\0" as *const u8 as *const libc::c_char,
        19 => return b"R_FRV_FUNCDESC_GOTOFF12\0" as *const u8 as *const libc::c_char,
        20 => return b"R_FRV_FUNCDESC_GOTOFFHI\0" as *const u8 as *const libc::c_char,
        21 => return b"R_FRV_FUNCDESC_GOTOFFLO\0" as *const u8 as *const libc::c_char,
        22 => return b"R_FRV_GOTOFF12\0" as *const u8 as *const libc::c_char,
        23 => return b"R_FRV_GOTOFFHI\0" as *const u8 as *const libc::c_char,
        24 => return b"R_FRV_GOTOFFLO\0" as *const u8 as *const libc::c_char,
        25 => return b"R_FRV_GETTLSOFF\0" as *const u8 as *const libc::c_char,
        26 => return b"R_FRV_TLSDESC_VALUE\0" as *const u8 as *const libc::c_char,
        27 => return b"R_FRV_GOTTLSDESC12\0" as *const u8 as *const libc::c_char,
        28 => return b"R_FRV_GOTTLSDESCHI\0" as *const u8 as *const libc::c_char,
        29 => return b"R_FRV_GOTTLSDESCLO\0" as *const u8 as *const libc::c_char,
        30 => return b"R_FRV_TLSMOFF12\0" as *const u8 as *const libc::c_char,
        31 => return b"R_FRV_TLSMOFFHI\0" as *const u8 as *const libc::c_char,
        32 => return b"R_FRV_TLSMOFFLO\0" as *const u8 as *const libc::c_char,
        33 => return b"R_FRV_GOTTLSOFF12\0" as *const u8 as *const libc::c_char,
        34 => return b"R_FRV_GOTTLSOFFHI\0" as *const u8 as *const libc::c_char,
        35 => return b"R_FRV_GOTTLSOFFLO\0" as *const u8 as *const libc::c_char,
        36 => return b"R_FRV_TLSOFF\0" as *const u8 as *const libc::c_char,
        37 => return b"R_FRV_TLSDESC_RELAX\0" as *const u8 as *const libc::c_char,
        38 => return b"R_FRV_GETTLSOFF_RELAX\0" as *const u8 as *const libc::c_char,
        39 => return b"R_FRV_TLSOFF_RELAX\0" as *const u8 as *const libc::c_char,
        40 => return b"R_FRV_TLSMOFF\0" as *const u8 as *const libc::c_char,
        200 => return b"R_FRV_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        201 => return b"R_FRV_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_ft32_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_FT32_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_FT32_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_FT32_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_FT32_8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_FT32_10\0" as *const u8 as *const libc::c_char,
        5 => return b"R_FT32_20\0" as *const u8 as *const libc::c_char,
        6 => return b"R_FT32_17\0" as *const u8 as *const libc::c_char,
        7 => return b"R_FT32_18\0" as *const u8 as *const libc::c_char,
        8 => return b"R_FT32_RELAX\0" as *const u8 as *const libc::c_char,
        9 => return b"R_FT32_SC0\0" as *const u8 as *const libc::c_char,
        10 => return b"R_FT32_SC1\0" as *const u8 as *const libc::c_char,
        11 => return b"R_FT32_15\0" as *const u8 as *const libc::c_char,
        12 => return b"R_FT32_DIFF32\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_hppa_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_PARISC_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_PARISC_DIR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_PARISC_DIR21L\0" as *const u8 as *const libc::c_char,
        3 => return b"R_PARISC_DIR17R\0" as *const u8 as *const libc::c_char,
        4 => return b"R_PARISC_DIR17F\0" as *const u8 as *const libc::c_char,
        6 => return b"R_PARISC_DIR14R\0" as *const u8 as *const libc::c_char,
        7 => return b"R_PARISC_DIR14F\0" as *const u8 as *const libc::c_char,
        8 => return b"R_PARISC_PCREL12F\0" as *const u8 as *const libc::c_char,
        9 => return b"R_PARISC_PCREL32\0" as *const u8 as *const libc::c_char,
        10 => return b"R_PARISC_PCREL21L\0" as *const u8 as *const libc::c_char,
        11 => return b"R_PARISC_PCREL17R\0" as *const u8 as *const libc::c_char,
        12 => return b"R_PARISC_PCREL17F\0" as *const u8 as *const libc::c_char,
        13 => return b"R_PARISC_PCREL17C\0" as *const u8 as *const libc::c_char,
        14 => return b"R_PARISC_PCREL14R\0" as *const u8 as *const libc::c_char,
        15 => return b"R_PARISC_PCREL14F\0" as *const u8 as *const libc::c_char,
        18 => return b"R_PARISC_DPREL21L\0" as *const u8 as *const libc::c_char,
        19 => return b"R_PARISC_DPREL14WR\0" as *const u8 as *const libc::c_char,
        20 => return b"R_PARISC_DPREL14DR\0" as *const u8 as *const libc::c_char,
        22 => return b"R_PARISC_DPREL14R\0" as *const u8 as *const libc::c_char,
        23 => return b"R_PARISC_DPREL14F\0" as *const u8 as *const libc::c_char,
        26 => return b"R_PARISC_DLTREL21L\0" as *const u8 as *const libc::c_char,
        30 => return b"R_PARISC_DLTREL14R\0" as *const u8 as *const libc::c_char,
        31 => return b"R_PARISC_DLTREL14F\0" as *const u8 as *const libc::c_char,
        34 => return b"R_PARISC_DLTIND21L\0" as *const u8 as *const libc::c_char,
        38 => return b"R_PARISC_DLTIND14R\0" as *const u8 as *const libc::c_char,
        39 => return b"R_PARISC_DLTIND14F\0" as *const u8 as *const libc::c_char,
        40 => return b"R_PARISC_SETBASE\0" as *const u8 as *const libc::c_char,
        41 => return b"R_PARISC_SECREL32\0" as *const u8 as *const libc::c_char,
        42 => return b"R_PARISC_BASEREL21L\0" as *const u8 as *const libc::c_char,
        43 => return b"R_PARISC_BASEREL17R\0" as *const u8 as *const libc::c_char,
        44 => return b"R_PARISC_BASEREL17F\0" as *const u8 as *const libc::c_char,
        46 => return b"R_PARISC_BASEREL14R\0" as *const u8 as *const libc::c_char,
        47 => return b"R_PARISC_BASEREL14F\0" as *const u8 as *const libc::c_char,
        48 => return b"R_PARISC_SEGBASE\0" as *const u8 as *const libc::c_char,
        49 => return b"R_PARISC_SEGREL32\0" as *const u8 as *const libc::c_char,
        50 => return b"R_PARISC_PLTOFF21L\0" as *const u8 as *const libc::c_char,
        54 => return b"R_PARISC_PLTOFF14R\0" as *const u8 as *const libc::c_char,
        55 => return b"R_PARISC_PLTOFF14F\0" as *const u8 as *const libc::c_char,
        57 => return b"R_PARISC_LTOFF_FPTR32\0" as *const u8 as *const libc::c_char,
        58 => return b"R_PARISC_LTOFF_FPTR21L\0" as *const u8 as *const libc::c_char,
        62 => return b"R_PARISC_LTOFF_FPTR14R\0" as *const u8 as *const libc::c_char,
        64 => return b"R_PARISC_FPTR64\0" as *const u8 as *const libc::c_char,
        65 => return b"R_PARISC_PLABEL32\0" as *const u8 as *const libc::c_char,
        66 => return b"R_PARISC_PLABEL21L\0" as *const u8 as *const libc::c_char,
        70 => return b"R_PARISC_PLABEL14R\0" as *const u8 as *const libc::c_char,
        72 => return b"R_PARISC_PCREL64\0" as *const u8 as *const libc::c_char,
        73 => return b"R_PARISC_PCREL22C\0" as *const u8 as *const libc::c_char,
        74 => return b"R_PARISC_PCREL22F\0" as *const u8 as *const libc::c_char,
        75 => return b"R_PARISC_PCREL14WR\0" as *const u8 as *const libc::c_char,
        76 => return b"R_PARISC_PCREL14DR\0" as *const u8 as *const libc::c_char,
        77 => return b"R_PARISC_PCREL16F\0" as *const u8 as *const libc::c_char,
        78 => return b"R_PARISC_PCREL16WF\0" as *const u8 as *const libc::c_char,
        79 => return b"R_PARISC_PCREL16DF\0" as *const u8 as *const libc::c_char,
        80 => return b"R_PARISC_DIR64\0" as *const u8 as *const libc::c_char,
        83 => return b"R_PARISC_DIR14WR\0" as *const u8 as *const libc::c_char,
        84 => return b"R_PARISC_DIR14DR\0" as *const u8 as *const libc::c_char,
        85 => return b"R_PARISC_DIR16F\0" as *const u8 as *const libc::c_char,
        86 => return b"R_PARISC_DIR16WF\0" as *const u8 as *const libc::c_char,
        87 => return b"R_PARISC_DIR16DF\0" as *const u8 as *const libc::c_char,
        88 => return b"R_PARISC_GPREL64\0" as *const u8 as *const libc::c_char,
        91 => return b"R_PARISC_DLTREL14WR\0" as *const u8 as *const libc::c_char,
        92 => return b"R_PARISC_DLTREL14DR\0" as *const u8 as *const libc::c_char,
        93 => return b"R_PARISC_GPREL16F\0" as *const u8 as *const libc::c_char,
        94 => return b"R_PARISC_GPREL16WF\0" as *const u8 as *const libc::c_char,
        95 => return b"R_PARISC_GPREL16DF\0" as *const u8 as *const libc::c_char,
        96 => return b"R_PARISC_LTOFF64\0" as *const u8 as *const libc::c_char,
        99 => return b"R_PARISC_DLTIND14WR\0" as *const u8 as *const libc::c_char,
        100 => return b"R_PARISC_DLTIND14DR\0" as *const u8 as *const libc::c_char,
        101 => return b"R_PARISC_LTOFF16F\0" as *const u8 as *const libc::c_char,
        102 => return b"R_PARISC_LTOFF16WF\0" as *const u8 as *const libc::c_char,
        103 => return b"R_PARISC_LTOFF16DF\0" as *const u8 as *const libc::c_char,
        104 => return b"R_PARISC_SECREL64\0" as *const u8 as *const libc::c_char,
        107 => return b"R_PARISC_BASEREL14WR\0" as *const u8 as *const libc::c_char,
        108 => return b"R_PARISC_BASEREL14DR\0" as *const u8 as *const libc::c_char,
        112 => return b"R_PARISC_SEGREL64\0" as *const u8 as *const libc::c_char,
        115 => return b"R_PARISC_PLTOFF14WR\0" as *const u8 as *const libc::c_char,
        116 => return b"R_PARISC_PLTOFF14DR\0" as *const u8 as *const libc::c_char,
        117 => return b"R_PARISC_PLTOFF16F\0" as *const u8 as *const libc::c_char,
        118 => return b"R_PARISC_PLTOFF16WF\0" as *const u8 as *const libc::c_char,
        119 => return b"R_PARISC_PLTOFF16DF\0" as *const u8 as *const libc::c_char,
        120 => return b"R_PARISC_LTOFF_FPTR64\0" as *const u8 as *const libc::c_char,
        123 => return b"R_PARISC_LTOFF_FPTR14WR\0" as *const u8 as *const libc::c_char,
        124 => return b"R_PARISC_LTOFF_FPTR14DR\0" as *const u8 as *const libc::c_char,
        125 => return b"R_PARISC_LTOFF_FPTR16F\0" as *const u8 as *const libc::c_char,
        126 => return b"R_PARISC_LTOFF_FPTR16WF\0" as *const u8 as *const libc::c_char,
        127 => return b"R_PARISC_LTOFF_FPTR16DF\0" as *const u8 as *const libc::c_char,
        128 => return b"R_PARISC_COPY\0" as *const u8 as *const libc::c_char,
        129 => return b"R_PARISC_IPLT\0" as *const u8 as *const libc::c_char,
        130 => return b"R_PARISC_EPLT\0" as *const u8 as *const libc::c_char,
        153 => return b"R_PARISC_TPREL32\0" as *const u8 as *const libc::c_char,
        154 => return b"R_PARISC_TPREL21L\0" as *const u8 as *const libc::c_char,
        158 => return b"R_PARISC_TPREL14R\0" as *const u8 as *const libc::c_char,
        162 => return b"R_PARISC_LTOFF_TP21L\0" as *const u8 as *const libc::c_char,
        166 => return b"R_PARISC_LTOFF_TP14R\0" as *const u8 as *const libc::c_char,
        167 => return b"R_PARISC_LTOFF_TP14F\0" as *const u8 as *const libc::c_char,
        216 => return b"R_PARISC_TPREL64\0" as *const u8 as *const libc::c_char,
        219 => return b"R_PARISC_TPREL14WR\0" as *const u8 as *const libc::c_char,
        220 => return b"R_PARISC_TPREL14DR\0" as *const u8 as *const libc::c_char,
        221 => return b"R_PARISC_TPREL16F\0" as *const u8 as *const libc::c_char,
        222 => return b"R_PARISC_TPREL16WF\0" as *const u8 as *const libc::c_char,
        223 => return b"R_PARISC_TPREL16DF\0" as *const u8 as *const libc::c_char,
        224 => return b"R_PARISC_LTOFF_TP64\0" as *const u8 as *const libc::c_char,
        227 => return b"R_PARISC_LTOFF_TP14WR\0" as *const u8 as *const libc::c_char,
        228 => return b"R_PARISC_LTOFF_TP14DR\0" as *const u8 as *const libc::c_char,
        229 => return b"R_PARISC_LTOFF_TP16F\0" as *const u8 as *const libc::c_char,
        230 => return b"R_PARISC_LTOFF_TP16WF\0" as *const u8 as *const libc::c_char,
        231 => return b"R_PARISC_LTOFF_TP16DF\0" as *const u8 as *const libc::c_char,
        232 => return b"R_PARISC_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        233 => return b"R_PARISC_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        234 => return b"R_PARISC_TLS_GD21L\0" as *const u8 as *const libc::c_char,
        235 => return b"R_PARISC_TLS_GD14R\0" as *const u8 as *const libc::c_char,
        236 => return b"R_PARISC_TLS_GDCALL\0" as *const u8 as *const libc::c_char,
        237 => return b"R_PARISC_TLS_LDM21L\0" as *const u8 as *const libc::c_char,
        238 => return b"R_PARISC_TLS_LDM14R\0" as *const u8 as *const libc::c_char,
        239 => return b"R_PARISC_TLS_LDMCALL\0" as *const u8 as *const libc::c_char,
        240 => return b"R_PARISC_TLS_LDO21L\0" as *const u8 as *const libc::c_char,
        241 => return b"R_PARISC_TLS_LDO14R\0" as *const u8 as *const libc::c_char,
        242 => return b"R_PARISC_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        243 => return b"R_PARISC_TLS_DTPMOD64\0" as *const u8 as *const libc::c_char,
        244 => return b"R_PARISC_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
        245 => return b"R_PARISC_TLS_DTPOFF64\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_i386_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_386_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_386_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_386_PC32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_386_GOT32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_386_PLT32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_386_COPY\0" as *const u8 as *const libc::c_char,
        6 => return b"R_386_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        7 => return b"R_386_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        8 => return b"R_386_RELATIVE\0" as *const u8 as *const libc::c_char,
        9 => return b"R_386_GOTOFF\0" as *const u8 as *const libc::c_char,
        10 => return b"R_386_GOTPC\0" as *const u8 as *const libc::c_char,
        11 => return b"R_386_32PLT\0" as *const u8 as *const libc::c_char,
        14 => return b"R_386_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
        15 => return b"R_386_TLS_IE\0" as *const u8 as *const libc::c_char,
        16 => return b"R_386_TLS_GOTIE\0" as *const u8 as *const libc::c_char,
        17 => return b"R_386_TLS_LE\0" as *const u8 as *const libc::c_char,
        18 => return b"R_386_TLS_GD\0" as *const u8 as *const libc::c_char,
        19 => return b"R_386_TLS_LDM\0" as *const u8 as *const libc::c_char,
        20 => return b"R_386_16\0" as *const u8 as *const libc::c_char,
        21 => return b"R_386_PC16\0" as *const u8 as *const libc::c_char,
        22 => return b"R_386_8\0" as *const u8 as *const libc::c_char,
        23 => return b"R_386_PC8\0" as *const u8 as *const libc::c_char,
        24 => return b"R_386_TLS_GD_32\0" as *const u8 as *const libc::c_char,
        25 => return b"R_386_TLS_GD_PUSH\0" as *const u8 as *const libc::c_char,
        26 => return b"R_386_TLS_GD_CALL\0" as *const u8 as *const libc::c_char,
        27 => return b"R_386_TLS_GD_POP\0" as *const u8 as *const libc::c_char,
        28 => return b"R_386_TLS_LDM_32\0" as *const u8 as *const libc::c_char,
        29 => return b"R_386_TLS_LDM_PUSH\0" as *const u8 as *const libc::c_char,
        30 => return b"R_386_TLS_LDM_CALL\0" as *const u8 as *const libc::c_char,
        31 => return b"R_386_TLS_LDM_POP\0" as *const u8 as *const libc::c_char,
        32 => return b"R_386_TLS_LDO_32\0" as *const u8 as *const libc::c_char,
        33 => return b"R_386_TLS_IE_32\0" as *const u8 as *const libc::c_char,
        34 => return b"R_386_TLS_LE_32\0" as *const u8 as *const libc::c_char,
        35 => return b"R_386_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        36 => return b"R_386_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
        37 => return b"R_386_TLS_TPOFF32\0" as *const u8 as *const libc::c_char,
        38 => return b"R_386_SIZE32\0" as *const u8 as *const libc::c_char,
        39 => return b"R_386_TLS_GOTDESC\0" as *const u8 as *const libc::c_char,
        40 => return b"R_386_TLS_DESC_CALL\0" as *const u8 as *const libc::c_char,
        41 => return b"R_386_TLS_DESC\0" as *const u8 as *const libc::c_char,
        42 => return b"R_386_IRELATIVE\0" as *const u8 as *const libc::c_char,
        43 => return b"R_386_GOT32X\0" as *const u8 as *const libc::c_char,
        200 => return b"R_386_USED_BY_INTEL_200\0" as *const u8 as *const libc::c_char,
        250 => return b"R_386_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        251 => return b"R_386_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn i370_reloc_type(mut rtype: libc::c_ulong) -> *const libc::c_char {
    match rtype {
        0 => return b"R_I370_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_I370_ADDR31\0" as *const u8 as *const libc::c_char,
        2 => return b"R_I370_ADDR32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_I370_ADDR16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_I370_REL31\0" as *const u8 as *const libc::c_char,
        5 => return b"R_I370_REL32\0" as *const u8 as *const libc::c_char,
        6 => return b"R_I370_ADDR12\0" as *const u8 as *const libc::c_char,
        7 => return b"R_I370_REL12\0" as *const u8 as *const libc::c_char,
        8 => return b"R_I370_ADDR8\0" as *const u8 as *const libc::c_char,
        9 => return b"R_I370_REL8\0" as *const u8 as *const libc::c_char,
        10 => return b"R_I370_COPY\0" as *const u8 as *const libc::c_char,
        11 => return b"R_I370_RELATIVE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_i860_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_860_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_860_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_860_COPY\0" as *const u8 as *const libc::c_char,
        3 => return b"R_860_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        4 => return b"R_860_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        5 => return b"R_860_RELATIVE\0" as *const u8 as *const libc::c_char,
        48 => return b"R_860_PC26\0" as *const u8 as *const libc::c_char,
        49 => return b"R_860_PLT26\0" as *const u8 as *const libc::c_char,
        50 => return b"R_860_PC16\0" as *const u8 as *const libc::c_char,
        64 => return b"R_860_LOW0\0" as *const u8 as *const libc::c_char,
        66 => return b"R_860_SPLIT0\0" as *const u8 as *const libc::c_char,
        68 => return b"R_860_LOW1\0" as *const u8 as *const libc::c_char,
        70 => return b"R_860_SPLIT1\0" as *const u8 as *const libc::c_char,
        72 => return b"R_860_LOW2\0" as *const u8 as *const libc::c_char,
        74 => return b"R_860_SPLIT2\0" as *const u8 as *const libc::c_char,
        76 => return b"R_860_LOW3\0" as *const u8 as *const libc::c_char,
        80 => return b"R_860_LOGOT0\0" as *const u8 as *const libc::c_char,
        82 => return b"R_860_SPGOT0\0" as *const u8 as *const libc::c_char,
        84 => return b"R_860_LOGOT1\0" as *const u8 as *const libc::c_char,
        86 => return b"R_860_SPGOT1\0" as *const u8 as *const libc::c_char,
        96 => return b"R_860_LOGOTOFF0\0" as *const u8 as *const libc::c_char,
        98 => return b"R_860_SPGOTOFF0\0" as *const u8 as *const libc::c_char,
        100 => return b"R_860_LOGOTOFF1\0" as *const u8 as *const libc::c_char,
        102 => return b"R_860_SPGOTOFF1\0" as *const u8 as *const libc::c_char,
        104 => return b"R_860_LOGOTOFF2\0" as *const u8 as *const libc::c_char,
        108 => return b"R_860_LOGOTOFF3\0" as *const u8 as *const libc::c_char,
        112 => return b"R_860_LOPC\0" as *const u8 as *const libc::c_char,
        128 => return b"R_860_HIGHADJ\0" as *const u8 as *const libc::c_char,
        144 => return b"R_860_HAGOT\0" as *const u8 as *const libc::c_char,
        160 => return b"R_860_HAGOTOFF\0" as *const u8 as *const libc::c_char,
        176 => return b"R_860_HAPC\0" as *const u8 as *const libc::c_char,
        192 => return b"R_860_HIGH\0" as *const u8 as *const libc::c_char,
        208 => return b"R_860_HIGOT\0" as *const u8 as *const libc::c_char,
        224 => return b"R_860_HIGOTOFF\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_i960_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_960_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_960_12\0" as *const u8 as *const libc::c_char,
        2 => return b"R_960_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_960_IP24\0" as *const u8 as *const libc::c_char,
        4 => return b"R_960_SUB\0" as *const u8 as *const libc::c_char,
        5 => return b"R_960_OPTCALL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_960_OPTCALLX\0" as *const u8 as *const libc::c_char,
        7 => return b"R_960_OPTCALLXA\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_ia64_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_IA64_NONE\0" as *const u8 as *const libc::c_char,
        33 => return b"R_IA64_IMM14\0" as *const u8 as *const libc::c_char,
        34 => return b"R_IA64_IMM22\0" as *const u8 as *const libc::c_char,
        35 => return b"R_IA64_IMM64\0" as *const u8 as *const libc::c_char,
        36 => return b"R_IA64_DIR32MSB\0" as *const u8 as *const libc::c_char,
        37 => return b"R_IA64_DIR32LSB\0" as *const u8 as *const libc::c_char,
        38 => return b"R_IA64_DIR64MSB\0" as *const u8 as *const libc::c_char,
        39 => return b"R_IA64_DIR64LSB\0" as *const u8 as *const libc::c_char,
        42 => return b"R_IA64_GPREL22\0" as *const u8 as *const libc::c_char,
        43 => return b"R_IA64_GPREL64I\0" as *const u8 as *const libc::c_char,
        44 => return b"R_IA64_GPREL32MSB\0" as *const u8 as *const libc::c_char,
        45 => return b"R_IA64_GPREL32LSB\0" as *const u8 as *const libc::c_char,
        46 => return b"R_IA64_GPREL64MSB\0" as *const u8 as *const libc::c_char,
        47 => return b"R_IA64_GPREL64LSB\0" as *const u8 as *const libc::c_char,
        50 => return b"R_IA64_LTOFF22\0" as *const u8 as *const libc::c_char,
        51 => return b"R_IA64_LTOFF64I\0" as *const u8 as *const libc::c_char,
        58 => return b"R_IA64_PLTOFF22\0" as *const u8 as *const libc::c_char,
        59 => return b"R_IA64_PLTOFF64I\0" as *const u8 as *const libc::c_char,
        62 => return b"R_IA64_PLTOFF64MSB\0" as *const u8 as *const libc::c_char,
        63 => return b"R_IA64_PLTOFF64LSB\0" as *const u8 as *const libc::c_char,
        67 => return b"R_IA64_FPTR64I\0" as *const u8 as *const libc::c_char,
        68 => return b"R_IA64_FPTR32MSB\0" as *const u8 as *const libc::c_char,
        69 => return b"R_IA64_FPTR32LSB\0" as *const u8 as *const libc::c_char,
        70 => return b"R_IA64_FPTR64MSB\0" as *const u8 as *const libc::c_char,
        71 => return b"R_IA64_FPTR64LSB\0" as *const u8 as *const libc::c_char,
        72 => return b"R_IA64_PCREL60B\0" as *const u8 as *const libc::c_char,
        73 => return b"R_IA64_PCREL21B\0" as *const u8 as *const libc::c_char,
        74 => return b"R_IA64_PCREL21M\0" as *const u8 as *const libc::c_char,
        75 => return b"R_IA64_PCREL21F\0" as *const u8 as *const libc::c_char,
        76 => return b"R_IA64_PCREL32MSB\0" as *const u8 as *const libc::c_char,
        77 => return b"R_IA64_PCREL32LSB\0" as *const u8 as *const libc::c_char,
        78 => return b"R_IA64_PCREL64MSB\0" as *const u8 as *const libc::c_char,
        79 => return b"R_IA64_PCREL64LSB\0" as *const u8 as *const libc::c_char,
        82 => return b"R_IA64_LTOFF_FPTR22\0" as *const u8 as *const libc::c_char,
        83 => return b"R_IA64_LTOFF_FPTR64I\0" as *const u8 as *const libc::c_char,
        84 => return b"R_IA64_LTOFF_FPTR32MSB\0" as *const u8 as *const libc::c_char,
        85 => return b"R_IA64_LTOFF_FPTR32LSB\0" as *const u8 as *const libc::c_char,
        86 => return b"R_IA64_LTOFF_FPTR64MSB\0" as *const u8 as *const libc::c_char,
        87 => return b"R_IA64_LTOFF_FPTR64LSB\0" as *const u8 as *const libc::c_char,
        92 => return b"R_IA64_SEGREL32MSB\0" as *const u8 as *const libc::c_char,
        93 => return b"R_IA64_SEGREL32LSB\0" as *const u8 as *const libc::c_char,
        94 => return b"R_IA64_SEGREL64MSB\0" as *const u8 as *const libc::c_char,
        95 => return b"R_IA64_SEGREL64LSB\0" as *const u8 as *const libc::c_char,
        100 => return b"R_IA64_SECREL32MSB\0" as *const u8 as *const libc::c_char,
        101 => return b"R_IA64_SECREL32LSB\0" as *const u8 as *const libc::c_char,
        102 => return b"R_IA64_SECREL64MSB\0" as *const u8 as *const libc::c_char,
        103 => return b"R_IA64_SECREL64LSB\0" as *const u8 as *const libc::c_char,
        108 => return b"R_IA64_REL32MSB\0" as *const u8 as *const libc::c_char,
        109 => return b"R_IA64_REL32LSB\0" as *const u8 as *const libc::c_char,
        110 => return b"R_IA64_REL64MSB\0" as *const u8 as *const libc::c_char,
        111 => return b"R_IA64_REL64LSB\0" as *const u8 as *const libc::c_char,
        116 => return b"R_IA64_LTV32MSB\0" as *const u8 as *const libc::c_char,
        117 => return b"R_IA64_LTV32LSB\0" as *const u8 as *const libc::c_char,
        118 => return b"R_IA64_LTV64MSB\0" as *const u8 as *const libc::c_char,
        119 => return b"R_IA64_LTV64LSB\0" as *const u8 as *const libc::c_char,
        121 => return b"R_IA64_PCREL21BI\0" as *const u8 as *const libc::c_char,
        122 => return b"R_IA64_PCREL22\0" as *const u8 as *const libc::c_char,
        123 => return b"R_IA64_PCREL64I\0" as *const u8 as *const libc::c_char,
        128 => return b"R_IA64_IPLTMSB\0" as *const u8 as *const libc::c_char,
        129 => return b"R_IA64_IPLTLSB\0" as *const u8 as *const libc::c_char,
        132 => return b"R_IA64_COPY\0" as *const u8 as *const libc::c_char,
        134 => return b"R_IA64_LTOFF22X\0" as *const u8 as *const libc::c_char,
        135 => return b"R_IA64_LDXMOV\0" as *const u8 as *const libc::c_char,
        145 => return b"R_IA64_TPREL14\0" as *const u8 as *const libc::c_char,
        146 => return b"R_IA64_TPREL22\0" as *const u8 as *const libc::c_char,
        147 => return b"R_IA64_TPREL64I\0" as *const u8 as *const libc::c_char,
        150 => return b"R_IA64_TPREL64MSB\0" as *const u8 as *const libc::c_char,
        151 => return b"R_IA64_TPREL64LSB\0" as *const u8 as *const libc::c_char,
        154 => return b"R_IA64_LTOFF_TPREL22\0" as *const u8 as *const libc::c_char,
        166 => return b"R_IA64_DTPMOD64MSB\0" as *const u8 as *const libc::c_char,
        167 => return b"R_IA64_DTPMOD64LSB\0" as *const u8 as *const libc::c_char,
        170 => return b"R_IA64_LTOFF_DTPMOD22\0" as *const u8 as *const libc::c_char,
        177 => return b"R_IA64_DTPREL14\0" as *const u8 as *const libc::c_char,
        178 => return b"R_IA64_DTPREL22\0" as *const u8 as *const libc::c_char,
        179 => return b"R_IA64_DTPREL64I\0" as *const u8 as *const libc::c_char,
        180 => return b"R_IA64_DTPREL32MSB\0" as *const u8 as *const libc::c_char,
        181 => return b"R_IA64_DTPREL32LSB\0" as *const u8 as *const libc::c_char,
        182 => return b"R_IA64_DTPREL64MSB\0" as *const u8 as *const libc::c_char,
        183 => return b"R_IA64_DTPREL64LSB\0" as *const u8 as *const libc::c_char,
        186 => return b"R_IA64_LTOFF_DTPREL22\0" as *const u8 as *const libc::c_char,
        1879048192 => return b"R_IA64_VMS_DIR8\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"R_IA64_VMS_DIR16LSB\0" as *const u8 as *const libc::c_char,
        1879048194 => {
            return b"R_IA64_VMS_CALL_SIGNATURE\0" as *const u8 as *const libc::c_char;
        }
        1879048195 => {
            return b"R_IA64_VMS_EXECLET_FUNC\0" as *const u8 as *const libc::c_char;
        }
        1879048196 => {
            return b"R_IA64_VMS_EXECLET_DATA\0" as *const u8 as *const libc::c_char;
        }
        1879048197 => return b"R_IA64_VMS_FIX8\0" as *const u8 as *const libc::c_char,
        1879048198 => return b"R_IA64_VMS_FIX16\0" as *const u8 as *const libc::c_char,
        1879048199 => return b"R_IA64_VMS_FIX32\0" as *const u8 as *const libc::c_char,
        1879048200 => return b"R_IA64_VMS_FIX64\0" as *const u8 as *const libc::c_char,
        1879048201 => return b"R_IA64_VMS_FIXFD\0" as *const u8 as *const libc::c_char,
        1879048202 => return b"R_IA64_VMS_ACC_LOAD\0" as *const u8 as *const libc::c_char,
        1879048203 => return b"R_IA64_VMS_ACC_ADD\0" as *const u8 as *const libc::c_char,
        1879048204 => return b"R_IA64_VMS_ACC_SUB\0" as *const u8 as *const libc::c_char,
        1879048205 => return b"R_IA64_VMS_ACC_MUL\0" as *const u8 as *const libc::c_char,
        1879048206 => return b"R_IA64_VMS_ACC_DIV\0" as *const u8 as *const libc::c_char,
        1879048207 => return b"R_IA64_VMS_ACC_AND\0" as *const u8 as *const libc::c_char,
        1879048208 => return b"R_IA64_VMS_ACC_IOR\0" as *const u8 as *const libc::c_char,
        1879048209 => return b"R_IA64_VMS_ACC_EOR\0" as *const u8 as *const libc::c_char,
        1879048210 => return b"R_IA64_VMS_ACC_ASH\0" as *const u8 as *const libc::c_char,
        1879048212 => return b"R_IA64_VMS_ACC_STO8\0" as *const u8 as *const libc::c_char,
        1879048213 => {
            return b"R_IA64_VMS_ACC_STO16LSH\0" as *const u8 as *const libc::c_char;
        }
        1879048214 => {
            return b"R_IA64_VMS_ACC_STO32LSH\0" as *const u8 as *const libc::c_char;
        }
        1879048215 => {
            return b"R_IA64_VMS_ACC_STO64LSH\0" as *const u8 as *const libc::c_char;
        }
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_ip2k_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_IP2K_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_IP2K_16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_IP2K_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_IP2K_FR9\0" as *const u8 as *const libc::c_char,
        4 => return b"R_IP2K_BANK\0" as *const u8 as *const libc::c_char,
        5 => return b"R_IP2K_ADDR16CJP\0" as *const u8 as *const libc::c_char,
        6 => return b"R_IP2K_PAGE3\0" as *const u8 as *const libc::c_char,
        7 => return b"R_IP2K_LO8DATA\0" as *const u8 as *const libc::c_char,
        8 => return b"R_IP2K_HI8DATA\0" as *const u8 as *const libc::c_char,
        9 => return b"R_IP2K_LO8INSN\0" as *const u8 as *const libc::c_char,
        10 => return b"R_IP2K_HI8INSN\0" as *const u8 as *const libc::c_char,
        11 => return b"R_IP2K_PC_SKIP\0" as *const u8 as *const libc::c_char,
        12 => return b"R_IP2K_TEXT\0" as *const u8 as *const libc::c_char,
        13 => return b"R_IP2K_FR_OFFSET\0" as *const u8 as *const libc::c_char,
        14 => return b"R_IP2K_EX8DATA\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_lm32_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_LM32_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_LM32_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_LM32_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_LM32_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_LM32_HI16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_LM32_LO16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_LM32_GPREL16\0" as *const u8 as *const libc::c_char,
        7 => return b"R_LM32_CALL\0" as *const u8 as *const libc::c_char,
        8 => return b"R_LM32_BRANCH\0" as *const u8 as *const libc::c_char,
        9 => return b"R_LM32_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        10 => return b"R_LM32_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        11 => return b"R_LM32_16_GOT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_LM32_GOTOFF_HI16\0" as *const u8 as *const libc::c_char,
        13 => return b"R_LM32_GOTOFF_LO16\0" as *const u8 as *const libc::c_char,
        14 => return b"R_LM32_COPY\0" as *const u8 as *const libc::c_char,
        15 => return b"R_LM32_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        16 => return b"R_LM32_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        17 => return b"R_LM32_RELATIVE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_iq2000_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_IQ2000_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_IQ2000_16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_IQ2000_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_IQ2000_26\0" as *const u8 as *const libc::c_char,
        4 => return b"R_IQ2000_PC16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_IQ2000_HI16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_IQ2000_LO16\0" as *const u8 as *const libc::c_char,
        7 => return b"R_IQ2000_OFFSET_16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_IQ2000_OFFSET_21\0" as *const u8 as *const libc::c_char,
        9 => return b"R_IQ2000_UHI16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_IQ2000_32_DEBUG\0" as *const u8 as *const libc::c_char,
        200 => return b"R_IQ2000_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        201 => return b"R_IQ2000_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_m32c_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_M32C_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_M32C_16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_M32C_24\0" as *const u8 as *const libc::c_char,
        3 => return b"R_M32C_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_M32C_8_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_M32C_16_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_M32C_8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_M32C_LO16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_M32C_HI8\0" as *const u8 as *const libc::c_char,
        9 => return b"R_M32C_HI16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_M32C_RL_JUMP\0" as *const u8 as *const libc::c_char,
        11 => return b"R_M32C_RL_1ADDR\0" as *const u8 as *const libc::c_char,
        12 => return b"R_M32C_RL_2ADDR\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_m32r_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_M32R_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_M32R_16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_M32R_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_M32R_24\0" as *const u8 as *const libc::c_char,
        4 => return b"R_M32R_10_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_M32R_18_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_M32R_26_PCREL\0" as *const u8 as *const libc::c_char,
        7 => return b"R_M32R_HI16_ULO\0" as *const u8 as *const libc::c_char,
        8 => return b"R_M32R_HI16_SLO\0" as *const u8 as *const libc::c_char,
        9 => return b"R_M32R_LO16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_M32R_SDA16\0" as *const u8 as *const libc::c_char,
        11 => return b"R_M32R_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_M32R_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        33 => return b"R_M32R_16_RELA\0" as *const u8 as *const libc::c_char,
        34 => return b"R_M32R_32_RELA\0" as *const u8 as *const libc::c_char,
        35 => return b"R_M32R_24_RELA\0" as *const u8 as *const libc::c_char,
        36 => return b"R_M32R_10_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        37 => return b"R_M32R_18_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        38 => return b"R_M32R_26_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        39 => return b"R_M32R_HI16_ULO_RELA\0" as *const u8 as *const libc::c_char,
        40 => return b"R_M32R_HI16_SLO_RELA\0" as *const u8 as *const libc::c_char,
        41 => return b"R_M32R_LO16_RELA\0" as *const u8 as *const libc::c_char,
        42 => return b"R_M32R_SDA16_RELA\0" as *const u8 as *const libc::c_char,
        43 => return b"R_M32R_RELA_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        44 => return b"R_M32R_RELA_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        45 => return b"R_M32R_REL32\0" as *const u8 as *const libc::c_char,
        48 => return b"R_M32R_GOT24\0" as *const u8 as *const libc::c_char,
        49 => return b"R_M32R_26_PLTREL\0" as *const u8 as *const libc::c_char,
        50 => return b"R_M32R_COPY\0" as *const u8 as *const libc::c_char,
        51 => return b"R_M32R_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        52 => return b"R_M32R_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        53 => return b"R_M32R_RELATIVE\0" as *const u8 as *const libc::c_char,
        54 => return b"R_M32R_GOTOFF\0" as *const u8 as *const libc::c_char,
        55 => return b"R_M32R_GOTPC24\0" as *const u8 as *const libc::c_char,
        56 => return b"R_M32R_GOT16_HI_ULO\0" as *const u8 as *const libc::c_char,
        57 => return b"R_M32R_GOT16_HI_SLO\0" as *const u8 as *const libc::c_char,
        58 => return b"R_M32R_GOT16_LO\0" as *const u8 as *const libc::c_char,
        59 => return b"R_M32R_GOTPC_HI_ULO\0" as *const u8 as *const libc::c_char,
        60 => return b"R_M32R_GOTPC_HI_SLO\0" as *const u8 as *const libc::c_char,
        61 => return b"R_M32R_GOTPC_LO\0" as *const u8 as *const libc::c_char,
        62 => return b"R_M32R_GOTOFF_HI_ULO\0" as *const u8 as *const libc::c_char,
        63 => return b"R_M32R_GOTOFF_HI_SLO\0" as *const u8 as *const libc::c_char,
        64 => return b"R_M32R_GOTOFF_LO\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_m68k_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_68K_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_68K_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_68K_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_68K_8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_68K_PC32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_68K_PC16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_68K_PC8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_68K_GOT32\0" as *const u8 as *const libc::c_char,
        8 => return b"R_68K_GOT16\0" as *const u8 as *const libc::c_char,
        9 => return b"R_68K_GOT8\0" as *const u8 as *const libc::c_char,
        10 => return b"R_68K_GOT32O\0" as *const u8 as *const libc::c_char,
        11 => return b"R_68K_GOT16O\0" as *const u8 as *const libc::c_char,
        12 => return b"R_68K_GOT8O\0" as *const u8 as *const libc::c_char,
        13 => return b"R_68K_PLT32\0" as *const u8 as *const libc::c_char,
        14 => return b"R_68K_PLT16\0" as *const u8 as *const libc::c_char,
        15 => return b"R_68K_PLT8\0" as *const u8 as *const libc::c_char,
        16 => return b"R_68K_PLT32O\0" as *const u8 as *const libc::c_char,
        17 => return b"R_68K_PLT16O\0" as *const u8 as *const libc::c_char,
        18 => return b"R_68K_PLT8O\0" as *const u8 as *const libc::c_char,
        19 => return b"R_68K_COPY\0" as *const u8 as *const libc::c_char,
        20 => return b"R_68K_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        21 => return b"R_68K_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        22 => return b"R_68K_RELATIVE\0" as *const u8 as *const libc::c_char,
        23 => return b"R_68K_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        24 => return b"R_68K_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        25 => return b"R_68K_TLS_GD32\0" as *const u8 as *const libc::c_char,
        26 => return b"R_68K_TLS_GD16\0" as *const u8 as *const libc::c_char,
        27 => return b"R_68K_TLS_GD8\0" as *const u8 as *const libc::c_char,
        28 => return b"R_68K_TLS_LDM32\0" as *const u8 as *const libc::c_char,
        29 => return b"R_68K_TLS_LDM16\0" as *const u8 as *const libc::c_char,
        30 => return b"R_68K_TLS_LDM8\0" as *const u8 as *const libc::c_char,
        31 => return b"R_68K_TLS_LDO32\0" as *const u8 as *const libc::c_char,
        32 => return b"R_68K_TLS_LDO16\0" as *const u8 as *const libc::c_char,
        33 => return b"R_68K_TLS_LDO8\0" as *const u8 as *const libc::c_char,
        34 => return b"R_68K_TLS_IE32\0" as *const u8 as *const libc::c_char,
        35 => return b"R_68K_TLS_IE16\0" as *const u8 as *const libc::c_char,
        36 => return b"R_68K_TLS_IE8\0" as *const u8 as *const libc::c_char,
        37 => return b"R_68K_TLS_LE32\0" as *const u8 as *const libc::c_char,
        38 => return b"R_68K_TLS_LE16\0" as *const u8 as *const libc::c_char,
        39 => return b"R_68K_TLS_LE8\0" as *const u8 as *const libc::c_char,
        40 => return b"R_68K_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        41 => return b"R_68K_TLS_DTPREL32\0" as *const u8 as *const libc::c_char,
        42 => return b"R_68K_TLS_TPREL32\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_m68hc11_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_M68HC11_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_M68HC11_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_M68HC11_HI8\0" as *const u8 as *const libc::c_char,
        3 => return b"R_M68HC11_LO8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_M68HC11_PCREL_8\0" as *const u8 as *const libc::c_char,
        5 => return b"R_M68HC11_16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_M68HC11_32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_M68HC11_3B\0" as *const u8 as *const libc::c_char,
        8 => return b"R_M68HC11_PCREL_16\0" as *const u8 as *const libc::c_char,
        9 => return b"R_M68HC11_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        10 => return b"R_M68HC11_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        11 => return b"R_M68HC11_24\0" as *const u8 as *const libc::c_char,
        12 => return b"R_M68HC11_LO16\0" as *const u8 as *const libc::c_char,
        13 => return b"R_M68HC11_PAGE\0" as *const u8 as *const libc::c_char,
        15 => return b"R_M68HC12_16B\0" as *const u8 as *const libc::c_char,
        16 => return b"R_M68HC12_PCREL_9\0" as *const u8 as *const libc::c_char,
        17 => return b"R_M68HC12_PCREL_10\0" as *const u8 as *const libc::c_char,
        18 => return b"R_M68HC12_HI8XG\0" as *const u8 as *const libc::c_char,
        19 => return b"R_M68HC12_LO8XG\0" as *const u8 as *const libc::c_char,
        20 => return b"R_M68HC11_RL_JUMP\0" as *const u8 as *const libc::c_char,
        21 => return b"R_M68HC11_RL_GROUP\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_s12z_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_S12Z_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_S12Z_OPR\0" as *const u8 as *const libc::c_char,
        2 => return b"R_S12Z_UKNWN_2\0" as *const u8 as *const libc::c_char,
        3 => return b"R_S12Z_PCREL_7_15\0" as *const u8 as *const libc::c_char,
        4 => return b"R_S12Z_EXT24\0" as *const u8 as *const libc::c_char,
        5 => return b"R_S12Z_EXT18\0" as *const u8 as *const libc::c_char,
        6 => return b"R_S12Z_CW32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_S12Z_EXT32\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_mcore_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MCORE_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MCORE_ADDR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MCORE_PCRELIMM8BY4\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MCORE_PCRELIMM11BY2\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MCORE_PCRELIMM4BY2\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MCORE_PCREL32\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MCORE_PCRELJSR_IMM11BY2\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MCORE_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        8 => return b"R_MCORE_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        9 => return b"R_MCORE_RELATIVE\0" as *const u8 as *const libc::c_char,
        10 => return b"R_MCORE_COPY\0" as *const u8 as *const libc::c_char,
        11 => return b"R_MCORE_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_MCORE_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_mep_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MEP_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_RELC\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MEP_8\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MEP_16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MEP_32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MEP_PCREL8A2\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MEP_PCREL12A2\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MEP_PCREL17A2\0" as *const u8 as *const libc::c_char,
        8 => return b"R_MEP_PCREL24A2\0" as *const u8 as *const libc::c_char,
        9 => return b"R_MEP_PCABS24A2\0" as *const u8 as *const libc::c_char,
        10 => return b"R_MEP_LOW16\0" as *const u8 as *const libc::c_char,
        11 => return b"R_MEP_HI16U\0" as *const u8 as *const libc::c_char,
        12 => return b"R_MEP_HI16S\0" as *const u8 as *const libc::c_char,
        13 => return b"R_MEP_GPREL\0" as *const u8 as *const libc::c_char,
        14 => return b"R_MEP_TPREL\0" as *const u8 as *const libc::c_char,
        15 => return b"R_MEP_TPREL7\0" as *const u8 as *const libc::c_char,
        16 => return b"R_MEP_TPREL7A2\0" as *const u8 as *const libc::c_char,
        17 => return b"R_MEP_TPREL7A4\0" as *const u8 as *const libc::c_char,
        18 => return b"R_MEP_UIMM24\0" as *const u8 as *const libc::c_char,
        19 => return b"R_MEP_ADDR24A4\0" as *const u8 as *const libc::c_char,
        20 => return b"R_MEP_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        21 => return b"R_MEP_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_metag_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_METAG_HIADDR16\0" as *const u8 as *const libc::c_char,
        1 => return b"R_METAG_LOADDR16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_METAG_ADDR32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_METAG_NONE\0" as *const u8 as *const libc::c_char,
        4 => return b"R_METAG_RELBRANCH\0" as *const u8 as *const libc::c_char,
        5 => return b"R_METAG_GETSETOFF\0" as *const u8 as *const libc::c_char,
        6 => return b"R_METAG_REG32OP1\0" as *const u8 as *const libc::c_char,
        7 => return b"R_METAG_REG32OP2\0" as *const u8 as *const libc::c_char,
        8 => return b"R_METAG_REG32OP3\0" as *const u8 as *const libc::c_char,
        9 => return b"R_METAG_REG16OP1\0" as *const u8 as *const libc::c_char,
        10 => return b"R_METAG_REG16OP2\0" as *const u8 as *const libc::c_char,
        11 => return b"R_METAG_REG16OP3\0" as *const u8 as *const libc::c_char,
        12 => return b"R_METAG_REG32OP4\0" as *const u8 as *const libc::c_char,
        13 => return b"R_METAG_HIOG\0" as *const u8 as *const libc::c_char,
        14 => return b"R_METAG_LOOG\0" as *const u8 as *const libc::c_char,
        15 => return b"R_METAG_REL8\0" as *const u8 as *const libc::c_char,
        16 => return b"R_METAG_REL16\0" as *const u8 as *const libc::c_char,
        30 => return b"R_METAG_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        31 => return b"R_METAG_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        32 => return b"R_METAG_HI16_GOTOFF\0" as *const u8 as *const libc::c_char,
        33 => return b"R_METAG_LO16_GOTOFF\0" as *const u8 as *const libc::c_char,
        34 => return b"R_METAG_GETSET_GOTOFF\0" as *const u8 as *const libc::c_char,
        35 => return b"R_METAG_GETSET_GOT\0" as *const u8 as *const libc::c_char,
        36 => return b"R_METAG_HI16_GOTPC\0" as *const u8 as *const libc::c_char,
        37 => return b"R_METAG_LO16_GOTPC\0" as *const u8 as *const libc::c_char,
        38 => return b"R_METAG_HI16_PLT\0" as *const u8 as *const libc::c_char,
        39 => return b"R_METAG_LO16_PLT\0" as *const u8 as *const libc::c_char,
        40 => return b"R_METAG_RELBRANCH_PLT\0" as *const u8 as *const libc::c_char,
        41 => return b"R_METAG_GOTOFF\0" as *const u8 as *const libc::c_char,
        42 => return b"R_METAG_PLT\0" as *const u8 as *const libc::c_char,
        43 => return b"R_METAG_COPY\0" as *const u8 as *const libc::c_char,
        44 => return b"R_METAG_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        45 => return b"R_METAG_RELATIVE\0" as *const u8 as *const libc::c_char,
        46 => return b"R_METAG_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        47 => return b"R_METAG_TLS_GD\0" as *const u8 as *const libc::c_char,
        48 => return b"R_METAG_TLS_LDM\0" as *const u8 as *const libc::c_char,
        49 => return b"R_METAG_TLS_LDO_HI16\0" as *const u8 as *const libc::c_char,
        50 => return b"R_METAG_TLS_LDO_LO16\0" as *const u8 as *const libc::c_char,
        51 => return b"R_METAG_TLS_LDO\0" as *const u8 as *const libc::c_char,
        52 => return b"R_METAG_TLS_IE\0" as *const u8 as *const libc::c_char,
        53 => return b"R_METAG_TLS_IENONPIC\0" as *const u8 as *const libc::c_char,
        54 => return b"R_METAG_TLS_IENONPIC_HI16\0" as *const u8 as *const libc::c_char,
        55 => return b"R_METAG_TLS_IENONPIC_LO16\0" as *const u8 as *const libc::c_char,
        56 => return b"R_METAG_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
        57 => return b"R_METAG_TLS_DTPMOD\0" as *const u8 as *const libc::c_char,
        58 => return b"R_METAG_TLS_DTPOFF\0" as *const u8 as *const libc::c_char,
        59 => return b"R_METAG_TLS_LE\0" as *const u8 as *const libc::c_char,
        60 => return b"R_METAG_TLS_LE_HI16\0" as *const u8 as *const libc::c_char,
        61 => return b"R_METAG_TLS_LE_LO16\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_microblaze_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MICROBLAZE_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MICROBLAZE_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MICROBLAZE_32_PCREL\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MICROBLAZE_64_PCREL\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MICROBLAZE_32_PCREL_LO\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MICROBLAZE_64\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MICROBLAZE_32_LO\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MICROBLAZE_SRO32\0" as *const u8 as *const libc::c_char,
        8 => return b"R_MICROBLAZE_SRW32\0" as *const u8 as *const libc::c_char,
        9 => return b"R_MICROBLAZE_64_NONE\0" as *const u8 as *const libc::c_char,
        10 => return b"R_MICROBLAZE_32_SYM_OP_SYM\0" as *const u8 as *const libc::c_char,
        11 => return b"R_MICROBLAZE_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_MICROBLAZE_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        13 => return b"R_MICROBLAZE_GOTPC_64\0" as *const u8 as *const libc::c_char,
        14 => return b"R_MICROBLAZE_GOT_64\0" as *const u8 as *const libc::c_char,
        15 => return b"R_MICROBLAZE_PLT_64\0" as *const u8 as *const libc::c_char,
        16 => return b"R_MICROBLAZE_REL\0" as *const u8 as *const libc::c_char,
        17 => return b"R_MICROBLAZE_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        18 => return b"R_MICROBLAZE_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        19 => return b"R_MICROBLAZE_GOTOFF_64\0" as *const u8 as *const libc::c_char,
        20 => return b"R_MICROBLAZE_GOTOFF_32\0" as *const u8 as *const libc::c_char,
        21 => return b"R_MICROBLAZE_COPY\0" as *const u8 as *const libc::c_char,
        22 => return b"R_MICROBLAZE_TLS\0" as *const u8 as *const libc::c_char,
        23 => return b"R_MICROBLAZE_TLSGD\0" as *const u8 as *const libc::c_char,
        24 => return b"R_MICROBLAZE_TLSLD\0" as *const u8 as *const libc::c_char,
        25 => return b"R_MICROBLAZE_TLSDTPMOD32\0" as *const u8 as *const libc::c_char,
        26 => return b"R_MICROBLAZE_TLSDTPREL32\0" as *const u8 as *const libc::c_char,
        27 => return b"R_MICROBLAZE_TLSDTPREL64\0" as *const u8 as *const libc::c_char,
        28 => return b"R_MICROBLAZE_TLSGOTTPREL32\0" as *const u8 as *const libc::c_char,
        29 => return b"R_MICROBLAZE_TLSTPREL32\0" as *const u8 as *const libc::c_char,
        30 => return b"R_MICROBLAZE_TEXTPCREL_64\0" as *const u8 as *const libc::c_char,
        31 => return b"R_MICROBLAZE_TEXTREL_64\0" as *const u8 as *const libc::c_char,
        32 => return b"R_MICROBLAZE_TEXTREL_32_LO\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_mips_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MIPS_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MIPS_16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MIPS_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MIPS_REL32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MIPS_26\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MIPS_HI16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MIPS_LO16\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MIPS_GPREL16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_MIPS_LITERAL\0" as *const u8 as *const libc::c_char,
        9 => return b"R_MIPS_GOT16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_MIPS_PC16\0" as *const u8 as *const libc::c_char,
        11 => return b"R_MIPS_CALL16\0" as *const u8 as *const libc::c_char,
        12 => return b"R_MIPS_GPREL32\0" as *const u8 as *const libc::c_char,
        13 => return b"R_MIPS_UNUSED1\0" as *const u8 as *const libc::c_char,
        14 => return b"R_MIPS_UNUSED2\0" as *const u8 as *const libc::c_char,
        15 => return b"R_MIPS_UNUSED3\0" as *const u8 as *const libc::c_char,
        16 => return b"R_MIPS_SHIFT5\0" as *const u8 as *const libc::c_char,
        17 => return b"R_MIPS_SHIFT6\0" as *const u8 as *const libc::c_char,
        18 => return b"R_MIPS_64\0" as *const u8 as *const libc::c_char,
        19 => return b"R_MIPS_GOT_DISP\0" as *const u8 as *const libc::c_char,
        20 => return b"R_MIPS_GOT_PAGE\0" as *const u8 as *const libc::c_char,
        21 => return b"R_MIPS_GOT_OFST\0" as *const u8 as *const libc::c_char,
        22 => return b"R_MIPS_GOT_HI16\0" as *const u8 as *const libc::c_char,
        23 => return b"R_MIPS_GOT_LO16\0" as *const u8 as *const libc::c_char,
        24 => return b"R_MIPS_SUB\0" as *const u8 as *const libc::c_char,
        25 => return b"R_MIPS_INSERT_A\0" as *const u8 as *const libc::c_char,
        26 => return b"R_MIPS_INSERT_B\0" as *const u8 as *const libc::c_char,
        27 => return b"R_MIPS_DELETE\0" as *const u8 as *const libc::c_char,
        28 => return b"R_MIPS_HIGHER\0" as *const u8 as *const libc::c_char,
        29 => return b"R_MIPS_HIGHEST\0" as *const u8 as *const libc::c_char,
        30 => return b"R_MIPS_CALL_HI16\0" as *const u8 as *const libc::c_char,
        31 => return b"R_MIPS_CALL_LO16\0" as *const u8 as *const libc::c_char,
        32 => return b"R_MIPS_SCN_DISP\0" as *const u8 as *const libc::c_char,
        33 => return b"R_MIPS_REL16\0" as *const u8 as *const libc::c_char,
        34 => return b"R_MIPS_ADD_IMMEDIATE\0" as *const u8 as *const libc::c_char,
        35 => return b"R_MIPS_PJUMP\0" as *const u8 as *const libc::c_char,
        36 => return b"R_MIPS_RELGOT\0" as *const u8 as *const libc::c_char,
        37 => return b"R_MIPS_JALR\0" as *const u8 as *const libc::c_char,
        38 => return b"R_MIPS_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        39 => return b"R_MIPS_TLS_DTPREL32\0" as *const u8 as *const libc::c_char,
        40 => return b"R_MIPS_TLS_DTPMOD64\0" as *const u8 as *const libc::c_char,
        41 => return b"R_MIPS_TLS_DTPREL64\0" as *const u8 as *const libc::c_char,
        42 => return b"R_MIPS_TLS_GD\0" as *const u8 as *const libc::c_char,
        43 => return b"R_MIPS_TLS_LDM\0" as *const u8 as *const libc::c_char,
        44 => return b"R_MIPS_TLS_DTPREL_HI16\0" as *const u8 as *const libc::c_char,
        45 => return b"R_MIPS_TLS_DTPREL_LO16\0" as *const u8 as *const libc::c_char,
        46 => return b"R_MIPS_TLS_GOTTPREL\0" as *const u8 as *const libc::c_char,
        47 => return b"R_MIPS_TLS_TPREL32\0" as *const u8 as *const libc::c_char,
        48 => return b"R_MIPS_TLS_TPREL64\0" as *const u8 as *const libc::c_char,
        49 => return b"R_MIPS_TLS_TPREL_HI16\0" as *const u8 as *const libc::c_char,
        50 => return b"R_MIPS_TLS_TPREL_LO16\0" as *const u8 as *const libc::c_char,
        51 => return b"R_MIPS_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        60 => return b"R_MIPS_PC21_S2\0" as *const u8 as *const libc::c_char,
        61 => return b"R_MIPS_PC26_S2\0" as *const u8 as *const libc::c_char,
        62 => return b"R_MIPS_PC18_S3\0" as *const u8 as *const libc::c_char,
        63 => return b"R_MIPS_PC19_S2\0" as *const u8 as *const libc::c_char,
        64 => return b"R_MIPS_PCHI16\0" as *const u8 as *const libc::c_char,
        65 => return b"R_MIPS_PCLO16\0" as *const u8 as *const libc::c_char,
        100 => return b"R_MIPS16_26\0" as *const u8 as *const libc::c_char,
        101 => return b"R_MIPS16_GPREL\0" as *const u8 as *const libc::c_char,
        102 => return b"R_MIPS16_GOT16\0" as *const u8 as *const libc::c_char,
        103 => return b"R_MIPS16_CALL16\0" as *const u8 as *const libc::c_char,
        104 => return b"R_MIPS16_HI16\0" as *const u8 as *const libc::c_char,
        105 => return b"R_MIPS16_LO16\0" as *const u8 as *const libc::c_char,
        106 => return b"R_MIPS16_TLS_GD\0" as *const u8 as *const libc::c_char,
        107 => return b"R_MIPS16_TLS_LDM\0" as *const u8 as *const libc::c_char,
        108 => return b"R_MIPS16_TLS_DTPREL_HI16\0" as *const u8 as *const libc::c_char,
        109 => return b"R_MIPS16_TLS_DTPREL_LO16\0" as *const u8 as *const libc::c_char,
        110 => return b"R_MIPS16_TLS_GOTTPREL\0" as *const u8 as *const libc::c_char,
        111 => return b"R_MIPS16_TLS_TPREL_HI16\0" as *const u8 as *const libc::c_char,
        112 => return b"R_MIPS16_TLS_TPREL_LO16\0" as *const u8 as *const libc::c_char,
        113 => return b"R_MIPS16_PC16_S1\0" as *const u8 as *const libc::c_char,
        126 => return b"R_MIPS_COPY\0" as *const u8 as *const libc::c_char,
        127 => return b"R_MIPS_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        133 => return b"R_MICROMIPS_26_S1\0" as *const u8 as *const libc::c_char,
        134 => return b"R_MICROMIPS_HI16\0" as *const u8 as *const libc::c_char,
        135 => return b"R_MICROMIPS_LO16\0" as *const u8 as *const libc::c_char,
        136 => return b"R_MICROMIPS_GPREL16\0" as *const u8 as *const libc::c_char,
        137 => return b"R_MICROMIPS_LITERAL\0" as *const u8 as *const libc::c_char,
        138 => return b"R_MICROMIPS_GOT16\0" as *const u8 as *const libc::c_char,
        139 => return b"R_MICROMIPS_PC7_S1\0" as *const u8 as *const libc::c_char,
        140 => return b"R_MICROMIPS_PC10_S1\0" as *const u8 as *const libc::c_char,
        141 => return b"R_MICROMIPS_PC16_S1\0" as *const u8 as *const libc::c_char,
        142 => return b"R_MICROMIPS_CALL16\0" as *const u8 as *const libc::c_char,
        145 => return b"R_MICROMIPS_GOT_DISP\0" as *const u8 as *const libc::c_char,
        146 => return b"R_MICROMIPS_GOT_PAGE\0" as *const u8 as *const libc::c_char,
        147 => return b"R_MICROMIPS_GOT_OFST\0" as *const u8 as *const libc::c_char,
        148 => return b"R_MICROMIPS_GOT_HI16\0" as *const u8 as *const libc::c_char,
        149 => return b"R_MICROMIPS_GOT_LO16\0" as *const u8 as *const libc::c_char,
        150 => return b"R_MICROMIPS_SUB\0" as *const u8 as *const libc::c_char,
        151 => return b"R_MICROMIPS_HIGHER\0" as *const u8 as *const libc::c_char,
        152 => return b"R_MICROMIPS_HIGHEST\0" as *const u8 as *const libc::c_char,
        153 => return b"R_MICROMIPS_CALL_HI16\0" as *const u8 as *const libc::c_char,
        154 => return b"R_MICROMIPS_CALL_LO16\0" as *const u8 as *const libc::c_char,
        155 => return b"R_MICROMIPS_SCN_DISP\0" as *const u8 as *const libc::c_char,
        156 => return b"R_MICROMIPS_JALR\0" as *const u8 as *const libc::c_char,
        157 => return b"R_MICROMIPS_HI0_LO16\0" as *const u8 as *const libc::c_char,
        162 => return b"R_MICROMIPS_TLS_GD\0" as *const u8 as *const libc::c_char,
        163 => return b"R_MICROMIPS_TLS_LDM\0" as *const u8 as *const libc::c_char,
        164 => {
            return b"R_MICROMIPS_TLS_DTPREL_HI16\0" as *const u8 as *const libc::c_char;
        }
        165 => {
            return b"R_MICROMIPS_TLS_DTPREL_LO16\0" as *const u8 as *const libc::c_char;
        }
        166 => return b"R_MICROMIPS_TLS_GOTTPREL\0" as *const u8 as *const libc::c_char,
        169 => return b"R_MICROMIPS_TLS_TPREL_HI16\0" as *const u8 as *const libc::c_char,
        170 => return b"R_MICROMIPS_TLS_TPREL_LO16\0" as *const u8 as *const libc::c_char,
        172 => return b"R_MICROMIPS_GPREL7_S2\0" as *const u8 as *const libc::c_char,
        173 => return b"R_MICROMIPS_PC23_S2\0" as *const u8 as *const libc::c_char,
        248 => return b"R_MIPS_PC32\0" as *const u8 as *const libc::c_char,
        249 => return b"R_MIPS_EH\0" as *const u8 as *const libc::c_char,
        250 => return b"R_MIPS_GNU_REL16_S2\0" as *const u8 as *const libc::c_char,
        253 => return b"R_MIPS_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        254 => return b"R_MIPS_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_mmix_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MMIX_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MMIX_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MMIX_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MMIX_24\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MMIX_32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MMIX_64\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MMIX_PC_8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MMIX_PC_16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_MMIX_PC_24\0" as *const u8 as *const libc::c_char,
        9 => return b"R_MMIX_PC_32\0" as *const u8 as *const libc::c_char,
        10 => return b"R_MMIX_PC_64\0" as *const u8 as *const libc::c_char,
        11 => return b"R_MMIX_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_MMIX_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        13 => return b"R_MMIX_GETA\0" as *const u8 as *const libc::c_char,
        14 => return b"R_MMIX_GETA_1\0" as *const u8 as *const libc::c_char,
        15 => return b"R_MMIX_GETA_2\0" as *const u8 as *const libc::c_char,
        16 => return b"R_MMIX_GETA_3\0" as *const u8 as *const libc::c_char,
        17 => return b"R_MMIX_CBRANCH\0" as *const u8 as *const libc::c_char,
        18 => return b"R_MMIX_CBRANCH_J\0" as *const u8 as *const libc::c_char,
        19 => return b"R_MMIX_CBRANCH_1\0" as *const u8 as *const libc::c_char,
        20 => return b"R_MMIX_CBRANCH_2\0" as *const u8 as *const libc::c_char,
        21 => return b"R_MMIX_CBRANCH_3\0" as *const u8 as *const libc::c_char,
        22 => return b"R_MMIX_PUSHJ\0" as *const u8 as *const libc::c_char,
        23 => return b"R_MMIX_PUSHJ_1\0" as *const u8 as *const libc::c_char,
        24 => return b"R_MMIX_PUSHJ_2\0" as *const u8 as *const libc::c_char,
        25 => return b"R_MMIX_PUSHJ_3\0" as *const u8 as *const libc::c_char,
        26 => return b"R_MMIX_JMP\0" as *const u8 as *const libc::c_char,
        27 => return b"R_MMIX_JMP_1\0" as *const u8 as *const libc::c_char,
        28 => return b"R_MMIX_JMP_2\0" as *const u8 as *const libc::c_char,
        29 => return b"R_MMIX_JMP_3\0" as *const u8 as *const libc::c_char,
        30 => return b"R_MMIX_ADDR19\0" as *const u8 as *const libc::c_char,
        31 => return b"R_MMIX_ADDR27\0" as *const u8 as *const libc::c_char,
        32 => return b"R_MMIX_REG_OR_BYTE\0" as *const u8 as *const libc::c_char,
        33 => return b"R_MMIX_REG\0" as *const u8 as *const libc::c_char,
        34 => return b"R_MMIX_BASE_PLUS_OFFSET\0" as *const u8 as *const libc::c_char,
        35 => return b"R_MMIX_LOCAL\0" as *const u8 as *const libc::c_char,
        36 => return b"R_MMIX_PUSHJ_STUBBABLE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_mn10200_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MN10200_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MN10200_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MN10200_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MN10200_8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MN10200_24\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MN10200_PCREL8\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MN10200_PCREL16\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MN10200_PCREL24\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_mn10300_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MN10300_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MN10300_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MN10300_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MN10300_8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MN10300_PCREL32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MN10300_PCREL16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MN10300_PCREL8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MN10300_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        8 => return b"R_MN10300_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        9 => return b"R_MN10300_24\0" as *const u8 as *const libc::c_char,
        10 => return b"R_MN10300_GOTPC32\0" as *const u8 as *const libc::c_char,
        11 => return b"R_MN10300_GOTPC16\0" as *const u8 as *const libc::c_char,
        12 => return b"R_MN10300_GOTOFF32\0" as *const u8 as *const libc::c_char,
        13 => return b"R_MN10300_GOTOFF24\0" as *const u8 as *const libc::c_char,
        14 => return b"R_MN10300_GOTOFF16\0" as *const u8 as *const libc::c_char,
        15 => return b"R_MN10300_PLT32\0" as *const u8 as *const libc::c_char,
        16 => return b"R_MN10300_PLT16\0" as *const u8 as *const libc::c_char,
        17 => return b"R_MN10300_GOT32\0" as *const u8 as *const libc::c_char,
        18 => return b"R_MN10300_GOT24\0" as *const u8 as *const libc::c_char,
        19 => return b"R_MN10300_GOT16\0" as *const u8 as *const libc::c_char,
        20 => return b"R_MN10300_COPY\0" as *const u8 as *const libc::c_char,
        21 => return b"R_MN10300_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        22 => return b"R_MN10300_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        23 => return b"R_MN10300_RELATIVE\0" as *const u8 as *const libc::c_char,
        24 => return b"R_MN10300_TLS_GD\0" as *const u8 as *const libc::c_char,
        25 => return b"R_MN10300_TLS_LD\0" as *const u8 as *const libc::c_char,
        26 => return b"R_MN10300_TLS_LDO\0" as *const u8 as *const libc::c_char,
        27 => return b"R_MN10300_TLS_GOTIE\0" as *const u8 as *const libc::c_char,
        28 => return b"R_MN10300_TLS_IE\0" as *const u8 as *const libc::c_char,
        29 => return b"R_MN10300_TLS_LE\0" as *const u8 as *const libc::c_char,
        30 => return b"R_MN10300_TLS_DTPMOD\0" as *const u8 as *const libc::c_char,
        31 => return b"R_MN10300_TLS_DTPOFF\0" as *const u8 as *const libc::c_char,
        32 => return b"R_MN10300_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
        33 => return b"R_MN10300_SYM_DIFF\0" as *const u8 as *const libc::c_char,
        34 => return b"R_MN10300_ALIGN\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_moxie_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MOXIE_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MOXIE_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MOXIE_PCREL10\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_mt_reloc_type(mut rtype: libc::c_ulong) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MT_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MT_16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MT_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MT_32_PCREL\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MT_PC16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MT_HI16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MT_LO16\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_msp430_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_MSP430_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_MSP430_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MSP430_10_PCREL\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MSP430_16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MSP430_16_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MSP430_16_BYTE\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MSP430_16_PCREL_BYTE\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MSP430_2X_PCREL\0" as *const u8 as *const libc::c_char,
        8 => return b"R_MSP430_RL_PCREL\0" as *const u8 as *const libc::c_char,
        9 => return b"R_MSP430_8\0" as *const u8 as *const libc::c_char,
        10 => return b"R_MSP430_SYM_DIFF\0" as *const u8 as *const libc::c_char,
        11 => return b"R_MSP430_GNU_SET_ULEB128\0" as *const u8 as *const libc::c_char,
        12 => return b"R_MSP430_GNU_SUB_ULEB128\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_msp430x_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        1 => return b"R_MSP430_ABS32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_MSP430_ABS16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_MSP430_ABS8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_MSP430_PCR16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_MSP430X_PCR20_EXT_SRC\0" as *const u8 as *const libc::c_char,
        6 => return b"R_MSP430X_PCR20_EXT_DST\0" as *const u8 as *const libc::c_char,
        7 => return b"R_MSP430X_PCR20_EXT_ODST\0" as *const u8 as *const libc::c_char,
        8 => return b"R_MSP430X_ABS20_EXT_SRC\0" as *const u8 as *const libc::c_char,
        9 => return b"R_MSP430X_ABS20_EXT_DST\0" as *const u8 as *const libc::c_char,
        10 => return b"R_MSP430X_ABS20_EXT_ODST\0" as *const u8 as *const libc::c_char,
        11 => return b"R_MSP430X_ABS20_ADR_SRC\0" as *const u8 as *const libc::c_char,
        12 => return b"R_MSP430X_ABS20_ADR_DST\0" as *const u8 as *const libc::c_char,
        13 => return b"R_MSP430X_PCR16\0" as *const u8 as *const libc::c_char,
        14 => return b"R_MSP430X_PCR20_CALL\0" as *const u8 as *const libc::c_char,
        15 => return b"R_MSP430X_ABS16\0" as *const u8 as *const libc::c_char,
        16 => return b"R_MSP430_ABS_HI16\0" as *const u8 as *const libc::c_char,
        17 => return b"R_MSP430_PREL31\0" as *const u8 as *const libc::c_char,
        18 => return b"R_MSP430_EHTYPE\0" as *const u8 as *const libc::c_char,
        19 => return b"R_MSP430X_10_PCREL\0" as *const u8 as *const libc::c_char,
        20 => return b"R_MSP430X_2X_PCREL\0" as *const u8 as *const libc::c_char,
        21 => return b"R_MSP430X_SYM_DIFF\0" as *const u8 as *const libc::c_char,
        22 => return b"R_MSP430X_GNU_SET_ULEB128\0" as *const u8 as *const libc::c_char,
        23 => return b"R_MSP430X_GNU_SUB_ULEB128\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_nds32_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_NDS32_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_NDS32_16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_NDS32_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_NDS32_20\0" as *const u8 as *const libc::c_char,
        4 => return b"R_NDS32_9_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_NDS32_15_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_NDS32_17_PCREL\0" as *const u8 as *const libc::c_char,
        7 => return b"R_NDS32_25_PCREL\0" as *const u8 as *const libc::c_char,
        8 => return b"R_NDS32_HI20\0" as *const u8 as *const libc::c_char,
        9 => return b"R_NDS32_LO12S3\0" as *const u8 as *const libc::c_char,
        10 => return b"R_NDS32_LO12S2\0" as *const u8 as *const libc::c_char,
        11 => return b"R_NDS32_LO12S1\0" as *const u8 as *const libc::c_char,
        12 => return b"R_NDS32_LO12S0\0" as *const u8 as *const libc::c_char,
        13 => return b"R_NDS32_SDA15S3\0" as *const u8 as *const libc::c_char,
        14 => return b"R_NDS32_SDA15S2\0" as *const u8 as *const libc::c_char,
        15 => return b"R_NDS32_SDA15S1\0" as *const u8 as *const libc::c_char,
        16 => return b"R_NDS32_SDA15S0\0" as *const u8 as *const libc::c_char,
        17 => return b"R_NDS32_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        18 => return b"R_NDS32_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        19 => return b"R_NDS32_16_RELA\0" as *const u8 as *const libc::c_char,
        20 => return b"R_NDS32_32_RELA\0" as *const u8 as *const libc::c_char,
        21 => return b"R_NDS32_20_RELA\0" as *const u8 as *const libc::c_char,
        22 => return b"R_NDS32_9_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        23 => return b"R_NDS32_15_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        24 => return b"R_NDS32_17_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        25 => return b"R_NDS32_25_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        26 => return b"R_NDS32_HI20_RELA\0" as *const u8 as *const libc::c_char,
        27 => return b"R_NDS32_LO12S3_RELA\0" as *const u8 as *const libc::c_char,
        28 => return b"R_NDS32_LO12S2_RELA\0" as *const u8 as *const libc::c_char,
        29 => return b"R_NDS32_LO12S1_RELA\0" as *const u8 as *const libc::c_char,
        30 => return b"R_NDS32_LO12S0_RELA\0" as *const u8 as *const libc::c_char,
        31 => return b"R_NDS32_SDA15S3_RELA\0" as *const u8 as *const libc::c_char,
        32 => return b"R_NDS32_SDA15S2_RELA\0" as *const u8 as *const libc::c_char,
        33 => return b"R_NDS32_SDA15S1_RELA\0" as *const u8 as *const libc::c_char,
        34 => return b"R_NDS32_SDA15S0_RELA\0" as *const u8 as *const libc::c_char,
        35 => return b"R_NDS32_RELA_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        36 => return b"R_NDS32_RELA_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        37 => return b"R_NDS32_GOT20\0" as *const u8 as *const libc::c_char,
        38 => return b"R_NDS32_25_PLTREL\0" as *const u8 as *const libc::c_char,
        39 => return b"R_NDS32_COPY\0" as *const u8 as *const libc::c_char,
        40 => return b"R_NDS32_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        41 => return b"R_NDS32_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        42 => return b"R_NDS32_RELATIVE\0" as *const u8 as *const libc::c_char,
        43 => return b"R_NDS32_GOTOFF\0" as *const u8 as *const libc::c_char,
        44 => return b"R_NDS32_GOTPC20\0" as *const u8 as *const libc::c_char,
        45 => return b"R_NDS32_GOT_HI20\0" as *const u8 as *const libc::c_char,
        46 => return b"R_NDS32_GOT_LO12\0" as *const u8 as *const libc::c_char,
        47 => return b"R_NDS32_GOTPC_HI20\0" as *const u8 as *const libc::c_char,
        48 => return b"R_NDS32_GOTPC_LO12\0" as *const u8 as *const libc::c_char,
        49 => return b"R_NDS32_GOTOFF_HI20\0" as *const u8 as *const libc::c_char,
        50 => return b"R_NDS32_GOTOFF_LO12\0" as *const u8 as *const libc::c_char,
        51 => return b"R_NDS32_INSN16\0" as *const u8 as *const libc::c_char,
        52 => return b"R_NDS32_LABEL\0" as *const u8 as *const libc::c_char,
        53 => return b"R_NDS32_LONGCALL1\0" as *const u8 as *const libc::c_char,
        54 => return b"R_NDS32_LONGCALL2\0" as *const u8 as *const libc::c_char,
        55 => return b"R_NDS32_LONGCALL3\0" as *const u8 as *const libc::c_char,
        56 => return b"R_NDS32_LONGJUMP1\0" as *const u8 as *const libc::c_char,
        57 => return b"R_NDS32_LONGJUMP2\0" as *const u8 as *const libc::c_char,
        58 => return b"R_NDS32_LONGJUMP3\0" as *const u8 as *const libc::c_char,
        59 => return b"R_NDS32_LOADSTORE\0" as *const u8 as *const libc::c_char,
        60 => return b"R_NDS32_9_FIXED_RELA\0" as *const u8 as *const libc::c_char,
        61 => return b"R_NDS32_15_FIXED_RELA\0" as *const u8 as *const libc::c_char,
        62 => return b"R_NDS32_17_FIXED_RELA\0" as *const u8 as *const libc::c_char,
        63 => return b"R_NDS32_25_FIXED_RELA\0" as *const u8 as *const libc::c_char,
        64 => return b"R_NDS32_PLTREL_HI20\0" as *const u8 as *const libc::c_char,
        65 => return b"R_NDS32_PLTREL_LO12\0" as *const u8 as *const libc::c_char,
        66 => return b"R_NDS32_PLT_GOTREL_HI20\0" as *const u8 as *const libc::c_char,
        67 => return b"R_NDS32_PLT_GOTREL_LO12\0" as *const u8 as *const libc::c_char,
        68 => return b"R_NDS32_SDA12S2_DP_RELA\0" as *const u8 as *const libc::c_char,
        69 => return b"R_NDS32_SDA12S2_SP_RELA\0" as *const u8 as *const libc::c_char,
        70 => return b"R_NDS32_LO12S2_DP_RELA\0" as *const u8 as *const libc::c_char,
        71 => return b"R_NDS32_LO12S2_SP_RELA\0" as *const u8 as *const libc::c_char,
        72 => return b"R_NDS32_LO12S0_ORI_RELA\0" as *const u8 as *const libc::c_char,
        73 => return b"R_NDS32_SDA16S3_RELA\0" as *const u8 as *const libc::c_char,
        74 => return b"R_NDS32_SDA17S2_RELA\0" as *const u8 as *const libc::c_char,
        75 => return b"R_NDS32_SDA18S1_RELA\0" as *const u8 as *const libc::c_char,
        76 => return b"R_NDS32_SDA19S0_RELA\0" as *const u8 as *const libc::c_char,
        77 => return b"R_NDS32_DWARF2_OP1_RELA\0" as *const u8 as *const libc::c_char,
        78 => return b"R_NDS32_DWARF2_OP2_RELA\0" as *const u8 as *const libc::c_char,
        79 => return b"R_NDS32_DWARF2_LEB_RELA\0" as *const u8 as *const libc::c_char,
        80 => return b"R_NDS32_UPDATE_TA_RELA\0" as *const u8 as *const libc::c_char,
        81 => return b"R_NDS32_9_PLTREL\0" as *const u8 as *const libc::c_char,
        82 => return b"R_NDS32_PLT_GOTREL_LO20\0" as *const u8 as *const libc::c_char,
        83 => return b"R_NDS32_PLT_GOTREL_LO15\0" as *const u8 as *const libc::c_char,
        84 => return b"R_NDS32_PLT_GOTREL_LO19\0" as *const u8 as *const libc::c_char,
        85 => return b"R_NDS32_GOT_LO15\0" as *const u8 as *const libc::c_char,
        86 => return b"R_NDS32_GOT_LO19\0" as *const u8 as *const libc::c_char,
        87 => return b"R_NDS32_GOTOFF_LO15\0" as *const u8 as *const libc::c_char,
        88 => return b"R_NDS32_GOTOFF_LO19\0" as *const u8 as *const libc::c_char,
        89 => return b"R_NDS32_GOT15S2_RELA\0" as *const u8 as *const libc::c_char,
        90 => return b"R_NDS32_GOT17S2_RELA\0" as *const u8 as *const libc::c_char,
        91 => return b"R_NDS32_5_RELA\0" as *const u8 as *const libc::c_char,
        92 => return b"R_NDS32_10_UPCREL_RELA\0" as *const u8 as *const libc::c_char,
        93 => return b"R_NDS32_SDA_FP7U2_RELA\0" as *const u8 as *const libc::c_char,
        94 => return b"R_NDS32_WORD_9_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        95 => return b"R_NDS32_25_ABS_RELA\0" as *const u8 as *const libc::c_char,
        96 => return b"R_NDS32_17IFC_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        97 => return b"R_NDS32_10IFCU_PCREL_RELA\0" as *const u8 as *const libc::c_char,
        98 => return b"R_NDS32_TLS_LE_HI20\0" as *const u8 as *const libc::c_char,
        99 => return b"R_NDS32_TLS_LE_LO12\0" as *const u8 as *const libc::c_char,
        100 => return b"R_NDS32_TLS_IE_HI20\0" as *const u8 as *const libc::c_char,
        101 => return b"R_NDS32_TLS_IE_LO12S2\0" as *const u8 as *const libc::c_char,
        102 => return b"R_NDS32_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
        103 => return b"R_NDS32_TLS_LE_20\0" as *const u8 as *const libc::c_char,
        104 => return b"R_NDS32_TLS_LE_15S0\0" as *const u8 as *const libc::c_char,
        105 => return b"R_NDS32_TLS_LE_15S1\0" as *const u8 as *const libc::c_char,
        106 => return b"R_NDS32_TLS_LE_15S2\0" as *const u8 as *const libc::c_char,
        107 => return b"R_NDS32_LONGCALL4\0" as *const u8 as *const libc::c_char,
        108 => return b"R_NDS32_LONGCALL5\0" as *const u8 as *const libc::c_char,
        109 => return b"R_NDS32_LONGCALL6\0" as *const u8 as *const libc::c_char,
        110 => return b"R_NDS32_LONGJUMP4\0" as *const u8 as *const libc::c_char,
        111 => return b"R_NDS32_LONGJUMP5\0" as *const u8 as *const libc::c_char,
        112 => return b"R_NDS32_LONGJUMP6\0" as *const u8 as *const libc::c_char,
        113 => return b"R_NDS32_LONGJUMP7\0" as *const u8 as *const libc::c_char,
        115 => return b"R_NDS32_TLS_IE_LO12\0" as *const u8 as *const libc::c_char,
        116 => return b"R_NDS32_TLS_IEGP_HI20\0" as *const u8 as *const libc::c_char,
        117 => return b"R_NDS32_TLS_IEGP_LO12\0" as *const u8 as *const libc::c_char,
        118 => return b"R_NDS32_TLS_IEGP_LO12S2\0" as *const u8 as *const libc::c_char,
        119 => return b"R_NDS32_TLS_DESC\0" as *const u8 as *const libc::c_char,
        120 => return b"R_NDS32_TLS_DESC_HI20\0" as *const u8 as *const libc::c_char,
        121 => return b"R_NDS32_TLS_DESC_LO12\0" as *const u8 as *const libc::c_char,
        122 => return b"R_NDS32_TLS_DESC_20\0" as *const u8 as *const libc::c_char,
        123 => return b"R_NDS32_TLS_DESC_SDA17S2\0" as *const u8 as *const libc::c_char,
        192 => return b"R_NDS32_RELAX_ENTRY\0" as *const u8 as *const libc::c_char,
        193 => return b"R_NDS32_GOT_SUFF\0" as *const u8 as *const libc::c_char,
        194 => return b"R_NDS32_GOTOFF_SUFF\0" as *const u8 as *const libc::c_char,
        195 => return b"R_NDS32_PLT_GOT_SUFF\0" as *const u8 as *const libc::c_char,
        196 => return b"R_NDS32_MULCALL_SUFF\0" as *const u8 as *const libc::c_char,
        197 => return b"R_NDS32_PTR\0" as *const u8 as *const libc::c_char,
        198 => return b"R_NDS32_PTR_COUNT\0" as *const u8 as *const libc::c_char,
        199 => return b"R_NDS32_PTR_RESOLVED\0" as *const u8 as *const libc::c_char,
        200 => return b"R_NDS32_PLTBLOCK\0" as *const u8 as *const libc::c_char,
        201 => return b"R_NDS32_RELAX_REGION_BEGIN\0" as *const u8 as *const libc::c_char,
        202 => return b"R_NDS32_RELAX_REGION_END\0" as *const u8 as *const libc::c_char,
        203 => return b"R_NDS32_MINUEND\0" as *const u8 as *const libc::c_char,
        204 => return b"R_NDS32_SUBTRAHEND\0" as *const u8 as *const libc::c_char,
        205 => return b"R_NDS32_DIFF8\0" as *const u8 as *const libc::c_char,
        206 => return b"R_NDS32_DIFF16\0" as *const u8 as *const libc::c_char,
        207 => return b"R_NDS32_DIFF32\0" as *const u8 as *const libc::c_char,
        208 => return b"R_NDS32_DIFF_ULEB128\0" as *const u8 as *const libc::c_char,
        209 => return b"R_NDS32_DATA\0" as *const u8 as *const libc::c_char,
        210 => return b"R_NDS32_TRAN\0" as *const u8 as *const libc::c_char,
        211 => return b"R_NDS32_TLS_LE_ADD\0" as *const u8 as *const libc::c_char,
        212 => return b"R_NDS32_TLS_LE_LS\0" as *const u8 as *const libc::c_char,
        213 => return b"R_NDS32_EMPTY\0" as *const u8 as *const libc::c_char,
        214 => return b"R_NDS32_TLS_DESC_ADD\0" as *const u8 as *const libc::c_char,
        215 => return b"R_NDS32_TLS_DESC_FUNC\0" as *const u8 as *const libc::c_char,
        216 => return b"R_NDS32_TLS_DESC_CALL\0" as *const u8 as *const libc::c_char,
        217 => return b"R_NDS32_TLS_DESC_MEM\0" as *const u8 as *const libc::c_char,
        218 => return b"R_NDS32_RELAX_REMOVE\0" as *const u8 as *const libc::c_char,
        219 => return b"R_NDS32_RELAX_GROUP\0" as *const u8 as *const libc::c_char,
        220 => return b"R_NDS32_TLS_IEGP_LW\0" as *const u8 as *const libc::c_char,
        221 => return b"R_NDS32_LSI\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_nfp3200_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_NFP3200_NOTYPE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_NFP3200_W32LE\0" as *const u8 as *const libc::c_char,
        2 => return b"R_NFP3200_SRC8_A\0" as *const u8 as *const libc::c_char,
        3 => return b"R_NFP3200_SRC8_B\0" as *const u8 as *const libc::c_char,
        4 => return b"R_NFP3200_IMMED8_I\0" as *const u8 as *const libc::c_char,
        5 => return b"R_NFP3200_SC\0" as *const u8 as *const libc::c_char,
        6 => return b"R_NFP3200_IMMED_LO16_I_A\0" as *const u8 as *const libc::c_char,
        7 => return b"R_NFP3200_IMMED_LO16_I_B\0" as *const u8 as *const libc::c_char,
        8 => return b"R_NFP3200_SRC7_B\0" as *const u8 as *const libc::c_char,
        9 => return b"R_NFP3200_SRC7_A\0" as *const u8 as *const libc::c_char,
        10 => return b"R_NFP3200_SRC8_I_B\0" as *const u8 as *const libc::c_char,
        11 => return b"R_NFP3200_SRC8_I_A\0" as *const u8 as *const libc::c_char,
        12 => return b"R_NFP3200_IMMED_HI16_I_A\0" as *const u8 as *const libc::c_char,
        13 => return b"R_NFP3200_IMMED_HI16_I_B\0" as *const u8 as *const libc::c_char,
        14 => return b"R_NFP3200_RSVD_0\0" as *const u8 as *const libc::c_char,
        15 => return b"R_NFP3200_RSVD_1\0" as *const u8 as *const libc::c_char,
        16 => return b"R_NFP3200_RSVD_2\0" as *const u8 as *const libc::c_char,
        17 => return b"R_NFP3200_RSVD_3\0" as *const u8 as *const libc::c_char,
        18 => return b"R_NFP3200_RSVD_4\0" as *const u8 as *const libc::c_char,
        19 => return b"R_NFP3200_RSVD_5\0" as *const u8 as *const libc::c_char,
        20 => return b"R_NFP3200_RSVD_6\0" as *const u8 as *const libc::c_char,
        21 => return b"R_NFP3200_W64LE\0" as *const u8 as *const libc::c_char,
        22 => return b"R_NFP3200_W32BE\0" as *const u8 as *const libc::c_char,
        23 => return b"R_NFP3200_W64BE\0" as *const u8 as *const libc::c_char,
        24 => return b"R_NFP3200_W32LE_AND\0" as *const u8 as *const libc::c_char,
        25 => return b"R_NFP3200_W32BE_AND\0" as *const u8 as *const libc::c_char,
        26 => return b"R_NFP3200_W32LE_OR\0" as *const u8 as *const libc::c_char,
        27 => return b"R_NFP3200_W32BE_OR\0" as *const u8 as *const libc::c_char,
        28 => return b"R_NFP3200_W64LE_AND\0" as *const u8 as *const libc::c_char,
        29 => return b"R_NFP3200_W64BE_AND\0" as *const u8 as *const libc::c_char,
        30 => return b"R_NFP3200_W64LE_OR\0" as *const u8 as *const libc::c_char,
        31 => return b"R_NFP3200_W64BE_OR\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_nfp_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_NFP_NOTYPE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_NFP_W32LE\0" as *const u8 as *const libc::c_char,
        2 => return b"R_NFP_SRC8_A\0" as *const u8 as *const libc::c_char,
        3 => return b"R_NFP_SRC8_B\0" as *const u8 as *const libc::c_char,
        4 => return b"R_NFP_IMMED8_I\0" as *const u8 as *const libc::c_char,
        5 => return b"R_NFP_SC\0" as *const u8 as *const libc::c_char,
        6 => return b"R_NFP_IMMED_LO16_I_A\0" as *const u8 as *const libc::c_char,
        7 => return b"R_NFP_IMMED_LO16_I_B\0" as *const u8 as *const libc::c_char,
        8 => return b"R_NFP_SRC7_B\0" as *const u8 as *const libc::c_char,
        9 => return b"R_NFP_SRC7_A\0" as *const u8 as *const libc::c_char,
        10 => return b"R_NFP_SRC8_I_B\0" as *const u8 as *const libc::c_char,
        11 => return b"R_NFP_SRC8_I_A\0" as *const u8 as *const libc::c_char,
        12 => return b"R_NFP_IMMED_HI16_I_A\0" as *const u8 as *const libc::c_char,
        13 => return b"R_NFP_IMMED_HI16_I_B\0" as *const u8 as *const libc::c_char,
        14 => return b"R_NFP_W64LE\0" as *const u8 as *const libc::c_char,
        15 => return b"R_NFP_SH_INFO\0" as *const u8 as *const libc::c_char,
        16 => return b"R_NFP_W32BE\0" as *const u8 as *const libc::c_char,
        17 => return b"R_NFP_W64BE\0" as *const u8 as *const libc::c_char,
        18 => return b"R_NFP_W32_29_24\0" as *const u8 as *const libc::c_char,
        19 => return b"R_NFP_W32LE_AND\0" as *const u8 as *const libc::c_char,
        20 => return b"R_NFP_W32BE_AND\0" as *const u8 as *const libc::c_char,
        21 => return b"R_NFP_W32LE_OR\0" as *const u8 as *const libc::c_char,
        22 => return b"R_NFP_W32BE_OR\0" as *const u8 as *const libc::c_char,
        23 => return b"R_NFP_W64LE_AND\0" as *const u8 as *const libc::c_char,
        24 => return b"R_NFP_W64BE_AND\0" as *const u8 as *const libc::c_char,
        25 => return b"R_NFP_W64LE_OR\0" as *const u8 as *const libc::c_char,
        26 => return b"R_NFP_W64BE_OR\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_nios2_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_NIOS2_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_NIOS2_S16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_NIOS2_U16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_NIOS2_PCREL16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_NIOS2_CALL26\0" as *const u8 as *const libc::c_char,
        5 => return b"R_NIOS2_IMM5\0" as *const u8 as *const libc::c_char,
        6 => return b"R_NIOS2_CACHE_OPX\0" as *const u8 as *const libc::c_char,
        7 => return b"R_NIOS2_IMM6\0" as *const u8 as *const libc::c_char,
        8 => return b"R_NIOS2_IMM8\0" as *const u8 as *const libc::c_char,
        9 => return b"R_NIOS2_HI16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_NIOS2_LO16\0" as *const u8 as *const libc::c_char,
        11 => return b"R_NIOS2_HIADJ16\0" as *const u8 as *const libc::c_char,
        12 => return b"R_NIOS2_BFD_RELOC_32\0" as *const u8 as *const libc::c_char,
        13 => return b"R_NIOS2_BFD_RELOC_16\0" as *const u8 as *const libc::c_char,
        14 => return b"R_NIOS2_BFD_RELOC_8\0" as *const u8 as *const libc::c_char,
        15 => return b"R_NIOS2_GPREL\0" as *const u8 as *const libc::c_char,
        16 => return b"R_NIOS2_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        17 => return b"R_NIOS2_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        18 => return b"R_NIOS2_UJMP\0" as *const u8 as *const libc::c_char,
        19 => return b"R_NIOS2_CJMP\0" as *const u8 as *const libc::c_char,
        20 => return b"R_NIOS2_CALLR\0" as *const u8 as *const libc::c_char,
        21 => return b"R_NIOS2_ALIGN\0" as *const u8 as *const libc::c_char,
        22 => return b"R_NIOS2_GOT16\0" as *const u8 as *const libc::c_char,
        23 => return b"R_NIOS2_CALL16\0" as *const u8 as *const libc::c_char,
        24 => return b"R_NIOS2_GOTOFF_LO\0" as *const u8 as *const libc::c_char,
        25 => return b"R_NIOS2_GOTOFF_HA\0" as *const u8 as *const libc::c_char,
        26 => return b"R_NIOS2_PCREL_LO\0" as *const u8 as *const libc::c_char,
        27 => return b"R_NIOS2_PCREL_HA\0" as *const u8 as *const libc::c_char,
        28 => return b"R_NIOS2_TLS_GD16\0" as *const u8 as *const libc::c_char,
        29 => return b"R_NIOS2_TLS_LDM16\0" as *const u8 as *const libc::c_char,
        30 => return b"R_NIOS2_TLS_LDO16\0" as *const u8 as *const libc::c_char,
        31 => return b"R_NIOS2_TLS_IE16\0" as *const u8 as *const libc::c_char,
        32 => return b"R_NIOS2_TLS_LE16\0" as *const u8 as *const libc::c_char,
        33 => return b"R_NIOS2_TLS_DTPMOD\0" as *const u8 as *const libc::c_char,
        34 => return b"R_NIOS2_TLS_DTPREL\0" as *const u8 as *const libc::c_char,
        35 => return b"R_NIOS2_TLS_TPREL\0" as *const u8 as *const libc::c_char,
        36 => return b"R_NIOS2_COPY\0" as *const u8 as *const libc::c_char,
        37 => return b"R_NIOS2_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        38 => return b"R_NIOS2_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        39 => return b"R_NIOS2_RELATIVE\0" as *const u8 as *const libc::c_char,
        40 => return b"R_NIOS2_GOTOFF\0" as *const u8 as *const libc::c_char,
        41 => return b"R_NIOS2_CALL26_NOAT\0" as *const u8 as *const libc::c_char,
        42 => return b"R_NIOS2_GOT_LO\0" as *const u8 as *const libc::c_char,
        43 => return b"R_NIOS2_GOT_HA\0" as *const u8 as *const libc::c_char,
        44 => return b"R_NIOS2_CALL_LO\0" as *const u8 as *const libc::c_char,
        45 => return b"R_NIOS2_CALL_HA\0" as *const u8 as *const libc::c_char,
        64 => return b"R_NIOS2_R2_S12\0" as *const u8 as *const libc::c_char,
        65 => return b"R_NIOS2_R2_I10_1_PCREL\0" as *const u8 as *const libc::c_char,
        66 => return b"R_NIOS2_R2_T1I7_1_PCREL\0" as *const u8 as *const libc::c_char,
        67 => return b"R_NIOS2_R2_T1I7_2\0" as *const u8 as *const libc::c_char,
        68 => return b"R_NIOS2_R2_T2I4\0" as *const u8 as *const libc::c_char,
        69 => return b"R_NIOS2_R2_T2I4_1\0" as *const u8 as *const libc::c_char,
        70 => return b"R_NIOS2_R2_T2I4_2\0" as *const u8 as *const libc::c_char,
        71 => return b"R_NIOS2_R2_X1I7_2\0" as *const u8 as *const libc::c_char,
        72 => return b"R_NIOS2_R2_X2L5\0" as *const u8 as *const libc::c_char,
        73 => return b"R_NIOS2_R2_F1I5_2\0" as *const u8 as *const libc::c_char,
        74 => return b"R_NIOS2_R2_L5I4X1\0" as *const u8 as *const libc::c_char,
        75 => return b"R_NIOS2_R2_T1X1I6\0" as *const u8 as *const libc::c_char,
        76 => return b"R_NIOS2_R2_T1X1I6_2\0" as *const u8 as *const libc::c_char,
        77 => return b"R_NIOS2_ILLEGAL\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_or1k_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_OR1K_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_OR1K_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_OR1K_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_OR1K_8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_OR1K_LO_16_IN_INSN\0" as *const u8 as *const libc::c_char,
        5 => return b"R_OR1K_HI_16_IN_INSN\0" as *const u8 as *const libc::c_char,
        6 => return b"R_OR1K_INSN_REL_26\0" as *const u8 as *const libc::c_char,
        7 => return b"R_OR1K_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        8 => return b"R_OR1K_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        9 => return b"R_OR1K_32_PCREL\0" as *const u8 as *const libc::c_char,
        10 => return b"R_OR1K_16_PCREL\0" as *const u8 as *const libc::c_char,
        11 => return b"R_OR1K_8_PCREL\0" as *const u8 as *const libc::c_char,
        12 => return b"R_OR1K_GOTPC_HI16\0" as *const u8 as *const libc::c_char,
        13 => return b"R_OR1K_GOTPC_LO16\0" as *const u8 as *const libc::c_char,
        14 => return b"R_OR1K_GOT16\0" as *const u8 as *const libc::c_char,
        15 => return b"R_OR1K_PLT26\0" as *const u8 as *const libc::c_char,
        16 => return b"R_OR1K_GOTOFF_HI16\0" as *const u8 as *const libc::c_char,
        17 => return b"R_OR1K_GOTOFF_LO16\0" as *const u8 as *const libc::c_char,
        18 => return b"R_OR1K_COPY\0" as *const u8 as *const libc::c_char,
        19 => return b"R_OR1K_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        20 => return b"R_OR1K_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        21 => return b"R_OR1K_RELATIVE\0" as *const u8 as *const libc::c_char,
        22 => return b"R_OR1K_TLS_GD_HI16\0" as *const u8 as *const libc::c_char,
        23 => return b"R_OR1K_TLS_GD_LO16\0" as *const u8 as *const libc::c_char,
        24 => return b"R_OR1K_TLS_LDM_HI16\0" as *const u8 as *const libc::c_char,
        25 => return b"R_OR1K_TLS_LDM_LO16\0" as *const u8 as *const libc::c_char,
        26 => return b"R_OR1K_TLS_LDO_HI16\0" as *const u8 as *const libc::c_char,
        27 => return b"R_OR1K_TLS_LDO_LO16\0" as *const u8 as *const libc::c_char,
        28 => return b"R_OR1K_TLS_IE_HI16\0" as *const u8 as *const libc::c_char,
        29 => return b"R_OR1K_TLS_IE_LO16\0" as *const u8 as *const libc::c_char,
        30 => return b"R_OR1K_TLS_LE_HI16\0" as *const u8 as *const libc::c_char,
        31 => return b"R_OR1K_TLS_LE_LO16\0" as *const u8 as *const libc::c_char,
        32 => return b"R_OR1K_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
        33 => return b"R_OR1K_TLS_DTPOFF\0" as *const u8 as *const libc::c_char,
        34 => return b"R_OR1K_TLS_DTPMOD\0" as *const u8 as *const libc::c_char,
        35 => return b"R_OR1K_AHI16\0" as *const u8 as *const libc::c_char,
        36 => return b"R_OR1K_GOTOFF_AHI16\0" as *const u8 as *const libc::c_char,
        37 => return b"R_OR1K_TLS_IE_AHI16\0" as *const u8 as *const libc::c_char,
        38 => return b"R_OR1K_TLS_LE_AHI16\0" as *const u8 as *const libc::c_char,
        39 => return b"R_OR1K_SLO16\0" as *const u8 as *const libc::c_char,
        40 => return b"R_OR1K_GOTOFF_SLO16\0" as *const u8 as *const libc::c_char,
        41 => return b"R_OR1K_TLS_LE_SLO16\0" as *const u8 as *const libc::c_char,
        42 => return b"R_OR1K_PCREL_PG21\0" as *const u8 as *const libc::c_char,
        43 => return b"R_OR1K_GOT_PG21\0" as *const u8 as *const libc::c_char,
        44 => return b"R_OR1K_TLS_GD_PG21\0" as *const u8 as *const libc::c_char,
        45 => return b"R_OR1K_TLS_LDM_PG21\0" as *const u8 as *const libc::c_char,
        46 => return b"R_OR1K_TLS_IE_PG21\0" as *const u8 as *const libc::c_char,
        47 => return b"R_OR1K_LO13\0" as *const u8 as *const libc::c_char,
        48 => return b"R_OR1K_GOT_LO13\0" as *const u8 as *const libc::c_char,
        49 => return b"R_OR1K_TLS_GD_LO13\0" as *const u8 as *const libc::c_char,
        50 => return b"R_OR1K_TLS_LDM_LO13\0" as *const u8 as *const libc::c_char,
        51 => return b"R_OR1K_TLS_IE_LO13\0" as *const u8 as *const libc::c_char,
        52 => return b"R_OR1K_SLO13\0" as *const u8 as *const libc::c_char,
        53 => return b"R_OR1K_PLTA26\0" as *const u8 as *const libc::c_char,
        54 => return b"R_OR1K_GOT_AHI16\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_pj_reloc_type(mut rtype: libc::c_ulong) -> *const libc::c_char {
    match rtype {
        0 => return b"R_PJ_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_PJ_DATA_DIR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_PJ_CODE_REL32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_PJ_CODE_REL16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_PJ_CODE_DIR32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_PJ_CODE_DIR16\0" as *const u8 as *const libc::c_char,
        13 => return b"R_PJ_CODE_LO16\0" as *const u8 as *const libc::c_char,
        14 => return b"R_PJ_CODE_HI16\0" as *const u8 as *const libc::c_char,
        15 => return b"R_PJ_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        16 => return b"R_PJ_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_ppc_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_PPC_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_PPC_ADDR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_PPC_ADDR24\0" as *const u8 as *const libc::c_char,
        3 => return b"R_PPC_ADDR16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_PPC_ADDR16_LO\0" as *const u8 as *const libc::c_char,
        5 => return b"R_PPC_ADDR16_HI\0" as *const u8 as *const libc::c_char,
        6 => return b"R_PPC_ADDR16_HA\0" as *const u8 as *const libc::c_char,
        7 => return b"R_PPC_ADDR14\0" as *const u8 as *const libc::c_char,
        8 => return b"R_PPC_ADDR14_BRTAKEN\0" as *const u8 as *const libc::c_char,
        9 => return b"R_PPC_ADDR14_BRNTAKEN\0" as *const u8 as *const libc::c_char,
        10 => return b"R_PPC_REL24\0" as *const u8 as *const libc::c_char,
        11 => return b"R_PPC_REL14\0" as *const u8 as *const libc::c_char,
        12 => return b"R_PPC_REL14_BRTAKEN\0" as *const u8 as *const libc::c_char,
        13 => return b"R_PPC_REL14_BRNTAKEN\0" as *const u8 as *const libc::c_char,
        14 => return b"R_PPC_GOT16\0" as *const u8 as *const libc::c_char,
        15 => return b"R_PPC_GOT16_LO\0" as *const u8 as *const libc::c_char,
        16 => return b"R_PPC_GOT16_HI\0" as *const u8 as *const libc::c_char,
        17 => return b"R_PPC_GOT16_HA\0" as *const u8 as *const libc::c_char,
        18 => return b"R_PPC_PLTREL24\0" as *const u8 as *const libc::c_char,
        19 => return b"R_PPC_COPY\0" as *const u8 as *const libc::c_char,
        20 => return b"R_PPC_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        21 => return b"R_PPC_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        22 => return b"R_PPC_RELATIVE\0" as *const u8 as *const libc::c_char,
        23 => return b"R_PPC_LOCAL24PC\0" as *const u8 as *const libc::c_char,
        24 => return b"R_PPC_UADDR32\0" as *const u8 as *const libc::c_char,
        25 => return b"R_PPC_UADDR16\0" as *const u8 as *const libc::c_char,
        26 => return b"R_PPC_REL32\0" as *const u8 as *const libc::c_char,
        27 => return b"R_PPC_PLT32\0" as *const u8 as *const libc::c_char,
        28 => return b"R_PPC_PLTREL32\0" as *const u8 as *const libc::c_char,
        29 => return b"R_PPC_PLT16_LO\0" as *const u8 as *const libc::c_char,
        30 => return b"R_PPC_PLT16_HI\0" as *const u8 as *const libc::c_char,
        31 => return b"R_PPC_PLT16_HA\0" as *const u8 as *const libc::c_char,
        32 => return b"R_PPC_SDAREL16\0" as *const u8 as *const libc::c_char,
        33 => return b"R_PPC_SECTOFF\0" as *const u8 as *const libc::c_char,
        34 => return b"R_PPC_SECTOFF_LO\0" as *const u8 as *const libc::c_char,
        35 => return b"R_PPC_SECTOFF_HI\0" as *const u8 as *const libc::c_char,
        36 => return b"R_PPC_SECTOFF_HA\0" as *const u8 as *const libc::c_char,
        37 => return b"R_PPC_ADDR30\0" as *const u8 as *const libc::c_char,
        67 => return b"R_PPC_TLS\0" as *const u8 as *const libc::c_char,
        68 => return b"R_PPC_DTPMOD32\0" as *const u8 as *const libc::c_char,
        69 => return b"R_PPC_TPREL16\0" as *const u8 as *const libc::c_char,
        70 => return b"R_PPC_TPREL16_LO\0" as *const u8 as *const libc::c_char,
        71 => return b"R_PPC_TPREL16_HI\0" as *const u8 as *const libc::c_char,
        72 => return b"R_PPC_TPREL16_HA\0" as *const u8 as *const libc::c_char,
        73 => return b"R_PPC_TPREL32\0" as *const u8 as *const libc::c_char,
        74 => return b"R_PPC_DTPREL16\0" as *const u8 as *const libc::c_char,
        75 => return b"R_PPC_DTPREL16_LO\0" as *const u8 as *const libc::c_char,
        76 => return b"R_PPC_DTPREL16_HI\0" as *const u8 as *const libc::c_char,
        77 => return b"R_PPC_DTPREL16_HA\0" as *const u8 as *const libc::c_char,
        78 => return b"R_PPC_DTPREL32\0" as *const u8 as *const libc::c_char,
        79 => return b"R_PPC_GOT_TLSGD16\0" as *const u8 as *const libc::c_char,
        80 => return b"R_PPC_GOT_TLSGD16_LO\0" as *const u8 as *const libc::c_char,
        81 => return b"R_PPC_GOT_TLSGD16_HI\0" as *const u8 as *const libc::c_char,
        82 => return b"R_PPC_GOT_TLSGD16_HA\0" as *const u8 as *const libc::c_char,
        83 => return b"R_PPC_GOT_TLSLD16\0" as *const u8 as *const libc::c_char,
        84 => return b"R_PPC_GOT_TLSLD16_LO\0" as *const u8 as *const libc::c_char,
        85 => return b"R_PPC_GOT_TLSLD16_HI\0" as *const u8 as *const libc::c_char,
        86 => return b"R_PPC_GOT_TLSLD16_HA\0" as *const u8 as *const libc::c_char,
        87 => return b"R_PPC_GOT_TPREL16\0" as *const u8 as *const libc::c_char,
        88 => return b"R_PPC_GOT_TPREL16_LO\0" as *const u8 as *const libc::c_char,
        89 => return b"R_PPC_GOT_TPREL16_HI\0" as *const u8 as *const libc::c_char,
        90 => return b"R_PPC_GOT_TPREL16_HA\0" as *const u8 as *const libc::c_char,
        91 => return b"R_PPC_GOT_DTPREL16\0" as *const u8 as *const libc::c_char,
        92 => return b"R_PPC_GOT_DTPREL16_LO\0" as *const u8 as *const libc::c_char,
        93 => return b"R_PPC_GOT_DTPREL16_HI\0" as *const u8 as *const libc::c_char,
        94 => return b"R_PPC_GOT_DTPREL16_HA\0" as *const u8 as *const libc::c_char,
        95 => return b"R_PPC_TLSGD\0" as *const u8 as *const libc::c_char,
        96 => return b"R_PPC_TLSLD\0" as *const u8 as *const libc::c_char,
        101 => return b"R_PPC_EMB_NADDR32\0" as *const u8 as *const libc::c_char,
        102 => return b"R_PPC_EMB_NADDR16\0" as *const u8 as *const libc::c_char,
        103 => return b"R_PPC_EMB_NADDR16_LO\0" as *const u8 as *const libc::c_char,
        104 => return b"R_PPC_EMB_NADDR16_HI\0" as *const u8 as *const libc::c_char,
        105 => return b"R_PPC_EMB_NADDR16_HA\0" as *const u8 as *const libc::c_char,
        106 => return b"R_PPC_EMB_SDAI16\0" as *const u8 as *const libc::c_char,
        107 => return b"R_PPC_EMB_SDA2I16\0" as *const u8 as *const libc::c_char,
        108 => return b"R_PPC_EMB_SDA2REL\0" as *const u8 as *const libc::c_char,
        109 => return b"R_PPC_EMB_SDA21\0" as *const u8 as *const libc::c_char,
        110 => return b"R_PPC_EMB_MRKREF\0" as *const u8 as *const libc::c_char,
        111 => return b"R_PPC_EMB_RELSEC16\0" as *const u8 as *const libc::c_char,
        112 => return b"R_PPC_EMB_RELST_LO\0" as *const u8 as *const libc::c_char,
        113 => return b"R_PPC_EMB_RELST_HI\0" as *const u8 as *const libc::c_char,
        114 => return b"R_PPC_EMB_RELST_HA\0" as *const u8 as *const libc::c_char,
        115 => return b"R_PPC_EMB_BIT_FLD\0" as *const u8 as *const libc::c_char,
        116 => return b"R_PPC_EMB_RELSDA\0" as *const u8 as *const libc::c_char,
        119 => return b"R_PPC_PLTSEQ\0" as *const u8 as *const libc::c_char,
        120 => return b"R_PPC_PLTCALL\0" as *const u8 as *const libc::c_char,
        216 => return b"R_PPC_VLE_REL8\0" as *const u8 as *const libc::c_char,
        217 => return b"R_PPC_VLE_REL15\0" as *const u8 as *const libc::c_char,
        218 => return b"R_PPC_VLE_REL24\0" as *const u8 as *const libc::c_char,
        219 => return b"R_PPC_VLE_LO16A\0" as *const u8 as *const libc::c_char,
        220 => return b"R_PPC_VLE_LO16D\0" as *const u8 as *const libc::c_char,
        221 => return b"R_PPC_VLE_HI16A\0" as *const u8 as *const libc::c_char,
        222 => return b"R_PPC_VLE_HI16D\0" as *const u8 as *const libc::c_char,
        223 => return b"R_PPC_VLE_HA16A\0" as *const u8 as *const libc::c_char,
        224 => return b"R_PPC_VLE_HA16D\0" as *const u8 as *const libc::c_char,
        225 => return b"R_PPC_VLE_SDA21\0" as *const u8 as *const libc::c_char,
        226 => return b"R_PPC_VLE_SDA21_LO\0" as *const u8 as *const libc::c_char,
        227 => return b"R_PPC_VLE_SDAREL_LO16A\0" as *const u8 as *const libc::c_char,
        228 => return b"R_PPC_VLE_SDAREL_LO16D\0" as *const u8 as *const libc::c_char,
        229 => return b"R_PPC_VLE_SDAREL_HI16A\0" as *const u8 as *const libc::c_char,
        230 => return b"R_PPC_VLE_SDAREL_HI16D\0" as *const u8 as *const libc::c_char,
        231 => return b"R_PPC_VLE_SDAREL_HA16A\0" as *const u8 as *const libc::c_char,
        232 => return b"R_PPC_VLE_SDAREL_HA16D\0" as *const u8 as *const libc::c_char,
        233 => return b"R_PPC_VLE_ADDR20\0" as *const u8 as *const libc::c_char,
        246 => return b"R_PPC_REL16DX_HA\0" as *const u8 as *const libc::c_char,
        248 => return b"R_PPC_IRELATIVE\0" as *const u8 as *const libc::c_char,
        249 => return b"R_PPC_REL16\0" as *const u8 as *const libc::c_char,
        250 => return b"R_PPC_REL16_LO\0" as *const u8 as *const libc::c_char,
        251 => return b"R_PPC_REL16_HI\0" as *const u8 as *const libc::c_char,
        252 => return b"R_PPC_REL16_HA\0" as *const u8 as *const libc::c_char,
        253 => return b"R_PPC_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        254 => return b"R_PPC_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        255 => return b"R_PPC_TOC16\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_ppc64_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_PPC64_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_PPC64_ADDR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_PPC64_ADDR24\0" as *const u8 as *const libc::c_char,
        3 => return b"R_PPC64_ADDR16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_PPC64_ADDR16_LO\0" as *const u8 as *const libc::c_char,
        5 => return b"R_PPC64_ADDR16_HI\0" as *const u8 as *const libc::c_char,
        6 => return b"R_PPC64_ADDR16_HA\0" as *const u8 as *const libc::c_char,
        7 => return b"R_PPC64_ADDR14\0" as *const u8 as *const libc::c_char,
        8 => return b"R_PPC64_ADDR14_BRTAKEN\0" as *const u8 as *const libc::c_char,
        9 => return b"R_PPC64_ADDR14_BRNTAKEN\0" as *const u8 as *const libc::c_char,
        10 => return b"R_PPC64_REL24\0" as *const u8 as *const libc::c_char,
        11 => return b"R_PPC64_REL14\0" as *const u8 as *const libc::c_char,
        12 => return b"R_PPC64_REL14_BRTAKEN\0" as *const u8 as *const libc::c_char,
        13 => return b"R_PPC64_REL14_BRNTAKEN\0" as *const u8 as *const libc::c_char,
        14 => return b"R_PPC64_GOT16\0" as *const u8 as *const libc::c_char,
        15 => return b"R_PPC64_GOT16_LO\0" as *const u8 as *const libc::c_char,
        16 => return b"R_PPC64_GOT16_HI\0" as *const u8 as *const libc::c_char,
        17 => return b"R_PPC64_GOT16_HA\0" as *const u8 as *const libc::c_char,
        19 => return b"R_PPC64_COPY\0" as *const u8 as *const libc::c_char,
        20 => return b"R_PPC64_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        21 => return b"R_PPC64_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        22 => return b"R_PPC64_RELATIVE\0" as *const u8 as *const libc::c_char,
        24 => return b"R_PPC64_UADDR32\0" as *const u8 as *const libc::c_char,
        25 => return b"R_PPC64_UADDR16\0" as *const u8 as *const libc::c_char,
        26 => return b"R_PPC64_REL32\0" as *const u8 as *const libc::c_char,
        27 => return b"R_PPC64_PLT32\0" as *const u8 as *const libc::c_char,
        28 => return b"R_PPC64_PLTREL32\0" as *const u8 as *const libc::c_char,
        29 => return b"R_PPC64_PLT16_LO\0" as *const u8 as *const libc::c_char,
        30 => return b"R_PPC64_PLT16_HI\0" as *const u8 as *const libc::c_char,
        31 => return b"R_PPC64_PLT16_HA\0" as *const u8 as *const libc::c_char,
        33 => return b"R_PPC64_SECTOFF\0" as *const u8 as *const libc::c_char,
        34 => return b"R_PPC64_SECTOFF_LO\0" as *const u8 as *const libc::c_char,
        35 => return b"R_PPC64_SECTOFF_HI\0" as *const u8 as *const libc::c_char,
        36 => return b"R_PPC64_SECTOFF_HA\0" as *const u8 as *const libc::c_char,
        37 => return b"R_PPC64_REL30\0" as *const u8 as *const libc::c_char,
        38 => return b"R_PPC64_ADDR64\0" as *const u8 as *const libc::c_char,
        39 => return b"R_PPC64_ADDR16_HIGHER\0" as *const u8 as *const libc::c_char,
        40 => return b"R_PPC64_ADDR16_HIGHERA\0" as *const u8 as *const libc::c_char,
        41 => return b"R_PPC64_ADDR16_HIGHEST\0" as *const u8 as *const libc::c_char,
        42 => return b"R_PPC64_ADDR16_HIGHESTA\0" as *const u8 as *const libc::c_char,
        43 => return b"R_PPC64_UADDR64\0" as *const u8 as *const libc::c_char,
        44 => return b"R_PPC64_REL64\0" as *const u8 as *const libc::c_char,
        45 => return b"R_PPC64_PLT64\0" as *const u8 as *const libc::c_char,
        46 => return b"R_PPC64_PLTREL64\0" as *const u8 as *const libc::c_char,
        47 => return b"R_PPC64_TOC16\0" as *const u8 as *const libc::c_char,
        48 => return b"R_PPC64_TOC16_LO\0" as *const u8 as *const libc::c_char,
        49 => return b"R_PPC64_TOC16_HI\0" as *const u8 as *const libc::c_char,
        50 => return b"R_PPC64_TOC16_HA\0" as *const u8 as *const libc::c_char,
        51 => return b"R_PPC64_TOC\0" as *const u8 as *const libc::c_char,
        52 => return b"R_PPC64_PLTGOT16\0" as *const u8 as *const libc::c_char,
        53 => return b"R_PPC64_PLTGOT16_LO\0" as *const u8 as *const libc::c_char,
        54 => return b"R_PPC64_PLTGOT16_HI\0" as *const u8 as *const libc::c_char,
        55 => return b"R_PPC64_PLTGOT16_HA\0" as *const u8 as *const libc::c_char,
        56 => return b"R_PPC64_ADDR16_DS\0" as *const u8 as *const libc::c_char,
        57 => return b"R_PPC64_ADDR16_LO_DS\0" as *const u8 as *const libc::c_char,
        58 => return b"R_PPC64_GOT16_DS\0" as *const u8 as *const libc::c_char,
        59 => return b"R_PPC64_GOT16_LO_DS\0" as *const u8 as *const libc::c_char,
        60 => return b"R_PPC64_PLT16_LO_DS\0" as *const u8 as *const libc::c_char,
        61 => return b"R_PPC64_SECTOFF_DS\0" as *const u8 as *const libc::c_char,
        62 => return b"R_PPC64_SECTOFF_LO_DS\0" as *const u8 as *const libc::c_char,
        63 => return b"R_PPC64_TOC16_DS\0" as *const u8 as *const libc::c_char,
        64 => return b"R_PPC64_TOC16_LO_DS\0" as *const u8 as *const libc::c_char,
        65 => return b"R_PPC64_PLTGOT16_DS\0" as *const u8 as *const libc::c_char,
        66 => return b"R_PPC64_PLTGOT16_LO_DS\0" as *const u8 as *const libc::c_char,
        67 => return b"R_PPC64_TLS\0" as *const u8 as *const libc::c_char,
        68 => return b"R_PPC64_DTPMOD64\0" as *const u8 as *const libc::c_char,
        69 => return b"R_PPC64_TPREL16\0" as *const u8 as *const libc::c_char,
        70 => return b"R_PPC64_TPREL16_LO\0" as *const u8 as *const libc::c_char,
        71 => return b"R_PPC64_TPREL16_HI\0" as *const u8 as *const libc::c_char,
        72 => return b"R_PPC64_TPREL16_HA\0" as *const u8 as *const libc::c_char,
        73 => return b"R_PPC64_TPREL64\0" as *const u8 as *const libc::c_char,
        74 => return b"R_PPC64_DTPREL16\0" as *const u8 as *const libc::c_char,
        75 => return b"R_PPC64_DTPREL16_LO\0" as *const u8 as *const libc::c_char,
        76 => return b"R_PPC64_DTPREL16_HI\0" as *const u8 as *const libc::c_char,
        77 => return b"R_PPC64_DTPREL16_HA\0" as *const u8 as *const libc::c_char,
        78 => return b"R_PPC64_DTPREL64\0" as *const u8 as *const libc::c_char,
        79 => return b"R_PPC64_GOT_TLSGD16\0" as *const u8 as *const libc::c_char,
        80 => return b"R_PPC64_GOT_TLSGD16_LO\0" as *const u8 as *const libc::c_char,
        81 => return b"R_PPC64_GOT_TLSGD16_HI\0" as *const u8 as *const libc::c_char,
        82 => return b"R_PPC64_GOT_TLSGD16_HA\0" as *const u8 as *const libc::c_char,
        83 => return b"R_PPC64_GOT_TLSLD16\0" as *const u8 as *const libc::c_char,
        84 => return b"R_PPC64_GOT_TLSLD16_LO\0" as *const u8 as *const libc::c_char,
        85 => return b"R_PPC64_GOT_TLSLD16_HI\0" as *const u8 as *const libc::c_char,
        86 => return b"R_PPC64_GOT_TLSLD16_HA\0" as *const u8 as *const libc::c_char,
        87 => return b"R_PPC64_GOT_TPREL16_DS\0" as *const u8 as *const libc::c_char,
        88 => return b"R_PPC64_GOT_TPREL16_LO_DS\0" as *const u8 as *const libc::c_char,
        89 => return b"R_PPC64_GOT_TPREL16_HI\0" as *const u8 as *const libc::c_char,
        90 => return b"R_PPC64_GOT_TPREL16_HA\0" as *const u8 as *const libc::c_char,
        91 => return b"R_PPC64_GOT_DTPREL16_DS\0" as *const u8 as *const libc::c_char,
        92 => return b"R_PPC64_GOT_DTPREL16_LO_DS\0" as *const u8 as *const libc::c_char,
        93 => return b"R_PPC64_GOT_DTPREL16_HI\0" as *const u8 as *const libc::c_char,
        94 => return b"R_PPC64_GOT_DTPREL16_HA\0" as *const u8 as *const libc::c_char,
        95 => return b"R_PPC64_TPREL16_DS\0" as *const u8 as *const libc::c_char,
        96 => return b"R_PPC64_TPREL16_LO_DS\0" as *const u8 as *const libc::c_char,
        97 => return b"R_PPC64_TPREL16_HIGHER\0" as *const u8 as *const libc::c_char,
        98 => return b"R_PPC64_TPREL16_HIGHERA\0" as *const u8 as *const libc::c_char,
        99 => return b"R_PPC64_TPREL16_HIGHEST\0" as *const u8 as *const libc::c_char,
        100 => return b"R_PPC64_TPREL16_HIGHESTA\0" as *const u8 as *const libc::c_char,
        101 => return b"R_PPC64_DTPREL16_DS\0" as *const u8 as *const libc::c_char,
        102 => return b"R_PPC64_DTPREL16_LO_DS\0" as *const u8 as *const libc::c_char,
        103 => return b"R_PPC64_DTPREL16_HIGHER\0" as *const u8 as *const libc::c_char,
        104 => return b"R_PPC64_DTPREL16_HIGHERA\0" as *const u8 as *const libc::c_char,
        105 => return b"R_PPC64_DTPREL16_HIGHEST\0" as *const u8 as *const libc::c_char,
        106 => return b"R_PPC64_DTPREL16_HIGHESTA\0" as *const u8 as *const libc::c_char,
        107 => return b"R_PPC64_TLSGD\0" as *const u8 as *const libc::c_char,
        108 => return b"R_PPC64_TLSLD\0" as *const u8 as *const libc::c_char,
        109 => return b"R_PPC64_TOCSAVE\0" as *const u8 as *const libc::c_char,
        110 => return b"R_PPC64_ADDR16_HIGH\0" as *const u8 as *const libc::c_char,
        111 => return b"R_PPC64_ADDR16_HIGHA\0" as *const u8 as *const libc::c_char,
        112 => return b"R_PPC64_TPREL16_HIGH\0" as *const u8 as *const libc::c_char,
        113 => return b"R_PPC64_TPREL16_HIGHA\0" as *const u8 as *const libc::c_char,
        114 => return b"R_PPC64_DTPREL16_HIGH\0" as *const u8 as *const libc::c_char,
        115 => return b"R_PPC64_DTPREL16_HIGHA\0" as *const u8 as *const libc::c_char,
        116 => return b"R_PPC64_REL24_NOTOC\0" as *const u8 as *const libc::c_char,
        117 => return b"R_PPC64_ADDR64_LOCAL\0" as *const u8 as *const libc::c_char,
        118 => return b"R_PPC64_ENTRY\0" as *const u8 as *const libc::c_char,
        119 => return b"R_PPC64_PLTSEQ\0" as *const u8 as *const libc::c_char,
        120 => return b"R_PPC64_PLTCALL\0" as *const u8 as *const libc::c_char,
        121 => return b"R_PPC64_PLTSEQ_NOTOC\0" as *const u8 as *const libc::c_char,
        122 => return b"R_PPC64_PLTCALL_NOTOC\0" as *const u8 as *const libc::c_char,
        123 => return b"R_PPC64_PCREL_OPT\0" as *const u8 as *const libc::c_char,
        128 => return b"R_PPC64_D34\0" as *const u8 as *const libc::c_char,
        129 => return b"R_PPC64_D34_LO\0" as *const u8 as *const libc::c_char,
        130 => return b"R_PPC64_D34_HI30\0" as *const u8 as *const libc::c_char,
        131 => return b"R_PPC64_D34_HA30\0" as *const u8 as *const libc::c_char,
        132 => return b"R_PPC64_PCREL34\0" as *const u8 as *const libc::c_char,
        133 => return b"R_PPC64_GOT_PCREL34\0" as *const u8 as *const libc::c_char,
        134 => return b"R_PPC64_PLT_PCREL34\0" as *const u8 as *const libc::c_char,
        135 => return b"R_PPC64_PLT_PCREL34_NOTOC\0" as *const u8 as *const libc::c_char,
        136 => return b"R_PPC64_ADDR16_HIGHER34\0" as *const u8 as *const libc::c_char,
        137 => return b"R_PPC64_ADDR16_HIGHERA34\0" as *const u8 as *const libc::c_char,
        138 => return b"R_PPC64_ADDR16_HIGHEST34\0" as *const u8 as *const libc::c_char,
        139 => return b"R_PPC64_ADDR16_HIGHESTA34\0" as *const u8 as *const libc::c_char,
        140 => return b"R_PPC64_REL16_HIGHER34\0" as *const u8 as *const libc::c_char,
        141 => return b"R_PPC64_REL16_HIGHERA34\0" as *const u8 as *const libc::c_char,
        142 => return b"R_PPC64_REL16_HIGHEST34\0" as *const u8 as *const libc::c_char,
        143 => return b"R_PPC64_REL16_HIGHESTA34\0" as *const u8 as *const libc::c_char,
        144 => return b"R_PPC64_D28\0" as *const u8 as *const libc::c_char,
        145 => return b"R_PPC64_PCREL28\0" as *const u8 as *const libc::c_char,
        146 => return b"R_PPC64_TPREL34\0" as *const u8 as *const libc::c_char,
        147 => return b"R_PPC64_DTPREL34\0" as *const u8 as *const libc::c_char,
        148 => return b"R_PPC64_GOT_TLSGD_PCREL34\0" as *const u8 as *const libc::c_char,
        149 => return b"R_PPC64_GOT_TLSLD_PCREL34\0" as *const u8 as *const libc::c_char,
        150 => return b"R_PPC64_GOT_TPREL_PCREL34\0" as *const u8 as *const libc::c_char,
        151 => return b"R_PPC64_GOT_DTPREL_PCREL34\0" as *const u8 as *const libc::c_char,
        240 => return b"R_PPC64_REL16_HIGH\0" as *const u8 as *const libc::c_char,
        241 => return b"R_PPC64_REL16_HIGHA\0" as *const u8 as *const libc::c_char,
        242 => return b"R_PPC64_REL16_HIGHER\0" as *const u8 as *const libc::c_char,
        243 => return b"R_PPC64_REL16_HIGHERA\0" as *const u8 as *const libc::c_char,
        244 => return b"R_PPC64_REL16_HIGHEST\0" as *const u8 as *const libc::c_char,
        245 => return b"R_PPC64_REL16_HIGHESTA\0" as *const u8 as *const libc::c_char,
        246 => return b"R_PPC64_REL16DX_HA\0" as *const u8 as *const libc::c_char,
        247 => return b"R_PPC64_JMP_IREL\0" as *const u8 as *const libc::c_char,
        248 => return b"R_PPC64_IRELATIVE\0" as *const u8 as *const libc::c_char,
        249 => return b"R_PPC64_REL16\0" as *const u8 as *const libc::c_char,
        250 => return b"R_PPC64_REL16_LO\0" as *const u8 as *const libc::c_char,
        251 => return b"R_PPC64_REL16_HI\0" as *const u8 as *const libc::c_char,
        252 => return b"R_PPC64_REL16_HA\0" as *const u8 as *const libc::c_char,
        253 => return b"R_PPC64_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        254 => return b"R_PPC64_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
#[inline]
unsafe extern "C" fn ppc64_decode_local_entry(mut other: libc::c_uint) -> libc::c_uint {
    return (((1 as libc::c_int) << other >> 2 as libc::c_int) << 2 as libc::c_int)
        as libc::c_uint;
}
unsafe extern "C" fn elf_pru_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_PRU_NONE\0" as *const u8 as *const libc::c_char,
        5 => return b"R_PRU_16_PMEM\0" as *const u8 as *const libc::c_char,
        6 => return b"R_PRU_U16_PMEMIMM\0" as *const u8 as *const libc::c_char,
        8 => return b"R_PRU_BFD_RELOC_16\0" as *const u8 as *const libc::c_char,
        9 => return b"R_PRU_U16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_PRU_32_PMEM\0" as *const u8 as *const libc::c_char,
        11 => return b"R_PRU_BFD_RELOC_32\0" as *const u8 as *const libc::c_char,
        14 => return b"R_PRU_S10_PCREL\0" as *const u8 as *const libc::c_char,
        15 => return b"R_PRU_U8_PCREL\0" as *const u8 as *const libc::c_char,
        18 => return b"R_PRU_LDI32\0" as *const u8 as *const libc::c_char,
        64 => return b"R_PRU_GNU_BFD_RELOC_8\0" as *const u8 as *const libc::c_char,
        65 => return b"R_PRU_GNU_DIFF8\0" as *const u8 as *const libc::c_char,
        66 => return b"R_PRU_GNU_DIFF16\0" as *const u8 as *const libc::c_char,
        67 => return b"R_PRU_GNU_DIFF32\0" as *const u8 as *const libc::c_char,
        68 => return b"R_PRU_GNU_DIFF16_PMEM\0" as *const u8 as *const libc::c_char,
        69 => return b"R_PRU_GNU_DIFF32_PMEM\0" as *const u8 as *const libc::c_char,
        70 => return b"R_PRU_ILLEGAL\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_riscv_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_RISCV_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_RISCV_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_RISCV_64\0" as *const u8 as *const libc::c_char,
        3 => return b"R_RISCV_RELATIVE\0" as *const u8 as *const libc::c_char,
        4 => return b"R_RISCV_COPY\0" as *const u8 as *const libc::c_char,
        5 => return b"R_RISCV_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        6 => return b"R_RISCV_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_RISCV_TLS_DTPMOD64\0" as *const u8 as *const libc::c_char,
        8 => return b"R_RISCV_TLS_DTPREL32\0" as *const u8 as *const libc::c_char,
        9 => return b"R_RISCV_TLS_DTPREL64\0" as *const u8 as *const libc::c_char,
        10 => return b"R_RISCV_TLS_TPREL32\0" as *const u8 as *const libc::c_char,
        11 => return b"R_RISCV_TLS_TPREL64\0" as *const u8 as *const libc::c_char,
        16 => return b"R_RISCV_BRANCH\0" as *const u8 as *const libc::c_char,
        17 => return b"R_RISCV_JAL\0" as *const u8 as *const libc::c_char,
        18 => return b"R_RISCV_CALL\0" as *const u8 as *const libc::c_char,
        19 => return b"R_RISCV_CALL_PLT\0" as *const u8 as *const libc::c_char,
        20 => return b"R_RISCV_GOT_HI20\0" as *const u8 as *const libc::c_char,
        21 => return b"R_RISCV_TLS_GOT_HI20\0" as *const u8 as *const libc::c_char,
        22 => return b"R_RISCV_TLS_GD_HI20\0" as *const u8 as *const libc::c_char,
        23 => return b"R_RISCV_PCREL_HI20\0" as *const u8 as *const libc::c_char,
        24 => return b"R_RISCV_PCREL_LO12_I\0" as *const u8 as *const libc::c_char,
        25 => return b"R_RISCV_PCREL_LO12_S\0" as *const u8 as *const libc::c_char,
        26 => return b"R_RISCV_HI20\0" as *const u8 as *const libc::c_char,
        27 => return b"R_RISCV_LO12_I\0" as *const u8 as *const libc::c_char,
        28 => return b"R_RISCV_LO12_S\0" as *const u8 as *const libc::c_char,
        29 => return b"R_RISCV_TPREL_HI20\0" as *const u8 as *const libc::c_char,
        30 => return b"R_RISCV_TPREL_LO12_I\0" as *const u8 as *const libc::c_char,
        31 => return b"R_RISCV_TPREL_LO12_S\0" as *const u8 as *const libc::c_char,
        32 => return b"R_RISCV_TPREL_ADD\0" as *const u8 as *const libc::c_char,
        33 => return b"R_RISCV_ADD8\0" as *const u8 as *const libc::c_char,
        34 => return b"R_RISCV_ADD16\0" as *const u8 as *const libc::c_char,
        35 => return b"R_RISCV_ADD32\0" as *const u8 as *const libc::c_char,
        36 => return b"R_RISCV_ADD64\0" as *const u8 as *const libc::c_char,
        37 => return b"R_RISCV_SUB8\0" as *const u8 as *const libc::c_char,
        38 => return b"R_RISCV_SUB16\0" as *const u8 as *const libc::c_char,
        39 => return b"R_RISCV_SUB32\0" as *const u8 as *const libc::c_char,
        40 => return b"R_RISCV_SUB64\0" as *const u8 as *const libc::c_char,
        41 => return b"R_RISCV_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        42 => return b"R_RISCV_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        43 => return b"R_RISCV_ALIGN\0" as *const u8 as *const libc::c_char,
        44 => return b"R_RISCV_RVC_BRANCH\0" as *const u8 as *const libc::c_char,
        45 => return b"R_RISCV_RVC_JUMP\0" as *const u8 as *const libc::c_char,
        46 => return b"R_RISCV_RVC_LUI\0" as *const u8 as *const libc::c_char,
        47 => return b"R_RISCV_GPREL_I\0" as *const u8 as *const libc::c_char,
        48 => return b"R_RISCV_GPREL_S\0" as *const u8 as *const libc::c_char,
        49 => return b"R_RISCV_TPREL_I\0" as *const u8 as *const libc::c_char,
        50 => return b"R_RISCV_TPREL_S\0" as *const u8 as *const libc::c_char,
        51 => return b"R_RISCV_RELAX\0" as *const u8 as *const libc::c_char,
        52 => return b"R_RISCV_SUB6\0" as *const u8 as *const libc::c_char,
        53 => return b"R_RISCV_SET6\0" as *const u8 as *const libc::c_char,
        54 => return b"R_RISCV_SET8\0" as *const u8 as *const libc::c_char,
        55 => return b"R_RISCV_SET16\0" as *const u8 as *const libc::c_char,
        56 => return b"R_RISCV_SET32\0" as *const u8 as *const libc::c_char,
        57 => return b"R_RISCV_32_PCREL\0" as *const u8 as *const libc::c_char,
        58 => return b"R_RISCV_IRELATIVE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_rl78_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_RL78_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_RL78_DIR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_RL78_DIR24S\0" as *const u8 as *const libc::c_char,
        3 => return b"R_RL78_DIR16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_RL78_DIR16U\0" as *const u8 as *const libc::c_char,
        5 => return b"R_RL78_DIR16S\0" as *const u8 as *const libc::c_char,
        6 => return b"R_RL78_DIR8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_RL78_DIR8U\0" as *const u8 as *const libc::c_char,
        8 => return b"R_RL78_DIR8S\0" as *const u8 as *const libc::c_char,
        9 => return b"R_RL78_DIR24S_PCREL\0" as *const u8 as *const libc::c_char,
        10 => return b"R_RL78_DIR16S_PCREL\0" as *const u8 as *const libc::c_char,
        11 => return b"R_RL78_DIR8S_PCREL\0" as *const u8 as *const libc::c_char,
        12 => return b"R_RL78_DIR16UL\0" as *const u8 as *const libc::c_char,
        13 => return b"R_RL78_DIR16UW\0" as *const u8 as *const libc::c_char,
        14 => return b"R_RL78_DIR8UL\0" as *const u8 as *const libc::c_char,
        15 => return b"R_RL78_DIR8UW\0" as *const u8 as *const libc::c_char,
        16 => return b"R_RL78_DIR32_REV\0" as *const u8 as *const libc::c_char,
        17 => return b"R_RL78_DIR16_REV\0" as *const u8 as *const libc::c_char,
        18 => return b"R_RL78_DIR3U_PCREL\0" as *const u8 as *const libc::c_char,
        45 => return b"R_RL78_RH_RELAX\0" as *const u8 as *const libc::c_char,
        46 => return b"R_RL78_RH_SFR\0" as *const u8 as *const libc::c_char,
        47 => return b"R_RL78_RH_SADDR\0" as *const u8 as *const libc::c_char,
        65 => return b"R_RL78_ABS32\0" as *const u8 as *const libc::c_char,
        66 => return b"R_RL78_ABS24S\0" as *const u8 as *const libc::c_char,
        67 => return b"R_RL78_ABS16\0" as *const u8 as *const libc::c_char,
        68 => return b"R_RL78_ABS16U\0" as *const u8 as *const libc::c_char,
        69 => return b"R_RL78_ABS16S\0" as *const u8 as *const libc::c_char,
        70 => return b"R_RL78_ABS8\0" as *const u8 as *const libc::c_char,
        71 => return b"R_RL78_ABS8U\0" as *const u8 as *const libc::c_char,
        72 => return b"R_RL78_ABS8S\0" as *const u8 as *const libc::c_char,
        73 => return b"R_RL78_ABS24S_PCREL\0" as *const u8 as *const libc::c_char,
        74 => return b"R_RL78_ABS16S_PCREL\0" as *const u8 as *const libc::c_char,
        75 => return b"R_RL78_ABS8S_PCREL\0" as *const u8 as *const libc::c_char,
        76 => return b"R_RL78_ABS16UL\0" as *const u8 as *const libc::c_char,
        77 => return b"R_RL78_ABS16UW\0" as *const u8 as *const libc::c_char,
        78 => return b"R_RL78_ABS8UL\0" as *const u8 as *const libc::c_char,
        79 => return b"R_RL78_ABS8UW\0" as *const u8 as *const libc::c_char,
        80 => return b"R_RL78_ABS32_REV\0" as *const u8 as *const libc::c_char,
        81 => return b"R_RL78_ABS16_REV\0" as *const u8 as *const libc::c_char,
        128 => return b"R_RL78_SYM\0" as *const u8 as *const libc::c_char,
        129 => return b"R_RL78_OPneg\0" as *const u8 as *const libc::c_char,
        130 => return b"R_RL78_OPadd\0" as *const u8 as *const libc::c_char,
        131 => return b"R_RL78_OPsub\0" as *const u8 as *const libc::c_char,
        132 => return b"R_RL78_OPmul\0" as *const u8 as *const libc::c_char,
        133 => return b"R_RL78_OPdiv\0" as *const u8 as *const libc::c_char,
        134 => return b"R_RL78_OPshla\0" as *const u8 as *const libc::c_char,
        135 => return b"R_RL78_OPshra\0" as *const u8 as *const libc::c_char,
        136 => return b"R_RL78_OPsctsize\0" as *const u8 as *const libc::c_char,
        141 => return b"R_RL78_OPscttop\0" as *const u8 as *const libc::c_char,
        144 => return b"R_RL78_OPand\0" as *const u8 as *const libc::c_char,
        145 => return b"R_RL78_OPor\0" as *const u8 as *const libc::c_char,
        146 => return b"R_RL78_OPxor\0" as *const u8 as *const libc::c_char,
        147 => return b"R_RL78_OPnot\0" as *const u8 as *const libc::c_char,
        148 => return b"R_RL78_OPmod\0" as *const u8 as *const libc::c_char,
        149 => return b"R_RL78_OPromtop\0" as *const u8 as *const libc::c_char,
        150 => return b"R_RL78_OPramtop\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_rx_reloc_type(mut rtype: libc::c_ulong) -> *const libc::c_char {
    match rtype {
        0 => return b"R_RX_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_RX_DIR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_RX_DIR24S\0" as *const u8 as *const libc::c_char,
        3 => return b"R_RX_DIR16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_RX_DIR16U\0" as *const u8 as *const libc::c_char,
        5 => return b"R_RX_DIR16S\0" as *const u8 as *const libc::c_char,
        6 => return b"R_RX_DIR8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_RX_DIR8U\0" as *const u8 as *const libc::c_char,
        8 => return b"R_RX_DIR8S\0" as *const u8 as *const libc::c_char,
        9 => return b"R_RX_DIR24S_PCREL\0" as *const u8 as *const libc::c_char,
        10 => return b"R_RX_DIR16S_PCREL\0" as *const u8 as *const libc::c_char,
        11 => return b"R_RX_DIR8S_PCREL\0" as *const u8 as *const libc::c_char,
        12 => return b"R_RX_DIR16UL\0" as *const u8 as *const libc::c_char,
        13 => return b"R_RX_DIR16UW\0" as *const u8 as *const libc::c_char,
        14 => return b"R_RX_DIR8UL\0" as *const u8 as *const libc::c_char,
        15 => return b"R_RX_DIR8UW\0" as *const u8 as *const libc::c_char,
        16 => return b"R_RX_DIR32_REV\0" as *const u8 as *const libc::c_char,
        17 => return b"R_RX_DIR16_REV\0" as *const u8 as *const libc::c_char,
        18 => return b"R_RX_DIR3U_PCREL\0" as *const u8 as *const libc::c_char,
        32 => return b"R_RX_RH_3_PCREL\0" as *const u8 as *const libc::c_char,
        33 => return b"R_RX_RH_16_OP\0" as *const u8 as *const libc::c_char,
        34 => return b"R_RX_RH_24_OP\0" as *const u8 as *const libc::c_char,
        35 => return b"R_RX_RH_32_OP\0" as *const u8 as *const libc::c_char,
        36 => return b"R_RX_RH_24_UNS\0" as *const u8 as *const libc::c_char,
        37 => return b"R_RX_RH_8_NEG\0" as *const u8 as *const libc::c_char,
        38 => return b"R_RX_RH_16_NEG\0" as *const u8 as *const libc::c_char,
        39 => return b"R_RX_RH_24_NEG\0" as *const u8 as *const libc::c_char,
        40 => return b"R_RX_RH_32_NEG\0" as *const u8 as *const libc::c_char,
        41 => return b"R_RX_RH_DIFF\0" as *const u8 as *const libc::c_char,
        42 => return b"R_RX_RH_GPRELB\0" as *const u8 as *const libc::c_char,
        43 => return b"R_RX_RH_GPRELW\0" as *const u8 as *const libc::c_char,
        44 => return b"R_RX_RH_GPRELL\0" as *const u8 as *const libc::c_char,
        45 => return b"R_RX_RH_RELAX\0" as *const u8 as *const libc::c_char,
        65 => return b"R_RX_ABS32\0" as *const u8 as *const libc::c_char,
        66 => return b"R_RX_ABS24S\0" as *const u8 as *const libc::c_char,
        67 => return b"R_RX_ABS16\0" as *const u8 as *const libc::c_char,
        68 => return b"R_RX_ABS16U\0" as *const u8 as *const libc::c_char,
        69 => return b"R_RX_ABS16S\0" as *const u8 as *const libc::c_char,
        70 => return b"R_RX_ABS8\0" as *const u8 as *const libc::c_char,
        71 => return b"R_RX_ABS8U\0" as *const u8 as *const libc::c_char,
        72 => return b"R_RX_ABS8S\0" as *const u8 as *const libc::c_char,
        73 => return b"R_RX_ABS24S_PCREL\0" as *const u8 as *const libc::c_char,
        74 => return b"R_RX_ABS16S_PCREL\0" as *const u8 as *const libc::c_char,
        75 => return b"R_RX_ABS8S_PCREL\0" as *const u8 as *const libc::c_char,
        76 => return b"R_RX_ABS16UL\0" as *const u8 as *const libc::c_char,
        77 => return b"R_RX_ABS16UW\0" as *const u8 as *const libc::c_char,
        78 => return b"R_RX_ABS8UL\0" as *const u8 as *const libc::c_char,
        79 => return b"R_RX_ABS8UW\0" as *const u8 as *const libc::c_char,
        80 => return b"R_RX_ABS32_REV\0" as *const u8 as *const libc::c_char,
        81 => return b"R_RX_ABS16_REV\0" as *const u8 as *const libc::c_char,
        128 => return b"R_RX_SYM\0" as *const u8 as *const libc::c_char,
        129 => return b"R_RX_OPneg\0" as *const u8 as *const libc::c_char,
        130 => return b"R_RX_OPadd\0" as *const u8 as *const libc::c_char,
        131 => return b"R_RX_OPsub\0" as *const u8 as *const libc::c_char,
        132 => return b"R_RX_OPmul\0" as *const u8 as *const libc::c_char,
        133 => return b"R_RX_OPdiv\0" as *const u8 as *const libc::c_char,
        134 => return b"R_RX_OPshla\0" as *const u8 as *const libc::c_char,
        135 => return b"R_RX_OPshra\0" as *const u8 as *const libc::c_char,
        136 => return b"R_RX_OPsctsize\0" as *const u8 as *const libc::c_char,
        141 => return b"R_RX_OPscttop\0" as *const u8 as *const libc::c_char,
        144 => return b"R_RX_OPand\0" as *const u8 as *const libc::c_char,
        145 => return b"R_RX_OPor\0" as *const u8 as *const libc::c_char,
        146 => return b"R_RX_OPxor\0" as *const u8 as *const libc::c_char,
        147 => return b"R_RX_OPnot\0" as *const u8 as *const libc::c_char,
        148 => return b"R_RX_OPmod\0" as *const u8 as *const libc::c_char,
        149 => return b"R_RX_OPromtop\0" as *const u8 as *const libc::c_char,
        150 => return b"R_RX_OPramtop\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_s390_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_390_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_390_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_390_12\0" as *const u8 as *const libc::c_char,
        3 => return b"R_390_16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_390_32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_390_PC32\0" as *const u8 as *const libc::c_char,
        6 => return b"R_390_GOT12\0" as *const u8 as *const libc::c_char,
        7 => return b"R_390_GOT32\0" as *const u8 as *const libc::c_char,
        8 => return b"R_390_PLT32\0" as *const u8 as *const libc::c_char,
        9 => return b"R_390_COPY\0" as *const u8 as *const libc::c_char,
        10 => return b"R_390_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        11 => return b"R_390_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_390_RELATIVE\0" as *const u8 as *const libc::c_char,
        13 => return b"R_390_GOTOFF32\0" as *const u8 as *const libc::c_char,
        14 => return b"R_390_GOTPC\0" as *const u8 as *const libc::c_char,
        15 => return b"R_390_GOT16\0" as *const u8 as *const libc::c_char,
        16 => return b"R_390_PC16\0" as *const u8 as *const libc::c_char,
        62 => return b"R_390_PC12DBL\0" as *const u8 as *const libc::c_char,
        63 => return b"R_390_PLT12DBL\0" as *const u8 as *const libc::c_char,
        17 => return b"R_390_PC16DBL\0" as *const u8 as *const libc::c_char,
        18 => return b"R_390_PLT16DBL\0" as *const u8 as *const libc::c_char,
        64 => return b"R_390_PC24DBL\0" as *const u8 as *const libc::c_char,
        65 => return b"R_390_PLT24DBL\0" as *const u8 as *const libc::c_char,
        19 => return b"R_390_PC32DBL\0" as *const u8 as *const libc::c_char,
        20 => return b"R_390_PLT32DBL\0" as *const u8 as *const libc::c_char,
        21 => return b"R_390_GOTPCDBL\0" as *const u8 as *const libc::c_char,
        22 => return b"R_390_64\0" as *const u8 as *const libc::c_char,
        23 => return b"R_390_PC64\0" as *const u8 as *const libc::c_char,
        24 => return b"R_390_GOT64\0" as *const u8 as *const libc::c_char,
        25 => return b"R_390_PLT64\0" as *const u8 as *const libc::c_char,
        26 => return b"R_390_GOTENT\0" as *const u8 as *const libc::c_char,
        27 => return b"R_390_GOTOFF16\0" as *const u8 as *const libc::c_char,
        28 => return b"R_390_GOTOFF64\0" as *const u8 as *const libc::c_char,
        29 => return b"R_390_GOTPLT12\0" as *const u8 as *const libc::c_char,
        30 => return b"R_390_GOTPLT16\0" as *const u8 as *const libc::c_char,
        31 => return b"R_390_GOTPLT32\0" as *const u8 as *const libc::c_char,
        32 => return b"R_390_GOTPLT64\0" as *const u8 as *const libc::c_char,
        33 => return b"R_390_GOTPLTENT\0" as *const u8 as *const libc::c_char,
        34 => return b"R_390_PLTOFF16\0" as *const u8 as *const libc::c_char,
        35 => return b"R_390_PLTOFF32\0" as *const u8 as *const libc::c_char,
        36 => return b"R_390_PLTOFF64\0" as *const u8 as *const libc::c_char,
        37 => return b"R_390_TLS_LOAD\0" as *const u8 as *const libc::c_char,
        38 => return b"R_390_TLS_GDCALL\0" as *const u8 as *const libc::c_char,
        39 => return b"R_390_TLS_LDCALL\0" as *const u8 as *const libc::c_char,
        40 => return b"R_390_TLS_GD32\0" as *const u8 as *const libc::c_char,
        41 => return b"R_390_TLS_GD64\0" as *const u8 as *const libc::c_char,
        42 => return b"R_390_TLS_GOTIE12\0" as *const u8 as *const libc::c_char,
        43 => return b"R_390_TLS_GOTIE32\0" as *const u8 as *const libc::c_char,
        44 => return b"R_390_TLS_GOTIE64\0" as *const u8 as *const libc::c_char,
        45 => return b"R_390_TLS_LDM32\0" as *const u8 as *const libc::c_char,
        46 => return b"R_390_TLS_LDM64\0" as *const u8 as *const libc::c_char,
        47 => return b"R_390_TLS_IE32\0" as *const u8 as *const libc::c_char,
        48 => return b"R_390_TLS_IE64\0" as *const u8 as *const libc::c_char,
        49 => return b"R_390_TLS_IEENT\0" as *const u8 as *const libc::c_char,
        50 => return b"R_390_TLS_LE32\0" as *const u8 as *const libc::c_char,
        51 => return b"R_390_TLS_LE64\0" as *const u8 as *const libc::c_char,
        52 => return b"R_390_TLS_LDO32\0" as *const u8 as *const libc::c_char,
        53 => return b"R_390_TLS_LDO64\0" as *const u8 as *const libc::c_char,
        54 => return b"R_390_TLS_DTPMOD\0" as *const u8 as *const libc::c_char,
        55 => return b"R_390_TLS_DTPOFF\0" as *const u8 as *const libc::c_char,
        56 => return b"R_390_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
        57 => return b"R_390_20\0" as *const u8 as *const libc::c_char,
        58 => return b"R_390_GOT20\0" as *const u8 as *const libc::c_char,
        59 => return b"R_390_GOTPLT20\0" as *const u8 as *const libc::c_char,
        60 => return b"R_390_TLS_GOTIE20\0" as *const u8 as *const libc::c_char,
        61 => return b"R_390_IRELATIVE\0" as *const u8 as *const libc::c_char,
        250 => return b"R_390_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        251 => return b"R_390_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_score_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_SCORE_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_SCORE_HI16\0" as *const u8 as *const libc::c_char,
        2 => return b"R_SCORE_LO16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_SCORE_BCMP\0" as *const u8 as *const libc::c_char,
        4 => return b"R_SCORE_24\0" as *const u8 as *const libc::c_char,
        5 => return b"R_SCORE_PC19\0" as *const u8 as *const libc::c_char,
        6 => return b"R_SCORE16_11\0" as *const u8 as *const libc::c_char,
        7 => return b"R_SCORE16_PC8\0" as *const u8 as *const libc::c_char,
        8 => return b"R_SCORE_ABS32\0" as *const u8 as *const libc::c_char,
        9 => return b"R_SCORE_ABS16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_SCORE_DUMMY2\0" as *const u8 as *const libc::c_char,
        11 => return b"R_SCORE_GP15\0" as *const u8 as *const libc::c_char,
        12 => return b"R_SCORE_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        13 => return b"R_SCORE_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        14 => return b"R_SCORE_GOT15\0" as *const u8 as *const libc::c_char,
        15 => return b"R_SCORE_GOT_LO16\0" as *const u8 as *const libc::c_char,
        16 => return b"R_SCORE_CALL15\0" as *const u8 as *const libc::c_char,
        17 => return b"R_SCORE_GPREL32\0" as *const u8 as *const libc::c_char,
        18 => return b"R_SCORE_REL32\0" as *const u8 as *const libc::c_char,
        19 => return b"R_SCORE_DUMMY_HI16\0" as *const u8 as *const libc::c_char,
        20 => return b"R_SCORE_IMM30\0" as *const u8 as *const libc::c_char,
        21 => return b"R_SCORE_IMM32\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_sh_reloc_type(mut rtype: libc::c_ulong) -> *const libc::c_char {
    match rtype {
        0 => return b"R_SH_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_SH_DIR32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_SH_REL32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_SH_DIR8WPN\0" as *const u8 as *const libc::c_char,
        4 => return b"R_SH_IND12W\0" as *const u8 as *const libc::c_char,
        5 => return b"R_SH_DIR8WPL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_SH_DIR8WPZ\0" as *const u8 as *const libc::c_char,
        7 => return b"R_SH_DIR8BP\0" as *const u8 as *const libc::c_char,
        8 => return b"R_SH_DIR8W\0" as *const u8 as *const libc::c_char,
        9 => return b"R_SH_DIR8L\0" as *const u8 as *const libc::c_char,
        10 => return b"R_SH_LOOP_START\0" as *const u8 as *const libc::c_char,
        11 => return b"R_SH_LOOP_END\0" as *const u8 as *const libc::c_char,
        22 => return b"R_SH_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        23 => return b"R_SH_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        24 => return b"R_SH_SWITCH8\0" as *const u8 as *const libc::c_char,
        25 => return b"R_SH_SWITCH16\0" as *const u8 as *const libc::c_char,
        26 => return b"R_SH_SWITCH32\0" as *const u8 as *const libc::c_char,
        27 => return b"R_SH_USES\0" as *const u8 as *const libc::c_char,
        28 => return b"R_SH_COUNT\0" as *const u8 as *const libc::c_char,
        29 => return b"R_SH_ALIGN\0" as *const u8 as *const libc::c_char,
        30 => return b"R_SH_CODE\0" as *const u8 as *const libc::c_char,
        31 => return b"R_SH_DATA\0" as *const u8 as *const libc::c_char,
        32 => return b"R_SH_LABEL\0" as *const u8 as *const libc::c_char,
        33 => return b"R_SH_DIR16\0" as *const u8 as *const libc::c_char,
        34 => return b"R_SH_DIR8\0" as *const u8 as *const libc::c_char,
        35 => return b"R_SH_DIR8UL\0" as *const u8 as *const libc::c_char,
        36 => return b"R_SH_DIR8UW\0" as *const u8 as *const libc::c_char,
        37 => return b"R_SH_DIR8U\0" as *const u8 as *const libc::c_char,
        38 => return b"R_SH_DIR8SW\0" as *const u8 as *const libc::c_char,
        39 => return b"R_SH_DIR8S\0" as *const u8 as *const libc::c_char,
        40 => return b"R_SH_DIR4UL\0" as *const u8 as *const libc::c_char,
        41 => return b"R_SH_DIR4UW\0" as *const u8 as *const libc::c_char,
        42 => return b"R_SH_DIR4U\0" as *const u8 as *const libc::c_char,
        43 => return b"R_SH_PSHA\0" as *const u8 as *const libc::c_char,
        44 => return b"R_SH_PSHL\0" as *const u8 as *const libc::c_char,
        45 => return b"R_SH_DIR5U\0" as *const u8 as *const libc::c_char,
        46 => return b"R_SH_DIR6U\0" as *const u8 as *const libc::c_char,
        47 => return b"R_SH_DIR6S\0" as *const u8 as *const libc::c_char,
        48 => return b"R_SH_DIR10S\0" as *const u8 as *const libc::c_char,
        49 => return b"R_SH_DIR10SW\0" as *const u8 as *const libc::c_char,
        50 => return b"R_SH_DIR10SL\0" as *const u8 as *const libc::c_char,
        51 => return b"R_SH_DIR10SQ\0" as *const u8 as *const libc::c_char,
        53 => return b"R_SH_DIR16S\0" as *const u8 as *const libc::c_char,
        144 => return b"R_SH_TLS_GD_32\0" as *const u8 as *const libc::c_char,
        145 => return b"R_SH_TLS_LD_32\0" as *const u8 as *const libc::c_char,
        146 => return b"R_SH_TLS_LDO_32\0" as *const u8 as *const libc::c_char,
        147 => return b"R_SH_TLS_IE_32\0" as *const u8 as *const libc::c_char,
        148 => return b"R_SH_TLS_LE_32\0" as *const u8 as *const libc::c_char,
        149 => return b"R_SH_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        150 => return b"R_SH_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
        151 => return b"R_SH_TLS_TPOFF32\0" as *const u8 as *const libc::c_char,
        160 => return b"R_SH_GOT32\0" as *const u8 as *const libc::c_char,
        161 => return b"R_SH_PLT32\0" as *const u8 as *const libc::c_char,
        162 => return b"R_SH_COPY\0" as *const u8 as *const libc::c_char,
        163 => return b"R_SH_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        164 => return b"R_SH_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        165 => return b"R_SH_RELATIVE\0" as *const u8 as *const libc::c_char,
        166 => return b"R_SH_GOTOFF\0" as *const u8 as *const libc::c_char,
        167 => return b"R_SH_GOTPC\0" as *const u8 as *const libc::c_char,
        168 => return b"R_SH_GOTPLT32\0" as *const u8 as *const libc::c_char,
        169 => return b"R_SH_GOT_LOW16\0" as *const u8 as *const libc::c_char,
        170 => return b"R_SH_GOT_MEDLOW16\0" as *const u8 as *const libc::c_char,
        171 => return b"R_SH_GOT_MEDHI16\0" as *const u8 as *const libc::c_char,
        172 => return b"R_SH_GOT_HI16\0" as *const u8 as *const libc::c_char,
        173 => return b"R_SH_GOTPLT_LOW16\0" as *const u8 as *const libc::c_char,
        174 => return b"R_SH_GOTPLT_MEDLOW16\0" as *const u8 as *const libc::c_char,
        175 => return b"R_SH_GOTPLT_MEDHI16\0" as *const u8 as *const libc::c_char,
        176 => return b"R_SH_GOTPLT_HI16\0" as *const u8 as *const libc::c_char,
        177 => return b"R_SH_PLT_LOW16\0" as *const u8 as *const libc::c_char,
        178 => return b"R_SH_PLT_MEDLOW16\0" as *const u8 as *const libc::c_char,
        179 => return b"R_SH_PLT_MEDHI16\0" as *const u8 as *const libc::c_char,
        180 => return b"R_SH_PLT_HI16\0" as *const u8 as *const libc::c_char,
        181 => return b"R_SH_GOTOFF_LOW16\0" as *const u8 as *const libc::c_char,
        182 => return b"R_SH_GOTOFF_MEDLOW16\0" as *const u8 as *const libc::c_char,
        183 => return b"R_SH_GOTOFF_MEDHI16\0" as *const u8 as *const libc::c_char,
        184 => return b"R_SH_GOTOFF_HI16\0" as *const u8 as *const libc::c_char,
        185 => return b"R_SH_GOTPC_LOW16\0" as *const u8 as *const libc::c_char,
        186 => return b"R_SH_GOTPC_MEDLOW16\0" as *const u8 as *const libc::c_char,
        187 => return b"R_SH_GOTPC_MEDHI16\0" as *const u8 as *const libc::c_char,
        188 => return b"R_SH_GOTPC_HI16\0" as *const u8 as *const libc::c_char,
        189 => return b"R_SH_GOT10BY4\0" as *const u8 as *const libc::c_char,
        190 => return b"R_SH_GOTPLT10BY4\0" as *const u8 as *const libc::c_char,
        191 => return b"R_SH_GOT10BY8\0" as *const u8 as *const libc::c_char,
        192 => return b"R_SH_GOTPLT10BY8\0" as *const u8 as *const libc::c_char,
        193 => return b"R_SH_COPY64\0" as *const u8 as *const libc::c_char,
        194 => return b"R_SH_GLOB_DAT64\0" as *const u8 as *const libc::c_char,
        195 => return b"R_SH_JMP_SLOT64\0" as *const u8 as *const libc::c_char,
        196 => return b"R_SH_RELATIVE64\0" as *const u8 as *const libc::c_char,
        201 => return b"R_SH_GOT20\0" as *const u8 as *const libc::c_char,
        202 => return b"R_SH_GOTOFF20\0" as *const u8 as *const libc::c_char,
        203 => return b"R_SH_GOTFUNCDESC\0" as *const u8 as *const libc::c_char,
        204 => return b"R_SH_GOTFUNCDESC20\0" as *const u8 as *const libc::c_char,
        205 => return b"R_SH_GOTOFFFUNCDESC\0" as *const u8 as *const libc::c_char,
        206 => return b"R_SH_GOTOFFFUNCDESC20\0" as *const u8 as *const libc::c_char,
        207 => return b"R_SH_FUNCDESC\0" as *const u8 as *const libc::c_char,
        208 => return b"R_SH_FUNCDESC_VALUE\0" as *const u8 as *const libc::c_char,
        242 => return b"R_SH_SHMEDIA_CODE\0" as *const u8 as *const libc::c_char,
        243 => return b"R_SH_PT_16\0" as *const u8 as *const libc::c_char,
        244 => return b"R_SH_IMMS16\0" as *const u8 as *const libc::c_char,
        245 => return b"R_SH_IMMU16\0" as *const u8 as *const libc::c_char,
        246 => return b"R_SH_IMM_LOW16\0" as *const u8 as *const libc::c_char,
        247 => return b"R_SH_IMM_LOW16_PCREL\0" as *const u8 as *const libc::c_char,
        248 => return b"R_SH_IMM_MEDLOW16\0" as *const u8 as *const libc::c_char,
        249 => return b"R_SH_IMM_MEDLOW16_PCREL\0" as *const u8 as *const libc::c_char,
        250 => return b"R_SH_IMM_MEDHI16\0" as *const u8 as *const libc::c_char,
        251 => return b"R_SH_IMM_MEDHI16_PCREL\0" as *const u8 as *const libc::c_char,
        252 => return b"R_SH_IMM_HI16\0" as *const u8 as *const libc::c_char,
        253 => return b"R_SH_IMM_HI16_PCREL\0" as *const u8 as *const libc::c_char,
        254 => return b"R_SH_64\0" as *const u8 as *const libc::c_char,
        255 => return b"R_SH_64_PCREL\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_sparc_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_SPARC_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_SPARC_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_SPARC_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_SPARC_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_SPARC_DISP8\0" as *const u8 as *const libc::c_char,
        5 => return b"R_SPARC_DISP16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_SPARC_DISP32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_SPARC_WDISP30\0" as *const u8 as *const libc::c_char,
        8 => return b"R_SPARC_WDISP22\0" as *const u8 as *const libc::c_char,
        9 => return b"R_SPARC_HI22\0" as *const u8 as *const libc::c_char,
        10 => return b"R_SPARC_22\0" as *const u8 as *const libc::c_char,
        11 => return b"R_SPARC_13\0" as *const u8 as *const libc::c_char,
        12 => return b"R_SPARC_LO10\0" as *const u8 as *const libc::c_char,
        13 => return b"R_SPARC_GOT10\0" as *const u8 as *const libc::c_char,
        14 => return b"R_SPARC_GOT13\0" as *const u8 as *const libc::c_char,
        15 => return b"R_SPARC_GOT22\0" as *const u8 as *const libc::c_char,
        16 => return b"R_SPARC_PC10\0" as *const u8 as *const libc::c_char,
        17 => return b"R_SPARC_PC22\0" as *const u8 as *const libc::c_char,
        18 => return b"R_SPARC_WPLT30\0" as *const u8 as *const libc::c_char,
        19 => return b"R_SPARC_COPY\0" as *const u8 as *const libc::c_char,
        20 => return b"R_SPARC_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        21 => return b"R_SPARC_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        22 => return b"R_SPARC_RELATIVE\0" as *const u8 as *const libc::c_char,
        23 => return b"R_SPARC_UA32\0" as *const u8 as *const libc::c_char,
        24 => return b"R_SPARC_PLT32\0" as *const u8 as *const libc::c_char,
        25 => return b"R_SPARC_HIPLT22\0" as *const u8 as *const libc::c_char,
        26 => return b"R_SPARC_LOPLT10\0" as *const u8 as *const libc::c_char,
        27 => return b"R_SPARC_PCPLT32\0" as *const u8 as *const libc::c_char,
        28 => return b"R_SPARC_PCPLT22\0" as *const u8 as *const libc::c_char,
        29 => return b"R_SPARC_PCPLT10\0" as *const u8 as *const libc::c_char,
        30 => return b"R_SPARC_10\0" as *const u8 as *const libc::c_char,
        31 => return b"R_SPARC_11\0" as *const u8 as *const libc::c_char,
        32 => return b"R_SPARC_64\0" as *const u8 as *const libc::c_char,
        33 => return b"R_SPARC_OLO10\0" as *const u8 as *const libc::c_char,
        34 => return b"R_SPARC_HH22\0" as *const u8 as *const libc::c_char,
        35 => return b"R_SPARC_HM10\0" as *const u8 as *const libc::c_char,
        36 => return b"R_SPARC_LM22\0" as *const u8 as *const libc::c_char,
        37 => return b"R_SPARC_PC_HH22\0" as *const u8 as *const libc::c_char,
        38 => return b"R_SPARC_PC_HM10\0" as *const u8 as *const libc::c_char,
        39 => return b"R_SPARC_PC_LM22\0" as *const u8 as *const libc::c_char,
        40 => return b"R_SPARC_WDISP16\0" as *const u8 as *const libc::c_char,
        41 => return b"R_SPARC_WDISP19\0" as *const u8 as *const libc::c_char,
        42 => return b"R_SPARC_UNUSED_42\0" as *const u8 as *const libc::c_char,
        43 => return b"R_SPARC_7\0" as *const u8 as *const libc::c_char,
        44 => return b"R_SPARC_5\0" as *const u8 as *const libc::c_char,
        45 => return b"R_SPARC_6\0" as *const u8 as *const libc::c_char,
        46 => return b"R_SPARC_DISP64\0" as *const u8 as *const libc::c_char,
        47 => return b"R_SPARC_PLT64\0" as *const u8 as *const libc::c_char,
        48 => return b"R_SPARC_HIX22\0" as *const u8 as *const libc::c_char,
        49 => return b"R_SPARC_LOX10\0" as *const u8 as *const libc::c_char,
        50 => return b"R_SPARC_H44\0" as *const u8 as *const libc::c_char,
        51 => return b"R_SPARC_M44\0" as *const u8 as *const libc::c_char,
        52 => return b"R_SPARC_L44\0" as *const u8 as *const libc::c_char,
        53 => return b"R_SPARC_REGISTER\0" as *const u8 as *const libc::c_char,
        54 => return b"R_SPARC_UA64\0" as *const u8 as *const libc::c_char,
        55 => return b"R_SPARC_UA16\0" as *const u8 as *const libc::c_char,
        56 => return b"R_SPARC_TLS_GD_HI22\0" as *const u8 as *const libc::c_char,
        57 => return b"R_SPARC_TLS_GD_LO10\0" as *const u8 as *const libc::c_char,
        58 => return b"R_SPARC_TLS_GD_ADD\0" as *const u8 as *const libc::c_char,
        59 => return b"R_SPARC_TLS_GD_CALL\0" as *const u8 as *const libc::c_char,
        60 => return b"R_SPARC_TLS_LDM_HI22\0" as *const u8 as *const libc::c_char,
        61 => return b"R_SPARC_TLS_LDM_LO10\0" as *const u8 as *const libc::c_char,
        62 => return b"R_SPARC_TLS_LDM_ADD\0" as *const u8 as *const libc::c_char,
        63 => return b"R_SPARC_TLS_LDM_CALL\0" as *const u8 as *const libc::c_char,
        64 => return b"R_SPARC_TLS_LDO_HIX22\0" as *const u8 as *const libc::c_char,
        65 => return b"R_SPARC_TLS_LDO_LOX10\0" as *const u8 as *const libc::c_char,
        66 => return b"R_SPARC_TLS_LDO_ADD\0" as *const u8 as *const libc::c_char,
        67 => return b"R_SPARC_TLS_IE_HI22\0" as *const u8 as *const libc::c_char,
        68 => return b"R_SPARC_TLS_IE_LO10\0" as *const u8 as *const libc::c_char,
        69 => return b"R_SPARC_TLS_IE_LD\0" as *const u8 as *const libc::c_char,
        70 => return b"R_SPARC_TLS_IE_LDX\0" as *const u8 as *const libc::c_char,
        71 => return b"R_SPARC_TLS_IE_ADD\0" as *const u8 as *const libc::c_char,
        72 => return b"R_SPARC_TLS_LE_HIX22\0" as *const u8 as *const libc::c_char,
        73 => return b"R_SPARC_TLS_LE_LOX10\0" as *const u8 as *const libc::c_char,
        74 => return b"R_SPARC_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        75 => return b"R_SPARC_TLS_DTPMOD64\0" as *const u8 as *const libc::c_char,
        76 => return b"R_SPARC_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
        77 => return b"R_SPARC_TLS_DTPOFF64\0" as *const u8 as *const libc::c_char,
        78 => return b"R_SPARC_TLS_TPOFF32\0" as *const u8 as *const libc::c_char,
        79 => return b"R_SPARC_TLS_TPOFF64\0" as *const u8 as *const libc::c_char,
        80 => return b"R_SPARC_GOTDATA_HIX22\0" as *const u8 as *const libc::c_char,
        81 => return b"R_SPARC_GOTDATA_LOX10\0" as *const u8 as *const libc::c_char,
        82 => return b"R_SPARC_GOTDATA_OP_HIX22\0" as *const u8 as *const libc::c_char,
        83 => return b"R_SPARC_GOTDATA_OP_LOX10\0" as *const u8 as *const libc::c_char,
        84 => return b"R_SPARC_GOTDATA_OP\0" as *const u8 as *const libc::c_char,
        85 => return b"R_SPARC_H34\0" as *const u8 as *const libc::c_char,
        86 => return b"R_SPARC_SIZE32\0" as *const u8 as *const libc::c_char,
        87 => return b"R_SPARC_SIZE64\0" as *const u8 as *const libc::c_char,
        88 => return b"R_SPARC_WDISP10\0" as *const u8 as *const libc::c_char,
        248 => return b"R_SPARC_JMP_IREL\0" as *const u8 as *const libc::c_char,
        249 => return b"R_SPARC_IRELATIVE\0" as *const u8 as *const libc::c_char,
        250 => return b"R_SPARC_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        251 => return b"R_SPARC_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        252 => return b"R_SPARC_REV32\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_spu_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_SPU_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_SPU_ADDR10\0" as *const u8 as *const libc::c_char,
        2 => return b"R_SPU_ADDR16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_SPU_ADDR16_HI\0" as *const u8 as *const libc::c_char,
        4 => return b"R_SPU_ADDR16_LO\0" as *const u8 as *const libc::c_char,
        5 => return b"R_SPU_ADDR18\0" as *const u8 as *const libc::c_char,
        6 => return b"R_SPU_ADDR32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_SPU_REL16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_SPU_ADDR7\0" as *const u8 as *const libc::c_char,
        9 => return b"R_SPU_REL9\0" as *const u8 as *const libc::c_char,
        10 => return b"R_SPU_REL9I\0" as *const u8 as *const libc::c_char,
        11 => return b"R_SPU_ADDR10I\0" as *const u8 as *const libc::c_char,
        12 => return b"R_SPU_ADDR16I\0" as *const u8 as *const libc::c_char,
        13 => return b"R_SPU_REL32\0" as *const u8 as *const libc::c_char,
        14 => return b"R_SPU_ADDR16X\0" as *const u8 as *const libc::c_char,
        15 => return b"R_SPU_PPU32\0" as *const u8 as *const libc::c_char,
        16 => return b"R_SPU_PPU64\0" as *const u8 as *const libc::c_char,
        17 => return b"R_SPU_ADD_PIC\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_tic6x_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_C6000_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_C6000_ABS32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_C6000_ABS16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_C6000_ABS8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_C6000_PCR_S21\0" as *const u8 as *const libc::c_char,
        5 => return b"R_C6000_PCR_S12\0" as *const u8 as *const libc::c_char,
        6 => return b"R_C6000_PCR_S10\0" as *const u8 as *const libc::c_char,
        7 => return b"R_C6000_PCR_S7\0" as *const u8 as *const libc::c_char,
        8 => return b"R_C6000_ABS_S16\0" as *const u8 as *const libc::c_char,
        9 => return b"R_C6000_ABS_L16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_C6000_ABS_H16\0" as *const u8 as *const libc::c_char,
        11 => return b"R_C6000_SBR_U15_B\0" as *const u8 as *const libc::c_char,
        12 => return b"R_C6000_SBR_U15_H\0" as *const u8 as *const libc::c_char,
        13 => return b"R_C6000_SBR_U15_W\0" as *const u8 as *const libc::c_char,
        14 => return b"R_C6000_SBR_S16\0" as *const u8 as *const libc::c_char,
        15 => return b"R_C6000_SBR_L16_B\0" as *const u8 as *const libc::c_char,
        16 => return b"R_C6000_SBR_L16_H\0" as *const u8 as *const libc::c_char,
        17 => return b"R_C6000_SBR_L16_W\0" as *const u8 as *const libc::c_char,
        18 => return b"R_C6000_SBR_H16_B\0" as *const u8 as *const libc::c_char,
        19 => return b"R_C6000_SBR_H16_H\0" as *const u8 as *const libc::c_char,
        20 => return b"R_C6000_SBR_H16_W\0" as *const u8 as *const libc::c_char,
        21 => return b"R_C6000_SBR_GOT_U15_W\0" as *const u8 as *const libc::c_char,
        22 => return b"R_C6000_SBR_GOT_L16_W\0" as *const u8 as *const libc::c_char,
        23 => return b"R_C6000_SBR_GOT_H16_W\0" as *const u8 as *const libc::c_char,
        24 => return b"R_C6000_DSBT_INDEX\0" as *const u8 as *const libc::c_char,
        25 => return b"R_C6000_PREL31\0" as *const u8 as *const libc::c_char,
        26 => return b"R_C6000_COPY\0" as *const u8 as *const libc::c_char,
        27 => return b"R_C6000_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        28 => return b"R_C6000_EHTYPE\0" as *const u8 as *const libc::c_char,
        29 => return b"R_C6000_PCR_H16\0" as *const u8 as *const libc::c_char,
        30 => return b"R_C6000_PCR_L16\0" as *const u8 as *const libc::c_char,
        253 => return b"R_C6000_ALIGN\0" as *const u8 as *const libc::c_char,
        254 => return b"R_C6000_FPHEAD\0" as *const u8 as *const libc::c_char,
        255 => return b"R_C6000_NOCMP\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_tilegx_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_TILEGX_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_TILEGX_64\0" as *const u8 as *const libc::c_char,
        2 => return b"R_TILEGX_32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_TILEGX_16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_TILEGX_8\0" as *const u8 as *const libc::c_char,
        5 => return b"R_TILEGX_64_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_TILEGX_32_PCREL\0" as *const u8 as *const libc::c_char,
        7 => return b"R_TILEGX_16_PCREL\0" as *const u8 as *const libc::c_char,
        8 => return b"R_TILEGX_8_PCREL\0" as *const u8 as *const libc::c_char,
        9 => return b"R_TILEGX_HW0\0" as *const u8 as *const libc::c_char,
        10 => return b"R_TILEGX_HW1\0" as *const u8 as *const libc::c_char,
        11 => return b"R_TILEGX_HW2\0" as *const u8 as *const libc::c_char,
        12 => return b"R_TILEGX_HW3\0" as *const u8 as *const libc::c_char,
        13 => return b"R_TILEGX_HW0_LAST\0" as *const u8 as *const libc::c_char,
        14 => return b"R_TILEGX_HW1_LAST\0" as *const u8 as *const libc::c_char,
        15 => return b"R_TILEGX_HW2_LAST\0" as *const u8 as *const libc::c_char,
        16 => return b"R_TILEGX_COPY\0" as *const u8 as *const libc::c_char,
        17 => return b"R_TILEGX_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        18 => return b"R_TILEGX_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        19 => return b"R_TILEGX_RELATIVE\0" as *const u8 as *const libc::c_char,
        20 => return b"R_TILEGX_BROFF_X1\0" as *const u8 as *const libc::c_char,
        21 => return b"R_TILEGX_JUMPOFF_X1\0" as *const u8 as *const libc::c_char,
        22 => return b"R_TILEGX_JUMPOFF_X1_PLT\0" as *const u8 as *const libc::c_char,
        23 => return b"R_TILEGX_IMM8_X0\0" as *const u8 as *const libc::c_char,
        24 => return b"R_TILEGX_IMM8_Y0\0" as *const u8 as *const libc::c_char,
        25 => return b"R_TILEGX_IMM8_X1\0" as *const u8 as *const libc::c_char,
        26 => return b"R_TILEGX_IMM8_Y1\0" as *const u8 as *const libc::c_char,
        27 => return b"R_TILEGX_DEST_IMM8_X1\0" as *const u8 as *const libc::c_char,
        28 => return b"R_TILEGX_MT_IMM14_X1\0" as *const u8 as *const libc::c_char,
        29 => return b"R_TILEGX_MF_IMM14_X1\0" as *const u8 as *const libc::c_char,
        30 => return b"R_TILEGX_MMSTART_X0\0" as *const u8 as *const libc::c_char,
        31 => return b"R_TILEGX_MMEND_X0\0" as *const u8 as *const libc::c_char,
        32 => return b"R_TILEGX_SHAMT_X0\0" as *const u8 as *const libc::c_char,
        33 => return b"R_TILEGX_SHAMT_X1\0" as *const u8 as *const libc::c_char,
        34 => return b"R_TILEGX_SHAMT_Y0\0" as *const u8 as *const libc::c_char,
        35 => return b"R_TILEGX_SHAMT_Y1\0" as *const u8 as *const libc::c_char,
        36 => return b"R_TILEGX_IMM16_X0_HW0\0" as *const u8 as *const libc::c_char,
        37 => return b"R_TILEGX_IMM16_X1_HW0\0" as *const u8 as *const libc::c_char,
        38 => return b"R_TILEGX_IMM16_X0_HW1\0" as *const u8 as *const libc::c_char,
        39 => return b"R_TILEGX_IMM16_X1_HW1\0" as *const u8 as *const libc::c_char,
        40 => return b"R_TILEGX_IMM16_X0_HW2\0" as *const u8 as *const libc::c_char,
        41 => return b"R_TILEGX_IMM16_X1_HW2\0" as *const u8 as *const libc::c_char,
        42 => return b"R_TILEGX_IMM16_X0_HW3\0" as *const u8 as *const libc::c_char,
        43 => return b"R_TILEGX_IMM16_X1_HW3\0" as *const u8 as *const libc::c_char,
        44 => return b"R_TILEGX_IMM16_X0_HW0_LAST\0" as *const u8 as *const libc::c_char,
        45 => return b"R_TILEGX_IMM16_X1_HW0_LAST\0" as *const u8 as *const libc::c_char,
        46 => return b"R_TILEGX_IMM16_X0_HW1_LAST\0" as *const u8 as *const libc::c_char,
        47 => return b"R_TILEGX_IMM16_X1_HW1_LAST\0" as *const u8 as *const libc::c_char,
        48 => return b"R_TILEGX_IMM16_X0_HW2_LAST\0" as *const u8 as *const libc::c_char,
        49 => return b"R_TILEGX_IMM16_X1_HW2_LAST\0" as *const u8 as *const libc::c_char,
        50 => return b"R_TILEGX_IMM16_X0_HW0_PCREL\0" as *const u8 as *const libc::c_char,
        51 => return b"R_TILEGX_IMM16_X1_HW0_PCREL\0" as *const u8 as *const libc::c_char,
        52 => return b"R_TILEGX_IMM16_X0_HW1_PCREL\0" as *const u8 as *const libc::c_char,
        53 => return b"R_TILEGX_IMM16_X1_HW1_PCREL\0" as *const u8 as *const libc::c_char,
        54 => return b"R_TILEGX_IMM16_X0_HW2_PCREL\0" as *const u8 as *const libc::c_char,
        55 => return b"R_TILEGX_IMM16_X1_HW2_PCREL\0" as *const u8 as *const libc::c_char,
        56 => return b"R_TILEGX_IMM16_X0_HW3_PCREL\0" as *const u8 as *const libc::c_char,
        57 => return b"R_TILEGX_IMM16_X1_HW3_PCREL\0" as *const u8 as *const libc::c_char,
        58 => {
            return b"R_TILEGX_IMM16_X0_HW0_LAST_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        59 => {
            return b"R_TILEGX_IMM16_X1_HW0_LAST_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        60 => {
            return b"R_TILEGX_IMM16_X0_HW1_LAST_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        61 => {
            return b"R_TILEGX_IMM16_X1_HW1_LAST_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        62 => {
            return b"R_TILEGX_IMM16_X0_HW2_LAST_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        63 => {
            return b"R_TILEGX_IMM16_X1_HW2_LAST_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        64 => return b"R_TILEGX_IMM16_X0_HW0_GOT\0" as *const u8 as *const libc::c_char,
        65 => return b"R_TILEGX_IMM16_X1_HW0_GOT\0" as *const u8 as *const libc::c_char,
        66 => {
            return b"R_TILEGX_IMM16_X0_HW0_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        67 => {
            return b"R_TILEGX_IMM16_X1_HW0_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        68 => {
            return b"R_TILEGX_IMM16_X0_HW1_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        69 => {
            return b"R_TILEGX_IMM16_X1_HW1_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        70 => {
            return b"R_TILEGX_IMM16_X0_HW2_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        71 => {
            return b"R_TILEGX_IMM16_X1_HW2_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        72 => {
            return b"R_TILEGX_IMM16_X0_HW0_LAST_GOT\0" as *const u8
                as *const libc::c_char;
        }
        73 => {
            return b"R_TILEGX_IMM16_X1_HW0_LAST_GOT\0" as *const u8
                as *const libc::c_char;
        }
        74 => {
            return b"R_TILEGX_IMM16_X0_HW1_LAST_GOT\0" as *const u8
                as *const libc::c_char;
        }
        75 => {
            return b"R_TILEGX_IMM16_X1_HW1_LAST_GOT\0" as *const u8
                as *const libc::c_char;
        }
        76 => {
            return b"R_TILEGX_IMM16_X0_HW3_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        77 => {
            return b"R_TILEGX_IMM16_X1_HW3_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        78 => {
            return b"R_TILEGX_IMM16_X0_HW0_TLS_GD\0" as *const u8 as *const libc::c_char;
        }
        79 => {
            return b"R_TILEGX_IMM16_X1_HW0_TLS_GD\0" as *const u8 as *const libc::c_char;
        }
        80 => {
            return b"R_TILEGX_IMM16_X0_HW0_TLS_LE\0" as *const u8 as *const libc::c_char;
        }
        81 => {
            return b"R_TILEGX_IMM16_X1_HW0_TLS_LE\0" as *const u8 as *const libc::c_char;
        }
        82 => {
            return b"R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE\0" as *const u8
                as *const libc::c_char;
        }
        83 => {
            return b"R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE\0" as *const u8
                as *const libc::c_char;
        }
        84 => {
            return b"R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE\0" as *const u8
                as *const libc::c_char;
        }
        85 => {
            return b"R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE\0" as *const u8
                as *const libc::c_char;
        }
        86 => {
            return b"R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD\0" as *const u8
                as *const libc::c_char;
        }
        87 => {
            return b"R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD\0" as *const u8
                as *const libc::c_char;
        }
        88 => {
            return b"R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD\0" as *const u8
                as *const libc::c_char;
        }
        89 => {
            return b"R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD\0" as *const u8
                as *const libc::c_char;
        }
        92 => {
            return b"R_TILEGX_IMM16_X0_HW0_TLS_IE\0" as *const u8 as *const libc::c_char;
        }
        93 => {
            return b"R_TILEGX_IMM16_X1_HW0_TLS_IE\0" as *const u8 as *const libc::c_char;
        }
        94 => {
            return b"R_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        95 => {
            return b"R_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        96 => {
            return b"R_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        97 => {
            return b"R_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        98 => {
            return b"R_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        99 => {
            return b"R_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL\0" as *const u8
                as *const libc::c_char;
        }
        100 => {
            return b"R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE\0" as *const u8
                as *const libc::c_char;
        }
        101 => {
            return b"R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE\0" as *const u8
                as *const libc::c_char;
        }
        102 => {
            return b"R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE\0" as *const u8
                as *const libc::c_char;
        }
        103 => {
            return b"R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE\0" as *const u8
                as *const libc::c_char;
        }
        106 => return b"R_TILEGX_TLS_DTPMOD64\0" as *const u8 as *const libc::c_char,
        107 => return b"R_TILEGX_TLS_DTPOFF64\0" as *const u8 as *const libc::c_char,
        108 => return b"R_TILEGX_TLS_TPOFF64\0" as *const u8 as *const libc::c_char,
        109 => return b"R_TILEGX_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        110 => return b"R_TILEGX_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
        111 => return b"R_TILEGX_TLS_TPOFF32\0" as *const u8 as *const libc::c_char,
        112 => return b"R_TILEGX_TLS_GD_CALL\0" as *const u8 as *const libc::c_char,
        113 => {
            return b"R_TILEGX_IMM8_X0_TLS_GD_ADD\0" as *const u8 as *const libc::c_char;
        }
        114 => {
            return b"R_TILEGX_IMM8_X1_TLS_GD_ADD\0" as *const u8 as *const libc::c_char;
        }
        115 => {
            return b"R_TILEGX_IMM8_Y0_TLS_GD_ADD\0" as *const u8 as *const libc::c_char;
        }
        116 => {
            return b"R_TILEGX_IMM8_Y1_TLS_GD_ADD\0" as *const u8 as *const libc::c_char;
        }
        117 => return b"R_TILEGX_TLS_IE_LOAD\0" as *const u8 as *const libc::c_char,
        118 => return b"R_TILEGX_IMM8_X0_TLS_ADD\0" as *const u8 as *const libc::c_char,
        119 => return b"R_TILEGX_IMM8_X1_TLS_ADD\0" as *const u8 as *const libc::c_char,
        120 => return b"R_TILEGX_IMM8_Y0_TLS_ADD\0" as *const u8 as *const libc::c_char,
        121 => return b"R_TILEGX_IMM8_Y1_TLS_ADD\0" as *const u8 as *const libc::c_char,
        128 => return b"R_TILEGX_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        129 => return b"R_TILEGX_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_tilepro_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_TILEPRO_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_TILEPRO_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_TILEPRO_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_TILEPRO_8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_TILEPRO_32_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_TILEPRO_16_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_TILEPRO_8_PCREL\0" as *const u8 as *const libc::c_char,
        7 => return b"R_TILEPRO_LO16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_TILEPRO_HI16\0" as *const u8 as *const libc::c_char,
        9 => return b"R_TILEPRO_HA16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_TILEPRO_COPY\0" as *const u8 as *const libc::c_char,
        11 => return b"R_TILEPRO_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        12 => return b"R_TILEPRO_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        13 => return b"R_TILEPRO_RELATIVE\0" as *const u8 as *const libc::c_char,
        14 => return b"R_TILEPRO_BROFF_X1\0" as *const u8 as *const libc::c_char,
        15 => return b"R_TILEPRO_JOFFLONG_X1\0" as *const u8 as *const libc::c_char,
        16 => return b"R_TILEPRO_JOFFLONG_X1_PLT\0" as *const u8 as *const libc::c_char,
        17 => return b"R_TILEPRO_IMM8_X0\0" as *const u8 as *const libc::c_char,
        18 => return b"R_TILEPRO_IMM8_Y0\0" as *const u8 as *const libc::c_char,
        19 => return b"R_TILEPRO_IMM8_X1\0" as *const u8 as *const libc::c_char,
        20 => return b"R_TILEPRO_IMM8_Y1\0" as *const u8 as *const libc::c_char,
        21 => return b"R_TILEPRO_MT_IMM15_X1\0" as *const u8 as *const libc::c_char,
        22 => return b"R_TILEPRO_MF_IMM15_X1\0" as *const u8 as *const libc::c_char,
        23 => return b"R_TILEPRO_IMM16_X0\0" as *const u8 as *const libc::c_char,
        24 => return b"R_TILEPRO_IMM16_X1\0" as *const u8 as *const libc::c_char,
        25 => return b"R_TILEPRO_IMM16_X0_LO\0" as *const u8 as *const libc::c_char,
        26 => return b"R_TILEPRO_IMM16_X1_LO\0" as *const u8 as *const libc::c_char,
        27 => return b"R_TILEPRO_IMM16_X0_HI\0" as *const u8 as *const libc::c_char,
        28 => return b"R_TILEPRO_IMM16_X1_HI\0" as *const u8 as *const libc::c_char,
        29 => return b"R_TILEPRO_IMM16_X0_HA\0" as *const u8 as *const libc::c_char,
        30 => return b"R_TILEPRO_IMM16_X1_HA\0" as *const u8 as *const libc::c_char,
        31 => return b"R_TILEPRO_IMM16_X0_PCREL\0" as *const u8 as *const libc::c_char,
        32 => return b"R_TILEPRO_IMM16_X1_PCREL\0" as *const u8 as *const libc::c_char,
        33 => return b"R_TILEPRO_IMM16_X0_LO_PCREL\0" as *const u8 as *const libc::c_char,
        34 => return b"R_TILEPRO_IMM16_X1_LO_PCREL\0" as *const u8 as *const libc::c_char,
        35 => return b"R_TILEPRO_IMM16_X0_HI_PCREL\0" as *const u8 as *const libc::c_char,
        36 => return b"R_TILEPRO_IMM16_X1_HI_PCREL\0" as *const u8 as *const libc::c_char,
        37 => return b"R_TILEPRO_IMM16_X0_HA_PCREL\0" as *const u8 as *const libc::c_char,
        38 => return b"R_TILEPRO_IMM16_X1_HA_PCREL\0" as *const u8 as *const libc::c_char,
        39 => return b"R_TILEPRO_IMM16_X0_GOT\0" as *const u8 as *const libc::c_char,
        40 => return b"R_TILEPRO_IMM16_X1_GOT\0" as *const u8 as *const libc::c_char,
        41 => return b"R_TILEPRO_IMM16_X0_GOT_LO\0" as *const u8 as *const libc::c_char,
        42 => return b"R_TILEPRO_IMM16_X1_GOT_LO\0" as *const u8 as *const libc::c_char,
        43 => return b"R_TILEPRO_IMM16_X0_GOT_HI\0" as *const u8 as *const libc::c_char,
        44 => return b"R_TILEPRO_IMM16_X1_GOT_HI\0" as *const u8 as *const libc::c_char,
        45 => return b"R_TILEPRO_IMM16_X0_GOT_HA\0" as *const u8 as *const libc::c_char,
        46 => return b"R_TILEPRO_IMM16_X1_GOT_HA\0" as *const u8 as *const libc::c_char,
        47 => return b"R_TILEPRO_MMSTART_X0\0" as *const u8 as *const libc::c_char,
        48 => return b"R_TILEPRO_MMEND_X0\0" as *const u8 as *const libc::c_char,
        49 => return b"R_TILEPRO_MMSTART_X1\0" as *const u8 as *const libc::c_char,
        50 => return b"R_TILEPRO_MMEND_X1\0" as *const u8 as *const libc::c_char,
        51 => return b"R_TILEPRO_SHAMT_X0\0" as *const u8 as *const libc::c_char,
        52 => return b"R_TILEPRO_SHAMT_X1\0" as *const u8 as *const libc::c_char,
        53 => return b"R_TILEPRO_SHAMT_Y0\0" as *const u8 as *const libc::c_char,
        54 => return b"R_TILEPRO_SHAMT_Y1\0" as *const u8 as *const libc::c_char,
        55 => return b"R_TILEPRO_DEST_IMM8_X1\0" as *const u8 as *const libc::c_char,
        60 => return b"R_TILEPRO_TLS_GD_CALL\0" as *const u8 as *const libc::c_char,
        61 => {
            return b"R_TILEPRO_IMM8_X0_TLS_GD_ADD\0" as *const u8 as *const libc::c_char;
        }
        62 => {
            return b"R_TILEPRO_IMM8_X1_TLS_GD_ADD\0" as *const u8 as *const libc::c_char;
        }
        63 => {
            return b"R_TILEPRO_IMM8_Y0_TLS_GD_ADD\0" as *const u8 as *const libc::c_char;
        }
        64 => {
            return b"R_TILEPRO_IMM8_Y1_TLS_GD_ADD\0" as *const u8 as *const libc::c_char;
        }
        65 => return b"R_TILEPRO_TLS_IE_LOAD\0" as *const u8 as *const libc::c_char,
        66 => return b"R_TILEPRO_IMM16_X0_TLS_GD\0" as *const u8 as *const libc::c_char,
        67 => return b"R_TILEPRO_IMM16_X1_TLS_GD\0" as *const u8 as *const libc::c_char,
        68 => {
            return b"R_TILEPRO_IMM16_X0_TLS_GD_LO\0" as *const u8 as *const libc::c_char;
        }
        69 => {
            return b"R_TILEPRO_IMM16_X1_TLS_GD_LO\0" as *const u8 as *const libc::c_char;
        }
        70 => {
            return b"R_TILEPRO_IMM16_X0_TLS_GD_HI\0" as *const u8 as *const libc::c_char;
        }
        71 => {
            return b"R_TILEPRO_IMM16_X1_TLS_GD_HI\0" as *const u8 as *const libc::c_char;
        }
        72 => {
            return b"R_TILEPRO_IMM16_X0_TLS_GD_HA\0" as *const u8 as *const libc::c_char;
        }
        73 => {
            return b"R_TILEPRO_IMM16_X1_TLS_GD_HA\0" as *const u8 as *const libc::c_char;
        }
        74 => return b"R_TILEPRO_IMM16_X0_TLS_IE\0" as *const u8 as *const libc::c_char,
        75 => return b"R_TILEPRO_IMM16_X1_TLS_IE\0" as *const u8 as *const libc::c_char,
        76 => {
            return b"R_TILEPRO_IMM16_X0_TLS_IE_LO\0" as *const u8 as *const libc::c_char;
        }
        77 => {
            return b"R_TILEPRO_IMM16_X1_TLS_IE_LO\0" as *const u8 as *const libc::c_char;
        }
        78 => {
            return b"R_TILEPRO_IMM16_X0_TLS_IE_HI\0" as *const u8 as *const libc::c_char;
        }
        79 => {
            return b"R_TILEPRO_IMM16_X1_TLS_IE_HI\0" as *const u8 as *const libc::c_char;
        }
        80 => {
            return b"R_TILEPRO_IMM16_X0_TLS_IE_HA\0" as *const u8 as *const libc::c_char;
        }
        81 => {
            return b"R_TILEPRO_IMM16_X1_TLS_IE_HA\0" as *const u8 as *const libc::c_char;
        }
        82 => return b"R_TILEPRO_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
        83 => return b"R_TILEPRO_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
        84 => return b"R_TILEPRO_TLS_TPOFF32\0" as *const u8 as *const libc::c_char,
        85 => return b"R_TILEPRO_IMM16_X0_TLS_LE\0" as *const u8 as *const libc::c_char,
        86 => return b"R_TILEPRO_IMM16_X1_TLS_LE\0" as *const u8 as *const libc::c_char,
        87 => {
            return b"R_TILEPRO_IMM16_X0_TLS_LE_LO\0" as *const u8 as *const libc::c_char;
        }
        88 => {
            return b"R_TILEPRO_IMM16_X1_TLS_LE_LO\0" as *const u8 as *const libc::c_char;
        }
        89 => {
            return b"R_TILEPRO_IMM16_X0_TLS_LE_HI\0" as *const u8 as *const libc::c_char;
        }
        90 => {
            return b"R_TILEPRO_IMM16_X1_TLS_LE_HI\0" as *const u8 as *const libc::c_char;
        }
        91 => {
            return b"R_TILEPRO_IMM16_X0_TLS_LE_HA\0" as *const u8 as *const libc::c_char;
        }
        92 => {
            return b"R_TILEPRO_IMM16_X1_TLS_LE_HA\0" as *const u8 as *const libc::c_char;
        }
        128 => return b"R_TILEPRO_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        129 => return b"R_TILEPRO_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn v850_reloc_type(mut rtype: libc::c_ulong) -> *const libc::c_char {
    match rtype {
        0 => return b"R_V850_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_V850_9_PCREL\0" as *const u8 as *const libc::c_char,
        2 => return b"R_V850_22_PCREL\0" as *const u8 as *const libc::c_char,
        3 => return b"R_V850_HI16_S\0" as *const u8 as *const libc::c_char,
        4 => return b"R_V850_HI16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_V850_LO16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_V850_ABS32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_V850_16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_V850_8\0" as *const u8 as *const libc::c_char,
        9 => return b"R_V850_SDA_16_16_OFFSET\0" as *const u8 as *const libc::c_char,
        10 => return b"R_V850_SDA_15_16_OFFSET\0" as *const u8 as *const libc::c_char,
        11 => return b"R_V850_ZDA_16_16_OFFSET\0" as *const u8 as *const libc::c_char,
        12 => return b"R_V850_ZDA_15_16_OFFSET\0" as *const u8 as *const libc::c_char,
        13 => return b"R_V850_TDA_6_8_OFFSET\0" as *const u8 as *const libc::c_char,
        14 => return b"R_V850_TDA_7_8_OFFSET\0" as *const u8 as *const libc::c_char,
        15 => return b"R_V850_TDA_7_7_OFFSET\0" as *const u8 as *const libc::c_char,
        16 => return b"R_V850_TDA_16_16_OFFSET\0" as *const u8 as *const libc::c_char,
        17 => return b"R_V850_TDA_4_5_OFFSET\0" as *const u8 as *const libc::c_char,
        18 => return b"R_V850_TDA_4_4_OFFSET\0" as *const u8 as *const libc::c_char,
        19 => {
            return b"R_V850_SDA_16_16_SPLIT_OFFSET\0" as *const u8 as *const libc::c_char;
        }
        20 => {
            return b"R_V850_ZDA_16_16_SPLIT_OFFSET\0" as *const u8 as *const libc::c_char;
        }
        21 => return b"R_V850_CALLT_6_7_OFFSET\0" as *const u8 as *const libc::c_char,
        22 => return b"R_V850_CALLT_16_16_OFFSET\0" as *const u8 as *const libc::c_char,
        23 => return b"R_V850_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        24 => return b"R_V850_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        25 => return b"R_V850_LONGCALL\0" as *const u8 as *const libc::c_char,
        26 => return b"R_V850_LONGJUMP\0" as *const u8 as *const libc::c_char,
        27 => return b"R_V850_ALIGN\0" as *const u8 as *const libc::c_char,
        28 => return b"R_V850_REL32\0" as *const u8 as *const libc::c_char,
        29 => return b"R_V850_LO16_SPLIT_OFFSET\0" as *const u8 as *const libc::c_char,
        30 => return b"R_V850_16_PCREL\0" as *const u8 as *const libc::c_char,
        31 => return b"R_V850_17_PCREL\0" as *const u8 as *const libc::c_char,
        32 => return b"R_V850_23\0" as *const u8 as *const libc::c_char,
        33 => return b"R_V850_32_PCREL\0" as *const u8 as *const libc::c_char,
        34 => return b"R_V850_32_ABS\0" as *const u8 as *const libc::c_char,
        35 => return b"R_V850_16_SPLIT_OFFSET\0" as *const u8 as *const libc::c_char,
        36 => return b"R_V850_16_S1\0" as *const u8 as *const libc::c_char,
        37 => return b"R_V850_LO16_S1\0" as *const u8 as *const libc::c_char,
        38 => return b"R_V850_CALLT_15_16_OFFSET\0" as *const u8 as *const libc::c_char,
        39 => return b"R_V850_32_GOTPCREL\0" as *const u8 as *const libc::c_char,
        40 => return b"R_V850_16_GOT\0" as *const u8 as *const libc::c_char,
        41 => return b"R_V850_32_GOT\0" as *const u8 as *const libc::c_char,
        42 => return b"R_V850_22_PLT\0" as *const u8 as *const libc::c_char,
        43 => return b"R_V850_32_PLT\0" as *const u8 as *const libc::c_char,
        44 => return b"R_V850_COPY\0" as *const u8 as *const libc::c_char,
        45 => return b"R_V850_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        46 => return b"R_V850_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        47 => return b"R_V850_RELATIVE\0" as *const u8 as *const libc::c_char,
        48 => return b"R_V850_16_GOTOFF\0" as *const u8 as *const libc::c_char,
        49 => return b"R_V850_32_GOTOFF\0" as *const u8 as *const libc::c_char,
        50 => return b"R_V850_CODE\0" as *const u8 as *const libc::c_char,
        51 => return b"R_V850_DATA\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn v800_reloc_type(mut rtype: libc::c_ulong) -> *const libc::c_char {
    match rtype {
        0 => return b"R_V800_NONE\0" as *const u8 as *const libc::c_char,
        48 => return b"R_V810_NONE\0" as *const u8 as *const libc::c_char,
        49 => return b"R_V810_BYTE\0" as *const u8 as *const libc::c_char,
        50 => return b"R_V810_HWORD\0" as *const u8 as *const libc::c_char,
        51 => return b"R_V810_WORD\0" as *const u8 as *const libc::c_char,
        52 => return b"R_V810_WLO\0" as *const u8 as *const libc::c_char,
        53 => return b"R_V810_WHI\0" as *const u8 as *const libc::c_char,
        54 => return b"R_V810_WHI1\0" as *const u8 as *const libc::c_char,
        55 => return b"R_V810_GPBYTE\0" as *const u8 as *const libc::c_char,
        56 => return b"R_V810_GPHWORD\0" as *const u8 as *const libc::c_char,
        57 => return b"R_V810_GPWORD\0" as *const u8 as *const libc::c_char,
        58 => return b"R_V810_GPWLO\0" as *const u8 as *const libc::c_char,
        59 => return b"R_V810_GPWHI\0" as *const u8 as *const libc::c_char,
        60 => return b"R_V810_GPWHI1\0" as *const u8 as *const libc::c_char,
        61 => return b"R_V850_HWLO\0" as *const u8 as *const libc::c_char,
        63 => return b"R_V850_EP7BIT\0" as *const u8 as *const libc::c_char,
        64 => return b"R_V850_EPHBYTE\0" as *const u8 as *const libc::c_char,
        65 => return b"R_V850_EPWBYTE\0" as *const u8 as *const libc::c_char,
        66 => return b"R_V850_REGHWLO\0" as *const u8 as *const libc::c_char,
        68 => return b"R_V850_GPHWLO\0" as *const u8 as *const libc::c_char,
        70 => return b"R_V850_PCR22\0" as *const u8 as *const libc::c_char,
        71 => return b"R_V850_BLO\0" as *const u8 as *const libc::c_char,
        72 => return b"R_V850_EP4BIT\0" as *const u8 as *const libc::c_char,
        73 => return b"R_V850_EP5BIT\0" as *const u8 as *const libc::c_char,
        74 => return b"R_V850_REGBLO\0" as *const u8 as *const libc::c_char,
        75 => return b"R_V850_GPBLO\0" as *const u8 as *const libc::c_char,
        76 => return b"R_V810_WLO_1\0" as *const u8 as *const libc::c_char,
        77 => return b"R_V810_GPWLO_1\0" as *const u8 as *const libc::c_char,
        78 => return b"R_V850_BLO_1\0" as *const u8 as *const libc::c_char,
        79 => return b"R_V850_HWLO_1\0" as *const u8 as *const libc::c_char,
        81 => return b"R_V850_GPBLO_1\0" as *const u8 as *const libc::c_char,
        82 => return b"R_V850_GPHWLO_1\0" as *const u8 as *const libc::c_char,
        84 => return b"R_V850_EPBLO\0" as *const u8 as *const libc::c_char,
        85 => return b"R_V850_EPHWLO\0" as *const u8 as *const libc::c_char,
        87 => return b"R_V850_EPWLO_N\0" as *const u8 as *const libc::c_char,
        88 => return b"R_V850_PC32\0" as *const u8 as *const libc::c_char,
        89 => return b"R_V850_W23BIT\0" as *const u8 as *const libc::c_char,
        90 => return b"R_V850_GPW23BIT\0" as *const u8 as *const libc::c_char,
        91 => return b"R_V850_EPW23BIT\0" as *const u8 as *const libc::c_char,
        92 => return b"R_V850_B23BIT\0" as *const u8 as *const libc::c_char,
        93 => return b"R_V850_GPB23BIT\0" as *const u8 as *const libc::c_char,
        94 => return b"R_V850_EPB23BIT\0" as *const u8 as *const libc::c_char,
        95 => return b"R_V850_PC16U\0" as *const u8 as *const libc::c_char,
        96 => return b"R_V850_PC17\0" as *const u8 as *const libc::c_char,
        97 => return b"R_V850_DW8\0" as *const u8 as *const libc::c_char,
        98 => return b"R_V850_GPDW8\0" as *const u8 as *const libc::c_char,
        99 => return b"R_V850_EPDW8\0" as *const u8 as *const libc::c_char,
        100 => return b"R_V850_PC9\0" as *const u8 as *const libc::c_char,
        101 => return b"R_V810_REGBYTE\0" as *const u8 as *const libc::c_char,
        102 => return b"R_V810_REGHWORD\0" as *const u8 as *const libc::c_char,
        103 => return b"R_V810_REGWORD\0" as *const u8 as *const libc::c_char,
        104 => return b"R_V810_REGWLO\0" as *const u8 as *const libc::c_char,
        105 => return b"R_V810_REGWHI\0" as *const u8 as *const libc::c_char,
        106 => return b"R_V810_REGWHI1\0" as *const u8 as *const libc::c_char,
        107 => return b"R_V850_REGW23BIT\0" as *const u8 as *const libc::c_char,
        108 => return b"R_V850_REGB23BIT\0" as *const u8 as *const libc::c_char,
        109 => return b"R_V850_REGDW8\0" as *const u8 as *const libc::c_char,
        110 => return b"R_V810_EPBYTE\0" as *const u8 as *const libc::c_char,
        111 => return b"R_V810_EPHWORD\0" as *const u8 as *const libc::c_char,
        112 => return b"R_V810_EPWORD\0" as *const u8 as *const libc::c_char,
        113 => return b"R_V850_WLO23\0" as *const u8 as *const libc::c_char,
        114 => return b"R_V850_WORD_E\0" as *const u8 as *const libc::c_char,
        115 => return b"R_V850_REGWORD_E\0" as *const u8 as *const libc::c_char,
        116 => return b"R_V850_WORD\0" as *const u8 as *const libc::c_char,
        117 => return b"R_V850_GPWORD\0" as *const u8 as *const libc::c_char,
        118 => return b"R_V850_REGWORD\0" as *const u8 as *const libc::c_char,
        119 => return b"R_V850_EPWORD\0" as *const u8 as *const libc::c_char,
        120 => return b"R_V810_TPBYTE\0" as *const u8 as *const libc::c_char,
        121 => return b"R_V810_TPHWORD\0" as *const u8 as *const libc::c_char,
        122 => return b"R_V810_TPWORD\0" as *const u8 as *const libc::c_char,
        123 => return b"R_V810_TPWLO\0" as *const u8 as *const libc::c_char,
        124 => return b"R_V810_TPWHI\0" as *const u8 as *const libc::c_char,
        125 => return b"R_V810_TPWHI1\0" as *const u8 as *const libc::c_char,
        126 => return b"R_V850_TPHWLO\0" as *const u8 as *const libc::c_char,
        127 => return b"R_V850_TPBLO\0" as *const u8 as *const libc::c_char,
        128 => return b"R_V810_TPWLO_1\0" as *const u8 as *const libc::c_char,
        129 => return b"R_V850_TPBLO_1\0" as *const u8 as *const libc::c_char,
        130 => return b"R_V850_TPHWLO_1\0" as *const u8 as *const libc::c_char,
        131 => return b"R_V850_TP23BIT\0" as *const u8 as *const libc::c_char,
        132 => return b"R_V850_TPW23BIT\0" as *const u8 as *const libc::c_char,
        133 => return b"R_V850_TPDW8\0" as *const u8 as *const libc::c_char,
        160 => return b"R_V810_ABS32\0" as *const u8 as *const libc::c_char,
        224 => return b"R_V850_SYM\0" as *const u8 as *const libc::c_char,
        225 => return b"R_V850_OPadd\0" as *const u8 as *const libc::c_char,
        226 => return b"R_V850_OPsub\0" as *const u8 as *const libc::c_char,
        227 => return b"R_V850_OPsctsize\0" as *const u8 as *const libc::c_char,
        228 => return b"R_V850_OPscttop\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_vax_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_VAX_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_VAX_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_VAX_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_VAX_8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_VAX_PC32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_VAX_PC16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_VAX_PC8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_VAX_GOT32\0" as *const u8 as *const libc::c_char,
        13 => return b"R_VAX_PLT32\0" as *const u8 as *const libc::c_char,
        19 => return b"R_VAX_COPY\0" as *const u8 as *const libc::c_char,
        20 => return b"R_VAX_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        21 => return b"R_VAX_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        22 => return b"R_VAX_RELATIVE\0" as *const u8 as *const libc::c_char,
        23 => return b"R_VAX_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        24 => return b"R_VAX_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_visium_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_VISIUM_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_VISIUM_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_VISIUM_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_VISIUM_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_VISIUM_8_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_VISIUM_16_PCREL\0" as *const u8 as *const libc::c_char,
        6 => return b"R_VISIUM_32_PCREL\0" as *const u8 as *const libc::c_char,
        7 => return b"R_VISIUM_PC16\0" as *const u8 as *const libc::c_char,
        8 => return b"R_VISIUM_HI16\0" as *const u8 as *const libc::c_char,
        9 => return b"R_VISIUM_LO16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_VISIUM_IM16\0" as *const u8 as *const libc::c_char,
        11 => return b"R_VISIUM_HI16_PCREL\0" as *const u8 as *const libc::c_char,
        12 => return b"R_VISIUM_LO16_PCREL\0" as *const u8 as *const libc::c_char,
        13 => return b"R_VISIUM_IM16_PCREL\0" as *const u8 as *const libc::c_char,
        200 => return b"R_VISIUM_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        201 => return b"R_VISIUM_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_wasm32_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_WASM32_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_WASM32_32\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_x86_64_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_X86_64_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_X86_64_64\0" as *const u8 as *const libc::c_char,
        2 => return b"R_X86_64_PC32\0" as *const u8 as *const libc::c_char,
        3 => return b"R_X86_64_GOT32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_X86_64_PLT32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_X86_64_COPY\0" as *const u8 as *const libc::c_char,
        6 => return b"R_X86_64_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        7 => return b"R_X86_64_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
        8 => return b"R_X86_64_RELATIVE\0" as *const u8 as *const libc::c_char,
        9 => return b"R_X86_64_GOTPCREL\0" as *const u8 as *const libc::c_char,
        10 => return b"R_X86_64_32\0" as *const u8 as *const libc::c_char,
        11 => return b"R_X86_64_32S\0" as *const u8 as *const libc::c_char,
        12 => return b"R_X86_64_16\0" as *const u8 as *const libc::c_char,
        13 => return b"R_X86_64_PC16\0" as *const u8 as *const libc::c_char,
        14 => return b"R_X86_64_8\0" as *const u8 as *const libc::c_char,
        15 => return b"R_X86_64_PC8\0" as *const u8 as *const libc::c_char,
        16 => return b"R_X86_64_DTPMOD64\0" as *const u8 as *const libc::c_char,
        17 => return b"R_X86_64_DTPOFF64\0" as *const u8 as *const libc::c_char,
        18 => return b"R_X86_64_TPOFF64\0" as *const u8 as *const libc::c_char,
        19 => return b"R_X86_64_TLSGD\0" as *const u8 as *const libc::c_char,
        20 => return b"R_X86_64_TLSLD\0" as *const u8 as *const libc::c_char,
        21 => return b"R_X86_64_DTPOFF32\0" as *const u8 as *const libc::c_char,
        22 => return b"R_X86_64_GOTTPOFF\0" as *const u8 as *const libc::c_char,
        23 => return b"R_X86_64_TPOFF32\0" as *const u8 as *const libc::c_char,
        24 => return b"R_X86_64_PC64\0" as *const u8 as *const libc::c_char,
        25 => return b"R_X86_64_GOTOFF64\0" as *const u8 as *const libc::c_char,
        26 => return b"R_X86_64_GOTPC32\0" as *const u8 as *const libc::c_char,
        27 => return b"R_X86_64_GOT64\0" as *const u8 as *const libc::c_char,
        28 => return b"R_X86_64_GOTPCREL64\0" as *const u8 as *const libc::c_char,
        29 => return b"R_X86_64_GOTPC64\0" as *const u8 as *const libc::c_char,
        30 => return b"R_X86_64_GOTPLT64\0" as *const u8 as *const libc::c_char,
        31 => return b"R_X86_64_PLTOFF64\0" as *const u8 as *const libc::c_char,
        32 => return b"R_X86_64_SIZE32\0" as *const u8 as *const libc::c_char,
        33 => return b"R_X86_64_SIZE64\0" as *const u8 as *const libc::c_char,
        34 => return b"R_X86_64_GOTPC32_TLSDESC\0" as *const u8 as *const libc::c_char,
        35 => return b"R_X86_64_TLSDESC_CALL\0" as *const u8 as *const libc::c_char,
        36 => return b"R_X86_64_TLSDESC\0" as *const u8 as *const libc::c_char,
        37 => return b"R_X86_64_IRELATIVE\0" as *const u8 as *const libc::c_char,
        38 => return b"R_X86_64_RELATIVE64\0" as *const u8 as *const libc::c_char,
        39 => return b"R_X86_64_PC32_BND\0" as *const u8 as *const libc::c_char,
        40 => return b"R_X86_64_PLT32_BND\0" as *const u8 as *const libc::c_char,
        41 => return b"R_X86_64_GOTPCRELX\0" as *const u8 as *const libc::c_char,
        42 => return b"R_X86_64_REX_GOTPCRELX\0" as *const u8 as *const libc::c_char,
        250 => return b"R_X86_64_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        251 => return b"R_X86_64_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_xc16x_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_XC16X_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_XC16X_ABS_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_XC16X_ABS_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_XC16X_ABS_32\0" as *const u8 as *const libc::c_char,
        4 => return b"R_XC16X_8_PCREL\0" as *const u8 as *const libc::c_char,
        5 => return b"R_XC16X_PAG\0" as *const u8 as *const libc::c_char,
        6 => return b"R_XC16X_POF\0" as *const u8 as *const libc::c_char,
        7 => return b"R_XC16X_SEG\0" as *const u8 as *const libc::c_char,
        8 => return b"R_XC16X_SOF\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_xgate_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_XGATE_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_XGATE_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_XGATE_PCREL_8\0" as *const u8 as *const libc::c_char,
        3 => return b"R_XGATE_16\0" as *const u8 as *const libc::c_char,
        4 => return b"R_XGATE_32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_XGATE_PCREL_16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_XGATE_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        7 => return b"R_XGATE_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        8 => return b"R_XGATE_24\0" as *const u8 as *const libc::c_char,
        9 => return b"R_XGATE_LO16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_XGATE_GPAGE\0" as *const u8 as *const libc::c_char,
        11 => return b"R_XGATE_PCREL_9\0" as *const u8 as *const libc::c_char,
        12 => return b"R_XGATE_PCREL_10\0" as *const u8 as *const libc::c_char,
        13 => return b"R_XGATE_IMM8_LO\0" as *const u8 as *const libc::c_char,
        14 => return b"R_XGATE_IMM8_HI\0" as *const u8 as *const libc::c_char,
        15 => return b"R_XGATE_IMM3\0" as *const u8 as *const libc::c_char,
        16 => return b"R_XGATE_IMM4\0" as *const u8 as *const libc::c_char,
        17 => return b"R_XGATE_IMM5\0" as *const u8 as *const libc::c_char,
        18 => return b"R_XGATE_RL_JUMP\0" as *const u8 as *const libc::c_char,
        19 => return b"R_XGATE_RL_GROUP\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_xstormy16_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_XSTORMY16_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_XSTORMY16_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_XSTORMY16_16\0" as *const u8 as *const libc::c_char,
        3 => return b"R_XSTORMY16_8\0" as *const u8 as *const libc::c_char,
        4 => return b"R_XSTORMY16_PC32\0" as *const u8 as *const libc::c_char,
        5 => return b"R_XSTORMY16_PC16\0" as *const u8 as *const libc::c_char,
        6 => return b"R_XSTORMY16_PC8\0" as *const u8 as *const libc::c_char,
        7 => return b"R_XSTORMY16_REL_12\0" as *const u8 as *const libc::c_char,
        8 => return b"R_XSTORMY16_24\0" as *const u8 as *const libc::c_char,
        9 => return b"R_XSTORMY16_FPTR16\0" as *const u8 as *const libc::c_char,
        10 => return b"R_XSTORMY16_LO16\0" as *const u8 as *const libc::c_char,
        11 => return b"R_XSTORMY16_HI16\0" as *const u8 as *const libc::c_char,
        12 => return b"R_XSTORMY16_12\0" as *const u8 as *const libc::c_char,
        128 => return b"R_XSTORMY16_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        129 => return b"R_XSTORMY16_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_xtensa_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_XTENSA_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_XTENSA_32\0" as *const u8 as *const libc::c_char,
        2 => return b"R_XTENSA_RTLD\0" as *const u8 as *const libc::c_char,
        3 => return b"R_XTENSA_GLOB_DAT\0" as *const u8 as *const libc::c_char,
        4 => return b"R_XTENSA_JMP_SLOT\0" as *const u8 as *const libc::c_char,
        5 => return b"R_XTENSA_RELATIVE\0" as *const u8 as *const libc::c_char,
        6 => return b"R_XTENSA_PLT\0" as *const u8 as *const libc::c_char,
        8 => return b"R_XTENSA_OP0\0" as *const u8 as *const libc::c_char,
        9 => return b"R_XTENSA_OP1\0" as *const u8 as *const libc::c_char,
        10 => return b"R_XTENSA_OP2\0" as *const u8 as *const libc::c_char,
        11 => return b"R_XTENSA_ASM_EXPAND\0" as *const u8 as *const libc::c_char,
        12 => return b"R_XTENSA_ASM_SIMPLIFY\0" as *const u8 as *const libc::c_char,
        14 => return b"R_XTENSA_32_PCREL\0" as *const u8 as *const libc::c_char,
        15 => return b"R_XTENSA_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
        16 => return b"R_XTENSA_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
        17 => return b"R_XTENSA_DIFF8\0" as *const u8 as *const libc::c_char,
        18 => return b"R_XTENSA_DIFF16\0" as *const u8 as *const libc::c_char,
        19 => return b"R_XTENSA_DIFF32\0" as *const u8 as *const libc::c_char,
        20 => return b"R_XTENSA_SLOT0_OP\0" as *const u8 as *const libc::c_char,
        21 => return b"R_XTENSA_SLOT1_OP\0" as *const u8 as *const libc::c_char,
        22 => return b"R_XTENSA_SLOT2_OP\0" as *const u8 as *const libc::c_char,
        23 => return b"R_XTENSA_SLOT3_OP\0" as *const u8 as *const libc::c_char,
        24 => return b"R_XTENSA_SLOT4_OP\0" as *const u8 as *const libc::c_char,
        25 => return b"R_XTENSA_SLOT5_OP\0" as *const u8 as *const libc::c_char,
        26 => return b"R_XTENSA_SLOT6_OP\0" as *const u8 as *const libc::c_char,
        27 => return b"R_XTENSA_SLOT7_OP\0" as *const u8 as *const libc::c_char,
        28 => return b"R_XTENSA_SLOT8_OP\0" as *const u8 as *const libc::c_char,
        29 => return b"R_XTENSA_SLOT9_OP\0" as *const u8 as *const libc::c_char,
        30 => return b"R_XTENSA_SLOT10_OP\0" as *const u8 as *const libc::c_char,
        31 => return b"R_XTENSA_SLOT11_OP\0" as *const u8 as *const libc::c_char,
        32 => return b"R_XTENSA_SLOT12_OP\0" as *const u8 as *const libc::c_char,
        33 => return b"R_XTENSA_SLOT13_OP\0" as *const u8 as *const libc::c_char,
        34 => return b"R_XTENSA_SLOT14_OP\0" as *const u8 as *const libc::c_char,
        35 => return b"R_XTENSA_SLOT0_ALT\0" as *const u8 as *const libc::c_char,
        36 => return b"R_XTENSA_SLOT1_ALT\0" as *const u8 as *const libc::c_char,
        37 => return b"R_XTENSA_SLOT2_ALT\0" as *const u8 as *const libc::c_char,
        38 => return b"R_XTENSA_SLOT3_ALT\0" as *const u8 as *const libc::c_char,
        39 => return b"R_XTENSA_SLOT4_ALT\0" as *const u8 as *const libc::c_char,
        40 => return b"R_XTENSA_SLOT5_ALT\0" as *const u8 as *const libc::c_char,
        41 => return b"R_XTENSA_SLOT6_ALT\0" as *const u8 as *const libc::c_char,
        42 => return b"R_XTENSA_SLOT7_ALT\0" as *const u8 as *const libc::c_char,
        43 => return b"R_XTENSA_SLOT8_ALT\0" as *const u8 as *const libc::c_char,
        44 => return b"R_XTENSA_SLOT9_ALT\0" as *const u8 as *const libc::c_char,
        45 => return b"R_XTENSA_SLOT10_ALT\0" as *const u8 as *const libc::c_char,
        46 => return b"R_XTENSA_SLOT11_ALT\0" as *const u8 as *const libc::c_char,
        47 => return b"R_XTENSA_SLOT12_ALT\0" as *const u8 as *const libc::c_char,
        48 => return b"R_XTENSA_SLOT13_ALT\0" as *const u8 as *const libc::c_char,
        49 => return b"R_XTENSA_SLOT14_ALT\0" as *const u8 as *const libc::c_char,
        50 => return b"R_XTENSA_TLSDESC_FN\0" as *const u8 as *const libc::c_char,
        51 => return b"R_XTENSA_TLSDESC_ARG\0" as *const u8 as *const libc::c_char,
        52 => return b"R_XTENSA_TLS_DTPOFF\0" as *const u8 as *const libc::c_char,
        53 => return b"R_XTENSA_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
        54 => return b"R_XTENSA_TLS_FUNC\0" as *const u8 as *const libc::c_char,
        55 => return b"R_XTENSA_TLS_ARG\0" as *const u8 as *const libc::c_char,
        56 => return b"R_XTENSA_TLS_CALL\0" as *const u8 as *const libc::c_char,
        57 => return b"R_XTENSA_PDIFF8\0" as *const u8 as *const libc::c_char,
        58 => return b"R_XTENSA_PDIFF16\0" as *const u8 as *const libc::c_char,
        59 => return b"R_XTENSA_PDIFF32\0" as *const u8 as *const libc::c_char,
        60 => return b"R_XTENSA_NDIFF8\0" as *const u8 as *const libc::c_char,
        61 => return b"R_XTENSA_NDIFF16\0" as *const u8 as *const libc::c_char,
        62 => return b"R_XTENSA_NDIFF32\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn elf_z80_reloc_type(
    mut rtype: libc::c_ulong,
) -> *const libc::c_char {
    match rtype {
        0 => return b"R_Z80_NONE\0" as *const u8 as *const libc::c_char,
        1 => return b"R_Z80_8\0" as *const u8 as *const libc::c_char,
        2 => return b"R_Z80_8_DIS\0" as *const u8 as *const libc::c_char,
        3 => return b"R_Z80_8_PCREL\0" as *const u8 as *const libc::c_char,
        4 => return b"R_Z80_16\0" as *const u8 as *const libc::c_char,
        5 => return b"R_Z80_24\0" as *const u8 as *const libc::c_char,
        6 => return b"R_Z80_32\0" as *const u8 as *const libc::c_char,
        7 => return b"R_Z80_BYTE0\0" as *const u8 as *const libc::c_char,
        8 => return b"R_Z80_BYTE1\0" as *const u8 as *const libc::c_char,
        9 => return b"R_Z80_BYTE2\0" as *const u8 as *const libc::c_char,
        10 => return b"R_Z80_BYTE3\0" as *const u8 as *const libc::c_char,
        11 => return b"R_Z80_WORD0\0" as *const u8 as *const libc::c_char,
        12 => return b"R_Z80_WORD1\0" as *const u8 as *const libc::c_char,
        13 => return b"R_Z80_16_BE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
static mut cmdline: dump_data = dump_data {
    dump_sects: 0 as *const dump_type as *mut dump_type,
    num_dump_sects: 0,
};
static mut dump_sects_byname: *mut dump_list_entry = 0 as *const dump_list_entry
    as *mut dump_list_entry;
static mut show_name: bool = 0 as libc::c_int != 0;
static mut do_dynamic: bool = 0 as libc::c_int != 0;
static mut do_syms: bool = 0 as libc::c_int != 0;
static mut do_dyn_syms: bool = 0 as libc::c_int != 0;
static mut do_lto_syms: bool = 0 as libc::c_int != 0;
static mut do_reloc: bool = 0 as libc::c_int != 0;
static mut do_sections: bool = 0 as libc::c_int != 0;
static mut do_section_groups: bool = 0 as libc::c_int != 0;
static mut do_section_details: bool = 0 as libc::c_int != 0;
static mut do_segments: bool = 0 as libc::c_int != 0;
static mut do_unwind: bool = 0 as libc::c_int != 0;
static mut do_using_dynamic: bool = 0 as libc::c_int != 0;
static mut do_header: bool = 0 as libc::c_int != 0;
static mut do_dump: bool = 0 as libc::c_int != 0;
static mut do_version: bool = 0 as libc::c_int != 0;
static mut do_histogram: bool = 0 as libc::c_int != 0;
static mut do_debugging: bool = 0 as libc::c_int != 0;
static mut do_ctf: bool = 0 as libc::c_int != 0;
static mut do_arch: bool = 0 as libc::c_int != 0;
static mut do_notes: bool = 0 as libc::c_int != 0;
static mut do_archive_index: bool = 0 as libc::c_int != 0;
static mut check_all: bool = 0 as libc::c_int != 0;
static mut is_32bit_elf: bool = 0 as libc::c_int != 0;
static mut decompress_dumps: bool = 0 as libc::c_int != 0;
static mut do_not_show_symbol_truncation: bool = 0 as libc::c_int != 0;
static mut do_demangle: bool = 0 as libc::c_int != 0;
static mut process_links: bool = 0 as libc::c_int != 0;
static mut demangle_flags: libc::c_int = (1 as libc::c_int) << 1 as libc::c_int
    | (1 as libc::c_int) << 0 as libc::c_int;
static mut sym_base: libc::c_int = 0 as libc::c_int;
static mut dump_ctf_parent_name: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
static mut dump_ctf_symtab_name: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
static mut dump_ctf_strtab_name: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
unsafe extern "C" fn get_symbol_version_string(
    mut filedata: *mut Filedata,
    mut is_dynsym: bool,
    mut strtab: *const libc::c_char,
    mut strtab_size: libc::c_ulong,
    mut si: libc::c_uint,
    mut psym: *mut Elf_Internal_Sym,
    mut sym_info: *mut versioned_symbol_info,
    mut vna_other: *mut libc::c_ushort,
) -> *const libc::c_char {
    let mut data: [libc::c_uchar; 2] = [0; 2];
    let mut vers_data: libc::c_ushort = 0;
    let mut offset: libc::c_ulong = 0;
    let mut max_vd_ndx: libc::c_ushort = 0;
    if !is_dynsym
        || (*filedata)
            .version_info[(0x6fffffff as libc::c_int - 0x6ffffff0 as libc::c_int)
            as usize] == 0 as libc::c_int as libc::c_ulong
    {
        return 0 as *const libc::c_char;
    }
    offset = offset_from_vma(
        filedata,
        (*filedata)
            .version_info[(0x6fffffff as libc::c_int - 0x6ffffff0 as libc::c_int)
            as usize],
        (::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong)
            .wrapping_add(
                (si as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,
                    ),
            ),
    ) as libc::c_ulong;
    if (get_data(
        &mut data as *mut [libc::c_uchar; 2] as *mut libc::c_void,
        filedata,
        offset
            .wrapping_add(
                (si as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,
                    ),
            ),
        ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong,
        1 as libc::c_int as bfd_size_type,
        dcgettext(
            0 as *const libc::c_char,
            b"version data\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ))
        .is_null()
    {
        return 0 as *const libc::c_char;
    }
    vers_data = byte_get
        .expect(
            "non-null function pointer",
        )(data.as_mut_ptr(), 2 as libc::c_int as libc::c_uint) as libc::c_ushort;
    if vers_data as libc::c_int & 0x8000 as libc::c_int == 0 as libc::c_int
        && vers_data as libc::c_int == 0 as libc::c_int
    {
        return 0 as *const libc::c_char;
    }
    *sym_info = (if vers_data as libc::c_int & 0x8000 as libc::c_int != 0 as libc::c_int
    {
        symbol_hidden as libc::c_int
    } else {
        symbol_public as libc::c_int
    }) as versioned_symbol_info;
    max_vd_ndx = 0 as libc::c_int as libc::c_ushort;
    if (*psym).st_shndx != 0 as libc::c_int as libc::c_uint
        && vers_data as libc::c_int != 0x8001 as libc::c_int
        && (*filedata)
            .version_info[(0x6fffffff as libc::c_int - 0x6ffffffc as libc::c_int)
            as usize] != 0
    {
        let mut ivd: Elf_Internal_Verdef = Elf_Internal_Verdef {
            vd_version: 0,
            vd_flags: 0,
            vd_ndx: 0,
            vd_cnt: 0,
            vd_hash: 0,
            vd_aux: 0,
            vd_next: 0,
            vd_bfd: 0 as *mut bfd,
            vd_nodename: 0 as *const libc::c_char,
            vd_nextdef: 0 as *mut elf_internal_verdef,
            vd_auxptr: 0 as *mut elf_internal_verdaux,
            vd_exp_refno: 0,
        };
        let mut ivda: Elf_Internal_Verdaux = Elf_Internal_Verdaux {
            vda_name: 0,
            vda_next: 0,
            vda_nodename: 0 as *const libc::c_char,
            vda_nextptr: 0 as *mut elf_internal_verdaux,
        };
        let mut evda: Elf_External_Verdaux = Elf_External_Verdaux {
            vda_name: [0; 4],
            vda_next: [0; 4],
        };
        let mut off: libc::c_ulong = 0;
        off = offset_from_vma(
            filedata,
            (*filedata)
                .version_info[(0x6fffffff as libc::c_int - 0x6ffffffc as libc::c_int)
                as usize],
            ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong,
        ) as libc::c_ulong;
        loop {
            let mut evd: Elf_External_Verdef = Elf_External_Verdef {
                vd_version: [0; 2],
                vd_flags: [0; 2],
                vd_ndx: [0; 2],
                vd_cnt: [0; 2],
                vd_hash: [0; 4],
                vd_aux: [0; 4],
                vd_next: [0; 4],
            };
            if (get_data(
                &mut evd as *mut Elf_External_Verdef as *mut libc::c_void,
                filedata,
                off,
                ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                dcgettext(
                    0 as *const libc::c_char,
                    b"version def\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ))
                .is_null()
            {
                ivd.vd_ndx = 0 as libc::c_int as libc::c_ushort;
                ivd.vd_aux = 0 as libc::c_int as libc::c_ulong;
                ivd.vd_next = 0 as libc::c_int as libc::c_ulong;
                ivd.vd_flags = 0 as libc::c_int as libc::c_ushort;
            } else {
                ivd
                    .vd_ndx = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (evd.vd_ndx).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_ushort;
                ivd
                    .vd_aux = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (evd.vd_aux).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                ivd
                    .vd_next = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (evd.vd_next).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                ivd
                    .vd_flags = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (evd.vd_flags).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_ushort;
            }
            if ivd.vd_ndx as libc::c_int & 0x7fff as libc::c_int
                > max_vd_ndx as libc::c_int
            {
                max_vd_ndx = (ivd.vd_ndx as libc::c_int & 0x7fff as libc::c_int)
                    as libc::c_ushort;
            }
            off = off.wrapping_add(ivd.vd_next);
            if !(ivd.vd_ndx as libc::c_int
                != vers_data as libc::c_int & 0x7fff as libc::c_int
                && ivd.vd_next != 0 as libc::c_int as libc::c_ulong)
            {
                break;
            }
        }
        if ivd.vd_ndx as libc::c_int == vers_data as libc::c_int & 0x7fff as libc::c_int
        {
            if ivd.vd_ndx as libc::c_int == 1 as libc::c_int
                && ivd.vd_flags as libc::c_int == 0x1 as libc::c_int
            {
                return 0 as *const libc::c_char;
            }
            off = off.wrapping_sub(ivd.vd_next);
            off = off.wrapping_add(ivd.vd_aux);
            if !(get_data(
                &mut evda as *mut Elf_External_Verdaux as *mut libc::c_void,
                filedata,
                off,
                ::core::mem::size_of::<Elf_External_Verdaux>() as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                dcgettext(
                    0 as *const libc::c_char,
                    b"version def aux\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ))
                .is_null()
            {
                ivda
                    .vda_name = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (evda.vda_name).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                if (*psym).st_name != ivda.vda_name {
                    return if ivda.vda_name < strtab_size {
                        strtab.offset(ivda.vda_name as isize)
                    } else {
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<corrupt>\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ) as *const libc::c_char
                    };
                }
            }
        }
    }
    if (*filedata)
        .version_info[(0x6fffffff as libc::c_int - 0x6ffffffe as libc::c_int) as usize]
        != 0
    {
        let mut evn: Elf_External_Verneed = Elf_External_Verneed {
            vn_version: [0; 2],
            vn_cnt: [0; 2],
            vn_file: [0; 4],
            vn_aux: [0; 4],
            vn_next: [0; 4],
        };
        let mut ivn: Elf_Internal_Verneed = Elf_Internal_Verneed {
            vn_version: 0,
            vn_cnt: 0,
            vn_file: 0,
            vn_aux: 0,
            vn_next: 0,
            vn_bfd: 0 as *mut bfd,
            vn_filename: 0 as *const libc::c_char,
            vn_auxptr: 0 as *mut elf_internal_vernaux,
            vn_nextref: 0 as *mut elf_internal_verneed,
        };
        let mut ivna: Elf_Internal_Vernaux = Elf_Internal_Vernaux {
            vna_hash: 0,
            vna_flags: 0,
            vna_other: 0,
            vna_name: 0,
            vna_next: 0,
            vna_nodename: 0 as *const libc::c_char,
            vna_nextptr: 0 as *mut elf_internal_vernaux,
        };
        offset = offset_from_vma(
            filedata,
            (*filedata)
                .version_info[(0x6fffffff as libc::c_int - 0x6ffffffe as libc::c_int)
                as usize],
            ::core::mem::size_of::<Elf_External_Verneed>() as libc::c_ulong,
        ) as libc::c_ulong;
        loop {
            let mut vna_off: libc::c_ulong = 0;
            if (get_data(
                &mut evn as *mut Elf_External_Verneed as *mut libc::c_void,
                filedata,
                offset,
                ::core::mem::size_of::<Elf_External_Verneed>() as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                dcgettext(
                    0 as *const libc::c_char,
                    b"version need\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ))
                .is_null()
            {
                ivna.vna_next = 0 as libc::c_int as libc::c_ulong;
                ivna.vna_other = 0 as libc::c_int as libc::c_ushort;
                ivna.vna_name = 0 as libc::c_int as libc::c_ulong;
                break;
            } else {
                ivn
                    .vn_aux = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (evn.vn_aux).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                ivn
                    .vn_next = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (evn.vn_next).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                vna_off = offset.wrapping_add(ivn.vn_aux);
                loop {
                    let mut evna: Elf_External_Vernaux = Elf_External_Vernaux {
                        vna_hash: [0; 4],
                        vna_flags: [0; 2],
                        vna_other: [0; 2],
                        vna_name: [0; 4],
                        vna_next: [0; 4],
                    };
                    if (get_data(
                        &mut evna as *mut Elf_External_Vernaux as *mut libc::c_void,
                        filedata,
                        vna_off,
                        ::core::mem::size_of::<Elf_External_Vernaux>() as libc::c_ulong,
                        1 as libc::c_int as bfd_size_type,
                        dcgettext(
                            0 as *const libc::c_char,
                            b"version need aux (3)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    ))
                        .is_null()
                    {
                        ivna.vna_next = 0 as libc::c_int as libc::c_ulong;
                        ivna.vna_other = 0 as libc::c_int as libc::c_ushort;
                        ivna.vna_name = 0 as libc::c_int as libc::c_ulong;
                    } else {
                        ivna
                            .vna_other = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            (evna.vna_other).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                                as libc::c_uint,
                        ) as libc::c_ushort;
                        ivna
                            .vna_next = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            (evna.vna_next).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        ivna
                            .vna_name = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            (evna.vna_name).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                    }
                    vna_off = vna_off.wrapping_add(ivna.vna_next);
                    if !(ivna.vna_other as libc::c_int != vers_data as libc::c_int
                        && ivna.vna_next != 0 as libc::c_int as libc::c_ulong)
                    {
                        break;
                    }
                }
                if ivna.vna_other as libc::c_int == vers_data as libc::c_int {
                    break;
                }
                offset = offset.wrapping_add(ivn.vn_next);
                if !(ivn.vn_next != 0 as libc::c_int as libc::c_ulong) {
                    break;
                }
            }
        }
        if ivna.vna_other as libc::c_int == vers_data as libc::c_int {
            *sym_info = symbol_undefined;
            *vna_other = ivna.vna_other;
            return if ivna.vna_name < strtab_size {
                strtab.offset(ivna.vna_name as isize)
            } else {
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ) as *const libc::c_char
            };
        } else if (max_vd_ndx as libc::c_int != 0
            || vers_data as libc::c_int & 0x7fff as libc::c_int != 1 as libc::c_int)
            && vers_data as libc::c_int & 0x7fff as libc::c_int
                > max_vd_ndx as libc::c_int
        {
            return dcgettext(
                0 as *const libc::c_char,
                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        }
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn bfd_vmatoa(
    mut fmtch: *mut libc::c_char,
    mut value: bfd_vma,
) -> *const libc::c_char {
    static mut buf_pos: libc::c_int = 0 as libc::c_int;
    static mut buf: [bfd_vmatoa_buf; 4] = [bfd_vmatoa_buf { place: [0; 64] }; 4];
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fmt: [libc::c_char; 32] = [0; 32];
    let fresh0 = buf_pos;
    buf_pos = buf_pos + 1;
    ret = (buf[fresh0 as usize].place).as_mut_ptr();
    buf_pos = (buf_pos as libc::c_ulong)
        .wrapping_rem(
            (::core::mem::size_of::<[bfd_vmatoa_buf; 4]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<bfd_vmatoa_buf>() as libc::c_ulong),
        ) as libc::c_int as libc::c_int;
    sprintf(
        fmt.as_mut_ptr(),
        b"%%%s%s\0" as *const u8 as *const libc::c_char,
        b"l\0" as *const u8 as *const libc::c_char,
        fmtch,
    );
    snprintf(
        ret,
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        fmt.as_mut_ptr(),
        value,
    );
    return ret;
}
unsafe extern "C" fn get_data(
    mut var: *mut libc::c_void,
    mut filedata: *mut Filedata,
    mut offset: libc::c_ulong,
    mut size: bfd_size_type,
    mut nmemb: bfd_size_type,
    mut reason: *const libc::c_char,
) -> *mut libc::c_void {
    let mut mvar: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut amt: bfd_size_type = size.wrapping_mul(nmemb);
    if size == 0 as libc::c_int as libc::c_ulong
        || nmemb == 0 as libc::c_int as libc::c_ulong
    {
        return 0 as *mut libc::c_void;
    }
    if size != size || nmemb != nmemb || amt != amt {
        if !reason.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Size truncation prevents reading %s elements of size %s for %s\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                bfd_vmatoa(
                    b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    nmemb,
                ),
                bfd_vmatoa(
                    b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    size,
                ),
                reason,
            );
        }
        return 0 as *mut libc::c_void;
    }
    if amt.wrapping_div(size) != nmemb
        || amt.wrapping_add(1 as libc::c_int as libc::c_ulong)
            == 0 as libc::c_int as libc::c_ulong
    {
        if !reason.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Size overflow prevents reading %s elements of size %s for %s\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                bfd_vmatoa(
                    b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    nmemb,
                ),
                bfd_vmatoa(
                    b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    size,
                ),
                reason,
            );
        }
        return 0 as *mut libc::c_void;
    }
    if (*filedata).archive_file_offset > (*filedata).file_size
        || offset > ((*filedata).file_size).wrapping_sub((*filedata).archive_file_offset)
        || amt
            > ((*filedata).file_size)
                .wrapping_sub((*filedata).archive_file_offset)
                .wrapping_sub(offset)
    {
        if !reason.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Reading %s bytes extends past end of file for %s\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                bfd_vmatoa(
                    b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    amt,
                ),
                reason,
            );
        }
        return 0 as *mut libc::c_void;
    }
    if fseek(
        (*filedata).handle,
        ((*filedata).archive_file_offset).wrapping_add(offset) as libc::c_long,
        0 as libc::c_int,
    ) != 0
    {
        if !reason.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unable to seek to 0x%lx for %s\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                ((*filedata).archive_file_offset).wrapping_add(offset),
                reason,
            );
        }
        return 0 as *mut libc::c_void;
    }
    mvar = var;
    if mvar.is_null() {
        mvar = malloc(amt.wrapping_add(1 as libc::c_int as libc::c_ulong));
        if mvar.is_null() {
            if !reason.is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Out of memory allocating %s bytes for %s\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    bfd_vmatoa(
                        b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                        amt,
                    ),
                    reason,
                );
            }
            return 0 as *mut libc::c_void;
        }
        *(mvar as *mut libc::c_char).offset(amt as isize) = '\0' as i32 as libc::c_char;
    }
    if fread(mvar, size, nmemb, (*filedata).handle) != nmemb {
        if !reason.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unable to read in %s bytes of %s\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                bfd_vmatoa(
                    b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    amt,
                ),
                reason,
            );
        }
        if mvar != var {
            free(mvar);
        }
        return 0 as *mut libc::c_void;
    }
    return mvar;
}
unsafe extern "C" fn print_vma(mut vma: bfd_vma, mut mode: print_mode) -> libc::c_uint {
    let mut nc: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut current_block_16: u64;
    match mode as libc::c_uint {
        8 => {
            nc = printf(b"0x\0" as *const u8 as *const libc::c_char) as libc::c_uint;
            current_block_16 = 440458735126116356;
        }
        9 => {
            current_block_16 = 440458735126116356;
        }
        3 => {
            if vma <= 99999 as libc::c_int as libc::c_ulong {
                return printf(b"%5ld\0" as *const u8 as *const libc::c_char, vma)
                    as libc::c_uint;
            }
            current_block_16 = 8822202253849485291;
        }
        6 => {
            current_block_16 = 8822202253849485291;
        }
        0 => {
            current_block_16 = 2958930358923157166;
        }
        7 => {
            nc = printf(b"0x\0" as *const u8 as *const libc::c_char) as libc::c_uint;
            current_block_16 = 4774627978064054392;
        }
        1 => {
            current_block_16 = 4774627978064054392;
        }
        2 => {
            return printf(b"%ld\0" as *const u8 as *const libc::c_char, vma)
                as libc::c_uint;
        }
        4 => {
            return printf(b"%lu\0" as *const u8 as *const libc::c_char, vma)
                as libc::c_uint;
        }
        5 => {
            return printf(b"%5lu\0" as *const u8 as *const libc::c_char, vma)
                as libc::c_uint;
        }
        10 => {
            return printf(b"%lo\0" as *const u8 as *const libc::c_char, vma)
                as libc::c_uint;
        }
        11 => {
            return printf(b"%5lo\0" as *const u8 as *const libc::c_char, vma)
                as libc::c_uint;
        }
        _ => return 0 as libc::c_int as libc::c_uint,
    }
    match current_block_16 {
        440458735126116356 => {
            if is_32bit_elf {
                return nc
                    .wrapping_add(
                        printf(b"%8.8lx\0" as *const u8 as *const libc::c_char, vma)
                            as libc::c_uint,
                    );
            }
            fprintf(stdout, b"%016lx\0" as *const u8 as *const libc::c_char, vma);
            return nc.wrapping_add(16 as libc::c_int as libc::c_uint);
        }
        8822202253849485291 => {
            nc = printf(b"0x\0" as *const u8 as *const libc::c_char) as libc::c_uint;
        }
        4774627978064054392 => {
            return nc
                .wrapping_add(
                    printf(b"%05lx\0" as *const u8 as *const libc::c_char, vma)
                        as libc::c_uint,
                );
        }
        _ => {}
    }
    return nc
        .wrapping_add(
            printf(b"%lx\0" as *const u8 as *const libc::c_char, vma) as libc::c_uint,
        );
}
unsafe extern "C" fn print_symbol(
    mut width: libc::c_int,
    mut symbol: *const libc::c_char,
) -> libc::c_uint {
    let mut extra_padding: bool = 0 as libc::c_int != 0;
    let mut do_dots: bool = 0 as libc::c_int != 0;
    let mut num_printed: libc::c_int = 0 as libc::c_int;
    let mut state: mbstate_t = mbstate_t {
        __count: 0,
        __value: C2RustUnnamed { __wch: 0 },
    };
    let mut width_remaining: libc::c_uint = 0;
    let mut alloced_symbol: *const libc::c_void = 0 as *const libc::c_void;
    if width < 0 as libc::c_int {
        width = -width;
        extra_padding = 1 as libc::c_int != 0;
    } else if width == 0 as libc::c_int {
        return 0 as libc::c_int as libc::c_uint
    }
    if do_wide != 0 {
        width_remaining = 2147483647 as libc::c_int as libc::c_uint;
    } else {
        width_remaining = width as libc::c_uint;
        if !do_not_show_symbol_truncation && strlen(symbol) as libc::c_int > width {
            width_remaining = width_remaining
                .wrapping_sub(5 as libc::c_int as libc::c_uint);
            if (width_remaining as libc::c_int) < 0 as libc::c_int {
                width_remaining = 0 as libc::c_int as libc::c_uint;
            }
            do_dots = 1 as libc::c_int != 0;
        }
    }
    memset(
        &mut state as *mut mbstate_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,
    );
    if do_demangle as libc::c_int != 0 && *symbol as libc::c_int != 0 {
        let mut res: *const libc::c_char = cplus_demangle(symbol, demangle_flags);
        if !res.is_null() {
            symbol = res;
            alloced_symbol = symbol as *const libc::c_void;
        }
    }
    while width_remaining != 0 {
        let mut n: size_t = 0;
        let fresh1 = symbol;
        symbol = symbol.offset(1);
        let c: libc::c_char = *fresh1;
        if c as libc::c_int == 0 as libc::c_int {
            break;
        }
        if _sch_istable[(c as libc::c_int & 0xff as libc::c_int) as usize] as libc::c_int
            & _sch_iscntrl as libc::c_int as libc::c_ushort as libc::c_int != 0
        {
            if width_remaining < 2 as libc::c_int as libc::c_uint {
                break;
            }
            printf(
                b"^%c\0" as *const u8 as *const libc::c_char,
                c as libc::c_int + 0x40 as libc::c_int,
            );
            width_remaining = width_remaining
                .wrapping_sub(2 as libc::c_int as libc::c_uint);
            num_printed += 2 as libc::c_int;
        } else if _sch_istable[(c as libc::c_int & 0xff as libc::c_int) as usize]
            as libc::c_int & _sch_isprint as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            putchar(c as libc::c_int);
            width_remaining = width_remaining.wrapping_sub(1);
            width_remaining;
            num_printed += 1;
            num_printed;
        } else {
            let mut w: wchar_t = 0;
            printf(
                b"%.1s\0" as *const u8 as *const libc::c_char,
                symbol.offset(-(1 as libc::c_int as isize)),
            );
            width_remaining = width_remaining.wrapping_sub(1);
            width_remaining;
            num_printed += 1;
            num_printed;
            n = mbrtowc(
                &mut w,
                symbol.offset(-(1 as libc::c_int as isize)),
                __ctype_get_mb_cur_max(),
                &mut state,
            );
            if n != -(1 as libc::c_int) as size_t && n != -(2 as libc::c_int) as size_t
                && n > 0 as libc::c_int as libc::c_ulong
            {
                symbol = symbol
                    .offset(n.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize);
            }
        }
    }
    if do_dots {
        num_printed += printf(b"[...]\0" as *const u8 as *const libc::c_char);
    }
    if extra_padding as libc::c_int != 0 && num_printed < width {
        printf(
            b"%-*s\0" as *const u8 as *const libc::c_char,
            width - num_printed,
            b" \0" as *const u8 as *const libc::c_char,
        );
        num_printed = width;
    }
    free(alloced_symbol as *mut libc::c_void);
    return num_printed as libc::c_uint;
}
unsafe extern "C" fn printable_section_name(
    mut filedata: *mut Filedata,
    mut sec: *const Elf_Internal_Shdr,
) -> *const libc::c_char {
    static mut sec_name_buf: [libc::c_char; 257] = [0; 257];
    let mut name: *const libc::c_char = if sec.is_null() {
        dcgettext(
            0 as *const libc::c_char,
            b"<none>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        )
    } else if ((*filedata).string_table).is_null() {
        dcgettext(
            0 as *const libc::c_char,
            b"<no-strings>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        )
    } else if (*sec).sh_name as libc::c_ulong >= (*filedata).string_table_length {
        dcgettext(
            0 as *const libc::c_char,
            b"<corrupt>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        )
    } else {
        ((*filedata).string_table).offset((*sec).sh_name as isize)
    };
    let mut buf: *mut libc::c_char = sec_name_buf.as_mut_ptr();
    let mut c: libc::c_char = 0;
    let mut remaining: libc::c_uint = 256 as libc::c_int as libc::c_uint;
    loop {
        let fresh2 = name;
        name = name.offset(1);
        c = *fresh2;
        if !(c as libc::c_int != 0 as libc::c_int) {
            break;
        }
        if _sch_istable[(c as libc::c_int & 0xff as libc::c_int) as usize] as libc::c_int
            & _sch_iscntrl as libc::c_int as libc::c_ushort as libc::c_int != 0
        {
            if remaining < 2 as libc::c_int as libc::c_uint {
                break;
            }
            let fresh3 = buf;
            buf = buf.offset(1);
            *fresh3 = '^' as i32 as libc::c_char;
            let fresh4 = buf;
            buf = buf.offset(1);
            *fresh4 = (c as libc::c_int + 0x40 as libc::c_int) as libc::c_char;
            remaining = remaining.wrapping_sub(2 as libc::c_int as libc::c_uint);
        } else if _sch_istable[(c as libc::c_int & 0xff as libc::c_int) as usize]
            as libc::c_int & _sch_isprint as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            let fresh5 = buf;
            buf = buf.offset(1);
            *fresh5 = c;
            remaining = remaining.wrapping_sub(1 as libc::c_int as libc::c_uint);
        } else {
            static mut hex: [libc::c_char; 17] = unsafe {
                *::core::mem::transmute::<
                    &[u8; 17],
                    &mut [libc::c_char; 17],
                >(b"0123456789ABCDEF\0")
            };
            if remaining < 4 as libc::c_int as libc::c_uint {
                break;
            }
            let fresh6 = buf;
            buf = buf.offset(1);
            *fresh6 = '<' as i32 as libc::c_char;
            let fresh7 = buf;
            buf = buf.offset(1);
            *fresh7 = hex[((c as libc::c_int & 0xf0 as libc::c_int) >> 4 as libc::c_int)
                as usize];
            let fresh8 = buf;
            buf = buf.offset(1);
            *fresh8 = hex[(c as libc::c_int & 0xf as libc::c_int) as usize];
            let fresh9 = buf;
            buf = buf.offset(1);
            *fresh9 = '>' as i32 as libc::c_char;
            remaining = remaining.wrapping_sub(4 as libc::c_int as libc::c_uint);
        }
        if remaining == 0 as libc::c_int as libc::c_uint {
            break;
        }
    }
    *buf = 0 as libc::c_int as libc::c_char;
    return sec_name_buf.as_mut_ptr();
}
unsafe extern "C" fn printable_section_name_from_index(
    mut filedata: *mut Filedata,
    mut ndx: libc::c_ulong,
) -> *const libc::c_char {
    if ndx >= (*filedata).file_header.e_shnum as libc::c_ulong {
        return dcgettext(
            0 as *const libc::c_char,
            b"<corrupt>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        );
    }
    return printable_section_name(
        filedata,
        ((*filedata).section_headers).offset(ndx as isize),
    );
}
unsafe extern "C" fn find_section(
    mut filedata: *mut Filedata,
    mut name: *const libc::c_char,
) -> *mut Elf_Internal_Shdr {
    let mut i: libc::c_uint = 0;
    if ((*filedata).section_headers).is_null() {
        return 0 as *mut Elf_Internal_Shdr;
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*filedata).file_header.e_shnum {
        if !((*filedata).section_headers).offset(i as isize).is_null()
            && !((*filedata).string_table).is_null()
            && ((*((*filedata).section_headers).offset(i as isize)).sh_name
                as libc::c_ulong) < (*filedata).string_table_length
            && strcmp(
                ((*filedata).string_table)
                    .offset(
                        (*((*filedata).section_headers).offset(i as isize)).sh_name
                            as isize,
                    ),
                name,
            ) == 0 as libc::c_int
        {
            return ((*filedata).section_headers).offset(i as isize);
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as *mut Elf_Internal_Shdr;
}
unsafe extern "C" fn find_section_by_address(
    mut filedata: *mut Filedata,
    mut addr: bfd_vma,
) -> *mut Elf_Internal_Shdr {
    let mut i: libc::c_uint = 0;
    if ((*filedata).section_headers).is_null() {
        return 0 as *mut Elf_Internal_Shdr;
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*filedata).file_header.e_shnum {
        let mut sec: *mut Elf_Internal_Shdr = ((*filedata).section_headers)
            .offset(i as isize);
        if addr >= (*sec).sh_addr && addr < ((*sec).sh_addr).wrapping_add((*sec).sh_size)
        {
            return sec;
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as *mut Elf_Internal_Shdr;
}
unsafe extern "C" fn find_section_by_type(
    mut filedata: *mut Filedata,
    mut type_0: libc::c_uint,
) -> *mut Elf_Internal_Shdr {
    let mut i: libc::c_uint = 0;
    if ((*filedata).section_headers).is_null() {
        return 0 as *mut Elf_Internal_Shdr;
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*filedata).file_header.e_shnum {
        let mut sec: *mut Elf_Internal_Shdr = ((*filedata).section_headers)
            .offset(i as isize);
        if (*sec).sh_type == type_0 {
            return sec;
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as *mut Elf_Internal_Shdr;
}
unsafe extern "C" fn find_section_in_set(
    mut filedata: *mut Filedata,
    mut name: *const libc::c_char,
    mut set: *mut libc::c_uint,
) -> *mut Elf_Internal_Shdr {
    let mut i: libc::c_uint = 0;
    if ((*filedata).section_headers).is_null() {
        return 0 as *mut Elf_Internal_Shdr;
    }
    if !set.is_null() {
        loop {
            let fresh10 = set;
            set = set.offset(1);
            i = *fresh10;
            if !(i > 0 as libc::c_int as libc::c_uint) {
                break;
            }
            if i >= (*filedata).file_header.e_shnum {
                continue;
            }
            if !((*filedata).section_headers).offset(i as isize).is_null()
                && !((*filedata).string_table).is_null()
                && ((*((*filedata).section_headers).offset(i as isize)).sh_name
                    as libc::c_ulong) < (*filedata).string_table_length
                && strcmp(
                    ((*filedata).string_table)
                        .offset(
                            (*((*filedata).section_headers).offset(i as isize)).sh_name
                                as isize,
                        ),
                    name,
                ) == 0 as libc::c_int
            {
                return ((*filedata).section_headers).offset(i as isize);
            }
        }
    }
    return find_section(filedata, name);
}
#[inline]
unsafe extern "C" fn is_ia64_vms(mut filedata: *mut Filedata) -> bool {
    return (*filedata).file_header.e_machine as libc::c_int == 50 as libc::c_int
        && (*filedata).file_header.e_ident[7 as libc::c_int as usize] as libc::c_int
            == 13 as libc::c_int;
}
unsafe extern "C" fn guess_is_rela(mut e_machine: libc::c_uint) -> bool {
    match e_machine {
        3 | 6 | 19 | 40 | 85 | 30288 | 23205 | 8 | 10 | 36929 | 135 | 115 | 250 | 247 => {
            return 0 as libc::c_int != 0;
        }
        4 | 7 | 183 | 4643 | 36902 | 113 | 45 | 93 | 195 | 83 | 4183 | 106 | 177 | 76
        | 114 | 252 | 86 | 30326 | 84 | 222 | 13104 | 21569 | 48 | 46 | 47 | 50 | 101
        | 33303 | 65210 | 138 | 65200 | 120 | 88 | 39 | 61453 | 174 | 80 | 90 | 57005
        | 89 | 48879 | 223 | 105 | 4185 | 9520 | 167 | 65211 | 92 | 21 | 20 | 144 | 243
        | 197 | 173 | 22 | 41872 | 42 | 2 | 18 | 43 | 23 | 140 | 191 | 188 | 36 | 87
        | 36992 | 75 | 221 | 62 | 180 | 181 | 44357 | 94 | 43975 | 189 | 47787
        | 16727 => return 1 as libc::c_int != 0,
        72 | 71 | 70 | 69 | 66 | 59 | 54 | 56 | 57 | 55 | 60 | 74 | 68 | 67 | 58 | 73
        | 61 | _ => {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Don't know about relocations on this machine architecture\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
    };
}
unsafe extern "C" fn slurp_rela_relocs(
    mut filedata: *mut Filedata,
    mut rel_offset: libc::c_ulong,
    mut rel_size: libc::c_ulong,
    mut relasp: *mut *mut Elf_Internal_Rela,
    mut nrelasp: *mut libc::c_ulong,
) -> bool {
    let mut relas: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut nrelas: size_t = 0;
    let mut i: libc::c_uint = 0;
    if is_32bit_elf {
        let mut erelas: *mut Elf32_External_Rela = 0 as *mut Elf32_External_Rela;
        erelas = get_data(
            0 as *mut libc::c_void,
            filedata,
            rel_offset,
            1 as libc::c_int as bfd_size_type,
            rel_size,
            dcgettext(
                0 as *const libc::c_char,
                b"32-bit relocation data\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        ) as *mut Elf32_External_Rela;
        if erelas.is_null() {
            return 0 as libc::c_int != 0;
        }
        nrelas = rel_size
            .wrapping_div(
                ::core::mem::size_of::<Elf32_External_Rela>() as libc::c_ulong,
            );
        relas = cmalloc(
            nrelas,
            ::core::mem::size_of::<Elf_Internal_Rela>() as libc::c_ulong,
        ) as *mut Elf_Internal_Rela;
        if relas.is_null() {
            free(erelas as *mut libc::c_void);
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"out of memory parsing relocs\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong) < nrelas {
            (*relas.offset(i as isize))
                .r_offset = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*erelas.offset(i as isize)).r_offset).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            );
            (*relas.offset(i as isize))
                .r_info = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*erelas.offset(i as isize)).r_info).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            );
            (*relas.offset(i as isize))
                .r_addend = byte_get_signed(
                ((*erelas.offset(i as isize)).r_addend).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            );
            i = i.wrapping_add(1);
            i;
        }
        free(erelas as *mut libc::c_void);
    } else {
        let mut erelas_0: *mut Elf64_External_Rela = 0 as *mut Elf64_External_Rela;
        erelas_0 = get_data(
            0 as *mut libc::c_void,
            filedata,
            rel_offset,
            1 as libc::c_int as bfd_size_type,
            rel_size,
            dcgettext(
                0 as *const libc::c_char,
                b"64-bit relocation data\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        ) as *mut Elf64_External_Rela;
        if erelas_0.is_null() {
            return 0 as libc::c_int != 0;
        }
        nrelas = rel_size
            .wrapping_div(
                ::core::mem::size_of::<Elf64_External_Rela>() as libc::c_ulong,
            );
        relas = cmalloc(
            nrelas,
            ::core::mem::size_of::<Elf_Internal_Rela>() as libc::c_ulong,
        ) as *mut Elf_Internal_Rela;
        if relas.is_null() {
            free(erelas_0 as *mut libc::c_void);
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"out of memory parsing relocs\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong) < nrelas {
            (*relas.offset(i as isize))
                .r_offset = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*erelas_0.offset(i as isize)).r_offset).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            );
            (*relas.offset(i as isize))
                .r_info = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*erelas_0.offset(i as isize)).r_info).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            );
            (*relas.offset(i as isize))
                .r_addend = byte_get_signed(
                ((*erelas_0.offset(i as isize)).r_addend).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            );
            if (*filedata).file_header.e_machine as libc::c_int == 8 as libc::c_int
                && (*filedata).file_header.e_ident[5 as libc::c_int as usize]
                    as libc::c_int != 2 as libc::c_int
            {
                let mut inf: bfd_vma = (*relas.offset(i as isize)).r_info;
                inf = (inf & 0xffffffff as libc::c_uint as libc::c_ulong)
                    << 32 as libc::c_int
                    | inf >> 56 as libc::c_int & 0xff as libc::c_int as libc::c_ulong
                    | inf >> 40 as libc::c_int & 0xff00 as libc::c_int as libc::c_ulong
                    | inf >> 24 as libc::c_int & 0xff0000 as libc::c_int as libc::c_ulong
                    | inf >> 8 as libc::c_int
                        & 0xff000000 as libc::c_uint as libc::c_ulong;
                (*relas.offset(i as isize)).r_info = inf;
            }
            i = i.wrapping_add(1);
            i;
        }
        free(erelas_0 as *mut libc::c_void);
    }
    *relasp = relas;
    *nrelasp = nrelas;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn slurp_rel_relocs(
    mut filedata: *mut Filedata,
    mut rel_offset: libc::c_ulong,
    mut rel_size: libc::c_ulong,
    mut relsp: *mut *mut Elf_Internal_Rela,
    mut nrelsp: *mut libc::c_ulong,
) -> bool {
    let mut rels: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut nrels: size_t = 0;
    let mut i: libc::c_uint = 0;
    if is_32bit_elf {
        let mut erels: *mut Elf32_External_Rel = 0 as *mut Elf32_External_Rel;
        erels = get_data(
            0 as *mut libc::c_void,
            filedata,
            rel_offset,
            1 as libc::c_int as bfd_size_type,
            rel_size,
            dcgettext(
                0 as *const libc::c_char,
                b"32-bit relocation data\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        ) as *mut Elf32_External_Rel;
        if erels.is_null() {
            return 0 as libc::c_int != 0;
        }
        nrels = rel_size
            .wrapping_div(::core::mem::size_of::<Elf32_External_Rel>() as libc::c_ulong);
        rels = cmalloc(
            nrels,
            ::core::mem::size_of::<Elf_Internal_Rela>() as libc::c_ulong,
        ) as *mut Elf_Internal_Rela;
        if rels.is_null() {
            free(erels as *mut libc::c_void);
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"out of memory parsing relocs\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong) < nrels {
            (*rels.offset(i as isize))
                .r_offset = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*erels.offset(i as isize)).r_offset).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            );
            (*rels.offset(i as isize))
                .r_info = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*erels.offset(i as isize)).r_info).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            );
            (*rels.offset(i as isize)).r_addend = 0 as libc::c_int as bfd_vma;
            i = i.wrapping_add(1);
            i;
        }
        free(erels as *mut libc::c_void);
    } else {
        let mut erels_0: *mut Elf64_External_Rel = 0 as *mut Elf64_External_Rel;
        erels_0 = get_data(
            0 as *mut libc::c_void,
            filedata,
            rel_offset,
            1 as libc::c_int as bfd_size_type,
            rel_size,
            dcgettext(
                0 as *const libc::c_char,
                b"64-bit relocation data\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        ) as *mut Elf64_External_Rel;
        if erels_0.is_null() {
            return 0 as libc::c_int != 0;
        }
        nrels = rel_size
            .wrapping_div(::core::mem::size_of::<Elf64_External_Rel>() as libc::c_ulong);
        rels = cmalloc(
            nrels,
            ::core::mem::size_of::<Elf_Internal_Rela>() as libc::c_ulong,
        ) as *mut Elf_Internal_Rela;
        if rels.is_null() {
            free(erels_0 as *mut libc::c_void);
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"out of memory parsing relocs\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong) < nrels {
            (*rels.offset(i as isize))
                .r_offset = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*erels_0.offset(i as isize)).r_offset).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            );
            (*rels.offset(i as isize))
                .r_info = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*erels_0.offset(i as isize)).r_info).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            );
            (*rels.offset(i as isize)).r_addend = 0 as libc::c_int as bfd_vma;
            if (*filedata).file_header.e_machine as libc::c_int == 8 as libc::c_int
                && (*filedata).file_header.e_ident[5 as libc::c_int as usize]
                    as libc::c_int != 2 as libc::c_int
            {
                let mut inf: bfd_vma = (*rels.offset(i as isize)).r_info;
                inf = (inf & 0xffffffff as libc::c_uint as libc::c_ulong)
                    << 32 as libc::c_int
                    | inf >> 56 as libc::c_int & 0xff as libc::c_int as libc::c_ulong
                    | inf >> 40 as libc::c_int & 0xff00 as libc::c_int as libc::c_ulong
                    | inf >> 24 as libc::c_int & 0xff0000 as libc::c_int as libc::c_ulong
                    | inf >> 8 as libc::c_int
                        & 0xff000000 as libc::c_uint as libc::c_ulong;
                (*rels.offset(i as isize)).r_info = inf;
            }
            i = i.wrapping_add(1);
            i;
        }
        free(erels_0 as *mut libc::c_void);
    }
    *relsp = rels;
    *nrelsp = nrels;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_reloc_type(
    mut filedata: *mut Filedata,
    mut reloc_info: bfd_vma,
) -> libc::c_uint {
    if is_32bit_elf {
        return (reloc_info & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
    }
    match (*filedata).file_header.e_machine as libc::c_int {
        8 => return (reloc_info & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint,
        43 => return (reloc_info & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint,
        _ => {
            return (reloc_info & 0xffffffff as libc::c_uint as libc::c_ulong)
                as libc::c_uint;
        }
    };
}
unsafe extern "C" fn get_reloc_symindex(mut reloc_info: bfd_vma) -> bfd_vma {
    return if is_32bit_elf as libc::c_int != 0 {
        reloc_info >> 8 as libc::c_int
    } else {
        reloc_info >> 32 as libc::c_int
    };
}
#[inline]
unsafe extern "C" fn uses_msp430x_relocs(mut filedata: *mut Filedata) -> bool {
    return (*filedata).file_header.e_machine as libc::c_int == 105 as libc::c_int
        && ((*filedata).file_header.e_flags & 0xff as libc::c_int as libc::c_ulong
            == 45 as libc::c_int as libc::c_ulong
            || (*filedata).file_header.e_ident[7 as libc::c_int as usize] as libc::c_int
                == 0 as libc::c_int);
}
unsafe extern "C" fn dump_relocations(
    mut filedata: *mut Filedata,
    mut rel_offset: libc::c_ulong,
    mut rel_size: libc::c_ulong,
    mut symtab: *mut Elf_Internal_Sym,
    mut nsyms: libc::c_ulong,
    mut strtab: *mut libc::c_char,
    mut strtablen: libc::c_ulong,
    mut is_rela: libc::c_int,
    mut is_dynsym: bool,
) -> bool {
    let mut i: libc::c_ulong = 0;
    let mut rels: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut res: bool = 1 as libc::c_int != 0;
    if is_rela == -(1 as libc::c_int) {
        is_rela = guess_is_rela((*filedata).file_header.e_machine as libc::c_uint)
            as libc::c_int;
    }
    if is_rela != 0 {
        if !slurp_rela_relocs(filedata, rel_offset, rel_size, &mut rels, &mut rel_size) {
            return 0 as libc::c_int != 0;
        }
    } else if !slurp_rel_relocs(
        filedata,
        rel_offset,
        rel_size,
        &mut rels,
        &mut rel_size,
    ) {
        return 0 as libc::c_int != 0
    }
    if is_32bit_elf {
        if is_rela != 0 {
            if do_wide != 0 {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
        } else if do_wide != 0 {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Offset     Info    Type                Sym. Value  Symbol's Name\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Offset     Info    Type            Sym.Value  Sym. Name\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
    } else if is_rela != 0 {
        if do_wide != 0 {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
    } else if do_wide != 0 {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"    Offset             Info             Type               Symbol's Value  Symbol's Name\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Offset          Info           Type           Sym. Value    Sym. Name\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    i = 0 as libc::c_int as libc::c_ulong;
    while i < rel_size {
        let mut rtype: *const libc::c_char = 0 as *const libc::c_char;
        let mut offset: bfd_vma = 0;
        let mut inf: bfd_vma = 0;
        let mut symtab_index: bfd_vma = 0;
        let mut type_0: bfd_vma = 0;
        offset = (*rels.offset(i as isize)).r_offset;
        inf = (*rels.offset(i as isize)).r_info;
        type_0 = get_reloc_type(filedata, inf) as bfd_vma;
        symtab_index = get_reloc_symindex(inf);
        if is_32bit_elf {
            printf(
                b"%8.8lx  %8.8lx \0" as *const u8 as *const libc::c_char,
                offset & 0xffffffff as libc::c_uint as libc::c_ulong,
                inf & 0xffffffff as libc::c_uint as libc::c_ulong,
            );
        } else {
            printf(
                if do_wide != 0 {
                    b"%16.16lx  %16.16lx \0" as *const u8 as *const libc::c_char
                } else {
                    b"%12.12lx  %12.12lx \0" as *const u8 as *const libc::c_char
                },
                offset,
                inf,
            );
        }
        let mut current_block_117: u64;
        match (*filedata).file_header.e_machine as libc::c_int {
            183 => {
                rtype = elf_aarch64_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            88 | 36929 => {
                rtype = elf_m32r_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            3 | 6 => {
                rtype = elf_i386_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            70 | 53 => {
                rtype = elf_m68hc11_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            19951 => {
                rtype = elf_s12z_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            4 => {
                rtype = elf_m68k_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            19 => {
                rtype = elf_i960_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            83 | 4183 => {
                rtype = elf_avr_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            11 | 18 | 43 | 2 => {
                rtype = elf_sparc_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            23 => {
                rtype = elf_spu_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            36 => {
                rtype = v800_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            87 | 36992 => {
                rtype = v850_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            85 | 30288 => {
                rtype = elf_d10v_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            86 | 30326 => {
                rtype = elf_d30v_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            23205 => {
                rtype = elf_dlx_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            42 => {
                rtype = elf_sh_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            89 | 48879 => {
                rtype = elf_mn10300_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            90 | 57005 => {
                rtype = elf_mn10200_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            84 | 13104 => {
                rtype = elf_fr30_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            21569 => {
                rtype = elf_frv_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            252 => {
                rtype = elf_csky_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            222 => {
                rtype = elf_ft32_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            39 => {
                rtype = elf_mcore_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            80 => {
                rtype = elf_mmix_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            223 => {
                rtype = elf_moxie_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            105 => {
                if uses_msp430x_relocs(filedata) {
                    rtype = elf_msp430x_reloc_type(type_0);
                    current_block_117 = 1228639923084383292;
                } else {
                    current_block_117 = 16906203418972200896;
                }
            }
            4185 => {
                current_block_117 = 16906203418972200896;
            }
            167 => {
                rtype = elf_nds32_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            20 => {
                rtype = elf_ppc_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            21 => {
                rtype = elf_ppc64_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            8 | 10 => {
                rtype = elf_mips_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            243 => {
                rtype = elf_riscv_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            36902 => {
                rtype = elf_alpha_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            40 => {
                rtype = elf_arm_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            45 | 93 | 195 => {
                rtype = elf_arc_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            15 => {
                rtype = elf_hppa_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            46 | 47 | 48 => {
                rtype = elf_h8_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            92 => {
                rtype = elf_or1k_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            91 | 99 => {
                rtype = elf_pj_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            50 => {
                rtype = elf_ia64_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            76 => {
                rtype = elf_cris_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            7 => {
                rtype = elf_i860_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            62 | 180 | 181 => {
                rtype = elf_x86_64_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            9 => {
                rtype = i370_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            41872 | 22 => {
                rtype = elf_s390_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            135 => {
                rtype = elf_score_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            44357 => {
                rtype = elf_xstormy16_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            114 => {
                rtype = elf_crx_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            75 => {
                rtype = elf_vax_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            221 => {
                rtype = elf_visium_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            247 => {
                rtype = elf_bpf_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            4643 => {
                rtype = elf_epiphany_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            101 | 33303 => {
                rtype = elf_ip2k_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            65210 => {
                rtype = elf_iq2000_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            43975 | 94 => {
                rtype = elf_xtensa_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            138 => {
                rtype = elf_lm32_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            65200 | 120 => {
                rtype = elf_m32c_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            9520 => {
                rtype = elf_mt_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            106 => {
                rtype = elf_bfin_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            61453 => {
                rtype = elf_mep_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            177 => {
                rtype = elf_cr16_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            189 | 47787 => {
                rtype = elf_microblaze_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            197 => {
                rtype = elf_rl78_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            173 => {
                rtype = elf_rx_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            174 => {
                rtype = elf_metag_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            18056 | 116 => {
                rtype = elf_xc16x_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            140 => {
                rtype = elf_tic6x_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            191 => {
                rtype = elf_tilegx_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            188 => {
                rtype = elf_tilepro_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            16727 => {
                rtype = elf_wasm32_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            115 => {
                rtype = elf_xgate_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            113 => {
                rtype = elf_nios2_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            144 => {
                rtype = elf_pru_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            250 => {
                if (*filedata).file_header.e_flags >> 8 as libc::c_int
                    & 0xffff as libc::c_int as libc::c_ulong
                    == 0x3200 as libc::c_int as libc::c_ulong
                {
                    rtype = elf_nfp3200_reloc_type(type_0);
                } else {
                    rtype = elf_nfp_reloc_type(type_0);
                }
                current_block_117 = 1228639923084383292;
            }
            220 => {
                rtype = elf_z80_reloc_type(type_0);
                current_block_117 = 1228639923084383292;
            }
            _ => {
                rtype = 0 as *const libc::c_char;
                current_block_117 = 1228639923084383292;
            }
        }
        match current_block_117 {
            16906203418972200896 => {
                rtype = elf_msp430_reloc_type(type_0);
            }
            _ => {}
        }
        if rtype.is_null() {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"unrecognized: %-7lx\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                type_0 & 0xffffffff as libc::c_uint as libc::c_ulong,
            );
        } else {
            printf(
                if do_wide != 0 {
                    b"%-22s\0" as *const u8 as *const libc::c_char
                } else {
                    b"%-17.17s\0" as *const u8 as *const libc::c_char
                },
                rtype,
            );
        }
        if (*filedata).file_header.e_machine as libc::c_int == 0x9026 as libc::c_int
            && !rtype.is_null()
            && strcmp(rtype, b"R_ALPHA_LITUSE\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && is_rela != 0
        {
            match (*rels.offset(i as isize)).r_addend {
                0 => {
                    rtype = b"ADDR\0" as *const u8 as *const libc::c_char;
                }
                1 => {
                    rtype = b"BASE\0" as *const u8 as *const libc::c_char;
                }
                2 => {
                    rtype = b"BYTOFF\0" as *const u8 as *const libc::c_char;
                }
                3 => {
                    rtype = b"JSR\0" as *const u8 as *const libc::c_char;
                }
                4 => {
                    rtype = b"TLSGD\0" as *const u8 as *const libc::c_char;
                }
                5 => {
                    rtype = b"TLSLDM\0" as *const u8 as *const libc::c_char;
                }
                6 => {
                    rtype = b"JSRDIRECT\0" as *const u8 as *const libc::c_char;
                }
                _ => {
                    rtype = 0 as *const libc::c_char;
                }
            }
            if !rtype.is_null() {
                printf(b" (%s)\0" as *const u8 as *const libc::c_char, rtype);
            } else {
                putchar(' ' as i32);
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown addend: %lx>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*rels.offset(i as isize)).r_addend,
                );
                res = 0 as libc::c_int != 0;
            }
        } else if symtab_index != 0 {
            if symtab.is_null() || symtab_index >= nsyms {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" bad symbol index: %08lx in reloc\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    symtab_index,
                );
                res = 0 as libc::c_int != 0;
            } else {
                let mut psym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
                let mut version_string: *const libc::c_char = 0 as *const libc::c_char;
                let mut sym_info: versioned_symbol_info = symbol_undefined;
                let mut vna_other: libc::c_ushort = 0;
                psym = symtab.offset(symtab_index as isize);
                version_string = get_symbol_version_string(
                    filedata,
                    is_dynsym,
                    strtab,
                    strtablen,
                    symtab_index as libc::c_uint,
                    psym,
                    &mut sym_info,
                    &mut vna_other,
                );
                printf(b" \0" as *const u8 as *const libc::c_char);
                if (*psym).st_info as libc::c_int & 0xf as libc::c_int
                    == 10 as libc::c_int
                {
                    let mut name: *const libc::c_char = 0 as *const libc::c_char;
                    let mut len: libc::c_uint = 0;
                    let mut width: libc::c_uint = (if is_32bit_elf as libc::c_int != 0 {
                        8 as libc::c_int
                    } else {
                        14 as libc::c_int
                    }) as libc::c_uint;
                    if strtab.is_null()
                        || (*psym).st_name == 0 as libc::c_int as libc::c_ulong
                        || (*psym).st_name >= strtablen
                    {
                        name = b"??\0" as *const u8 as *const libc::c_char;
                    } else {
                        name = strtab.offset((*psym).st_name as isize);
                    }
                    len = print_symbol(width as libc::c_int, name);
                    if !version_string.is_null() {
                        printf(
                            if sym_info as libc::c_uint
                                == symbol_public as libc::c_int as libc::c_uint
                            {
                                b"@@%s\0" as *const u8 as *const libc::c_char
                            } else {
                                b"@%s\0" as *const u8 as *const libc::c_char
                            },
                            version_string,
                        );
                    }
                    printf(
                        b"()%-*s\0" as *const u8 as *const libc::c_char,
                        if len <= width {
                            width
                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                .wrapping_sub(len)
                        } else {
                            1 as libc::c_int as libc::c_uint
                        },
                        b" \0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    print_vma((*psym).st_value, LONG_HEX);
                    printf(
                        if is_32bit_elf as libc::c_int != 0 {
                            b"   \0" as *const u8 as *const libc::c_char
                        } else {
                            b" \0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                if (*psym).st_name == 0 as libc::c_int as libc::c_ulong {
                    let mut sec_name: *const libc::c_char = b"<null>\0" as *const u8
                        as *const libc::c_char;
                    let mut name_buf: [libc::c_char; 40] = [0; 40];
                    if (*psym).st_info as libc::c_int & 0xf as libc::c_int
                        == 3 as libc::c_int
                    {
                        if (*psym).st_shndx < (*filedata).file_header.e_shnum {
                            sec_name = if ((*filedata).section_headers)
                                .offset((*psym).st_shndx as isize)
                                .is_null()
                            {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<none>\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            } else if ((*filedata).string_table).is_null() {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<no-strings>\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            } else if (*((*filedata).section_headers)
                                .offset((*psym).st_shndx as isize))
                                .sh_name as libc::c_ulong >= (*filedata).string_table_length
                            {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<corrupt>\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            } else {
                                ((*filedata).string_table)
                                    .offset(
                                        (*((*filedata).section_headers)
                                            .offset((*psym).st_shndx as isize))
                                            .sh_name as isize,
                                    )
                            };
                        } else if (*psym).st_shndx
                            == (0xf as libc::c_uint).wrapping_neg()
                        {
                            sec_name = b"ABS\0" as *const u8 as *const libc::c_char;
                        } else if (*psym).st_shndx
                            == (0xe as libc::c_uint).wrapping_neg()
                        {
                            sec_name = b"COMMON\0" as *const u8 as *const libc::c_char;
                        } else if (*filedata).file_header.e_machine as libc::c_int
                            == 8 as libc::c_int
                            && (*psym).st_shndx
                                == (0x100 as libc::c_uint)
                                    .wrapping_neg()
                                    .wrapping_add(3 as libc::c_int as libc::c_uint)
                            || (*filedata).file_header.e_machine as libc::c_int
                                == 140 as libc::c_int
                                && (*psym).st_shndx
                                    == (0x100 as libc::c_uint).wrapping_neg()
                        {
                            sec_name = b"SCOMMON\0" as *const u8 as *const libc::c_char;
                        } else if (*filedata).file_header.e_machine as libc::c_int
                            == 8 as libc::c_int
                            && (*psym).st_shndx
                                == (0x100 as libc::c_uint)
                                    .wrapping_neg()
                                    .wrapping_add(4 as libc::c_int as libc::c_uint)
                        {
                            sec_name = b"SUNDEF\0" as *const u8 as *const libc::c_char;
                        } else if ((*filedata).file_header.e_machine as libc::c_int
                            == 62 as libc::c_int
                            || (*filedata).file_header.e_machine as libc::c_int
                                == 180 as libc::c_int
                            || (*filedata).file_header.e_machine as libc::c_int
                                == 181 as libc::c_int)
                            && (*psym).st_shndx
                                == (0x100 as libc::c_uint)
                                    .wrapping_neg()
                                    .wrapping_add(2 as libc::c_int as libc::c_uint)
                        {
                            sec_name = b"LARGE_COMMON\0" as *const u8
                                as *const libc::c_char;
                        } else if (*filedata).file_header.e_machine as libc::c_int
                            == 50 as libc::c_int
                            && (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                                as libc::c_int == 1 as libc::c_int
                            && (*psym).st_shndx == (0x100 as libc::c_uint).wrapping_neg()
                        {
                            sec_name = b"ANSI_COM\0" as *const u8 as *const libc::c_char;
                        } else if is_ia64_vms(filedata) as libc::c_int != 0
                            && (*psym).st_shndx == (0xe0 as libc::c_uint).wrapping_neg()
                        {
                            sec_name = b"VMS_SYMVEC\0" as *const u8
                                as *const libc::c_char;
                        } else {
                            sprintf(
                                name_buf.as_mut_ptr(),
                                b"<section 0x%x>\0" as *const u8 as *const libc::c_char,
                                (*psym).st_shndx,
                            );
                            sec_name = name_buf.as_mut_ptr();
                        }
                    }
                    print_symbol(22 as libc::c_int, sec_name);
                } else if strtab.is_null() {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<string table index: %3ld>\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*psym).st_name,
                    );
                } else if (*psym).st_name >= strtablen {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<corrupt string table index: %3ld>\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*psym).st_name,
                    );
                    res = 0 as libc::c_int != 0;
                } else {
                    print_symbol(
                        22 as libc::c_int,
                        strtab.offset((*psym).st_name as isize),
                    );
                    if !version_string.is_null() {
                        printf(
                            if sym_info as libc::c_uint
                                == symbol_public as libc::c_int as libc::c_uint
                            {
                                b"@@%s\0" as *const u8 as *const libc::c_char
                            } else {
                                b"@%s\0" as *const u8 as *const libc::c_char
                            },
                            version_string,
                        );
                    }
                }
                if is_rela != 0 {
                    let mut off: bfd_vma = (*rels.offset(i as isize)).r_addend;
                    if (off as bfd_signed_vma) < 0 as libc::c_int as libc::c_long {
                        printf(
                            b" - %lx\0" as *const u8 as *const libc::c_char,
                            off.wrapping_neg(),
                        );
                    } else {
                        printf(b" + %lx\0" as *const u8 as *const libc::c_char, off);
                    }
                }
            }
        } else if is_rela != 0 {
            let mut off_0: bfd_vma = (*rels.offset(i as isize)).r_addend;
            printf(
                b"%*c\0" as *const u8 as *const libc::c_char,
                if is_32bit_elf as libc::c_int != 0 {
                    12 as libc::c_int
                } else {
                    20 as libc::c_int
                },
                ' ' as i32,
            );
            if (off_0 as bfd_signed_vma) < 0 as libc::c_int as libc::c_long {
                printf(
                    b"-%lx\0" as *const u8 as *const libc::c_char,
                    off_0.wrapping_neg(),
                );
            } else {
                printf(b"%lx\0" as *const u8 as *const libc::c_char, off_0);
            }
        }
        if (*filedata).file_header.e_machine as libc::c_int == 43 as libc::c_int
            && !rtype.is_null()
            && strcmp(rtype, b"R_SPARC_OLO10\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            printf(
                b" + %lx\0" as *const u8 as *const libc::c_char,
                ((((inf & 0xffffffff as libc::c_uint as libc::c_ulong)
                    >> 8 as libc::c_int) as bfd_signed_vma
                    ^ 0x800000 as libc::c_int as libc::c_long)
                    - 0x800000 as libc::c_int as libc::c_long) as libc::c_ulong,
            );
        }
        putchar('\n' as i32);
        if !is_32bit_elf
            && (*filedata).file_header.e_machine as libc::c_int == 8 as libc::c_int
        {
            let mut type2: bfd_vma = inf >> 8 as libc::c_int
                & 0xff as libc::c_int as libc::c_ulong;
            let mut type3: bfd_vma = inf >> 16 as libc::c_int
                & 0xff as libc::c_int as libc::c_ulong;
            let mut rtype2: *const libc::c_char = elf_mips_reloc_type(type2);
            let mut rtype3: *const libc::c_char = elf_mips_reloc_type(type3);
            printf(b"                    Type2: \0" as *const u8 as *const libc::c_char);
            if rtype2.is_null() {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unrecognized: %-7lx\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type2 & 0xffffffff as libc::c_uint as libc::c_ulong,
                );
            } else {
                printf(b"%-17.17s\0" as *const u8 as *const libc::c_char, rtype2);
            }
            printf(
                b"\n                    Type3: \0" as *const u8 as *const libc::c_char,
            );
            if rtype3.is_null() {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unrecognized: %-7lx\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type3 & 0xffffffff as libc::c_uint as libc::c_ulong,
                );
            } else {
                printf(b"%-17.17s\0" as *const u8 as *const libc::c_char, rtype3);
            }
            putchar('\n' as i32);
        }
        i = i.wrapping_add(1);
        i;
    }
    free(rels as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn get_aarch64_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048193 => return b"AARCH64_BTI_PLT\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"AARCH64_PAC_PLT\0" as *const u8 as *const libc::c_char,
        1879048197 => return b"AARCH64_VARIANT_PCS\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_mips_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048193 => return b"MIPS_RLD_VERSION\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"MIPS_TIME_STAMP\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"MIPS_ICHECKSUM\0" as *const u8 as *const libc::c_char,
        1879048196 => return b"MIPS_IVERSION\0" as *const u8 as *const libc::c_char,
        1879048197 => return b"MIPS_FLAGS\0" as *const u8 as *const libc::c_char,
        1879048198 => return b"MIPS_BASE_ADDRESS\0" as *const u8 as *const libc::c_char,
        1879048199 => return b"MIPS_MSYM\0" as *const u8 as *const libc::c_char,
        1879048200 => return b"MIPS_CONFLICT\0" as *const u8 as *const libc::c_char,
        1879048201 => return b"MIPS_LIBLIST\0" as *const u8 as *const libc::c_char,
        1879048202 => return b"MIPS_LOCAL_GOTNO\0" as *const u8 as *const libc::c_char,
        1879048203 => return b"MIPS_CONFLICTNO\0" as *const u8 as *const libc::c_char,
        1879048208 => return b"MIPS_LIBLISTNO\0" as *const u8 as *const libc::c_char,
        1879048209 => return b"MIPS_SYMTABNO\0" as *const u8 as *const libc::c_char,
        1879048210 => return b"MIPS_UNREFEXTNO\0" as *const u8 as *const libc::c_char,
        1879048211 => return b"MIPS_GOTSYM\0" as *const u8 as *const libc::c_char,
        1879048212 => return b"MIPS_HIPAGENO\0" as *const u8 as *const libc::c_char,
        1879048214 => return b"MIPS_RLD_MAP\0" as *const u8 as *const libc::c_char,
        1879048245 => return b"MIPS_RLD_MAP_REL\0" as *const u8 as *const libc::c_char,
        1879048215 => return b"MIPS_DELTA_CLASS\0" as *const u8 as *const libc::c_char,
        1879048216 => return b"MIPS_DELTA_CLASS_NO\0" as *const u8 as *const libc::c_char,
        1879048217 => return b"MIPS_DELTA_INSTANCE\0" as *const u8 as *const libc::c_char,
        1879048218 => {
            return b"MIPS_DELTA_INSTANCE_NO\0" as *const u8 as *const libc::c_char;
        }
        1879048219 => return b"MIPS_DELTA_RELOC\0" as *const u8 as *const libc::c_char,
        1879048220 => return b"MIPS_DELTA_RELOC_NO\0" as *const u8 as *const libc::c_char,
        1879048221 => return b"MIPS_DELTA_SYM\0" as *const u8 as *const libc::c_char,
        1879048222 => return b"MIPS_DELTA_SYM_NO\0" as *const u8 as *const libc::c_char,
        1879048224 => return b"MIPS_DELTA_CLASSSYM\0" as *const u8 as *const libc::c_char,
        1879048225 => {
            return b"MIPS_DELTA_CLASSSYM_NO\0" as *const u8 as *const libc::c_char;
        }
        1879048226 => return b"MIPS_CXX_FLAGS\0" as *const u8 as *const libc::c_char,
        1879048227 => return b"MIPS_PIXIE_INIT\0" as *const u8 as *const libc::c_char,
        1879048228 => return b"MIPS_SYMBOL_LIB\0" as *const u8 as *const libc::c_char,
        1879048229 => {
            return b"MIPS_LOCALPAGE_GOTIDX\0" as *const u8 as *const libc::c_char;
        }
        1879048230 => return b"MIPS_LOCAL_GOTIDX\0" as *const u8 as *const libc::c_char,
        1879048231 => return b"MIPS_HIDDEN_GOTIDX\0" as *const u8 as *const libc::c_char,
        1879048232 => {
            return b"MIPS_PROTECTED_GOTIDX\0" as *const u8 as *const libc::c_char;
        }
        1879048233 => return b"MIPS_OPTIONS\0" as *const u8 as *const libc::c_char,
        1879048234 => return b"MIPS_INTERFACE\0" as *const u8 as *const libc::c_char,
        1879048235 => return b"MIPS_DYNSTR_ALIGN\0" as *const u8 as *const libc::c_char,
        1879048236 => return b"MIPS_INTERFACE_SIZE\0" as *const u8 as *const libc::c_char,
        1879048237 => {
            return b"MIPS_RLD_TEXT_RESOLVE_ADDR\0" as *const u8 as *const libc::c_char;
        }
        1879048238 => return b"MIPS_PERF_SUFFIX\0" as *const u8 as *const libc::c_char,
        1879048239 => return b"MIPS_COMPACT_SIZE\0" as *const u8 as *const libc::c_char,
        1879048240 => return b"MIPS_GP_VALUE\0" as *const u8 as *const libc::c_char,
        1879048241 => return b"MIPS_AUX_DYNAMIC\0" as *const u8 as *const libc::c_char,
        1879048242 => return b"MIPS_PLTGOT\0" as *const u8 as *const libc::c_char,
        1879048244 => return b"MIPS_RWPLT\0" as *const u8 as *const libc::c_char,
        1879048246 => return b"MIPS_XHASH\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_sparc64_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048193 => return b"SPARC_REGISTER\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_ppc_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"PPC_GOT\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"PPC_OPT\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_ppc64_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"PPC64_GLINK\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"PPC64_OPD\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"PPC64_OPDSZ\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"PPC64_OPT\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_parisc_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1610612736 => return b"HP_LOAD_MAP\0" as *const u8 as *const libc::c_char,
        1610612737 => return b"HP_DLD_FLAGS\0" as *const u8 as *const libc::c_char,
        1610612738 => return b"HP_DLD_HOOK\0" as *const u8 as *const libc::c_char,
        1610612739 => return b"HP_UX10_INIT\0" as *const u8 as *const libc::c_char,
        1610612740 => return b"HP_UX10_INITSZ\0" as *const u8 as *const libc::c_char,
        1610612741 => return b"HP_PREINIT\0" as *const u8 as *const libc::c_char,
        1610612742 => return b"HP_PREINITSZ\0" as *const u8 as *const libc::c_char,
        1610612743 => return b"HP_NEEDED\0" as *const u8 as *const libc::c_char,
        1610612744 => return b"HP_TIME_STAMP\0" as *const u8 as *const libc::c_char,
        1610612745 => return b"HP_CHECKSUM\0" as *const u8 as *const libc::c_char,
        1610612746 => return b"HP_GST_SIZE\0" as *const u8 as *const libc::c_char,
        1610612747 => return b"HP_GST_VERSION\0" as *const u8 as *const libc::c_char,
        1610612748 => return b"HP_GST_HASHVAL\0" as *const u8 as *const libc::c_char,
        1610612749 => return b"HP_GST_EPLTREL\0" as *const u8 as *const libc::c_char,
        1610612750 => return b"HP_GST_EPLTRELSZ\0" as *const u8 as *const libc::c_char,
        1610612751 => return b"HP_FILTERED\0" as *const u8 as *const libc::c_char,
        1610612752 => return b"HP_FILTER_TLS\0" as *const u8 as *const libc::c_char,
        1610612753 => return b"HP_COMPAT_FILTERED\0" as *const u8 as *const libc::c_char,
        1610612754 => return b"HP_LAZYLOAD\0" as *const u8 as *const libc::c_char,
        1610612755 => return b"HP_BIND_NOW_COUNT\0" as *const u8 as *const libc::c_char,
        1610612756 => return b"PLT\0" as *const u8 as *const libc::c_char,
        1610612757 => return b"PLT_SIZE\0" as *const u8 as *const libc::c_char,
        1610612758 => return b"DLT\0" as *const u8 as *const libc::c_char,
        1610612759 => return b"DLT_SIZE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_ia64_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"IA_64_PLT_RESERVE\0" as *const u8 as *const libc::c_char,
        1610612749 => return b"VMS_SUBTYPE\0" as *const u8 as *const libc::c_char,
        1610612751 => return b"VMS_IMGIOCNT\0" as *const u8 as *const libc::c_char,
        1610612757 => return b"VMS_LNKFLAGS\0" as *const u8 as *const libc::c_char,
        1610612759 => return b"VMS_VIR_MEM_BLK_SIZ\0" as *const u8 as *const libc::c_char,
        1610612761 => return b"VMS_IDENT\0" as *const u8 as *const libc::c_char,
        1610612765 => return b"VMS_NEEDED_IDENT\0" as *const u8 as *const libc::c_char,
        1610612767 => return b"VMS_IMG_RELA_CNT\0" as *const u8 as *const libc::c_char,
        1610612769 => return b"VMS_SEG_RELA_CNT\0" as *const u8 as *const libc::c_char,
        1610612771 => return b"VMS_FIXUP_RELA_CNT\0" as *const u8 as *const libc::c_char,
        1610612773 => return b"VMS_FIXUP_NEEDED\0" as *const u8 as *const libc::c_char,
        1610612775 => return b"VMS_SYMVEC_CNT\0" as *const u8 as *const libc::c_char,
        1610612779 => return b"VMS_XLATED\0" as *const u8 as *const libc::c_char,
        1610612781 => return b"VMS_STACKSIZE\0" as *const u8 as *const libc::c_char,
        1610612783 => return b"VMS_UNWINDSZ\0" as *const u8 as *const libc::c_char,
        1610612785 => return b"VMS_UNWIND_CODSEG\0" as *const u8 as *const libc::c_char,
        1610612787 => return b"VMS_UNWIND_INFOSEG\0" as *const u8 as *const libc::c_char,
        1610612789 => return b"VMS_LINKTIME\0" as *const u8 as *const libc::c_char,
        1610612791 => return b"VMS_SEG_NO\0" as *const u8 as *const libc::c_char,
        1610612793 => return b"VMS_SYMVEC_OFFSET\0" as *const u8 as *const libc::c_char,
        1610612795 => return b"VMS_SYMVEC_SEG\0" as *const u8 as *const libc::c_char,
        1610612797 => return b"VMS_UNWIND_OFFSET\0" as *const u8 as *const libc::c_char,
        1610612799 => return b"VMS_UNWIND_SEG\0" as *const u8 as *const libc::c_char,
        1610612801 => return b"VMS_STRTAB_OFFSET\0" as *const u8 as *const libc::c_char,
        1610612803 => return b"VMS_SYSVER_OFFSET\0" as *const u8 as *const libc::c_char,
        1610612805 => return b"VMS_IMG_RELA_OFF\0" as *const u8 as *const libc::c_char,
        1610612807 => return b"VMS_SEG_RELA_OFF\0" as *const u8 as *const libc::c_char,
        1610612809 => return b"VMS_FIXUP_RELA_OFF\0" as *const u8 as *const libc::c_char,
        1610612811 => return b"VMS_PLTGOT_OFFSET\0" as *const u8 as *const libc::c_char,
        1610612813 => return b"VMS_PLTGOT_SEG\0" as *const u8 as *const libc::c_char,
        1610612815 => return b"VMS_FPMODE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_solaris_section_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048174 => return b"SUNW_ancillary\0" as *const u8 as *const libc::c_char,
        1879048175 => return b"SUNW_capchain\0" as *const u8 as *const libc::c_char,
        1879048176 => return b"SUNW_capinfo\0" as *const u8 as *const libc::c_char,
        1879048177 => return b"SUNW_symsort\0" as *const u8 as *const libc::c_char,
        1879048178 => return b"SUNW_tlssort\0" as *const u8 as *const libc::c_char,
        1879048179 => return b"SUNW_LDYNSYM\0" as *const u8 as *const libc::c_char,
        1879048180 => return b"SUNW_dof\0" as *const u8 as *const libc::c_char,
        1879048181 => return b"SUNW_cap\0" as *const u8 as *const libc::c_char,
        1879048182 => return b"SUNW_SIGNATURE\0" as *const u8 as *const libc::c_char,
        1879048183 => return b"SUNW_ANNOTATE\0" as *const u8 as *const libc::c_char,
        1879048184 => return b"SUNW_DEBUGSTR\0" as *const u8 as *const libc::c_char,
        1879048185 => return b"SUNW_DEBUG\0" as *const u8 as *const libc::c_char,
        1879048186 => return b"SUNW_move\0" as *const u8 as *const libc::c_char,
        1879048187 => return b"SUNW_COMDAT\0" as *const u8 as *const libc::c_char,
        1879048188 => return b"SUNW_syminfo\0" as *const u8 as *const libc::c_char,
        1879048189 => return b"SUNW_verdef\0" as *const u8 as *const libc::c_char,
        1879048190 => return b"SUNW_verneed\0" as *const u8 as *const libc::c_char,
        1879048191 => return b"SUNW_versym\0" as *const u8 as *const libc::c_char,
        1879048192 => return b"SPARC_GOTDATA\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_alpha_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"ALPHA_PLTRO\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_score_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048193 => return b"SCORE_BASE_ADDRESS\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"SCORE_LOCAL_GOTNO\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"SCORE_SYMTABNO\0" as *const u8 as *const libc::c_char,
        1879048196 => return b"SCORE_GOTSYM\0" as *const u8 as *const libc::c_char,
        1879048197 => return b"SCORE_UNREFEXTNO\0" as *const u8 as *const libc::c_char,
        1879048198 => return b"SCORE_HIPAGENO\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_tic6x_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1610612749 => return b"C6000_GSYM_OFFSET\0" as *const u8 as *const libc::c_char,
        1610612751 => return b"C6000_GSTR_OFFSET\0" as *const u8 as *const libc::c_char,
        1879048192 => return b"C6000_DSBT_BASE\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"C6000_DSBT_SIZE\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"C6000_PREEMPTMAP\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"C6000_DSBT_INDEX\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_nios2_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048194 => return b"NIOS2_GP\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_solaris_dynamic_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1610612749 => return b"SUNW_AUXILIARY\0" as *const u8 as *const libc::c_char,
        1610612750 => return b"SUNW_RTLDINF\0" as *const u8 as *const libc::c_char,
        1610612751 => return b"SUNW_FILTER\0" as *const u8 as *const libc::c_char,
        1610612752 => return b"SUNW_CAP\0" as *const u8 as *const libc::c_char,
        1610612753 => return b"SUNW_SYMTAB\0" as *const u8 as *const libc::c_char,
        1610612754 => return b"SUNW_SYMSZ\0" as *const u8 as *const libc::c_char,
        1610612755 => return b"SUNW_SORTENT\0" as *const u8 as *const libc::c_char,
        1610612756 => return b"SUNW_SYMSORT\0" as *const u8 as *const libc::c_char,
        1610612757 => return b"SUNW_SYMSORTSZ\0" as *const u8 as *const libc::c_char,
        1610612758 => return b"SUNW_TLSSORT\0" as *const u8 as *const libc::c_char,
        1610612759 => return b"SUNW_TLSSORTSZ\0" as *const u8 as *const libc::c_char,
        1610612760 => return b"SUNW_CAPINFO\0" as *const u8 as *const libc::c_char,
        1610612761 => return b"SUNW_STRPAD\0" as *const u8 as *const libc::c_char,
        1610612762 => return b"SUNW_CAPCHAIN\0" as *const u8 as *const libc::c_char,
        1610612763 => return b"SUNW_LDMACH\0" as *const u8 as *const libc::c_char,
        1610612765 => return b"SUNW_CAPCHAINENT\0" as *const u8 as *const libc::c_char,
        1610612767 => return b"SUNW_CAPCHAINSZ\0" as *const u8 as *const libc::c_char,
        1610612769 => return b"SUNW_PARENT\0" as *const u8 as *const libc::c_char,
        1610612771 => return b"SUNW_ASLR\0" as *const u8 as *const libc::c_char,
        1610612773 => return b"SUNW_RELAX\0" as *const u8 as *const libc::c_char,
        1610612777 => return b"SUNW_NXHEAP\0" as *const u8 as *const libc::c_char,
        1610612779 => return b"SUNW_NXSTACK\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"SPARC_REGISTER\0" as *const u8 as *const libc::c_char,
        2147483645 => return b"AUXILIARY\0" as *const u8 as *const libc::c_char,
        2147483646 => return b"USED\0" as *const u8 as *const libc::c_char,
        2147483647 => return b"FILTER\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_dynamic_type(
    mut filedata: *mut Filedata,
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    match type_0 {
        0 => return b"NULL\0" as *const u8 as *const libc::c_char,
        1 => return b"NEEDED\0" as *const u8 as *const libc::c_char,
        2 => return b"PLTRELSZ\0" as *const u8 as *const libc::c_char,
        3 => return b"PLTGOT\0" as *const u8 as *const libc::c_char,
        4 => return b"HASH\0" as *const u8 as *const libc::c_char,
        5 => return b"STRTAB\0" as *const u8 as *const libc::c_char,
        6 => return b"SYMTAB\0" as *const u8 as *const libc::c_char,
        7 => return b"RELA\0" as *const u8 as *const libc::c_char,
        8 => return b"RELASZ\0" as *const u8 as *const libc::c_char,
        9 => return b"RELAENT\0" as *const u8 as *const libc::c_char,
        10 => return b"STRSZ\0" as *const u8 as *const libc::c_char,
        11 => return b"SYMENT\0" as *const u8 as *const libc::c_char,
        12 => return b"INIT\0" as *const u8 as *const libc::c_char,
        13 => return b"FINI\0" as *const u8 as *const libc::c_char,
        14 => return b"SONAME\0" as *const u8 as *const libc::c_char,
        15 => return b"RPATH\0" as *const u8 as *const libc::c_char,
        16 => return b"SYMBOLIC\0" as *const u8 as *const libc::c_char,
        17 => return b"REL\0" as *const u8 as *const libc::c_char,
        18 => return b"RELSZ\0" as *const u8 as *const libc::c_char,
        19 => return b"RELENT\0" as *const u8 as *const libc::c_char,
        20 => return b"PLTREL\0" as *const u8 as *const libc::c_char,
        21 => return b"DEBUG\0" as *const u8 as *const libc::c_char,
        22 => return b"TEXTREL\0" as *const u8 as *const libc::c_char,
        23 => return b"JMPREL\0" as *const u8 as *const libc::c_char,
        24 => return b"BIND_NOW\0" as *const u8 as *const libc::c_char,
        25 => return b"INIT_ARRAY\0" as *const u8 as *const libc::c_char,
        26 => return b"FINI_ARRAY\0" as *const u8 as *const libc::c_char,
        27 => return b"INIT_ARRAYSZ\0" as *const u8 as *const libc::c_char,
        28 => return b"FINI_ARRAYSZ\0" as *const u8 as *const libc::c_char,
        29 => return b"RUNPATH\0" as *const u8 as *const libc::c_char,
        30 => return b"FLAGS\0" as *const u8 as *const libc::c_char,
        32 => return b"PREINIT_ARRAY\0" as *const u8 as *const libc::c_char,
        33 => return b"PREINIT_ARRAYSZ\0" as *const u8 as *const libc::c_char,
        34 => return b"SYMTAB_SHNDX\0" as *const u8 as *const libc::c_char,
        1879047672 => return b"CHECKSUM\0" as *const u8 as *const libc::c_char,
        1879047673 => return b"PLTPADSZ\0" as *const u8 as *const libc::c_char,
        1879047674 => return b"MOVEENT\0" as *const u8 as *const libc::c_char,
        1879047675 => return b"MOVESZ\0" as *const u8 as *const libc::c_char,
        1879047676 => return b"FEATURE\0" as *const u8 as *const libc::c_char,
        1879047677 => return b"POSFLAG_1\0" as *const u8 as *const libc::c_char,
        1879047678 => return b"SYMINSZ\0" as *const u8 as *const libc::c_char,
        1879047679 => return b"SYMINENT\0" as *const u8 as *const libc::c_char,
        1879047680 => return b"ADDRRNGLO\0" as *const u8 as *const libc::c_char,
        1879047930 => return b"CONFIG\0" as *const u8 as *const libc::c_char,
        1879047931 => return b"DEPAUDIT\0" as *const u8 as *const libc::c_char,
        1879047932 => return b"AUDIT\0" as *const u8 as *const libc::c_char,
        1879047933 => return b"PLTPAD\0" as *const u8 as *const libc::c_char,
        1879047934 => return b"MOVETAB\0" as *const u8 as *const libc::c_char,
        1879047935 => return b"SYMINFO\0" as *const u8 as *const libc::c_char,
        1879048176 => return b"VERSYM\0" as *const u8 as *const libc::c_char,
        1879047927 => return b"TLSDESC_GOT\0" as *const u8 as *const libc::c_char,
        1879047926 => return b"TLSDESC_PLT\0" as *const u8 as *const libc::c_char,
        1879048185 => return b"RELACOUNT\0" as *const u8 as *const libc::c_char,
        1879048186 => return b"RELCOUNT\0" as *const u8 as *const libc::c_char,
        1879048187 => return b"FLAGS_1\0" as *const u8 as *const libc::c_char,
        1879048188 => return b"VERDEF\0" as *const u8 as *const libc::c_char,
        1879048189 => return b"VERDEFNUM\0" as *const u8 as *const libc::c_char,
        1879048190 => return b"VERNEED\0" as *const u8 as *const libc::c_char,
        1879048191 => return b"VERNEEDNUM\0" as *const u8 as *const libc::c_char,
        2147483645 => return b"AUXILIARY\0" as *const u8 as *const libc::c_char,
        2147483646 => return b"USED\0" as *const u8 as *const libc::c_char,
        2147483647 => return b"FILTER\0" as *const u8 as *const libc::c_char,
        1879047669 => return b"GNU_PRELINKED\0" as *const u8 as *const libc::c_char,
        1879047928 => return b"GNU_CONFLICT\0" as *const u8 as *const libc::c_char,
        1879047670 => return b"GNU_CONFLICTSZ\0" as *const u8 as *const libc::c_char,
        1879047929 => return b"GNU_LIBLIST\0" as *const u8 as *const libc::c_char,
        1879047671 => return b"GNU_LIBLISTSZ\0" as *const u8 as *const libc::c_char,
        1879047925 => return b"GNU_HASH\0" as *const u8 as *const libc::c_char,
        1879047668 => return b"GNU_FLAGS_1\0" as *const u8 as *const libc::c_char,
        _ => {
            if type_0 >= 0x70000000 as libc::c_int as libc::c_ulong
                && type_0 <= 0x7fffffff as libc::c_int as libc::c_ulong
            {
                let mut result: *const libc::c_char = 0 as *const libc::c_char;
                match (*filedata).file_header.e_machine as libc::c_int {
                    183 => {
                        result = get_aarch64_dynamic_type(type_0);
                    }
                    8 | 10 => {
                        result = get_mips_dynamic_type(type_0);
                    }
                    43 => {
                        result = get_sparc64_dynamic_type(type_0);
                    }
                    20 => {
                        result = get_ppc_dynamic_type(type_0);
                    }
                    21 => {
                        result = get_ppc64_dynamic_type(type_0);
                    }
                    50 => {
                        result = get_ia64_dynamic_type(type_0);
                    }
                    36902 => {
                        result = get_alpha_dynamic_type(type_0);
                    }
                    135 => {
                        result = get_score_dynamic_type(type_0);
                    }
                    140 => {
                        result = get_tic6x_dynamic_type(type_0);
                    }
                    113 => {
                        result = get_nios2_dynamic_type(type_0);
                    }
                    _ => {
                        if (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                            as libc::c_int == 6 as libc::c_int
                        {
                            result = get_solaris_dynamic_type(type_0);
                        } else {
                            result = 0 as *const libc::c_char;
                        }
                    }
                }
                if !result.is_null() {
                    return result;
                }
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Processor Specific: %lx\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type_0,
                );
            } else if type_0 >= 0x6000000d as libc::c_int as libc::c_ulong
                && type_0 <= 0x6ffff000 as libc::c_int as libc::c_ulong
                || (*filedata).file_header.e_machine as libc::c_int == 15 as libc::c_int
                    && type_0 >= 0x60000000 as libc::c_int as libc::c_ulong
                    && type_0 <= 0x6fffffff as libc::c_int as libc::c_ulong
            {
                let mut result_0: *const libc::c_char = 0 as *const libc::c_char;
                match (*filedata).file_header.e_machine as libc::c_int {
                    15 => {
                        result_0 = get_parisc_dynamic_type(type_0);
                    }
                    50 => {
                        result_0 = get_ia64_dynamic_type(type_0);
                    }
                    _ => {
                        if (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                            as libc::c_int == 6 as libc::c_int
                        {
                            result_0 = get_solaris_dynamic_type(type_0);
                        } else {
                            result_0 = 0 as *const libc::c_char;
                        }
                    }
                }
                if !result_0.is_null() {
                    return result_0;
                }
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Operating System specific: %lx\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type_0,
                );
            } else {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>: %lx\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type_0,
                );
            }
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn get_program_headers(mut filedata: *mut Filedata) -> bool {
    let mut phdrs: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    if !((*filedata).program_headers).is_null() {
        return 1 as libc::c_int != 0;
    }
    if ((*filedata).file_header.e_phnum as libc::c_ulong)
        .wrapping_mul(
            if is_32bit_elf as libc::c_int != 0 {
                ::core::mem::size_of::<Elf32_External_Phdr>() as libc::c_ulong
            } else {
                ::core::mem::size_of::<Elf64_External_Phdr>() as libc::c_ulong
            },
        ) >= (*filedata).file_size
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Too many program headers - %#x - the file is not that big\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_header.e_phnum,
        );
        return 0 as libc::c_int != 0;
    }
    phdrs = cmalloc(
        (*filedata).file_header.e_phnum as size_t,
        ::core::mem::size_of::<Elf_Internal_Phdr>() as libc::c_ulong,
    ) as *mut Elf_Internal_Phdr;
    if phdrs.is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory reading %u program headers\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_header.e_phnum,
        );
        return 0 as libc::c_int != 0;
    }
    if if is_32bit_elf as libc::c_int != 0 {
        get_32bit_program_headers(filedata, phdrs) as libc::c_int
    } else {
        get_64bit_program_headers(filedata, phdrs) as libc::c_int
    } != 0
    {
        (*filedata).program_headers = phdrs;
        return 1 as libc::c_int != 0;
    }
    free(phdrs as *mut libc::c_void);
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn get_dynamic_section(mut filedata: *mut Filedata) -> bool {
    if !((*filedata).dynamic_section).is_null() {
        return 1 as libc::c_int != 0;
    }
    if is_32bit_elf {
        return get_32bit_dynamic_section(filedata)
    } else {
        return get_64bit_dynamic_section(filedata)
    };
}
unsafe extern "C" fn locate_dynamic_section(mut filedata: *mut Filedata) {
    let mut dynamic_addr: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut dynamic_size: bfd_size_type = 0 as libc::c_int as bfd_size_type;
    if (*filedata).file_header.e_phnum != 0 as libc::c_int as libc::c_uint
        && get_program_headers(filedata) as libc::c_int != 0
    {
        let mut segment: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
        let mut i: libc::c_uint = 0;
        i = 0 as libc::c_int as libc::c_uint;
        segment = (*filedata).program_headers;
        while i < (*filedata).file_header.e_phnum {
            if (*segment).p_type == 2 as libc::c_int as libc::c_ulong {
                dynamic_addr = (*segment).p_offset;
                dynamic_size = (*segment).p_filesz;
                if !((*filedata).section_headers).is_null() {
                    let mut sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
                    sec = find_section(
                        filedata,
                        b".dynamic\0" as *const u8 as *const libc::c_char,
                    );
                    if !sec.is_null() {
                        if (*sec).sh_size == 0 as libc::c_int as libc::c_ulong
                            || (*sec).sh_type == 8 as libc::c_int as libc::c_uint
                        {
                            dynamic_addr = 0 as libc::c_int as libc::c_ulong;
                            dynamic_size = 0 as libc::c_int as bfd_size_type;
                        } else {
                            dynamic_addr = (*sec).sh_offset as libc::c_ulong;
                            dynamic_size = (*sec).sh_size;
                        }
                    }
                }
                if dynamic_addr > (*filedata).file_size
                    || dynamic_size > ((*filedata).file_size).wrapping_sub(dynamic_addr)
                {
                    dynamic_addr = 0 as libc::c_int as libc::c_ulong;
                    dynamic_size = 0 as libc::c_int as bfd_size_type;
                }
                break;
            } else {
                i = i.wrapping_add(1);
                i;
                segment = segment.offset(1);
                segment;
            }
        }
    }
    (*filedata).dynamic_addr = dynamic_addr;
    (*filedata)
        .dynamic_size = if dynamic_size != 0 {
        dynamic_size
    } else {
        1 as libc::c_int as libc::c_ulong
    };
}
unsafe extern "C" fn is_pie(mut filedata: *mut Filedata) -> bool {
    let mut entry: *mut Elf_Internal_Dyn = 0 as *mut Elf_Internal_Dyn;
    if (*filedata).dynamic_size == 0 as libc::c_int as libc::c_ulong {
        locate_dynamic_section(filedata);
    }
    if (*filedata).dynamic_size <= 1 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    if !get_dynamic_section(filedata) {
        return 0 as libc::c_int != 0;
    }
    entry = (*filedata).dynamic_section;
    while entry < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
    {
        if (*entry).d_tag == 0x6ffffffb as libc::c_int as libc::c_ulong {
            if (*entry).d_un.d_val & 0x8000000 as libc::c_int as libc::c_ulong
                != 0 as libc::c_int as libc::c_ulong
            {
                return 1 as libc::c_int != 0;
            }
            break;
        } else {
            entry = entry.offset(1);
            entry;
        }
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn get_file_type(mut filedata: *mut Filedata) -> *mut libc::c_char {
    let mut e_type: libc::c_uint = (*filedata).file_header.e_type as libc::c_uint;
    static mut buff: [libc::c_char; 64] = [0; 64];
    match e_type {
        0 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NONE (None)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        1 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"REL (Relocatable file)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        2 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"EXEC (Executable file)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        3 => {
            if is_pie(filedata) {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"DYN (Position-Independent Executable file)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                )
            } else {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"DYN (Shared object file)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                )
            }
        }
        4 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"CORE (Core file)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        _ => {
            if e_type >= 0xff00 as libc::c_int as libc::c_uint
                && e_type <= 0xffff as libc::c_int as libc::c_uint
            {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Processor Specific: (%x)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    e_type,
                );
            } else if e_type >= 0xfe00 as libc::c_int as libc::c_uint
                && e_type <= 0xfeff as libc::c_int as libc::c_uint
            {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"OS Specific: (%x)\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    e_type,
                );
            } else {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>: %x\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    e_type,
                );
            }
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn get_machine_name(mut e_machine: libc::c_uint) -> *mut libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    match e_machine {
        0 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"None\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        1 => return b"WE32100\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        2 => return b"Sparc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        3 => {
            return b"Intel 80386\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        4 => return b"MC68000\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        5 => return b"MC88000\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        6 => {
            return b"Intel MCU\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        7 => {
            return b"Intel 80860\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        8 => {
            return b"MIPS R3000\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        9 => {
            return b"IBM System/370\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        10 => {
            return b"MIPS R4000 big-endian\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        11 => {
            return b"Sparc v9 (old)\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        15 => return b"HPPA\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        17 => {
            return b"Fujitsu VPP500\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        18 => {
            return b"Sparc v8+\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        19 => {
            return b"Intel 80960\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        20 => {
            return b"PowerPC\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        21 => {
            return b"PowerPC64\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        41872 | 22 => {
            return b"IBM S/390\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        23 => return b"SPU\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        36 => {
            return b"Renesas V850 (using RH850 ABI)\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        37 => {
            return b"Fujitsu FR20\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        38 => {
            return b"TRW RH32\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        39 => return b"MCORE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        40 => return b"ARM\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        41 => {
            return b"Digital Alpha (old)\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        42 => {
            return b"Renesas / SuperH SH\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        43 => {
            return b"Sparc v9\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        44 => {
            return b"Siemens Tricore\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        45 => return b"ARC\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        46 => {
            return b"Renesas H8/300\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        47 => {
            return b"Renesas H8/300H\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        48 => {
            return b"Renesas H8S\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        49 => {
            return b"Renesas H8/500\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        50 => {
            return b"Intel IA-64\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        51 => {
            return b"Stanford MIPS-X\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        52 => {
            return b"Motorola Coldfire\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        53 => {
            return b"Motorola MC68HC12 Microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        54 => {
            return b"Fujitsu Multimedia Accelerator\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        55 => {
            return b"Siemens PCP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        56 => {
            return b"Sony nCPU embedded RISC processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        57 => {
            return b"Denso NDR1 microprocesspr\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        58 => {
            return b"Motorola Star*Core processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        59 => {
            return b"Toyota ME16 processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        60 => {
            return b"STMicroelectronics ST100 processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        61 => {
            return b"Advanced Logic Corp. TinyJ embedded processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        62 => {
            return b"Advanced Micro Devices X86-64\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        63 => {
            return b"Sony DSP processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        64 => {
            return b"Digital Equipment Corp. PDP-10\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        65 => {
            return b"Digital Equipment Corp. PDP-11\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        66 => {
            return b"Siemens FX66 microcontroller\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        67 => {
            return b"STMicroelectronics ST9+ 8/16 bit microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        68 => {
            return b"STMicroelectronics ST7 8-bit microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        69 => {
            return b"Motorola MC68HC16 Microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        70 => {
            return b"Motorola MC68HC11 Microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        71 => {
            return b"Motorola MC68HC08 Microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        72 => {
            return b"Motorola MC68HC05 Microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        73 => {
            return b"Silicon Graphics SVx\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        74 => {
            return b"STMicroelectronics ST19 8-bit microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        75 => {
            return b"Digital VAX\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        76 => {
            return b"Axis Communications 32-bit embedded processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        77 => {
            return b"Infineon Technologies 32-bit embedded cpu\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        78 => {
            return b"Element 14 64-bit DSP processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        79 => {
            return b"LSI Logic's 16-bit DSP processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        80 => {
            return b"Donald Knuth's educational 64-bit processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        81 => {
            return b"Harvard Universitys's machine-independent object format\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        82 => {
            return b"Vitesse Prism\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        4183 | 83 => {
            return b"Atmel AVR 8-bit microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        13104 | 84 => {
            return b"Fujitsu FR30\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        30288 | 85 => {
            return b"d10v\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        30326 | 86 => {
            return b"d30v\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        36992 | 87 => {
            return b"Renesas V850\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        36929 | 88 => {
            return b"Renesas M32R (formerly Mitsubishi M32r)\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        48879 | 89 => {
            return b"mn10300\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        57005 | 90 => {
            return b"mn10200\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        91 => {
            return b"picoJava\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        92 => {
            return b"OpenRISC 1000\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        93 => {
            return b"ARCompact\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        43975 | 94 => {
            return b"Tensilica Xtensa Processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        95 => {
            return b"Alphamosaic VideoCore processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        96 => {
            return b"Thompson Multimedia General Purpose Processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        97 => {
            return b"National Semiconductor 32000 series\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        98 => {
            return b"Tenor Network TPC processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        99 => {
            return b"Trebia SNP 1000 processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        100 => {
            return b"STMicroelectronics ST200 microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        33303 | 101 => {
            return b"Ubicom IP2xxx 8-bit microcontrollers\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        102 => {
            return b"MAX Processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        103 => {
            return b"National Semiconductor CompactRISC\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        104 => {
            return b"Fujitsu F2MC16\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        105 => {
            return b"Texas Instruments msp430 microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        106 => {
            return b"Analog Devices Blackfin\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        107 => {
            return b"S1C33 Family of Seiko Epson processors\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        108 => {
            return b"Sharp embedded microprocessor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        109 => {
            return b"Arca RISC microprocessor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        110 => {
            return b"Unicore\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        111 => {
            return b"eXcess 16/32/64-bit configurable embedded CPU\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        112 => {
            return b"Icera Semiconductor Inc. Deep Execution Processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        113 => {
            return b"Altera Nios II\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        114 => {
            return b"National Semiconductor CRX microprocessor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        115 => {
            return b"Motorola XGATE embedded processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        116 | 18056 => {
            return b"Infineon Technologies xc16x\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        117 => {
            return b"Renesas M16C series microprocessors\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        118 => {
            return b"Microchip Technology dsPIC30F Digital Signal Controller\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        119 => {
            return b"Freescale Communication Engine RISC core\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        120 => {
            return b"Renesas M32c\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        131 => {
            return b"Altium TSK3000 core\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        132 => {
            return b"Freescale RS08 embedded processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        134 => {
            return b"Cyan Technology eCOG2 microprocessor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        135 => {
            return b"SUNPLUS S+Core\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        136 => {
            return b"New Japan Radio (NJR) 24-bit DSP Processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        137 => {
            return b"Broadcom VideoCore III processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        138 => {
            return b"Lattice Mico32\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        139 => {
            return b"Seiko Epson C17 family\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        140 => {
            return b"Texas Instruments TMS320C6000 DSP family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        141 => {
            return b"Texas Instruments TMS320C2000 DSP family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        142 => {
            return b"Texas Instruments TMS320C55x DSP family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        144 => {
            return b"TI PRU I/O processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        160 => {
            return b"STMicroelectronics 64bit VLIW Data Signal Processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        161 => {
            return b"Cypress M8C microprocessor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        162 => {
            return b"Renesas R32C series microprocessors\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        163 => {
            return b"NXP Semiconductors TriMedia architecture family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        164 => {
            return b"QUALCOMM DSP6 Processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        165 => {
            return b"Intel 8051 and variants\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        166 => {
            return b"STMicroelectronics STxP7x family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        167 => {
            return b"Andes Technology compact code size embedded RISC processor family\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        168 => {
            return b"Cyan Technology eCOG1X family\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        169 => {
            return b"Dallas Semiconductor MAXQ30 Core microcontrollers\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        170 => {
            return b"New Japan Radio (NJR) 16-bit DSP Processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        171 => {
            return b"M2000 Reconfigurable RISC Microprocessor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        172 => {
            return b"Cray Inc. NV2 vector architecture\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        173 => {
            return b"Renesas RX\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        174 => {
            return b"Imagination Technologies Meta processor architecture\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        175 => {
            return b"MCST Elbrus general purpose hardware architecture\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        176 => {
            return b"Cyan Technology eCOG16 family\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        177 | 189 | 47787 => {
            return b"Xilinx MicroBlaze\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        178 => {
            return b"Freescale Extended Time Processing Unit\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        179 => {
            return b"Infineon Technologies SLE9X core\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        180 => {
            return b"Intel L1OM\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        181 => {
            return b"Intel K1OM\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        182 => {
            return b"Intel (reserved)\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        183 => {
            return b"AArch64\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        184 => {
            return b"ARM (reserved)\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        185 => {
            return b"Atmel Corporation 32-bit microprocessor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        186 => {
            return b"STMicroeletronics STM8 8-bit microcontroller\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        187 => {
            return b"Tilera TILE64 multicore architecture family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        188 => {
            return b"Tilera TILEPro multicore architecture family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        190 => {
            return b"NVIDIA CUDA architecture\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        191 => {
            return b"Tilera TILE-Gx multicore architecture family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        192 => {
            return b"CloudShield architecture family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        193 => {
            return b"KIPO-KAIST Core-A 1st generation processor family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        194 => {
            return b"KIPO-KAIST Core-A 2nd generation processor family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        195 => return b"ARCv2\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        196 => {
            return b"Open8 8-bit RISC soft processor core\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        197 => {
            return b"Renesas RL78\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        198 => {
            return b"Broadcom VideoCore V processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        199 => {
            return b"Renesas 78K0R\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        200 => {
            return b"Freescale 56800EX Digital Signal Controller (DSC)\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        201 => {
            return b"Beyond BA1 CPU architecture\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        202 => {
            return b"Beyond BA2 CPU architecture\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        203 => {
            return b"XMOS xCORE processor family\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        204 => {
            return b"Microchip 8-bit PIC(r) family\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        205 => {
            return b"Intel Graphics Technology\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        210 => {
            return b"KM211 KM32 32-bit processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        211 => {
            return b"KM211 KMX32 32-bit processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        212 => {
            return b"KM211 KMX16 16-bit processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        213 => {
            return b"KM211 KMX8 8-bit processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        214 => {
            return b"KM211 KVARC processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        215 => {
            return b"Paneve CDP architecture family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        216 => {
            return b"Cognitive Smart Memory Processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        217 => {
            return b"Bluechip Systems CoolEngine\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        218 => {
            return b"Nanoradio Optimized RISC\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        219 => {
            return b"CSR Kalimba architecture family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        220 => {
            return b"Zilog Z80\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        221 => {
            return b"CDS VISIUMcore processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        222 => {
            return b"FTDI Chip FT32\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        223 => return b"Moxie\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        224 => {
            return b"AMD GPU\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        243 => {
            return b"RISC-V\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        244 => {
            return b"Lanai 32-bit processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        245 => {
            return b"CEVA Processor Architecture Family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        246 => {
            return b"CEVA X2 Processor Family\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        247 => {
            return b"Linux BPF\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        248 => {
            return b"Graphcore Intelligent Processing Unit\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        249 => {
            return b"Imagination Technologies\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        250 => {
            return b"Netronome Flow Processor\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        251 => {
            return b"NEC Vector Engine\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        252 => return b"C-SKY\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        253 => {
            return b"Synopsys ARCv2.3 64-bit\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        254 => {
            return b"MOS Technology MCS 6502 processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        255 => {
            return b"Synopsys ARCv2.3 32-bit\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        256 => {
            return b"Kalray VLIW core of the MPPA processor family\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        257 => {
            return b"WDC 65816/65C816\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        258 => {
            return b"LoongArch\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        259 => {
            return b"ChipON KungFu32\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        9520 => {
            return b"Morpho Techologies MT processor\0" as *const u8
                as *const libc::c_char as *mut libc::c_char;
        }
        36902 => {
            return b"Alpha\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        16727 => {
            return b"Web Assembly\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        23205 => {
            return b"OpenDLX\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        44357 => {
            return b"Sanyo XStormy16 CPU core\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        65210 => {
            return b"Vitesse IQ2000\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        65200 | 65211 => {
            return b"Altera Nios\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        61453 => {
            return b"Toshiba MeP Media Engine\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        4643 => {
            return b"Adapteva EPIPHANY\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        21569 => {
            return b"Fujitsu FR-V\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        19951 => {
            return b"Freescale S12Z\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char;
        }
        _ => {
            snprintf(
                buff.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"<unknown>: 0x%x\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                e_machine,
            );
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn decode_ARC_machine_flags(
    mut e_flags: libc::c_uint,
    mut e_machine: libc::c_uint,
    mut buf: *mut libc::c_char,
) {
    match e_flags & 0xff as libc::c_int as libc::c_uint {
        5 => {
            strcat(buf, b", ARC EM\0" as *const u8 as *const libc::c_char);
        }
        6 => {
            strcat(buf, b", ARC HS\0" as *const u8 as *const libc::c_char);
        }
        2 => {
            strcat(buf, b", ARC600\0" as *const u8 as *const libc::c_char);
        }
        4 => {
            strcat(buf, b", ARC601\0" as *const u8 as *const libc::c_char);
        }
        3 => {
            strcat(buf, b", ARC700\0" as *const u8 as *const libc::c_char);
        }
        _ => {
            if e_machine == 93 as libc::c_int as libc::c_uint {
                strcat(
                    buf,
                    b", Unknown ARCompact\0" as *const u8 as *const libc::c_char,
                );
            } else {
                strcat(buf, b", Unknown ARC\0" as *const u8 as *const libc::c_char);
            }
        }
    }
    match e_flags & 0xf00 as libc::c_int as libc::c_uint {
        0 => {
            strcat(buf, b", (ABI:legacy)\0" as *const u8 as *const libc::c_char);
        }
        512 => {
            strcat(buf, b", (ABI:v2)\0" as *const u8 as *const libc::c_char);
        }
        768 => {
            strcat(
                buf,
                b", v3 no-legacy-syscalls ABI\0" as *const u8 as *const libc::c_char,
            );
        }
        1024 => {
            strcat(buf, b", v4 ABI\0" as *const u8 as *const libc::c_char);
        }
        _ => {
            strcat(
                buf,
                b", unrecognised ARC OSABI flag\0" as *const u8 as *const libc::c_char,
            );
        }
    };
}
unsafe extern "C" fn decode_ARM_machine_flags(
    mut e_flags: libc::c_uint,
    mut buf: *mut libc::c_char,
) {
    let mut eabi: libc::c_uint = 0;
    let mut unknown: bool = 0 as libc::c_int != 0;
    eabi = e_flags & 0xff000000 as libc::c_uint;
    e_flags &= !(0xff000000 as libc::c_uint);
    if e_flags & 0x1 as libc::c_int as libc::c_uint != 0 {
        strcat(buf, b", relocatable executable\0" as *const u8 as *const libc::c_char);
        e_flags &= !(0x1 as libc::c_int) as libc::c_uint;
    }
    if e_flags & 0x20 as libc::c_int as libc::c_uint != 0 {
        strcat(buf, b", position independent\0" as *const u8 as *const libc::c_char);
        e_flags &= !(0x20 as libc::c_int) as libc::c_uint;
    }
    match eabi {
        16777216 => {
            strcat(buf, b", Version1 EABI\0" as *const u8 as *const libc::c_char);
            while e_flags != 0 {
                let mut flag: libc::c_uint = 0;
                flag = e_flags & e_flags.wrapping_neg();
                e_flags &= !flag;
                match flag {
                    4 => {
                        strcat(
                            buf,
                            b", sorted symbol tables\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    _ => {
                        unknown = 1 as libc::c_int != 0;
                    }
                }
            }
        }
        33554432 => {
            strcat(buf, b", Version2 EABI\0" as *const u8 as *const libc::c_char);
            while e_flags != 0 {
                let mut flag_0: libc::c_uint = 0;
                flag_0 = e_flags & e_flags.wrapping_neg();
                e_flags &= !flag_0;
                match flag_0 {
                    4 => {
                        strcat(
                            buf,
                            b", sorted symbol tables\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    8 => {
                        strcat(
                            buf,
                            b", dynamic symbols use segment index\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    16 => {
                        strcat(
                            buf,
                            b", mapping symbols precede others\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    _ => {
                        unknown = 1 as libc::c_int != 0;
                    }
                }
            }
        }
        50331648 => {
            strcat(buf, b", Version3 EABI\0" as *const u8 as *const libc::c_char);
        }
        67108864 => {
            strcat(buf, b", Version4 EABI\0" as *const u8 as *const libc::c_char);
            while e_flags != 0 {
                let mut flag_1: libc::c_uint = 0;
                flag_1 = e_flags & e_flags.wrapping_neg();
                e_flags &= !flag_1;
                match flag_1 {
                    8388608 => {
                        strcat(buf, b", BE8\0" as *const u8 as *const libc::c_char);
                    }
                    4194304 => {
                        strcat(buf, b", LE8\0" as *const u8 as *const libc::c_char);
                    }
                    _ => {
                        unknown = 1 as libc::c_int != 0;
                    }
                }
            }
        }
        83886080 => {
            strcat(buf, b", Version5 EABI\0" as *const u8 as *const libc::c_char);
            while e_flags != 0 {
                let mut flag_2: libc::c_uint = 0;
                flag_2 = e_flags & e_flags.wrapping_neg();
                e_flags &= !flag_2;
                match flag_2 {
                    8388608 => {
                        strcat(buf, b", BE8\0" as *const u8 as *const libc::c_char);
                    }
                    4194304 => {
                        strcat(buf, b", LE8\0" as *const u8 as *const libc::c_char);
                    }
                    512 => {
                        strcat(
                            buf,
                            b", soft-float ABI\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    1024 => {
                        strcat(
                            buf,
                            b", hard-float ABI\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        unknown = 1 as libc::c_int != 0;
                    }
                }
            }
        }
        0 => {
            strcat(buf, b", GNU EABI\0" as *const u8 as *const libc::c_char);
            while e_flags != 0 {
                let mut flag_3: libc::c_uint = 0;
                flag_3 = e_flags & e_flags.wrapping_neg();
                e_flags &= !flag_3;
                match flag_3 {
                    4 => {
                        strcat(
                            buf,
                            b", interworking enabled\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    8 => {
                        strcat(
                            buf,
                            b", uses APCS/26\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    16 => {
                        strcat(
                            buf,
                            b", uses APCS/float\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    32 => {
                        strcat(
                            buf,
                            b", position independent\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    64 => {
                        strcat(
                            buf,
                            b", 8 bit structure alignment\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    128 => {
                        strcat(
                            buf,
                            b", uses new ABI\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    256 => {
                        strcat(
                            buf,
                            b", uses old ABI\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    512 => {
                        strcat(
                            buf,
                            b", software FP\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    1024 => {
                        strcat(buf, b", VFP\0" as *const u8 as *const libc::c_char);
                    }
                    2048 => {
                        strcat(
                            buf,
                            b", Maverick FP\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        unknown = 1 as libc::c_int != 0;
                    }
                }
            }
        }
        _ => {
            strcat(buf, b", <unrecognized EABI>\0" as *const u8 as *const libc::c_char);
            if e_flags != 0 {
                unknown = 1 as libc::c_int != 0;
            }
        }
    }
    if unknown {
        strcat(
            buf,
            dcgettext(
                0 as *const libc::c_char,
                b", <unknown>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
}
unsafe extern "C" fn decode_AVR_machine_flags(
    mut e_flags: libc::c_uint,
    mut buf: *mut libc::c_char,
    mut size: size_t,
) {
    size = size.wrapping_sub(1);
    size;
    match e_flags & 0x7f as libc::c_int as libc::c_uint {
        1 => {
            strncat(buf, b", avr:1\0" as *const u8 as *const libc::c_char, size);
        }
        2 => {
            strncat(buf, b", avr:2\0" as *const u8 as *const libc::c_char, size);
        }
        25 => {
            strncat(buf, b", avr:25\0" as *const u8 as *const libc::c_char, size);
        }
        3 => {
            strncat(buf, b", avr:3\0" as *const u8 as *const libc::c_char, size);
        }
        31 => {
            strncat(buf, b", avr:31\0" as *const u8 as *const libc::c_char, size);
        }
        35 => {
            strncat(buf, b", avr:35\0" as *const u8 as *const libc::c_char, size);
        }
        4 => {
            strncat(buf, b", avr:4\0" as *const u8 as *const libc::c_char, size);
        }
        5 => {
            strncat(buf, b", avr:5\0" as *const u8 as *const libc::c_char, size);
        }
        51 => {
            strncat(buf, b", avr:51\0" as *const u8 as *const libc::c_char, size);
        }
        6 => {
            strncat(buf, b", avr:6\0" as *const u8 as *const libc::c_char, size);
        }
        100 => {
            strncat(buf, b", avr:100\0" as *const u8 as *const libc::c_char, size);
        }
        101 => {
            strncat(buf, b", avr:101\0" as *const u8 as *const libc::c_char, size);
        }
        102 => {
            strncat(buf, b", avr:102\0" as *const u8 as *const libc::c_char, size);
        }
        103 => {
            strncat(buf, b", avr:103\0" as *const u8 as *const libc::c_char, size);
        }
        104 => {
            strncat(buf, b", avr:104\0" as *const u8 as *const libc::c_char, size);
        }
        105 => {
            strncat(buf, b", avr:105\0" as *const u8 as *const libc::c_char, size);
        }
        106 => {
            strncat(buf, b", avr:106\0" as *const u8 as *const libc::c_char, size);
        }
        107 => {
            strncat(buf, b", avr:107\0" as *const u8 as *const libc::c_char, size);
        }
        _ => {
            strncat(buf, b", avr:<unknown>\0" as *const u8 as *const libc::c_char, size);
        }
    }
    size = (size as libc::c_ulong).wrapping_sub(strlen(buf as *const libc::c_char))
        as size_t as size_t;
    if e_flags & 0x80 as libc::c_int as libc::c_uint != 0 {
        strncat(buf, b", link-relax\0" as *const u8 as *const libc::c_char, size);
    }
}
unsafe extern "C" fn decode_NDS32_machine_flags(
    mut e_flags: libc::c_uint,
    mut buf: *mut libc::c_char,
    mut size: size_t,
) {
    let mut abi: libc::c_uint = 0;
    let mut arch: libc::c_uint = 0;
    let mut config: libc::c_uint = 0;
    let mut version: libc::c_uint = 0;
    let mut has_fpu: bool = 0 as libc::c_int != 0;
    let mut r: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    static mut ABI_STRINGS: [*const libc::c_char; 6] = [
        b"ABI v0\0" as *const u8 as *const libc::c_char,
        b"ABI v1\0" as *const u8 as *const libc::c_char,
        b"ABI v2\0" as *const u8 as *const libc::c_char,
        b"ABI v2fp\0" as *const u8 as *const libc::c_char,
        b"AABI\0" as *const u8 as *const libc::c_char,
        b"ABI2 FP+\0" as *const u8 as *const libc::c_char,
    ];
    static mut VER_STRINGS: [*const libc::c_char; 3] = [
        b"Andes ELF V1.3 or older\0" as *const u8 as *const libc::c_char,
        b"Andes ELF V1.3.1\0" as *const u8 as *const libc::c_char,
        b"Andes ELF V1.4\0" as *const u8 as *const libc::c_char,
    ];
    static mut ARCH_STRINGS: [*const libc::c_char; 5] = [
        b"\0" as *const u8 as *const libc::c_char,
        b"Andes Star v1.0\0" as *const u8 as *const libc::c_char,
        b"Andes Star v2.0\0" as *const u8 as *const libc::c_char,
        b"Andes Star v3.0\0" as *const u8 as *const libc::c_char,
        b"Andes Star v3.0m\0" as *const u8 as *const libc::c_char,
    ];
    abi = 0xf0 as libc::c_int as libc::c_uint & e_flags;
    arch = 0xf0000000 as libc::c_uint & e_flags;
    config = 0xfffff00 as libc::c_int as libc::c_uint & e_flags;
    version = 0xf as libc::c_int as libc::c_uint & e_flags;
    memset(buf as *mut libc::c_void, 0 as libc::c_int, size);
    match abi {
        0 | 16 | 32 | 48 | 64 | 80 => {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", %s\0" as *const u8 as *const libc::c_char,
                        ABI_STRINGS[(abi >> 4 as libc::c_int) as usize],
                    ) as libc::c_uint,
                );
        }
        _ => {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", <unrecognized ABI>\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
    }
    match version {
        0 | 1 | 2 => {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", %s\0" as *const u8 as *const libc::c_char,
                        VER_STRINGS[(version >> 0 as libc::c_int) as usize],
                    ) as libc::c_uint,
                );
        }
        _ => {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", <unrecognized ELF version number>\0" as *const u8
                            as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
    }
    if 0 as libc::c_int as libc::c_uint == abi {
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", Andes Star v1.0, N1213HC, MAC, PERF1\0" as *const u8
                        as *const libc::c_char,
                ) as libc::c_uint,
            );
        if arch == 0x10000000 as libc::c_int as libc::c_uint {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", 16b\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
        return;
    }
    match arch {
        268435456 | 536870912 | 805306368 | 1073741824 => {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", %s\0" as *const u8 as *const libc::c_char,
                        ARCH_STRINGS[(arch >> 28 as libc::c_int) as usize],
                    ) as libc::c_uint,
                );
        }
        _ => {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", <unrecognized architecture>\0" as *const u8
                            as *const libc::c_char,
                    ) as libc::c_uint,
                );
            return;
        }
    }
    if arch == 0x10000000 as libc::c_int as libc::c_uint {
        if config & 0x100 as libc::c_int as libc::c_uint != 0 {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", MFUSR_PC\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
        if config & 0x100000 as libc::c_int as libc::c_uint == 0 {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", MAC\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
        if config & 0x2000 as libc::c_int as libc::c_uint != 0 {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", DIV\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
        if config & 0x4000 as libc::c_int as libc::c_uint != 0 {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", 16b\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
    } else {
        if config & 0x100 as libc::c_int as libc::c_uint != 0 {
            if version <= 0x1 as libc::c_int as libc::c_uint {
                r = r
                    .wrapping_add(
                        snprintf(
                            buf.offset(r as isize),
                            size.wrapping_sub(r as libc::c_ulong),
                            b", [B8]\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint,
                    );
            } else {
                r = r
                    .wrapping_add(
                        snprintf(
                            buf.offset(r as isize),
                            size.wrapping_sub(r as libc::c_ulong),
                            b", EX9\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint,
                    );
            }
        }
        if config & 0x100000 as libc::c_int as libc::c_uint != 0 {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", MAC_DX\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
        if config & 0x2000 as libc::c_int as libc::c_uint != 0 {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", DIV_DX\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
        if config & 0x4000 as libc::c_int as libc::c_uint != 0 {
            if version <= 0x1 as libc::c_int as libc::c_uint {
                r = r
                    .wrapping_add(
                        snprintf(
                            buf.offset(r as isize),
                            size.wrapping_sub(r as libc::c_ulong),
                            b", 16b\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint,
                    );
            } else {
                r = r
                    .wrapping_add(
                        snprintf(
                            buf.offset(r as isize),
                            size.wrapping_sub(r as libc::c_ulong),
                            b", IFC\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint,
                    );
            }
        }
    }
    if config & 0x200 as libc::c_int as libc::c_uint != 0 {
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", PERF1\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if config & 0x400 as libc::c_int as libc::c_uint != 0 {
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", PERF2\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if config & 0x800 as libc::c_int as libc::c_uint != 0 {
        has_fpu = 1 as libc::c_int != 0;
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", FPU_SP\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if config & 0x80000 as libc::c_int as libc::c_uint != 0 {
        has_fpu = 1 as libc::c_int != 0;
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", FPU_DP\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if config & 0x1000000 as libc::c_int as libc::c_uint != 0 {
        has_fpu = 1 as libc::c_int != 0;
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", FPU_MAC\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if has_fpu {
        match (config & ((0x3 as libc::c_int) << 22 as libc::c_int) as libc::c_uint)
            >> 22 as libc::c_int
        {
            0 => {
                r = r
                    .wrapping_add(
                        snprintf(
                            buf.offset(r as isize),
                            size.wrapping_sub(r as libc::c_ulong),
                            b", FPU_REG:8/4\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint,
                    );
            }
            1 => {
                r = r
                    .wrapping_add(
                        snprintf(
                            buf.offset(r as isize),
                            size.wrapping_sub(r as libc::c_ulong),
                            b", FPU_REG:16/8\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint,
                    );
            }
            2 => {
                r = r
                    .wrapping_add(
                        snprintf(
                            buf.offset(r as isize),
                            size.wrapping_sub(r as libc::c_ulong),
                            b", FPU_REG:32/16\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint,
                    );
            }
            3 => {
                r = r
                    .wrapping_add(
                        snprintf(
                            buf.offset(r as isize),
                            size.wrapping_sub(r as libc::c_ulong),
                            b", FPU_REG:32/32\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_uint,
                    );
            }
            _ => {}
        }
    }
    if config & 0x1000 as libc::c_int as libc::c_uint != 0 {
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", AUDIO\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if config & 0x8000 as libc::c_int as libc::c_uint != 0 {
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", STR\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if config & 0x10000 as libc::c_int as libc::c_uint != 0 {
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", 16REG\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if config & 0x20000 as libc::c_int as libc::c_uint != 0 {
        if version <= 0x1 as libc::c_int as libc::c_uint {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", VIDEO\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        } else {
            r = r
                .wrapping_add(
                    snprintf(
                        buf.offset(r as isize),
                        size.wrapping_sub(r as libc::c_ulong),
                        b", SATURATION\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_uint,
                );
        }
    }
    if config & 0x40000 as libc::c_int as libc::c_uint != 0 {
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", ENCRP\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
    if config & 0x200000 as libc::c_int as libc::c_uint != 0 {
        r = r
            .wrapping_add(
                snprintf(
                    buf.offset(r as isize),
                    size.wrapping_sub(r as libc::c_ulong),
                    b", L2C\0" as *const u8 as *const libc::c_char,
                ) as libc::c_uint,
            );
    }
}
unsafe extern "C" fn get_machine_flags(
    mut filedata: *mut Filedata,
    mut e_flags: libc::c_uint,
    mut e_machine: libc::c_uint,
) -> *mut libc::c_char {
    static mut buf: [libc::c_char; 1024] = [0; 1024];
    buf[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    if e_flags != 0 {
        match e_machine {
            195 | 93 => {
                decode_ARC_machine_flags(e_flags, e_machine, buf.as_mut_ptr());
            }
            40 => {
                decode_ARM_machine_flags(e_flags, buf.as_mut_ptr());
            }
            83 => {
                decode_AVR_machine_flags(
                    e_flags,
                    buf.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                );
            }
            106 => {
                if e_flags & 0x1 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", PIC\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x2 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", FDPIC\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x10 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", code in L1\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x20 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", data in L1\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            21569 => {
                match e_flags & 0xff000000 as libc::c_uint {
                    0 => {}
                    33554432 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", fr300\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    83886080 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", fr400\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    117440512 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", fr405\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    134217728 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", fr450\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    16777216 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", fr500\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    100663296 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", fr550\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    50331648 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", simple\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    67108864 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", tomcat\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", fr???\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
            }
            4 => {
                if e_flags
                    & (0x1000000 as libc::c_int | 0x810000 as libc::c_int
                        | 0x8000 as libc::c_int | 0x2000000 as libc::c_int)
                        as libc::c_uint == 0x1000000 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", m68000\0" as *const u8 as *const libc::c_char,
                    );
                } else if e_flags
                    & (0x1000000 as libc::c_int | 0x810000 as libc::c_int
                        | 0x8000 as libc::c_int | 0x2000000 as libc::c_int)
                        as libc::c_uint == 0x810000 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", cpu32\0" as *const u8 as *const libc::c_char,
                    );
                } else if e_flags
                    & (0x1000000 as libc::c_int | 0x810000 as libc::c_int
                        | 0x8000 as libc::c_int | 0x2000000 as libc::c_int)
                        as libc::c_uint == 0x2000000 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", fido_a\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    let mut isa: *const libc::c_char = dcgettext(
                        0 as *const libc::c_char,
                        b"unknown\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    );
                    let mut mac: *const libc::c_char = dcgettext(
                        0 as *const libc::c_char,
                        b"unknown mac\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    );
                    let mut additional: *const libc::c_char = 0 as *const libc::c_char;
                    match e_flags & 0xf as libc::c_int as libc::c_uint {
                        1 => {
                            isa = b"A\0" as *const u8 as *const libc::c_char;
                            additional = b", nodiv\0" as *const u8
                                as *const libc::c_char;
                        }
                        2 => {
                            isa = b"A\0" as *const u8 as *const libc::c_char;
                        }
                        3 => {
                            isa = b"A+\0" as *const u8 as *const libc::c_char;
                        }
                        4 => {
                            isa = b"B\0" as *const u8 as *const libc::c_char;
                            additional = b", nousp\0" as *const u8
                                as *const libc::c_char;
                        }
                        5 => {
                            isa = b"B\0" as *const u8 as *const libc::c_char;
                        }
                        6 => {
                            isa = b"C\0" as *const u8 as *const libc::c_char;
                        }
                        7 => {
                            isa = b"C\0" as *const u8 as *const libc::c_char;
                            additional = b", nodiv\0" as *const u8
                                as *const libc::c_char;
                        }
                        _ => {}
                    }
                    strcat(
                        buf.as_mut_ptr(),
                        b", cf, isa \0" as *const u8 as *const libc::c_char,
                    );
                    strcat(buf.as_mut_ptr(), isa);
                    if !additional.is_null() {
                        strcat(buf.as_mut_ptr(), additional);
                    }
                    if e_flags & 0x40 as libc::c_int as libc::c_uint != 0 {
                        strcat(
                            buf.as_mut_ptr(),
                            b", float\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    match e_flags & 0x30 as libc::c_int as libc::c_uint {
                        0 => {
                            mac = 0 as *const libc::c_char;
                        }
                        16 => {
                            mac = b"mac\0" as *const u8 as *const libc::c_char;
                        }
                        32 => {
                            mac = b"emac\0" as *const u8 as *const libc::c_char;
                        }
                        48 => {
                            mac = b"emac_b\0" as *const u8 as *const libc::c_char;
                        }
                        _ => {}
                    }
                    if !mac.is_null() {
                        strcat(
                            buf.as_mut_ptr(),
                            b", \0" as *const u8 as *const libc::c_char,
                        );
                        strcat(buf.as_mut_ptr(), mac);
                    }
                }
            }
            61453 => {
                match e_flags & 0xff000000 as libc::c_uint {
                    0 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", generic MeP\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    16777216 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", MeP C2\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    33554432 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", MeP C3\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    67108864 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", MeP C4\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    134217728 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", MeP C5\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    268435456 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", MeP H1\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b", <unknown MeP cpu type>\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
                match e_flags & 0xff0000 as libc::c_int as libc::c_uint {
                    0 => {}
                    65536 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", AVC coprocessor\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    131072 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", AVC2 coprocessor\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    196608 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", FMAX coprocessor\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    393216 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", IVC2 coprocessor\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b"<unknown MeP copro type>\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
                if e_flags & 0x100 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", Built for Library\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0xff as libc::c_int as libc::c_uint != 0 {
                    sprintf(
                        buf.as_mut_ptr().offset(strlen(buf.as_mut_ptr()) as isize),
                        b", Configuration Index: %#x\0" as *const u8
                            as *const libc::c_char,
                        e_flags & 0xff as libc::c_int as libc::c_uint,
                    );
                }
                if e_flags & !(0xffff01ff as libc::c_uint) != 0 {
                    sprintf(
                        buf.as_mut_ptr().offset(strlen(buf.as_mut_ptr()) as isize),
                        dcgettext(
                            0 as *const libc::c_char,
                            b", unknown flags bits: %#x\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        e_flags & !(0xffff01ff as libc::c_uint),
                    );
                }
            }
            20 => {
                if e_flags & 0x80000000 as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", emb\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x10000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        dcgettext(
                            0 as *const libc::c_char,
                            b", relocatable\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                if e_flags & 0x8000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        dcgettext(
                            0 as *const libc::c_char,
                            b", relocatable-lib\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            21 => {
                if e_flags & 3 as libc::c_int as libc::c_uint != 0 {
                    let mut abi: [libc::c_char; 8] = *::core::mem::transmute::<
                        &[u8; 8],
                        &mut [libc::c_char; 8],
                    >(b", abiv0\0");
                    abi[6 as libc::c_int
                        as usize] = (abi[6 as libc::c_int as usize] as libc::c_uint)
                        .wrapping_add(e_flags & 3 as libc::c_int as libc::c_uint)
                        as libc::c_char as libc::c_char;
                    strcat(buf.as_mut_ptr(), abi.as_mut_ptr());
                }
            }
            36 => {
                if e_flags & 0xf0000000 as libc::c_uint == 0xf0000000 as libc::c_uint {
                    strcat(
                        buf.as_mut_ptr(),
                        b", RH850 ABI\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x100000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", V3 architecture\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & (0x1 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", FPU not used\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & (0x20 as libc::c_int | 0x40 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", regmode: COMMON\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags
                    & (0x100 as libc::c_int | 0x200 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", r4 not used\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags
                    & (0x400 as libc::c_int | 0x800 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", r30 not used\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags
                    & (0x1000 as libc::c_int | 0x2000 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", r5 not used\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags
                    & (0x4000 as libc::c_int | 0x8000 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", r2 not used\0" as *const u8 as *const libc::c_char,
                    );
                }
                e_flags &= 0xffff as libc::c_int as libc::c_uint;
                while e_flags != 0 {
                    match e_flags & e_flags.wrapping_neg() {
                        1 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", double precision FPU\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        2 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", single precision FPU\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        32 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", regmode:22\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        64 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", regmode:23\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        256 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", r4 fixed\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        512 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", r4 free\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        1024 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", r30 fixed\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        2048 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", r30 free\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        4096 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", r5 fixed\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        8192 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", r5 free\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        16384 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", r2 fixed\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        32768 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", r2 free\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        _ => {}
                    }
                    e_flags &= !(e_flags & e_flags.wrapping_neg());
                }
            }
            87 | 36992 => {
                match e_flags & 0xf0000000 as libc::c_uint {
                    1610612736 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", v850e3v5\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    1073741824 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", v850e2v3\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    805306368 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", v850e2\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    536870912 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", v850e1\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    268435456 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", v850e\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    0 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", v850\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b", unknown v850 architecture variant\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
            }
            88 | 36929 => {
                if e_flags & 0x30000000 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", m32r\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            8 | 10 => {
                if e_flags & 0x1 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", noreorder\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x2 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", pic\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x4 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", cpic\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x10 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", ugen_reserved\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x20 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", abi2\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x80 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", odk first\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x100 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", 32bitmode\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x400 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", nan2008\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x200 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", fp64\0" as *const u8 as *const libc::c_char,
                    );
                }
                match e_flags & 0xff0000 as libc::c_int as libc::c_uint {
                    8454144 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 3900\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    8519680 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 4010\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    8585216 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 4100\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    8912896 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 4111\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    8847360 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 4120\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    8716288 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 4650\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9502720 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 5400\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9961472 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 5500\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9568256 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 5900\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9043968 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sb1\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    10027008 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", 9000\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    10485760 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", loongson-2e\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    10551296 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", loongson-2f\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    10616832 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", gs464\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    10682368 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", gs464e\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    10747904 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", gs264e\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9109504 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", octeon\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9240576 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", octeon2\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9306112 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", octeon3\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9175040 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", xlr\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9633792 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", interaptiv-mr2\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    0 => {}
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b", unknown CPU\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
                match e_flags & 0xf000 as libc::c_int as libc::c_uint {
                    4096 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", o32\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    8192 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", o64\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    12288 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", eabi32\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    16384 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", eabi64\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    0 => {}
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b", unknown ABI\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
                if e_flags & 0x8000000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", mdmx\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x4000000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", mips16\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x2000000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", micromips\0" as *const u8 as *const libc::c_char,
                    );
                }
                match e_flags & 0xf0000000 as libc::c_uint {
                    0 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips1\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    268435456 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips2\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    536870912 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips3\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    805306368 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips4\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    1073741824 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips5\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    1342177280 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips32\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    1879048192 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips32r2\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    2415919104 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips32r6\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    1610612736 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips64\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    2147483648 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips64r2\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    2684354560 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", mips64r6\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b", unknown ISA\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
            }
            167 => {
                decode_NDS32_machine_flags(
                    e_flags,
                    buf.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                );
            }
            250 => {
                match e_flags >> 8 as libc::c_int & 0xffff as libc::c_int as libc::c_uint
                {
                    12800 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", NFP-32xx\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    24576 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", NFP-6xxx\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {}
                }
            }
            243 => {
                if e_flags & 0x1 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", RVC\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x8 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", RVE\0" as *const u8 as *const libc::c_char,
                    );
                }
                match e_flags & 0x6 as libc::c_int as libc::c_uint {
                    0 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", soft-float ABI\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    2 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", single-float ABI\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    4 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", double-float ABI\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    6 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", quad-float ABI\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {}
                }
            }
            42 => {
                match e_flags & 0x1f as libc::c_int as libc::c_uint {
                    1 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh1\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    2 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh2\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    3 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh3\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    4 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh-dsp\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    5 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh3-dsp\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    6 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh4al-dsp\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    8 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh3e\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    9 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh4\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    10 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh5\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    11 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh2e\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    12 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh4a\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    13 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh2a\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    16 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh4-nofpu\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    17 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh4a-nofpu\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    19 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh2a-nofpu\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    20 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh3-nommu\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    18 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh4-nommu-nofpu\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    21 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh2a-nofpu-or-sh4-nommu-nofpu\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    22 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh2a-nofpu-or-sh3-nommu\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    23 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh2a-or-sh4\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    24 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", sh2a-or-sh3e\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b", unknown ISA\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
                if e_flags & 0x100 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", pic\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x8000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", fdpic\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            92 => {
                if e_flags as libc::c_ulong & (1 as libc::c_ulong) << 0 as libc::c_int
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", no delay\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            43 => {
                if e_flags & 0x100 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", v8+\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x200 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", ultrasparcI\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x800 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", ultrasparcIII\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x400 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", halr1\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x800000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", ledata\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x3 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", tso\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x3 as libc::c_int as libc::c_uint
                    == 0x1 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", pso\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x3 as libc::c_int as libc::c_uint
                    == 0x2 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", rmo\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            15 => {
                match e_flags & 0xffff as libc::c_int as libc::c_uint {
                    523 => {
                        strcpy(
                            buf.as_mut_ptr(),
                            b", PA-RISC 1.0\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    528 => {
                        strcpy(
                            buf.as_mut_ptr(),
                            b", PA-RISC 1.1\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    532 => {
                        strcpy(
                            buf.as_mut_ptr(),
                            b", PA-RISC 2.0\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {}
                }
                if e_flags & 0x10000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", trapnil\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x20000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", ext\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x40000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", lsb\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x80000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", wide\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x100000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", no kabp\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x400000 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", lazyswap\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            91 | 99 => {
                if e_flags & 0x10 as libc::c_int as libc::c_uint
                    == 0x10 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", new calling convention\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x20 as libc::c_int as libc::c_uint
                    == 0x20 as libc::c_int as libc::c_uint
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", gnu calling convention\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            50 => {
                if e_flags & ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", 64-bit\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    strcat(
                        buf.as_mut_ptr(),
                        b", 32-bit\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & ((1 as libc::c_int) << 5 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", reduced fp model\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", no function descriptors, constant gp\0" as *const u8
                            as *const libc::c_char,
                    );
                } else if e_flags
                    & ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_uint != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", constant gp\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", absolute\0" as *const u8 as *const libc::c_char,
                    );
                }
                if (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                    as libc::c_int == 13 as libc::c_int
                {
                    if e_flags & 0x4 as libc::c_int as libc::c_uint != 0 {
                        strcat(
                            buf.as_mut_ptr(),
                            b", vms_linkages\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    match e_flags & 0x3 as libc::c_int as libc::c_uint {
                        0 => {}
                        1 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", warning\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        2 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", error\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        3 => {
                            strcat(
                                buf.as_mut_ptr(),
                                b", abort\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        _ => {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Unrecognised IA64 VMS Command Code: %x\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                e_flags & 0x3 as libc::c_int as libc::c_uint,
                            );
                            strcat(
                                buf.as_mut_ptr(),
                                b", <unknown>\0" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                }
            }
            75 => {
                if e_flags & 0x1 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", non-PIC\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x100 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", D-Float\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x200 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", G-Float\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            221 => {
                if e_flags & 0x1 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", mcm\0" as *const u8 as *const libc::c_char,
                    );
                } else if e_flags & 0x2 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", mcm24\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & 0x4 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", gr6\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            197 => {
                match e_flags & 0xc as libc::c_int as libc::c_uint {
                    4 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", G10\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    8 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", G13\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    12 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", G14\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    0 | _ => {}
                }
                if e_flags & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", 64-bit doubles\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            173 => {
                if e_flags & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", 64-bit doubles\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", dsp\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", pid\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", RX ABI\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        if e_flags
                            & ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint
                            != 0
                        {
                            b", uses String instructions\0" as *const u8
                                as *const libc::c_char
                        } else {
                            b", bans String instructions\0" as *const u8
                                as *const libc::c_char
                        },
                    );
                }
                if e_flags & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", V2\0" as *const u8 as *const libc::c_char,
                    );
                }
                if e_flags & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_uint
                    != 0
                {
                    strcat(
                        buf.as_mut_ptr(),
                        b", V3\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            22 => {
                if e_flags & 0x1 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", highgprs\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            140 => {
                if e_flags & 0x1 as libc::c_int as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        b", relocatable module\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            105 => {
                strcat(
                    buf.as_mut_ptr(),
                    dcgettext(
                        0 as *const libc::c_char,
                        b": architecture variant: \0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                match e_flags & 0xff as libc::c_int as libc::c_uint {
                    11 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x11\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    110 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x11x1 \0" as *const u8 as *const libc::c_char,
                        );
                    }
                    12 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x12\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    13 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x13\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    14 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x14\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    15 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x15\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    16 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x16\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    31 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x31\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    32 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x32\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    33 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x33\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    41 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x41\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    42 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x42\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    43 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x43\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    44 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430x44\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    45 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b"MSP430X\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b": unknown\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
                if e_flags & !(0xff as libc::c_int) as libc::c_uint != 0 {
                    strcat(
                        buf.as_mut_ptr(),
                        dcgettext(
                            0 as *const libc::c_char,
                            b": unknown extra flag bits also present\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            220 => {
                match e_flags & 0xff as libc::c_int as libc::c_uint {
                    1 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", Z80\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    2 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", Z180\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    3 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", R800\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    4 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", EZ80\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    132 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", EZ80, ADL\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    5 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", GBZ80\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    6 => {
                        strcat(
                            buf.as_mut_ptr(),
                            b", Z80N\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        strcat(
                            buf.as_mut_ptr(),
                            dcgettext(
                                0 as *const libc::c_char,
                                b", unknown\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
            }
            _ => {}
        }
    }
    return buf.as_mut_ptr();
}
unsafe extern "C" fn get_osabi_name(
    mut filedata: *mut Filedata,
    mut osabi: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 32] = [0; 32];
    match osabi {
        0 => return b"UNIX - System V\0" as *const u8 as *const libc::c_char,
        1 => return b"UNIX - HP-UX\0" as *const u8 as *const libc::c_char,
        2 => return b"UNIX - NetBSD\0" as *const u8 as *const libc::c_char,
        3 => return b"UNIX - GNU\0" as *const u8 as *const libc::c_char,
        6 => return b"UNIX - Solaris\0" as *const u8 as *const libc::c_char,
        7 => return b"UNIX - AIX\0" as *const u8 as *const libc::c_char,
        8 => return b"UNIX - IRIX\0" as *const u8 as *const libc::c_char,
        9 => return b"UNIX - FreeBSD\0" as *const u8 as *const libc::c_char,
        10 => return b"UNIX - TRU64\0" as *const u8 as *const libc::c_char,
        11 => return b"Novell - Modesto\0" as *const u8 as *const libc::c_char,
        12 => return b"UNIX - OpenBSD\0" as *const u8 as *const libc::c_char,
        13 => return b"VMS - OpenVMS\0" as *const u8 as *const libc::c_char,
        14 => return b"HP - Non-Stop Kernel\0" as *const u8 as *const libc::c_char,
        15 => return b"AROS\0" as *const u8 as *const libc::c_char,
        16 => return b"FenixOS\0" as *const u8 as *const libc::c_char,
        17 => return b"Nuxi CloudABI\0" as *const u8 as *const libc::c_char,
        18 => {
            return b"Stratus Technologies OpenVOS\0" as *const u8 as *const libc::c_char;
        }
        _ => {
            if osabi >= 64 as libc::c_int as libc::c_uint {
                match (*filedata).file_header.e_machine as libc::c_int {
                    40 => {
                        match osabi {
                            97 => return b"ARM\0" as *const u8 as *const libc::c_char,
                            65 => {
                                return b"ARM FDPIC\0" as *const u8 as *const libc::c_char;
                            }
                            _ => {}
                        }
                    }
                    105 | 4185 | 221 => {
                        match osabi {
                            255 => {
                                return dcgettext(
                                    0 as *const libc::c_char,
                                    b"Standalone App\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                );
                            }
                            _ => {}
                        }
                    }
                    140 => {
                        match osabi {
                            64 => {
                                return dcgettext(
                                    0 as *const libc::c_char,
                                    b"Bare-metal C6000\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                );
                            }
                            65 => {
                                return b"Linux C6000\0" as *const u8 as *const libc::c_char;
                            }
                            _ => {}
                        }
                    }
                    _ => {}
                }
            }
            snprintf(
                buff.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                osabi,
            );
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn get_aarch64_segment_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"AARCH64_ARCHEXT\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_arm_segment_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048193 => return b"EXIDX\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_s390_segment_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"S390_PGSTE\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_mips_segment_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"REGINFO\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"RTPROC\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"OPTIONS\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"ABIFLAGS\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_parisc_segment_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"PARISC_ARCHEXT\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"PARISC_UNWIND\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"PARISC_WEAKORDER\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_ia64_segment_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"IA_64_ARCHEXT\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"IA_64_UNWIND\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_tic6x_segment_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1879048192 => return b"C6000_PHATTR\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_hpux_segment_type(
    mut type_0: libc::c_ulong,
    mut e_machine: libc::c_uint,
) -> *const libc::c_char {
    if e_machine == 15 as libc::c_int as libc::c_uint {
        match type_0 {
            1610612736 => return b"HP_TLS\0" as *const u8 as *const libc::c_char,
            1610612737 => return b"HP_CORE_NONE\0" as *const u8 as *const libc::c_char,
            1610612738 => return b"HP_CORE_VERSION\0" as *const u8 as *const libc::c_char,
            1610612739 => return b"HP_CORE_KERNEL\0" as *const u8 as *const libc::c_char,
            1610612740 => return b"HP_CORE_COMM\0" as *const u8 as *const libc::c_char,
            1610612741 => return b"HP_CORE_PROC\0" as *const u8 as *const libc::c_char,
            1610612742 => {
                return b"HP_CORE_LOADABLE\0" as *const u8 as *const libc::c_char;
            }
            1610612743 => return b"HP_CORE_STACK\0" as *const u8 as *const libc::c_char,
            1610612744 => return b"HP_CORE_SHM\0" as *const u8 as *const libc::c_char,
            1610612745 => return b"HP_CORE_MMF\0" as *const u8 as *const libc::c_char,
            1610612752 => return b"HP_PARALLEL\0" as *const u8 as *const libc::c_char,
            1610612753 => return b"HP_FASTBIND\0" as *const u8 as *const libc::c_char,
            1610612754 => return b"HP_OPT_ANNOT\0" as *const u8 as *const libc::c_char,
            1610612755 => return b"HP_HSL_ANNOT\0" as *const u8 as *const libc::c_char,
            1610612756 => return b"HP_STACK\0" as *const u8 as *const libc::c_char,
            1610612757 => return b"HP_CORE_UTSNAME\0" as *const u8 as *const libc::c_char,
            _ => return 0 as *const libc::c_char,
        }
    }
    if e_machine == 50 as libc::c_int as libc::c_uint {
        match type_0 {
            1610612736 => return b"HP_TLS\0" as *const u8 as *const libc::c_char,
            1610612754 => return b"HP_OPT_ANNOT\0" as *const u8 as *const libc::c_char,
            1610612755 => return b"HP_HSL_ANNOT\0" as *const u8 as *const libc::c_char,
            1610612756 => return b"HP_STACK\0" as *const u8 as *const libc::c_char,
            _ => return 0 as *const libc::c_char,
        }
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn get_solaris_segment_type(
    mut type_0: libc::c_ulong,
) -> *const libc::c_char {
    match type_0 {
        1684333904 => return b"PT_SUNW_UNWIND\0" as *const u8 as *const libc::c_char,
        1685382480 => return b"PT_SUNW_EH_FRAME\0" as *const u8 as *const libc::c_char,
        1879048183 => return b"PT_LOSUNW\0" as *const u8 as *const libc::c_char,
        1879048186 => return b"PT_SUNWBSS\0" as *const u8 as *const libc::c_char,
        1879048187 => return b"PT_SUNWSTACK\0" as *const u8 as *const libc::c_char,
        1879048188 => return b"PT_SUNWDTRACE\0" as *const u8 as *const libc::c_char,
        1879048189 => return b"PT_SUNWCAP\0" as *const u8 as *const libc::c_char,
        1879048191 => return b"PT_HISUNW\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_segment_type(
    mut filedata: *mut Filedata,
    mut p_type: libc::c_ulong,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 32] = [0; 32];
    match p_type {
        0 => return b"NULL\0" as *const u8 as *const libc::c_char,
        1 => return b"LOAD\0" as *const u8 as *const libc::c_char,
        2 => return b"DYNAMIC\0" as *const u8 as *const libc::c_char,
        3 => return b"INTERP\0" as *const u8 as *const libc::c_char,
        4 => return b"NOTE\0" as *const u8 as *const libc::c_char,
        5 => return b"SHLIB\0" as *const u8 as *const libc::c_char,
        6 => return b"PHDR\0" as *const u8 as *const libc::c_char,
        7 => return b"TLS\0" as *const u8 as *const libc::c_char,
        1685382480 => return b"GNU_EH_FRAME\0" as *const u8 as *const libc::c_char,
        1685382481 => return b"GNU_STACK\0" as *const u8 as *const libc::c_char,
        1685382482 => return b"GNU_RELRO\0" as *const u8 as *const libc::c_char,
        1685382483 => return b"GNU_PROPERTY\0" as *const u8 as *const libc::c_char,
        1705237478 => return b"OPENBSD_RANDOMIZE\0" as *const u8 as *const libc::c_char,
        1705237479 => return b"OPENBSD_WXNEEDED\0" as *const u8 as *const libc::c_char,
        1705253862 => return b"OPENBSD_BOOTDATA\0" as *const u8 as *const libc::c_char,
        _ => {
            if p_type >= 0x70000000 as libc::c_int as libc::c_ulong
                && p_type <= 0x7fffffff as libc::c_int as libc::c_ulong
            {
                let mut result: *const libc::c_char = 0 as *const libc::c_char;
                match (*filedata).file_header.e_machine as libc::c_int {
                    183 => {
                        result = get_aarch64_segment_type(p_type);
                    }
                    40 => {
                        result = get_arm_segment_type(p_type);
                    }
                    8 | 10 => {
                        result = get_mips_segment_type(p_type);
                    }
                    15 => {
                        result = get_parisc_segment_type(p_type);
                    }
                    50 => {
                        result = get_ia64_segment_type(p_type);
                    }
                    140 => {
                        result = get_tic6x_segment_type(p_type);
                    }
                    22 | 41872 => {
                        result = get_s390_segment_type(p_type);
                    }
                    _ => {
                        result = 0 as *const libc::c_char;
                    }
                }
                if !result.is_null() {
                    return result;
                }
                sprintf(
                    buff.as_mut_ptr(),
                    b"LOPROC+%#lx\0" as *const u8 as *const libc::c_char,
                    p_type.wrapping_sub(0x70000000 as libc::c_int as libc::c_ulong),
                );
            } else if p_type >= 0x60000000 as libc::c_int as libc::c_ulong
                && p_type <= 0x6fffffff as libc::c_int as libc::c_ulong
            {
                let mut result_0: *const libc::c_char = 0 as *const libc::c_char;
                match (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                    as libc::c_int
                {
                    3 | 9 => {
                        if p_type
                            >= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int)
                                as libc::c_ulong
                            && p_type
                                <= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int
                                    + 4096 as libc::c_int - 1 as libc::c_int) as libc::c_ulong
                        {
                            sprintf(
                                buff.as_mut_ptr(),
                                b"GNU_MBIND+%#lx\0" as *const u8 as *const libc::c_char,
                                p_type
                                    .wrapping_sub(
                                        (0x60000000 as libc::c_int + 0x474e555 as libc::c_int)
                                            as libc::c_ulong,
                                    ),
                            );
                            result_0 = buff.as_mut_ptr();
                        }
                    }
                    1 => {
                        result_0 = get_hpux_segment_type(
                            p_type,
                            (*filedata).file_header.e_machine as libc::c_uint,
                        );
                    }
                    6 => {
                        result_0 = get_solaris_segment_type(p_type);
                    }
                    _ => {}
                }
                if !result_0.is_null() {
                    return result_0;
                }
                sprintf(
                    buff.as_mut_ptr(),
                    b"LOOS+%#lx\0" as *const u8 as *const libc::c_char,
                    p_type.wrapping_sub(0x60000000 as libc::c_int as libc::c_ulong),
                );
            } else {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>: %lx\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    p_type,
                );
            }
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn get_arc_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048193 => return b"ARC_ATTRIBUTES\0" as *const u8 as *const libc::c_char,
        _ => {}
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn get_mips_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048192 => return b"MIPS_LIBLIST\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"MIPS_MSYM\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"MIPS_CONFLICT\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"MIPS_GPTAB\0" as *const u8 as *const libc::c_char,
        1879048196 => return b"MIPS_UCODE\0" as *const u8 as *const libc::c_char,
        1879048197 => return b"MIPS_DEBUG\0" as *const u8 as *const libc::c_char,
        1879048198 => return b"MIPS_REGINFO\0" as *const u8 as *const libc::c_char,
        1879048199 => return b"MIPS_PACKAGE\0" as *const u8 as *const libc::c_char,
        1879048200 => return b"MIPS_PACKSYM\0" as *const u8 as *const libc::c_char,
        1879048201 => return b"MIPS_RELD\0" as *const u8 as *const libc::c_char,
        1879048203 => return b"MIPS_IFACE\0" as *const u8 as *const libc::c_char,
        1879048204 => return b"MIPS_CONTENT\0" as *const u8 as *const libc::c_char,
        1879048205 => return b"MIPS_OPTIONS\0" as *const u8 as *const libc::c_char,
        1879048208 => return b"MIPS_SHDR\0" as *const u8 as *const libc::c_char,
        1879048209 => return b"MIPS_FDESC\0" as *const u8 as *const libc::c_char,
        1879048210 => return b"MIPS_EXTSYM\0" as *const u8 as *const libc::c_char,
        1879048211 => return b"MIPS_DENSE\0" as *const u8 as *const libc::c_char,
        1879048212 => return b"MIPS_PDESC\0" as *const u8 as *const libc::c_char,
        1879048213 => return b"MIPS_LOCSYM\0" as *const u8 as *const libc::c_char,
        1879048214 => return b"MIPS_AUXSYM\0" as *const u8 as *const libc::c_char,
        1879048215 => return b"MIPS_OPTSYM\0" as *const u8 as *const libc::c_char,
        1879048216 => return b"MIPS_LOCSTR\0" as *const u8 as *const libc::c_char,
        1879048217 => return b"MIPS_LINE\0" as *const u8 as *const libc::c_char,
        1879048218 => return b"MIPS_RFDESC\0" as *const u8 as *const libc::c_char,
        1879048219 => return b"MIPS_DELTASYM\0" as *const u8 as *const libc::c_char,
        1879048220 => return b"MIPS_DELTAINST\0" as *const u8 as *const libc::c_char,
        1879048221 => return b"MIPS_DELTACLASS\0" as *const u8 as *const libc::c_char,
        1879048222 => return b"MIPS_DWARF\0" as *const u8 as *const libc::c_char,
        1879048223 => return b"MIPS_DELTADECL\0" as *const u8 as *const libc::c_char,
        1879048224 => return b"MIPS_SYMBOL_LIB\0" as *const u8 as *const libc::c_char,
        1879048225 => return b"MIPS_EVENTS\0" as *const u8 as *const libc::c_char,
        1879048226 => return b"MIPS_TRANSLATE\0" as *const u8 as *const libc::c_char,
        1879048227 => return b"MIPS_PIXIE\0" as *const u8 as *const libc::c_char,
        1879048228 => return b"MIPS_XLATE\0" as *const u8 as *const libc::c_char,
        1879048229 => return b"MIPS_XLATE_DEBUG\0" as *const u8 as *const libc::c_char,
        1879048230 => return b"MIPS_WHIRL\0" as *const u8 as *const libc::c_char,
        1879048231 => return b"MIPS_EH_REGION\0" as *const u8 as *const libc::c_char,
        1879048232 => return b"MIPS_XLATE_OLD\0" as *const u8 as *const libc::c_char,
        1879048233 => return b"MIPS_PDR_EXCEPTION\0" as *const u8 as *const libc::c_char,
        1879048234 => return b"MIPS_ABIFLAGS\0" as *const u8 as *const libc::c_char,
        1879048235 => return b"MIPS_XHASH\0" as *const u8 as *const libc::c_char,
        _ => {}
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn get_parisc_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048192 => return b"PARISC_EXT\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"PARISC_UNWIND\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"PARISC_DOC\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"PARISC_ANNOT\0" as *const u8 as *const libc::c_char,
        1879048200 => return b"PARISC_SYMEXTN\0" as *const u8 as *const libc::c_char,
        1879048201 => return b"PARISC_STUBS\0" as *const u8 as *const libc::c_char,
        1879048196 => return b"PARISC_DLKM\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_ia64_section_type_name(
    mut filedata: *mut Filedata,
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    if sh_type & 0xff000000 as libc::c_uint
        == (0x70000000 as libc::c_int + 0x8000000 as libc::c_int) as libc::c_uint
    {
        return get_osabi_name(
            filedata,
            (sh_type & 0xff0000 as libc::c_int as libc::c_uint) >> 16 as libc::c_int,
        );
    }
    match sh_type {
        1879048192 => return b"IA_64_EXT\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"IA_64_UNWIND\0" as *const u8 as *const libc::c_char,
        2030043136 => return b"IA_64_PRIORITY_INIT\0" as *const u8 as *const libc::c_char,
        1610612736 => return b"VMS_TRACE\0" as *const u8 as *const libc::c_char,
        1610612737 => return b"VMS_TIE_SIGNATURES\0" as *const u8 as *const libc::c_char,
        1610612738 => return b"VMS_DEBUG\0" as *const u8 as *const libc::c_char,
        1610612739 => return b"VMS_DEBUG_STR\0" as *const u8 as *const libc::c_char,
        1610612740 => return b"VMS_LINKAGES\0" as *const u8 as *const libc::c_char,
        1610612741 => return b"VMS_SYMBOL_VECTOR\0" as *const u8 as *const libc::c_char,
        1610612742 => return b"VMS_FIXUP\0" as *const u8 as *const libc::c_char,
        _ => {}
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn get_x86_64_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048193 => return b"X86_64_UNWIND\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_aarch64_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048195 => return b"AARCH64_ATTRIBUTES\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_arm_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048193 => return b"ARM_EXIDX\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"ARM_PREEMPTMAP\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"ARM_ATTRIBUTES\0" as *const u8 as *const libc::c_char,
        1879048196 => return b"ARM_DEBUGOVERLAY\0" as *const u8 as *const libc::c_char,
        1879048197 => return b"ARM_OVERLAYSECTION\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_tic6x_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048193 => return b"C6000_UNWIND\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"C6000_PREEMPTMAP\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"C6000_ATTRIBUTES\0" as *const u8 as *const libc::c_char,
        2130706432 => return b"TI_ICODE\0" as *const u8 as *const libc::c_char,
        2130706433 => return b"TI_XREF\0" as *const u8 as *const libc::c_char,
        2130706434 => return b"TI_HANDLER\0" as *const u8 as *const libc::c_char,
        2130706435 => return b"TI_INITINFO\0" as *const u8 as *const libc::c_char,
        2130706436 => return b"TI_PHATTRS\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_msp430_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        2130706437 => return b"MSP430_SEC_FLAGS\0" as *const u8 as *const libc::c_char,
        2130706438 => return b"MSP430_SYM_ALIASES\0" as *const u8 as *const libc::c_char,
        1879048195 => return b"MSP430_ATTRIBUTES\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_nfp_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048193 => return b"NFP_MECONFIG\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"NFP_INITREG\0" as *const u8 as *const libc::c_char,
        2147483648 => return b"NFP_UDEBUG\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_v850_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048192 => return b"V850 Small Common\0" as *const u8 as *const libc::c_char,
        1879048193 => return b"V850 Tiny Common\0" as *const u8 as *const libc::c_char,
        1879048194 => return b"V850 Zero Common\0" as *const u8 as *const libc::c_char,
        2147483648 => return b"RENESAS IOP\0" as *const u8 as *const libc::c_char,
        2684354560 => return b"RENESAS INFO\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_riscv_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048195 => return b"RISCV_ATTRIBUTES\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_csky_section_type_name(
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    match sh_type {
        1879048193 => return b"CSKY_ATTRIBUTES\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_section_type_name(
    mut filedata: *mut Filedata,
    mut sh_type: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 32] = [0; 32];
    let mut result: *const libc::c_char = 0 as *const libc::c_char;
    match sh_type {
        0 => return b"NULL\0" as *const u8 as *const libc::c_char,
        1 => return b"PROGBITS\0" as *const u8 as *const libc::c_char,
        2 => return b"SYMTAB\0" as *const u8 as *const libc::c_char,
        3 => return b"STRTAB\0" as *const u8 as *const libc::c_char,
        4 => return b"RELA\0" as *const u8 as *const libc::c_char,
        5 => return b"HASH\0" as *const u8 as *const libc::c_char,
        6 => return b"DYNAMIC\0" as *const u8 as *const libc::c_char,
        7 => return b"NOTE\0" as *const u8 as *const libc::c_char,
        8 => return b"NOBITS\0" as *const u8 as *const libc::c_char,
        9 => return b"REL\0" as *const u8 as *const libc::c_char,
        10 => return b"SHLIB\0" as *const u8 as *const libc::c_char,
        11 => return b"DYNSYM\0" as *const u8 as *const libc::c_char,
        14 => return b"INIT_ARRAY\0" as *const u8 as *const libc::c_char,
        15 => return b"FINI_ARRAY\0" as *const u8 as *const libc::c_char,
        16 => return b"PREINIT_ARRAY\0" as *const u8 as *const libc::c_char,
        1879048182 => return b"GNU_HASH\0" as *const u8 as *const libc::c_char,
        17 => return b"GROUP\0" as *const u8 as *const libc::c_char,
        18 => return b"SYMTAB SECTION INDICES\0" as *const u8 as *const libc::c_char,
        1879048189 => return b"VERDEF\0" as *const u8 as *const libc::c_char,
        1879048190 => return b"VERNEED\0" as *const u8 as *const libc::c_char,
        1879048191 => return b"VERSYM\0" as *const u8 as *const libc::c_char,
        1879048176 => return b"VERSYM\0" as *const u8 as *const libc::c_char,
        1879048188 => return b"VERDEF\0" as *const u8 as *const libc::c_char,
        2147483645 => return b"AUXILIARY\0" as *const u8 as *const libc::c_char,
        2147483647 => return b"FILTER\0" as *const u8 as *const libc::c_char,
        1879048183 => return b"GNU_LIBLIST\0" as *const u8 as *const libc::c_char,
        _ => {
            if sh_type >= 0x70000000 as libc::c_int as libc::c_uint
                && sh_type <= 0x7fffffff as libc::c_int as libc::c_uint
            {
                match (*filedata).file_header.e_machine as libc::c_int {
                    45 | 93 | 195 => {
                        result = get_arc_section_type_name(sh_type);
                    }
                    8 | 10 => {
                        result = get_mips_section_type_name(sh_type);
                    }
                    15 => {
                        result = get_parisc_section_type_name(sh_type);
                    }
                    50 => {
                        result = get_ia64_section_type_name(filedata, sh_type);
                    }
                    62 | 180 | 181 => {
                        result = get_x86_64_section_type_name(sh_type);
                    }
                    183 => {
                        result = get_aarch64_section_type_name(sh_type);
                    }
                    40 => {
                        result = get_arm_section_type_name(sh_type);
                    }
                    140 => {
                        result = get_tic6x_section_type_name(sh_type);
                    }
                    105 => {
                        result = get_msp430_section_type_name(sh_type);
                    }
                    250 => {
                        result = get_nfp_section_type_name(sh_type);
                    }
                    36 | 87 | 36992 => {
                        result = get_v850_section_type_name(sh_type);
                    }
                    243 => {
                        result = get_riscv_section_type_name(sh_type);
                    }
                    252 => {
                        result = get_csky_section_type_name(sh_type);
                    }
                    _ => {
                        result = 0 as *const libc::c_char;
                    }
                }
                if !result.is_null() {
                    return result;
                }
                sprintf(
                    buff.as_mut_ptr(),
                    b"LOPROC+%#x\0" as *const u8 as *const libc::c_char,
                    sh_type.wrapping_sub(0x70000000 as libc::c_int as libc::c_uint),
                );
            } else if sh_type >= 0x60000000 as libc::c_int as libc::c_uint
                && sh_type <= 0x6fffffff as libc::c_int as libc::c_uint
            {
                match (*filedata).file_header.e_machine as libc::c_int {
                    50 => {
                        result = get_ia64_section_type_name(filedata, sh_type);
                    }
                    _ => {
                        if (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                            as libc::c_int == 6 as libc::c_int
                        {
                            result = get_solaris_section_type(sh_type as libc::c_ulong);
                        } else {
                            match sh_type {
                                1879000832 => {
                                    result = b"GNU_INCREMENTAL_INPUTS\0" as *const u8
                                        as *const libc::c_char;
                                }
                                1879048181 => {
                                    result = b"GNU_ATTRIBUTES\0" as *const u8
                                        as *const libc::c_char;
                                }
                                1879048182 => {
                                    result = b"GNU_HASH\0" as *const u8 as *const libc::c_char;
                                }
                                1879048183 => {
                                    result = b"GNU_LIBLIST\0" as *const u8
                                        as *const libc::c_char;
                                }
                                _ => {
                                    result = 0 as *const libc::c_char;
                                }
                            }
                        }
                    }
                }
                if !result.is_null() {
                    return result;
                }
                sprintf(
                    buff.as_mut_ptr(),
                    b"LOOS+%#x\0" as *const u8 as *const libc::c_char,
                    sh_type.wrapping_sub(0x60000000 as libc::c_int as libc::c_uint),
                );
            } else if sh_type >= 0x80000000 as libc::c_uint
                && sh_type <= 0xffffffff as libc::c_uint
            {
                match (*filedata).file_header.e_machine as libc::c_int {
                    36 | 87 | 36992 => {
                        result = get_v850_section_type_name(sh_type);
                    }
                    _ => {
                        result = 0 as *const libc::c_char;
                    }
                }
                if !result.is_null() {
                    return result;
                }
                sprintf(
                    buff.as_mut_ptr(),
                    b"LOUSER+%#x\0" as *const u8 as *const libc::c_char,
                    sh_type.wrapping_sub(0x80000000 as libc::c_uint),
                );
            } else {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"%08x: <unknown>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    sh_type,
                );
            }
            return buff.as_mut_ptr();
        }
    };
}
static mut options: [option; 49] = [
    {
        let mut init = option {
            name: b"arch-specific\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'A' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"all\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'a' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"demangle\0" as *const u8 as *const libc::c_char,
            has_arg: 2 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'C' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"archive-index\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'c' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"use-dynamic\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'D' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"dynamic\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'd' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"headers\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'e' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"section-groups\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'g' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"help\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'H' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"file-header\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'h' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"histogram\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'I' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"lint\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'L' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"enable-checks\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'L' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"program-headers\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'l' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"segments\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'l' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"full-section-name\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'N' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"notes\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'n' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"process-links\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'P' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"string-dump\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'p' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"relocated-dump\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'R' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"relocs\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'r' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"section-headers\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'S' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"sections\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'S' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"symbols\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 's' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"syms\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 's' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"silent-truncation\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'T' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"section-details\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 't' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"unwind\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'u' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"version-info\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'V' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"version\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'v' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"wide\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'W' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"hex-dump\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'x' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"decompress\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 'z' as i32,
        };
        init
    },
    {
        let mut init = option {
            name: b"no-demangle\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_NO_DEMANGLING as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"recurse-limit\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_RECURSE_LIMIT as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"no-recurse-limit\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_NO_RECURSE_LIMIT as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"no-recursion-limit\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_NO_RECURSE_LIMIT as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"dyn-syms\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_DYN_SYMS as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"lto-syms\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_LTO_SYMS as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"debug-dump\0" as *const u8 as *const libc::c_char,
            has_arg: 2 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_DEBUG_DUMP as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"dwarf-depth\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_DWARF_DEPTH as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"dwarf-start\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_DWARF_START as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"dwarf-check\0" as *const u8 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_DWARF_CHECK as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"ctf\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_CTF_DUMP as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"ctf-symbols\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_CTF_SYMBOLS as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"ctf-strings\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_CTF_STRINGS as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"ctf-parent\0" as *const u8 as *const libc::c_char,
            has_arg: 1 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_CTF_PARENT as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: b"sym-base\0" as *const u8 as *const libc::c_char,
            has_arg: 2 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: OPTION_SYM_BASE as libc::c_int,
        };
        init
    },
    {
        let mut init = option {
            name: 0 as *const libc::c_char,
            has_arg: 0 as libc::c_int,
            flag: 0 as *const libc::c_int as *mut libc::c_int,
            val: 0 as libc::c_int,
        };
        init
    },
];
unsafe extern "C" fn usage(mut stream: *mut FILE) {
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"Usage: readelf <option(s)> elf-file(s)\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b" Display information about the contents of ELF format files\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b" Options are:\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -h --file-header       Display the ELF file header\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -l --program-headers   Display the program headers\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --segments          An alias for --program-headers\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -S --section-headers   Display the sections' header\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --sections          An alias for --section-headers\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -g --section-groups    Display the section groups\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -t --section-details   Display the section details\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -e --headers           Equivalent to: -h -l -S\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -s --syms              Display the symbol table\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --symbols           An alias for --syms\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --dyn-syms          Display the dynamic symbol table\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --lto-syms          Display LTO symbol tables\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --sym-base=[0|8|10|16] \n                         Force base for symbol sizes.  The options are \n                         mixed (the default), octal, decimal, hexadecimal.\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -C --demangle[=STYLE]  Decode low-level symbol names into user-level names\n                          The STYLE, if specified, can be `auto' (the default),\n                          `gnu', `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n                          or `gnat'\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --no-demangle       Do not demangle low-level symbol names.  (default)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --recurse-limit     Enable a demangling recursion limit.  (default)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"     --no-recurse-limit  Disable a demangling recursion limit\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -n --notes             Display the core notes (if present)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -r --relocs            Display the relocations (if present)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -u --unwind            Display the unwind info (if present)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -d --dynamic           Display the dynamic section (if present)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -V --version-info      Display the version sections (if present)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -A --arch-specific     Display architecture specific information (if any)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -c --archive-index     Display the symbol/file index in an archive\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -D --use-dynamic       Use the dynamic section info when displaying symbols\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -L --lint|--enable-checks\n                         Display warning messages for possible problems\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -x --hex-dump=<number|name>\n                         Dump the contents of section <number|name> as bytes\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -p --string-dump=<number|name>\n                         Dump the contents of section <number|name> as strings\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -R --relocated-dump=<number|name>\n                         Dump the relocated contents of section <number|name>\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -z --decompress        Decompress section before dumping it\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -w --debug-dump[a/=abbrev, A/=addr, r/=aranges, c/=cu_index, L/=decodedline,\n                  f/=frames, F/=frames-interp, g/=gdb_index, i/=info, o/=loc,\n                  m/=macro, p/=pubnames, t/=pubtypes, R/=Ranges, l/=rawline,\n                  s/=str, O/=str-offsets, u/=trace_abbrev, T/=trace_aranges,\n                  U/=trace_info]\n                         Display the contents of DWARF debug sections\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -wk --debug-dump=links Display the contents of sections that link to separate\n                          debuginfo files\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -P --process-links     Display the contents of non-debug sections in separate\n                          debuginfo files.  (Implies -wK)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -wK --debug-dump=follow-links\n                         Follow links to separate debug info files (default)\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -wN --debug-dump=no-follow-links\n                         Do not follow links to separate debug info files\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  --dwarf-depth=N        Do not display DIEs at depth N or greater\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  --dwarf-start=N        Display DIEs starting at offset N\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  --ctf=<number|name>    Display CTF info from section <number|name>\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  --ctf-parent=<number|name>\n                         Use section <number|name> as the CTF parent\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  --ctf-symbols=<number|name>\n                         Use section <number|name> as the CTF external symtab\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  --ctf-strings=<number|name>\n                         Use section <number|name> as the CTF external strtab\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -I --histogram         Display histogram of bucket list lengths\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -W --wide              Allow output width to exceed 80 characters\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -T --silent-truncation If a symbol name is truncated, do not add [...] suffix\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  @<file>                Read options from <file>\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -H --help              Display this information\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    fprintf(
        stream,
        dcgettext(
            0 as *const libc::c_char,
            b"  -v --version           Display the version number of readelf\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    if (*::core::mem::transmute::<
        &[u8; 39],
        &[libc::c_char; 39],
    >(b"<https://www.sourceware.org/bugzilla/>\0"))[0 as libc::c_int as usize]
        as libc::c_int != 0 && stream == stdout
    {
        fprintf(
            stdout,
            dcgettext(
                0 as *const libc::c_char,
                b"Report bugs to %s\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            b"<https://www.sourceware.org/bugzilla/>\0" as *const u8
                as *const libc::c_char,
        );
    }
    exit(if stream == stdout { 0 as libc::c_int } else { 1 as libc::c_int });
}
unsafe extern "C" fn request_dump_bynumber(
    mut dumpdata: *mut dump_data,
    mut section: libc::c_uint,
    mut type_0: dump_type,
) {
    if section >= (*dumpdata).num_dump_sects {
        let mut new_dump_sects: *mut dump_type = 0 as *mut dump_type;
        new_dump_sects = calloc(
            section.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
            ::core::mem::size_of::<dump_type>() as libc::c_ulong,
        ) as *mut dump_type;
        if new_dump_sects.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Out of memory allocating dump request table.\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            if !((*dumpdata).dump_sects).is_null() {
                memcpy(
                    new_dump_sects as *mut libc::c_void,
                    (*dumpdata).dump_sects as *const libc::c_void,
                    ((*dumpdata).num_dump_sects as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<dump_type>() as libc::c_ulong,
                        ),
                );
                free((*dumpdata).dump_sects as *mut libc::c_void);
            }
            (*dumpdata).dump_sects = new_dump_sects;
            (*dumpdata)
                .num_dump_sects = section.wrapping_add(1 as libc::c_int as libc::c_uint);
        }
    }
    if !((*dumpdata).dump_sects).is_null() {
        let ref mut fresh11 = *((*dumpdata).dump_sects).offset(section as isize);
        *fresh11 = (*fresh11 as libc::c_int | type_0 as libc::c_int) as dump_type;
    }
}
unsafe extern "C" fn request_dump_byname(
    mut section: *const libc::c_char,
    mut type_0: dump_type,
) {
    let mut new_request: *mut dump_list_entry = 0 as *mut dump_list_entry;
    new_request = malloc(::core::mem::size_of::<dump_list_entry>() as libc::c_ulong)
        as *mut dump_list_entry;
    if new_request.is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory allocating dump request table.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    (*new_request).name = strdup(section);
    if ((*new_request).name).is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory allocating dump request table.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    (*new_request).type_0 = type_0;
    (*new_request).next = dump_sects_byname;
    dump_sects_byname = new_request;
}
#[inline]
unsafe extern "C" fn request_dump(mut dumpdata: *mut dump_data, mut type_0: dump_type) {
    let mut section: libc::c_int = 0;
    let mut cp: *mut libc::c_char = 0 as *mut libc::c_char;
    do_dump = 1 as libc::c_int != 0;
    section = strtoul(optarg, &mut cp, 0 as libc::c_int) as libc::c_int;
    if *cp == 0 && section >= 0 as libc::c_int {
        request_dump_bynumber(dumpdata, section as libc::c_uint, type_0);
    } else {
        request_dump_byname(optarg, type_0);
    };
}
unsafe extern "C" fn parse_args(
    mut dumpdata: *mut dump_data,
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) {
    let mut c: libc::c_int = 0;
    if argc < 2 as libc::c_int {
        usage(stderr);
    }
    loop {
        c = getopt_long(
            argc,
            argv,
            b"ACDHILNPR:STVWacdeghi:lnp:rstuvw::x:z\0" as *const u8
                as *const libc::c_char,
            options.as_mut_ptr(),
            0 as *mut libc::c_int,
        );
        if !(c != -(1 as libc::c_int)) {
            break;
        }
        let mut current_block_92: u64;
        match c {
            72 => {
                usage(stdout);
                current_block_92 = 2705889988320590074;
            }
            97 => {
                do_syms = 1 as libc::c_int != 0;
                do_reloc = 1 as libc::c_int != 0;
                do_unwind = 1 as libc::c_int != 0;
                do_dynamic = 1 as libc::c_int != 0;
                do_header = 1 as libc::c_int != 0;
                do_sections = 1 as libc::c_int != 0;
                do_section_groups = 1 as libc::c_int != 0;
                do_segments = 1 as libc::c_int != 0;
                do_version = 1 as libc::c_int != 0;
                do_histogram = 1 as libc::c_int != 0;
                do_arch = 1 as libc::c_int != 0;
                do_notes = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            103 => {
                do_section_groups = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            116 | 78 => {
                do_sections = 1 as libc::c_int != 0;
                do_section_details = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            101 => {
                do_header = 1 as libc::c_int != 0;
                do_sections = 1 as libc::c_int != 0;
                do_segments = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            65 => {
                do_arch = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            68 => {
                do_using_dynamic = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            114 => {
                do_reloc = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            117 => {
                do_unwind = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            104 => {
                do_header = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            108 => {
                do_segments = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            115 => {
                do_syms = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            83 => {
                do_sections = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            100 => {
                do_dynamic = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            73 => {
                do_histogram = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            110 => {
                do_notes = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            99 => {
                do_archive_index = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            76 => {
                do_checks = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            80 => {
                process_links = 1 as libc::c_int != 0;
                do_follow_links = 1 as libc::c_int;
                current_block_92 = 2705889988320590074;
            }
            120 => {
                request_dump(
                    dumpdata,
                    ((1 as libc::c_int) << 0 as libc::c_int) as dump_type,
                );
                current_block_92 = 2705889988320590074;
            }
            112 => {
                request_dump(
                    dumpdata,
                    ((1 as libc::c_int) << 3 as libc::c_int) as dump_type,
                );
                current_block_92 = 2705889988320590074;
            }
            82 => {
                request_dump(
                    dumpdata,
                    ((1 as libc::c_int) << 4 as libc::c_int) as dump_type,
                );
                current_block_92 = 2705889988320590074;
            }
            122 => {
                decompress_dumps = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            119 => {
                do_dump = 1 as libc::c_int != 0;
                if optarg.is_null() {
                    do_debugging = 1 as libc::c_int != 0;
                    dwarf_select_sections_all();
                } else {
                    do_debugging = 0 as libc::c_int != 0;
                    dwarf_select_sections_by_letters(optarg);
                }
                current_block_92 = 2705889988320590074;
            }
            512 => {
                do_dump = 1 as libc::c_int != 0;
                if optarg.is_null() {
                    do_debugging = 1 as libc::c_int != 0;
                    dwarf_select_sections_all();
                } else {
                    do_debugging = 0 as libc::c_int != 0;
                    dwarf_select_sections_by_names(optarg);
                }
                current_block_92 = 2705889988320590074;
            }
            515 => {
                let mut cp: *mut libc::c_char = 0 as *mut libc::c_char;
                dwarf_cutoff_level = strtoul(optarg, &mut cp, 0 as libc::c_int)
                    as libc::c_int;
                current_block_92 = 2705889988320590074;
            }
            516 => {
                let mut cp_0: *mut libc::c_char = 0 as *mut libc::c_char;
                dwarf_start_die = strtoul(optarg, &mut cp_0, 0 as libc::c_int);
                current_block_92 = 2705889988320590074;
            }
            517 => {
                dwarf_check = 1 as libc::c_int;
                current_block_92 = 2705889988320590074;
            }
            518 => {
                do_ctf = 1 as libc::c_int != 0;
                request_dump(
                    dumpdata,
                    ((1 as libc::c_int) << 5 as libc::c_int) as dump_type,
                );
                current_block_92 = 2705889988320590074;
            }
            520 => {
                free(dump_ctf_symtab_name as *mut libc::c_void);
                dump_ctf_symtab_name = strdup(optarg);
                current_block_92 = 2705889988320590074;
            }
            521 => {
                free(dump_ctf_strtab_name as *mut libc::c_void);
                dump_ctf_strtab_name = strdup(optarg);
                current_block_92 = 2705889988320590074;
            }
            519 => {
                free(dump_ctf_parent_name as *mut libc::c_void);
                dump_ctf_parent_name = strdup(optarg);
                current_block_92 = 2705889988320590074;
            }
            513 => {
                do_dyn_syms = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            514 => {
                do_lto_syms = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            118 => {
                print_version(program_name);
                current_block_92 = 2705889988320590074;
            }
            86 => {
                do_version = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            87 => {
                do_wide = 1 as libc::c_int;
                current_block_92 = 2705889988320590074;
            }
            84 => {
                do_not_show_symbol_truncation = 1 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            67 => {
                do_demangle = 1 as libc::c_int != 0;
                if !optarg.is_null() {
                    let mut style: demangling_styles = unknown_demangling;
                    style = cplus_demangle_name_to_style(optarg);
                    if style as libc::c_int == unknown_demangling as libc::c_int {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"unknown demangling style `%s'\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            optarg,
                        );
                    }
                    cplus_demangle_set_style(style);
                }
                current_block_92 = 2705889988320590074;
            }
            525 => {
                do_demangle = 0 as libc::c_int != 0;
                current_block_92 = 2705889988320590074;
            }
            523 => {
                demangle_flags &= !((1 as libc::c_int) << 18 as libc::c_int);
                current_block_92 = 2705889988320590074;
            }
            524 => {
                demangle_flags |= (1 as libc::c_int) << 18 as libc::c_int;
                current_block_92 = 2705889988320590074;
            }
            0 | 522 => {
                current_block_92 = 2705889988320590074;
            }
            526 => {
                sym_base = 0 as libc::c_int;
                if !optarg.is_null() {
                    sym_base = strtoul(
                        optarg,
                        0 as *mut *mut libc::c_char,
                        0 as libc::c_int,
                    ) as libc::c_int;
                    match sym_base {
                        0 | 8 | 10 | 16 => {}
                        _ => {
                            sym_base = 0 as libc::c_int;
                        }
                    }
                }
                current_block_92 = 2705889988320590074;
            }
            63 => {
                current_block_92 = 1532940187123634610;
            }
            _ => {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Invalid option '-%c'\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    c,
                );
                current_block_92 = 1532940187123634610;
            }
        }
        match current_block_92 {
            1532940187123634610 => {
                usage(stderr);
            }
            _ => {}
        }
    }
    if !do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections && !do_segments
        && !do_header && !do_dump && !do_version && !do_histogram && !do_debugging
        && !do_arch && !do_notes && !do_section_groups && !do_archive_index
        && !do_dyn_syms && !do_lto_syms
    {
        if do_checks {
            check_all = 1 as libc::c_int != 0;
            do_sections = 1 as libc::c_int != 0;
            do_unwind = do_sections;
            do_reloc = do_unwind;
            do_syms = do_reloc;
            do_dynamic = do_syms;
            do_version = 1 as libc::c_int != 0;
            do_dump = do_version;
            do_header = do_dump;
            do_segments = do_header;
            do_notes = 1 as libc::c_int != 0;
            do_arch = do_notes;
            do_debugging = do_arch;
            do_histogram = do_debugging;
            do_dyn_syms = 1 as libc::c_int != 0;
            do_archive_index = do_dyn_syms;
            do_section_groups = do_archive_index;
            do_lto_syms = 1 as libc::c_int != 0;
        } else {
            usage(stderr);
        }
    }
}
unsafe extern "C" fn get_elf_class(mut elf_class: libc::c_uint) -> *const libc::c_char {
    static mut buff: [libc::c_char; 32] = [0; 32];
    match elf_class {
        0 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"none\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        1 => return b"ELF32\0" as *const u8 as *const libc::c_char,
        2 => return b"ELF64\0" as *const u8 as *const libc::c_char,
        _ => {
            snprintf(
                buff.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                elf_class,
            );
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn get_data_encoding(
    mut encoding: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 32] = [0; 32];
    match encoding {
        0 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"none\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        1 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"2's complement, little endian\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        2 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"2's complement, big endian\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        _ => {
            snprintf(
                buff.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                encoding,
            );
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn process_file_header(mut filedata: *mut Filedata) -> bool {
    let mut header: *mut Elf_Internal_Ehdr = &mut (*filedata).file_header;
    if (*header).e_ident[0 as libc::c_int as usize] as libc::c_int != 0x7f as libc::c_int
        || (*header).e_ident[1 as libc::c_int as usize] as libc::c_int != 'E' as i32
        || (*header).e_ident[2 as libc::c_int as usize] as libc::c_int != 'L' as i32
        || (*header).e_ident[3 as libc::c_int as usize] as libc::c_int != 'F' as i32
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Not an ELF file - it has the wrong magic bytes at the start\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    if !(*filedata).is_separate {
        init_dwarf_regnames_by_elf_machine_code((*header).e_machine as libc::c_uint);
    }
    if do_header {
        let mut i: libc::c_uint = 0;
        if (*filedata).is_separate {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"ELF Header in linked file '%s':\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*filedata).file_name,
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"ELF Header:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Magic:   \0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        i = 0 as libc::c_int as libc::c_uint;
        while i < 16 as libc::c_int as libc::c_uint {
            printf(
                b"%2.2x \0" as *const u8 as *const libc::c_char,
                (*header).e_ident[i as usize] as libc::c_int,
            );
            i = i.wrapping_add(1);
            i;
        }
        printf(b"\n\0" as *const u8 as *const libc::c_char);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Class:                             %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            get_elf_class((*header).e_ident[4 as libc::c_int as usize] as libc::c_uint),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Data:                              %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            get_data_encoding(
                (*header).e_ident[5 as libc::c_int as usize] as libc::c_uint,
            ),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Version:                           %d%s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_ident[6 as libc::c_int as usize] as libc::c_int,
            if (*header).e_ident[6 as libc::c_int as usize] as libc::c_int
                == 1 as libc::c_int
            {
                dcgettext(
                    0 as *const libc::c_char,
                    b" (current)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ) as *const libc::c_char
            } else if (*header).e_ident[6 as libc::c_int as usize] as libc::c_int
                != 0 as libc::c_int
            {
                dcgettext(
                    0 as *const libc::c_char,
                    b" <unknown>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ) as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  OS/ABI:                            %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            get_osabi_name(
                filedata,
                (*header).e_ident[7 as libc::c_int as usize] as libc::c_uint,
            ),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  ABI Version:                       %d\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_ident[8 as libc::c_int as usize] as libc::c_int,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Type:                              %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            get_file_type(filedata),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Machine:                           %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            get_machine_name((*header).e_machine as libc::c_uint),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Version:                           0x%lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_version,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Entry point address:               \0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        print_vma((*header).e_entry, PREFIX_HEX);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\n  Start of program headers:          \0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        print_vma((*header).e_phoff, DEC);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b" (bytes into file)\n  Start of section headers:          \0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        print_vma((*header).e_shoff, DEC);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b" (bytes into file)\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Flags:                             0x%lx%s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_flags,
            get_machine_flags(
                filedata,
                (*header).e_flags as libc::c_uint,
                (*header).e_machine as libc::c_uint,
            ),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Size of this header:               %u (bytes)\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_ehsize,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Size of program headers:           %u (bytes)\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_phentsize,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Number of program headers:         %u\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_phnum,
        );
        if !((*filedata).section_headers).is_null()
            && (*header).e_phnum == 0xffff as libc::c_int as libc::c_uint
            && (*((*filedata).section_headers).offset(0 as libc::c_int as isize)).sh_info
                != 0 as libc::c_int as libc::c_uint
        {
            (*header)
                .e_phnum = (*((*filedata).section_headers)
                .offset(0 as libc::c_int as isize))
                .sh_info;
            printf(b" (%u)\0" as *const u8 as *const libc::c_char, (*header).e_phnum);
        }
        putc('\n' as i32, stdout);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Size of section headers:           %u (bytes)\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_shentsize,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Number of section headers:         %u\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_shnum,
        );
        if !((*filedata).section_headers).is_null()
            && (*header).e_shnum == 0 as libc::c_int as libc::c_uint
        {
            (*header)
                .e_shnum = (*((*filedata).section_headers)
                .offset(0 as libc::c_int as isize))
                .sh_size as libc::c_uint;
            printf(b" (%u)\0" as *const u8 as *const libc::c_char, (*header).e_shnum);
        }
        putc('\n' as i32, stdout);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Section header string table index: %u\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*header).e_shstrndx,
        );
        if !((*filedata).section_headers).is_null()
            && (*header).e_shstrndx
                == (0x1 as libc::c_uint).wrapping_neg()
                    & 0xffff as libc::c_int as libc::c_uint
        {
            (*header)
                .e_shstrndx = (*((*filedata).section_headers)
                .offset(0 as libc::c_int as isize))
                .sh_link;
            printf(b" (%u)\0" as *const u8 as *const libc::c_char, (*header).e_shstrndx);
        }
        if (*header).e_shstrndx != 0 as libc::c_int as libc::c_uint
            && (*header).e_shstrndx >= (*header).e_shnum
        {
            (*header).e_shstrndx = 0 as libc::c_int as libc::c_uint;
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" <corrupt: out of range>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        putc('\n' as i32, stdout);
    }
    if !((*filedata).section_headers).is_null() {
        if (*header).e_phnum == 0xffff as libc::c_int as libc::c_uint
            && (*((*filedata).section_headers).offset(0 as libc::c_int as isize)).sh_info
                != 0 as libc::c_int as libc::c_uint
        {
            (*header)
                .e_phnum = (*((*filedata).section_headers)
                .offset(0 as libc::c_int as isize))
                .sh_info;
        }
        if (*header).e_shnum == 0 as libc::c_int as libc::c_uint {
            (*header)
                .e_shnum = (*((*filedata).section_headers)
                .offset(0 as libc::c_int as isize))
                .sh_size as libc::c_uint;
        }
        if (*header).e_shstrndx
            == (0x1 as libc::c_uint).wrapping_neg()
                & 0xffff as libc::c_int as libc::c_uint
        {
            (*header)
                .e_shstrndx = (*((*filedata).section_headers)
                .offset(0 as libc::c_int as isize))
                .sh_link;
        }
        if (*header).e_shstrndx >= (*header).e_shnum {
            (*header).e_shstrndx = 0 as libc::c_int as libc::c_uint;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_32bit_program_headers(
    mut filedata: *mut Filedata,
    mut pheaders: *mut Elf_Internal_Phdr,
) -> bool {
    let mut phdrs: *mut Elf32_External_Phdr = 0 as *mut Elf32_External_Phdr;
    let mut external: *mut Elf32_External_Phdr = 0 as *mut Elf32_External_Phdr;
    let mut internal: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut i: libc::c_uint = 0;
    let mut size: libc::c_uint = (*filedata).file_header.e_phentsize;
    let mut num: libc::c_uint = (*filedata).file_header.e_phnum;
    if size == 0 as libc::c_int as libc::c_uint
        || num == 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    if (size as libc::c_ulong)
        < ::core::mem::size_of::<Elf32_External_Phdr>() as libc::c_ulong
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"The e_phentsize field in the ELF header is less than the size of an ELF program header\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    if size as libc::c_ulong
        > ::core::mem::size_of::<Elf32_External_Phdr>() as libc::c_ulong
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"The e_phentsize field in the ELF header is larger than the size of an ELF program header\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    phdrs = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*filedata).file_header.e_phoff,
        size as bfd_size_type,
        num as bfd_size_type,
        dcgettext(
            0 as *const libc::c_char,
            b"program headers\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut Elf32_External_Phdr;
    if phdrs.is_null() {
        return 0 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as libc::c_uint;
    internal = pheaders;
    external = phdrs;
    while i < (*filedata).file_header.e_phnum {
        (*internal)
            .p_type = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_type).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_offset = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_offset).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_vaddr = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_vaddr).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_paddr = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_paddr).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_filesz = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_filesz).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_memsz = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_memsz).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_flags = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_flags).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_align = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_align).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        i = i.wrapping_add(1);
        i;
        internal = internal.offset(1);
        internal;
        external = external.offset(1);
        external;
    }
    free(phdrs as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_64bit_program_headers(
    mut filedata: *mut Filedata,
    mut pheaders: *mut Elf_Internal_Phdr,
) -> bool {
    let mut phdrs: *mut Elf64_External_Phdr = 0 as *mut Elf64_External_Phdr;
    let mut external: *mut Elf64_External_Phdr = 0 as *mut Elf64_External_Phdr;
    let mut internal: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut i: libc::c_uint = 0;
    let mut size: libc::c_uint = (*filedata).file_header.e_phentsize;
    let mut num: libc::c_uint = (*filedata).file_header.e_phnum;
    if size == 0 as libc::c_int as libc::c_uint
        || num == 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    if (size as libc::c_ulong)
        < ::core::mem::size_of::<Elf64_External_Phdr>() as libc::c_ulong
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"The e_phentsize field in the ELF header is less than the size of an ELF program header\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    if size as libc::c_ulong
        > ::core::mem::size_of::<Elf64_External_Phdr>() as libc::c_ulong
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"The e_phentsize field in the ELF header is larger than the size of an ELF program header\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    phdrs = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*filedata).file_header.e_phoff,
        size as bfd_size_type,
        num as bfd_size_type,
        dcgettext(
            0 as *const libc::c_char,
            b"program headers\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut Elf64_External_Phdr;
    if phdrs.is_null() {
        return 0 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as libc::c_uint;
    internal = pheaders;
    external = phdrs;
    while i < (*filedata).file_header.e_phnum {
        (*internal)
            .p_type = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_type).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_flags = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_flags).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_offset = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_offset).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_vaddr = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_vaddr).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_paddr = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_paddr).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_filesz = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_filesz).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_memsz = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_memsz).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .p_align = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).p_align).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        i = i.wrapping_add(1);
        i;
        internal = internal.offset(1);
        internal;
        external = external.offset(1);
        external;
    }
    free(phdrs as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn process_program_headers(mut filedata: *mut Filedata) {
    let mut dynamic_addr: libc::c_ulong = 0;
    let mut dynamic_size: bfd_size_type = 0;
    let mut segment: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut i: libc::c_uint = 0;
    let mut previous_load: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    if (*filedata).file_header.e_phnum == 0 as libc::c_int as libc::c_uint {
        if (*filedata).file_header.e_phoff != 0 as libc::c_int as libc::c_ulong {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"possibly corrupt ELF header - it has a non-zero program header offset, but no program headers\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else if do_segments {
            if (*filedata).is_separate {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere are no program headers in linked file '%s'.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_name,
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere are no program headers in this file.\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
        }
    } else {
        if do_segments as libc::c_int != 0 && !do_header {
            if (*filedata).is_separate {
                printf(
                    b"\nIn linked file '%s' the ELF file type is %s\n\0" as *const u8
                        as *const libc::c_char,
                    (*filedata).file_name,
                    get_file_type(filedata),
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nElf file type is %s\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    get_file_type(filedata),
                );
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Entry point 0x%s\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                bfd_vmatoa(
                    b"x\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*filedata).file_header.e_entry,
                ),
            );
            printf(
                dcngettext(
                    0 as *const libc::c_char,
                    b"There is %d program header, starting at offset %s\n\0" as *const u8
                        as *const libc::c_char,
                    b"There are %d program headers, starting at offset %s\n\0"
                        as *const u8 as *const libc::c_char,
                    (*filedata).file_header.e_phnum as libc::c_ulong,
                    5 as libc::c_int,
                ),
                (*filedata).file_header.e_phnum,
                bfd_vmatoa(
                    b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    (*filedata).file_header.e_phoff,
                ),
            );
        }
        if get_program_headers(filedata) {
            if do_segments {
                if (*filedata).file_header.e_phnum > 1 as libc::c_int as libc::c_uint {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\nProgram Headers:\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\nProgram Headers:\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                if is_32bit_elf {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                } else if do_wide != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  Type           Offset             VirtAddr           PhysAddr\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"                 FileSiz            MemSiz              Flags  Align\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            dynamic_addr = 0 as libc::c_int as libc::c_ulong;
            dynamic_size = 0 as libc::c_int as bfd_size_type;
            i = 0 as libc::c_int as libc::c_uint;
            segment = (*filedata).program_headers;
            while i < (*filedata).file_header.e_phnum {
                if do_segments {
                    printf(
                        b"  %-14.14s \0" as *const u8 as *const libc::c_char,
                        get_segment_type(filedata, (*segment).p_type),
                    );
                    if is_32bit_elf {
                        printf(
                            b"0x%6.6lx \0" as *const u8 as *const libc::c_char,
                            (*segment).p_offset,
                        );
                        printf(
                            b"0x%8.8lx \0" as *const u8 as *const libc::c_char,
                            (*segment).p_vaddr,
                        );
                        printf(
                            b"0x%8.8lx \0" as *const u8 as *const libc::c_char,
                            (*segment).p_paddr,
                        );
                        printf(
                            b"0x%5.5lx \0" as *const u8 as *const libc::c_char,
                            (*segment).p_filesz,
                        );
                        printf(
                            b"0x%5.5lx \0" as *const u8 as *const libc::c_char,
                            (*segment).p_memsz,
                        );
                        printf(
                            b"%c%c%c \0" as *const u8 as *const libc::c_char,
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'R' as i32
                            } else {
                                ' ' as i32
                            },
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'W' as i32
                            } else {
                                ' ' as i32
                            },
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'E' as i32
                            } else {
                                ' ' as i32
                            },
                        );
                        printf(
                            b"%#lx\0" as *const u8 as *const libc::c_char,
                            (*segment).p_align,
                        );
                    } else if do_wide != 0 {
                        if (*segment).p_offset == (*segment).p_offset {
                            printf(
                                b"0x%6.6lx \0" as *const u8 as *const libc::c_char,
                                (*segment).p_offset,
                            );
                        } else {
                            print_vma((*segment).p_offset, FULL_HEX);
                            putchar(' ' as i32);
                        }
                        print_vma((*segment).p_vaddr, FULL_HEX);
                        putchar(' ' as i32);
                        print_vma((*segment).p_paddr, FULL_HEX);
                        putchar(' ' as i32);
                        if (*segment).p_filesz == (*segment).p_filesz {
                            printf(
                                b"0x%6.6lx \0" as *const u8 as *const libc::c_char,
                                (*segment).p_filesz,
                            );
                        } else {
                            print_vma((*segment).p_filesz, FULL_HEX);
                            putchar(' ' as i32);
                        }
                        if (*segment).p_memsz == (*segment).p_memsz {
                            printf(
                                b"0x%6.6lx\0" as *const u8 as *const libc::c_char,
                                (*segment).p_memsz,
                            );
                        } else {
                            print_vma((*segment).p_memsz, FULL_HEX);
                        }
                        printf(
                            b" %c%c%c \0" as *const u8 as *const libc::c_char,
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'R' as i32
                            } else {
                                ' ' as i32
                            },
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'W' as i32
                            } else {
                                ' ' as i32
                            },
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'E' as i32
                            } else {
                                ' ' as i32
                            },
                        );
                        if (*segment).p_align == (*segment).p_align {
                            printf(
                                b"%#lx\0" as *const u8 as *const libc::c_char,
                                (*segment).p_align,
                            );
                        } else {
                            print_vma((*segment).p_align, PREFIX_HEX);
                        }
                    } else {
                        print_vma((*segment).p_offset, FULL_HEX);
                        putchar(' ' as i32);
                        print_vma((*segment).p_vaddr, FULL_HEX);
                        putchar(' ' as i32);
                        print_vma((*segment).p_paddr, FULL_HEX);
                        printf(
                            b"\n                 \0" as *const u8 as *const libc::c_char,
                        );
                        print_vma((*segment).p_filesz, FULL_HEX);
                        putchar(' ' as i32);
                        print_vma((*segment).p_memsz, FULL_HEX);
                        printf(
                            b"  %c%c%c    \0" as *const u8 as *const libc::c_char,
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'R' as i32
                            } else {
                                ' ' as i32
                            },
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'W' as i32
                            } else {
                                ' ' as i32
                            },
                            if (*segment).p_flags
                                & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong
                                != 0
                            {
                                'E' as i32
                            } else {
                                ' ' as i32
                            },
                        );
                        print_vma((*segment).p_align, PREFIX_HEX);
                    }
                    putc('\n' as i32, stdout);
                }
                let mut current_block_114: u64;
                match (*segment).p_type {
                    1 => {
                        if (*segment).p_memsz < (*segment).p_filesz {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"the segment's file size is larger than its memory size\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        previous_load = segment;
                    }
                    6 => {
                        if i > 0 as libc::c_int as libc::c_uint
                            && !previous_load.is_null()
                        {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"the PHDR segment must occur before any LOAD segment\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        if (*filedata).file_header.e_machine as libc::c_int
                            != 15 as libc::c_int
                        {
                            let mut j: libc::c_uint = 0;
                            j = 1 as libc::c_int as libc::c_uint;
                            while j < (*filedata).file_header.e_phnum {
                                let mut load: *mut Elf_Internal_Phdr = ((*filedata)
                                    .program_headers)
                                    .offset(j as isize);
                                if (*load).p_type == 1 as libc::c_int as libc::c_ulong
                                    && (*load).p_offset <= (*segment).p_offset
                                    && ((*load).p_offset).wrapping_add((*load).p_filesz)
                                        >= ((*segment).p_offset).wrapping_add((*segment).p_filesz)
                                    && (*load).p_vaddr <= (*segment).p_vaddr
                                    && ((*load).p_vaddr).wrapping_add((*load).p_filesz)
                                        >= ((*segment).p_vaddr).wrapping_add((*segment).p_filesz)
                                {
                                    break;
                                }
                                j = j.wrapping_add(1);
                                j;
                            }
                            if j == (*filedata).file_header.e_phnum {
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"the PHDR segment is not covered by a LOAD segment\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                        }
                    }
                    2 => {
                        if dynamic_addr != 0 {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"more than one dynamic segment\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        dynamic_addr = (*segment).p_offset;
                        dynamic_size = (*segment).p_filesz;
                        if !((*filedata).section_headers).is_null() {
                            let mut sec: *mut Elf_Internal_Shdr = 0
                                as *mut Elf_Internal_Shdr;
                            sec = find_section(
                                filedata,
                                b".dynamic\0" as *const u8 as *const libc::c_char,
                            );
                            if sec.is_null()
                                || (*sec).sh_size == 0 as libc::c_int as libc::c_ulong
                            {
                                if !is_ia64_vms(filedata) {
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"no .dynamic section in the dynamic segment\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                }
                                current_block_114 = 3217137713928741134;
                            } else if (*sec).sh_type == 8 as libc::c_int as libc::c_uint
                            {
                                dynamic_addr = 0 as libc::c_int as libc::c_ulong;
                                dynamic_size = 0 as libc::c_int as bfd_size_type;
                                current_block_114 = 3217137713928741134;
                            } else {
                                dynamic_addr = (*sec).sh_offset as libc::c_ulong;
                                dynamic_size = (*sec).sh_size;
                                if do_checks as libc::c_int != 0
                                    && (dynamic_addr != (*segment).p_offset
                                        || dynamic_size != (*segment).p_filesz)
                                {
                                    warn(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"the .dynamic section is not the same as the dynamic segment\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                }
                                current_block_114 = 496303045384785551;
                            }
                        } else {
                            current_block_114 = 496303045384785551;
                        }
                        match current_block_114 {
                            3217137713928741134 => {}
                            _ => {
                                if dynamic_addr > (*filedata).file_size
                                    || dynamic_size
                                        > ((*filedata).file_size).wrapping_sub(dynamic_addr)
                                {
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"the dynamic segment offset + size exceeds the size of the file\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    dynamic_addr = 0 as libc::c_int as libc::c_ulong;
                                    dynamic_size = 0 as libc::c_int as bfd_size_type;
                                }
                            }
                        }
                    }
                    3 => {
                        if (*segment).p_offset >= (*filedata).file_size
                            || (*segment).p_filesz
                                > ((*filedata).file_size).wrapping_sub((*segment).p_offset)
                            || ((*segment).p_filesz)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                >= -(2 as libc::c_int) as size_t
                            || fseek(
                                (*filedata).handle,
                                ((*filedata).archive_file_offset)
                                    .wrapping_add(
                                        (*segment).p_offset as libc::c_long as libc::c_ulong,
                                    ) as libc::c_long,
                                0 as libc::c_int,
                            ) != 0
                        {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Unable to find program interpreter name\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        } else {
                            let mut len: size_t = (*segment).p_filesz;
                            free((*filedata).program_interpreter as *mut libc::c_void);
                            (*filedata)
                                .program_interpreter = xmalloc(
                                len.wrapping_add(1 as libc::c_int as libc::c_ulong),
                            ) as *mut libc::c_char;
                            len = fread(
                                (*filedata).program_interpreter as *mut libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                len,
                                (*filedata).handle,
                            );
                            *((*filedata).program_interpreter)
                                .offset(len as isize) = 0 as libc::c_int as libc::c_char;
                            if do_segments {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"      [Requesting program interpreter: %s]\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    (*filedata).program_interpreter,
                                );
                            }
                        }
                    }
                    _ => {}
                }
                i = i.wrapping_add(1);
                i;
                segment = segment.offset(1);
                segment;
            }
            if do_segments as libc::c_int != 0
                && !((*filedata).section_headers).is_null()
                && !((*filedata).string_table).is_null()
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\n Section to Segment mapping:\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Segment Sections...\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                i = 0 as libc::c_int as libc::c_uint;
                while i < (*filedata).file_header.e_phnum {
                    let mut j_0: libc::c_uint = 0;
                    let mut section: *mut Elf_Internal_Shdr = 0
                        as *mut Elf_Internal_Shdr;
                    segment = ((*filedata).program_headers).offset(i as isize);
                    section = ((*filedata).section_headers)
                        .offset(1 as libc::c_int as isize);
                    printf(b"   %2.2d     \0" as *const u8 as *const libc::c_char, i);
                    j_0 = 1 as libc::c_int as libc::c_uint;
                    while j_0 < (*filedata).file_header.e_shnum {
                        if !((*section).sh_flags
                            & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                            != 0 as libc::c_int as libc::c_ulong
                            && (*section).sh_type == 8 as libc::c_int as libc::c_uint
                            && (*segment).p_type != 7 as libc::c_int as libc::c_ulong)
                            && (((*section).sh_flags
                                & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && ((*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                    || (*segment).p_type
                                        == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                            as libc::c_ulong
                                    || (*segment).p_type == 1 as libc::c_int as libc::c_ulong)
                                || (*section).sh_flags
                                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                    == 0 as libc::c_int as libc::c_ulong
                                    && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                    && (*segment).p_type != 6 as libc::c_int as libc::c_ulong)
                                && !((*section).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    == 0 as libc::c_int as libc::c_ulong
                                    && ((*segment).p_type == 1 as libc::c_int as libc::c_ulong
                                        || (*segment).p_type == 2 as libc::c_int as libc::c_ulong
                                        || (*segment).p_type
                                            == (0x60000000 as libc::c_int + 0x474e550 as libc::c_int)
                                                as libc::c_ulong
                                        || (*segment).p_type
                                            == (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                                                as libc::c_ulong
                                        || (*segment).p_type
                                            == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                                as libc::c_ulong
                                        || (*segment).p_type
                                            >= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int)
                                                as libc::c_ulong
                                            && (*segment).p_type
                                                <= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int
                                                    + 4096 as libc::c_int - 1 as libc::c_int) as libc::c_ulong))
                                && ((*section).sh_type == 8 as libc::c_int as libc::c_uint
                                    || (*section).sh_offset as bfd_vma >= (*segment).p_offset
                                        && (1 as libc::c_int == 0
                                            || ((*section).sh_offset as libc::c_ulong)
                                                .wrapping_sub((*segment).p_offset)
                                                <= ((*segment).p_filesz)
                                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                                        && ((*section).sh_offset as libc::c_ulong)
                                            .wrapping_sub((*segment).p_offset)
                                            .wrapping_add(
                                                if (*section).sh_flags
                                                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                                    != 0 as libc::c_int as libc::c_ulong
                                                    && (*section).sh_type == 8 as libc::c_int as libc::c_uint
                                                    && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                                {
                                                    0 as libc::c_int as libc::c_ulong
                                                } else {
                                                    (*section).sh_size
                                                },
                                            ) <= (*segment).p_filesz)
                                && (1 as libc::c_int == 0
                                    || (*section).sh_flags
                                        & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                        == 0 as libc::c_int as libc::c_ulong
                                    || (*section).sh_addr >= (*segment).p_vaddr
                                        && (1 as libc::c_int == 0
                                            || ((*section).sh_addr).wrapping_sub((*segment).p_vaddr)
                                                <= ((*segment).p_memsz)
                                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                                        && ((*section).sh_addr)
                                            .wrapping_sub((*segment).p_vaddr)
                                            .wrapping_add(
                                                if (*section).sh_flags
                                                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                                    != 0 as libc::c_int as libc::c_ulong
                                                    && (*section).sh_type == 8 as libc::c_int as libc::c_uint
                                                    && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                                {
                                                    0 as libc::c_int as libc::c_ulong
                                                } else {
                                                    (*section).sh_size
                                                },
                                            ) <= (*segment).p_memsz)
                                && ((*segment).p_type != 2 as libc::c_int as libc::c_ulong
                                    && (*segment).p_type != 4 as libc::c_int as libc::c_ulong
                                    || (*section).sh_size != 0 as libc::c_int as libc::c_ulong
                                    || (*segment).p_memsz == 0 as libc::c_int as libc::c_ulong
                                    || ((*section).sh_type == 8 as libc::c_int as libc::c_uint
                                        || (*section).sh_offset as bfd_vma > (*segment).p_offset
                                            && ((*section).sh_offset as libc::c_ulong)
                                                .wrapping_sub((*segment).p_offset) < (*segment).p_filesz)
                                        && ((*section).sh_flags
                                            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                            == 0 as libc::c_int as libc::c_ulong
                                            || (*section).sh_addr > (*segment).p_vaddr
                                                && ((*section).sh_addr).wrapping_sub((*segment).p_vaddr)
                                                    < (*segment).p_memsz)))
                        {
                            printf(
                                b"%s \0" as *const u8 as *const libc::c_char,
                                printable_section_name(filedata, section),
                            );
                        }
                        j_0 = j_0.wrapping_add(1);
                        j_0;
                        section = section.offset(1);
                        section;
                    }
                    putc('\n' as i32, stdout);
                    i = i.wrapping_add(1);
                    i;
                }
            }
            (*filedata).dynamic_addr = dynamic_addr;
            (*filedata)
                .dynamic_size = if dynamic_size != 0 {
                dynamic_size
            } else {
                1 as libc::c_int as libc::c_ulong
            };
            return;
        }
    }
    (*filedata).dynamic_addr = 0 as libc::c_int as libc::c_ulong;
    (*filedata).dynamic_size = 1 as libc::c_int as bfd_size_type;
}
unsafe extern "C" fn offset_from_vma(
    mut filedata: *mut Filedata,
    mut vma: bfd_vma,
    mut size: bfd_size_type,
) -> libc::c_long {
    let mut seg: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    if !get_program_headers(filedata) {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Cannot interpret virtual addresses without program headers.\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return vma as libc::c_long;
    }
    seg = (*filedata).program_headers;
    while seg
        < ((*filedata).program_headers).offset((*filedata).file_header.e_phnum as isize)
    {
        if !((*seg).p_type != 1 as libc::c_int as libc::c_ulong) {
            if vma >= (*seg).p_vaddr & ((*seg).p_align).wrapping_neg()
                && vma.wrapping_add(size)
                    <= ((*seg).p_vaddr).wrapping_add((*seg).p_filesz)
            {
                return vma.wrapping_sub((*seg).p_vaddr).wrapping_add((*seg).p_offset)
                    as libc::c_long;
            }
        }
        seg = seg.offset(1);
        seg;
    }
    warn(
        dcgettext(
            0 as *const libc::c_char,
            b"Virtual address 0x%lx not located in any PT_LOAD segment.\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        vma,
    );
    return vma as libc::c_long;
}
unsafe extern "C" fn get_32bit_section_headers(
    mut filedata: *mut Filedata,
    mut probe: bool,
) -> bool {
    let mut shdrs: *mut Elf32_External_Shdr = 0 as *mut Elf32_External_Shdr;
    let mut internal: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_uint = 0;
    let mut size: libc::c_uint = (*filedata).file_header.e_shentsize;
    let mut num: libc::c_uint = if probe as libc::c_int != 0 {
        1 as libc::c_int as libc::c_uint
    } else {
        (*filedata).file_header.e_shnum
    };
    if size == 0 as libc::c_int as libc::c_uint
        || num == 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    if (size as libc::c_ulong)
        < ::core::mem::size_of::<Elf32_External_Shdr>() as libc::c_ulong
    {
        if !probe {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The e_shentsize field in the ELF header is less than the size of an ELF section header\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        return 0 as libc::c_int != 0;
    }
    if !probe
        && size as libc::c_ulong
            > ::core::mem::size_of::<Elf32_External_Shdr>() as libc::c_ulong
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"The e_shentsize field in the ELF header is larger than the size of an ELF section header\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    shdrs = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*filedata).file_header.e_shoff,
        size as bfd_size_type,
        num as bfd_size_type,
        if probe as libc::c_int != 0 {
            0 as *mut libc::c_char
        } else {
            dcgettext(
                0 as *const libc::c_char,
                b"section headers\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        },
    ) as *mut Elf32_External_Shdr;
    if shdrs.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*filedata)
        .section_headers = cmalloc(
        num as size_t,
        ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
    ) as *mut Elf_Internal_Shdr;
    if ((*filedata).section_headers).is_null() {
        if !probe {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Out of memory reading %u section headers\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                num,
            );
        }
        free(shdrs as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as libc::c_uint;
    internal = (*filedata).section_headers;
    while i < num {
        (*internal)
            .sh_name = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_name).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*internal)
            .sh_type = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_type).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*internal)
            .sh_flags = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_flags).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .sh_addr = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_addr).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .sh_offset = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_offset).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as file_ptr;
        (*internal)
            .sh_size = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_size).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .sh_link = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_link).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*internal)
            .sh_info = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_info).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*internal)
            .sh_addralign = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_addralign).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .sh_entsize = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_entsize).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        if !probe && (*internal).sh_link > num {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Section %u has an out of range sh_link value of %u\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                i,
                (*internal).sh_link,
            );
        }
        if !probe
            && (*internal).sh_flags
                & ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong != 0
            && (*internal).sh_info > num
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Section %u has an out of range sh_info value of %u\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                i,
                (*internal).sh_info,
            );
        }
        i = i.wrapping_add(1);
        i;
        internal = internal.offset(1);
        internal;
    }
    free(shdrs as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_64bit_section_headers(
    mut filedata: *mut Filedata,
    mut probe: bool,
) -> bool {
    let mut shdrs: *mut Elf64_External_Shdr = 0 as *mut Elf64_External_Shdr;
    let mut internal: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_uint = 0;
    let mut size: libc::c_uint = (*filedata).file_header.e_shentsize;
    let mut num: libc::c_uint = if probe as libc::c_int != 0 {
        1 as libc::c_int as libc::c_uint
    } else {
        (*filedata).file_header.e_shnum
    };
    if size == 0 as libc::c_int as libc::c_uint
        || num == 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    if (size as libc::c_ulong)
        < ::core::mem::size_of::<Elf64_External_Shdr>() as libc::c_ulong
    {
        if !probe {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The e_shentsize field in the ELF header is less than the size of an ELF section header\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        return 0 as libc::c_int != 0;
    }
    if !probe
        && size as libc::c_ulong
            > ::core::mem::size_of::<Elf64_External_Shdr>() as libc::c_ulong
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"The e_shentsize field in the ELF header is larger than the size of an ELF section header\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    shdrs = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*filedata).file_header.e_shoff,
        size as bfd_size_type,
        num as bfd_size_type,
        if probe as libc::c_int != 0 {
            0 as *mut libc::c_char
        } else {
            dcgettext(
                0 as *const libc::c_char,
                b"section headers\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        },
    ) as *mut Elf64_External_Shdr;
    if shdrs.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*filedata)
        .section_headers = cmalloc(
        num as size_t,
        ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
    ) as *mut Elf_Internal_Shdr;
    if ((*filedata).section_headers).is_null() {
        if !probe {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Out of memory reading %u section headers\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                num,
            );
        }
        free(shdrs as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as libc::c_uint;
    internal = (*filedata).section_headers;
    while i < num {
        (*internal)
            .sh_name = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_name).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*internal)
            .sh_type = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_type).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*internal)
            .sh_flags = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_flags).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .sh_addr = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_addr).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .sh_size = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_size).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .sh_entsize = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_entsize).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*internal)
            .sh_link = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_link).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*internal)
            .sh_info = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_info).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*internal)
            .sh_offset = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_offset).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        ) as file_ptr;
        (*internal)
            .sh_addralign = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*shdrs.offset(i as isize)).sh_addralign).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        if !probe && (*internal).sh_link > num {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Section %u has an out of range sh_link value of %u\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                i,
                (*internal).sh_link,
            );
        }
        if !probe
            && (*internal).sh_flags
                & ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong != 0
            && (*internal).sh_info > num
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Section %u has an out of range sh_info value of %u\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                i,
                (*internal).sh_info,
            );
        }
        i = i.wrapping_add(1);
        i;
        internal = internal.offset(1);
        internal;
    }
    free(shdrs as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_section_headers(
    mut filedata: *mut Filedata,
    mut probe: bool,
) -> bool {
    if !((*filedata).section_headers).is_null() {
        return 1 as libc::c_int != 0;
    }
    if is_32bit_elf {
        return get_32bit_section_headers(filedata, probe)
    } else {
        return get_64bit_section_headers(filedata, probe)
    };
}
unsafe extern "C" fn get_32bit_elf_symbols(
    mut filedata: *mut Filedata,
    mut section: *mut Elf_Internal_Shdr,
    mut num_syms_return: *mut libc::c_ulong,
) -> *mut Elf_Internal_Sym {
    let mut current_block: u64;
    let mut number: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut esyms: *mut Elf32_External_Sym = 0 as *mut Elf32_External_Sym;
    let mut shndx: *mut Elf_External_Sym_Shndx = 0 as *mut Elf_External_Sym_Shndx;
    let mut isyms: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut psym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut j: libc::c_uint = 0;
    let mut entry: *mut elf_section_list = 0 as *mut elf_section_list;
    if (*section).sh_size == 0 as libc::c_int as libc::c_ulong {
        if !num_syms_return.is_null() {
            *num_syms_return = 0 as libc::c_int as libc::c_ulong;
        }
        return 0 as *mut Elf_Internal_Sym;
    }
    if (*section).sh_entsize == 0 as libc::c_int as libc::c_ulong
        || (*section).sh_entsize > (*section).sh_size
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Section %s has an invalid sh_entsize of 0x%lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
            (*section).sh_entsize,
        );
    } else if (*section).sh_size > (*filedata).file_size {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Section %s has an invalid sh_size of 0x%lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
            (*section).sh_size,
        );
    } else {
        number = ((*section).sh_size).wrapping_div((*section).sh_entsize);
        if number
            .wrapping_mul(::core::mem::size_of::<Elf32_External_Sym>() as libc::c_ulong)
            > ((*section).sh_size).wrapping_add(1 as libc::c_int as libc::c_ulong)
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).sh_size,
                printable_section_name(filedata, section),
                (*section).sh_entsize,
            );
        } else {
            esyms = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*section).sh_offset as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                (*section).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"symbols\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut Elf32_External_Sym;
            if !esyms.is_null() {
                shndx = 0 as *mut Elf_External_Sym_Shndx;
                entry = (*filedata).symtab_shndx_list;
                loop {
                    if entry.is_null() {
                        current_block = 9828876828309294594;
                        break;
                    }
                    if !((*(*entry).hdr).sh_link as libc::c_ulong
                        != section.offset_from((*filedata).section_headers)
                            as libc::c_long as libc::c_ulong)
                    {
                        if !shndx.is_null() {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Multiple symbol table index sections associated with the same symbol section\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            free(shndx as *mut libc::c_void);
                        }
                        shndx = get_data(
                            0 as *mut libc::c_void,
                            filedata,
                            (*(*entry).hdr).sh_offset as libc::c_ulong,
                            1 as libc::c_int as bfd_size_type,
                            (*(*entry).hdr).sh_size,
                            dcgettext(
                                0 as *const libc::c_char,
                                b"symbol table section indices\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        ) as *mut Elf_External_Sym_Shndx;
                        if shndx.is_null() {
                            current_block = 6456178330288964032;
                            break;
                        }
                        if ((*(*entry).hdr).sh_size)
                            .wrapping_div(
                                ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                    as libc::c_ulong,
                            ) < number
                        {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Index section %s has an sh_size of 0x%lx - expected 0x%lx\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                printable_section_name(filedata, (*entry).hdr),
                                (*(*entry).hdr).sh_size,
                                (*section).sh_size,
                            );
                            current_block = 6456178330288964032;
                            break;
                        }
                    }
                    entry = (*entry).next;
                }
                match current_block {
                    6456178330288964032 => {}
                    _ => {
                        isyms = cmalloc(
                            number,
                            ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
                        ) as *mut Elf_Internal_Sym;
                        if isyms.is_null() {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Out of memory reading %lu symbols\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                number,
                            );
                        } else {
                            j = 0 as libc::c_int as libc::c_uint;
                            psym = isyms;
                            while (j as libc::c_ulong) < number {
                                (*psym)
                                    .st_name = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_name).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                (*psym)
                                    .st_value = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_value).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                (*psym)
                                    .st_size = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_size).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                (*psym)
                                    .st_shndx = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_shndx).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 2]>()
                                        as libc::c_ulong as libc::c_uint,
                                ) as libc::c_uint;
                                if (*psym).st_shndx
                                    == (0x1 as libc::c_uint).wrapping_neg()
                                        & 0xffff as libc::c_int as libc::c_uint && !shndx.is_null()
                                {
                                    (*psym)
                                        .st_shndx = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        &mut *shndx.offset(j as isize)
                                            as *mut Elf_External_Sym_Shndx as *mut libc::c_uchar,
                                        ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as libc::c_uint;
                                } else if (*psym).st_shndx
                                    >= (0x100 as libc::c_uint).wrapping_neg()
                                        & 0xffff as libc::c_int as libc::c_uint
                                {
                                    (*psym)
                                        .st_shndx = ((*psym).st_shndx)
                                        .wrapping_add(
                                            (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_sub(
                                                    (0x100 as libc::c_uint).wrapping_neg()
                                                        & 0xffff as libc::c_int as libc::c_uint,
                                                ),
                                        );
                                }
                                (*psym)
                                    .st_info = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_info).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 1]>()
                                        as libc::c_ulong as libc::c_uint,
                                ) as libc::c_uchar;
                                (*psym)
                                    .st_other = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_other).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 1]>()
                                        as libc::c_ulong as libc::c_uint,
                                ) as libc::c_uchar;
                                j = j.wrapping_add(1);
                                j;
                                psym = psym.offset(1);
                                psym;
                            }
                        }
                    }
                }
            }
        }
    }
    free(shndx as *mut libc::c_void);
    free(esyms as *mut libc::c_void);
    if !num_syms_return.is_null() {
        *num_syms_return = if isyms.is_null() {
            0 as libc::c_int as libc::c_ulong
        } else {
            number
        };
    }
    return isyms;
}
unsafe extern "C" fn get_64bit_elf_symbols(
    mut filedata: *mut Filedata,
    mut section: *mut Elf_Internal_Shdr,
    mut num_syms_return: *mut libc::c_ulong,
) -> *mut Elf_Internal_Sym {
    let mut current_block: u64;
    let mut number: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut esyms: *mut Elf64_External_Sym = 0 as *mut Elf64_External_Sym;
    let mut shndx: *mut Elf_External_Sym_Shndx = 0 as *mut Elf_External_Sym_Shndx;
    let mut isyms: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut psym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut j: libc::c_uint = 0;
    let mut entry: *mut elf_section_list = 0 as *mut elf_section_list;
    if (*section).sh_size == 0 as libc::c_int as libc::c_ulong {
        if !num_syms_return.is_null() {
            *num_syms_return = 0 as libc::c_int as libc::c_ulong;
        }
        return 0 as *mut Elf_Internal_Sym;
    }
    if (*section).sh_entsize == 0 as libc::c_int as libc::c_ulong
        || (*section).sh_entsize > (*section).sh_size
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Section %s has an invalid sh_entsize of 0x%lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
            (*section).sh_entsize,
        );
    } else if (*section).sh_size > (*filedata).file_size {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Section %s has an invalid sh_size of 0x%lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
            (*section).sh_size,
        );
    } else {
        number = ((*section).sh_size).wrapping_div((*section).sh_entsize);
        if number
            .wrapping_mul(::core::mem::size_of::<Elf64_External_Sym>() as libc::c_ulong)
            > ((*section).sh_size).wrapping_add(1 as libc::c_int as libc::c_ulong)
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).sh_size,
                printable_section_name(filedata, section),
                (*section).sh_entsize,
            );
        } else {
            esyms = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*section).sh_offset as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                (*section).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"symbols\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut Elf64_External_Sym;
            if !esyms.is_null() {
                shndx = 0 as *mut Elf_External_Sym_Shndx;
                entry = (*filedata).symtab_shndx_list;
                loop {
                    if entry.is_null() {
                        current_block = 9828876828309294594;
                        break;
                    }
                    if !((*(*entry).hdr).sh_link as libc::c_ulong
                        != section.offset_from((*filedata).section_headers)
                            as libc::c_long as libc::c_ulong)
                    {
                        if !shndx.is_null() {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Multiple symbol table index sections associated with the same symbol section\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            free(shndx as *mut libc::c_void);
                        }
                        shndx = get_data(
                            0 as *mut libc::c_void,
                            filedata,
                            (*(*entry).hdr).sh_offset as libc::c_ulong,
                            1 as libc::c_int as bfd_size_type,
                            (*(*entry).hdr).sh_size,
                            dcgettext(
                                0 as *const libc::c_char,
                                b"symbol table section indices\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        ) as *mut Elf_External_Sym_Shndx;
                        if shndx.is_null() {
                            current_block = 10611951676661815613;
                            break;
                        }
                        if ((*(*entry).hdr).sh_size)
                            .wrapping_div(
                                ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                    as libc::c_ulong,
                            ) < number
                        {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Index section %s has an sh_size of 0x%lx - expected 0x%lx\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                printable_section_name(filedata, (*entry).hdr),
                                (*(*entry).hdr).sh_size,
                                (*section).sh_size,
                            );
                            current_block = 10611951676661815613;
                            break;
                        }
                    }
                    entry = (*entry).next;
                }
                match current_block {
                    10611951676661815613 => {}
                    _ => {
                        isyms = cmalloc(
                            number,
                            ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
                        ) as *mut Elf_Internal_Sym;
                        if isyms.is_null() {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Out of memory reading %lu symbols\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                number,
                            );
                        } else {
                            j = 0 as libc::c_int as libc::c_uint;
                            psym = isyms;
                            while (j as libc::c_ulong) < number {
                                (*psym)
                                    .st_name = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_name).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                (*psym)
                                    .st_info = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_info).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 1]>()
                                        as libc::c_ulong as libc::c_uint,
                                ) as libc::c_uchar;
                                (*psym)
                                    .st_other = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_other).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 1]>()
                                        as libc::c_ulong as libc::c_uint,
                                ) as libc::c_uchar;
                                (*psym)
                                    .st_shndx = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_shndx).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 2]>()
                                        as libc::c_ulong as libc::c_uint,
                                ) as libc::c_uint;
                                if (*psym).st_shndx
                                    == (0x1 as libc::c_uint).wrapping_neg()
                                        & 0xffff as libc::c_int as libc::c_uint && !shndx.is_null()
                                {
                                    (*psym)
                                        .st_shndx = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        &mut *shndx.offset(j as isize)
                                            as *mut Elf_External_Sym_Shndx as *mut libc::c_uchar,
                                        ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as libc::c_uint;
                                } else if (*psym).st_shndx
                                    >= (0x100 as libc::c_uint).wrapping_neg()
                                        & 0xffff as libc::c_int as libc::c_uint
                                {
                                    (*psym)
                                        .st_shndx = ((*psym).st_shndx)
                                        .wrapping_add(
                                            (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_sub(
                                                    (0x100 as libc::c_uint).wrapping_neg()
                                                        & 0xffff as libc::c_int as libc::c_uint,
                                                ),
                                        );
                                }
                                (*psym)
                                    .st_value = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_value).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 8]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                (*psym)
                                    .st_size = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*esyms.offset(j as isize)).st_size).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 8]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                j = j.wrapping_add(1);
                                j;
                                psym = psym.offset(1);
                                psym;
                            }
                        }
                    }
                }
            }
        }
    }
    free(shndx as *mut libc::c_void);
    free(esyms as *mut libc::c_void);
    if !num_syms_return.is_null() {
        *num_syms_return = if isyms.is_null() {
            0 as libc::c_int as libc::c_ulong
        } else {
            number
        };
    }
    return isyms;
}
unsafe extern "C" fn get_elf_symbols(
    mut filedata: *mut Filedata,
    mut section: *mut Elf_Internal_Shdr,
    mut num_syms_return: *mut libc::c_ulong,
) -> *mut Elf_Internal_Sym {
    if is_32bit_elf {
        return get_32bit_elf_symbols(filedata, section, num_syms_return)
    } else {
        return get_64bit_elf_symbols(filedata, section, num_syms_return)
    };
}
static mut flags: [C2RustUnnamed_28; 27] = [C2RustUnnamed_28 {
    str_0: 0 as *const libc::c_char,
    len: 0,
}; 27];
unsafe extern "C" fn get_elf_section_flags(
    mut filedata: *mut Filedata,
    mut sh_flags: bfd_vma,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 1024] = [0; 1024];
    let mut p: *mut libc::c_char = buff.as_mut_ptr();
    let mut field_size: libc::c_uint = (if is_32bit_elf as libc::c_int != 0 {
        8 as libc::c_int
    } else {
        16 as libc::c_int
    }) as libc::c_uint;
    let mut sindex: libc::c_int = 0;
    let mut size: libc::c_uint = (::core::mem::size_of::<[libc::c_char; 1024]>()
        as libc::c_ulong)
        .wrapping_sub(
            field_size
                .wrapping_add(4 as libc::c_int as libc::c_uint)
                .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
        ) as libc::c_uint;
    let mut os_flags: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut proc_flags: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut unknown_flags: bfd_vma = 0 as libc::c_int as bfd_vma;
    if do_section_details {
        sprintf(
            buff.as_mut_ptr(),
            b"[%*.*lx]: \0" as *const u8 as *const libc::c_char,
            field_size,
            field_size,
            sh_flags,
        );
        p = p.offset(field_size.wrapping_add(4 as libc::c_int as libc::c_uint) as isize);
    }
    while sh_flags != 0 {
        let mut flag: bfd_vma = 0;
        flag = sh_flags & sh_flags.wrapping_neg();
        sh_flags &= !flag;
        if do_section_details {
            match flag {
                1 => {
                    sindex = 0 as libc::c_int;
                }
                2 => {
                    sindex = 1 as libc::c_int;
                }
                4 => {
                    sindex = 2 as libc::c_int;
                }
                16 => {
                    sindex = 3 as libc::c_int;
                }
                32 => {
                    sindex = 4 as libc::c_int;
                }
                64 => {
                    sindex = 5 as libc::c_int;
                }
                128 => {
                    sindex = 6 as libc::c_int;
                }
                256 => {
                    sindex = 7 as libc::c_int;
                }
                512 => {
                    sindex = 8 as libc::c_int;
                }
                1024 => {
                    sindex = 9 as libc::c_int;
                }
                2147483648 => {
                    sindex = 18 as libc::c_int;
                }
                2048 => {
                    sindex = 20 as libc::c_int;
                }
                _ => {
                    sindex = -(1 as libc::c_int);
                    match (*filedata).file_header.e_machine as libc::c_int {
                        50 => {
                            if flag == 0x10000000 as libc::c_int as libc::c_ulong {
                                sindex = 10 as libc::c_int;
                            } else if flag == 0x20000000 as libc::c_int as libc::c_ulong
                            {
                                sindex = 11 as libc::c_int;
                            } else if (*filedata)
                                .file_header
                                .e_ident[7 as libc::c_int as usize] as libc::c_int
                                == 13 as libc::c_int
                            {
                                match flag {
                                    4294967296 => {
                                        sindex = 12 as libc::c_int;
                                    }
                                    8589934592 => {
                                        sindex = 13 as libc::c_int;
                                    }
                                    17179869184 => {
                                        sindex = 14 as libc::c_int;
                                    }
                                    34359738368 => {
                                        sindex = 15 as libc::c_int;
                                    }
                                    68719476736 => {
                                        sindex = 16 as libc::c_int;
                                    }
                                    137438953472 => {
                                        sindex = 17 as libc::c_int;
                                    }
                                    _ => {}
                                }
                            }
                        }
                        3 | 6 | 62 | 180 | 181 | 11 | 18 | 43 | 2 => {
                            if flag == 0x40000000 as libc::c_int as libc::c_ulong {
                                sindex = 19 as libc::c_int;
                            }
                        }
                        40 => {
                            match flag {
                                268435456 => {
                                    sindex = 21 as libc::c_int;
                                }
                                536870912 => {
                                    sindex = 22 as libc::c_int;
                                }
                                2147483648 => {
                                    sindex = 23 as libc::c_int;
                                }
                                _ => {}
                            }
                        }
                        20 => {
                            if flag == 0x10000000 as libc::c_int as libc::c_ulong {
                                sindex = 25 as libc::c_int;
                            }
                        }
                        _ => {}
                    }
                    let mut current_block_43: u64;
                    match (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                        as libc::c_int
                    {
                        3 | 9 => {
                            if flag
                                == ((1 as libc::c_int) << 21 as libc::c_int)
                                    as libc::c_ulong
                            {
                                sindex = 26 as libc::c_int;
                            }
                            current_block_43 = 4398528925228648566;
                        }
                        0 => {
                            current_block_43 = 4398528925228648566;
                        }
                        _ => {
                            current_block_43 = 8869332144787829186;
                        }
                    }
                    match current_block_43 {
                        4398528925228648566 => {
                            if flag == 0x1000000 as libc::c_int as libc::c_ulong {
                                sindex = 24 as libc::c_int;
                            }
                        }
                        _ => {}
                    }
                }
            }
            if sindex != -(1 as libc::c_int) {
                if p
                    != buff
                        .as_mut_ptr()
                        .offset(field_size as isize)
                        .offset(4 as libc::c_int as isize)
                {
                    if size < (10 as libc::c_int + 2 as libc::c_int) as libc::c_uint {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Internal error: not enough buffer room for section flag info\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        return dcgettext(
                            0 as *const libc::c_char,
                            b"<unknown>\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        );
                    }
                    size = size.wrapping_sub(2 as libc::c_int as libc::c_uint);
                    let fresh12 = p;
                    p = p.offset(1);
                    *fresh12 = ',' as i32 as libc::c_char;
                    let fresh13 = p;
                    p = p.offset(1);
                    *fresh13 = ' ' as i32 as libc::c_char;
                }
                size = size.wrapping_sub(flags[sindex as usize].len);
                p = stpcpy(p, flags[sindex as usize].str_0);
            } else if flag & 0xff00000 as libc::c_int as libc::c_ulong != 0 {
                os_flags |= flag;
            } else if flag & 0xf0000000 as libc::c_uint as libc::c_ulong != 0 {
                proc_flags |= flag;
            } else {
                unknown_flags |= flag;
            }
        } else {
            match flag {
                1 => {
                    *p = 'W' as i32 as libc::c_char;
                }
                2 => {
                    *p = 'A' as i32 as libc::c_char;
                }
                4 => {
                    *p = 'X' as i32 as libc::c_char;
                }
                16 => {
                    *p = 'M' as i32 as libc::c_char;
                }
                32 => {
                    *p = 'S' as i32 as libc::c_char;
                }
                64 => {
                    *p = 'I' as i32 as libc::c_char;
                }
                128 => {
                    *p = 'L' as i32 as libc::c_char;
                }
                256 => {
                    *p = 'O' as i32 as libc::c_char;
                }
                512 => {
                    *p = 'G' as i32 as libc::c_char;
                }
                1024 => {
                    *p = 'T' as i32 as libc::c_char;
                }
                2147483648 => {
                    *p = 'E' as i32 as libc::c_char;
                }
                2048 => {
                    *p = 'C' as i32 as libc::c_char;
                }
                _ => {
                    if ((*filedata).file_header.e_machine as libc::c_int
                        == 62 as libc::c_int
                        || (*filedata).file_header.e_machine as libc::c_int
                            == 180 as libc::c_int
                        || (*filedata).file_header.e_machine as libc::c_int
                            == 181 as libc::c_int)
                        && flag == 0x10000000 as libc::c_int as libc::c_ulong
                    {
                        *p = 'l' as i32 as libc::c_char;
                    } else if (*filedata).file_header.e_machine as libc::c_int
                        == 40 as libc::c_int
                        && flag == 0x20000000 as libc::c_int as libc::c_ulong
                    {
                        *p = 'y' as i32 as libc::c_char;
                    } else if (*filedata).file_header.e_machine as libc::c_int
                        == 20 as libc::c_int
                        && flag == 0x10000000 as libc::c_int as libc::c_ulong
                    {
                        *p = 'v' as i32 as libc::c_char;
                    } else if flag & 0xff00000 as libc::c_int as libc::c_ulong != 0 {
                        let mut current_block_83: u64;
                        match (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                            as libc::c_int
                        {
                            3 | 9 => {
                                if flag
                                    == ((1 as libc::c_int) << 21 as libc::c_int)
                                        as libc::c_ulong
                                {
                                    *p = 'R' as i32 as libc::c_char;
                                    current_block_83 = 10109057886293123569;
                                } else {
                                    current_block_83 = 10456417380794143983;
                                }
                            }
                            0 => {
                                current_block_83 = 10456417380794143983;
                            }
                            _ => {
                                current_block_83 = 1313103347008124595;
                            }
                        }
                        match current_block_83 {
                            10456417380794143983 => {
                                if flag == 0x1000000 as libc::c_int as libc::c_ulong {
                                    *p = 'D' as i32 as libc::c_char;
                                    current_block_83 = 10109057886293123569;
                                } else {
                                    current_block_83 = 1313103347008124595;
                                }
                            }
                            _ => {}
                        }
                        match current_block_83 {
                            1313103347008124595 => {
                                *p = 'o' as i32 as libc::c_char;
                                sh_flags &= !(0xff00000 as libc::c_int) as libc::c_ulong;
                            }
                            _ => {}
                        }
                    } else if flag & 0xf0000000 as libc::c_uint as libc::c_ulong != 0 {
                        *p = 'p' as i32 as libc::c_char;
                        sh_flags &= !(0xf0000000 as libc::c_uint) as libc::c_ulong;
                    } else {
                        *p = 'x' as i32 as libc::c_char;
                    }
                }
            }
            p = p.offset(1);
            p;
        }
    }
    if do_section_details {
        if os_flags != 0 {
            size = size
                .wrapping_sub(
                    (5 as libc::c_int as libc::c_uint).wrapping_add(field_size),
                );
            if p
                != buff
                    .as_mut_ptr()
                    .offset(field_size as isize)
                    .offset(4 as libc::c_int as isize)
            {
                if size < (2 as libc::c_int + 1 as libc::c_int) as libc::c_uint {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Internal error: not enough buffer room for section flag info\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                size = size.wrapping_sub(2 as libc::c_int as libc::c_uint);
                let fresh14 = p;
                p = p.offset(1);
                *fresh14 = ',' as i32 as libc::c_char;
                let fresh15 = p;
                p = p.offset(1);
                *fresh15 = ' ' as i32 as libc::c_char;
            }
            sprintf(
                p,
                b"OS (%*.*lx)\0" as *const u8 as *const libc::c_char,
                field_size,
                field_size,
                os_flags,
            );
            p = p
                .offset(
                    (5 as libc::c_int as libc::c_uint).wrapping_add(field_size) as isize,
                );
        }
        if proc_flags != 0 {
            size = size
                .wrapping_sub(
                    (7 as libc::c_int as libc::c_uint).wrapping_add(field_size),
                );
            if p
                != buff
                    .as_mut_ptr()
                    .offset(field_size as isize)
                    .offset(4 as libc::c_int as isize)
            {
                if size < (2 as libc::c_int + 1 as libc::c_int) as libc::c_uint {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Internal error: not enough buffer room for section flag info\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                size = size.wrapping_sub(2 as libc::c_int as libc::c_uint);
                let fresh16 = p;
                p = p.offset(1);
                *fresh16 = ',' as i32 as libc::c_char;
                let fresh17 = p;
                p = p.offset(1);
                *fresh17 = ' ' as i32 as libc::c_char;
            }
            sprintf(
                p,
                b"PROC (%*.*lx)\0" as *const u8 as *const libc::c_char,
                field_size,
                field_size,
                proc_flags,
            );
            p = p
                .offset(
                    (7 as libc::c_int as libc::c_uint).wrapping_add(field_size) as isize,
                );
        }
        if unknown_flags != 0 {
            size = size
                .wrapping_sub(
                    (10 as libc::c_int as libc::c_uint).wrapping_add(field_size),
                );
            if p
                != buff
                    .as_mut_ptr()
                    .offset(field_size as isize)
                    .offset(4 as libc::c_int as isize)
            {
                if size < (2 as libc::c_int + 1 as libc::c_int) as libc::c_uint {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Internal error: not enough buffer room for section flag info\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                size = size.wrapping_sub(2 as libc::c_int as libc::c_uint);
                let fresh18 = p;
                p = p.offset(1);
                *fresh18 = ',' as i32 as libc::c_char;
                let fresh19 = p;
                p = p.offset(1);
                *fresh19 = ' ' as i32 as libc::c_char;
            }
            sprintf(
                p,
                dcgettext(
                    0 as *const libc::c_char,
                    b"UNKNOWN (%*.*lx)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                field_size,
                field_size,
                unknown_flags,
            );
            p = p
                .offset(
                    (10 as libc::c_int as libc::c_uint).wrapping_add(field_size) as isize,
                );
        }
    }
    *p = '\0' as i32 as libc::c_char;
    return buff.as_mut_ptr();
}
unsafe extern "C" fn get_compression_header(
    mut chdr: *mut Elf_Internal_Chdr,
    mut buf: *mut libc::c_uchar,
    mut size: bfd_size_type,
) -> libc::c_uint {
    if is_32bit_elf {
        let mut echdr: *mut Elf32_External_Chdr = buf as *mut Elf32_External_Chdr;
        if size < ::core::mem::size_of::<Elf32_External_Chdr>() as libc::c_ulong {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Compressed section is too small even for a compression header\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int as libc::c_uint;
        }
        (*chdr)
            .ch_type = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*echdr).ch_type).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*chdr)
            .ch_size = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*echdr).ch_size).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*chdr)
            .ch_addralign = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*echdr).ch_addralign).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        return ::core::mem::size_of::<Elf32_External_Chdr>() as libc::c_ulong
            as libc::c_uint;
    } else {
        let mut echdr_0: *mut Elf64_External_Chdr = buf as *mut Elf64_External_Chdr;
        if size < ::core::mem::size_of::<Elf64_External_Chdr>() as libc::c_ulong {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Compressed section is too small even for a compression header\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int as libc::c_uint;
        }
        (*chdr)
            .ch_type = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*echdr_0).ch_type).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*chdr)
            .ch_size = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*echdr_0).ch_size).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*chdr)
            .ch_addralign = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*echdr_0).ch_addralign).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        return ::core::mem::size_of::<Elf64_External_Chdr>() as libc::c_ulong
            as libc::c_uint;
    };
}
unsafe extern "C" fn process_section_headers(mut filedata: *mut Filedata) -> bool {
    let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_uint = 0;
    if (*filedata).file_header.e_shnum == 0 as libc::c_int as libc::c_uint {
        if (*filedata).file_header.e_shoff != 0 as libc::c_int as libc::c_ulong {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"possibly corrupt ELF file header - it has a non-zero section header offset, but no section headers\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        } else if do_sections {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nThere are no sections in this file.\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        return 1 as libc::c_int != 0;
    }
    if do_sections as libc::c_int != 0 && !do_header {
        if (*filedata).is_separate as libc::c_int != 0
            && process_links as libc::c_int != 0
        {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"In linked file '%s': \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*filedata).file_name,
            );
        }
        if !(*filedata).is_separate || process_links as libc::c_int != 0 {
            printf(
                dcngettext(
                    0 as *const libc::c_char,
                    b"There is %d section header, starting at offset 0x%lx:\n\0"
                        as *const u8 as *const libc::c_char,
                    b"There are %d section headers, starting at offset 0x%lx:\n\0"
                        as *const u8 as *const libc::c_char,
                    (*filedata).file_header.e_shnum as libc::c_ulong,
                    5 as libc::c_int,
                ),
                (*filedata).file_header.e_shnum,
                (*filedata).file_header.e_shoff,
            );
        }
    }
    if !get_section_headers(filedata, 0 as libc::c_int != 0) {
        return 0 as libc::c_int != 0;
    }
    if (*filedata).file_header.e_shstrndx != 0 as libc::c_int as libc::c_uint
        && (*filedata).file_header.e_shstrndx < (*filedata).file_header.e_shnum
    {
        section = ((*filedata).section_headers)
            .offset((*filedata).file_header.e_shstrndx as isize);
        if (*section).sh_size != 0 as libc::c_int as libc::c_ulong {
            (*filedata)
                .string_table = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*section).sh_offset as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                (*section).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"string table\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut libc::c_char;
            (*filedata)
                .string_table_length = if !((*filedata).string_table).is_null() {
                (*section).sh_size
            } else {
                0 as libc::c_int as libc::c_ulong
            };
        }
    }
    eh_addr_size = (if is_32bit_elf as libc::c_int != 0 {
        4 as libc::c_int
    } else {
        8 as libc::c_int
    }) as libc::c_uint;
    match (*filedata).file_header.e_machine as libc::c_int {
        8 | 10 => {
            if (*filedata).file_header.e_flags & 0xf000 as libc::c_int as libc::c_ulong
                == 0x4000 as libc::c_int as libc::c_ulong
                && (find_section(
                    filedata,
                    b".gcc_compiled_long32\0" as *const u8 as *const libc::c_char,
                ))
                    .is_null()
            {
                eh_addr_size = 8 as libc::c_int as libc::c_uint;
            }
        }
        46 | 47 => {
            match (*filedata).file_header.e_flags
                & 0xff0000 as libc::c_int as libc::c_ulong
            {
                8388608 | 8585216 | 8650752 | 8781824 => {
                    eh_addr_size = 2 as libc::c_int as libc::c_uint;
                }
                8454144 | 8519680 | 8716288 => {
                    eh_addr_size = 4 as libc::c_int as libc::c_uint;
                }
                _ => {}
            }
        }
        65200 | 120 => {
            match (*filedata).file_header.e_flags & 0x7f as libc::c_int as libc::c_ulong
            {
                117 => {
                    eh_addr_size = 2 as libc::c_int as libc::c_uint;
                }
                _ => {}
            }
        }
        _ => {}
    }
    let mut current_block_110: u64;
    i = 0 as libc::c_int as libc::c_uint;
    section = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum {
        let mut name: *mut libc::c_char = if section.is_null() {
            dcgettext(
                0 as *const libc::c_char,
                b"<none>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        } else if ((*filedata).string_table).is_null() {
            dcgettext(
                0 as *const libc::c_char,
                b"<no-strings>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        } else if (*section).sh_name as libc::c_ulong >= (*filedata).string_table_length
        {
            dcgettext(
                0 as *const libc::c_char,
                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        } else {
            ((*filedata).string_table).offset((*section).sh_name as isize)
        };
        match (*section).sh_type {
            11 => {
                if !((*filedata).dynamic_symbols).is_null() {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"File contains multiple dynamic symbol tables\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    current_block_110 = 2873832966593178012;
                } else {
                    let mut expected_entsize: bfd_size_type = if is_32bit_elf
                        as libc::c_int != 0
                    {
                        ::core::mem::size_of::<Elf32_External_Sym>() as libc::c_ulong
                    } else {
                        ::core::mem::size_of::<Elf64_External_Sym>() as libc::c_ulong
                    };
                    if (*section).sh_entsize != expected_entsize {
                        let mut buf: [libc::c_char; 40] = [0; 40];
                        sprintf(
                            buf.as_mut_ptr(),
                            b"%016lx\0" as *const u8 as *const libc::c_char,
                            (*section).sh_entsize,
                        );
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Section %d has invalid sh_entsize of %s\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            i,
                            buf.as_mut_ptr(),
                        );
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(Using the expected size of %u for the rest of this dump)\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            expected_entsize as libc::c_uint,
                        );
                        (*section).sh_entsize = expected_entsize;
                    }
                    (*filedata)
                        .dynamic_symbols = get_elf_symbols(
                        filedata,
                        section,
                        &mut (*filedata).num_dynamic_syms,
                    );
                    (*filedata).dynamic_symtab_section = section;
                    current_block_110 = 7416055328783156979;
                }
            }
            3 => {
                if strcmp(name, b".dynstr\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    if !((*filedata).dynamic_strings).is_null() {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"File contains multiple dynamic string tables\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        current_block_110 = 2873832966593178012;
                    } else {
                        (*filedata)
                            .dynamic_strings = get_data(
                            0 as *mut libc::c_void,
                            filedata,
                            (*section).sh_offset as libc::c_ulong,
                            1 as libc::c_int as bfd_size_type,
                            (*section).sh_size,
                            dcgettext(
                                0 as *const libc::c_char,
                                b"dynamic strings\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        ) as *mut libc::c_char;
                        (*filedata)
                            .dynamic_strings_length = if ((*filedata).dynamic_strings)
                            .is_null()
                        {
                            0 as libc::c_int as libc::c_ulong
                        } else {
                            (*section).sh_size
                        };
                        (*filedata).dynamic_strtab_section = section;
                        current_block_110 = 7416055328783156979;
                    }
                } else {
                    current_block_110 = 7416055328783156979;
                }
            }
            18 => {
                let mut entry: *mut elf_section_list = xmalloc(
                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                ) as *mut elf_section_list;
                (*entry).hdr = section;
                (*entry).next = (*filedata).symtab_shndx_list;
                (*filedata).symtab_shndx_list = entry;
                current_block_110 = 7416055328783156979;
            }
            2 => {
                let mut expected_entsize_0: bfd_size_type = if is_32bit_elf
                    as libc::c_int != 0
                {
                    ::core::mem::size_of::<Elf32_External_Sym>() as libc::c_ulong
                } else {
                    ::core::mem::size_of::<Elf64_External_Sym>() as libc::c_ulong
                };
                if (*section).sh_entsize != expected_entsize_0 {
                    let mut buf_0: [libc::c_char; 40] = [0; 40];
                    sprintf(
                        buf_0.as_mut_ptr(),
                        b"%016lx\0" as *const u8 as *const libc::c_char,
                        (*section).sh_entsize,
                    );
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Section %d has invalid sh_entsize of %s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        buf_0.as_mut_ptr(),
                    );
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(Using the expected size of %u for the rest of this dump)\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        expected_entsize_0 as libc::c_uint,
                    );
                    (*section).sh_entsize = expected_entsize_0;
                }
                current_block_110 = 7416055328783156979;
            }
            17 => {
                let mut expected_entsize_1: bfd_size_type = (if is_32bit_elf
                    as libc::c_int != 0
                {
                    4 as libc::c_int
                } else {
                    4 as libc::c_int
                }) as bfd_size_type;
                if (*section).sh_entsize != expected_entsize_1 {
                    let mut buf_1: [libc::c_char; 40] = [0; 40];
                    sprintf(
                        buf_1.as_mut_ptr(),
                        b"%016lx\0" as *const u8 as *const libc::c_char,
                        (*section).sh_entsize,
                    );
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Section %d has invalid sh_entsize of %s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        buf_1.as_mut_ptr(),
                    );
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(Using the expected size of %u for the rest of this dump)\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        expected_entsize_1 as libc::c_uint,
                    );
                    (*section).sh_entsize = expected_entsize_1;
                }
                current_block_110 = 7416055328783156979;
            }
            9 => {
                let mut expected_entsize_2: bfd_size_type = if is_32bit_elf
                    as libc::c_int != 0
                {
                    ::core::mem::size_of::<Elf32_External_Rel>() as libc::c_ulong
                } else {
                    ::core::mem::size_of::<Elf64_External_Rel>() as libc::c_ulong
                };
                if (*section).sh_entsize != expected_entsize_2 {
                    let mut buf_2: [libc::c_char; 40] = [0; 40];
                    sprintf(
                        buf_2.as_mut_ptr(),
                        b"%016lx\0" as *const u8 as *const libc::c_char,
                        (*section).sh_entsize,
                    );
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Section %d has invalid sh_entsize of %s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        buf_2.as_mut_ptr(),
                    );
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(Using the expected size of %u for the rest of this dump)\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        expected_entsize_2 as libc::c_uint,
                    );
                    (*section).sh_entsize = expected_entsize_2;
                }
                if do_checks as libc::c_int != 0
                    && (*section).sh_size == 0 as libc::c_int as libc::c_ulong
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Section '%s': zero-sized relocation section\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        name,
                    );
                }
                current_block_110 = 7416055328783156979;
            }
            4 => {
                let mut expected_entsize_3: bfd_size_type = if is_32bit_elf
                    as libc::c_int != 0
                {
                    ::core::mem::size_of::<Elf32_External_Rela>() as libc::c_ulong
                } else {
                    ::core::mem::size_of::<Elf64_External_Rela>() as libc::c_ulong
                };
                if (*section).sh_entsize != expected_entsize_3 {
                    let mut buf_3: [libc::c_char; 40] = [0; 40];
                    sprintf(
                        buf_3.as_mut_ptr(),
                        b"%016lx\0" as *const u8 as *const libc::c_char,
                        (*section).sh_entsize,
                    );
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Section %d has invalid sh_entsize of %s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        buf_3.as_mut_ptr(),
                    );
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(Using the expected size of %u for the rest of this dump)\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        expected_entsize_3 as libc::c_uint,
                    );
                    (*section).sh_entsize = expected_entsize_3;
                }
                if do_checks as libc::c_int != 0
                    && (*section).sh_size == 0 as libc::c_int as libc::c_ulong
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Section '%s': zero-sized relocation section\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        name,
                    );
                }
                current_block_110 = 7416055328783156979;
            }
            7 | 1 => {
                if do_checks as libc::c_int != 0
                    && (*section).sh_size == 0 as libc::c_int as libc::c_ulong
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Section '%s': has a size of zero - is this intended ?\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        name,
                    );
                }
                current_block_110 = 7416055328783156979;
            }
            _ => {
                current_block_110 = 7416055328783156979;
            }
        }
        match current_block_110 {
            7416055328783156979 => {
                if (do_debugging as libc::c_int != 0 || do_debug_info != 0
                    || do_debug_abbrevs != 0 || do_debug_lines != 0
                    || do_debug_pubnames != 0 || do_debug_pubtypes != 0
                    || do_debug_aranges != 0 || do_debug_frames != 0
                    || do_debug_macinfo != 0 || do_debug_str != 0
                    || do_debug_str_offsets != 0 || do_debug_loc != 0
                    || do_debug_ranges != 0 || do_debug_addr != 0
                    || do_debug_cu_index != 0 || do_debug_links != 0)
                    && (startswith(
                        name,
                        b".debug_\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_int != 0
                        || startswith(
                            name,
                            b".zdebug_\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_int != 0)
                {
                    if *name.offset(1 as libc::c_int as isize) as libc::c_int
                        == 'z' as i32
                    {
                        name = name
                            .offset(
                                (::core::mem::size_of::<[libc::c_char; 9]>()
                                    as libc::c_ulong)
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                            );
                    } else {
                        name = name
                            .offset(
                                (::core::mem::size_of::<[libc::c_char; 8]>()
                                    as libc::c_ulong)
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                            );
                    }
                    if do_debugging as libc::c_int != 0
                        || do_debug_info != 0
                            && startswith(
                                name,
                                b"info\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_info != 0
                            && startswith(
                                name,
                                b"types\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_abbrevs != 0
                            && startswith(
                                name,
                                b"abbrev\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_lines != 0
                            && strcmp(
                                name,
                                b"line\0" as *const u8 as *const libc::c_char,
                            ) == 0 as libc::c_int
                        || do_debug_lines != 0
                            && startswith(
                                name,
                                b"line.\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_pubnames != 0
                            && startswith(
                                name,
                                b"pubnames\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_pubtypes != 0
                            && startswith(
                                name,
                                b"pubtypes\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_pubnames != 0
                            && startswith(
                                name,
                                b"gnu_pubnames\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_pubtypes != 0
                            && startswith(
                                name,
                                b"gnu_pubtypes\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_aranges != 0
                            && startswith(
                                name,
                                b"aranges\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_ranges != 0
                            && startswith(
                                name,
                                b"ranges\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_ranges != 0
                            && startswith(
                                name,
                                b"rnglists\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_frames != 0
                            && startswith(
                                name,
                                b"frame\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_macinfo != 0
                            && startswith(
                                name,
                                b"macinfo\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_macinfo != 0
                            && startswith(
                                name,
                                b"macro\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_str != 0
                            && startswith(
                                name,
                                b"str\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_links != 0
                            && startswith(
                                name,
                                b"sup\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_str_offsets != 0
                            && startswith(
                                name,
                                b"str_offsets\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_loc != 0
                            && startswith(
                                name,
                                b"loc\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_loc != 0
                            && startswith(
                                name,
                                b"loclists\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_addr != 0
                            && startswith(
                                name,
                                b"addr\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_cu_index != 0
                            && startswith(
                                name,
                                b"cu_index\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                        || do_debug_cu_index != 0
                            && startswith(
                                name,
                                b"tu_index\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                    {
                        request_dump_bynumber(
                            &mut (*filedata).dump,
                            i,
                            ((1 as libc::c_int) << 2 as libc::c_int) as dump_type,
                        );
                    }
                } else if (do_debugging as libc::c_int != 0 || do_debug_info != 0)
                    && startswith(
                        name,
                        b".gnu.linkonce.wi.\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_int != 0
                {
                    request_dump_bynumber(
                        &mut (*filedata).dump,
                        i,
                        ((1 as libc::c_int) << 2 as libc::c_int) as dump_type,
                    );
                } else if do_debug_frames != 0
                    && strcmp(name, b".eh_frame\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    request_dump_bynumber(
                        &mut (*filedata).dump,
                        i,
                        ((1 as libc::c_int) << 2 as libc::c_int) as dump_type,
                    );
                } else if do_gdb_index != 0
                    && (strcmp(name, b".gdb_index\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                        || strcmp(
                            name,
                            b".debug_names\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int)
                {
                    request_dump_bynumber(
                        &mut (*filedata).dump,
                        i,
                        ((1 as libc::c_int) << 2 as libc::c_int) as dump_type,
                    );
                } else if (do_debugging as libc::c_int != 0 || do_trace_info != 0
                    || do_trace_abbrevs != 0 || do_trace_aranges != 0)
                    && startswith(name, b".trace_\0" as *const u8 as *const libc::c_char)
                        as libc::c_int != 0
                {
                    name = name
                        .offset(
                            (::core::mem::size_of::<[libc::c_char; 8]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                        );
                    if do_debugging as libc::c_int != 0
                        || do_trace_info != 0
                            && strcmp(
                                name,
                                b"info\0" as *const u8 as *const libc::c_char,
                            ) == 0 as libc::c_int
                        || do_trace_abbrevs != 0
                            && strcmp(
                                name,
                                b"abbrev\0" as *const u8 as *const libc::c_char,
                            ) == 0 as libc::c_int
                        || do_trace_aranges != 0
                            && strcmp(
                                name,
                                b"aranges\0" as *const u8 as *const libc::c_char,
                            ) == 0 as libc::c_int
                    {
                        request_dump_bynumber(
                            &mut (*filedata).dump,
                            i,
                            ((1 as libc::c_int) << 2 as libc::c_int) as dump_type,
                        );
                    }
                } else if (do_debugging as libc::c_int != 0 || do_debug_links != 0)
                    && (startswith(
                        name,
                        b".gnu_debuglink\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_int != 0
                        || startswith(
                            name,
                            b".gnu_debugaltlink\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_int != 0)
                {
                    request_dump_bynumber(
                        &mut (*filedata).dump,
                        i,
                        ((1 as libc::c_int) << 2 as libc::c_int) as dump_type,
                    );
                }
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    if !do_sections {
        return 1 as libc::c_int != 0;
    }
    if (*filedata).is_separate as libc::c_int != 0 && !process_links {
        return 1 as libc::c_int != 0;
    }
    if (*filedata).is_separate {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nSection Headers in linked file '%s':\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_name,
        );
    } else if (*filedata).file_header.e_shnum > 1 as libc::c_int as libc::c_uint {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nSection Headers:\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nSection Header:\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    if is_32bit_elf {
        if do_section_details {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  [Nr] Name\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"       Type            Addr     Off    Size   ES   Lk Inf Al\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
    } else if do_wide != 0 {
        if do_section_details {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  [Nr] Name\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"       Type            Address          Off    Size   ES   Lk Inf Al\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
    } else if do_section_details {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  [Nr] Name\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"       Type              Address          Offset            Link\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"       Size              EntSize          Info              Align\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  [Nr] Name              Type             Address           Offset\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"       Size              EntSize          Flags  Link  Info  Align\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    if do_section_details {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"       Flags\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    i = 0 as libc::c_int as libc::c_uint;
    section = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum {
        let mut current_block_152: u64;
        match (*section).sh_type {
            9 | 4 => {
                if (*section).sh_link == 0 as libc::c_int as libc::c_uint
                    && ((*filedata).file_header.e_type as libc::c_int == 2 as libc::c_int
                        || (*filedata).file_header.e_type as libc::c_int
                            == 3 as libc::c_int)
                {
                    current_block_152 = 12129449210080749085;
                } else {
                    current_block_152 = 15612193027111100860;
                }
            }
            18 | 17 | 5 | 1879048182 | 1879048191 => {
                current_block_152 = 15612193027111100860;
            }
            6 | 2 | 11 | 1879048190 | 1879048189 | 1879048183 => {
                if (*section).sh_link == 0 as libc::c_int as libc::c_uint
                    || (*section).sh_link >= (*filedata).file_header.e_shnum
                    || (*((*filedata).section_headers)
                        .offset((*section).sh_link as isize))
                        .sh_type != 3 as libc::c_int as libc::c_uint
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"[%2u]: Link field (%u) should index a string section.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        (*section).sh_link,
                    );
                }
                current_block_152 = 12129449210080749085;
            }
            14 | 15 | 16 => {
                if (*section).sh_type < 0x60000000 as libc::c_int as libc::c_uint
                    && (*section).sh_link != 0 as libc::c_int as libc::c_uint
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"[%2u]: Unexpected value (%u) in link field.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        (*section).sh_link,
                    );
                }
                current_block_152 = 12129449210080749085;
            }
            _ => {
                current_block_152 = 12129449210080749085;
            }
        }
        match current_block_152 {
            15612193027111100860 => {
                if (*section).sh_link == 0 as libc::c_int as libc::c_uint
                    || (*section).sh_link >= (*filedata).file_header.e_shnum
                    || (*((*filedata).section_headers)
                        .offset((*section).sh_link as isize))
                        .sh_type != 2 as libc::c_int as libc::c_uint
                        && (*((*filedata).section_headers)
                            .offset((*section).sh_link as isize))
                            .sh_type != 11 as libc::c_int as libc::c_uint
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"[%2u]: Link field (%u) should index a symtab section.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        (*section).sh_link,
                    );
                }
            }
            _ => {}
        }
        match (*section).sh_type {
            9 | 4 => {
                if !((*section).sh_info == 0 as libc::c_int as libc::c_uint
                    && ((*filedata).file_header.e_type as libc::c_int == 2 as libc::c_int
                        || (*filedata).file_header.e_type as libc::c_int
                            == 3 as libc::c_int))
                {
                    if (*section).sh_info == 0 as libc::c_int as libc::c_uint
                        || (*section).sh_info >= (*filedata).file_header.e_shnum
                        || (*((*filedata).section_headers)
                            .offset((*section).sh_info as isize))
                            .sh_type != 1 as libc::c_int as libc::c_uint
                            && (*((*filedata).section_headers)
                                .offset((*section).sh_info as isize))
                                .sh_type != 8 as libc::c_int as libc::c_uint
                            && (*((*filedata).section_headers)
                                .offset((*section).sh_info as isize))
                                .sh_type != 7 as libc::c_int as libc::c_uint
                            && (*((*filedata).section_headers)
                                .offset((*section).sh_info as isize))
                                .sh_type != 14 as libc::c_int as libc::c_uint
                            && (*((*filedata).section_headers)
                                .offset((*section).sh_info as isize))
                                .sh_type != 15 as libc::c_int as libc::c_uint
                            && (*((*filedata).section_headers)
                                .offset((*section).sh_info as isize))
                                .sh_type != 16 as libc::c_int as libc::c_uint
                            && (*((*filedata).section_headers)
                                .offset((*section).sh_info as isize))
                                .sh_type < 0x60000000 as libc::c_int as libc::c_uint
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"[%2u]: Info field (%u) should index a relocatable section.\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            i,
                            (*section).sh_info,
                        );
                    }
                }
            }
            6 | 5 | 18 | 14 | 15 | 16 => {
                if (*section).sh_info != 0 as libc::c_int as libc::c_uint {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"[%2u]: Unexpected value (%u) in info field.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        (*section).sh_info,
                    );
                }
            }
            17 | 2 | 11 => {}
            _ => {
                if !((*section).sh_type == 8 as libc::c_int as libc::c_uint) {
                    if (*section).sh_flags
                        & ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong != 0
                    {
                        if (*section).sh_info < 1 as libc::c_int as libc::c_uint
                            || (*section).sh_info >= (*filedata).file_header.e_shnum
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"[%2u]: Expected link to another section in info field\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                i,
                            );
                        }
                    } else if (*section).sh_type
                        < 0x60000000 as libc::c_int as libc::c_uint
                        && (*section).sh_flags
                            & 0x1000000 as libc::c_int as libc::c_ulong
                            == 0 as libc::c_int as libc::c_ulong
                        && (*section).sh_info != 0 as libc::c_int as libc::c_uint
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"[%2u]: Unexpected value (%u) in info field.\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            i,
                            (*section).sh_info,
                        );
                    }
                }
            }
        }
        if (*section).sh_size > (*filedata).file_size
            && (*section).sh_type != 8 as libc::c_int as libc::c_uint
            && (*section).sh_type != 0 as libc::c_int as libc::c_uint
            && (*section).sh_type < 0x60000000 as libc::c_int as libc::c_uint
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Size of section %u is larger than the entire file!\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                i,
            );
        }
        printf(b"  [%2u] \0" as *const u8 as *const libc::c_char, i);
        if do_section_details {
            printf(
                b"%s\n      \0" as *const u8 as *const libc::c_char,
                printable_section_name(filedata, section),
            );
        } else {
            print_symbol(
                -(17 as libc::c_int),
                if section.is_null() {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<none>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                } else if ((*filedata).string_table).is_null() {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<no-strings>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                } else if (*section).sh_name as libc::c_ulong
                    >= (*filedata).string_table_length
                {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                } else {
                    ((*filedata).string_table).offset((*section).sh_name as isize)
                },
            );
        }
        printf(
            if do_wide != 0 {
                b" %-15s \0" as *const u8 as *const libc::c_char
            } else {
                b" %-15.15s \0" as *const u8 as *const libc::c_char
            },
            get_section_type_name(filedata, (*section).sh_type),
        );
        if is_32bit_elf {
            let mut link_too_big: *const libc::c_char = 0 as *const libc::c_char;
            print_vma((*section).sh_addr, LONG_HEX);
            printf(
                b" %6.6lx %6.6lx %2.2lx\0" as *const u8 as *const libc::c_char,
                (*section).sh_offset as libc::c_ulong,
                (*section).sh_size,
                (*section).sh_entsize,
            );
            if do_section_details {
                fputs(b"  \0" as *const u8 as *const libc::c_char, stdout);
            } else {
                printf(
                    b" %3s \0" as *const u8 as *const libc::c_char,
                    get_elf_section_flags(filedata, (*section).sh_flags),
                );
            }
            if (*section).sh_link >= (*filedata).file_header.e_shnum {
                link_too_big = b"\0" as *const u8 as *const libc::c_char;
                match (*filedata).file_header.e_machine as libc::c_int {
                    3 | 6 | 62 | 180 | 181 | 11 | 18 | 43 | 2 => {
                        if (*section).sh_link
                            == (0x100 as libc::c_uint).wrapping_neg()
                                & 0xffff as libc::c_int as libc::c_uint
                        {
                            link_too_big = b"BEFORE\0" as *const u8
                                as *const libc::c_char;
                        } else if (*section).sh_link
                            == (0x100 as libc::c_uint)
                                .wrapping_neg()
                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                & 0xffff as libc::c_int as libc::c_uint
                        {
                            link_too_big = b"AFTER\0" as *const u8
                                as *const libc::c_char;
                        }
                    }
                    _ => {}
                }
            }
            if do_section_details {
                if !link_too_big.is_null() && *link_too_big as libc::c_int != 0 {
                    printf(b"<%s> \0" as *const u8 as *const libc::c_char, link_too_big);
                } else {
                    printf(
                        b"%2u \0" as *const u8 as *const libc::c_char,
                        (*section).sh_link,
                    );
                }
                printf(
                    b"%3u %2lu\n\0" as *const u8 as *const libc::c_char,
                    (*section).sh_info,
                    (*section).sh_addralign,
                );
            } else {
                printf(
                    b"%2u %3u %2lu\n\0" as *const u8 as *const libc::c_char,
                    (*section).sh_link,
                    (*section).sh_info,
                    (*section).sh_addralign,
                );
            }
            if !link_too_big.is_null() && *link_too_big == 0 {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"section %u: sh_link value of %u is larger than the number of sections\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    i,
                    (*section).sh_link,
                );
            }
        } else if do_wide != 0 {
            print_vma((*section).sh_addr, LONG_HEX);
            if (*section).sh_offset == (*section).sh_offset {
                printf(
                    b" %6.6lx\0" as *const u8 as *const libc::c_char,
                    (*section).sh_offset as libc::c_ulong,
                );
            } else {
                putchar(' ' as i32);
                print_vma((*section).sh_offset as bfd_vma, LONG_HEX);
            }
            if (*section).sh_size == (*section).sh_size {
                printf(
                    b" %6.6lx\0" as *const u8 as *const libc::c_char,
                    (*section).sh_size,
                );
            } else {
                putchar(' ' as i32);
                print_vma((*section).sh_size, LONG_HEX);
            }
            if (*section).sh_entsize == (*section).sh_entsize {
                printf(
                    b" %2.2lx\0" as *const u8 as *const libc::c_char,
                    (*section).sh_entsize,
                );
            } else {
                putchar(' ' as i32);
                print_vma((*section).sh_entsize, LONG_HEX);
            }
            if do_section_details {
                fputs(b"  \0" as *const u8 as *const libc::c_char, stdout);
            } else {
                printf(
                    b" %3s \0" as *const u8 as *const libc::c_char,
                    get_elf_section_flags(filedata, (*section).sh_flags),
                );
            }
            printf(
                b"%2u %3u \0" as *const u8 as *const libc::c_char,
                (*section).sh_link,
                (*section).sh_info,
            );
            if (*section).sh_addralign == (*section).sh_addralign {
                printf(
                    b"%2lu\n\0" as *const u8 as *const libc::c_char,
                    (*section).sh_addralign,
                );
            } else {
                print_vma((*section).sh_addralign, DEC);
                putchar('\n' as i32);
            }
        } else if do_section_details {
            putchar(' ' as i32);
            print_vma((*section).sh_addr, LONG_HEX);
            if (*section).sh_offset == (*section).sh_offset {
                printf(
                    b"  %16.16lx\0" as *const u8 as *const libc::c_char,
                    (*section).sh_offset as libc::c_ulong,
                );
            } else {
                printf(b"  \0" as *const u8 as *const libc::c_char);
                print_vma((*section).sh_offset as bfd_vma, LONG_HEX);
            }
            printf(
                b"  %u\n       \0" as *const u8 as *const libc::c_char,
                (*section).sh_link,
            );
            print_vma((*section).sh_size, LONG_HEX);
            putchar(' ' as i32);
            print_vma((*section).sh_entsize, LONG_HEX);
            printf(
                b"  %-16u  %lu\n\0" as *const u8 as *const libc::c_char,
                (*section).sh_info,
                (*section).sh_addralign,
            );
        } else {
            putchar(' ' as i32);
            print_vma((*section).sh_addr, LONG_HEX);
            if (*section).sh_offset == (*section).sh_offset {
                printf(
                    b"  %8.8lx\0" as *const u8 as *const libc::c_char,
                    (*section).sh_offset as libc::c_ulong,
                );
            } else {
                printf(b"  \0" as *const u8 as *const libc::c_char);
                print_vma((*section).sh_offset as bfd_vma, LONG_HEX);
            }
            printf(b"\n       \0" as *const u8 as *const libc::c_char);
            print_vma((*section).sh_size, LONG_HEX);
            printf(b"  \0" as *const u8 as *const libc::c_char);
            print_vma((*section).sh_entsize, LONG_HEX);
            printf(
                b" %3s \0" as *const u8 as *const libc::c_char,
                get_elf_section_flags(filedata, (*section).sh_flags),
            );
            printf(
                b"     %2u   %3u     %lu\n\0" as *const u8 as *const libc::c_char,
                (*section).sh_link,
                (*section).sh_info,
                (*section).sh_addralign,
            );
        }
        if do_section_details {
            printf(
                b"       %s\n\0" as *const u8 as *const libc::c_char,
                get_elf_section_flags(filedata, (*section).sh_flags),
            );
            if (*section).sh_flags
                & ((1 as libc::c_int) << 11 as libc::c_int) as libc::c_ulong
                != 0 as libc::c_int as libc::c_ulong
            {
                let mut buf_4: [libc::c_uchar; 24] = [0; 24];
                if ::core::mem::size_of::<[libc::c_uchar; 24]>() as libc::c_ulong
                    >= ::core::mem::size_of::<Elf64_External_Chdr>() as libc::c_ulong
                {} else {
                    __assert_fail(
                        b"sizeof (buf) >= sizeof (Elf64_External_Chdr)\0" as *const u8
                            as *const libc::c_char,
                        b"readelf.c\0" as *const u8 as *const libc::c_char,
                        7192 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 42],
                            &[libc::c_char; 42],
                        >(b"_Bool process_section_headers(Filedata *)\0"))
                            .as_ptr(),
                    );
                }
                'c_81366: {
                    if ::core::mem::size_of::<[libc::c_uchar; 24]>() as libc::c_ulong
                        >= ::core::mem::size_of::<Elf64_External_Chdr>() as libc::c_ulong
                    {} else {
                        __assert_fail(
                            b"sizeof (buf) >= sizeof (Elf64_External_Chdr)\0"
                                as *const u8 as *const libc::c_char,
                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                            7192 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 42],
                                &[libc::c_char; 42],
                            >(b"_Bool process_section_headers(Filedata *)\0"))
                                .as_ptr(),
                        );
                    }
                };
                if !(get_data(
                    &mut buf_4 as *mut [libc::c_uchar; 24] as *mut libc::c_void,
                    filedata,
                    (*section).sh_offset as libc::c_ulong,
                    1 as libc::c_int as bfd_size_type,
                    ::core::mem::size_of::<[libc::c_uchar; 24]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"compression header\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                ))
                    .is_null()
                {
                    let mut chdr: Elf_Internal_Chdr = Elf_Internal_Chdr {
                        ch_type: 0,
                        ch_size: 0,
                        ch_addralign: 0,
                    };
                    if get_compression_header(
                        &mut chdr,
                        buf_4.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 24]>() as libc::c_ulong,
                    ) == 0 as libc::c_int as libc::c_uint
                    {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"       [<corrupt>]\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        if chdr.ch_type == 1 as libc::c_int as libc::c_uint {
                            printf(
                                b"       ZLIB, \0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"       [<unknown>: 0x%x], \0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                chdr.ch_type,
                            );
                        }
                        print_vma(chdr.ch_size, LONG_HEX);
                        printf(
                            b", %lu\n\0" as *const u8 as *const libc::c_char,
                            chdr.ch_addralign,
                        );
                    }
                }
            }
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    if !do_section_details {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  \0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        let mut current_block_273: u64;
        match (*filedata).file_header.e_ident[7 as libc::c_int as usize] as libc::c_int {
            3 | 9 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"R (retain), \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                current_block_273 = 8473230586835025397;
            }
            0 => {
                current_block_273 = 8473230586835025397;
            }
            _ => {
                current_block_273 = 15319172335895842423;
            }
        }
        match current_block_273 {
            8473230586835025397 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"D (mbind), \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            _ => {}
        }
        if (*filedata).file_header.e_machine as libc::c_int == 62 as libc::c_int
            || (*filedata).file_header.e_machine as libc::c_int == 180 as libc::c_int
            || (*filedata).file_header.e_machine as libc::c_int == 181 as libc::c_int
        {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"l (large), \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else if (*filedata).file_header.e_machine as libc::c_int == 40 as libc::c_int {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"y (purecode), \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else if (*filedata).file_header.e_machine as libc::c_int == 20 as libc::c_int {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"v (VLE), \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        printf(b"p (processor specific)\n\0" as *const u8 as *const libc::c_char);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_symtab(
    mut filedata: *mut Filedata,
    mut symsec: *mut Elf_Internal_Shdr,
    mut symtab: *mut *mut Elf_Internal_Sym,
    mut nsyms: *mut libc::c_ulong,
    mut strtab: *mut *mut libc::c_char,
    mut strtablen: *mut libc::c_ulong,
) -> bool {
    *strtab = 0 as *mut libc::c_char;
    *strtablen = 0 as libc::c_int as libc::c_ulong;
    *symtab = get_elf_symbols(filedata, symsec, nsyms);
    if (*symtab).is_null() {
        return 0 as libc::c_int != 0;
    }
    if (*symsec).sh_link != 0 as libc::c_int as libc::c_uint {
        let mut strsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        if (*symsec).sh_link >= (*filedata).file_header.e_shnum {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Bad sh_link in symbol table section\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            free(*symtab as *mut libc::c_void);
            *symtab = 0 as *mut Elf_Internal_Sym;
            *nsyms = 0 as libc::c_int as libc::c_ulong;
            return 0 as libc::c_int != 0;
        }
        strsec = ((*filedata).section_headers).offset((*symsec).sh_link as isize);
        *strtab = get_data(
            0 as *mut libc::c_void,
            filedata,
            (*strsec).sh_offset as libc::c_ulong,
            1 as libc::c_int as bfd_size_type,
            (*strsec).sh_size,
            dcgettext(
                0 as *const libc::c_char,
                b"string table\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        ) as *mut libc::c_char;
        if (*strtab).is_null() {
            free(*symtab as *mut libc::c_void);
            *symtab = 0 as *mut Elf_Internal_Sym;
            *nsyms = 0 as libc::c_int as libc::c_ulong;
            return 0 as libc::c_int != 0;
        }
        *strtablen = (*strsec).sh_size;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_group_flags(mut flags_0: libc::c_uint) -> *const libc::c_char {
    static mut buff: [libc::c_char; 128] = [0; 128];
    if flags_0 == 0 as libc::c_int as libc::c_uint {
        return b"\0" as *const u8 as *const libc::c_char
    } else if flags_0 == 0x1 as libc::c_int as libc::c_uint {
        return b"COMDAT \0" as *const u8 as *const libc::c_char
    }
    snprintf(
        buff.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
        b"[0x%x: %s%s%s]\0" as *const u8 as *const libc::c_char,
        flags_0,
        if flags_0 & 0xff00000 as libc::c_int as libc::c_uint != 0 {
            dcgettext(
                0 as *const libc::c_char,
                b"<OS specific>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ) as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
        if flags_0 & 0xf0000000 as libc::c_uint != 0 {
            dcgettext(
                0 as *const libc::c_char,
                b"<PROC specific>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ) as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
        if flags_0
            & !((0x1 as libc::c_int | 0xff00000 as libc::c_int) as libc::c_uint
                | 0xf0000000 as libc::c_uint) != 0
        {
            dcgettext(
                0 as *const libc::c_char,
                b"<unknown>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ) as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
    );
    return buff.as_mut_ptr();
}
unsafe extern "C" fn process_section_groups(mut filedata: *mut Filedata) -> bool {
    let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_uint = 0;
    let mut group: *mut group = 0 as *mut group;
    let mut symtab_sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut strtab_sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symtab: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut num_syms: libc::c_ulong = 0;
    let mut strtab: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut strtab_size: size_t = 0;
    if !do_unwind && !do_section_groups {
        return 1 as libc::c_int != 0;
    }
    if (*filedata).file_header.e_shnum == 0 as libc::c_int as libc::c_uint {
        if do_section_groups {
            if (*filedata).is_separate {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere are no sections group in linked file '%s'.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_name,
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere are no section groups in this file.\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
        }
        return 1 as libc::c_int != 0;
    }
    if ((*filedata).section_headers).is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Section headers are not available!\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    (*filedata)
        .section_headers_groups = calloc(
        (*filedata).file_header.e_shnum as libc::c_ulong,
        ::core::mem::size_of::<*mut group>() as libc::c_ulong,
    ) as *mut *mut group;
    if ((*filedata).section_headers_groups).is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory reading %u section group headers\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_header.e_shnum,
        );
        return 0 as libc::c_int != 0;
    }
    (*filedata).group_count = 0 as libc::c_int as size_t;
    i = 0 as libc::c_int as libc::c_uint;
    section = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum {
        if (*section).sh_type == 17 as libc::c_int as libc::c_uint {
            (*filedata).group_count = ((*filedata).group_count).wrapping_add(1);
            (*filedata).group_count;
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    if (*filedata).group_count == 0 as libc::c_int as libc::c_ulong {
        if do_section_groups {
            if (*filedata).is_separate {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere are no section groups in linked file '%s'.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_name,
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere are no section groups in this file.\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
        }
        return 1 as libc::c_int != 0;
    }
    (*filedata)
        .section_groups = calloc(
        (*filedata).group_count,
        ::core::mem::size_of::<group>() as libc::c_ulong,
    ) as *mut group;
    if ((*filedata).section_groups).is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory reading %lu groups\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).group_count,
        );
        return 0 as libc::c_int != 0;
    }
    symtab_sec = 0 as *mut Elf_Internal_Shdr;
    strtab_sec = 0 as *mut Elf_Internal_Shdr;
    symtab = 0 as *mut Elf_Internal_Sym;
    num_syms = 0 as libc::c_int as libc::c_ulong;
    strtab = 0 as *mut libc::c_char;
    strtab_size = 0 as libc::c_int as size_t;
    if (*filedata).is_separate {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Section groups in linked file '%s'\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_name,
        );
    }
    let mut current_block_115: u64;
    i = 0 as libc::c_int as libc::c_uint;
    section = (*filedata).section_headers;
    group = (*filedata).section_groups;
    while i < (*filedata).file_header.e_shnum {
        if (*section).sh_type == 17 as libc::c_int as libc::c_uint {
            let mut name: *const libc::c_char = printable_section_name(
                filedata,
                section,
            );
            let mut group_name: *const libc::c_char = 0 as *const libc::c_char;
            let mut start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut indices: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut entry: libc::c_uint = 0;
            let mut j: libc::c_uint = 0;
            let mut size: libc::c_uint = 0;
            let mut sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
            let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
            if (*section).sh_link >= (*filedata).file_header.e_shnum
                || {
                    sec = ((*filedata).section_headers)
                        .offset((*section).sh_link as isize);
                    (*sec).sh_type != 2 as libc::c_int as libc::c_uint
                }
            {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Bad sh_link in group section `%s'\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    name,
                );
            } else {
                if symtab_sec != sec {
                    symtab_sec = sec;
                    free(symtab as *mut libc::c_void);
                    symtab = get_elf_symbols(filedata, symtab_sec, &mut num_syms);
                }
                if symtab.is_null() {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Corrupt header in group section `%s'\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        name,
                    );
                } else if (*section).sh_info as libc::c_ulong >= num_syms {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Bad sh_info in group section `%s'\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        name,
                    );
                } else {
                    sym = symtab.offset((*section).sh_info as isize);
                    if (*sym).st_info as libc::c_int & 0xf as libc::c_int
                        == 3 as libc::c_int
                    {
                        if (*sym).st_shndx == 0 as libc::c_int as libc::c_uint
                            || (*sym).st_shndx >= (*filedata).file_header.e_shnum
                        {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Bad sh_info in group section `%s'\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                name,
                            );
                            current_block_115 = 6450636197030046351;
                        } else {
                            group_name = if ((*filedata).section_headers)
                                .offset((*sym).st_shndx as isize)
                                .is_null()
                            {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<none>\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            } else if ((*filedata).string_table).is_null() {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<no-strings>\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            } else if (*((*filedata).section_headers)
                                .offset((*sym).st_shndx as isize))
                                .sh_name as libc::c_ulong >= (*filedata).string_table_length
                            {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<corrupt>\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            } else {
                                ((*filedata).string_table)
                                    .offset(
                                        (*((*filedata).section_headers)
                                            .offset((*sym).st_shndx as isize))
                                            .sh_name as isize,
                                    )
                            };
                            strtab_sec = 0 as *mut Elf_Internal_Shdr;
                            free(strtab as *mut libc::c_void);
                            strtab = 0 as *mut libc::c_char;
                            strtab_size = 0 as libc::c_int as size_t;
                            current_block_115 = 5028470053297453708;
                        }
                    } else {
                        if (*symtab_sec).sh_link >= (*filedata).file_header.e_shnum {
                            strtab_sec = 0 as *mut Elf_Internal_Shdr;
                            free(strtab as *mut libc::c_void);
                            strtab = 0 as *mut libc::c_char;
                            strtab_size = 0 as libc::c_int as size_t;
                        } else {
                            sec = ((*filedata).section_headers)
                                .offset((*symtab_sec).sh_link as isize);
                            if strtab_sec != sec {
                                strtab_sec = sec;
                                free(strtab as *mut libc::c_void);
                                strtab = get_data(
                                    0 as *mut libc::c_void,
                                    filedata,
                                    (*strtab_sec).sh_offset as libc::c_ulong,
                                    1 as libc::c_int as bfd_size_type,
                                    (*strtab_sec).sh_size,
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"string table\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                ) as *mut libc::c_char;
                                strtab_size = if !strtab.is_null() {
                                    (*strtab_sec).sh_size
                                } else {
                                    0 as libc::c_int as libc::c_ulong
                                };
                            }
                        }
                        group_name = if (*sym).st_name < strtab_size {
                            strtab.offset((*sym).st_name as isize)
                        } else {
                            dcgettext(
                                0 as *const libc::c_char,
                                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            )
                        };
                        current_block_115 = 5028470053297453708;
                    }
                    match current_block_115 {
                        6450636197030046351 => {}
                        _ => {
                            if (*section).sh_entsize > (*section).sh_size {
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Section %s has sh_entsize (0x%lx) which is larger than its size (0x%lx)\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    printable_section_name(filedata, section),
                                    (*section).sh_entsize,
                                    (*section).sh_size,
                                );
                            } else {
                                start = get_data(
                                    0 as *mut libc::c_void,
                                    filedata,
                                    (*section).sh_offset as libc::c_ulong,
                                    1 as libc::c_int as bfd_size_type,
                                    (*section).sh_size,
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"section data\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                ) as *mut libc::c_uchar;
                                if !start.is_null() {
                                    indices = start;
                                    size = ((*section).sh_size)
                                        .wrapping_div((*section).sh_entsize)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                        as libc::c_uint;
                                    entry = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(indices, 4 as libc::c_int as libc::c_uint)
                                        as libc::c_uint;
                                    indices = indices.offset(4 as libc::c_int as isize);
                                    if do_section_groups {
                                        printf(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            get_group_flags(entry),
                                            i,
                                            name,
                                            group_name,
                                            size,
                                        );
                                        printf(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"   [Index]    Name\n\0" as *const u8
                                                    as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                        );
                                    }
                                    (*group).group_index = i;
                                    let mut current_block_112: u64;
                                    j = 0 as libc::c_int as libc::c_uint;
                                    while j < size {
                                        let mut g: *mut group_list = 0 as *mut group_list;
                                        entry = byte_get
                                            .expect(
                                                "non-null function pointer",
                                            )(indices, 4 as libc::c_int as libc::c_uint)
                                            as libc::c_uint;
                                        indices = indices.offset(4 as libc::c_int as isize);
                                        if entry >= (*filedata).file_header.e_shnum {
                                            static mut num_group_errors: libc::c_uint = 0 as libc::c_int
                                                as libc::c_uint;
                                            let fresh20 = num_group_errors;
                                            num_group_errors = num_group_errors.wrapping_add(1);
                                            if fresh20 < 10 as libc::c_int as libc::c_uint {
                                                error(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"section [%5u] in group section [%5u] > maximum section [%5u]\n\0"
                                                            as *const u8 as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    entry,
                                                    i,
                                                    ((*filedata).file_header.e_shnum)
                                                        .wrapping_sub(1 as libc::c_int as libc::c_uint),
                                                );
                                                if num_group_errors == 10 as libc::c_int as libc::c_uint {
                                                    warn(
                                                        dcgettext(
                                                            0 as *const libc::c_char,
                                                            b"Further error messages about overlarge group section indices suppressed\n\0"
                                                                as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                    );
                                                }
                                            }
                                        } else {
                                            if !(*((*filedata).section_headers_groups)
                                                .offset(entry as isize))
                                                .is_null()
                                            {
                                                if entry != 0 {
                                                    static mut num_errs: libc::c_uint = 0 as libc::c_int
                                                        as libc::c_uint;
                                                    let fresh21 = num_errs;
                                                    num_errs = num_errs.wrapping_add(1);
                                                    if fresh21 < 10 as libc::c_int as libc::c_uint {
                                                        error(
                                                            dcgettext(
                                                                0 as *const libc::c_char,
                                                                b"section [%5u] in group section [%5u] already in group section [%5u]\n\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                5 as libc::c_int,
                                                            ),
                                                            entry,
                                                            i,
                                                            (**((*filedata).section_headers_groups)
                                                                .offset(entry as isize))
                                                                .group_index,
                                                        );
                                                        if num_errs == 10 as libc::c_int as libc::c_uint {
                                                            warn(
                                                                dcgettext(
                                                                    0 as *const libc::c_char,
                                                                    b"Further error messages about already contained group sections suppressed\n\0"
                                                                        as *const u8 as *const libc::c_char,
                                                                    5 as libc::c_int,
                                                                ),
                                                            );
                                                        }
                                                    }
                                                    current_block_112 = 479107131381816815;
                                                } else {
                                                    static mut warned: bool = 0 as libc::c_int != 0;
                                                    if !warned {
                                                        error(
                                                            dcgettext(
                                                                0 as *const libc::c_char,
                                                                b"section 0 in group section [%5u]\n\0" as *const u8
                                                                    as *const libc::c_char,
                                                                5 as libc::c_int,
                                                            ),
                                                            (**((*filedata).section_headers_groups)
                                                                .offset(entry as isize))
                                                                .group_index,
                                                        );
                                                        warned = 1 as libc::c_int != 0;
                                                    }
                                                    current_block_112 = 14865402277128115059;
                                                }
                                            } else {
                                                current_block_112 = 14865402277128115059;
                                            }
                                            match current_block_112 {
                                                479107131381816815 => {}
                                                _ => {
                                                    let ref mut fresh22 = *((*filedata).section_headers_groups)
                                                        .offset(entry as isize);
                                                    *fresh22 = group;
                                                    if do_section_groups {
                                                        sec = ((*filedata).section_headers).offset(entry as isize);
                                                        printf(
                                                            b"   [%5u]   %s\n\0" as *const u8 as *const libc::c_char,
                                                            entry,
                                                            printable_section_name(filedata, sec),
                                                        );
                                                    }
                                                    g = xmalloc(
                                                        ::core::mem::size_of::<group_list>() as libc::c_ulong,
                                                    ) as *mut group_list;
                                                    (*g).section_index = entry;
                                                    (*g).next = (*group).root;
                                                    (*group).root = g;
                                                }
                                            }
                                        }
                                        j = j.wrapping_add(1);
                                        j;
                                    }
                                    free(start as *mut libc::c_void);
                                    group = group.offset(1);
                                    group;
                                }
                            }
                        }
                    }
                }
            }
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    free(symtab as *mut libc::c_void);
    free(strtab as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn dump_ia64_vms_dynamic_fixups(
    mut filedata: *mut Filedata,
    mut fixup: *mut ia64_vms_dynfixup,
    mut strtab: *const libc::c_char,
    mut strtab_sz: libc::c_uint,
) -> bool {
    let mut imfs: *mut Elf64_External_VMS_IMAGE_FIXUP = 0
        as *mut Elf64_External_VMS_IMAGE_FIXUP;
    let mut i: libc::c_long = 0;
    let mut lib_name: *const libc::c_char = 0 as *const libc::c_char;
    imfs = get_data(
        0 as *mut libc::c_void,
        filedata,
        ((*filedata).dynamic_addr).wrapping_add((*fixup).fixup_rela_off),
        ::core::mem::size_of::<Elf64_External_VMS_IMAGE_FIXUP>() as libc::c_ulong,
        (*fixup).fixup_rela_cnt,
        dcgettext(
            0 as *const libc::c_char,
            b"dynamic section image fixups\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut Elf64_External_VMS_IMAGE_FIXUP;
    if imfs.is_null() {
        return 0 as libc::c_int != 0;
    }
    if (*fixup).needed < strtab_sz as libc::c_ulong {
        lib_name = strtab.offset((*fixup).needed as isize);
    } else {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt library name index of 0x%lx found in dynamic entry\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*fixup).needed,
        );
        lib_name = b"???\0" as *const u8 as *const libc::c_char;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\nImage fixups for needed library #%d: %s - ident: %lx\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        (*fixup).fixup_needed as libc::c_int,
        lib_name,
        (*fixup).needed_ident as libc::c_long,
    );
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"Seg Offset           Type                             SymVec DataType\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    i = 0 as libc::c_int as libc::c_long;
    while i < (*fixup).fixup_rela_cnt as libc::c_long {
        let mut type_0: libc::c_uint = 0;
        let mut rtype: *const libc::c_char = 0 as *const libc::c_char;
        printf(
            b"%3u \0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imfs.offset(i as isize)).fixup_seg).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            ) as libc::c_uint,
        );
        fprintf(
            stdout,
            b"%016lx\0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imfs.offset(i as isize)).fixup_offset).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            ),
        );
        type_0 = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*imfs.offset(i as isize)).type_0).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        rtype = elf_ia64_reloc_type(type_0 as libc::c_ulong);
        if rtype.is_null() {
            printf(
                b" 0x%08x                       \0" as *const u8 as *const libc::c_char,
                type_0,
            );
        } else {
            printf(b" %-32s \0" as *const u8 as *const libc::c_char, rtype);
        }
        printf(
            b"%6u \0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imfs.offset(i as isize)).symvec_index).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            ) as libc::c_uint,
        );
        printf(
            b"0x%08x\n\0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imfs.offset(i as isize)).data_type).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            ) as libc::c_uint,
        );
        i += 1;
        i;
    }
    free(imfs as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn dump_ia64_vms_dynamic_relocs(
    mut filedata: *mut Filedata,
    mut imgrela: *mut ia64_vms_dynimgrela,
) -> bool {
    let mut imrs: *mut Elf64_External_VMS_IMAGE_RELA = 0
        as *mut Elf64_External_VMS_IMAGE_RELA;
    let mut i: libc::c_long = 0;
    imrs = get_data(
        0 as *mut libc::c_void,
        filedata,
        ((*filedata).dynamic_addr).wrapping_add((*imgrela).img_rela_off),
        ::core::mem::size_of::<Elf64_External_VMS_IMAGE_RELA>() as libc::c_ulong,
        (*imgrela).img_rela_cnt,
        dcgettext(
            0 as *const libc::c_char,
            b"dynamic section image relocations\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut Elf64_External_VMS_IMAGE_RELA;
    if imrs.is_null() {
        return 0 as libc::c_int != 0;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\nImage relocs\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"Seg Offset   Type                            Addend            Seg Sym Off\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    i = 0 as libc::c_int as libc::c_long;
    while i < (*imgrela).img_rela_cnt as libc::c_long {
        let mut type_0: libc::c_uint = 0;
        let mut rtype: *const libc::c_char = 0 as *const libc::c_char;
        printf(
            b"%3u \0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imrs.offset(i as isize)).rela_seg).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            ) as libc::c_uint,
        );
        printf(
            b"%08lx \0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imrs.offset(i as isize)).rela_offset).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            ),
        );
        type_0 = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*imrs.offset(i as isize)).type_0).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        rtype = elf_ia64_reloc_type(type_0 as libc::c_ulong);
        if rtype.is_null() {
            printf(
                b"0x%08x                      \0" as *const u8 as *const libc::c_char,
                type_0,
            );
        } else {
            printf(b"%-31s \0" as *const u8 as *const libc::c_char, rtype);
        }
        print_vma(
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imrs.offset(i as isize)).addend).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            ),
            FULL_HEX,
        );
        printf(
            b"%3u \0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imrs.offset(i as isize)).sym_seg).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                    as libc::c_uint,
            ) as libc::c_uint,
        );
        printf(
            b"%08lx\n\0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*imrs.offset(i as isize)).sym_offset).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                    as libc::c_uint,
            ),
        );
        i += 1;
        i;
    }
    free(imrs as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn process_ia64_vms_dynamic_relocs(
    mut filedata: *mut Filedata,
) -> bool {
    let mut fixup: ia64_vms_dynfixup = ia64_vms_dynfixup {
        needed_ident: 0,
        needed: 0,
        fixup_needed: 0,
        fixup_rela_cnt: 0,
        fixup_rela_off: 0,
    };
    let mut imgrela: ia64_vms_dynimgrela = ia64_vms_dynimgrela {
        img_rela_cnt: 0,
        img_rela_off: 0,
    };
    let mut entry: *mut Elf_Internal_Dyn = 0 as *mut Elf_Internal_Dyn;
    let mut strtab_off: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut strtab_sz: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut strtab: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut res: bool = 1 as libc::c_int != 0;
    memset(
        &mut fixup as *mut ia64_vms_dynfixup as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ia64_vms_dynfixup>() as libc::c_ulong,
    );
    memset(
        &mut imgrela as *mut ia64_vms_dynimgrela as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ia64_vms_dynimgrela>() as libc::c_ulong,
    );
    entry = (*filedata).dynamic_section;
    while entry < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
    {
        match (*entry).d_tag {
            1610612801 => {
                strtab_off = (*entry).d_un.d_val;
            }
            10 => {
                strtab_sz = (*entry).d_un.d_val;
                if strtab.is_null() {
                    strtab = get_data(
                        0 as *mut libc::c_void,
                        filedata,
                        ((*filedata).dynamic_addr).wrapping_add(strtab_off),
                        1 as libc::c_int as bfd_size_type,
                        strtab_sz,
                        dcgettext(
                            0 as *const libc::c_char,
                            b"dynamic string section\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    ) as *mut libc::c_char;
                }
                if strtab.is_null() {
                    strtab_sz = 0 as libc::c_int as bfd_vma;
                }
            }
            1610612765 => {
                fixup.needed_ident = (*entry).d_un.d_val;
            }
            1 => {
                fixup.needed = (*entry).d_un.d_val;
            }
            1610612773 => {
                fixup.fixup_needed = (*entry).d_un.d_val;
            }
            1610612771 => {
                fixup.fixup_rela_cnt = (*entry).d_un.d_val;
            }
            1610612809 => {
                fixup.fixup_rela_off = (*entry).d_un.d_val;
                if !dump_ia64_vms_dynamic_fixups(
                    filedata,
                    &mut fixup,
                    strtab,
                    strtab_sz as libc::c_uint,
                ) {
                    res = 0 as libc::c_int != 0;
                }
            }
            1610612767 => {
                imgrela.img_rela_cnt = (*entry).d_un.d_val;
            }
            1610612805 => {
                imgrela.img_rela_off = (*entry).d_un.d_val;
                if !dump_ia64_vms_dynamic_relocs(filedata, &mut imgrela) {
                    res = 0 as libc::c_int != 0;
                }
            }
            _ => {}
        }
        entry = entry.offset(1);
        entry;
    }
    free(strtab as *mut libc::c_void);
    return res;
}
static mut dynamic_relocations: [C2RustUnnamed_29; 3] = [
    {
        let mut init = C2RustUnnamed_29 {
            name: b"REL\0" as *const u8 as *const libc::c_char,
            reloc: 17 as libc::c_int,
            size: 18 as libc::c_int,
            rela: 0 as libc::c_int,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            name: b"RELA\0" as *const u8 as *const libc::c_char,
            reloc: 7 as libc::c_int,
            size: 8 as libc::c_int,
            rela: 1 as libc::c_int,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_29 {
            name: b"PLT\0" as *const u8 as *const libc::c_char,
            reloc: 23 as libc::c_int,
            size: 2 as libc::c_int,
            rela: -(1 as libc::c_int),
        };
        init
    },
];
unsafe extern "C" fn process_relocs(mut filedata: *mut Filedata) -> bool {
    let mut rel_size: libc::c_ulong = 0;
    let mut rel_offset: libc::c_ulong = 0;
    if !do_reloc {
        return 1 as libc::c_int != 0;
    }
    if do_using_dynamic {
        let mut is_rela: libc::c_int = 0;
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        let mut has_dynamic_reloc: bool = false;
        let mut i: libc::c_uint = 0;
        has_dynamic_reloc = 0 as libc::c_int != 0;
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong)
            < (::core::mem::size_of::<[C2RustUnnamed_29; 3]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<C2RustUnnamed_29>() as libc::c_ulong,
                )
        {
            is_rela = dynamic_relocations[i as usize].rela;
            name = dynamic_relocations[i as usize].name;
            rel_size = (*filedata)
                .dynamic_info[dynamic_relocations[i as usize].size as usize];
            rel_offset = (*filedata)
                .dynamic_info[dynamic_relocations[i as usize].reloc as usize];
            if rel_size != 0 {
                has_dynamic_reloc = 1 as libc::c_int != 0;
            }
            if is_rela == -(1 as libc::c_int) {
                if dynamic_relocations[i as usize].reloc == 23 as libc::c_int {
                    match (*filedata).dynamic_info[20 as libc::c_int as usize] {
                        17 => {
                            is_rela = 0 as libc::c_int;
                        }
                        7 => {
                            is_rela = 1 as libc::c_int;
                        }
                        _ => {}
                    }
                }
            }
            if rel_size != 0 {
                if (*filedata).is_separate {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\nIn linked file '%s' section '%s' at offset 0x%lx contains %ld bytes:\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*filedata).file_name,
                        name,
                        rel_offset,
                        rel_size,
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        name,
                        rel_offset,
                        rel_size,
                    );
                }
                dump_relocations(
                    filedata,
                    offset_from_vma(filedata, rel_offset, rel_size) as libc::c_ulong,
                    rel_size,
                    (*filedata).dynamic_symbols,
                    (*filedata).num_dynamic_syms,
                    (*filedata).dynamic_strings,
                    (*filedata).dynamic_strings_length,
                    is_rela,
                    1 as libc::c_int != 0,
                );
            }
            i = i.wrapping_add(1);
            i;
        }
        if is_ia64_vms(filedata) {
            if process_ia64_vms_dynamic_relocs(filedata) {
                has_dynamic_reloc = 1 as libc::c_int != 0;
            }
        }
        if !has_dynamic_reloc {
            if (*filedata).is_separate {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere are no dynamic relocations in linked file '%s'.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_name,
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere are no dynamic relocations in this file.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
        }
    } else {
        let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut i_0: libc::c_ulong = 0;
        let mut found: bool = 0 as libc::c_int != 0;
        let mut current_block_50: u64;
        i_0 = 0 as libc::c_int as libc::c_ulong;
        section = (*filedata).section_headers;
        while i_0 < (*filedata).file_header.e_shnum as libc::c_ulong {
            if !((*section).sh_type != 4 as libc::c_int as libc::c_uint
                && (*section).sh_type != 9 as libc::c_int as libc::c_uint)
            {
                rel_offset = (*section).sh_offset as libc::c_ulong;
                rel_size = (*section).sh_size;
                if rel_size != 0 {
                    let mut is_rela_0: libc::c_int = 0;
                    let mut num_rela: libc::c_ulong = 0;
                    if (*filedata).is_separate {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\nIn linked file '%s' relocation section \0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*filedata).file_name,
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\nRelocation section \0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    if ((*filedata).string_table).is_null() {
                        printf(
                            b"%d\0" as *const u8 as *const libc::c_char,
                            (*section).sh_name,
                        );
                    } else {
                        printf(
                            b"'%s'\0" as *const u8 as *const libc::c_char,
                            printable_section_name(filedata, section),
                        );
                    }
                    num_rela = rel_size.wrapping_div((*section).sh_entsize);
                    printf(
                        dcngettext(
                            0 as *const libc::c_char,
                            b" at offset 0x%lx contains %lu entry:\n\0" as *const u8
                                as *const libc::c_char,
                            b" at offset 0x%lx contains %lu entries:\n\0" as *const u8
                                as *const libc::c_char,
                            num_rela,
                            5 as libc::c_int,
                        ),
                        rel_offset,
                        num_rela,
                    );
                    is_rela_0 = ((*section).sh_type == 4 as libc::c_int as libc::c_uint)
                        as libc::c_int;
                    if (*section).sh_link != 0 as libc::c_int as libc::c_uint
                        && (*section).sh_link < (*filedata).file_header.e_shnum
                    {
                        let mut symsec: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut symtab: *mut Elf_Internal_Sym = 0
                            as *mut Elf_Internal_Sym;
                        let mut nsyms: libc::c_ulong = 0;
                        let mut strtablen: libc::c_ulong = 0 as libc::c_int
                            as libc::c_ulong;
                        let mut strtab: *mut libc::c_char = 0 as *mut libc::c_char;
                        symsec = ((*filedata).section_headers)
                            .offset((*section).sh_link as isize);
                        if (*symsec).sh_type != 2 as libc::c_int as libc::c_uint
                            && (*symsec).sh_type != 11 as libc::c_int as libc::c_uint
                        {
                            current_block_50 = 17500079516916021833;
                        } else if !get_symtab(
                            filedata,
                            symsec,
                            &mut symtab,
                            &mut nsyms,
                            &mut strtab,
                            &mut strtablen,
                        ) {
                            current_block_50 = 17500079516916021833;
                        } else {
                            dump_relocations(
                                filedata,
                                rel_offset,
                                rel_size,
                                symtab,
                                nsyms,
                                strtab,
                                strtablen,
                                is_rela_0,
                                (*symsec).sh_type == 11 as libc::c_int as libc::c_uint,
                            );
                            free(strtab as *mut libc::c_void);
                            free(symtab as *mut libc::c_void);
                            current_block_50 = 13826291924415791078;
                        }
                    } else {
                        dump_relocations(
                            filedata,
                            rel_offset,
                            rel_size,
                            0 as *mut Elf_Internal_Sym,
                            0 as libc::c_int as libc::c_ulong,
                            0 as *mut libc::c_char,
                            0 as libc::c_int as libc::c_ulong,
                            is_rela_0,
                            0 as libc::c_int != 0,
                        );
                        current_block_50 = 13826291924415791078;
                    }
                    match current_block_50 {
                        17500079516916021833 => {}
                        _ => {
                            found = 1 as libc::c_int != 0;
                        }
                    }
                }
            }
            i_0 = i_0.wrapping_add(1);
            i_0;
            section = section.offset(1);
            section;
        }
        if !found {
            i_0 = 0 as libc::c_int as libc::c_ulong;
            while i_0
                < (::core::mem::size_of::<[C2RustUnnamed_29; 3]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_29>() as libc::c_ulong,
                    )
            {
                if (*filedata)
                    .dynamic_info[dynamic_relocations[i_0 as usize].size as usize] != 0
                {
                    if (*filedata).is_separate {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\nThere are no static relocations in linked file '%s'.\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*filedata).file_name,
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\nThere are no static relocations in this file.\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\nTo see the dynamic relocations add --use-dynamic to the command line.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    break;
                } else {
                    i_0 = i_0.wrapping_add(1);
                    i_0;
                }
            }
            if i_0
                == (::core::mem::size_of::<[C2RustUnnamed_29; 3]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_29>() as libc::c_ulong,
                    )
            {
                if (*filedata).is_separate {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\nThere are no relocations in linked file '%s'.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*filedata).file_name,
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\nThere are no relocations in this file.\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn find_symbol_for_address(
    mut filedata: *mut Filedata,
    mut symtab: *mut Elf_Internal_Sym,
    mut nsyms: libc::c_ulong,
    mut strtab: *const libc::c_char,
    mut strtab_size: libc::c_ulong,
    mut addr: absaddr,
    mut symname: *mut *const libc::c_char,
    mut offset: *mut bfd_vma,
) {
    let mut dist: bfd_vma = 0x100000 as libc::c_int as bfd_vma;
    let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut beg: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut end: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut best: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    if (*filedata).file_header.e_machine as libc::c_int == 40 as libc::c_int {
        addr.offset &= !(1 as libc::c_int) as libc::c_ulong;
    }
    beg = symtab;
    end = symtab.offset(nsyms as isize);
    while beg < end {
        let mut value: bfd_vma = 0;
        sym = beg
            .offset(
                (end.offset_from(beg) as libc::c_long / 2 as libc::c_int as libc::c_long)
                    as isize,
            );
        value = (*sym).st_value;
        if (*filedata).file_header.e_machine as libc::c_int == 40 as libc::c_int {
            value &= !(1 as libc::c_int) as libc::c_ulong;
        }
        if (*sym).st_name != 0 as libc::c_int as libc::c_ulong
            && (addr.section as libc::c_int == 0 as libc::c_int
                || addr.section as libc::c_uint == (*sym).st_shndx)
            && addr.offset >= value && (addr.offset).wrapping_sub(value) < dist
        {
            best = sym;
            dist = (addr.offset).wrapping_sub(value);
            if dist == 0 {
                break;
            }
        }
        if addr.offset < value {
            end = sym;
        } else {
            beg = sym.offset(1 as libc::c_int as isize);
        }
    }
    if !best.is_null() {
        *symname = if (*best).st_name >= strtab_size {
            dcgettext(
                0 as *const libc::c_char,
                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ) as *const libc::c_char
        } else {
            strtab.offset((*best).st_name as isize)
        };
        *offset = dist;
        return;
    }
    *symname = 0 as *const libc::c_char;
    *offset = addr.offset;
}
unsafe extern "C" fn symcmp(
    mut p: *const libc::c_void,
    mut q: *const libc::c_void,
) -> libc::c_int {
    let mut sp: *mut Elf_Internal_Sym = p as *mut Elf_Internal_Sym;
    let mut sq: *mut Elf_Internal_Sym = q as *mut Elf_Internal_Sym;
    return if (*sp).st_value > (*sq).st_value {
        1 as libc::c_int
    } else if (*sp).st_value < (*sq).st_value {
        -(1 as libc::c_int)
    } else {
        0 as libc::c_int
    };
}
unsafe extern "C" fn dump_ia64_unwind(
    mut filedata: *mut Filedata,
    mut aux: *mut ia64_unw_aux_info,
) -> bool {
    let mut tp: *mut ia64_unw_table_entry = 0 as *mut ia64_unw_table_entry;
    let mut j: libc::c_ulong = 0;
    let mut nfuns: libc::c_ulong = 0;
    let mut in_body: libc::c_int = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    (*aux)
        .funtab = xmalloc(
        ((*aux).nsyms)
            .wrapping_mul(::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong),
    ) as *mut Elf_Internal_Sym;
    nfuns = 0 as libc::c_int as libc::c_ulong;
    j = 0 as libc::c_int as libc::c_ulong;
    while j < (*aux).nsyms {
        if (*((*aux).symtab).offset(j as isize)).st_value != 0
            && (*((*aux).symtab).offset(j as isize)).st_info as libc::c_int
                & 0xf as libc::c_int == 2 as libc::c_int
        {
            let fresh23 = nfuns;
            nfuns = nfuns.wrapping_add(1);
            *((*aux).funtab)
                .offset(fresh23 as isize) = *((*aux).symtab).offset(j as isize);
        }
        j = j.wrapping_add(1);
        j;
    }
    (*aux).nfuns = nfuns;
    qsort(
        (*aux).funtab as *mut libc::c_void,
        (*aux).nfuns,
        ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
        Some(
            symcmp
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    let mut current_block_37: u64;
    tp = (*aux).table;
    while tp < ((*aux).table).offset((*aux).table_len as isize) {
        let mut stamp: bfd_vma = 0;
        let mut offset: bfd_vma = 0;
        let mut dp: *const libc::c_uchar = 0 as *const libc::c_uchar;
        let mut head: *const libc::c_uchar = 0 as *const libc::c_uchar;
        let mut end: *const libc::c_uchar = 0 as *const libc::c_uchar;
        let mut procname: *const libc::c_char = 0 as *const libc::c_char;
        find_symbol_for_address(
            filedata,
            (*aux).funtab,
            (*aux).nfuns,
            (*aux).strtab,
            (*aux).strtab_size,
            (*tp).start,
            &mut procname,
            &mut offset,
        );
        fputs(b"\n<\0" as *const u8 as *const libc::c_char, stdout);
        if !procname.is_null() {
            fputs(procname, stdout);
            if offset != 0 {
                printf(b"+%lx\0" as *const u8 as *const libc::c_char, offset);
            }
        }
        fputs(b">: [\0" as *const u8 as *const libc::c_char, stdout);
        print_vma((*tp).start.offset, PREFIX_HEX);
        fputc('-' as i32, stdout);
        print_vma((*tp).end.offset, PREFIX_HEX);
        printf(
            b"], info at +0x%lx\n\0" as *const u8 as *const libc::c_char,
            ((*tp).info.offset).wrapping_sub((*aux).seg_base),
        );
        if !((*aux).info).is_null() {
            offset = (*tp).info.offset;
            if (*tp).info.section != 0 {
                if (*tp).info.section as libc::c_uint >= (*filedata).file_header.e_shnum
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Invalid section %u in table entry %ld\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*tp).info.section as libc::c_int,
                        tp.offset_from((*aux).table) as libc::c_long,
                    );
                    res = 0 as libc::c_int != 0;
                    current_block_37 = 6937071982253665452;
                } else {
                    offset = (offset as libc::c_ulong)
                        .wrapping_add(
                            (*((*filedata).section_headers)
                                .offset((*tp).info.section as isize))
                                .sh_addr,
                        ) as bfd_vma as bfd_vma;
                    current_block_37 = 7172762164747879670;
                }
            } else {
                current_block_37 = 7172762164747879670;
            }
            match current_block_37 {
                6937071982253665452 => {}
                _ => {
                    offset = (offset as libc::c_ulong).wrapping_sub((*aux).info_addr)
                        as bfd_vma as bfd_vma;
                    if offset >= (*aux).info_size
                        || ((*aux).info_size).wrapping_sub(offset)
                            < 8 as libc::c_int as libc::c_ulong
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Invalid offset %lx in table entry %ld\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*tp).info.offset as libc::c_long,
                            tp.offset_from((*aux).table) as libc::c_long,
                        );
                        res = 0 as libc::c_int != 0;
                    } else {
                        head = ((*aux).info).offset(offset as isize);
                        stamp = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            head as *mut libc::c_uchar,
                            ::core::mem::size_of::<bfd_vma>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        printf(
                            b"  v%u, flags=0x%lx (%s%s), len=%lu bytes\n\0" as *const u8
                                as *const libc::c_char,
                            (stamp >> 48 as libc::c_int) as libc::c_uint,
                            ((stamp as libc::c_ulonglong
                                & 0xffff00000000 as libc::c_longlong as libc::c_ulonglong)
                                >> 32 as libc::c_int) as libc::c_ulong,
                            if stamp as libc::c_ulonglong
                                & 0x100000000 as libc::c_longlong as libc::c_ulonglong != 0
                            {
                                b" ehandler\0" as *const u8 as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                            if stamp as libc::c_ulonglong
                                & 0x200000000 as libc::c_longlong as libc::c_ulonglong != 0
                            {
                                b" uhandler\0" as *const u8 as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                            (eh_addr_size as libc::c_ulonglong)
                                .wrapping_mul(
                                    stamp as libc::c_ulonglong
                                        & 0xffffffff as libc::c_longlong as libc::c_ulonglong,
                                ) as libc::c_ulong,
                        );
                        if stamp >> 48 as libc::c_int
                            != 1 as libc::c_int as libc::c_ulong
                        {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"\tUnknown version.\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        } else {
                            in_body = 0 as libc::c_int;
                            end = head
                                .offset(8 as libc::c_int as isize)
                                .offset(
                                    (eh_addr_size as libc::c_ulonglong)
                                        .wrapping_mul(
                                            stamp as libc::c_ulonglong
                                                & 0xffffffff as libc::c_longlong as libc::c_ulonglong,
                                        ) as isize,
                                );
                            if end
                                > ((*aux).info).offset((*aux).info_size as isize)
                                    as *const libc::c_uchar
                            {
                                end = ((*aux).info).offset((*aux).info_size as isize);
                            }
                            dp = head.offset(8 as libc::c_int as isize);
                            while dp < end {
                                dp = unw_decode(
                                    dp,
                                    in_body,
                                    &mut in_body as *mut libc::c_int as *mut libc::c_void,
                                    end,
                                );
                            }
                        }
                    }
                }
            }
        }
        tp = tp.offset(1);
        tp;
    }
    free((*aux).funtab as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn slurp_ia64_unwind_table(
    mut filedata: *mut Filedata,
    mut aux: *mut ia64_unw_aux_info,
    mut sec: *mut Elf_Internal_Shdr,
) -> bool {
    let mut size: libc::c_ulong = 0;
    let mut nrelas: libc::c_ulong = 0;
    let mut i: libc::c_ulong = 0;
    let mut seg: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut tep: *mut ia64_unw_table_entry = 0 as *mut ia64_unw_table_entry;
    let mut relsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut rela: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut rp: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut table: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tp: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut relname: *const libc::c_char = 0 as *const libc::c_char;
    (*aux).table_len = 0 as libc::c_int as libc::c_ulong;
    if (*filedata).file_header.e_phnum != 0 {
        if !get_program_headers(filedata) {
            return 0 as libc::c_int != 0;
        }
        seg = (*filedata).program_headers;
        while seg
            < ((*filedata).program_headers)
                .offset((*filedata).file_header.e_phnum as isize)
        {
            if !((*seg).p_type != 1 as libc::c_int as libc::c_ulong) {
                if (*sec).sh_addr >= (*seg).p_vaddr
                    && ((*sec).sh_addr).wrapping_add((*sec).sh_size)
                        <= ((*seg).p_vaddr).wrapping_add((*seg).p_memsz)
                {
                    (*aux).seg_base = (*seg).p_vaddr;
                    break;
                }
            }
            seg = seg.offset(1);
            seg;
        }
    }
    size = (*sec).sh_size;
    table = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*sec).sh_offset as libc::c_ulong,
        1 as libc::c_int as bfd_size_type,
        size,
        dcgettext(
            0 as *const libc::c_char,
            b"unwind table\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut libc::c_uchar;
    if table.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*aux)
        .table_len = size
        .wrapping_div(
            (3 as libc::c_int as libc::c_uint).wrapping_mul(eh_addr_size)
                as libc::c_ulong,
        );
    (*aux)
        .table = xcmalloc(
        (*aux).table_len,
        ::core::mem::size_of::<ia64_unw_table_entry>() as libc::c_ulong,
    ) as *mut ia64_unw_table_entry;
    tep = (*aux).table;
    tp = table;
    while tp
        <= table
            .offset(size as isize)
            .offset(
                -((3 as libc::c_int as libc::c_uint).wrapping_mul(eh_addr_size) as isize),
            )
    {
        (*tep).start.section = 0 as libc::c_int as libc::c_ushort;
        (*tep).end.section = 0 as libc::c_int as libc::c_ushort;
        (*tep).info.section = 0 as libc::c_int as libc::c_ushort;
        (*tep)
            .start
            .offset = byte_get.expect("non-null function pointer")(tp, eh_addr_size);
        tp = tp.offset(eh_addr_size as isize);
        (*tep)
            .end
            .offset = byte_get.expect("non-null function pointer")(tp, eh_addr_size);
        tp = tp.offset(eh_addr_size as isize);
        (*tep)
            .info
            .offset = byte_get.expect("non-null function pointer")(tp, eh_addr_size);
        tp = tp.offset(eh_addr_size as isize);
        (*tep)
            .start
            .offset = ((*tep).start.offset as libc::c_ulong)
            .wrapping_add((*aux).seg_base) as bfd_vma as bfd_vma;
        (*tep)
            .end
            .offset = ((*tep).end.offset as libc::c_ulong).wrapping_add((*aux).seg_base)
            as bfd_vma as bfd_vma;
        (*tep)
            .info
            .offset = ((*tep).info.offset as libc::c_ulong).wrapping_add((*aux).seg_base)
            as bfd_vma as bfd_vma;
        tep = tep.offset(1);
        tep;
    }
    free(table as *mut libc::c_void);
    relsec = (*filedata).section_headers;
    while relsec
        < ((*filedata).section_headers).offset((*filedata).file_header.e_shnum as isize)
    {
        if !((*relsec).sh_type != 4 as libc::c_int as libc::c_uint
            || (*relsec).sh_info >= (*filedata).file_header.e_shnum
            || ((*filedata).section_headers).offset((*relsec).sh_info as isize) != sec)
        {
            if !slurp_rela_relocs(
                filedata,
                (*relsec).sh_offset as libc::c_ulong,
                (*relsec).sh_size,
                &mut rela,
                &mut nrelas,
            ) {
                free((*aux).table as *mut libc::c_void);
                (*aux).table = 0 as *mut ia64_unw_table_entry;
                (*aux).table_len = 0 as libc::c_int as libc::c_ulong;
                return 0 as libc::c_int != 0;
            }
            rp = rela;
            while rp < rela.offset(nrelas as isize) {
                let mut sym_ndx: libc::c_uint = 0;
                let mut r_type: libc::c_uint = get_reloc_type(filedata, (*rp).r_info);
                relname = elf_ia64_reloc_type(r_type as libc::c_ulong);
                if relname.is_null() {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Skipping unknown relocation type: %u\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        r_type,
                    );
                } else if !startswith(
                    relname,
                    b"R_IA64_SEGREL\0" as *const u8 as *const libc::c_char,
                ) {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Skipping unexpected relocation type: %s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        relname,
                    );
                } else {
                    i = ((*rp).r_offset)
                        .wrapping_div(
                            (3 as libc::c_int as libc::c_uint).wrapping_mul(eh_addr_size)
                                as libc::c_ulong,
                        );
                    if i >= (*aux).table_len {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Skipping reloc with overlarge offset: %lx\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            i,
                        );
                    } else {
                        sym_ndx = get_reloc_symindex((*rp).r_info) as libc::c_uint;
                        if sym_ndx as libc::c_ulong >= (*aux).nsyms {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Skipping reloc with invalid symbol index: %u\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                sym_ndx,
                            );
                        } else {
                            sym = ((*aux).symtab).offset(sym_ndx as isize);
                            match ((*rp).r_offset)
                                .wrapping_div(eh_addr_size as libc::c_ulong)
                                .wrapping_rem(3 as libc::c_int as libc::c_ulong)
                            {
                                0 => {
                                    (*((*aux).table).offset(i as isize))
                                        .start
                                        .section = (*sym).st_shndx as libc::c_ushort;
                                    (*((*aux).table).offset(i as isize))
                                        .start
                                        .offset = ((*rp).r_addend).wrapping_add((*sym).st_value);
                                }
                                1 => {
                                    (*((*aux).table).offset(i as isize))
                                        .end
                                        .section = (*sym).st_shndx as libc::c_ushort;
                                    (*((*aux).table).offset(i as isize))
                                        .end
                                        .offset = ((*rp).r_addend).wrapping_add((*sym).st_value);
                                }
                                2 => {
                                    (*((*aux).table).offset(i as isize))
                                        .info
                                        .section = (*sym).st_shndx as libc::c_ushort;
                                    (*((*aux).table).offset(i as isize))
                                        .info
                                        .offset = ((*rp).r_addend).wrapping_add((*sym).st_value);
                                }
                                _ => {}
                            }
                        }
                    }
                }
                rp = rp.offset(1);
                rp;
            }
            free(rela as *mut libc::c_void);
        }
        relsec = relsec.offset(1);
        relsec;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn ia64_process_unwind(mut filedata: *mut Filedata) -> bool {
    let mut sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut unwsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_ulong = 0;
    let mut unwcount: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut unwstart: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut aux: ia64_unw_aux_info = ia64_unw_aux_info {
        table: 0 as *mut ia64_unw_table_entry,
        table_len: 0,
        info: 0 as *mut libc::c_uchar,
        info_size: 0,
        info_addr: 0,
        seg_base: 0,
        symtab: 0 as *mut Elf_Internal_Sym,
        nsyms: 0,
        funtab: 0 as *mut Elf_Internal_Sym,
        nfuns: 0,
        strtab: 0 as *mut libc::c_char,
        strtab_size: 0,
    };
    let mut res: bool = 1 as libc::c_int != 0;
    memset(
        &mut aux as *mut ia64_unw_aux_info as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ia64_unw_aux_info>() as libc::c_ulong,
    );
    i = 0 as libc::c_int as libc::c_ulong;
    sec = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum as libc::c_ulong {
        if (*sec).sh_type == 2 as libc::c_int as libc::c_uint {
            if !(aux.symtab).is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Multiple symbol tables encountered\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                free(aux.symtab as *mut libc::c_void);
                aux.symtab = 0 as *mut Elf_Internal_Sym;
                free(aux.strtab as *mut libc::c_void);
                aux.strtab = 0 as *mut libc::c_char;
            }
            if !get_symtab(
                filedata,
                sec,
                &mut aux.symtab,
                &mut aux.nsyms,
                &mut aux.strtab,
                &mut aux.strtab_size,
            ) {
                return 0 as libc::c_int != 0;
            }
        } else if (*sec).sh_type
            == (0x70000000 as libc::c_int + 1 as libc::c_int) as libc::c_uint
        {
            unwcount = unwcount.wrapping_add(1);
            unwcount;
        }
        i = i.wrapping_add(1);
        i;
        sec = sec.offset(1);
        sec;
    }
    if unwcount == 0 {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nThere are no unwind sections in this file.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    loop {
        let fresh24 = unwcount;
        unwcount = unwcount.wrapping_sub(1);
        if !(fresh24 > 0 as libc::c_int as libc::c_ulong) {
            break;
        }
        let mut suffix: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut len: size_t = 0;
        let mut len2: size_t = 0;
        i = unwstart;
        sec = ((*filedata).section_headers).offset(unwstart as isize);
        unwsec = 0 as *mut Elf_Internal_Shdr;
        while i < (*filedata).file_header.e_shnum as libc::c_ulong {
            if (*sec).sh_type
                == (0x70000000 as libc::c_int + 1 as libc::c_int) as libc::c_uint
            {
                unwsec = sec;
                break;
            } else {
                i = i.wrapping_add(1);
                i;
                sec = sec.offset(1);
                sec;
            }
        }
        if !unwsec.is_null() {} else {
            __assert_fail(
                b"unwsec != NULL\0" as *const u8 as *const libc::c_char,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                8387 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 38],
                    &[libc::c_char; 38],
                >(b"_Bool ia64_process_unwind(Filedata *)\0"))
                    .as_ptr(),
            );
        }
        'c_91421: {
            if !unwsec.is_null() {} else {
                __assert_fail(
                    b"unwsec != NULL\0" as *const u8 as *const libc::c_char,
                    b"readelf.c\0" as *const u8 as *const libc::c_char,
                    8387 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 38],
                        &[libc::c_char; 38],
                    >(b"_Bool ia64_process_unwind(Filedata *)\0"))
                        .as_ptr(),
                );
            }
        };
        unwstart = i.wrapping_add(1 as libc::c_int as libc::c_ulong);
        len = (::core::mem::size_of::<[libc::c_char; 23]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong);
        if (*unwsec).sh_flags & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong
            != 0 as libc::c_int as libc::c_ulong
        {
            let mut g: *mut group_list = 0 as *mut group_list;
            if ((*filedata).section_headers_groups).is_null()
                || (*((*filedata).section_headers_groups).offset(i as isize)).is_null()
            {
                i = (*filedata).file_header.e_shnum as libc::c_ulong;
            } else {
                g = (**((*filedata).section_headers_groups).offset(i as isize)).root;
                while !g.is_null() {
                    sec = ((*filedata).section_headers)
                        .offset((*g).section_index as isize);
                    if !sec.is_null() && !((*filedata).string_table).is_null()
                        && ((*sec).sh_name as libc::c_ulong)
                            < (*filedata).string_table_length
                        && strcmp(
                            ((*filedata).string_table).offset((*sec).sh_name as isize),
                            b".IA_64.unwind_info\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                    {
                        break;
                    }
                    g = (*g).next;
                }
                if g.is_null() {
                    i = (*filedata).file_header.e_shnum as libc::c_ulong;
                }
            }
        } else if !unwsec.is_null() && !((*filedata).string_table).is_null()
            && ((*unwsec).sh_name as libc::c_ulong) < (*filedata).string_table_length
            && startswith(
                ((*filedata).string_table).offset((*unwsec).sh_name as isize),
                b".gnu.linkonce.ia64unw.\0" as *const u8 as *const libc::c_char,
            ) as libc::c_int != 0
        {
            len2 = (::core::mem::size_of::<[libc::c_char; 24]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong);
            suffix = ((*filedata).string_table)
                .offset((*unwsec).sh_name as isize)
                .offset(len as isize);
            i = 0 as libc::c_int as libc::c_ulong;
            sec = (*filedata).section_headers;
            while i < (*filedata).file_header.e_shnum as libc::c_ulong {
                if !sec.is_null() && !((*filedata).string_table).is_null()
                    && ((*sec).sh_name as libc::c_ulong)
                        < (*filedata).string_table_length
                    && startswith(
                        ((*filedata).string_table).offset((*sec).sh_name as isize),
                        b".gnu.linkonce.ia64unwi.\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_int != 0
                    && strcmp(
                        ((*filedata).string_table)
                            .offset((*sec).sh_name as isize)
                            .offset(len2 as isize),
                        suffix,
                    ) == 0 as libc::c_int
                {
                    break;
                }
                i = i.wrapping_add(1);
                i;
                sec = sec.offset(1);
                sec;
            }
        } else {
            len = (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong);
            len2 = (::core::mem::size_of::<[libc::c_char; 19]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong);
            suffix = b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
            if !unwsec.is_null() && !((*filedata).string_table).is_null()
                && ((*unwsec).sh_name as libc::c_ulong) < (*filedata).string_table_length
                && startswith(
                    ((*filedata).string_table).offset((*unwsec).sh_name as isize),
                    b".IA_64.unwind\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
            {
                suffix = ((*filedata).string_table)
                    .offset((*unwsec).sh_name as isize)
                    .offset(len as isize);
            }
            i = 0 as libc::c_int as libc::c_ulong;
            sec = (*filedata).section_headers;
            while i < (*filedata).file_header.e_shnum as libc::c_ulong {
                if !sec.is_null() && !((*filedata).string_table).is_null()
                    && ((*sec).sh_name as libc::c_ulong)
                        < (*filedata).string_table_length
                    && startswith(
                        ((*filedata).string_table).offset((*sec).sh_name as isize),
                        b".IA_64.unwind_info\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_int != 0
                    && strcmp(
                        ((*filedata).string_table)
                            .offset((*sec).sh_name as isize)
                            .offset(len2 as isize),
                        suffix,
                    ) == 0 as libc::c_int
                {
                    break;
                }
                i = i.wrapping_add(1);
                i;
                sec = sec.offset(1);
                sec;
            }
        }
        if i == (*filedata).file_header.e_shnum as libc::c_ulong {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nCould not find unwind info section for \0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            if ((*filedata).string_table).is_null() {
                printf(b"%d\0" as *const u8 as *const libc::c_char, (*unwsec).sh_name);
            } else {
                printf(
                    b"'%s'\0" as *const u8 as *const libc::c_char,
                    printable_section_name(filedata, unwsec),
                );
            }
        } else {
            aux.info_addr = (*sec).sh_addr;
            aux
                .info = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*sec).sh_offset as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                (*sec).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"unwind info\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut libc::c_uchar;
            aux
                .info_size = if (aux.info).is_null() {
                0 as libc::c_int as libc::c_ulong
            } else {
                (*sec).sh_size
            };
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nUnwind section \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            if ((*filedata).string_table).is_null() {
                printf(b"%d\0" as *const u8 as *const libc::c_char, (*unwsec).sh_name);
            } else {
                printf(
                    b"'%s'\0" as *const u8 as *const libc::c_char,
                    printable_section_name(filedata, unwsec),
                );
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" at offset 0x%lx contains %lu entries:\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*unwsec).sh_offset as libc::c_ulong,
                ((*unwsec).sh_size)
                    .wrapping_div(
                        (3 as libc::c_int as libc::c_uint).wrapping_mul(eh_addr_size)
                            as libc::c_ulong,
                    ),
            );
            if slurp_ia64_unwind_table(filedata, &mut aux, unwsec) as libc::c_int != 0
                && aux.table_len > 0 as libc::c_int as libc::c_ulong
            {
                dump_ia64_unwind(filedata, &mut aux);
            }
            free(aux.table as *mut libc::c_char as *mut libc::c_void);
            free(aux.info as *mut libc::c_char as *mut libc::c_void);
            aux.table = 0 as *mut ia64_unw_table_entry;
            aux.info = 0 as *mut libc::c_uchar;
        }
    }
    free(aux.symtab as *mut libc::c_void);
    free(aux.strtab as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn dump_hppa_unwind(
    mut filedata: *mut Filedata,
    mut aux: *mut hppa_unw_aux_info,
) -> bool {
    let mut tp: *mut hppa_unw_table_entry = 0 as *mut hppa_unw_table_entry;
    let mut j: libc::c_ulong = 0;
    let mut nfuns: libc::c_ulong = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    (*aux)
        .funtab = xmalloc(
        ((*aux).nsyms)
            .wrapping_mul(::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong),
    ) as *mut Elf_Internal_Sym;
    nfuns = 0 as libc::c_int as libc::c_ulong;
    j = 0 as libc::c_int as libc::c_ulong;
    while j < (*aux).nsyms {
        if (*((*aux).symtab).offset(j as isize)).st_value != 0
            && (*((*aux).symtab).offset(j as isize)).st_info as libc::c_int
                & 0xf as libc::c_int == 2 as libc::c_int
        {
            let fresh25 = nfuns;
            nfuns = nfuns.wrapping_add(1);
            *((*aux).funtab)
                .offset(fresh25 as isize) = *((*aux).symtab).offset(j as isize);
        }
        j = j.wrapping_add(1);
        j;
    }
    (*aux).nfuns = nfuns;
    qsort(
        (*aux).funtab as *mut libc::c_void,
        (*aux).nfuns,
        ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
        Some(
            symcmp
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    tp = (*aux).table;
    while tp < ((*aux).table).offset((*aux).table_len as isize) {
        let mut offset: bfd_vma = 0;
        let mut procname: *const libc::c_char = 0 as *const libc::c_char;
        find_symbol_for_address(
            filedata,
            (*aux).funtab,
            (*aux).nfuns,
            (*aux).strtab,
            (*aux).strtab_size,
            (*tp).start,
            &mut procname,
            &mut offset,
        );
        fputs(b"\n<\0" as *const u8 as *const libc::c_char, stdout);
        if !procname.is_null() {
            fputs(procname, stdout);
            if offset != 0 {
                printf(b"+%lx\0" as *const u8 as *const libc::c_char, offset);
            }
        }
        fputs(b">: [\0" as *const u8 as *const libc::c_char, stdout);
        print_vma((*tp).start.offset, PREFIX_HEX);
        fputc('-' as i32, stdout);
        print_vma((*tp).end.offset, PREFIX_HEX);
        printf(b"]\n\t\0" as *const u8 as *const libc::c_char);
        if (*tp).Cannot_unwind() != 0 {
            printf(b"Cannot_unwind \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Millicode() != 0 {
            printf(b"Millicode \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Millicode_save_sr0() != 0 {
            printf(b"Millicode_save_sr0 \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Entry_SR() != 0 {
            printf(b"Entry_SR \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Entry_FR() != 0 {
            printf(
                b"Entry_FR=%d \0" as *const u8 as *const libc::c_char,
                (*tp).Entry_FR() as libc::c_int,
            );
        }
        if (*tp).Entry_GR() != 0 {
            printf(
                b"Entry_GR=%d \0" as *const u8 as *const libc::c_char,
                (*tp).Entry_GR() as libc::c_int,
            );
        }
        if (*tp).Args_stored() != 0 {
            printf(b"Args_stored \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Variable_Frame() != 0 {
            printf(b"Variable_Frame \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Separate_Package_Body() != 0 {
            printf(b"Separate_Package_Body \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Frame_Extension_Millicode() != 0 {
            printf(b"Frame_Extension_Millicode \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Stack_Overflow_Check() != 0 {
            printf(b"Stack_Overflow_Check \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Two_Instruction_SP_Increment() != 0 {
            printf(
                b"Two_Instruction_SP_Increment \0" as *const u8 as *const libc::c_char,
            );
        }
        if (*tp).Ada_Region() != 0 {
            printf(b"Ada_Region \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).cxx_info() != 0 {
            printf(b"cxx_info \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).cxx_try_catch() != 0 {
            printf(b"cxx_try_catch \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).sched_entry_seq() != 0 {
            printf(b"sched_entry_seq \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Save_SP() != 0 {
            printf(b"Save_SP \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Save_RP() != 0 {
            printf(b"Save_RP \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Save_MRP_in_frame() != 0 {
            printf(b"Save_MRP_in_frame \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).extn_ptr_defined() != 0 {
            printf(b"extn_ptr_defined \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Cleanup_defined() != 0 {
            printf(b"Cleanup_defined \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).MPE_XL_interrupt_marker() != 0 {
            printf(b"MPE_XL_interrupt_marker \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).HP_UX_interrupt_marker() != 0 {
            printf(b"HP_UX_interrupt_marker \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Large_frame() != 0 {
            printf(b"Large_frame \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Pseudo_SP_Set() != 0 {
            printf(b"Pseudo_SP_Set \0" as *const u8 as *const libc::c_char);
        }
        if (*tp).Total_frame_size() != 0 {
            printf(
                b"Total_frame_size=%d \0" as *const u8 as *const libc::c_char,
                (*tp).Total_frame_size() as libc::c_int,
            );
        }
        tp = tp.offset(1);
        tp;
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    free((*aux).funtab as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn slurp_hppa_unwind_table(
    mut filedata: *mut Filedata,
    mut aux: *mut hppa_unw_aux_info,
    mut sec: *mut Elf_Internal_Shdr,
) -> bool {
    let mut size: libc::c_ulong = 0;
    let mut unw_ent_size: libc::c_ulong = 0;
    let mut nentries: libc::c_ulong = 0;
    let mut nrelas: libc::c_ulong = 0;
    let mut i: libc::c_ulong = 0;
    let mut seg: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut tep: *mut hppa_unw_table_entry = 0 as *mut hppa_unw_table_entry;
    let mut relsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut rela: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut rp: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut table: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tp: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut relname: *const libc::c_char = 0 as *const libc::c_char;
    if (*filedata).file_header.e_phnum != 0 {
        if !get_program_headers(filedata) {
            return 0 as libc::c_int != 0;
        }
        seg = (*filedata).program_headers;
        while seg
            < ((*filedata).program_headers)
                .offset((*filedata).file_header.e_phnum as isize)
        {
            if !((*seg).p_type != 1 as libc::c_int as libc::c_ulong) {
                if (*sec).sh_addr >= (*seg).p_vaddr
                    && ((*sec).sh_addr).wrapping_add((*sec).sh_size)
                        <= ((*seg).p_vaddr).wrapping_add((*seg).p_memsz)
                {
                    (*aux).seg_base = (*seg).p_vaddr;
                    break;
                }
            }
            seg = seg.offset(1);
            seg;
        }
    }
    size = (*sec).sh_size;
    table = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*sec).sh_offset as libc::c_ulong,
        1 as libc::c_int as bfd_size_type,
        size,
        dcgettext(
            0 as *const libc::c_char,
            b"unwind table\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut libc::c_uchar;
    if table.is_null() {
        return 0 as libc::c_int != 0;
    }
    unw_ent_size = 16 as libc::c_int as libc::c_ulong;
    nentries = size.wrapping_div(unw_ent_size);
    size = unw_ent_size.wrapping_mul(nentries);
    (*aux).table_len = nentries;
    (*aux)
        .table = xcmalloc(
        nentries,
        ::core::mem::size_of::<hppa_unw_table_entry>() as libc::c_ulong,
    ) as *mut hppa_unw_table_entry;
    tep = (*aux).table;
    tp = table;
    while tp < table.offset(size as isize) {
        let mut tmp1: libc::c_uint = 0;
        let mut tmp2: libc::c_uint = 0;
        (*tep).start.section = 0 as libc::c_int as libc::c_ushort;
        (*tep).end.section = 0 as libc::c_int as libc::c_ushort;
        (*tep)
            .start
            .offset = byte_get
            .expect(
                "non-null function pointer",
            )(tp.offset(0 as libc::c_int as isize), 4 as libc::c_int as libc::c_uint);
        (*tep)
            .end
            .offset = byte_get
            .expect(
                "non-null function pointer",
            )(tp.offset(4 as libc::c_int as isize), 4 as libc::c_int as libc::c_uint);
        tmp1 = byte_get
            .expect(
                "non-null function pointer",
            )(tp.offset(8 as libc::c_int as isize), 4 as libc::c_int as libc::c_uint)
            as libc::c_uint;
        tmp2 = byte_get
            .expect(
                "non-null function pointer",
            )(tp.offset(12 as libc::c_int as isize), 4 as libc::c_int as libc::c_uint)
            as libc::c_uint;
        (*tep)
            .start
            .offset = ((*tep).start.offset as libc::c_ulong)
            .wrapping_add((*aux).seg_base) as bfd_vma as bfd_vma;
        (*tep)
            .end
            .offset = ((*tep).end.offset as libc::c_ulong).wrapping_add((*aux).seg_base)
            as bfd_vma as bfd_vma;
        (*tep)
            .set_Cannot_unwind(
                tmp1 >> 31 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Millicode(
                tmp1 >> 30 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Millicode_save_sr0(
                tmp1 >> 29 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Region_description(
                tmp1 >> 27 as libc::c_int & 0x3 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_reserved1(
                tmp1 >> 26 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Entry_SR(
                tmp1 >> 25 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Entry_FR(
                tmp1 >> 21 as libc::c_int & 0xf as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Entry_GR(
                tmp1 >> 16 as libc::c_int & 0x1f as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Args_stored(
                tmp1 >> 15 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Variable_Frame(
                tmp1 >> 14 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Separate_Package_Body(
                tmp1 >> 13 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Frame_Extension_Millicode(
                tmp1 >> 12 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Stack_Overflow_Check(
                tmp1 >> 11 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Two_Instruction_SP_Increment(
                tmp1 >> 10 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Ada_Region(
                tmp1 >> 9 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_cxx_info(tmp1 >> 8 as libc::c_int & 0x1 as libc::c_int as libc::c_uint);
        (*tep)
            .set_cxx_try_catch(
                tmp1 >> 7 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_sched_entry_seq(
                tmp1 >> 6 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_reserved2(
                tmp1 >> 5 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Save_SP(tmp1 >> 4 as libc::c_int & 0x1 as libc::c_int as libc::c_uint);
        (*tep)
            .set_Save_RP(tmp1 >> 3 as libc::c_int & 0x1 as libc::c_int as libc::c_uint);
        (*tep)
            .set_Save_MRP_in_frame(
                tmp1 >> 2 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_extn_ptr_defined(
                tmp1 >> 1 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep).set_Cleanup_defined(tmp1 & 0x1 as libc::c_int as libc::c_uint);
        (*tep)
            .set_MPE_XL_interrupt_marker(
                tmp2 >> 31 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_HP_UX_interrupt_marker(
                tmp2 >> 30 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Large_frame(
                tmp2 >> 29 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_Pseudo_SP_Set(
                tmp2 >> 28 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep)
            .set_reserved4(
                tmp2 >> 27 as libc::c_int & 0x1 as libc::c_int as libc::c_uint,
            );
        (*tep).set_Total_frame_size(tmp2 & 0x7ffffff as libc::c_int as libc::c_uint);
        tp = tp.offset(unw_ent_size as isize);
        tep = tep.offset(1);
        tep;
    }
    free(table as *mut libc::c_void);
    relsec = (*filedata).section_headers;
    while relsec
        < ((*filedata).section_headers).offset((*filedata).file_header.e_shnum as isize)
    {
        if !((*relsec).sh_type != 4 as libc::c_int as libc::c_uint
            || (*relsec).sh_info >= (*filedata).file_header.e_shnum
            || ((*filedata).section_headers).offset((*relsec).sh_info as isize) != sec)
        {
            if !slurp_rela_relocs(
                filedata,
                (*relsec).sh_offset as libc::c_ulong,
                (*relsec).sh_size,
                &mut rela,
                &mut nrelas,
            ) {
                return 0 as libc::c_int != 0;
            }
            rp = rela;
            while rp < rela.offset(nrelas as isize) {
                let mut sym_ndx: libc::c_uint = 0;
                let mut r_type: libc::c_uint = get_reloc_type(filedata, (*rp).r_info);
                relname = elf_hppa_reloc_type(r_type as libc::c_ulong);
                if relname.is_null() {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Skipping unknown relocation type: %u\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        r_type,
                    );
                } else if !startswith(
                    relname,
                    b"R_PARISC_SEGREL\0" as *const u8 as *const libc::c_char,
                ) {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Skipping unexpected relocation type: %s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        relname,
                    );
                } else {
                    i = ((*rp).r_offset).wrapping_div(unw_ent_size);
                    if i >= (*aux).table_len {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Skipping reloc with overlarge offset: %lx\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            i,
                        );
                    } else {
                        sym_ndx = get_reloc_symindex((*rp).r_info) as libc::c_uint;
                        if sym_ndx as libc::c_ulong >= (*aux).nsyms {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Skipping reloc with invalid symbol index: %u\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                sym_ndx,
                            );
                        } else {
                            sym = ((*aux).symtab).offset(sym_ndx as isize);
                            match ((*rp).r_offset)
                                .wrapping_rem(unw_ent_size)
                                .wrapping_div(4 as libc::c_int as libc::c_ulong)
                            {
                                0 => {
                                    (*((*aux).table).offset(i as isize))
                                        .start
                                        .section = (*sym).st_shndx as libc::c_ushort;
                                    (*((*aux).table).offset(i as isize))
                                        .start
                                        .offset = ((*sym).st_value).wrapping_add((*rp).r_addend);
                                }
                                1 => {
                                    (*((*aux).table).offset(i as isize))
                                        .end
                                        .section = (*sym).st_shndx as libc::c_ushort;
                                    (*((*aux).table).offset(i as isize))
                                        .end
                                        .offset = ((*sym).st_value).wrapping_add((*rp).r_addend);
                                }
                                _ => {}
                            }
                        }
                    }
                }
                rp = rp.offset(1);
                rp;
            }
            free(rela as *mut libc::c_void);
        }
        relsec = relsec.offset(1);
        relsec;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn hppa_process_unwind(mut filedata: *mut Filedata) -> bool {
    let mut aux: hppa_unw_aux_info = hppa_unw_aux_info {
        table: 0 as *mut hppa_unw_table_entry,
        table_len: 0,
        seg_base: 0,
        symtab: 0 as *mut Elf_Internal_Sym,
        nsyms: 0,
        funtab: 0 as *mut Elf_Internal_Sym,
        nfuns: 0,
        strtab: 0 as *mut libc::c_char,
        strtab_size: 0,
    };
    let mut unwsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_ulong = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    if ((*filedata).string_table).is_null() {
        return 0 as libc::c_int != 0;
    }
    memset(
        &mut aux as *mut hppa_unw_aux_info as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<hppa_unw_aux_info>() as libc::c_ulong,
    );
    i = 0 as libc::c_int as libc::c_ulong;
    sec = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum as libc::c_ulong {
        if (*sec).sh_type == 2 as libc::c_int as libc::c_uint {
            if !(aux.symtab).is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Multiple symbol tables encountered\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                free(aux.symtab as *mut libc::c_void);
                aux.symtab = 0 as *mut Elf_Internal_Sym;
                free(aux.strtab as *mut libc::c_void);
                aux.strtab = 0 as *mut libc::c_char;
            }
            if !get_symtab(
                filedata,
                sec,
                &mut aux.symtab,
                &mut aux.nsyms,
                &mut aux.strtab,
                &mut aux.strtab_size,
            ) {
                return 0 as libc::c_int != 0;
            }
        } else if !sec.is_null() && !((*filedata).string_table).is_null()
            && ((*sec).sh_name as libc::c_ulong) < (*filedata).string_table_length
            && strcmp(
                ((*filedata).string_table).offset((*sec).sh_name as isize),
                b".PARISC.unwind\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            unwsec = sec;
        }
        i = i.wrapping_add(1);
        i;
        sec = sec.offset(1);
        sec;
    }
    if unwsec.is_null() {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nThere are no unwind sections in this file.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    i = 0 as libc::c_int as libc::c_ulong;
    sec = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum as libc::c_ulong {
        if !sec.is_null() && !((*filedata).string_table).is_null()
            && ((*sec).sh_name as libc::c_ulong) < (*filedata).string_table_length
            && strcmp(
                ((*filedata).string_table).offset((*sec).sh_name as isize),
                b".PARISC.unwind\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut num_unwind: libc::c_ulong = ((*sec).sh_size)
                .wrapping_div(16 as libc::c_int as libc::c_ulong);
            printf(
                dcngettext(
                    0 as *const libc::c_char,
                    b"\nUnwind section '%s' at offset 0x%lx contains %lu entry:\n\0"
                        as *const u8 as *const libc::c_char,
                    b"\nUnwind section '%s' at offset 0x%lx contains %lu entries:\n\0"
                        as *const u8 as *const libc::c_char,
                    num_unwind,
                    5 as libc::c_int,
                ),
                printable_section_name(filedata, sec),
                (*sec).sh_offset as libc::c_ulong,
                num_unwind,
            );
            if !slurp_hppa_unwind_table(filedata, &mut aux, sec) {
                res = 0 as libc::c_int != 0;
            }
            if res as libc::c_int != 0
                && aux.table_len > 0 as libc::c_int as libc::c_ulong
            {
                if !dump_hppa_unwind(filedata, &mut aux) {
                    res = 0 as libc::c_int != 0;
                }
            }
            free(aux.table as *mut libc::c_char as *mut libc::c_void);
            aux.table = 0 as *mut hppa_unw_table_entry;
        }
        i = i.wrapping_add(1);
        i;
        sec = sec.offset(1);
        sec;
    }
    free(aux.symtab as *mut libc::c_void);
    free(aux.strtab as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn arm_print_vma_and_name(
    mut filedata: *mut Filedata,
    mut aux: *mut arm_unw_aux_info,
    mut fn_0: bfd_vma,
    mut addr: absaddr,
) -> *const libc::c_char {
    let mut procname: *const libc::c_char = 0 as *const libc::c_char;
    let mut sym_offset: bfd_vma = 0;
    if addr.section as libc::c_int == 0 as libc::c_int {
        addr.offset = fn_0;
    }
    find_symbol_for_address(
        filedata,
        (*aux).funtab,
        (*aux).nfuns,
        (*aux).strtab,
        (*aux).strtab_size,
        addr,
        &mut procname,
        &mut sym_offset,
    );
    print_vma(fn_0, PREFIX_HEX);
    if !procname.is_null() {
        fputs(b" <\0" as *const u8 as *const libc::c_char, stdout);
        fputs(procname, stdout);
        if sym_offset != 0 {
            printf(b"+0x%lx\0" as *const u8 as *const libc::c_char, sym_offset);
        }
        fputc('>' as i32, stdout);
    }
    return procname;
}
unsafe extern "C" fn arm_free_section(mut arm_sec: *mut arm_section) {
    free((*arm_sec).data as *mut libc::c_void);
    free((*arm_sec).rela as *mut libc::c_void);
}
unsafe extern "C" fn get_unwind_section_word(
    mut filedata: *mut Filedata,
    mut aux: *mut arm_unw_aux_info,
    mut arm_sec: *mut arm_section,
    mut sec: *mut Elf_Internal_Shdr,
    mut word_offset: bfd_vma,
    mut wordp: *mut libc::c_uint,
    mut addr: *mut absaddr,
    mut sym_name: *mut bfd_vma,
) -> bool {
    let mut rp: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut relname: *const libc::c_char = 0 as *const libc::c_char;
    let mut word: libc::c_uint = 0;
    let mut wrapped: bool = false;
    if sec.is_null() || arm_sec.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*addr).section = 0 as libc::c_int as libc::c_ushort;
    (*addr).offset = 0 as libc::c_int as bfd_vma;
    if !sym_name.is_null() {
        *sym_name = -(1 as libc::c_int) as bfd_vma;
    }
    if sec != (*arm_sec).sec {
        let mut relsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        arm_free_section(arm_sec);
        (*arm_sec).sec = sec;
        (*arm_sec)
            .data = get_data(
            0 as *mut libc::c_void,
            (*aux).filedata,
            (*sec).sh_offset as libc::c_ulong,
            1 as libc::c_int as bfd_size_type,
            (*sec).sh_size,
            dcgettext(
                0 as *const libc::c_char,
                b"unwind data\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        ) as *mut libc::c_uchar;
        (*arm_sec).rela = 0 as *mut Elf_Internal_Rela;
        (*arm_sec).nrelas = 0 as libc::c_int as libc::c_ulong;
        relsec = (*filedata).section_headers;
        while relsec
            < ((*filedata).section_headers)
                .offset((*filedata).file_header.e_shnum as isize)
        {
            if (*relsec).sh_info >= (*filedata).file_header.e_shnum
                || ((*filedata).section_headers).offset((*relsec).sh_info as isize)
                    != sec
                || (*relsec).sh_type != 9 as libc::c_int as libc::c_uint
                    && (*relsec).sh_type != 4 as libc::c_int as libc::c_uint
            {
                relsec = relsec.offset(1);
                relsec;
            } else {
                (*arm_sec).rel_type = (*relsec).sh_type;
                if (*relsec).sh_type == 9 as libc::c_int as libc::c_uint {
                    if !slurp_rel_relocs(
                        (*aux).filedata,
                        (*relsec).sh_offset as libc::c_ulong,
                        (*relsec).sh_size,
                        &mut (*arm_sec).rela,
                        &mut (*arm_sec).nrelas,
                    ) {
                        return 0 as libc::c_int != 0;
                    }
                } else if !slurp_rela_relocs(
                    (*aux).filedata,
                    (*relsec).sh_offset as libc::c_ulong,
                    (*relsec).sh_size,
                    &mut (*arm_sec).rela,
                    &mut (*arm_sec).nrelas,
                ) {
                    return 0 as libc::c_int != 0
                }
                break;
            }
        }
        (*arm_sec).next_rela = (*arm_sec).rela;
    }
    if ((*arm_sec).data).is_null() {
        return 0 as libc::c_int != 0;
    }
    if (*sec).sh_size < 4 as libc::c_int as libc::c_ulong
        || word_offset > ((*sec).sh_size).wrapping_sub(4 as libc::c_int as libc::c_ulong)
        || (word_offset as bfd_signed_vma) < 0 as libc::c_int as libc::c_long
    {
        return 0 as libc::c_int != 0;
    }
    word = byte_get
        .expect(
            "non-null function pointer",
        )(
        ((*arm_sec).data).offset(word_offset as isize),
        4 as libc::c_int as libc::c_uint,
    ) as libc::c_uint;
    if ((*arm_sec).rela).is_null() {
        *wordp = word;
        return 1 as libc::c_int != 0;
    }
    wrapped = 0 as libc::c_int != 0;
    let mut current_block_62: u64;
    rp = (*arm_sec).next_rela;
    while rp != ((*arm_sec).rela).offset((*arm_sec).nrelas as isize) {
        let mut prelval: bfd_vma = 0;
        let mut offset: bfd_vma = 0;
        if (*rp).r_offset > word_offset && !wrapped {
            rp = (*arm_sec).rela;
            wrapped = 1 as libc::c_int != 0;
        }
        if (*rp).r_offset > word_offset {
            break;
        }
        if (*rp).r_offset & 3 as libc::c_int as libc::c_ulong != 0 {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Skipping unexpected relocation at offset 0x%lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*rp).r_offset,
            );
        } else if !((*rp).r_offset < word_offset) {
            if !((*aux).symtab).is_null() {
                if (*arm_sec).rel_type == 9 as libc::c_int as libc::c_uint {
                    offset = (word & 0x7fffffff as libc::c_int as libc::c_uint)
                        as bfd_vma;
                    if offset & 0x40000000 as libc::c_int as libc::c_ulong != 0 {
                        offset |= !(0x7fffffff as libc::c_int as bfd_vma);
                    }
                } else if (*arm_sec).rel_type == 4 as libc::c_int as libc::c_uint {
                    offset = (*rp).r_addend;
                } else {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unknown section relocation type %d encountered\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*arm_sec).rel_type,
                    );
                    break;
                }
                if (*rp).r_info >> 8 as libc::c_int >= (*aux).nsyms {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Bad symbol index in unwind relocation (%lu > %lu)\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*rp).r_info >> 8 as libc::c_int,
                        (*aux).nsyms,
                    );
                    break;
                } else {
                    sym = ((*aux).symtab)
                        .offset(((*rp).r_info >> 8 as libc::c_int) as isize);
                    offset = (offset as libc::c_ulong).wrapping_add((*sym).st_value)
                        as bfd_vma as bfd_vma;
                    prelval = offset
                        .wrapping_sub(
                            ((*(*arm_sec).sec).sh_addr).wrapping_add((*rp).r_offset),
                        );
                    if (*filedata).file_header.e_machine as libc::c_int
                        == 40 as libc::c_int
                    {
                        relname = elf_arm_reloc_type(
                            (*rp).r_info & 0xff as libc::c_int as libc::c_ulong,
                        );
                        if relname.is_null() {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Skipping unknown ARM relocation type: %d\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ((*rp).r_info & 0xff as libc::c_int as libc::c_ulong)
                                    as libc::c_int,
                            );
                            current_block_62 = 4775909272756257391;
                        } else if strcmp(
                            relname,
                            b"R_ARM_NONE\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            current_block_62 = 4775909272756257391;
                        } else if !(strcmp(
                            relname,
                            b"R_ARM_PREL31\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int)
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Skipping unexpected ARM relocation type %s\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                relname,
                            );
                            current_block_62 = 4775909272756257391;
                        } else {
                            current_block_62 = 317151059986244064;
                        }
                    } else if (*filedata).file_header.e_machine as libc::c_int
                        == 140 as libc::c_int
                    {
                        relname = elf_tic6x_reloc_type(
                            (*rp).r_info & 0xff as libc::c_int as libc::c_ulong,
                        );
                        if relname.is_null() {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Skipping unknown C6000 relocation type: %d\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ((*rp).r_info & 0xff as libc::c_int as libc::c_ulong)
                                    as libc::c_int,
                            );
                            current_block_62 = 4775909272756257391;
                        } else if strcmp(
                            relname,
                            b"R_C6000_NONE\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            current_block_62 = 4775909272756257391;
                        } else if !(strcmp(
                            relname,
                            b"R_C6000_PREL31\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int)
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Skipping unexpected C6000 relocation type %s\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                relname,
                            );
                            current_block_62 = 4775909272756257391;
                        } else {
                            prelval >>= 1 as libc::c_int;
                            current_block_62 = 317151059986244064;
                        }
                    } else {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Only TI and ARM unwinders are currently supported\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        break;
                    }
                    match current_block_62 {
                        4775909272756257391 => {}
                        _ => {
                            word = (word as libc::c_ulong
                                & !(0x7fffffff as libc::c_int as bfd_vma)
                                | prelval & 0x7fffffff as libc::c_int as libc::c_ulong)
                                as libc::c_uint;
                            (*addr).section = (*sym).st_shndx as libc::c_ushort;
                            (*addr).offset = offset;
                            if !sym_name.is_null() {
                                *sym_name = (*sym).st_name;
                            }
                            break;
                        }
                    }
                }
            }
        }
        rp = rp.offset(1);
        rp;
    }
    *wordp = word;
    (*arm_sec).next_rela = rp;
    return 1 as libc::c_int != 0;
}
static mut tic6x_unwind_regnames: [*const libc::c_char; 16] = [
    b"A15\0" as *const u8 as *const libc::c_char,
    b"B15\0" as *const u8 as *const libc::c_char,
    b"B14\0" as *const u8 as *const libc::c_char,
    b"B13\0" as *const u8 as *const libc::c_char,
    b"B12\0" as *const u8 as *const libc::c_char,
    b"B11\0" as *const u8 as *const libc::c_char,
    b"B10\0" as *const u8 as *const libc::c_char,
    b"B3\0" as *const u8 as *const libc::c_char,
    b"A14\0" as *const u8 as *const libc::c_char,
    b"A13\0" as *const u8 as *const libc::c_char,
    b"A12\0" as *const u8 as *const libc::c_char,
    b"A11\0" as *const u8 as *const libc::c_char,
    b"A10\0" as *const u8 as *const libc::c_char,
    b"[invalid reg 13]\0" as *const u8 as *const libc::c_char,
    b"[invalid reg 14]\0" as *const u8 as *const libc::c_char,
    b"[invalid reg 15]\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn decode_tic6x_unwind_regmask(mut mask: libc::c_uint) {
    let mut i: libc::c_int = 0;
    i = 12 as libc::c_int;
    while mask != 0 {
        if mask & 1 as libc::c_int as libc::c_uint != 0 {
            fputs(tic6x_unwind_regnames[i as usize], stdout);
            if mask > 1 as libc::c_int as libc::c_uint {
                fputs(b", \0" as *const u8 as *const libc::c_char, stdout);
            }
        }
        mask >>= 1 as libc::c_int;
        i -= 1;
        i;
    }
}
unsafe extern "C" fn decode_arm_unwind_bytecode(
    mut filedata: *mut Filedata,
    mut aux: *mut arm_unw_aux_info,
    mut word: libc::c_uint,
    mut remaining: libc::c_uint,
    mut more_words: libc::c_uint,
    mut data_offset: bfd_vma,
    mut data_sec: *mut Elf_Internal_Shdr,
    mut data_arm_sec: *mut arm_section,
) -> bool {
    let mut addr: absaddr = absaddr { section: 0, offset: 0 };
    let mut res: bool = 1 as libc::c_int != 0;
    loop {
        let mut op: libc::c_uint = 0;
        let mut op2: libc::c_uint = 0;
        if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
            data_offset = (data_offset as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma as bfd_vma;
            if !get_unwind_section_word(
                filedata,
                aux,
                data_arm_sec,
                data_sec,
                data_offset,
                &mut word,
                &mut addr,
                0 as *mut bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
            remaining = 4 as libc::c_int as libc::c_uint;
            more_words = more_words.wrapping_sub(1);
            more_words;
        }
        if remaining == 0 as libc::c_int as libc::c_uint {
            break;
        }
        remaining = remaining.wrapping_sub(1);
        remaining;
        op = word >> 24 as libc::c_int;
        word <<= 8 as libc::c_int;
        printf(b"  0x%02x \0" as *const u8 as *const libc::c_char, op);
        if op & 0xc0 as libc::c_int as libc::c_uint == 0 as libc::c_int as libc::c_uint {
            let mut offset: libc::c_int = ((op & 0x3f as libc::c_int as libc::c_uint)
                << 2 as libc::c_int)
                .wrapping_add(4 as libc::c_int as libc::c_uint) as libc::c_int;
            printf(b"     vsp = vsp + %d\0" as *const u8 as *const libc::c_char, offset);
        } else if op & 0xc0 as libc::c_int as libc::c_uint
            == 0x40 as libc::c_int as libc::c_uint
        {
            let mut offset_0: libc::c_int = ((op & 0x3f as libc::c_int as libc::c_uint)
                << 2 as libc::c_int)
                .wrapping_add(4 as libc::c_int as libc::c_uint) as libc::c_int;
            printf(
                b"     vsp = vsp - %d\0" as *const u8 as *const libc::c_char,
                offset_0,
            );
        } else if op & 0xf0 as libc::c_int as libc::c_uint
            == 0x80 as libc::c_int as libc::c_uint
        {
            if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                data_offset = (data_offset as libc::c_ulong)
                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                    as bfd_vma;
                if !get_unwind_section_word(
                    filedata,
                    aux,
                    data_arm_sec,
                    data_sec,
                    data_offset,
                    &mut word,
                    &mut addr,
                    0 as *mut bfd_vma,
                ) {
                    return 0 as libc::c_int != 0;
                }
                remaining = 4 as libc::c_int as libc::c_uint;
                more_words = more_words.wrapping_sub(1);
                more_words;
            }
            if remaining != 0 {
                remaining = remaining.wrapping_sub(1);
                remaining;
                op2 = word >> 24 as libc::c_int;
                word <<= 8 as libc::c_int;
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[Truncated opcode]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            printf(b"0x%02x \0" as *const u8 as *const libc::c_char, op2);
            if op == 0x80 as libc::c_int as libc::c_uint
                && op2 == 0 as libc::c_int as libc::c_uint
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Refuse to unwind\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                let mut mask: libc::c_uint = (op & 0xf as libc::c_int as libc::c_uint)
                    << 8 as libc::c_int | op2;
                let mut first: bool = 1 as libc::c_int != 0;
                let mut i: libc::c_int = 0;
                printf(b"pop {\0" as *const u8 as *const libc::c_char);
                i = 0 as libc::c_int;
                while i < 12 as libc::c_int {
                    if mask & ((1 as libc::c_int) << i) as libc::c_uint != 0 {
                        if first {
                            first = 0 as libc::c_int != 0;
                        } else {
                            printf(b", \0" as *const u8 as *const libc::c_char);
                        }
                        printf(
                            b"r%d\0" as *const u8 as *const libc::c_char,
                            4 as libc::c_int + i,
                        );
                    }
                    i += 1;
                    i;
                }
                printf(b"}\0" as *const u8 as *const libc::c_char);
            }
        } else if op & 0xf0 as libc::c_int as libc::c_uint
            == 0x90 as libc::c_int as libc::c_uint
        {
            if op == 0x9d as libc::c_int as libc::c_uint
                || op == 0x9f as libc::c_int as libc::c_uint
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"     [Reserved]\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                printf(
                    b"     vsp = r%d\0" as *const u8 as *const libc::c_char,
                    op & 0xf as libc::c_int as libc::c_uint,
                );
            }
        } else if op & 0xf0 as libc::c_int as libc::c_uint
            == 0xa0 as libc::c_int as libc::c_uint
        {
            let mut end: libc::c_int = (4 as libc::c_int as libc::c_uint)
                .wrapping_add(op & 0x7 as libc::c_int as libc::c_uint) as libc::c_int;
            let mut first_0: bool = 1 as libc::c_int != 0;
            let mut i_0: libc::c_int = 0;
            printf(b"     pop {\0" as *const u8 as *const libc::c_char);
            i_0 = 4 as libc::c_int;
            while i_0 <= end {
                if first_0 {
                    first_0 = 0 as libc::c_int != 0;
                } else {
                    printf(b", \0" as *const u8 as *const libc::c_char);
                }
                printf(b"r%d\0" as *const u8 as *const libc::c_char, i_0);
                i_0 += 1;
                i_0;
            }
            if op & 0x8 as libc::c_int as libc::c_uint != 0 {
                if !first_0 {
                    printf(b", \0" as *const u8 as *const libc::c_char);
                }
                printf(b"r14\0" as *const u8 as *const libc::c_char);
            }
            printf(b"}\0" as *const u8 as *const libc::c_char);
        } else if op == 0xb0 as libc::c_int as libc::c_uint {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"     finish\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else if op == 0xb1 as libc::c_int as libc::c_uint {
            if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                data_offset = (data_offset as libc::c_ulong)
                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                    as bfd_vma;
                if !get_unwind_section_word(
                    filedata,
                    aux,
                    data_arm_sec,
                    data_sec,
                    data_offset,
                    &mut word,
                    &mut addr,
                    0 as *mut bfd_vma,
                ) {
                    return 0 as libc::c_int != 0;
                }
                remaining = 4 as libc::c_int as libc::c_uint;
                more_words = more_words.wrapping_sub(1);
                more_words;
            }
            if remaining != 0 {
                remaining = remaining.wrapping_sub(1);
                remaining;
                op2 = word >> 24 as libc::c_int;
                word <<= 8 as libc::c_int;
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[Truncated opcode]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            printf(b"0x%02x \0" as *const u8 as *const libc::c_char, op2);
            if op2 == 0 as libc::c_int as libc::c_uint
                || op2 & 0xf0 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[Spare]\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                let mut mask_0: libc::c_uint = op2 & 0xf as libc::c_int as libc::c_uint;
                let mut first_1: bool = 1 as libc::c_int != 0;
                let mut i_1: libc::c_int = 0;
                printf(b"pop {\0" as *const u8 as *const libc::c_char);
                i_1 = 0 as libc::c_int;
                while i_1 < 12 as libc::c_int {
                    if mask_0 & ((1 as libc::c_int) << i_1) as libc::c_uint != 0 {
                        if first_1 {
                            first_1 = 0 as libc::c_int != 0;
                        } else {
                            printf(b", \0" as *const u8 as *const libc::c_char);
                        }
                        printf(b"r%d\0" as *const u8 as *const libc::c_char, i_1);
                    }
                    i_1 += 1;
                    i_1;
                }
                printf(b"}\0" as *const u8 as *const libc::c_char);
            }
        } else if op == 0xb2 as libc::c_int as libc::c_uint {
            let mut buf: [libc::c_uchar; 9] = [0; 9];
            let mut i_2: libc::c_uint = 0;
            let mut len: libc::c_uint = 0;
            let mut offset_1: libc::c_ulong = 0;
            i_2 = 0 as libc::c_int as libc::c_uint;
            while (i_2 as libc::c_ulong)
                < ::core::mem::size_of::<[libc::c_uchar; 9]>() as libc::c_ulong
            {
                if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                    data_offset = (data_offset as libc::c_ulong)
                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                        as bfd_vma;
                    if !get_unwind_section_word(
                        filedata,
                        aux,
                        data_arm_sec,
                        data_sec,
                        data_offset,
                        &mut word,
                        &mut addr,
                        0 as *mut bfd_vma,
                    ) {
                        return 0 as libc::c_int != 0;
                    }
                    remaining = 4 as libc::c_int as libc::c_uint;
                    more_words = more_words.wrapping_sub(1);
                    more_words;
                }
                if remaining != 0 {
                    remaining = remaining.wrapping_sub(1);
                    remaining;
                    buf[i_2 as usize] = (word >> 24 as libc::c_int) as libc::c_uchar;
                    word <<= 8 as libc::c_int;
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"[Truncated opcode]\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 0 as libc::c_int != 0;
                }
                printf(
                    b"0x%02x \0" as *const u8 as *const libc::c_char,
                    buf[i_2 as usize] as libc::c_int,
                );
                if buf[i_2 as usize] as libc::c_int & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    break;
                }
                i_2 = i_2.wrapping_add(1);
                i_2;
            }
            if i_2 as libc::c_ulong
                == ::core::mem::size_of::<[libc::c_uchar; 9]>() as libc::c_ulong
            {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"corrupt change to vsp\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                res = 0 as libc::c_int != 0;
            } else {
                offset_1 = read_leb128(
                    buf.as_mut_ptr(),
                    buf
                        .as_mut_ptr()
                        .offset(i_2 as isize)
                        .offset(1 as libc::c_int as isize),
                    0 as libc::c_int != 0,
                    &mut len,
                    0 as *mut libc::c_int,
                );
                if len == i_2.wrapping_add(1 as libc::c_int as libc::c_uint) {} else {
                    __assert_fail(
                        b"len == i + 1\0" as *const u8 as *const libc::c_char,
                        b"readelf.c\0" as *const u8 as *const libc::c_char,
                        9341 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 166],
                            &[libc::c_char; 166],
                        >(
                            b"_Bool decode_arm_unwind_bytecode(Filedata *, struct arm_unw_aux_info *, unsigned int, unsigned int, unsigned int, bfd_vma, Elf_Internal_Shdr *, struct arm_section *)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_95793: {
                    if len == i_2.wrapping_add(1 as libc::c_int as libc::c_uint)
                    {} else {
                        __assert_fail(
                            b"len == i + 1\0" as *const u8 as *const libc::c_char,
                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                            9341 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 166],
                                &[libc::c_char; 166],
                            >(
                                b"_Bool decode_arm_unwind_bytecode(Filedata *, struct arm_unw_aux_info *, unsigned int, unsigned int, unsigned int, bfd_vma, Elf_Internal_Shdr *, struct arm_section *)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
                offset_1 = offset_1
                    .wrapping_mul(4 as libc::c_int as libc::c_ulong)
                    .wrapping_add(0x204 as libc::c_int as libc::c_ulong);
                printf(
                    b"vsp = vsp + %ld\0" as *const u8 as *const libc::c_char,
                    offset_1,
                );
            }
        } else if op == 0xb3 as libc::c_int as libc::c_uint
            || op == 0xc8 as libc::c_int as libc::c_uint
            || op == 0xc9 as libc::c_int as libc::c_uint
        {
            let mut first_2: libc::c_uint = 0;
            let mut last: libc::c_uint = 0;
            if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                data_offset = (data_offset as libc::c_ulong)
                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                    as bfd_vma;
                if !get_unwind_section_word(
                    filedata,
                    aux,
                    data_arm_sec,
                    data_sec,
                    data_offset,
                    &mut word,
                    &mut addr,
                    0 as *mut bfd_vma,
                ) {
                    return 0 as libc::c_int != 0;
                }
                remaining = 4 as libc::c_int as libc::c_uint;
                more_words = more_words.wrapping_sub(1);
                more_words;
            }
            if remaining != 0 {
                remaining = remaining.wrapping_sub(1);
                remaining;
                op2 = word >> 24 as libc::c_int;
                word <<= 8 as libc::c_int;
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[Truncated opcode]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            printf(b"0x%02x \0" as *const u8 as *const libc::c_char, op2);
            first_2 = op2 >> 4 as libc::c_int;
            last = op2 & 0xf as libc::c_int as libc::c_uint;
            if op == 0xc8 as libc::c_int as libc::c_uint {
                first_2 = first_2.wrapping_add(16 as libc::c_int as libc::c_uint);
            }
            printf(b"pop {D%d\0" as *const u8 as *const libc::c_char, first_2);
            if last != 0 {
                printf(
                    b"-D%d\0" as *const u8 as *const libc::c_char,
                    first_2.wrapping_add(last),
                );
            }
            printf(b"}\0" as *const u8 as *const libc::c_char);
        } else if op & 0xf8 as libc::c_int as libc::c_uint
            == 0xb8 as libc::c_int as libc::c_uint
            || op & 0xf8 as libc::c_int as libc::c_uint
                == 0xd0 as libc::c_int as libc::c_uint
        {
            let mut count: libc::c_uint = op & 0x7 as libc::c_int as libc::c_uint;
            printf(b"pop {D8\0" as *const u8 as *const libc::c_char);
            if count != 0 {
                printf(
                    b"-D%d\0" as *const u8 as *const libc::c_char,
                    (8 as libc::c_int as libc::c_uint).wrapping_add(count),
                );
            }
            printf(b"}\0" as *const u8 as *const libc::c_char);
        } else if op >= 0xc0 as libc::c_int as libc::c_uint
            && op <= 0xc5 as libc::c_int as libc::c_uint
        {
            let mut count_0: libc::c_uint = op & 0x7 as libc::c_int as libc::c_uint;
            printf(b"     pop {wR10\0" as *const u8 as *const libc::c_char);
            if count_0 != 0 {
                printf(
                    b"-wR%d\0" as *const u8 as *const libc::c_char,
                    (10 as libc::c_int as libc::c_uint).wrapping_add(count_0),
                );
            }
            printf(b"}\0" as *const u8 as *const libc::c_char);
        } else if op == 0xc6 as libc::c_int as libc::c_uint {
            let mut first_3: libc::c_uint = 0;
            let mut last_0: libc::c_uint = 0;
            if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                data_offset = (data_offset as libc::c_ulong)
                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                    as bfd_vma;
                if !get_unwind_section_word(
                    filedata,
                    aux,
                    data_arm_sec,
                    data_sec,
                    data_offset,
                    &mut word,
                    &mut addr,
                    0 as *mut bfd_vma,
                ) {
                    return 0 as libc::c_int != 0;
                }
                remaining = 4 as libc::c_int as libc::c_uint;
                more_words = more_words.wrapping_sub(1);
                more_words;
            }
            if remaining != 0 {
                remaining = remaining.wrapping_sub(1);
                remaining;
                op2 = word >> 24 as libc::c_int;
                word <<= 8 as libc::c_int;
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[Truncated opcode]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            printf(b"0x%02x \0" as *const u8 as *const libc::c_char, op2);
            first_3 = op2 >> 4 as libc::c_int;
            last_0 = op2 & 0xf as libc::c_int as libc::c_uint;
            printf(b"pop {wR%d\0" as *const u8 as *const libc::c_char, first_3);
            if last_0 != 0 {
                printf(
                    b"-wR%d\0" as *const u8 as *const libc::c_char,
                    first_3.wrapping_add(last_0),
                );
            }
            printf(b"}\0" as *const u8 as *const libc::c_char);
        } else if op == 0xc7 as libc::c_int as libc::c_uint {
            if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                data_offset = (data_offset as libc::c_ulong)
                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                    as bfd_vma;
                if !get_unwind_section_word(
                    filedata,
                    aux,
                    data_arm_sec,
                    data_sec,
                    data_offset,
                    &mut word,
                    &mut addr,
                    0 as *mut bfd_vma,
                ) {
                    return 0 as libc::c_int != 0;
                }
                remaining = 4 as libc::c_int as libc::c_uint;
                more_words = more_words.wrapping_sub(1);
                more_words;
            }
            if remaining != 0 {
                remaining = remaining.wrapping_sub(1);
                remaining;
                op2 = word >> 24 as libc::c_int;
                word <<= 8 as libc::c_int;
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[Truncated opcode]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            printf(b"0x%02x \0" as *const u8 as *const libc::c_char, op2);
            if op2 == 0 as libc::c_int as libc::c_uint
                || op2 & 0xf0 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[Spare]\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                let mut mask_1: libc::c_uint = op2 & 0xf as libc::c_int as libc::c_uint;
                let mut first_4: bool = 1 as libc::c_int != 0;
                let mut i_3: libc::c_int = 0;
                printf(b"pop {\0" as *const u8 as *const libc::c_char);
                i_3 = 0 as libc::c_int;
                while i_3 < 4 as libc::c_int {
                    if mask_1 & ((1 as libc::c_int) << i_3) as libc::c_uint != 0 {
                        if first_4 {
                            first_4 = 0 as libc::c_int != 0;
                        } else {
                            printf(b", \0" as *const u8 as *const libc::c_char);
                        }
                        printf(b"wCGR%d\0" as *const u8 as *const libc::c_char, i_3);
                    }
                    i_3 += 1;
                    i_3;
                }
                printf(b"}\0" as *const u8 as *const libc::c_char);
            }
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"     [unsupported opcode]\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            res = 0 as libc::c_int != 0;
        }
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    return res;
}
unsafe extern "C" fn decode_tic6x_unwind_bytecode(
    mut filedata: *mut Filedata,
    mut aux: *mut arm_unw_aux_info,
    mut word: libc::c_uint,
    mut remaining: libc::c_uint,
    mut more_words: libc::c_uint,
    mut data_offset: bfd_vma,
    mut data_sec: *mut Elf_Internal_Shdr,
    mut data_arm_sec: *mut arm_section,
) -> bool {
    let mut addr: absaddr = absaddr { section: 0, offset: 0 };
    loop {
        let mut op: libc::c_uint = 0;
        let mut op2: libc::c_uint = 0;
        if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
            data_offset = (data_offset as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma as bfd_vma;
            if !get_unwind_section_word(
                filedata,
                aux,
                data_arm_sec,
                data_sec,
                data_offset,
                &mut word,
                &mut addr,
                0 as *mut bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
            remaining = 4 as libc::c_int as libc::c_uint;
            more_words = more_words.wrapping_sub(1);
            more_words;
        }
        if remaining == 0 as libc::c_int as libc::c_uint {
            break;
        }
        remaining = remaining.wrapping_sub(1);
        remaining;
        op = word >> 24 as libc::c_int;
        word <<= 8 as libc::c_int;
        printf(b"  0x%02x \0" as *const u8 as *const libc::c_char, op);
        if op & 0xc0 as libc::c_int as libc::c_uint == 0 as libc::c_int as libc::c_uint {
            let mut offset: libc::c_int = ((op & 0x3f as libc::c_int as libc::c_uint)
                << 3 as libc::c_int)
                .wrapping_add(8 as libc::c_int as libc::c_uint) as libc::c_int;
            printf(b"     sp = sp + %d\0" as *const u8 as *const libc::c_char, offset);
        } else if op & 0xc0 as libc::c_int as libc::c_uint
            == 0x80 as libc::c_int as libc::c_uint
        {
            if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                data_offset = (data_offset as libc::c_ulong)
                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                    as bfd_vma;
                if !get_unwind_section_word(
                    filedata,
                    aux,
                    data_arm_sec,
                    data_sec,
                    data_offset,
                    &mut word,
                    &mut addr,
                    0 as *mut bfd_vma,
                ) {
                    return 0 as libc::c_int != 0;
                }
                remaining = 4 as libc::c_int as libc::c_uint;
                more_words = more_words.wrapping_sub(1);
                more_words;
            }
            if remaining != 0 {
                remaining = remaining.wrapping_sub(1);
                remaining;
                op2 = word >> 24 as libc::c_int;
                word <<= 8 as libc::c_int;
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[Truncated opcode]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            printf(b"0x%02x \0" as *const u8 as *const libc::c_char, op2);
            if op == 0x80 as libc::c_int as libc::c_uint
                && op2 == 0 as libc::c_int as libc::c_uint
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Refuse to unwind\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                let mut mask: libc::c_uint = (op & 0x1f as libc::c_int as libc::c_uint)
                    << 8 as libc::c_int | op2;
                if op & 0x20 as libc::c_int as libc::c_uint != 0 {
                    printf(b"pop compact {\0" as *const u8 as *const libc::c_char);
                } else {
                    printf(b"pop {\0" as *const u8 as *const libc::c_char);
                }
                decode_tic6x_unwind_regmask(mask);
                printf(b"}\0" as *const u8 as *const libc::c_char);
            }
        } else if op & 0xf0 as libc::c_int as libc::c_uint
            == 0xc0 as libc::c_int as libc::c_uint
        {
            let mut reg: libc::c_uint = 0;
            let mut nregs: libc::c_uint = 0;
            let mut i: libc::c_uint = 0;
            let mut name: *const libc::c_char = 0 as *const libc::c_char;
            let mut regpos: [C2RustUnnamed_30; 16] = [C2RustUnnamed_30 {
                offset: 0,
                reg: 0,
            }; 16];
            nregs = 0 as libc::c_int as libc::c_uint;
            i = 0 as libc::c_int as libc::c_uint;
            while nregs < op & 0xf as libc::c_int as libc::c_uint {
                if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                    data_offset = (data_offset as libc::c_ulong)
                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                        as bfd_vma;
                    if !get_unwind_section_word(
                        filedata,
                        aux,
                        data_arm_sec,
                        data_sec,
                        data_offset,
                        &mut word,
                        &mut addr,
                        0 as *mut bfd_vma,
                    ) {
                        return 0 as libc::c_int != 0;
                    }
                    remaining = 4 as libc::c_int as libc::c_uint;
                    more_words = more_words.wrapping_sub(1);
                    more_words;
                }
                if remaining != 0 {
                    remaining = remaining.wrapping_sub(1);
                    remaining;
                    op2 = word >> 24 as libc::c_int;
                    word <<= 8 as libc::c_int;
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"[Truncated opcode]\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 0 as libc::c_int != 0;
                }
                printf(b"0x%02x \0" as *const u8 as *const libc::c_char, op2);
                reg = op2 >> 4 as libc::c_int;
                if reg != 0xf as libc::c_int as libc::c_uint {
                    regpos[nregs as usize]
                        .offset = i.wrapping_mul(2 as libc::c_int as libc::c_uint);
                    regpos[nregs as usize].reg = reg;
                    nregs = nregs.wrapping_add(1);
                    nregs;
                }
                reg = op2 & 0xf as libc::c_int as libc::c_uint;
                if reg != 0xf as libc::c_int as libc::c_uint {
                    regpos[nregs as usize]
                        .offset = i
                        .wrapping_mul(2 as libc::c_int as libc::c_uint)
                        .wrapping_add(1 as libc::c_int as libc::c_uint);
                    regpos[nregs as usize].reg = reg;
                    nregs = nregs.wrapping_add(1);
                    nregs;
                }
                i = i.wrapping_add(1);
                i;
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"pop frame {\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            if nregs == 0 as libc::c_int as libc::c_uint {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"*corrupt* - no registers specified\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                reg = nregs.wrapping_sub(1 as libc::c_int as libc::c_uint);
                i = i.wrapping_mul(2 as libc::c_int as libc::c_uint);
                while i > 0 as libc::c_int as libc::c_uint {
                    if regpos[reg as usize].offset
                        == i.wrapping_sub(1 as libc::c_int as libc::c_uint)
                    {
                        name = tic6x_unwind_regnames[regpos[reg as usize].reg as usize];
                        if reg > 0 as libc::c_int as libc::c_uint {
                            reg = reg.wrapping_sub(1);
                            reg;
                        }
                    } else {
                        name = dcgettext(
                            0 as *const libc::c_char,
                            b"[pad]\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        );
                    }
                    fputs(name, stdout);
                    if i > 1 as libc::c_int as libc::c_uint {
                        printf(b", \0" as *const u8 as *const libc::c_char);
                    }
                    i = i.wrapping_sub(1);
                    i;
                }
            }
            printf(b"}\0" as *const u8 as *const libc::c_char);
        } else if op == 0xd0 as libc::c_int as libc::c_uint {
            printf(b"     MOV FP, SP\0" as *const u8 as *const libc::c_char);
        } else if op == 0xd1 as libc::c_int as libc::c_uint {
            printf(b"     __c6xabi_pop_rts\0" as *const u8 as *const libc::c_char);
        } else if op == 0xd2 as libc::c_int as libc::c_uint {
            let mut buf: [libc::c_uchar; 9] = [0; 9];
            let mut i_0: libc::c_uint = 0;
            let mut len: libc::c_uint = 0;
            let mut offset_0: libc::c_ulong = 0;
            i_0 = 0 as libc::c_int as libc::c_uint;
            while (i_0 as libc::c_ulong)
                < ::core::mem::size_of::<[libc::c_uchar; 9]>() as libc::c_ulong
            {
                if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                    data_offset = (data_offset as libc::c_ulong)
                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                        as bfd_vma;
                    if !get_unwind_section_word(
                        filedata,
                        aux,
                        data_arm_sec,
                        data_sec,
                        data_offset,
                        &mut word,
                        &mut addr,
                        0 as *mut bfd_vma,
                    ) {
                        return 0 as libc::c_int != 0;
                    }
                    remaining = 4 as libc::c_int as libc::c_uint;
                    more_words = more_words.wrapping_sub(1);
                    more_words;
                }
                if remaining != 0 {
                    remaining = remaining.wrapping_sub(1);
                    remaining;
                    buf[i_0 as usize] = (word >> 24 as libc::c_int) as libc::c_uchar;
                    word <<= 8 as libc::c_int;
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"[Truncated opcode]\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 0 as libc::c_int != 0;
                }
                printf(
                    b"0x%02x \0" as *const u8 as *const libc::c_char,
                    buf[i_0 as usize] as libc::c_int,
                );
                if buf[i_0 as usize] as libc::c_int & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    break;
                }
                i_0 = i_0.wrapping_add(1);
                i_0;
            }
            if i_0 as libc::c_ulong
                == ::core::mem::size_of::<[libc::c_uchar; 9]>() as libc::c_ulong
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Corrupt stack pointer adjustment detected\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            offset_0 = read_leb128(
                buf.as_mut_ptr(),
                buf.as_mut_ptr().offset(i_0 as isize).offset(1 as libc::c_int as isize),
                0 as libc::c_int != 0,
                &mut len,
                0 as *mut libc::c_int,
            );
            if len == i_0.wrapping_add(1 as libc::c_int as libc::c_uint) {} else {
                __assert_fail(
                    b"len == i + 1\0" as *const u8 as *const libc::c_char,
                    b"readelf.c\0" as *const u8 as *const libc::c_char,
                    9560 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 168],
                        &[libc::c_char; 168],
                    >(
                        b"_Bool decode_tic6x_unwind_bytecode(Filedata *, struct arm_unw_aux_info *, unsigned int, unsigned int, unsigned int, bfd_vma, Elf_Internal_Shdr *, struct arm_section *)\0",
                    ))
                        .as_ptr(),
                );
            }
            'c_96878: {
                if len == i_0.wrapping_add(1 as libc::c_int as libc::c_uint) {} else {
                    __assert_fail(
                        b"len == i + 1\0" as *const u8 as *const libc::c_char,
                        b"readelf.c\0" as *const u8 as *const libc::c_char,
                        9560 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 168],
                            &[libc::c_char; 168],
                        >(
                            b"_Bool decode_tic6x_unwind_bytecode(Filedata *, struct arm_unw_aux_info *, unsigned int, unsigned int, unsigned int, bfd_vma, Elf_Internal_Shdr *, struct arm_section *)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            offset_0 = offset_0
                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                .wrapping_add(0x408 as libc::c_int as libc::c_ulong);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"sp = sp + %ld\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                offset_0,
            );
        } else if op & 0xf0 as libc::c_int as libc::c_uint
            == 0xe0 as libc::c_int as libc::c_uint
        {
            if op & 0xf as libc::c_int as libc::c_uint
                == 7 as libc::c_int as libc::c_uint
            {
                printf(b"     RETURN\0" as *const u8 as *const libc::c_char);
            } else {
                printf(
                    b"     MV %s, B3\0" as *const u8 as *const libc::c_char,
                    tic6x_unwind_regnames[(op & 0xf as libc::c_int as libc::c_uint)
                        as usize],
                );
            }
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"     [unsupported opcode]\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        putchar('\n' as i32);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn arm_expand_prel31(
    mut filedata: *mut Filedata,
    mut word: bfd_vma,
    mut where_0: bfd_vma,
) -> bfd_vma {
    let mut offset: bfd_vma = 0;
    offset = word & 0x7fffffff as libc::c_int as libc::c_ulong;
    if offset & 0x40000000 as libc::c_int as libc::c_ulong != 0 {
        offset |= !(0x7fffffff as libc::c_int as bfd_vma);
    }
    if (*filedata).file_header.e_machine as libc::c_int == 140 as libc::c_int {
        offset <<= 1 as libc::c_int;
    }
    return offset.wrapping_add(where_0);
}
unsafe extern "C" fn decode_arm_unwind(
    mut filedata: *mut Filedata,
    mut aux: *mut arm_unw_aux_info,
    mut word: libc::c_uint,
    mut remaining: libc::c_uint,
    mut data_offset: bfd_vma,
    mut data_sec: *mut Elf_Internal_Shdr,
    mut data_arm_sec: *mut arm_section,
) -> bool {
    let mut per_index: libc::c_int = 0;
    let mut more_words: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut addr: absaddr = absaddr { section: 0, offset: 0 };
    let mut sym_name: bfd_vma = -(1 as libc::c_int) as bfd_vma;
    let mut res: bool = 1 as libc::c_int != 0;
    if remaining == 0 as libc::c_int as libc::c_uint {
        if !get_unwind_section_word(
            filedata,
            aux,
            data_arm_sec,
            data_sec,
            data_offset,
            &mut word,
            &mut addr,
            &mut sym_name,
        ) {
            return 0 as libc::c_int != 0;
        }
        remaining = 4 as libc::c_int as libc::c_uint;
    } else {
        addr.section = 0 as libc::c_int as libc::c_ushort;
        addr.offset = 0 as libc::c_int as bfd_vma;
    }
    if word & 0x80000000 as libc::c_uint == 0 as libc::c_int as libc::c_uint {
        let mut fn_0: bfd_vma = 0;
        let mut procname: *const libc::c_char = 0 as *const libc::c_char;
        fn_0 = arm_expand_prel31(
            filedata,
            word as bfd_vma,
            ((*data_sec).sh_addr).wrapping_add(data_offset),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Personality routine: \0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        if fn_0 == 0 as libc::c_int as libc::c_ulong
            && addr.section as libc::c_int == 0 as libc::c_int
            && addr.offset == 0 as libc::c_int as libc::c_ulong
            && sym_name != -(1 as libc::c_int) as bfd_vma
            && sym_name < (*aux).strtab_size
        {
            procname = ((*aux).strtab).offset(sym_name as isize);
            print_vma(fn_0, PREFIX_HEX);
            if !procname.is_null() {
                fputs(b" <\0" as *const u8 as *const libc::c_char, stdout);
                fputs(procname, stdout);
                fputc('>' as i32, stdout);
            }
        } else {
            procname = arm_print_vma_and_name(filedata, aux, fn_0, addr);
        }
        fputc('\n' as i32, stdout);
        if !procname.is_null()
            && (startswith(
                procname,
                b"__gcc_personality_v0\0" as *const u8 as *const libc::c_char,
            ) as libc::c_int != 0
                || startswith(
                    procname,
                    b"__gxx_personality_v0\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
                || startswith(
                    procname,
                    b"__gcj_personality_v0\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
                || startswith(
                    procname,
                    b"__gnu_objc_personality_v0\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0)
        {
            remaining = 0 as libc::c_int as libc::c_uint;
            more_words = 1 as libc::c_int as libc::c_uint;
            if remaining == 0 as libc::c_int as libc::c_uint && more_words != 0 {
                data_offset = (data_offset as libc::c_ulong)
                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                    as bfd_vma;
                if !get_unwind_section_word(
                    filedata,
                    aux,
                    data_arm_sec,
                    data_sec,
                    data_offset,
                    &mut word,
                    &mut addr,
                    0 as *mut bfd_vma,
                ) {
                    return 0 as libc::c_int != 0;
                }
                remaining = 4 as libc::c_int as libc::c_uint;
                more_words = more_words.wrapping_sub(1);
                more_words;
            }
            if remaining == 0 {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  [Truncated data]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            more_words = word >> 24 as libc::c_int;
            word <<= 8 as libc::c_int;
            remaining = remaining.wrapping_sub(1);
            remaining;
            per_index = -(1 as libc::c_int);
        } else {
            return 1 as libc::c_int != 0
        }
    } else {
        if (*filedata).file_header.e_machine as libc::c_int == 40 as libc::c_int
            && word & 0x70000000 as libc::c_int as libc::c_uint != 0
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Corrupt ARM compact model table entry: %x \n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                word,
            );
            res = 0 as libc::c_int != 0;
        }
        per_index = (word >> 24 as libc::c_int & 0x7f as libc::c_int as libc::c_uint)
            as libc::c_int;
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Compact model index: %d\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            per_index,
        );
        if per_index == 0 as libc::c_int {
            more_words = 0 as libc::c_int as libc::c_uint;
            word <<= 8 as libc::c_int;
            remaining = remaining.wrapping_sub(1);
            remaining;
        } else if per_index < 3 as libc::c_int {
            more_words = word >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint;
            word <<= 16 as libc::c_int;
            remaining = remaining.wrapping_sub(2 as libc::c_int as libc::c_uint);
        }
    }
    match (*filedata).file_header.e_machine as libc::c_int {
        40 => {
            if per_index < 3 as libc::c_int {
                if !decode_arm_unwind_bytecode(
                    filedata,
                    aux,
                    word,
                    remaining,
                    more_words,
                    data_offset,
                    data_sec,
                    data_arm_sec,
                ) {
                    res = 0 as libc::c_int != 0;
                }
            } else {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unknown ARM compact model index encountered\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  [reserved]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                res = 0 as libc::c_int != 0;
            }
        }
        140 => {
            if per_index < 3 as libc::c_int {
                if !decode_tic6x_unwind_bytecode(
                    filedata,
                    aux,
                    word,
                    remaining,
                    more_words,
                    data_offset,
                    data_sec,
                    data_arm_sec,
                ) {
                    res = 0 as libc::c_int != 0;
                }
            } else if per_index < 5 as libc::c_int {
                if word >> 17 as libc::c_int & 0x7f as libc::c_int as libc::c_uint
                    == 0x7f as libc::c_int as libc::c_uint
                {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  Restore stack from frame pointer\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  Stack increment %d\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        word >> 14 as libc::c_int & 0x1fc as libc::c_int as libc::c_uint,
                    );
                }
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Registers restored: \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                if per_index == 4 as libc::c_int {
                    printf(b" (compact) \0" as *const u8 as *const libc::c_char);
                }
                decode_tic6x_unwind_regmask(
                    word >> 4 as libc::c_int & 0x1fff as libc::c_int as libc::c_uint,
                );
                putchar('\n' as i32);
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Return register: %s\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    tic6x_unwind_regnames[(word & 0xf as libc::c_int as libc::c_uint)
                        as usize],
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  [reserved (%d)]\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    per_index,
                );
            }
        }
        _ => {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unsupported architecture type %d encountered when decoding unwind table\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*filedata).file_header.e_machine as libc::c_int,
            );
            res = 0 as libc::c_int != 0;
        }
    }
    return res;
}
unsafe extern "C" fn dump_arm_unwind(
    mut filedata: *mut Filedata,
    mut aux: *mut arm_unw_aux_info,
    mut exidx_sec: *mut Elf_Internal_Shdr,
) -> bool {
    let mut exidx_arm_sec: arm_section = arm_section {
        data: 0 as *mut libc::c_uchar,
        sec: 0 as *mut Elf_Internal_Shdr,
        rela: 0 as *mut Elf_Internal_Rela,
        nrelas: 0,
        rel_type: 0,
        next_rela: 0 as *mut Elf_Internal_Rela,
    };
    let mut extab_arm_sec: arm_section = arm_section {
        data: 0 as *mut libc::c_uchar,
        sec: 0 as *mut Elf_Internal_Shdr,
        rela: 0 as *mut Elf_Internal_Rela,
        nrelas: 0,
        rel_type: 0,
        next_rela: 0 as *mut Elf_Internal_Rela,
    };
    let mut i: libc::c_uint = 0;
    let mut exidx_len: libc::c_uint = 0;
    let mut j: libc::c_ulong = 0;
    let mut nfuns: libc::c_ulong = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    memset(
        &mut exidx_arm_sec as *mut arm_section as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<arm_section>() as libc::c_ulong,
    );
    memset(
        &mut extab_arm_sec as *mut arm_section as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<arm_section>() as libc::c_ulong,
    );
    exidx_len = ((*exidx_sec).sh_size).wrapping_div(8 as libc::c_int as libc::c_ulong)
        as libc::c_uint;
    (*aux)
        .funtab = xmalloc(
        ((*aux).nsyms)
            .wrapping_mul(::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong),
    ) as *mut Elf_Internal_Sym;
    nfuns = 0 as libc::c_int as libc::c_ulong;
    j = 0 as libc::c_int as libc::c_ulong;
    while j < (*aux).nsyms {
        if (*((*aux).symtab).offset(j as isize)).st_value != 0
            && (*((*aux).symtab).offset(j as isize)).st_info as libc::c_int
                & 0xf as libc::c_int == 2 as libc::c_int
        {
            let fresh26 = nfuns;
            nfuns = nfuns.wrapping_add(1);
            *((*aux).funtab)
                .offset(fresh26 as isize) = *((*aux).symtab).offset(j as isize);
        }
        j = j.wrapping_add(1);
        j;
    }
    (*aux).nfuns = nfuns;
    qsort(
        (*aux).funtab as *mut libc::c_void,
        (*aux).nfuns,
        ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
        Some(
            symcmp
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    let mut current_block_47: u64;
    i = 0 as libc::c_int as libc::c_uint;
    while i < exidx_len {
        let mut exidx_fn: libc::c_uint = 0;
        let mut exidx_entry: libc::c_uint = 0;
        let mut fn_addr: absaddr = absaddr { section: 0, offset: 0 };
        let mut entry_addr: absaddr = absaddr { section: 0, offset: 0 };
        let mut fn_0: bfd_vma = 0;
        fputc('\n' as i32, stdout);
        if !get_unwind_section_word(
            filedata,
            aux,
            &mut exidx_arm_sec,
            exidx_sec,
            (8 as libc::c_int as libc::c_uint).wrapping_mul(i) as bfd_vma,
            &mut exidx_fn,
            &mut fn_addr,
            0 as *mut bfd_vma,
        )
            || !get_unwind_section_word(
                filedata,
                aux,
                &mut exidx_arm_sec,
                exidx_sec,
                (8 as libc::c_int as libc::c_uint)
                    .wrapping_mul(i)
                    .wrapping_add(4 as libc::c_int as libc::c_uint) as bfd_vma,
                &mut exidx_entry,
                &mut entry_addr,
                0 as *mut bfd_vma,
            )
        {
            free((*aux).funtab as *mut libc::c_void);
            arm_free_section(&mut exidx_arm_sec);
            arm_free_section(&mut extab_arm_sec);
            return 0 as libc::c_int != 0;
        }
        if exidx_fn & 0x80000000 as libc::c_uint != 0 {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"corrupt index table entry: %x\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                exidx_fn,
            );
            res = 0 as libc::c_int != 0;
        }
        fn_0 = arm_expand_prel31(
            filedata,
            exidx_fn as bfd_vma,
            ((*exidx_sec).sh_addr)
                .wrapping_add(
                    (8 as libc::c_int as libc::c_uint).wrapping_mul(i) as libc::c_ulong,
                ),
        );
        arm_print_vma_and_name(filedata, aux, fn_0, fn_addr);
        fputs(b": \0" as *const u8 as *const libc::c_char, stdout);
        if exidx_entry == 1 as libc::c_int as libc::c_uint {
            print_vma(exidx_entry as bfd_vma, PREFIX_HEX);
            fputs(b" [cantunwind]\n\0" as *const u8 as *const libc::c_char, stdout);
        } else if exidx_entry & 0x80000000 as libc::c_uint != 0 {
            print_vma(exidx_entry as bfd_vma, PREFIX_HEX);
            fputc('\n' as i32, stdout);
            decode_arm_unwind(
                filedata,
                aux,
                exidx_entry,
                4 as libc::c_int as libc::c_uint,
                0 as libc::c_int as bfd_vma,
                0 as *mut Elf_Internal_Shdr,
                0 as *mut arm_section,
            );
        } else {
            let mut table: bfd_vma = 0;
            let mut table_offset: bfd_vma = 0 as libc::c_int as bfd_vma;
            let mut table_sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
            fputs(b"@\0" as *const u8 as *const libc::c_char, stdout);
            table = arm_expand_prel31(
                filedata,
                exidx_entry as bfd_vma,
                ((*exidx_sec).sh_addr)
                    .wrapping_add(
                        (8 as libc::c_int as libc::c_uint).wrapping_mul(i)
                            as libc::c_ulong,
                    )
                    .wrapping_add(4 as libc::c_int as libc::c_ulong),
            );
            print_vma(table, PREFIX_HEX);
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            if entry_addr.section as libc::c_int != 0 as libc::c_int
                && (entry_addr.section as libc::c_uint) < (*filedata).file_header.e_shnum
            {
                table_sec = ((*filedata).section_headers)
                    .offset(entry_addr.section as libc::c_int as isize);
                table_offset = entry_addr.offset;
                if table_offset > (*table_sec).sh_size
                    || (table_offset as bfd_signed_vma)
                        < 0 as libc::c_int as libc::c_long
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unwind entry contains corrupt offset (0x%lx) into section %s\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        table_offset,
                        printable_section_name(filedata, table_sec),
                    );
                    res = 0 as libc::c_int != 0;
                    current_block_47 = 1394248824506584008;
                } else {
                    current_block_47 = 3123434771885419771;
                }
            } else {
                table_sec = find_section_by_address(filedata, table);
                if !table_sec.is_null() {
                    table_offset = table.wrapping_sub((*table_sec).sh_addr);
                }
                current_block_47 = 3123434771885419771;
            }
            match current_block_47 {
                1394248824506584008 => {}
                _ => {
                    if table_sec.is_null() {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Could not locate .ARM.extab section containing 0x%lx.\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            table,
                        );
                        res = 0 as libc::c_int != 0;
                    } else if !decode_arm_unwind(
                        filedata,
                        aux,
                        0 as libc::c_int as libc::c_uint,
                        0 as libc::c_int as libc::c_uint,
                        table_offset,
                        table_sec,
                        &mut extab_arm_sec,
                    ) {
                        res = 0 as libc::c_int != 0;
                    }
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    free((*aux).funtab as *mut libc::c_void);
    arm_free_section(&mut exidx_arm_sec);
    arm_free_section(&mut extab_arm_sec);
    return res;
}
unsafe extern "C" fn arm_process_unwind(mut filedata: *mut Filedata) -> bool {
    let mut aux: arm_unw_aux_info = arm_unw_aux_info {
        filedata: 0 as *mut Filedata,
        symtab: 0 as *mut Elf_Internal_Sym,
        nsyms: 0,
        funtab: 0 as *mut Elf_Internal_Sym,
        nfuns: 0,
        strtab: 0 as *mut libc::c_char,
        strtab_size: 0,
    };
    let mut unwsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_ulong = 0;
    let mut sec_type: libc::c_uint = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    match (*filedata).file_header.e_machine as libc::c_int {
        40 => {
            sec_type = 0x70000001 as libc::c_int as libc::c_uint;
        }
        140 => {
            sec_type = 0x70000001 as libc::c_int as libc::c_uint;
        }
        _ => {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unsupported architecture type %d encountered when processing unwind table\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*filedata).file_header.e_machine as libc::c_int,
            );
            return 0 as libc::c_int != 0;
        }
    }
    if ((*filedata).string_table).is_null() {
        return 0 as libc::c_int != 0;
    }
    memset(
        &mut aux as *mut arm_unw_aux_info as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<arm_unw_aux_info>() as libc::c_ulong,
    );
    aux.filedata = filedata;
    i = 0 as libc::c_int as libc::c_ulong;
    sec = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum as libc::c_ulong {
        if (*sec).sh_type == 2 as libc::c_int as libc::c_uint {
            if !(aux.symtab).is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Multiple symbol tables encountered\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                free(aux.symtab as *mut libc::c_void);
                aux.symtab = 0 as *mut Elf_Internal_Sym;
                free(aux.strtab as *mut libc::c_void);
                aux.strtab = 0 as *mut libc::c_char;
            }
            if !get_symtab(
                filedata,
                sec,
                &mut aux.symtab,
                &mut aux.nsyms,
                &mut aux.strtab,
                &mut aux.strtab_size,
            ) {
                return 0 as libc::c_int != 0;
            }
        } else if (*sec).sh_type == sec_type {
            unwsec = sec;
        }
        i = i.wrapping_add(1);
        i;
        sec = sec.offset(1);
        sec;
    }
    if unwsec.is_null() {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nThere are no unwind sections in this file.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else {
        i = 0 as libc::c_int as libc::c_ulong;
        sec = (*filedata).section_headers;
        while i < (*filedata).file_header.e_shnum as libc::c_ulong {
            if (*sec).sh_type == sec_type {
                let mut num_unwind: libc::c_ulong = ((*sec).sh_size)
                    .wrapping_div(
                        (2 as libc::c_int as libc::c_uint).wrapping_mul(eh_addr_size)
                            as libc::c_ulong,
                    );
                printf(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"\nUnwind section '%s' at offset 0x%lx contains %lu entry:\n\0"
                            as *const u8 as *const libc::c_char,
                        b"\nUnwind section '%s' at offset 0x%lx contains %lu entries:\n\0"
                            as *const u8 as *const libc::c_char,
                        num_unwind,
                        5 as libc::c_int,
                    ),
                    printable_section_name(filedata, sec),
                    (*sec).sh_offset as libc::c_ulong,
                    num_unwind,
                );
                if !dump_arm_unwind(filedata, &mut aux, sec) {
                    res = 0 as libc::c_int != 0;
                }
            }
            i = i.wrapping_add(1);
            i;
            sec = sec.offset(1);
            sec;
        }
    }
    free(aux.symtab as *mut libc::c_void);
    free(aux.strtab as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn no_processor_specific_unwind(mut _filedata: *mut Filedata) -> bool {
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"No processor specific unwind information to decode\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn process_unwind(mut filedata: *mut Filedata) -> bool {
    let mut handlers: [unwind_handler; 7] = [
        {
            let mut init = unwind_handler {
                machtype: 40 as libc::c_int as libc::c_uint,
                handler: Some(
                    arm_process_unwind as unsafe extern "C" fn(*mut Filedata) -> bool,
                ),
            };
            init
        },
        {
            let mut init = unwind_handler {
                machtype: 50 as libc::c_int as libc::c_uint,
                handler: Some(
                    ia64_process_unwind as unsafe extern "C" fn(*mut Filedata) -> bool,
                ),
            };
            init
        },
        {
            let mut init = unwind_handler {
                machtype: 15 as libc::c_int as libc::c_uint,
                handler: Some(
                    hppa_process_unwind as unsafe extern "C" fn(*mut Filedata) -> bool,
                ),
            };
            init
        },
        {
            let mut init = unwind_handler {
                machtype: 140 as libc::c_int as libc::c_uint,
                handler: Some(
                    arm_process_unwind as unsafe extern "C" fn(*mut Filedata) -> bool,
                ),
            };
            init
        },
        {
            let mut init = unwind_handler {
                machtype: 3 as libc::c_int as libc::c_uint,
                handler: Some(
                    no_processor_specific_unwind
                        as unsafe extern "C" fn(*mut Filedata) -> bool,
                ),
            };
            init
        },
        {
            let mut init = unwind_handler {
                machtype: 62 as libc::c_int as libc::c_uint,
                handler: Some(
                    no_processor_specific_unwind
                        as unsafe extern "C" fn(*mut Filedata) -> bool,
                ),
            };
            init
        },
        {
            let mut init = unwind_handler {
                machtype: 0 as libc::c_int as libc::c_uint,
                handler: None,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    if !do_unwind {
        return 1 as libc::c_int != 0;
    }
    i = 0 as libc::c_int;
    while (handlers[i as usize].handler).is_some() {
        if (*filedata).file_header.e_machine as libc::c_uint
            == handlers[i as usize].machtype
        {
            return (handlers[i as usize].handler)
                .expect("non-null function pointer")(filedata);
        }
        i += 1;
        i;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\nThe decoding of unwind sections for machine type %s is not currently supported.\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        get_machine_name((*filedata).file_header.e_machine as libc::c_uint),
    );
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn dynamic_section_aarch64_val(mut entry: *mut Elf_Internal_Dyn) {
    match (*entry).d_tag {
        1879048193 | 1879048195 => {}
        _ => {
            print_vma((*entry).d_un.d_ptr, PREFIX_HEX);
        }
    }
    putchar('\n' as i32);
}
unsafe extern "C" fn dynamic_section_mips_val(
    mut filedata: *mut Filedata,
    mut entry: *mut Elf_Internal_Dyn,
) {
    let mut current_block_23: u64;
    match (*entry).d_tag {
        1879048197 => {
            if (*entry).d_un.d_val == 0 as libc::c_int as libc::c_ulong {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"NONE\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                static mut opts: [*const libc::c_char; 15] = [
                    b"QUICKSTART\0" as *const u8 as *const libc::c_char,
                    b"NOTPOT\0" as *const u8 as *const libc::c_char,
                    b"NO_LIBRARY_REPLACEMENT\0" as *const u8 as *const libc::c_char,
                    b"NO_MOVE\0" as *const u8 as *const libc::c_char,
                    b"SGI_ONLY\0" as *const u8 as *const libc::c_char,
                    b"GUARANTEE_INIT\0" as *const u8 as *const libc::c_char,
                    b"DELTA_C_PLUS_PLUS\0" as *const u8 as *const libc::c_char,
                    b"GUARANTEE_START_INIT\0" as *const u8 as *const libc::c_char,
                    b"PIXIE\0" as *const u8 as *const libc::c_char,
                    b"DEFAULT_DELAY_LOAD\0" as *const u8 as *const libc::c_char,
                    b"REQUICKSTART\0" as *const u8 as *const libc::c_char,
                    b"REQUICKSTARTED\0" as *const u8 as *const libc::c_char,
                    b"CORD\0" as *const u8 as *const libc::c_char,
                    b"NO_UNRES_UNDEF\0" as *const u8 as *const libc::c_char,
                    b"RLD_ORDER_SAFE\0" as *const u8 as *const libc::c_char,
                ];
                let mut cnt: libc::c_uint = 0;
                let mut first: bool = 1 as libc::c_int != 0;
                cnt = 0 as libc::c_int as libc::c_uint;
                while (cnt as libc::c_ulong)
                    < (::core::mem::size_of::<[*const libc::c_char; 15]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )
                {
                    if (*entry).d_un.d_val & ((1 as libc::c_int) << cnt) as libc::c_ulong
                        != 0
                    {
                        printf(
                            b"%s%s\0" as *const u8 as *const libc::c_char,
                            if first as libc::c_int != 0 {
                                b"\0" as *const u8 as *const libc::c_char
                            } else {
                                b" \0" as *const u8 as *const libc::c_char
                            },
                            opts[cnt as usize],
                        );
                        first = 0 as libc::c_int != 0;
                    }
                    cnt = cnt.wrapping_add(1);
                    cnt;
                }
            }
            current_block_23 = 11636175345244025579;
        }
        1879048196 => {
            if !((*filedata).dynamic_strings).is_null()
                && (*entry).d_un.d_val < (*filedata).dynamic_strings_length
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Interface Version: %s\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    ((*filedata).dynamic_strings).offset((*entry).d_un.d_val as isize),
                );
            } else {
                let mut buf: [libc::c_char; 40] = [0; 40];
                sprintf(
                    buf.as_mut_ptr(),
                    b"%016lx\0" as *const u8 as *const libc::c_char,
                    (*entry).d_un.d_ptr,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt: %s>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    buf.as_mut_ptr(),
                );
            }
            current_block_23 = 11636175345244025579;
        }
        1879048194 => {
            let mut timebuf: [libc::c_char; 128] = [0; 128];
            let mut tmp: *mut tm = 0 as *mut tm;
            let mut atime: time_t = (*entry).d_un.d_val as time_t;
            tmp = gmtime(&mut atime);
            if tmp.is_null() {
                snprintf(
                    timebuf.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                snprintf(
                    timebuf.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                    b"%04u-%02u-%02uT%02u:%02u:%02u\0" as *const u8
                        as *const libc::c_char,
                    (*tmp).tm_year + 1900 as libc::c_int,
                    (*tmp).tm_mon + 1 as libc::c_int,
                    (*tmp).tm_mday,
                    (*tmp).tm_hour,
                    (*tmp).tm_min,
                    (*tmp).tm_sec,
                );
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Time Stamp: %s\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                timebuf.as_mut_ptr(),
            );
            current_block_23 = 11636175345244025579;
        }
        1879048193 | 1879048202 | 1879048203 | 1879048208 | 1879048209 | 1879048210
        | 1879048212 | 1879048216 | 1879048218 | 1879048220 | 1879048222 | 1879048225
        | 1879048239 => {
            print_vma((*entry).d_un.d_val, DEC);
            current_block_23 = 11636175345244025579;
        }
        1879048246 => {
            (*filedata).dynamic_info_DT_MIPS_XHASH = (*entry).d_un.d_val;
            (*filedata).dynamic_info_DT_GNU_HASH = (*entry).d_un.d_val;
            current_block_23 = 5104169300778226221;
        }
        _ => {
            current_block_23 = 5104169300778226221;
        }
    }
    match current_block_23 {
        5104169300778226221 => {
            print_vma((*entry).d_un.d_ptr, PREFIX_HEX);
        }
        _ => {}
    }
    putchar('\n' as i32);
}
unsafe extern "C" fn dynamic_section_parisc_val(mut entry: *mut Elf_Internal_Dyn) {
    match (*entry).d_tag {
        1610612737 => {
            static mut flags_0: [C2RustUnnamed_31; 17] = [
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x1 as libc::c_int as libc::c_long,
                        str_0: b"HP_DEBUG_PRIVATE\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x2 as libc::c_int as libc::c_long,
                        str_0: b"HP_DEBUG_CALLBACK\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x4 as libc::c_int as libc::c_long,
                        str_0: b"HP_DEBUG_CALLBACK_BOR\0" as *const u8
                            as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x8 as libc::c_int as libc::c_long,
                        str_0: b"HP_NO_ENVVAR\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x10 as libc::c_int as libc::c_long,
                        str_0: b"HP_BIND_NOW\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x20 as libc::c_int as libc::c_long,
                        str_0: b"HP_BIND_NONFATAL\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x40 as libc::c_int as libc::c_long,
                        str_0: b"HP_BIND_VERBOSE\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x80 as libc::c_int as libc::c_long,
                        str_0: b"HP_BIND_RESTRICTED\0" as *const u8
                            as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x100 as libc::c_int as libc::c_long,
                        str_0: b"HP_BIND_SYMBOLIC\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x200 as libc::c_int as libc::c_long,
                        str_0: b"HP_RPATH_FIRST\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x400 as libc::c_int as libc::c_long,
                        str_0: b"HP_BIND_DEPTH_FIRST\0" as *const u8
                            as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x800 as libc::c_int as libc::c_long,
                        str_0: b"HP_GST\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x1000 as libc::c_int as libc::c_long,
                        str_0: b"HP_SHLIB_FIXED\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x2000 as libc::c_int as libc::c_long,
                        str_0: b"HP_MERGE_SHLIB_SEG\0" as *const u8
                            as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x4000 as libc::c_int as libc::c_long,
                        str_0: b"HP_NODELETE\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x8000 as libc::c_int as libc::c_long,
                        str_0: b"HP_GROUP\0" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_31 {
                        bit: 0x10000 as libc::c_int as libc::c_long,
                        str_0: b"HP_PROTECT_LINKAGE_TABLE\0" as *const u8
                            as *const libc::c_char,
                    };
                    init
                },
            ];
            let mut first: bool = 1 as libc::c_int != 0;
            let mut cnt: size_t = 0;
            let mut val: bfd_vma = (*entry).d_un.d_val;
            cnt = 0 as libc::c_int as size_t;
            while cnt
                < (::core::mem::size_of::<[C2RustUnnamed_31; 17]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_31>() as libc::c_ulong,
                    )
            {
                if val & flags_0[cnt as usize].bit as libc::c_ulong != 0 {
                    if !first {
                        putchar(' ' as i32);
                    }
                    fputs(flags_0[cnt as usize].str_0, stdout);
                    first = 0 as libc::c_int != 0;
                    val ^= flags_0[cnt as usize].bit as libc::c_ulong;
                }
                cnt = cnt.wrapping_add(1);
                cnt;
            }
            if val != 0 as libc::c_int as libc::c_ulong || first as libc::c_int != 0 {
                if !first {
                    putchar(' ' as i32);
                }
                print_vma(val, HEX);
            }
        }
        _ => {
            print_vma((*entry).d_un.d_ptr, PREFIX_HEX);
        }
    }
    putchar('\n' as i32);
}
unsafe extern "C" fn print_vms_time(mut vmstime: bfd_int64_t) {
    let mut tm: *mut tm = 0 as *mut tm;
    let mut unxtime: time_t = 0;
    if vmstime as libc::c_longlong
        >= (-(9223372036854775807 as libc::c_long) - 1 as libc::c_int as libc::c_long)
            as libc::c_longlong + 35067168000000000 as libc::c_longlong
    {
        vmstime = ((vmstime as libc::c_longlong - 35067168000000000 as libc::c_longlong)
            / 10000000 as libc::c_int as libc::c_longlong) as bfd_int64_t;
        unxtime = vmstime;
        if unxtime == vmstime {
            tm = gmtime(&mut unxtime);
        }
    }
    if !tm.is_null() {
        printf(
            b"%04u-%02u-%02uT%02u:%02u:%02u\0" as *const u8 as *const libc::c_char,
            (*tm).tm_year + 1900 as libc::c_int,
            (*tm).tm_mon + 1 as libc::c_int,
            (*tm).tm_mday,
            (*tm).tm_hour,
            (*tm).tm_min,
            (*tm).tm_sec,
        );
    }
}
unsafe extern "C" fn dynamic_section_ia64_val(mut entry: *mut Elf_Internal_Dyn) {
    match (*entry).d_tag {
        1879048192 => {
            print_vma((*entry).d_un.d_ptr, PREFIX_HEX);
            printf(b" -- \0" as *const u8 as *const libc::c_char);
            print_vma(
                ((*entry).d_un.d_ptr)
                    .wrapping_add(
                        (3 as libc::c_int * 8 as libc::c_int) as libc::c_ulong,
                    ),
                PREFIX_HEX,
            );
        }
        1610612789 => {
            print_vms_time((*entry).d_un.d_val as bfd_int64_t);
        }
        1610612757 => {
            print_vma((*entry).d_un.d_ptr, PREFIX_HEX);
            if (*entry).d_un.d_val & 0x1 as libc::c_int as libc::c_ulong != 0 {
                printf(b" CALL_DEBUG\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x2 as libc::c_int as libc::c_ulong != 0 {
                printf(b" NOP0BUFS\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x4 as libc::c_int as libc::c_ulong != 0 {
                printf(b" P0IMAGE\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x8 as libc::c_int as libc::c_ulong != 0 {
                printf(b" MKTHREADS\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x10 as libc::c_int as libc::c_ulong != 0 {
                printf(b" UPCALLS\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x20 as libc::c_int as libc::c_ulong != 0 {
                printf(b" IMGSTA\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x40 as libc::c_int as libc::c_ulong != 0 {
                printf(b" INITIALIZE\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x80 as libc::c_int as libc::c_ulong != 0 {
                printf(b" MAIN\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x200 as libc::c_int as libc::c_ulong != 0 {
                printf(b" EXE_INIT\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x400 as libc::c_int as libc::c_ulong != 0 {
                printf(b" TBK_IN_IMG\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x800 as libc::c_int as libc::c_ulong != 0 {
                printf(b" DBG_IN_IMG\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x1000 as libc::c_int as libc::c_ulong != 0 {
                printf(b" TBK_IN_DSF\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x2000 as libc::c_int as libc::c_ulong != 0 {
                printf(b" DBG_IN_DSF\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x4000 as libc::c_int as libc::c_ulong != 0 {
                printf(b" SIGNATURES\0" as *const u8 as *const libc::c_char);
            }
            if (*entry).d_un.d_val & 0x8000 as libc::c_int as libc::c_ulong != 0 {
                printf(b" REL_SEG_OFF\0" as *const u8 as *const libc::c_char);
            }
        }
        _ => {
            print_vma((*entry).d_un.d_ptr, PREFIX_HEX);
        }
    }
    putchar('\n' as i32);
}
unsafe extern "C" fn get_32bit_dynamic_section(mut filedata: *mut Filedata) -> bool {
    let mut edyn: *mut Elf32_External_Dyn = 0 as *mut Elf32_External_Dyn;
    let mut ext: *mut Elf32_External_Dyn = 0 as *mut Elf32_External_Dyn;
    let mut entry: *mut Elf_Internal_Dyn = 0 as *mut Elf_Internal_Dyn;
    edyn = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*filedata).dynamic_addr,
        1 as libc::c_int as bfd_size_type,
        (*filedata).dynamic_size,
        dcgettext(
            0 as *const libc::c_char,
            b"dynamic section\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut Elf32_External_Dyn;
    if edyn.is_null() {
        return 0 as libc::c_int != 0;
    }
    ext = edyn;
    (*filedata).dynamic_nent = 0 as libc::c_int as size_t;
    while ext.offset(1 as libc::c_int as isize) as *mut libc::c_char
        <= (edyn as *mut libc::c_char).offset((*filedata).dynamic_size as isize)
    {
        (*filedata).dynamic_nent = ((*filedata).dynamic_nent).wrapping_add(1);
        (*filedata).dynamic_nent;
        if byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*ext).d_tag).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        ) == 0 as libc::c_int as libc::c_ulong
        {
            break;
        }
        ext = ext.offset(1);
        ext;
    }
    (*filedata)
        .dynamic_section = cmalloc(
        (*filedata).dynamic_nent,
        ::core::mem::size_of::<Elf_Internal_Dyn>() as libc::c_ulong,
    ) as *mut Elf_Internal_Dyn;
    if ((*filedata).dynamic_section).is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory allocating space for %lu dynamic entries\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).dynamic_nent,
        );
        free(edyn as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    ext = edyn;
    entry = (*filedata).dynamic_section;
    while entry < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
    {
        (*entry)
            .d_tag = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*ext).d_tag).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*entry)
            .d_un
            .d_val = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*ext).d_un.d_val).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        ext = ext.offset(1);
        ext;
        entry = entry.offset(1);
        entry;
    }
    free(edyn as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_64bit_dynamic_section(mut filedata: *mut Filedata) -> bool {
    let mut edyn: *mut Elf64_External_Dyn = 0 as *mut Elf64_External_Dyn;
    let mut ext: *mut Elf64_External_Dyn = 0 as *mut Elf64_External_Dyn;
    let mut entry: *mut Elf_Internal_Dyn = 0 as *mut Elf_Internal_Dyn;
    edyn = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*filedata).dynamic_addr,
        1 as libc::c_int as bfd_size_type,
        (*filedata).dynamic_size,
        dcgettext(
            0 as *const libc::c_char,
            b"dynamic section\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut Elf64_External_Dyn;
    if edyn.is_null() {
        return 0 as libc::c_int != 0;
    }
    ext = edyn;
    (*filedata).dynamic_nent = 0 as libc::c_int as size_t;
    while ext.offset(1 as libc::c_int as isize) as *mut libc::c_char
        <= (edyn as *mut libc::c_char).offset((*filedata).dynamic_size as isize)
    {
        (*filedata).dynamic_nent = ((*filedata).dynamic_nent).wrapping_add(1);
        (*filedata).dynamic_nent;
        if byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*ext).d_tag).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        ) == 0 as libc::c_int as libc::c_ulong
        {
            break;
        }
        ext = ext.offset(1);
        ext;
    }
    (*filedata)
        .dynamic_section = cmalloc(
        (*filedata).dynamic_nent,
        ::core::mem::size_of::<Elf_Internal_Dyn>() as libc::c_ulong,
    ) as *mut Elf_Internal_Dyn;
    if ((*filedata).dynamic_section).is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory allocating space for %lu dynamic entries\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).dynamic_nent,
        );
        free(edyn as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    ext = edyn;
    entry = (*filedata).dynamic_section;
    while entry < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
    {
        (*entry)
            .d_tag = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*ext).d_tag).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*entry)
            .d_un
            .d_val = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*ext).d_un.d_val).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        ext = ext.offset(1);
        ext;
        entry = entry.offset(1);
        entry;
    }
    free(edyn as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn print_dynamic_flags(mut flags_0: bfd_vma) {
    let mut first: bool = 1 as libc::c_int != 0;
    while flags_0 != 0 {
        let mut flag: bfd_vma = 0;
        flag = flags_0 & flags_0.wrapping_neg();
        flags_0 &= !flag;
        if first {
            first = 0 as libc::c_int != 0;
        } else {
            putc(' ' as i32, stdout);
        }
        match flag {
            1 => {
                fputs(b"ORIGIN\0" as *const u8 as *const libc::c_char, stdout);
            }
            2 => {
                fputs(b"SYMBOLIC\0" as *const u8 as *const libc::c_char, stdout);
            }
            4 => {
                fputs(b"TEXTREL\0" as *const u8 as *const libc::c_char, stdout);
            }
            8 => {
                fputs(b"BIND_NOW\0" as *const u8 as *const libc::c_char, stdout);
            }
            16 => {
                fputs(b"STATIC_TLS\0" as *const u8 as *const libc::c_char, stdout);
            }
            _ => {
                fputs(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unknown\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    stdout,
                );
            }
        }
    }
    puts(b"\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn get_dynamic_data(
    mut filedata: *mut Filedata,
    mut number: bfd_size_type,
    mut ent_size: libc::c_uint,
) -> *mut bfd_vma {
    let mut e_data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut i_data: *mut bfd_vma = 0 as *mut bfd_vma;
    if (::core::mem::size_of::<size_t>() as libc::c_ulong)
        < ::core::mem::size_of::<bfd_size_type>() as libc::c_ulong && number != number
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Size truncation prevents reading %s elements of size %u\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            bfd_vmatoa(
                b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                number,
            ),
            ent_size,
        );
        return 0 as *mut bfd_vma;
    }
    if (ent_size as libc::c_ulong).wrapping_mul(number) > (*filedata).file_size {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Invalid number of dynamic entries: %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            bfd_vmatoa(
                b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                number,
            ),
        );
        return 0 as *mut bfd_vma;
    }
    e_data = cmalloc(number, ent_size as size_t) as *mut libc::c_uchar;
    if e_data.is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory reading %s dynamic entries\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            bfd_vmatoa(
                b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                number,
            ),
        );
        return 0 as *mut bfd_vma;
    }
    if fread(
        e_data as *mut libc::c_void,
        ent_size as libc::c_ulong,
        number,
        (*filedata).handle,
    ) != number
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to read in %s bytes of dynamic data\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            bfd_vmatoa(
                b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                number.wrapping_mul(ent_size as libc::c_ulong),
            ),
        );
        free(e_data as *mut libc::c_void);
        return 0 as *mut bfd_vma;
    }
    i_data = cmalloc(number, ::core::mem::size_of::<bfd_vma>() as libc::c_ulong)
        as *mut bfd_vma;
    if i_data.is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory allocating space for %s dynamic entries\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            bfd_vmatoa(
                b"u\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                number,
            ),
        );
        free(e_data as *mut libc::c_void);
        return 0 as *mut bfd_vma;
    }
    loop {
        let fresh27 = number;
        number = number.wrapping_sub(1);
        if !(fresh27 != 0) {
            break;
        }
        *i_data
            .offset(
                number as isize,
            ) = byte_get
            .expect(
                "non-null function pointer",
            )(
            e_data.offset(number.wrapping_mul(ent_size as libc::c_ulong) as isize),
            ent_size,
        );
    }
    free(e_data as *mut libc::c_void);
    return i_data;
}
unsafe extern "C" fn get_num_dynamic_syms(mut filedata: *mut Filedata) -> libc::c_ulong {
    let mut current_block: u64;
    let mut num_of_syms: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    if !do_histogram && (!do_using_dynamic || do_dyn_syms as libc::c_int != 0) {
        return num_of_syms;
    }
    if (*filedata).dynamic_info[4 as libc::c_int as usize] != 0 {
        let mut nb: [libc::c_uchar; 8] = [0; 8];
        let mut nc: [libc::c_uchar; 8] = [0; 8];
        let mut hash_ent_size: libc::c_uint = 4 as libc::c_int as libc::c_uint;
        if ((*filedata).file_header.e_machine as libc::c_int == 0x9026 as libc::c_int
            || (*filedata).file_header.e_machine as libc::c_int == 22 as libc::c_int
            || (*filedata).file_header.e_machine as libc::c_int == 0xa390 as libc::c_int)
            && (*filedata).file_header.e_ident[4 as libc::c_int as usize] as libc::c_int
                == 2 as libc::c_int
        {
            hash_ent_size = 8 as libc::c_int as libc::c_uint;
        }
        if fseek(
            (*filedata).handle,
            ((*filedata).archive_file_offset)
                .wrapping_add(
                    offset_from_vma(
                        filedata,
                        (*filedata).dynamic_info[4 as libc::c_int as usize],
                        (::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong)
                            .wrapping_add(
                                ::core::mem::size_of::<[libc::c_uchar; 8]>()
                                    as libc::c_ulong,
                            ),
                    ) as libc::c_ulong,
                ) as libc::c_long,
            0 as libc::c_int,
        ) != 0
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unable to seek to start of dynamic information\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else if fread(
            nb.as_mut_ptr() as *mut libc::c_void,
            hash_ent_size as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            (*filedata).handle,
        ) != 1 as libc::c_int as libc::c_ulong
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Failed to read in number of buckets\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else if fread(
            nc.as_mut_ptr() as *mut libc::c_void,
            hash_ent_size as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            (*filedata).handle,
        ) != 1 as libc::c_int as libc::c_ulong
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Failed to read in number of chains\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            (*filedata)
                .nbuckets = byte_get
                .expect("non-null function pointer")(nb.as_mut_ptr(), hash_ent_size);
            (*filedata)
                .nchains = byte_get
                .expect("non-null function pointer")(nc.as_mut_ptr(), hash_ent_size);
            if (*filedata).nbuckets != 0 as libc::c_int as libc::c_ulong
                && (*filedata).nchains != 0 as libc::c_int as libc::c_ulong
            {
                (*filedata)
                    .buckets = get_dynamic_data(
                    filedata,
                    (*filedata).nbuckets,
                    hash_ent_size,
                );
                (*filedata)
                    .chains = get_dynamic_data(
                    filedata,
                    (*filedata).nchains,
                    hash_ent_size,
                );
                if !((*filedata).buckets).is_null() && !((*filedata).chains).is_null() {
                    num_of_syms = (*filedata).nchains;
                }
            }
        }
        if num_of_syms == 0 as libc::c_int as libc::c_ulong {
            free((*filedata).buckets as *mut libc::c_void);
            (*filedata).buckets = 0 as *mut bfd_vma;
            free((*filedata).chains as *mut libc::c_void);
            (*filedata).chains = 0 as *mut bfd_vma;
            (*filedata).nbuckets = 0 as libc::c_int as bfd_size_type;
        }
    }
    if (*filedata).dynamic_info_DT_GNU_HASH != 0 {
        let mut nb_0: [libc::c_uchar; 16] = [0; 16];
        let mut i: bfd_vma = 0;
        let mut maxchain: bfd_vma = 0xffffffff as libc::c_uint as bfd_vma;
        let mut bitmaskwords: bfd_vma = 0;
        let mut buckets_vma: bfd_vma = 0;
        let mut hn: libc::c_ulong = 0;
        if fseek(
            (*filedata).handle,
            ((*filedata).archive_file_offset)
                .wrapping_add(
                    offset_from_vma(
                        filedata,
                        (*filedata).dynamic_info_DT_GNU_HASH,
                        ::core::mem::size_of::<[libc::c_uchar; 16]>() as libc::c_ulong,
                    ) as libc::c_ulong,
                ) as libc::c_long,
            0 as libc::c_int,
        ) != 0
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unable to seek to start of dynamic information\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            current_block = 11385847528826952104;
        } else if fread(
            nb_0.as_mut_ptr() as *mut libc::c_void,
            16 as libc::c_int as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            (*filedata).handle,
        ) != 1 as libc::c_int as libc::c_ulong
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Failed to read in number of buckets\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            current_block = 11385847528826952104;
        } else {
            (*filedata)
                .ngnubuckets = byte_get
                .expect(
                    "non-null function pointer",
                )(nb_0.as_mut_ptr(), 4 as libc::c_int as libc::c_uint);
            (*filedata)
                .gnusymidx = byte_get
                .expect(
                    "non-null function pointer",
                )(
                nb_0.as_mut_ptr().offset(4 as libc::c_int as isize),
                4 as libc::c_int as libc::c_uint,
            );
            bitmaskwords = byte_get
                .expect(
                    "non-null function pointer",
                )(
                nb_0.as_mut_ptr().offset(8 as libc::c_int as isize),
                4 as libc::c_int as libc::c_uint,
            );
            buckets_vma = ((*filedata).dynamic_info_DT_GNU_HASH)
                .wrapping_add(16 as libc::c_int as libc::c_ulong);
            if is_32bit_elf {
                buckets_vma = (buckets_vma as libc::c_ulong)
                    .wrapping_add(
                        bitmaskwords.wrapping_mul(4 as libc::c_int as libc::c_ulong),
                    ) as bfd_vma as bfd_vma;
            } else {
                buckets_vma = (buckets_vma as libc::c_ulong)
                    .wrapping_add(
                        bitmaskwords.wrapping_mul(8 as libc::c_int as libc::c_ulong),
                    ) as bfd_vma as bfd_vma;
            }
            if fseek(
                (*filedata).handle,
                ((*filedata).archive_file_offset)
                    .wrapping_add(
                        offset_from_vma(
                            filedata,
                            buckets_vma,
                            4 as libc::c_int as bfd_size_type,
                        ) as libc::c_ulong,
                    ) as libc::c_long,
                0 as libc::c_int,
            ) != 0
            {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unable to seek to start of dynamic information\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                current_block = 11385847528826952104;
            } else {
                (*filedata)
                    .gnubuckets = get_dynamic_data(
                    filedata,
                    (*filedata).ngnubuckets,
                    4 as libc::c_int as libc::c_uint,
                );
                if ((*filedata).gnubuckets).is_null() {
                    current_block = 11385847528826952104;
                } else {
                    i = 0 as libc::c_int as bfd_vma;
                    loop {
                        if !(i < (*filedata).ngnubuckets) {
                            current_block = 12997042908615822766;
                            break;
                        }
                        if *((*filedata).gnubuckets).offset(i as isize)
                            != 0 as libc::c_int as libc::c_ulong
                        {
                            if *((*filedata).gnubuckets).offset(i as isize)
                                < (*filedata).gnusymidx
                            {
                                current_block = 11385847528826952104;
                                break;
                            }
                            if maxchain == 0xffffffff as libc::c_uint as libc::c_ulong
                                || *((*filedata).gnubuckets).offset(i as isize) > maxchain
                            {
                                maxchain = *((*filedata).gnubuckets).offset(i as isize);
                            }
                        }
                        i = i.wrapping_add(1);
                        i;
                    }
                    match current_block {
                        11385847528826952104 => {}
                        _ => {
                            if maxchain == 0xffffffff as libc::c_uint as libc::c_ulong {
                                current_block = 11385847528826952104;
                            } else {
                                maxchain = (maxchain as libc::c_ulong)
                                    .wrapping_sub((*filedata).gnusymidx) as bfd_vma as bfd_vma;
                                if fseek(
                                    (*filedata).handle,
                                    ((*filedata).archive_file_offset)
                                        .wrapping_add(
                                            offset_from_vma(
                                                filedata,
                                                buckets_vma
                                                    .wrapping_add(
                                                        (4 as libc::c_int as libc::c_ulong)
                                                            .wrapping_mul(
                                                                ((*filedata).ngnubuckets).wrapping_add(maxchain),
                                                            ),
                                                    ),
                                                4 as libc::c_int as bfd_size_type,
                                            ) as libc::c_ulong,
                                        ) as libc::c_long,
                                    0 as libc::c_int,
                                ) != 0
                                {
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Unable to seek to start of dynamic information\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    current_block = 11385847528826952104;
                                } else {
                                    loop {
                                        if fread(
                                            nb_0.as_mut_ptr() as *mut libc::c_void,
                                            4 as libc::c_int as libc::c_ulong,
                                            1 as libc::c_int as libc::c_ulong,
                                            (*filedata).handle,
                                        ) != 1 as libc::c_int as libc::c_ulong
                                        {
                                            error(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"Failed to determine last chain length\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                            );
                                            current_block = 11385847528826952104;
                                            break;
                                        } else {
                                            if maxchain.wrapping_add(1 as libc::c_int as libc::c_ulong)
                                                == 0 as libc::c_int as libc::c_ulong
                                            {
                                                current_block = 11385847528826952104;
                                                break;
                                            }
                                            maxchain = maxchain.wrapping_add(1);
                                            maxchain;
                                            if !(byte_get
                                                .expect(
                                                    "non-null function pointer",
                                                )(nb_0.as_mut_ptr(), 4 as libc::c_int as libc::c_uint)
                                                & 1 as libc::c_int as libc::c_ulong
                                                == 0 as libc::c_int as libc::c_ulong)
                                            {
                                                current_block = 7420279277351916581;
                                                break;
                                            }
                                        }
                                    }
                                    match current_block {
                                        11385847528826952104 => {}
                                        _ => {
                                            if fseek(
                                                (*filedata).handle,
                                                ((*filedata).archive_file_offset)
                                                    .wrapping_add(
                                                        offset_from_vma(
                                                            filedata,
                                                            buckets_vma
                                                                .wrapping_add(
                                                                    (4 as libc::c_int as libc::c_ulong)
                                                                        .wrapping_mul((*filedata).ngnubuckets),
                                                                ),
                                                            4 as libc::c_int as bfd_size_type,
                                                        ) as libc::c_ulong,
                                                    ) as libc::c_long,
                                                0 as libc::c_int,
                                            ) != 0
                                            {
                                                error(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"Unable to seek to start of dynamic information\n\0"
                                                            as *const u8 as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                );
                                                current_block = 11385847528826952104;
                                            } else {
                                                (*filedata)
                                                    .gnuchains = get_dynamic_data(
                                                    filedata,
                                                    maxchain,
                                                    4 as libc::c_int as libc::c_uint,
                                                );
                                                (*filedata).ngnuchains = maxchain;
                                                if ((*filedata).gnuchains).is_null() {
                                                    current_block = 11385847528826952104;
                                                } else {
                                                    if (*filedata).dynamic_info_DT_MIPS_XHASH != 0 {
                                                        if fseek(
                                                            (*filedata).handle,
                                                            ((*filedata).archive_file_offset)
                                                                .wrapping_add(
                                                                    offset_from_vma(
                                                                        filedata,
                                                                        buckets_vma
                                                                            .wrapping_add(
                                                                                (4 as libc::c_int as libc::c_ulong)
                                                                                    .wrapping_mul(
                                                                                        ((*filedata).ngnubuckets).wrapping_add(maxchain),
                                                                                    ),
                                                                            ),
                                                                        4 as libc::c_int as bfd_size_type,
                                                                    ) as libc::c_ulong,
                                                                ) as libc::c_long,
                                                            0 as libc::c_int,
                                                        ) != 0
                                                        {
                                                            error(
                                                                dcgettext(
                                                                    0 as *const libc::c_char,
                                                                    b"Unable to seek to start of dynamic information\n\0"
                                                                        as *const u8 as *const libc::c_char,
                                                                    5 as libc::c_int,
                                                                ),
                                                            );
                                                            current_block = 11385847528826952104;
                                                        } else {
                                                            (*filedata)
                                                                .mipsxlat = get_dynamic_data(
                                                                filedata,
                                                                maxchain,
                                                                4 as libc::c_int as libc::c_uint,
                                                            );
                                                            if ((*filedata).mipsxlat).is_null() {
                                                                current_block = 11385847528826952104;
                                                            } else {
                                                                current_block = 16203797167131938757;
                                                            }
                                                        }
                                                    } else {
                                                        current_block = 16203797167131938757;
                                                    }
                                                    match current_block {
                                                        11385847528826952104 => {}
                                                        _ => {
                                                            hn = 0 as libc::c_int as libc::c_ulong;
                                                            while hn < (*filedata).ngnubuckets {
                                                                if *((*filedata).gnubuckets).offset(hn as isize)
                                                                    != 0 as libc::c_int as libc::c_ulong
                                                                {
                                                                    let mut si: bfd_vma = *((*filedata).gnubuckets)
                                                                        .offset(hn as isize);
                                                                    let mut off: bfd_vma = si
                                                                        .wrapping_sub((*filedata).gnusymidx);
                                                                    loop {
                                                                        if (*filedata).dynamic_info_DT_MIPS_XHASH != 0 {
                                                                            if off < (*filedata).ngnuchains
                                                                                && *((*filedata).mipsxlat).offset(off as isize)
                                                                                    >= num_of_syms
                                                                            {
                                                                                num_of_syms = (*((*filedata).mipsxlat).offset(off as isize))
                                                                                    .wrapping_add(1 as libc::c_int as libc::c_ulong);
                                                                            }
                                                                        } else if si >= num_of_syms {
                                                                            num_of_syms = si
                                                                                .wrapping_add(1 as libc::c_int as libc::c_ulong);
                                                                        }
                                                                        si = si.wrapping_add(1);
                                                                        si;
                                                                        if !(off < (*filedata).ngnuchains
                                                                            && {
                                                                                let fresh28 = off;
                                                                                off = off.wrapping_add(1);
                                                                                *((*filedata).gnuchains).offset(fresh28 as isize)
                                                                                    & 1 as libc::c_int as libc::c_ulong
                                                                                    == 0 as libc::c_int as libc::c_ulong
                                                                            })
                                                                        {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                hn = hn.wrapping_add(1);
                                                                hn;
                                                            }
                                                            if num_of_syms == 0 as libc::c_int as libc::c_ulong {
                                                                current_block = 11385847528826952104;
                                                            } else {
                                                                current_block = 17167606947040001567;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        match current_block {
            17167606947040001567 => {}
            _ => {
                free((*filedata).mipsxlat as *mut libc::c_void);
                (*filedata).mipsxlat = 0 as *mut bfd_vma;
                free((*filedata).gnuchains as *mut libc::c_void);
                (*filedata).gnuchains = 0 as *mut bfd_vma;
                free((*filedata).gnubuckets as *mut libc::c_void);
                (*filedata).gnubuckets = 0 as *mut bfd_vma;
                (*filedata).ngnubuckets = 0 as libc::c_int as bfd_size_type;
                (*filedata).ngnuchains = 0 as libc::c_int as bfd_size_type;
            }
        }
    }
    return num_of_syms;
}
unsafe extern "C" fn process_dynamic_section(mut filedata: *mut Filedata) -> bool {
    let mut entry: *mut Elf_Internal_Dyn = 0 as *mut Elf_Internal_Dyn;
    if (*filedata).dynamic_size <= 1 as libc::c_int as libc::c_ulong {
        if do_dynamic {
            if (*filedata).is_separate {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere is no dynamic section in linked file '%s'.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_name,
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nThere is no dynamic section in this file.\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
        }
        return 1 as libc::c_int != 0;
    }
    if !get_dynamic_section(filedata) {
        return 0 as libc::c_int != 0;
    }
    if ((*filedata).dynamic_symbols).is_null() || do_histogram as libc::c_int != 0 {
        let mut num_of_syms: libc::c_ulong = 0;
        entry = (*filedata).dynamic_section;
        while entry
            < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
        {
            if (*entry).d_tag == 6 as libc::c_int as libc::c_ulong {
                (*filedata)
                    .dynamic_info[6 as libc::c_int as usize] = (*entry).d_un.d_val;
            } else if (*entry).d_tag == 11 as libc::c_int as libc::c_ulong {
                (*filedata)
                    .dynamic_info[11 as libc::c_int as usize] = (*entry).d_un.d_val;
            } else if (*entry).d_tag == 4 as libc::c_int as libc::c_ulong {
                (*filedata)
                    .dynamic_info[4 as libc::c_int as usize] = (*entry).d_un.d_val;
            } else if (*entry).d_tag == 0x6ffffef5 as libc::c_int as libc::c_ulong {
                (*filedata).dynamic_info_DT_GNU_HASH = (*entry).d_un.d_val;
            } else if ((*filedata).file_header.e_machine as libc::c_int
                == 8 as libc::c_int
                || (*filedata).file_header.e_machine as libc::c_int == 10 as libc::c_int)
                && (*entry).d_tag == 0x70000036 as libc::c_int as libc::c_ulong
            {
                (*filedata).dynamic_info_DT_MIPS_XHASH = (*entry).d_un.d_val;
                (*filedata).dynamic_info_DT_GNU_HASH = (*entry).d_un.d_val;
            }
            entry = entry.offset(1);
            entry;
        }
        num_of_syms = get_num_dynamic_syms(filedata);
        if num_of_syms != 0 as libc::c_int as libc::c_ulong
            && ((*filedata).dynamic_symbols).is_null()
            && (*filedata).dynamic_info[6 as libc::c_int as usize] != 0
            && (*filedata).dynamic_info[11 as libc::c_int as usize] != 0
        {
            let mut seg: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
            let mut vma: bfd_vma = (*filedata).dynamic_info[6 as libc::c_int as usize];
            if !get_program_headers(filedata) {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Cannot interpret virtual addresses without program headers.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            seg = (*filedata).program_headers;
            while seg
                < ((*filedata).program_headers)
                    .offset((*filedata).file_header.e_phnum as isize)
            {
                if !((*seg).p_type != 1 as libc::c_int as libc::c_ulong) {
                    if ((*seg).p_offset).wrapping_add((*seg).p_filesz)
                        > (*filedata).file_size
                    {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Invalid PT_LOAD entry\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        return 0 as libc::c_int != 0;
                    }
                    if vma >= (*seg).p_vaddr & ((*seg).p_align).wrapping_neg()
                        && vma < ((*seg).p_vaddr).wrapping_add((*seg).p_filesz)
                    {
                        let mut section: Elf_Internal_Shdr = Elf_Internal_Shdr {
                            sh_name: 0,
                            sh_type: 0,
                            sh_flags: 0,
                            sh_addr: 0,
                            sh_offset: 0,
                            sh_size: 0,
                            sh_link: 0,
                            sh_info: 0,
                            sh_addralign: 0,
                            sh_entsize: 0,
                            bfd_section: 0 as *mut asection,
                            contents: 0 as *mut libc::c_uchar,
                        };
                        section
                            .sh_offset = vma
                            .wrapping_sub((*seg).p_vaddr)
                            .wrapping_add((*seg).p_offset) as file_ptr;
                        section
                            .sh_size = num_of_syms
                            .wrapping_mul(
                                (*filedata).dynamic_info[11 as libc::c_int as usize],
                            );
                        section
                            .sh_entsize = (*filedata)
                            .dynamic_info[11 as libc::c_int as usize];
                        if do_checks as libc::c_int != 0
                            && !((*filedata).dynamic_symtab_section).is_null()
                            && ((*(*filedata).dynamic_symtab_section).sh_offset
                                != section.sh_offset
                                || (*(*filedata).dynamic_symtab_section).sh_size
                                    != section.sh_size
                                || (*(*filedata).dynamic_symtab_section).sh_entsize
                                    != section.sh_entsize)
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"the .dynsym section doesn't match the DT_SYMTAB and DT_SYMENT tags\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        section
                            .sh_name = (*filedata).string_table_length as libc::c_uint;
                        (*filedata)
                            .dynamic_symbols = get_elf_symbols(
                            filedata,
                            &mut section,
                            &mut (*filedata).num_dynamic_syms,
                        );
                        if ((*filedata).dynamic_symbols).is_null()
                            || (*filedata).num_dynamic_syms != num_of_syms
                        {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Corrupt DT_SYMTAB dynamic entry\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            return 0 as libc::c_int != 0;
                        }
                        break;
                    }
                }
                seg = seg.offset(1);
                seg;
            }
        }
    }
    if ((*filedata).dynamic_strings).is_null() {
        entry = (*filedata).dynamic_section;
        while entry
            < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
        {
            if (*entry).d_tag == 5 as libc::c_int as libc::c_ulong {
                (*filedata)
                    .dynamic_info[5 as libc::c_int as usize] = (*entry).d_un.d_val;
            }
            if (*entry).d_tag == 10 as libc::c_int as libc::c_ulong {
                (*filedata)
                    .dynamic_info[10 as libc::c_int as usize] = (*entry).d_un.d_val;
            }
            if (*filedata).dynamic_info[5 as libc::c_int as usize] != 0
                && (*filedata).dynamic_info[10 as libc::c_int as usize] != 0
            {
                let mut offset: libc::c_ulong = 0;
                let mut str_tab_len: bfd_size_type = (*filedata)
                    .dynamic_info[10 as libc::c_int as usize];
                offset = offset_from_vma(
                    filedata,
                    (*filedata).dynamic_info[5 as libc::c_int as usize],
                    str_tab_len,
                ) as libc::c_ulong;
                if do_checks as libc::c_int != 0
                    && !((*filedata).dynamic_strtab_section).is_null()
                    && ((*(*filedata).dynamic_strtab_section).sh_offset
                        != offset as file_ptr
                        || (*(*filedata).dynamic_strtab_section).sh_size != str_tab_len)
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"the .dynstr section doesn't match the DT_STRTAB and DT_STRSZ tags\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                (*filedata)
                    .dynamic_strings = get_data(
                    0 as *mut libc::c_void,
                    filedata,
                    offset,
                    1 as libc::c_int as bfd_size_type,
                    str_tab_len,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"dynamic string table\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                ) as *mut libc::c_char;
                if ((*filedata).dynamic_strings).is_null() {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Corrupt DT_STRTAB dynamic entry\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    break;
                } else {
                    (*filedata).dynamic_strings_length = str_tab_len;
                    break;
                }
            } else {
                entry = entry.offset(1);
                entry;
            }
        }
    }
    if ((*filedata).dynamic_syminfo).is_null() {
        let mut syminsz: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
        entry = (*filedata).dynamic_section;
        while entry
            < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
        {
            if (*entry).d_tag == 0x6ffffdff as libc::c_int as libc::c_ulong {
                if ::core::mem::size_of::<Elf_External_Syminfo>() as libc::c_ulong
                    != (*entry).d_un.d_val
                {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Bad value (%d) for SYMINENT entry\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*entry).d_un.d_val as libc::c_int,
                    );
                }
            } else if (*entry).d_tag == 0x6ffffdfe as libc::c_int as libc::c_ulong {
                syminsz = (*entry).d_un.d_val;
            } else if (*entry).d_tag == 0x6ffffeff as libc::c_int as libc::c_ulong {
                (*filedata)
                    .dynamic_syminfo_offset = offset_from_vma(
                    filedata,
                    (*entry).d_un.d_val,
                    syminsz,
                ) as libc::c_ulong;
            }
            entry = entry.offset(1);
            entry;
        }
        if (*filedata).dynamic_syminfo_offset != 0 as libc::c_int as libc::c_ulong
            && syminsz != 0 as libc::c_int as libc::c_ulong
        {
            let mut extsyminfo: *mut Elf_External_Syminfo = 0
                as *mut Elf_External_Syminfo;
            let mut extsym: *mut Elf_External_Syminfo = 0 as *mut Elf_External_Syminfo;
            let mut syminfo: *mut Elf_Internal_Syminfo = 0 as *mut Elf_Internal_Syminfo;
            extsyminfo = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*filedata).dynamic_syminfo_offset,
                1 as libc::c_int as bfd_size_type,
                syminsz,
                dcgettext(
                    0 as *const libc::c_char,
                    b"symbol information\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut Elf_External_Syminfo;
            if extsyminfo.is_null() {
                return 0 as libc::c_int != 0;
            }
            if !((*filedata).dynamic_syminfo).is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Multiple dynamic symbol information sections found\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                free((*filedata).dynamic_syminfo as *mut libc::c_void);
            }
            (*filedata).dynamic_syminfo = malloc(syminsz) as *mut Elf_Internal_Syminfo;
            if ((*filedata).dynamic_syminfo).is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Out of memory allocating %lu bytes for dynamic symbol info\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    syminsz,
                );
                return 0 as libc::c_int != 0;
            }
            (*filedata)
                .dynamic_syminfo_nent = syminsz
                .wrapping_div(
                    ::core::mem::size_of::<Elf_External_Syminfo>() as libc::c_ulong,
                ) as libc::c_uint;
            syminfo = (*filedata).dynamic_syminfo;
            extsym = extsyminfo;
            while syminfo
                < ((*filedata).dynamic_syminfo)
                    .offset((*filedata).dynamic_syminfo_nent as isize)
            {
                (*syminfo)
                    .si_boundto = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*extsym).si_boundto).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_ushort;
                (*syminfo)
                    .si_flags = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*extsym).si_flags).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_ushort;
                syminfo = syminfo.offset(1);
                syminfo;
                extsym = extsym.offset(1);
                extsym;
            }
            free(extsyminfo as *mut libc::c_void);
        }
    }
    if do_dynamic as libc::c_int != 0 && (*filedata).dynamic_addr != 0 {
        if (*filedata).dynamic_nent == 1 as libc::c_int as libc::c_ulong {
            if (*filedata).is_separate {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nIn linked file '%s' the dynamic section at offset 0x%lx contains 1 entry:\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_name,
                    (*filedata).dynamic_addr,
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\nDynamic section at offset 0x%lx contains 1 entry:\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).dynamic_addr,
                );
            }
        } else if (*filedata).is_separate {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nIn linked file '%s' the dynamic section at offset 0x%lx contains %lu entries:\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*filedata).file_name,
                (*filedata).dynamic_addr,
                (*filedata).dynamic_nent,
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nDynamic section at offset 0x%lx contains %lu entries:\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*filedata).dynamic_addr,
                (*filedata).dynamic_nent,
            );
        }
    }
    if do_dynamic {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Tag        Type                         Name/Value\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    entry = (*filedata).dynamic_section;
    while entry < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
    {
        if do_dynamic {
            let mut dtype: *const libc::c_char = 0 as *const libc::c_char;
            putchar(' ' as i32);
            print_vma((*entry).d_tag, FULL_HEX);
            dtype = get_dynamic_type(filedata, (*entry).d_tag);
            printf(
                b" (%s)%*s\0" as *const u8 as *const libc::c_char,
                dtype,
                (if is_32bit_elf as libc::c_int != 0 {
                    27 as libc::c_int
                } else {
                    19 as libc::c_int
                }) - strlen(dtype) as libc::c_int,
                b" \0" as *const u8 as *const libc::c_char,
            );
        }
        let mut current_block_369: u64;
        match (*entry).d_tag {
            30 => {
                if do_dynamic {
                    print_dynamic_flags((*entry).d_un.d_val);
                }
                current_block_369 = 4841263011268485695;
            }
            2147483645 | 2147483647 | 1879047930 | 1879047931 | 1879047932 => {
                if do_dynamic {
                    match (*entry).d_tag {
                        2147483645 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Auxiliary library\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        2147483647 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Filter library\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        1879047930 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Configuration file\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        1879047931 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Dependency audit library\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        1879047932 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Audit library\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        _ => {}
                    }
                    if !((*filedata).dynamic_strings).is_null()
                        && (*entry).d_un.d_val < (*filedata).dynamic_strings_length
                    {
                        printf(
                            b": [%s]\n\0" as *const u8 as *const libc::c_char,
                            ((*filedata).dynamic_strings)
                                .offset((*entry).d_un.d_val as isize),
                        );
                    } else {
                        printf(b": \0" as *const u8 as *const libc::c_char);
                        print_vma((*entry).d_un.d_val, PREFIX_HEX);
                        putchar('\n' as i32);
                    }
                }
                current_block_369 = 4841263011268485695;
            }
            1879047676 => {
                if do_dynamic {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Flags:\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    if (*entry).d_un.d_val == 0 as libc::c_int as libc::c_ulong {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" None\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        let mut val: libc::c_ulong = (*entry).d_un.d_val;
                        if val & 0x1 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" PARINIT\0" as *const u8 as *const libc::c_char);
                            val ^= 0x1 as libc::c_int as libc::c_ulong;
                        }
                        if val & 0x2 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" CONFEXP\0" as *const u8 as *const libc::c_char);
                            val ^= 0x2 as libc::c_int as libc::c_ulong;
                        }
                        if val != 0 as libc::c_int as libc::c_ulong {
                            printf(b" %lx\0" as *const u8 as *const libc::c_char, val);
                        }
                        puts(b"\0" as *const u8 as *const libc::c_char);
                    }
                }
                current_block_369 = 4841263011268485695;
            }
            1879047677 => {
                if do_dynamic {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Flags:\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    if (*entry).d_un.d_val == 0 as libc::c_int as libc::c_ulong {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" None\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        let mut val_0: libc::c_ulong = (*entry).d_un.d_val;
                        if val_0 & 0x1 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" LAZYLOAD\0" as *const u8 as *const libc::c_char);
                            val_0 ^= 0x1 as libc::c_int as libc::c_ulong;
                        }
                        if val_0 & 0x2 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" GROUPPERM\0" as *const u8 as *const libc::c_char);
                            val_0 ^= 0x2 as libc::c_int as libc::c_ulong;
                        }
                        if val_0 != 0 as libc::c_int as libc::c_ulong {
                            printf(b" %lx\0" as *const u8 as *const libc::c_char, val_0);
                        }
                        puts(b"\0" as *const u8 as *const libc::c_char);
                    }
                }
                current_block_369 = 4841263011268485695;
            }
            1879048187 => {
                if do_dynamic {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Flags:\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    if (*entry).d_un.d_val == 0 as libc::c_int as libc::c_ulong {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" None\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        let mut val_1: libc::c_ulong = (*entry).d_un.d_val;
                        if val_1 & 0x1 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NOW\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x1 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x2 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" GLOBAL\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x2 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x4 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" GROUP\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x4 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x8 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NODELETE\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x8 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x10 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" LOADFLTR\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x10 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x20 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" INITFIRST\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x20 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x40 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NOOPEN\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x40 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x80 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" ORIGIN\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x80 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x100 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" DIRECT\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x100 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x200 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" TRANS\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x200 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x400 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" INTERPOSE\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x400 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x800 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NODEFLIB\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x800 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x1000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NODUMP\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x1000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x2000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" CONFALT\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x2000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x4000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" ENDFILTEE\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x4000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x8000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" DISPRELDNE\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x8000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x10000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" DISPRELPND\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x10000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x20000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NODIRECT\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x20000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x40000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" IGNMULDEF\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x40000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x80000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NOKSYMS\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x80000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x100000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NOHDR\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x100000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x200000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" EDITED\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x200000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x400000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NORELOC\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x400000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x800000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" SYMINTPOSE\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x800000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x1000000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" GLOBAUDIT\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x1000000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x2000000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" SINGLETON\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x2000000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x4000000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" STUB\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x4000000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x8000000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" PIE\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x8000000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x10000000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" KMOD\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x10000000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x20000000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" WEAKFILTER\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x20000000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 & 0x40000000 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" NOCOMMON\0" as *const u8 as *const libc::c_char);
                            val_1 ^= 0x40000000 as libc::c_int as libc::c_ulong;
                        }
                        if val_1 != 0 as libc::c_int as libc::c_ulong {
                            printf(b" %lx\0" as *const u8 as *const libc::c_char, val_1);
                        }
                        puts(b"\0" as *const u8 as *const libc::c_char);
                    }
                }
                current_block_369 = 4841263011268485695;
            }
            20 => {
                (*filedata).dynamic_info[(*entry).d_tag as usize] = (*entry).d_un.d_val;
                if do_dynamic {
                    puts(get_dynamic_type(filedata, (*entry).d_un.d_val));
                }
                current_block_369 = 4841263011268485695;
            }
            0 | 1 | 3 | 4 | 5 | 6 | 7 | 12 | 13 | 14 | 15 | 16 | 17 | 21 | 22 | 23
            | 29 => {
                (*filedata).dynamic_info[(*entry).d_tag as usize] = (*entry).d_un.d_val;
                if do_dynamic {
                    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
                    if !((*filedata).dynamic_strings).is_null()
                        && (*entry).d_un.d_val < (*filedata).dynamic_strings_length
                    {
                        name = ((*filedata).dynamic_strings)
                            .offset((*entry).d_un.d_val as isize);
                    } else {
                        name = 0 as *mut libc::c_char;
                    }
                    if !name.is_null() {
                        match (*entry).d_tag {
                            1 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Shared library: [%s]\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    name,
                                );
                                if !((*filedata).program_interpreter).is_null()
                                    && strcmp(name, (*filedata).program_interpreter)
                                        == 0 as libc::c_int
                                {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" program interpreter\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                }
                            }
                            14 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Library soname: [%s]\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    name,
                                );
                            }
                            15 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Library rpath: [%s]\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    name,
                                );
                            }
                            29 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Library runpath: [%s]\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    name,
                                );
                            }
                            _ => {
                                print_vma((*entry).d_un.d_val, PREFIX_HEX);
                            }
                        }
                    } else {
                        print_vma((*entry).d_un.d_val, PREFIX_HEX);
                    }
                    putchar('\n' as i32);
                }
                current_block_369 = 4841263011268485695;
            }
            2 | 8 | 10 | 18 | 9 | 11 | 19 => {
                (*filedata).dynamic_info[(*entry).d_tag as usize] = (*entry).d_un.d_val;
                current_block_369 = 8195103219542253410;
            }
            1879047673 | 1879047674 | 1879047675 | 27 | 28 | 1879047670 | 1879047671 => {
                current_block_369 = 8195103219542253410;
            }
            1879048189 | 1879048191 | 1879048185 | 1879048186 => {
                if do_dynamic {
                    print_vma((*entry).d_un.d_val, UNSIGNED);
                    putchar('\n' as i32);
                }
                current_block_369 = 4841263011268485695;
            }
            1879047678 | 1879047679 | 1879047935 | 2147483646 | 25 | 26 => {
                if do_dynamic {
                    if (*entry).d_tag == 0x7ffffffe as libc::c_int as libc::c_ulong
                        && (!((*filedata).dynamic_strings).is_null()
                            && (*entry).d_un.d_val < (*filedata).dynamic_strings_length)
                    {
                        let mut name_0: *mut libc::c_char = ((*filedata).dynamic_strings)
                            .offset((*entry).d_un.d_val as isize);
                        if *name_0 != 0 {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Not needed object: [%s]\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                name_0,
                            );
                            current_block_369 = 4841263011268485695;
                        } else {
                            current_block_369 = 17854146808697783763;
                        }
                    } else {
                        current_block_369 = 17854146808697783763;
                    }
                    match current_block_369 {
                        4841263011268485695 => {}
                        _ => {
                            print_vma((*entry).d_un.d_val, PREFIX_HEX);
                            putchar('\n' as i32);
                            current_block_369 = 4841263011268485695;
                        }
                    }
                } else {
                    current_block_369 = 4841263011268485695;
                }
            }
            24 => {
                if do_dynamic {
                    putchar('\n' as i32);
                }
                current_block_369 = 4841263011268485695;
            }
            1879047669 => {
                if do_dynamic {
                    let mut tmp: *mut tm = 0 as *mut tm;
                    let mut atime: time_t = (*entry).d_un.d_val as time_t;
                    tmp = gmtime(&mut atime);
                    if tmp.is_null() {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"<corrupt time val: %lx\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            atime as libc::c_ulong,
                        );
                    } else {
                        printf(
                            b"%04u-%02u-%02uT%02u:%02u:%02u\n\0" as *const u8
                                as *const libc::c_char,
                            (*tmp).tm_year + 1900 as libc::c_int,
                            (*tmp).tm_mon + 1 as libc::c_int,
                            (*tmp).tm_mday,
                            (*tmp).tm_hour,
                            (*tmp).tm_min,
                            (*tmp).tm_sec,
                        );
                    }
                }
                current_block_369 = 4841263011268485695;
            }
            1879047925 => {
                (*filedata).dynamic_info_DT_GNU_HASH = (*entry).d_un.d_val;
                if do_dynamic {
                    print_vma((*entry).d_un.d_val, PREFIX_HEX);
                    putchar('\n' as i32);
                }
                current_block_369 = 4841263011268485695;
            }
            1879047668 => {
                if do_dynamic {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Flags:\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    if (*entry).d_un.d_val == 0 as libc::c_int as libc::c_ulong {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" None\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        let mut val_2: libc::c_ulong = (*entry).d_un.d_val;
                        if val_2 & 0x1 as libc::c_int as libc::c_ulong != 0 {
                            printf(b" UNIQUE\0" as *const u8 as *const libc::c_char);
                            val_2 ^= 0x1 as libc::c_int as libc::c_ulong;
                        }
                        if val_2 != 0 as libc::c_int as libc::c_ulong {
                            printf(b" %lx\0" as *const u8 as *const libc::c_char, val_2);
                        }
                        puts(b"\0" as *const u8 as *const libc::c_char);
                    }
                }
                current_block_369 = 4841263011268485695;
            }
            _ => {
                if (*entry).d_tag >= 0x6ffffff0 as libc::c_int as libc::c_ulong
                    && (*entry).d_tag <= 0x6fffffff as libc::c_int as libc::c_ulong
                {
                    (*filedata)
                        .version_info[(0x6fffffff as libc::c_int as libc::c_ulong)
                        .wrapping_sub((*entry).d_tag) as usize] = (*entry).d_un.d_val;
                }
                if do_dynamic {
                    match (*filedata).file_header.e_machine as libc::c_int {
                        183 => {
                            dynamic_section_aarch64_val(entry);
                        }
                        8 | 10 => {
                            dynamic_section_mips_val(filedata, entry);
                        }
                        15 => {
                            dynamic_section_parisc_val(entry);
                        }
                        50 => {
                            dynamic_section_ia64_val(entry);
                        }
                        _ => {
                            print_vma((*entry).d_un.d_val, PREFIX_HEX);
                            putchar('\n' as i32);
                        }
                    }
                }
                current_block_369 = 4841263011268485695;
            }
        }
        match current_block_369 {
            8195103219542253410 => {
                if do_dynamic {
                    print_vma((*entry).d_un.d_val, UNSIGNED);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" (bytes)\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            _ => {}
        }
        entry = entry.offset(1);
        entry;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_ver_flags(mut flags_0: libc::c_uint) -> *mut libc::c_char {
    static mut buff: [libc::c_char; 128] = [0; 128];
    buff[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    if flags_0 == 0 as libc::c_int as libc::c_uint {
        return dcgettext(
            0 as *const libc::c_char,
            b"none\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        );
    }
    if flags_0 & 0x1 as libc::c_int as libc::c_uint != 0 {
        strcat(buff.as_mut_ptr(), b"BASE\0" as *const u8 as *const libc::c_char);
    }
    if flags_0 & 0x2 as libc::c_int as libc::c_uint != 0 {
        if flags_0 & 0x1 as libc::c_int as libc::c_uint != 0 {
            strcat(buff.as_mut_ptr(), b" | \0" as *const u8 as *const libc::c_char);
        }
        strcat(buff.as_mut_ptr(), b"WEAK\0" as *const u8 as *const libc::c_char);
    }
    if flags_0 & 0x4 as libc::c_int as libc::c_uint != 0 {
        if flags_0 & (0x1 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint != 0 {
            strcat(buff.as_mut_ptr(), b" | \0" as *const u8 as *const libc::c_char);
        }
        strcat(buff.as_mut_ptr(), b"INFO\0" as *const u8 as *const libc::c_char);
    }
    if flags_0
        & !(0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int) as libc::c_uint
        != 0
    {
        if flags_0
            & (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int)
                as libc::c_uint != 0
        {
            strcat(buff.as_mut_ptr(), b" | \0" as *const u8 as *const libc::c_char);
        }
        strcat(
            buff.as_mut_ptr(),
            dcgettext(
                0 as *const libc::c_char,
                b"<unknown>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    return buff.as_mut_ptr();
}
unsafe extern "C" fn process_version_sections(mut filedata: *mut Filedata) -> bool {
    let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_uint = 0;
    let mut found: bool = 0 as libc::c_int != 0;
    if !do_version {
        return 1 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as libc::c_uint;
    section = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum {
        match (*section).sh_type {
            1879048189 => {
                let mut edefs: *mut Elf_External_Verdef = 0 as *mut Elf_External_Verdef;
                let mut idx: libc::c_ulong = 0;
                let mut cnt: libc::c_ulong = 0;
                let mut endbuf: *mut libc::c_char = 0 as *mut libc::c_char;
                found = 1 as libc::c_int != 0;
                if (*filedata).is_separate {
                    printf(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"\nIn linked file '%s' the version definition section '%s' contains %u entry:\n\0"
                                as *const u8 as *const libc::c_char,
                            b"\nIn linked file '%s' the version definition section '%s' contains %u entries:\n\0"
                                as *const u8 as *const libc::c_char,
                            (*section).sh_info as libc::c_ulong,
                            5 as libc::c_int,
                        ),
                        (*filedata).file_name,
                        printable_section_name(filedata, section),
                        (*section).sh_info,
                    );
                } else {
                    printf(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"\nVersion definition section '%s' contains %u entry:\n\0"
                                as *const u8 as *const libc::c_char,
                            b"\nVersion definition section '%s' contains %u entries:\n\0"
                                as *const u8 as *const libc::c_char,
                            (*section).sh_info as libc::c_ulong,
                            5 as libc::c_int,
                        ),
                        printable_section_name(filedata, section),
                        (*section).sh_info,
                    );
                }
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" Addr: 0x\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                fprintf(
                    stdout,
                    b"%016lx\0" as *const u8 as *const libc::c_char,
                    (*section).sh_addr,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Offset: %#08lx  Link: %u (%s)\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*section).sh_offset as libc::c_ulong,
                    (*section).sh_link,
                    printable_section_name_from_index(
                        filedata,
                        (*section).sh_link as libc::c_ulong,
                    ),
                );
                edefs = get_data(
                    0 as *mut libc::c_void,
                    filedata,
                    (*section).sh_offset as libc::c_ulong,
                    1 as libc::c_int as bfd_size_type,
                    (*section).sh_size,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"version definition section\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                ) as *mut Elf_External_Verdef;
                if !edefs.is_null() {
                    endbuf = (edefs as *mut libc::c_char)
                        .offset((*section).sh_size as isize);
                    cnt = 0 as libc::c_int as libc::c_ulong;
                    idx = cnt;
                    while cnt < (*section).sh_info as libc::c_ulong {
                        let mut vstart: *mut libc::c_char = 0 as *mut libc::c_char;
                        let mut edef: *mut Elf_External_Verdef = 0
                            as *mut Elf_External_Verdef;
                        let mut ent: Elf_Internal_Verdef = Elf_Internal_Verdef {
                            vd_version: 0,
                            vd_flags: 0,
                            vd_ndx: 0,
                            vd_cnt: 0,
                            vd_hash: 0,
                            vd_aux: 0,
                            vd_next: 0,
                            vd_bfd: 0 as *mut bfd,
                            vd_nodename: 0 as *const libc::c_char,
                            vd_nextdef: 0 as *mut elf_internal_verdef,
                            vd_auxptr: 0 as *mut elf_internal_verdaux,
                            vd_exp_refno: 0,
                        };
                        let mut eaux: *mut Elf_External_Verdaux = 0
                            as *mut Elf_External_Verdaux;
                        let mut aux: Elf_Internal_Verdaux = Elf_Internal_Verdaux {
                            vda_name: 0,
                            vda_next: 0,
                            vda_nodename: 0 as *const libc::c_char,
                            vda_nextptr: 0 as *mut elf_internal_verdaux,
                        };
                        let mut isum: libc::c_ulong = 0;
                        let mut j: libc::c_int = 0;
                        vstart = (edefs as *mut libc::c_char).offset(idx as isize);
                        if vstart
                            .offset(
                                ::core::mem::size_of::<Elf_External_Verdef>()
                                    as libc::c_ulong as isize,
                            ) > endbuf
                        {
                            break;
                        }
                        edef = vstart as *mut Elf_External_Verdef;
                        ent
                            .vd_version = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*edef).vd_version).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                                as libc::c_uint,
                        ) as libc::c_ushort;
                        ent
                            .vd_flags = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*edef).vd_flags).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                                as libc::c_uint,
                        ) as libc::c_ushort;
                        ent
                            .vd_ndx = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*edef).vd_ndx).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                                as libc::c_uint,
                        ) as libc::c_ushort;
                        ent
                            .vd_cnt = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*edef).vd_cnt).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                                as libc::c_uint,
                        ) as libc::c_ushort;
                        ent
                            .vd_hash = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*edef).vd_hash).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        ent
                            .vd_aux = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*edef).vd_aux).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        ent
                            .vd_next = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*edef).vd_next).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  %#06lx: Rev: %d  Flags: %s\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            idx,
                            ent.vd_version as libc::c_int,
                            get_ver_flags(ent.vd_flags as libc::c_uint),
                        );
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Index: %d  Cnt: %d  \0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            ent.vd_ndx as libc::c_int,
                            ent.vd_cnt as libc::c_int,
                        );
                        if ent.vd_aux
                            > endbuf.offset_from(vstart) as libc::c_long as size_t
                        {
                            break;
                        }
                        vstart = vstart.offset(ent.vd_aux as isize);
                        if vstart
                            .offset(
                                ::core::mem::size_of::<Elf_External_Verdaux>()
                                    as libc::c_ulong as isize,
                            ) > endbuf
                        {
                            break;
                        }
                        eaux = vstart as *mut Elf_External_Verdaux;
                        aux
                            .vda_name = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*eaux).vda_name).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        aux
                            .vda_next = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*eaux).vda_next).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        if !((*filedata).dynamic_strings).is_null()
                            && aux.vda_name < (*filedata).dynamic_strings_length
                        {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Name: %s\n\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ((*filedata).dynamic_strings).offset(aux.vda_name as isize),
                            );
                        } else {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Name index: %ld\n\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                aux.vda_name,
                            );
                        }
                        isum = idx.wrapping_add(ent.vd_aux);
                        j = 1 as libc::c_int;
                        while j < ent.vd_cnt as libc::c_int {
                            if aux.vda_next
                                < ::core::mem::size_of::<Elf_External_Verdaux>()
                                    as libc::c_ulong
                                && !(j == ent.vd_cnt as libc::c_int - 1 as libc::c_int
                                    && aux.vda_next == 0 as libc::c_int as libc::c_ulong)
                            {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Invalid vda_next field of %lx\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    aux.vda_next,
                                );
                                j = ent.vd_cnt as libc::c_int;
                                break;
                            } else {
                                if aux.vda_next
                                    > endbuf.offset_from(vstart) as libc::c_long as size_t
                                {
                                    break;
                                }
                                isum = isum.wrapping_add(aux.vda_next);
                                vstart = vstart.offset(aux.vda_next as isize);
                                if vstart
                                    .offset(
                                        ::core::mem::size_of::<Elf_External_Verdaux>()
                                            as libc::c_ulong as isize,
                                    ) > endbuf
                                {
                                    break;
                                }
                                eaux = vstart as *mut Elf_External_Verdaux;
                                aux
                                    .vda_name = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*eaux).vda_name).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                aux
                                    .vda_next = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*eaux).vda_next).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                if !((*filedata).dynamic_strings).is_null()
                                    && aux.vda_name < (*filedata).dynamic_strings_length
                                {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"  %#06lx: Parent %d: %s\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        isum,
                                        j,
                                        ((*filedata).dynamic_strings).offset(aux.vda_name as isize),
                                    );
                                } else {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"  %#06lx: Parent %d, name index: %ld\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        isum,
                                        j,
                                        aux.vda_name,
                                    );
                                }
                                j += 1;
                                j;
                            }
                        }
                        if j < ent.vd_cnt as libc::c_int {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Version def aux past end of section\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        if ent.vd_next
                            < ::core::mem::size_of::<Elf_External_Verdef>()
                                as libc::c_ulong
                            && !(cnt
                                == ((*section).sh_info)
                                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                    as libc::c_ulong
                                && ent.vd_next == 0 as libc::c_int as libc::c_ulong)
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Invalid vd_next field of %lx\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ent.vd_next,
                            );
                            cnt = (*section).sh_info as libc::c_ulong;
                            break;
                        } else {
                            if ent.vd_next
                                > endbuf
                                    .offset_from(
                                        (edefs as *mut libc::c_char).offset(idx as isize),
                                    ) as libc::c_long as size_t
                            {
                                break;
                            }
                            idx = idx.wrapping_add(ent.vd_next);
                            cnt = cnt.wrapping_add(1);
                            cnt;
                        }
                    }
                    if cnt < (*section).sh_info as libc::c_ulong {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Version definition past end of section\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    free(edefs as *mut libc::c_void);
                }
            }
            1879048190 => {
                let mut eneed: *mut Elf_External_Verneed = 0
                    as *mut Elf_External_Verneed;
                let mut idx_0: libc::c_ulong = 0;
                let mut cnt_0: libc::c_ulong = 0;
                let mut endbuf_0: *mut libc::c_char = 0 as *mut libc::c_char;
                found = 1 as libc::c_int != 0;
                if (*filedata).is_separate {
                    printf(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"\nIn linked file '%s' the version needs section '%s' contains %u entry:\n\0"
                                as *const u8 as *const libc::c_char,
                            b"\nIn linked file '%s' the version needs section '%s' contains %u entries:\n\0"
                                as *const u8 as *const libc::c_char,
                            (*section).sh_info as libc::c_ulong,
                            5 as libc::c_int,
                        ),
                        (*filedata).file_name,
                        printable_section_name(filedata, section),
                        (*section).sh_info,
                    );
                } else {
                    printf(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"\nVersion needs section '%s' contains %u entry:\n\0"
                                as *const u8 as *const libc::c_char,
                            b"\nVersion needs section '%s' contains %u entries:\n\0"
                                as *const u8 as *const libc::c_char,
                            (*section).sh_info as libc::c_ulong,
                            5 as libc::c_int,
                        ),
                        printable_section_name(filedata, section),
                        (*section).sh_info,
                    );
                }
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" Addr: 0x\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                fprintf(
                    stdout,
                    b"%016lx\0" as *const u8 as *const libc::c_char,
                    (*section).sh_addr,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Offset: %#08lx  Link: %u (%s)\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*section).sh_offset as libc::c_ulong,
                    (*section).sh_link,
                    printable_section_name_from_index(
                        filedata,
                        (*section).sh_link as libc::c_ulong,
                    ),
                );
                eneed = get_data(
                    0 as *mut libc::c_void,
                    filedata,
                    (*section).sh_offset as libc::c_ulong,
                    1 as libc::c_int as bfd_size_type,
                    (*section).sh_size,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Version Needs section\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                ) as *mut Elf_External_Verneed;
                if !eneed.is_null() {
                    endbuf_0 = (eneed as *mut libc::c_char)
                        .offset((*section).sh_size as isize);
                    cnt_0 = 0 as libc::c_int as libc::c_ulong;
                    idx_0 = cnt_0;
                    while cnt_0 < (*section).sh_info as libc::c_ulong {
                        let mut entry: *mut Elf_External_Verneed = 0
                            as *mut Elf_External_Verneed;
                        let mut ent_0: Elf_Internal_Verneed = Elf_Internal_Verneed {
                            vn_version: 0,
                            vn_cnt: 0,
                            vn_file: 0,
                            vn_aux: 0,
                            vn_next: 0,
                            vn_bfd: 0 as *mut bfd,
                            vn_filename: 0 as *const libc::c_char,
                            vn_auxptr: 0 as *mut elf_internal_vernaux,
                            vn_nextref: 0 as *mut elf_internal_verneed,
                        };
                        let mut isum_0: libc::c_ulong = 0;
                        let mut j_0: libc::c_int = 0;
                        let mut vstart_0: *mut libc::c_char = 0 as *mut libc::c_char;
                        vstart_0 = (eneed as *mut libc::c_char).offset(idx_0 as isize);
                        if vstart_0
                            .offset(
                                ::core::mem::size_of::<Elf_External_Verneed>()
                                    as libc::c_ulong as isize,
                            ) > endbuf_0
                        {
                            break;
                        }
                        entry = vstart_0 as *mut Elf_External_Verneed;
                        ent_0
                            .vn_version = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*entry).vn_version).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                                as libc::c_uint,
                        ) as libc::c_ushort;
                        ent_0
                            .vn_cnt = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*entry).vn_cnt).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                                as libc::c_uint,
                        ) as libc::c_ushort;
                        ent_0
                            .vn_file = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*entry).vn_file).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        ent_0
                            .vn_aux = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*entry).vn_aux).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        ent_0
                            .vn_next = byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*entry).vn_next).as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                                as libc::c_uint,
                        );
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  %#06lx: Version: %d\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            idx_0,
                            ent_0.vn_version as libc::c_int,
                        );
                        if !((*filedata).dynamic_strings).is_null()
                            && ent_0.vn_file < (*filedata).dynamic_strings_length
                        {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  File: %s\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ((*filedata).dynamic_strings).offset(ent_0.vn_file as isize),
                            );
                        } else {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  File: %lx\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ent_0.vn_file,
                            );
                        }
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Cnt: %d\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            ent_0.vn_cnt as libc::c_int,
                        );
                        if ent_0.vn_aux
                            > endbuf_0.offset_from(vstart_0) as libc::c_long as size_t
                        {
                            break;
                        }
                        vstart_0 = vstart_0.offset(ent_0.vn_aux as isize);
                        j_0 = 0 as libc::c_int;
                        isum_0 = idx_0.wrapping_add(ent_0.vn_aux);
                        while j_0 < ent_0.vn_cnt as libc::c_int {
                            let mut eaux_0: *mut Elf_External_Vernaux = 0
                                as *mut Elf_External_Vernaux;
                            let mut aux_0: Elf_Internal_Vernaux = Elf_Internal_Vernaux {
                                vna_hash: 0,
                                vna_flags: 0,
                                vna_other: 0,
                                vna_name: 0,
                                vna_next: 0,
                                vna_nodename: 0 as *const libc::c_char,
                                vna_nextptr: 0 as *mut elf_internal_vernaux,
                            };
                            if vstart_0
                                .offset(
                                    ::core::mem::size_of::<Elf_External_Vernaux>()
                                        as libc::c_ulong as isize,
                                ) > endbuf_0
                            {
                                break;
                            }
                            eaux_0 = vstart_0 as *mut Elf_External_Vernaux;
                            aux_0
                                .vna_hash = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*eaux_0).vna_hash).as_mut_ptr(),
                                ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                    as libc::c_ulong as libc::c_uint,
                            );
                            aux_0
                                .vna_flags = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*eaux_0).vna_flags).as_mut_ptr(),
                                ::core::mem::size_of::<[libc::c_uchar; 2]>()
                                    as libc::c_ulong as libc::c_uint,
                            ) as libc::c_ushort;
                            aux_0
                                .vna_other = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*eaux_0).vna_other).as_mut_ptr(),
                                ::core::mem::size_of::<[libc::c_uchar; 2]>()
                                    as libc::c_ulong as libc::c_uint,
                            ) as libc::c_ushort;
                            aux_0
                                .vna_name = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*eaux_0).vna_name).as_mut_ptr(),
                                ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                    as libc::c_ulong as libc::c_uint,
                            );
                            aux_0
                                .vna_next = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*eaux_0).vna_next).as_mut_ptr(),
                                ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                    as libc::c_ulong as libc::c_uint,
                            );
                            if !((*filedata).dynamic_strings).is_null()
                                && aux_0.vna_name < (*filedata).dynamic_strings_length
                            {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"  %#06lx:   Name: %s\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    isum_0,
                                    ((*filedata).dynamic_strings)
                                        .offset(aux_0.vna_name as isize),
                                );
                            } else {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"  %#06lx:   Name index: %lx\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    isum_0,
                                    aux_0.vna_name,
                                );
                            }
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Flags: %s  Version: %d\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                get_ver_flags(aux_0.vna_flags as libc::c_uint),
                                aux_0.vna_other as libc::c_int,
                            );
                            if aux_0.vna_next
                                < ::core::mem::size_of::<Elf_External_Vernaux>()
                                    as libc::c_ulong
                                && !(j_0 == ent_0.vn_cnt as libc::c_int - 1 as libc::c_int
                                    && aux_0.vna_next == 0 as libc::c_int as libc::c_ulong)
                            {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Invalid vna_next field of %lx\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    aux_0.vna_next,
                                );
                                j_0 = ent_0.vn_cnt as libc::c_int;
                                break;
                            } else {
                                if aux_0.vna_next
                                    > endbuf_0.offset_from(vstart_0) as libc::c_long as size_t
                                {
                                    break;
                                }
                                isum_0 = isum_0.wrapping_add(aux_0.vna_next);
                                vstart_0 = vstart_0.offset(aux_0.vna_next as isize);
                                j_0 += 1;
                                j_0;
                            }
                        }
                        if j_0 < ent_0.vn_cnt as libc::c_int {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Missing Version Needs auxiliary information\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        if ent_0.vn_next
                            < ::core::mem::size_of::<Elf_External_Verneed>()
                                as libc::c_ulong
                            && !(cnt_0
                                == ((*section).sh_info)
                                    .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                    as libc::c_ulong
                                && ent_0.vn_next == 0 as libc::c_int as libc::c_ulong)
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Invalid vn_next field of %lx\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ent_0.vn_next,
                            );
                            cnt_0 = (*section).sh_info as libc::c_ulong;
                            break;
                        } else {
                            if ent_0.vn_next
                                > endbuf_0
                                    .offset_from(
                                        (eneed as *mut libc::c_char).offset(idx_0 as isize),
                                    ) as libc::c_long as size_t
                            {
                                break;
                            }
                            idx_0 = idx_0.wrapping_add(ent_0.vn_next);
                            cnt_0 = cnt_0.wrapping_add(1);
                            cnt_0;
                        }
                    }
                    if cnt_0 < (*section).sh_info as libc::c_ulong {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Missing Version Needs information\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    free(eneed as *mut libc::c_void);
                }
            }
            1879048191 => {
                let mut link_section: *mut Elf_Internal_Shdr = 0
                    as *mut Elf_Internal_Shdr;
                let mut total: size_t = 0;
                let mut cnt_1: libc::c_uint = 0;
                let mut edata: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                let mut data: *mut libc::c_ushort = 0 as *mut libc::c_ushort;
                let mut strtab: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut symbols: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
                let mut string_sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
                let mut num_syms: libc::c_ulong = 0;
                let mut off: libc::c_long = 0;
                if !((*section).sh_link >= (*filedata).file_header.e_shnum) {
                    link_section = ((*filedata).section_headers)
                        .offset((*section).sh_link as isize);
                    total = ((*section).sh_size)
                        .wrapping_div(
                            ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong,
                        );
                    if !((*link_section).sh_link >= (*filedata).file_header.e_shnum) {
                        found = 1 as libc::c_int != 0;
                        symbols = get_elf_symbols(filedata, link_section, &mut num_syms);
                        if !symbols.is_null() {
                            string_sec = ((*filedata).section_headers)
                                .offset((*link_section).sh_link as isize);
                            strtab = get_data(
                                0 as *mut libc::c_void,
                                filedata,
                                (*string_sec).sh_offset as libc::c_ulong,
                                1 as libc::c_int as bfd_size_type,
                                (*string_sec).sh_size,
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"version string table\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            ) as *mut libc::c_char;
                            if strtab.is_null() {
                                free(symbols as *mut libc::c_void);
                            } else {
                                if (*filedata).is_separate {
                                    printf(
                                        dcngettext(
                                            0 as *const libc::c_char,
                                            b"\nIn linked file '%s' the version symbols section '%s' contains %lu entry:\n\0"
                                                as *const u8 as *const libc::c_char,
                                            b"\nIn linked file '%s' the version symbols section '%s' contains %lu entries:\n\0"
                                                as *const u8 as *const libc::c_char,
                                            total,
                                            5 as libc::c_int,
                                        ),
                                        (*filedata).file_name,
                                        printable_section_name(filedata, section),
                                        total,
                                    );
                                } else {
                                    printf(
                                        dcngettext(
                                            0 as *const libc::c_char,
                                            b"\nVersion symbols section '%s' contains %lu entry:\n\0"
                                                as *const u8 as *const libc::c_char,
                                            b"\nVersion symbols section '%s' contains %lu entries:\n\0"
                                                as *const u8 as *const libc::c_char,
                                            total,
                                            5 as libc::c_int,
                                        ),
                                        printable_section_name(filedata, section),
                                        total,
                                    );
                                }
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b" Addr: 0x\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                fprintf(
                                    stdout,
                                    b"%016lx\0" as *const u8 as *const libc::c_char,
                                    (*section).sh_addr,
                                );
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"  Offset: %#08lx  Link: %u (%s)\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    (*section).sh_offset as libc::c_ulong,
                                    (*section).sh_link,
                                    printable_section_name(filedata, link_section),
                                );
                                off = offset_from_vma(
                                    filedata,
                                    (*filedata)
                                        .version_info[(0x6fffffff as libc::c_int
                                        - 0x6ffffff0 as libc::c_int) as usize],
                                    total
                                        .wrapping_mul(
                                            ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                                        ),
                                );
                                edata = get_data(
                                    0 as *mut libc::c_void,
                                    filedata,
                                    off as libc::c_ulong,
                                    ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                                    total,
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"version symbol data\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                ) as *mut libc::c_uchar;
                                if edata.is_null() {
                                    free(strtab as *mut libc::c_void);
                                    free(symbols as *mut libc::c_void);
                                } else {
                                    data = cmalloc(
                                        total,
                                        ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                                    ) as *mut libc::c_ushort;
                                    cnt_1 = total as libc::c_uint;
                                    loop {
                                        let fresh29 = cnt_1;
                                        cnt_1 = cnt_1.wrapping_sub(1);
                                        if !(fresh29 != 0) {
                                            break;
                                        }
                                        *data
                                            .offset(
                                                cnt_1 as isize,
                                            ) = byte_get
                                            .expect(
                                                "non-null function pointer",
                                            )(
                                            edata
                                                .offset(
                                                    (cnt_1 as libc::c_ulong)
                                                        .wrapping_mul(
                                                            ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                                                        ) as isize,
                                                ),
                                            ::core::mem::size_of::<libc::c_short>() as libc::c_ulong
                                                as libc::c_uint,
                                        ) as libc::c_ushort;
                                    }
                                    free(edata as *mut libc::c_void);
                                    cnt_1 = 0 as libc::c_int as libc::c_uint;
                                    while (cnt_1 as libc::c_ulong) < total {
                                        let mut j_1: libc::c_int = 0;
                                        let mut nn: libc::c_int = 0;
                                        let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
                                        let mut invalid: *mut libc::c_char = dcgettext(
                                            0 as *const libc::c_char,
                                            b"*invalid*\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        );
                                        printf(
                                            b"  %03x:\0" as *const u8 as *const libc::c_char,
                                            cnt_1,
                                        );
                                        j_1 = 0 as libc::c_int;
                                        while j_1 < 4 as libc::c_int
                                            && (cnt_1.wrapping_add(j_1 as libc::c_uint)
                                                as libc::c_ulong) < total
                                        {
                                            let mut current_block_171: u64;
                                            match *data
                                                .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                as libc::c_int
                                            {
                                                0 => {
                                                    fputs(
                                                        dcgettext(
                                                            0 as *const libc::c_char,
                                                            b"   0 (*local*)    \0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                        stdout,
                                                    );
                                                }
                                                1 => {
                                                    fputs(
                                                        dcgettext(
                                                            0 as *const libc::c_char,
                                                            b"   1 (*global*)   \0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                        stdout,
                                                    );
                                                }
                                                _ => {
                                                    nn = printf(
                                                        b"%4x%c\0" as *const u8 as *const libc::c_char,
                                                        *data
                                                            .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                            as libc::c_int & 0x7fff as libc::c_int,
                                                        if *data
                                                            .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                            as libc::c_int & 0x8000 as libc::c_int != 0
                                                        {
                                                            'h' as i32
                                                        } else {
                                                            ' ' as i32
                                                        },
                                                    );
                                                    if cnt_1.wrapping_add(j_1 as libc::c_uint) as libc::c_ulong
                                                        >= num_syms
                                                    {
                                                        warn(
                                                            dcgettext(
                                                                0 as *const libc::c_char,
                                                                b"invalid index into symbol array\n\0" as *const u8
                                                                    as *const libc::c_char,
                                                                5 as libc::c_int,
                                                            ),
                                                        );
                                                    } else {
                                                        name = 0 as *mut libc::c_char;
                                                        if (*filedata)
                                                            .version_info[(0x6fffffff as libc::c_int
                                                            - 0x6ffffffe as libc::c_int) as usize] != 0
                                                        {
                                                            let mut ivn: Elf_Internal_Verneed = Elf_Internal_Verneed {
                                                                vn_version: 0,
                                                                vn_cnt: 0,
                                                                vn_file: 0,
                                                                vn_aux: 0,
                                                                vn_next: 0,
                                                                vn_bfd: 0 as *mut bfd,
                                                                vn_filename: 0 as *const libc::c_char,
                                                                vn_auxptr: 0 as *mut elf_internal_vernaux,
                                                                vn_nextref: 0 as *mut elf_internal_verneed,
                                                            };
                                                            let mut offset: libc::c_ulong = 0;
                                                            offset = offset_from_vma(
                                                                filedata,
                                                                (*filedata)
                                                                    .version_info[(0x6fffffff as libc::c_int
                                                                    - 0x6ffffffe as libc::c_int) as usize],
                                                                ::core::mem::size_of::<Elf_External_Verneed>()
                                                                    as libc::c_ulong,
                                                            ) as libc::c_ulong;
                                                            loop {
                                                                let mut ivna: Elf_Internal_Vernaux = Elf_Internal_Vernaux {
                                                                    vna_hash: 0,
                                                                    vna_flags: 0,
                                                                    vna_other: 0,
                                                                    vna_name: 0,
                                                                    vna_next: 0,
                                                                    vna_nodename: 0 as *const libc::c_char,
                                                                    vna_nextptr: 0 as *mut elf_internal_vernaux,
                                                                };
                                                                let mut evn: Elf_External_Verneed = Elf_External_Verneed {
                                                                    vn_version: [0; 2],
                                                                    vn_cnt: [0; 2],
                                                                    vn_file: [0; 4],
                                                                    vn_aux: [0; 4],
                                                                    vn_next: [0; 4],
                                                                };
                                                                let mut evna: Elf_External_Vernaux = Elf_External_Vernaux {
                                                                    vna_hash: [0; 4],
                                                                    vna_flags: [0; 2],
                                                                    vna_other: [0; 2],
                                                                    vna_name: [0; 4],
                                                                    vna_next: [0; 4],
                                                                };
                                                                let mut a_off: libc::c_ulong = 0;
                                                                if (get_data(
                                                                    &mut evn as *mut Elf_External_Verneed as *mut libc::c_void,
                                                                    filedata,
                                                                    offset,
                                                                    ::core::mem::size_of::<Elf_External_Verneed>()
                                                                        as libc::c_ulong,
                                                                    1 as libc::c_int as bfd_size_type,
                                                                    dcgettext(
                                                                        0 as *const libc::c_char,
                                                                        b"version need\0" as *const u8 as *const libc::c_char,
                                                                        5 as libc::c_int,
                                                                    ),
                                                                ))
                                                                    .is_null()
                                                                {
                                                                    break;
                                                                }
                                                                ivn
                                                                    .vn_aux = byte_get
                                                                    .expect(
                                                                        "non-null function pointer",
                                                                    )(
                                                                    (evn.vn_aux).as_mut_ptr(),
                                                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                                                        as libc::c_ulong as libc::c_uint,
                                                                );
                                                                ivn
                                                                    .vn_next = byte_get
                                                                    .expect(
                                                                        "non-null function pointer",
                                                                    )(
                                                                    (evn.vn_next).as_mut_ptr(),
                                                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                                                        as libc::c_ulong as libc::c_uint,
                                                                );
                                                                a_off = offset.wrapping_add(ivn.vn_aux);
                                                                loop {
                                                                    if (get_data(
                                                                        &mut evna as *mut Elf_External_Vernaux as *mut libc::c_void,
                                                                        filedata,
                                                                        a_off,
                                                                        ::core::mem::size_of::<Elf_External_Vernaux>()
                                                                            as libc::c_ulong,
                                                                        1 as libc::c_int as bfd_size_type,
                                                                        dcgettext(
                                                                            0 as *const libc::c_char,
                                                                            b"version need aux (2)\0" as *const u8
                                                                                as *const libc::c_char,
                                                                            5 as libc::c_int,
                                                                        ),
                                                                    ))
                                                                        .is_null()
                                                                    {
                                                                        ivna.vna_next = 0 as libc::c_int as libc::c_ulong;
                                                                        ivna.vna_other = 0 as libc::c_int as libc::c_ushort;
                                                                    } else {
                                                                        ivna
                                                                            .vna_next = byte_get
                                                                            .expect(
                                                                                "non-null function pointer",
                                                                            )(
                                                                            (evna.vna_next).as_mut_ptr(),
                                                                            ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                                                                as libc::c_ulong as libc::c_uint,
                                                                        );
                                                                        ivna
                                                                            .vna_other = byte_get
                                                                            .expect(
                                                                                "non-null function pointer",
                                                                            )(
                                                                            (evna.vna_other).as_mut_ptr(),
                                                                            ::core::mem::size_of::<[libc::c_uchar; 2]>()
                                                                                as libc::c_ulong as libc::c_uint,
                                                                        ) as libc::c_ushort;
                                                                    }
                                                                    a_off = a_off.wrapping_add(ivna.vna_next);
                                                                    if !(ivna.vna_other as libc::c_int
                                                                        != *data
                                                                            .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                                            as libc::c_int
                                                                        && ivna.vna_next != 0 as libc::c_int as libc::c_ulong)
                                                                    {
                                                                        break;
                                                                    }
                                                                }
                                                                if ivna.vna_other as libc::c_int
                                                                    == *data
                                                                        .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                                        as libc::c_int
                                                                {
                                                                    ivna
                                                                        .vna_name = byte_get
                                                                        .expect(
                                                                            "non-null function pointer",
                                                                        )(
                                                                        (evna.vna_name).as_mut_ptr(),
                                                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                                                            as libc::c_ulong as libc::c_uint,
                                                                    );
                                                                    if ivna.vna_name >= (*string_sec).sh_size {
                                                                        name = invalid;
                                                                    } else {
                                                                        name = strtab.offset(ivna.vna_name as isize);
                                                                    }
                                                                    break;
                                                                } else {
                                                                    offset = offset.wrapping_add(ivn.vn_next);
                                                                    if !(ivn.vn_next != 0) {
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if *data
                                                            .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                            as libc::c_int != 0x8001 as libc::c_int
                                                            && (*filedata)
                                                                .version_info[(0x6fffffff as libc::c_int
                                                                - 0x6ffffffc as libc::c_int) as usize] != 0
                                                        {
                                                            let mut ivd: Elf_Internal_Verdef = Elf_Internal_Verdef {
                                                                vd_version: 0,
                                                                vd_flags: 0,
                                                                vd_ndx: 0,
                                                                vd_cnt: 0,
                                                                vd_hash: 0,
                                                                vd_aux: 0,
                                                                vd_next: 0,
                                                                vd_bfd: 0 as *mut bfd,
                                                                vd_nodename: 0 as *const libc::c_char,
                                                                vd_nextdef: 0 as *mut elf_internal_verdef,
                                                                vd_auxptr: 0 as *mut elf_internal_verdaux,
                                                                vd_exp_refno: 0,
                                                            };
                                                            let mut evd: Elf_External_Verdef = Elf_External_Verdef {
                                                                vd_version: [0; 2],
                                                                vd_flags: [0; 2],
                                                                vd_ndx: [0; 2],
                                                                vd_cnt: [0; 2],
                                                                vd_hash: [0; 4],
                                                                vd_aux: [0; 4],
                                                                vd_next: [0; 4],
                                                            };
                                                            let mut offset_0: libc::c_ulong = 0;
                                                            offset_0 = offset_from_vma(
                                                                filedata,
                                                                (*filedata)
                                                                    .version_info[(0x6fffffff as libc::c_int
                                                                    - 0x6ffffffc as libc::c_int) as usize],
                                                                ::core::mem::size_of::<Elf_External_Verdef>()
                                                                    as libc::c_ulong,
                                                            ) as libc::c_ulong;
                                                            loop {
                                                                if (get_data(
                                                                    &mut evd as *mut Elf_External_Verdef as *mut libc::c_void,
                                                                    filedata,
                                                                    offset_0,
                                                                    ::core::mem::size_of::<Elf_External_Verdef>()
                                                                        as libc::c_ulong,
                                                                    1 as libc::c_int as bfd_size_type,
                                                                    dcgettext(
                                                                        0 as *const libc::c_char,
                                                                        b"version def\0" as *const u8 as *const libc::c_char,
                                                                        5 as libc::c_int,
                                                                    ),
                                                                ))
                                                                    .is_null()
                                                                {
                                                                    ivd.vd_next = 0 as libc::c_int as libc::c_ulong;
                                                                    ivd
                                                                        .vd_ndx = ((*data
                                                                        .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                                        as libc::c_int & 0x7fff as libc::c_int) + 1 as libc::c_int)
                                                                        as libc::c_ushort;
                                                                    break;
                                                                } else {
                                                                    ivd
                                                                        .vd_next = byte_get
                                                                        .expect(
                                                                            "non-null function pointer",
                                                                        )(
                                                                        (evd.vd_next).as_mut_ptr(),
                                                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                                                            as libc::c_ulong as libc::c_uint,
                                                                    );
                                                                    ivd
                                                                        .vd_ndx = byte_get
                                                                        .expect(
                                                                            "non-null function pointer",
                                                                        )(
                                                                        (evd.vd_ndx).as_mut_ptr(),
                                                                        ::core::mem::size_of::<[libc::c_uchar; 2]>()
                                                                            as libc::c_ulong as libc::c_uint,
                                                                    ) as libc::c_ushort;
                                                                    offset_0 = offset_0.wrapping_add(ivd.vd_next);
                                                                    if !(ivd.vd_ndx as libc::c_int
                                                                        != *data
                                                                            .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                                            as libc::c_int & 0x7fff as libc::c_int
                                                                        && ivd.vd_next != 0 as libc::c_int as libc::c_ulong)
                                                                    {
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            if ivd.vd_ndx as libc::c_int
                                                                == *data
                                                                    .offset(cnt_1.wrapping_add(j_1 as libc::c_uint) as isize)
                                                                    as libc::c_int & 0x7fff as libc::c_int
                                                            {
                                                                let mut evda: Elf_External_Verdaux = Elf_External_Verdaux {
                                                                    vda_name: [0; 4],
                                                                    vda_next: [0; 4],
                                                                };
                                                                let mut ivda: Elf_Internal_Verdaux = Elf_Internal_Verdaux {
                                                                    vda_name: 0,
                                                                    vda_next: 0,
                                                                    vda_nodename: 0 as *const libc::c_char,
                                                                    vda_nextptr: 0 as *mut elf_internal_verdaux,
                                                                };
                                                                ivd
                                                                    .vd_aux = byte_get
                                                                    .expect(
                                                                        "non-null function pointer",
                                                                    )(
                                                                    (evd.vd_aux).as_mut_ptr(),
                                                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                                                        as libc::c_ulong as libc::c_uint,
                                                                );
                                                                if (get_data(
                                                                    &mut evda as *mut Elf_External_Verdaux as *mut libc::c_void,
                                                                    filedata,
                                                                    offset_0.wrapping_sub(ivd.vd_next).wrapping_add(ivd.vd_aux),
                                                                    ::core::mem::size_of::<Elf_External_Verdaux>()
                                                                        as libc::c_ulong,
                                                                    1 as libc::c_int as bfd_size_type,
                                                                    dcgettext(
                                                                        0 as *const libc::c_char,
                                                                        b"version def aux\0" as *const u8 as *const libc::c_char,
                                                                        5 as libc::c_int,
                                                                    ),
                                                                ))
                                                                    .is_null()
                                                                {
                                                                    current_block_171 = 13193481930143188038;
                                                                } else {
                                                                    ivda
                                                                        .vda_name = byte_get
                                                                        .expect(
                                                                            "non-null function pointer",
                                                                        )(
                                                                        (evda.vda_name).as_mut_ptr(),
                                                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                                                            as libc::c_ulong as libc::c_uint,
                                                                    );
                                                                    if ivda.vda_name >= (*string_sec).sh_size {
                                                                        name = invalid;
                                                                    } else if !name.is_null() && name != invalid {
                                                                        name = dcgettext(
                                                                            0 as *const libc::c_char,
                                                                            b"*both*\0" as *const u8 as *const libc::c_char,
                                                                            5 as libc::c_int,
                                                                        );
                                                                    } else {
                                                                        name = strtab.offset(ivda.vda_name as isize);
                                                                    }
                                                                    current_block_171 = 1691841359054504885;
                                                                }
                                                            } else {
                                                                current_block_171 = 1691841359054504885;
                                                            }
                                                        } else {
                                                            current_block_171 = 1691841359054504885;
                                                        }
                                                        match current_block_171 {
                                                            13193481930143188038 => {}
                                                            _ => {
                                                                if !name.is_null() {
                                                                    nn
                                                                        += printf(
                                                                            b"(%s%-*s\0" as *const u8 as *const libc::c_char,
                                                                            name,
                                                                            12 as libc::c_int - strlen(name) as libc::c_int,
                                                                            b")\0" as *const u8 as *const libc::c_char,
                                                                        );
                                                                }
                                                                if nn < 18 as libc::c_int {
                                                                    printf(
                                                                        b"%*c\0" as *const u8 as *const libc::c_char,
                                                                        18 as libc::c_int - nn,
                                                                        ' ' as i32,
                                                                    );
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            j_1 += 1;
                                            j_1;
                                        }
                                        putchar('\n' as i32);
                                        cnt_1 = cnt_1
                                            .wrapping_add(4 as libc::c_int as libc::c_uint);
                                    }
                                    free(data as *mut libc::c_void);
                                    free(strtab as *mut libc::c_void);
                                    free(symbols as *mut libc::c_void);
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    if !found {
        if (*filedata).is_separate {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nNo version information found in linked file '%s'.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*filedata).file_name,
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nNo version information found in this file.\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_symbol_binding(
    mut filedata: *mut Filedata,
    mut binding: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    match binding {
        0 => return b"LOCAL\0" as *const u8 as *const libc::c_char,
        1 => return b"GLOBAL\0" as *const u8 as *const libc::c_char,
        2 => return b"WEAK\0" as *const u8 as *const libc::c_char,
        _ => {
            if binding >= 13 as libc::c_int as libc::c_uint
                && binding <= 15 as libc::c_int as libc::c_uint
            {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<processor specific>: %d\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    binding,
                );
            } else if binding >= 10 as libc::c_int as libc::c_uint
                && binding <= 12 as libc::c_int as libc::c_uint
            {
                if binding == 10 as libc::c_int as libc::c_uint
                    && (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                        as libc::c_int == 3 as libc::c_int
                {
                    return b"UNIQUE\0" as *const u8 as *const libc::c_char;
                }
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<OS specific>: %d\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    binding,
                );
            } else {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>: %d\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    binding,
                );
            }
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn get_symbol_type(
    mut filedata: *mut Filedata,
    mut type_0: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    match type_0 {
        0 => return b"NOTYPE\0" as *const u8 as *const libc::c_char,
        1 => return b"OBJECT\0" as *const u8 as *const libc::c_char,
        2 => return b"FUNC\0" as *const u8 as *const libc::c_char,
        3 => return b"SECTION\0" as *const u8 as *const libc::c_char,
        4 => return b"FILE\0" as *const u8 as *const libc::c_char,
        5 => return b"COMMON\0" as *const u8 as *const libc::c_char,
        6 => return b"TLS\0" as *const u8 as *const libc::c_char,
        8 => return b"RELC\0" as *const u8 as *const libc::c_char,
        9 => return b"SRELC\0" as *const u8 as *const libc::c_char,
        _ => {
            if type_0 >= 13 as libc::c_int as libc::c_uint
                && type_0 <= 15 as libc::c_int as libc::c_uint
            {
                if (*filedata).file_header.e_machine as libc::c_int == 40 as libc::c_int
                    && type_0 == 13 as libc::c_int as libc::c_uint
                {
                    return b"THUMB_FUNC\0" as *const u8 as *const libc::c_char;
                }
                if (*filedata).file_header.e_machine as libc::c_int == 43 as libc::c_int
                    && type_0 == 13 as libc::c_int as libc::c_uint
                {
                    return b"REGISTER\0" as *const u8 as *const libc::c_char;
                }
                if (*filedata).file_header.e_machine as libc::c_int == 15 as libc::c_int
                    && type_0 == 13 as libc::c_int as libc::c_uint
                {
                    return b"PARISC_MILLI\0" as *const u8 as *const libc::c_char;
                }
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<processor specific>: %d\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type_0,
                );
            } else if type_0 >= 10 as libc::c_int as libc::c_uint
                && type_0 <= 12 as libc::c_int as libc::c_uint
            {
                if (*filedata).file_header.e_machine as libc::c_int == 15 as libc::c_int
                {
                    if type_0 == (10 as libc::c_int + 0x1 as libc::c_int) as libc::c_uint
                    {
                        return b"HP_OPAQUE\0" as *const u8 as *const libc::c_char;
                    }
                    if type_0 == (10 as libc::c_int + 0x2 as libc::c_int) as libc::c_uint
                    {
                        return b"HP_STUB\0" as *const u8 as *const libc::c_char;
                    }
                }
                if type_0 == 10 as libc::c_int as libc::c_uint
                    && ((*filedata).file_header.e_ident[7 as libc::c_int as usize]
                        as libc::c_int == 3 as libc::c_int
                        || (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                            as libc::c_int == 9 as libc::c_int)
                {
                    return b"IFUNC\0" as *const u8 as *const libc::c_char;
                }
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<OS specific>: %d\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type_0,
                );
            } else {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>: %d\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type_0,
                );
            }
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn get_symbol_visibility(
    mut visibility: libc::c_uint,
) -> *const libc::c_char {
    match visibility {
        0 => return b"DEFAULT\0" as *const u8 as *const libc::c_char,
        1 => return b"INTERNAL\0" as *const u8 as *const libc::c_char,
        2 => return b"HIDDEN\0" as *const u8 as *const libc::c_char,
        3 => return b"PROTECTED\0" as *const u8 as *const libc::c_char,
        _ => {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unrecognized visibility value: %u\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                visibility,
            );
            return dcgettext(
                0 as *const libc::c_char,
                b"<unknown>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
    };
}
unsafe extern "C" fn get_alpha_symbol_other(
    mut other: libc::c_uint,
) -> *const libc::c_char {
    match other {
        128 => return b"NOPV\0" as *const u8 as *const libc::c_char,
        136 => return b"STD GPLOAD\0" as *const u8 as *const libc::c_char,
        _ => {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unrecognized alpha specific other value: %u\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                other,
            );
            return dcgettext(
                0 as *const libc::c_char,
                b"<unknown>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
    };
}
unsafe extern "C" fn get_solaris_symbol_visibility(
    mut visibility: libc::c_uint,
) -> *const libc::c_char {
    match visibility {
        4 => return b"EXPORTED\0" as *const u8 as *const libc::c_char,
        5 => return b"SINGLETON\0" as *const u8 as *const libc::c_char,
        6 => return b"ELIMINATE\0" as *const u8 as *const libc::c_char,
        _ => return get_symbol_visibility(visibility),
    };
}
unsafe extern "C" fn get_aarch64_symbol_other(
    mut other: libc::c_uint,
) -> *const libc::c_char {
    static mut buf: [libc::c_char; 32] = [0; 32];
    if other & 0x80 as libc::c_int as libc::c_uint != 0 {
        other &= !(0x80 as libc::c_int) as libc::c_uint;
        if other == 0 as libc::c_int as libc::c_uint {
            return b"VARIANT_PCS\0" as *const u8 as *const libc::c_char;
        }
        snprintf(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
            b"VARIANT_PCS | %x\0" as *const u8 as *const libc::c_char,
            other,
        );
        return buf.as_mut_ptr();
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn get_mips_symbol_other(
    mut other: libc::c_uint,
) -> *const libc::c_char {
    match other {
        4 => return b"OPTIONAL\0" as *const u8 as *const libc::c_char,
        8 => return b"MIPS PLT\0" as *const u8 as *const libc::c_char,
        32 => return b"MIPS PIC\0" as *const u8 as *const libc::c_char,
        128 => return b"MICROMIPS\0" as *const u8 as *const libc::c_char,
        160 => return b"MICROMIPS, MIPS PIC\0" as *const u8 as *const libc::c_char,
        240 => return b"MIPS16\0" as *const u8 as *const libc::c_char,
        _ => return 0 as *const libc::c_char,
    };
}
unsafe extern "C" fn get_ia64_symbol_other(
    mut filedata: *mut Filedata,
    mut other: libc::c_uint,
) -> *const libc::c_char {
    if is_ia64_vms(filedata) {
        static mut res: [libc::c_char; 32] = [0; 32];
        res[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        match (*filedata).file_header.e_type as libc::c_int {
            3 | 2 => {
                match (other & 0x30 as libc::c_int as libc::c_uint) >> 4 as libc::c_int {
                    0 => {
                        strcat(
                            res.as_mut_ptr(),
                            b" CA\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    1 => {
                        strcat(
                            res.as_mut_ptr(),
                            b" VEC\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    2 => {
                        strcat(
                            res.as_mut_ptr(),
                            b" FD\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    3 => {
                        strcat(
                            res.as_mut_ptr(),
                            b" RSV\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Unrecognized IA64 VMS ST Function type: %d\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (other & 0x30 as libc::c_int as libc::c_uint)
                                >> 4 as libc::c_int,
                        );
                        strcat(
                            res.as_mut_ptr(),
                            b" <unknown>\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
            }
            _ => {}
        }
        match (other & 0xc0 as libc::c_int as libc::c_uint) >> 6 as libc::c_int {
            0 => {
                strcat(res.as_mut_ptr(), b" IGN\0" as *const u8 as *const libc::c_char);
            }
            1 => {
                strcat(res.as_mut_ptr(), b" RSV\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                strcat(res.as_mut_ptr(), b" STD\0" as *const u8 as *const libc::c_char);
            }
            3 => {
                strcat(res.as_mut_ptr(), b" LNK\0" as *const u8 as *const libc::c_char);
            }
            _ => {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unrecognized IA64 VMS ST Linkage: %d\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (other & 0xc0 as libc::c_int as libc::c_uint) >> 6 as libc::c_int,
                );
                strcat(
                    res.as_mut_ptr(),
                    b" <unknown>\0" as *const u8 as *const libc::c_char,
                );
            }
        }
        if res[0 as libc::c_int as usize] as libc::c_int != 0 as libc::c_int {
            return res.as_mut_ptr().offset(1 as libc::c_int as isize)
        } else {
            return res.as_mut_ptr()
        }
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn get_ppc64_symbol_other(
    mut other: libc::c_uint,
) -> *const libc::c_char {
    if other & !((7 as libc::c_int) << 5 as libc::c_int) as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        return 0 as *const libc::c_char;
    }
    other >>= 5 as libc::c_int;
    if other <= 6 as libc::c_int as libc::c_uint {
        static mut buf: [libc::c_char; 64] = [0; 64];
        if other >= 2 as libc::c_int as libc::c_uint {
            other = ppc64_decode_local_entry(other);
        }
        snprintf(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            dcgettext(
                0 as *const libc::c_char,
                b"<localentry>: %d\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            other,
        );
        return buf.as_mut_ptr();
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn get_symbol_other(
    mut filedata: *mut Filedata,
    mut other: libc::c_uint,
) -> *const libc::c_char {
    let mut result: *const libc::c_char = 0 as *const libc::c_char;
    static mut buff: [libc::c_char; 64] = [0; 64];
    if other == 0 as libc::c_int as libc::c_uint {
        return b"\0" as *const u8 as *const libc::c_char;
    }
    match (*filedata).file_header.e_machine as libc::c_int {
        36902 => {
            result = get_alpha_symbol_other(other);
        }
        183 => {
            result = get_aarch64_symbol_other(other);
        }
        8 => {
            result = get_mips_symbol_other(other);
        }
        50 => {
            result = get_ia64_symbol_other(filedata, other);
        }
        21 => {
            result = get_ppc64_symbol_other(other);
        }
        _ => {
            result = 0 as *const libc::c_char;
        }
    }
    if !result.is_null() {
        return result;
    }
    snprintf(
        buff.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        dcgettext(
            0 as *const libc::c_char,
            b"<other>: %x\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        other,
    );
    return buff.as_mut_ptr();
}
unsafe extern "C" fn get_symbol_index_type(
    mut filedata: *mut Filedata,
    mut type_0: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 32] = [0; 32];
    match type_0 {
        0 => return b"UND\0" as *const u8 as *const libc::c_char,
        4294967281 => return b"ABS\0" as *const u8 as *const libc::c_char,
        4294967282 => return b"COM\0" as *const u8 as *const libc::c_char,
        _ => {
            if type_0 == (0x100 as libc::c_uint).wrapping_neg()
                && (*filedata).file_header.e_machine as libc::c_int == 50 as libc::c_int
                && (*filedata).file_header.e_ident[7 as libc::c_int as usize]
                    as libc::c_int == 1 as libc::c_int
            {
                return b"ANSI_COM\0" as *const u8 as *const libc::c_char
            } else if ((*filedata).file_header.e_machine as libc::c_int
                == 62 as libc::c_int
                || (*filedata).file_header.e_machine as libc::c_int == 180 as libc::c_int
                || (*filedata).file_header.e_machine as libc::c_int
                    == 181 as libc::c_int)
                && type_0
                    == (0x100 as libc::c_uint)
                        .wrapping_neg()
                        .wrapping_add(2 as libc::c_int as libc::c_uint)
            {
                return b"LARGE_COM\0" as *const u8 as *const libc::c_char
            } else if type_0
                == (0x100 as libc::c_uint)
                    .wrapping_neg()
                    .wrapping_add(3 as libc::c_int as libc::c_uint)
                && (*filedata).file_header.e_machine as libc::c_int == 8 as libc::c_int
                || type_0 == (0x100 as libc::c_uint).wrapping_neg()
                    && (*filedata).file_header.e_machine as libc::c_int
                        == 140 as libc::c_int
            {
                return b"SCOM\0" as *const u8 as *const libc::c_char
            } else if type_0
                == (0x100 as libc::c_uint)
                    .wrapping_neg()
                    .wrapping_add(4 as libc::c_int as libc::c_uint)
                && (*filedata).file_header.e_machine as libc::c_int == 8 as libc::c_int
            {
                return b"SUND\0" as *const u8 as *const libc::c_char
            } else if type_0 >= (0x100 as libc::c_uint).wrapping_neg()
                && type_0 <= (0xe1 as libc::c_uint).wrapping_neg()
            {
                sprintf(
                    buff.as_mut_ptr(),
                    b"PRC[0x%04x]\0" as *const u8 as *const libc::c_char,
                    type_0 & 0xffff as libc::c_int as libc::c_uint,
                );
            } else if type_0 >= (0xe0 as libc::c_uint).wrapping_neg()
                && type_0 <= (0xc1 as libc::c_uint).wrapping_neg()
            {
                sprintf(
                    buff.as_mut_ptr(),
                    b"OS [0x%04x]\0" as *const u8 as *const libc::c_char,
                    type_0 & 0xffff as libc::c_int as libc::c_uint,
                );
            } else if type_0 >= (0x100 as libc::c_uint).wrapping_neg() {
                sprintf(
                    buff.as_mut_ptr(),
                    b"RSV[0x%04x]\0" as *const u8 as *const libc::c_char,
                    type_0 & 0xffff as libc::c_int as libc::c_uint,
                );
            } else if (*filedata).file_header.e_shnum != 0 as libc::c_int as libc::c_uint
                && type_0 >= (*filedata).file_header.e_shnum
            {
                sprintf(
                    buff.as_mut_ptr(),
                    dcgettext(
                        0 as *const libc::c_char,
                        b"bad section index[%3d]\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type_0,
                );
            } else {
                sprintf(
                    buff.as_mut_ptr(),
                    b"%3d\0" as *const u8 as *const libc::c_char,
                    type_0,
                );
            }
        }
    }
    return buff.as_mut_ptr();
}
unsafe extern "C" fn print_dynamic_symbol_size(
    mut vma: bfd_vma,
    mut base: libc::c_int,
) -> libc::c_uint {
    match base {
        8 => return print_vma(vma, OCTAL_5),
        10 => return print_vma(vma, UNSIGNED_5),
        16 => return print_vma(vma, PREFIX_HEX_5),
        0 | _ => return print_vma(vma, DEC_5),
    };
}
unsafe extern "C" fn print_dynamic_symbol(
    mut filedata: *mut Filedata,
    mut si: libc::c_ulong,
    mut symtab: *mut Elf_Internal_Sym,
    mut section: *mut Elf_Internal_Shdr,
    mut strtab: *mut libc::c_char,
    mut strtab_size: size_t,
) {
    let mut version_string: *const libc::c_char = 0 as *const libc::c_char;
    let mut sym_info: versioned_symbol_info = symbol_undefined;
    let mut vna_other: libc::c_ushort = 0;
    let mut is_valid: bool = false;
    let mut sstr: *const libc::c_char = 0 as *const libc::c_char;
    let mut psym: *mut Elf_Internal_Sym = symtab.offset(si as isize);
    printf(b"%6ld: \0" as *const u8 as *const libc::c_char, si);
    print_vma((*psym).st_value, LONG_HEX);
    putchar(' ' as i32);
    print_dynamic_symbol_size((*psym).st_size, sym_base);
    printf(
        b" %-7s\0" as *const u8 as *const libc::c_char,
        get_symbol_type(
            filedata,
            ((*psym).st_info as libc::c_int & 0xf as libc::c_int) as libc::c_uint,
        ),
    );
    printf(
        b" %-6s\0" as *const u8 as *const libc::c_char,
        get_symbol_binding(filedata, (*psym).st_info as libc::c_uint >> 4 as libc::c_int),
    );
    if (*filedata).file_header.e_ident[7 as libc::c_int as usize] as libc::c_int
        == 6 as libc::c_int
    {
        printf(
            b" %-7s\0" as *const u8 as *const libc::c_char,
            get_solaris_symbol_visibility((*psym).st_other as libc::c_uint),
        );
    } else {
        let mut vis: libc::c_uint = ((*psym).st_other as libc::c_int
            & 0x3 as libc::c_int) as libc::c_uint;
        printf(
            b" %-7s\0" as *const u8 as *const libc::c_char,
            get_symbol_visibility(vis),
        );
        if (*psym).st_other as libc::c_uint ^ vis != 0 {
            printf(
                b" [%s] \0" as *const u8 as *const libc::c_char,
                get_symbol_other(filedata, (*psym).st_other as libc::c_uint ^ vis),
            );
        }
    }
    printf(
        b" %4s \0" as *const u8 as *const libc::c_char,
        get_symbol_index_type(filedata, (*psym).st_shndx),
    );
    if (*psym).st_info as libc::c_int & 0xf as libc::c_int == 3 as libc::c_int
        && (*psym).st_shndx < (*filedata).file_header.e_shnum
        && (*psym).st_name == 0 as libc::c_int as libc::c_ulong
    {
        is_valid = !((*filedata).section_headers)
            .offset((*psym).st_shndx as isize)
            .is_null() && !((*filedata).string_table).is_null()
            && ((*((*filedata).section_headers).offset((*psym).st_shndx as isize))
                .sh_name as libc::c_ulong) < (*filedata).string_table_length;
        sstr = if is_valid as libc::c_int != 0 {
            if ((*filedata).section_headers).offset((*psym).st_shndx as isize).is_null()
            {
                dcgettext(
                    0 as *const libc::c_char,
                    b"<none>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                )
            } else if ((*filedata).string_table).is_null() {
                dcgettext(
                    0 as *const libc::c_char,
                    b"<no-strings>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                )
            } else if (*((*filedata).section_headers).offset((*psym).st_shndx as isize))
                .sh_name as libc::c_ulong >= (*filedata).string_table_length
            {
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                )
            } else {
                ((*filedata).string_table)
                    .offset(
                        (*((*filedata).section_headers)
                            .offset((*psym).st_shndx as isize))
                            .sh_name as isize,
                    )
            }
        } else {
            dcgettext(
                0 as *const libc::c_char,
                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        };
    } else {
        is_valid = !strtab.is_null() && (*psym).st_name < strtab_size;
        sstr = if is_valid as libc::c_int != 0 {
            strtab.offset((*psym).st_name as isize)
        } else {
            dcgettext(
                0 as *const libc::c_char,
                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        };
    }
    version_string = get_symbol_version_string(
        filedata,
        section.is_null() || (*section).sh_type == 11 as libc::c_int as libc::c_uint,
        strtab,
        strtab_size,
        si as libc::c_uint,
        psym,
        &mut sym_info,
        &mut vna_other,
    );
    let mut len_avail: libc::c_int = 21 as libc::c_int;
    if do_wide == 0 && !version_string.is_null() {
        let mut buffer: [libc::c_char; 16] = [0; 16];
        len_avail = (len_avail as libc::c_ulong)
            .wrapping_sub(
                (1 as libc::c_int as libc::c_ulong).wrapping_add(strlen(version_string)),
            ) as libc::c_int as libc::c_int;
        if sym_info as libc::c_uint == symbol_undefined as libc::c_int as libc::c_uint {
            len_avail
                -= sprintf(
                    buffer.as_mut_ptr(),
                    b" (%d)\0" as *const u8 as *const libc::c_char,
                    vna_other as libc::c_int,
                );
        } else if sym_info as libc::c_uint
            != symbol_hidden as libc::c_int as libc::c_uint
        {
            len_avail -= 1 as libc::c_int;
        }
    }
    print_symbol(len_avail, sstr);
    if !version_string.is_null() {
        if sym_info as libc::c_uint == symbol_undefined as libc::c_int as libc::c_uint {
            printf(
                b"@%s (%d)\0" as *const u8 as *const libc::c_char,
                version_string,
                vna_other as libc::c_int,
            );
        } else {
            printf(
                if sym_info as libc::c_uint
                    == symbol_hidden as libc::c_int as libc::c_uint
                {
                    b"@%s\0" as *const u8 as *const libc::c_char
                } else {
                    b"@@%s\0" as *const u8 as *const libc::c_char
                },
                version_string,
            );
        }
    }
    putchar('\n' as i32);
    if (*psym).st_info as libc::c_uint >> 4 as libc::c_int
        == 0 as libc::c_int as libc::c_uint && !section.is_null()
        && si >= (*section).sh_info as libc::c_ulong
        && (*filedata).file_header.e_machine as libc::c_int != 8 as libc::c_int
        && (*filedata).file_header.e_ident[7 as libc::c_int as usize] as libc::c_int
            != 6 as libc::c_int
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"local symbol %lu found at index >= %s's sh_info value of %u\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            si,
            printable_section_name(filedata, section),
            (*section).sh_info,
        );
    }
}
unsafe extern "C" fn get_lto_kind(mut kind: libc::c_uint) -> *const libc::c_char {
    match kind {
        0 => return b"DEF\0" as *const u8 as *const libc::c_char,
        1 => return b"WEAKDEF\0" as *const u8 as *const libc::c_char,
        2 => return b"UNDEF\0" as *const u8 as *const libc::c_char,
        3 => return b"WEAKUNDEF\0" as *const u8 as *const libc::c_char,
        4 => return b"COMMON\0" as *const u8 as *const libc::c_char,
        _ => {}
    }
    static mut buffer: [libc::c_char; 30] = [0; 30];
    error(
        dcgettext(
            0 as *const libc::c_char,
            b"Unknown LTO symbol definition encountered: %u\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        kind,
    );
    sprintf(
        buffer.as_mut_ptr(),
        b"<unknown: %u>\0" as *const u8 as *const libc::c_char,
        kind,
    );
    return buffer.as_mut_ptr();
}
unsafe extern "C" fn get_lto_visibility(
    mut visibility: libc::c_uint,
) -> *const libc::c_char {
    match visibility {
        0 => return b"DEFAULT\0" as *const u8 as *const libc::c_char,
        1 => return b"PROTECTED\0" as *const u8 as *const libc::c_char,
        2 => return b"INTERNAL\0" as *const u8 as *const libc::c_char,
        3 => return b"HIDDEN\0" as *const u8 as *const libc::c_char,
        _ => {}
    }
    static mut buffer: [libc::c_char; 30] = [0; 30];
    error(
        dcgettext(
            0 as *const libc::c_char,
            b"Unknown LTO symbol visibility encountered: %u\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        visibility,
    );
    sprintf(
        buffer.as_mut_ptr(),
        b"<unknown: %u>\0" as *const u8 as *const libc::c_char,
        visibility,
    );
    return buffer.as_mut_ptr();
}
unsafe extern "C" fn get_lto_sym_type(
    mut sym_type: libc::c_uint,
) -> *const libc::c_char {
    match sym_type {
        0 => return b"UNKNOWN\0" as *const u8 as *const libc::c_char,
        1 => return b"FUNCTION\0" as *const u8 as *const libc::c_char,
        2 => return b"VARIABLE\0" as *const u8 as *const libc::c_char,
        _ => {}
    }
    static mut buffer: [libc::c_char; 30] = [0; 30];
    error(
        dcgettext(
            0 as *const libc::c_char,
            b"Unknown LTO symbol type encountered: %u\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        sym_type,
    );
    sprintf(
        buffer.as_mut_ptr(),
        b"<unknown: %u>\0" as *const u8 as *const libc::c_char,
        sym_type,
    );
    return buffer.as_mut_ptr();
}
unsafe extern "C" fn display_lto_symtab(
    mut filedata: *mut Filedata,
    mut section: *mut Elf_Internal_Shdr,
) -> bool {
    let mut current_block: u64;
    if (*section).sh_size == 0 as libc::c_int as libc::c_ulong {
        if (*filedata).is_separate {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nThe LTO Symbol table section '%s' in linked file '%s' is empty!\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                printable_section_name(filedata, section),
                (*filedata).file_name,
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nLTO Symbol table '%s' is empty!\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                printable_section_name(filedata, section),
            );
        }
        return 1 as libc::c_int != 0;
    }
    if (*section).sh_size > (*filedata).file_size {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Section %s has an invalid sh_size of 0x%lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
            (*section).sh_size,
        );
        return 0 as libc::c_int != 0;
    }
    let mut alloced_data: *mut libc::c_void = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*section).sh_offset as libc::c_ulong,
        (*section).sh_size,
        1 as libc::c_int as bfd_size_type,
        dcgettext(
            0 as *const libc::c_char,
            b"LTO symbols\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    if alloced_data.is_null() {
        return 0 as libc::c_int != 0;
    }
    let mut ext: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut ext_data_orig: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ext_data: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ext_data_end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ext_name: *mut libc::c_char = 0 as *mut libc::c_char;
    if asprintf(
        &mut ext_name as *mut *mut libc::c_char,
        b".gnu.lto_.ext_symtab.%s\0" as *const u8 as *const libc::c_char,
        ((*filedata).string_table)
            .offset((*section).sh_name as isize)
            .offset(
                ::core::mem::size_of::<[libc::c_char; 18]>() as libc::c_ulong as isize,
            )
            .offset(-(1 as libc::c_int as isize)),
    ) > 0 as libc::c_int && !ext_name.is_null()
        && {
            ext = find_section(filedata, ext_name);
            !ext.is_null()
        }
    {
        if (*ext).sh_size < 3 as libc::c_int as libc::c_ulong {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"LTO Symbol extension table '%s' is empty!\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                printable_section_name(filedata, ext),
            );
        } else {
            ext_data = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*ext).sh_offset as libc::c_ulong,
                (*ext).sh_size,
                1 as libc::c_int as bfd_size_type,
                dcgettext(
                    0 as *const libc::c_char,
                    b"LTO ext symbol data\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut libc::c_char;
            ext_data_orig = ext_data as *mut libc::c_void;
            if !ext_data.is_null() {
                ext_data_end = ext_data.offset((*ext).sh_size as isize);
                let fresh30 = ext_data;
                ext_data = ext_data.offset(1);
                if *fresh30 as libc::c_int != 1 as libc::c_int {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unexpected version number in symbol extension table\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
        }
    }
    let mut data: *const libc::c_uchar = alloced_data as *const libc::c_uchar;
    let mut end: *const libc::c_uchar = data.offset((*section).sh_size as isize);
    if (*filedata).is_separate {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nIn linked file '%s': \0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_name,
        );
    } else {
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    if !ext_data_orig.is_null() {
        if do_wide != 0 {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"LTO Symbol table '%s' and extension table '%s' contain:\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                printable_section_name(filedata, section),
                printable_section_name(filedata, ext),
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"LTO Symbol table '%s'\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                printable_section_name(filedata, section),
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" and extension table '%s' contain:\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                printable_section_name(filedata, ext),
            );
        }
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"LTO Symbol table '%s' contains:\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
        );
    }
    if !ext_data_orig.is_null() {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Comdat_Key       Kind  Visibility     Size      Slot      Type  Section Name\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Comdat_Key       Kind  Visibility     Size      Slot Name\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    loop {
        if !(data < end) {
            current_block = 10095721787123848864;
            break;
        }
        let mut sym_name: *const libc::c_uchar = data;
        data = data
            .offset(
                (strnlen(
                    sym_name as *const libc::c_char,
                    end.offset_from(data) as libc::c_long as size_t,
                ))
                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
            );
        if data >= end {
            current_block = 4221810264664061047;
            break;
        }
        let mut comdat_key: *const libc::c_uchar = data;
        data = data
            .offset(
                (strnlen(
                    comdat_key as *const libc::c_char,
                    end.offset_from(data) as libc::c_long as size_t,
                ))
                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
            );
        if data >= end {
            current_block = 4221810264664061047;
            break;
        }
        if data
            .offset(2 as libc::c_int as isize)
            .offset(8 as libc::c_int as isize)
            .offset(4 as libc::c_int as isize) > end
        {
            current_block = 4221810264664061047;
            break;
        }
        let fresh31 = data;
        data = data.offset(1);
        let mut kind: libc::c_uint = *fresh31 as libc::c_uint;
        let fresh32 = data;
        data = data.offset(1);
        let mut visibility: libc::c_uint = *fresh32 as libc::c_uint;
        let mut size: elf_vma = byte_get
            .expect("non-null function pointer")(data, 8 as libc::c_int as libc::c_uint);
        data = data.offset(8 as libc::c_int as isize);
        let mut slot: elf_vma = byte_get
            .expect("non-null function pointer")(data, 4 as libc::c_int as libc::c_uint);
        data = data.offset(4 as libc::c_int as isize);
        if !ext_data.is_null() {
            if ext_data < ext_data_end.offset(-(1 as libc::c_int as isize)) {
                let fresh33 = ext_data;
                ext_data = ext_data.offset(1);
                let mut sym_type: libc::c_uint = *fresh33 as libc::c_uint;
                let fresh34 = ext_data;
                ext_data = ext_data.offset(1);
                let mut sec_kind: libc::c_uint = *fresh34 as libc::c_uint;
                printf(
                    b"  %10s %10s %11s %08lx  %08lx %9s %08lx _\0" as *const u8
                        as *const libc::c_char,
                    if *comdat_key as libc::c_int == 0 as libc::c_int {
                        b"-\0" as *const u8 as *const libc::c_char
                    } else {
                        comdat_key as *mut libc::c_char as *const libc::c_char
                    },
                    get_lto_kind(kind),
                    get_lto_visibility(visibility),
                    size as libc::c_long,
                    slot as libc::c_long,
                    get_lto_sym_type(sym_type),
                    sec_kind as libc::c_long,
                );
                print_symbol(6 as libc::c_int, sym_name as *const libc::c_char);
            } else {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Ran out of LTO symbol extension data\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                ext_data = 0 as *mut libc::c_char;
            }
        } else {
            printf(
                b"  %10s %10s %11s %08lx  %08lx _\0" as *const u8 as *const libc::c_char,
                if *comdat_key as libc::c_int == 0 as libc::c_int {
                    b"-\0" as *const u8 as *const libc::c_char
                } else {
                    comdat_key as *mut libc::c_char as *const libc::c_char
                },
                get_lto_kind(kind),
                get_lto_visibility(visibility),
                size as libc::c_long,
                slot as libc::c_long,
            );
            print_symbol(21 as libc::c_int, sym_name as *const libc::c_char);
        }
        putchar('\n' as i32);
    }
    match current_block {
        10095721787123848864 => {
            if !ext_data.is_null() && ext_data < ext_data_end {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Data remains in the LTO symbol extension table\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                free(alloced_data);
                free(ext_data_orig);
                free(ext_name as *mut libc::c_void);
                return 1 as libc::c_int != 0;
            }
        }
        _ => {}
    }
    error(
        dcgettext(
            0 as *const libc::c_char,
            b"Buffer overrun encountered whilst decoding LTO symbol table\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    free(alloced_data);
    free(ext_data_orig);
    free(ext_name as *mut libc::c_void);
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn process_lto_symbol_tables(mut filedata: *mut Filedata) -> bool {
    let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_uint = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    if !do_lto_syms {
        return 1 as libc::c_int != 0;
    }
    if ((*filedata).section_headers).is_null() {
        return 1 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as libc::c_uint;
    section = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum {
        if !section.is_null() && !((*filedata).string_table).is_null()
            && ((*section).sh_name as libc::c_ulong) < (*filedata).string_table_length
            && startswith(
                ((*filedata).string_table).offset((*section).sh_name as isize),
                b".gnu.lto_.symtab.\0" as *const u8 as *const libc::c_char,
            ) as libc::c_int != 0
        {
            res = (res as libc::c_int
                & display_lto_symtab(filedata, section) as libc::c_int) != 0;
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    return res;
}
unsafe extern "C" fn process_symbol_table(mut filedata: *mut Filedata) -> bool {
    let mut current_block: u64;
    let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    if !do_syms && !do_dyn_syms && !do_histogram {
        return 1 as libc::c_int != 0;
    }
    if ((*filedata).dynamic_info[4 as libc::c_int as usize] != 0
        || (*filedata).dynamic_info_DT_GNU_HASH != 0) && do_syms as libc::c_int != 0
        && do_using_dynamic as libc::c_int != 0
        && !((*filedata).dynamic_strings).is_null()
        && !((*filedata).dynamic_symbols).is_null()
    {
        let mut si: libc::c_ulong = 0;
        if (*filedata).is_separate {
            printf(
                dcngettext(
                    0 as *const libc::c_char,
                    b"\nIn linked file '%s' the dynamic symbol table contains %lu entry:\n\0"
                        as *const u8 as *const libc::c_char,
                    b"\nIn linked file '%s' the dynamic symbol table contains %lu entries:\n\0"
                        as *const u8 as *const libc::c_char,
                    (*filedata).num_dynamic_syms,
                    5 as libc::c_int,
                ),
                (*filedata).file_name,
                (*filedata).num_dynamic_syms,
            );
        } else {
            printf(
                dcngettext(
                    0 as *const libc::c_char,
                    b"\nSymbol table for image contains %lu entry:\n\0" as *const u8
                        as *const libc::c_char,
                    b"\nSymbol table for image contains %lu entries:\n\0" as *const u8
                        as *const libc::c_char,
                    (*filedata).num_dynamic_syms,
                    5 as libc::c_int,
                ),
                (*filedata).num_dynamic_syms,
            );
        }
        if is_32bit_elf {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"   Num:    Value  Size Type    Bind   Vis      Ndx Name\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"   Num:    Value          Size Type    Bind   Vis      Ndx Name\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        si = 0 as libc::c_int as libc::c_ulong;
        while si < (*filedata).num_dynamic_syms {
            print_dynamic_symbol(
                filedata,
                si,
                (*filedata).dynamic_symbols,
                0 as *mut Elf_Internal_Shdr,
                (*filedata).dynamic_strings,
                (*filedata).dynamic_strings_length,
            );
            si = si.wrapping_add(1);
            si;
        }
    } else if (do_dyn_syms as libc::c_int != 0
        || do_syms as libc::c_int != 0 && !do_using_dynamic)
        && !((*filedata).section_headers).is_null()
    {
        let mut i: libc::c_uint = 0;
        i = 0 as libc::c_int as libc::c_uint;
        section = (*filedata).section_headers;
        while i < (*filedata).file_header.e_shnum {
            let mut strtab: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut strtab_size: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
            let mut symtab: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
            let mut si_0: libc::c_ulong = 0;
            let mut num_syms: libc::c_ulong = 0;
            if !((*section).sh_type != 2 as libc::c_int as libc::c_uint
                && (*section).sh_type != 11 as libc::c_int as libc::c_uint
                || !do_syms && (*section).sh_type == 2 as libc::c_int as libc::c_uint)
            {
                if (*section).sh_entsize == 0 as libc::c_int as libc::c_ulong {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\nSymbol table '%s' has a sh_entsize of zero!\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        printable_section_name(filedata, section),
                    );
                } else {
                    num_syms = ((*section).sh_size).wrapping_div((*section).sh_entsize);
                    if (*filedata).is_separate {
                        printf(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"\nIn linked file '%s' symbol section '%s' contains %lu entry:\n\0"
                                    as *const u8 as *const libc::c_char,
                                b"\nIn linked file '%s' symbol section '%s' contains %lu entries:\n\0"
                                    as *const u8 as *const libc::c_char,
                                num_syms,
                                5 as libc::c_int,
                            ),
                            (*filedata).file_name,
                            printable_section_name(filedata, section),
                            num_syms,
                        );
                    } else {
                        printf(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"\nSymbol table '%s' contains %lu entry:\n\0" as *const u8
                                    as *const libc::c_char,
                                b"\nSymbol table '%s' contains %lu entries:\n\0"
                                    as *const u8 as *const libc::c_char,
                                num_syms,
                                5 as libc::c_int,
                            ),
                            printable_section_name(filedata, section),
                            num_syms,
                        );
                    }
                    if is_32bit_elf {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"   Num:    Value  Size Type    Bind   Vis      Ndx Name\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"   Num:    Value          Size Type    Bind   Vis      Ndx Name\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    symtab = get_elf_symbols(filedata, section, &mut num_syms);
                    if !symtab.is_null() {
                        if (*section).sh_link == (*filedata).file_header.e_shstrndx {
                            strtab = (*filedata).string_table;
                            strtab_size = (*filedata).string_table_length;
                        } else if (*section).sh_link < (*filedata).file_header.e_shnum {
                            let mut string_sec: *mut Elf_Internal_Shdr = 0
                                as *mut Elf_Internal_Shdr;
                            string_sec = ((*filedata).section_headers)
                                .offset((*section).sh_link as isize);
                            strtab = get_data(
                                0 as *mut libc::c_void,
                                filedata,
                                (*string_sec).sh_offset as libc::c_ulong,
                                1 as libc::c_int as bfd_size_type,
                                (*string_sec).sh_size,
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"string table\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            ) as *mut libc::c_char;
                            strtab_size = if !strtab.is_null() {
                                (*string_sec).sh_size
                            } else {
                                0 as libc::c_int as libc::c_ulong
                            };
                        }
                        si_0 = 0 as libc::c_int as libc::c_ulong;
                        while si_0 < num_syms {
                            print_dynamic_symbol(
                                filedata,
                                si_0,
                                symtab,
                                section,
                                strtab,
                                strtab_size,
                            );
                            si_0 = si_0.wrapping_add(1);
                            si_0;
                        }
                        free(symtab as *mut libc::c_void);
                        if strtab != (*filedata).string_table {
                            free(strtab as *mut libc::c_void);
                        }
                    }
                }
            }
            i = i.wrapping_add(1);
            i;
            section = section.offset(1);
            section;
        }
    } else if do_syms {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nDynamic symbol information is not available for displaying symbols.\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    if do_histogram as libc::c_int != 0 && !((*filedata).buckets).is_null() {
        let mut lengths: *mut libc::c_ulong = 0 as *mut libc::c_ulong;
        let mut counts: *mut libc::c_ulong = 0 as *mut libc::c_ulong;
        let mut hn: libc::c_ulong = 0;
        let mut si_1: bfd_vma = 0;
        let mut maxlength: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
        let mut nzero_counts: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
        let mut nsyms: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
        let mut visited: *mut libc::c_char = 0 as *mut libc::c_char;
        printf(
            dcngettext(
                0 as *const libc::c_char,
                b"\nHistogram for bucket list length (total of %lu bucket):\n\0"
                    as *const u8 as *const libc::c_char,
                b"\nHistogram for bucket list length (total of %lu buckets):\n\0"
                    as *const u8 as *const libc::c_char,
                (*filedata).nbuckets,
                5 as libc::c_int,
            ),
            (*filedata).nbuckets,
        );
        lengths = calloc(
            (*filedata).nbuckets,
            ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong,
        ) as *mut libc::c_ulong;
        if lengths.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Out of memory allocating space for histogram buckets\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            current_block = 13991705295567883643;
        } else {
            visited = xcmalloc((*filedata).nchains, 1 as libc::c_int as size_t)
                as *mut libc::c_char;
            memset(visited as *mut libc::c_void, 0 as libc::c_int, (*filedata).nchains);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Length  Number     %% of total  Coverage\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            hn = 0 as libc::c_int as libc::c_ulong;
            while hn < (*filedata).nbuckets {
                si_1 = *((*filedata).buckets).offset(hn as isize);
                while si_1 > 0 as libc::c_int as libc::c_ulong {
                    nsyms = nsyms.wrapping_add(1);
                    nsyms;
                    let ref mut fresh35 = *lengths.offset(hn as isize);
                    *fresh35 = (*fresh35).wrapping_add(1);
                    if maxlength < *fresh35 {
                        maxlength = maxlength.wrapping_add(1);
                        maxlength;
                    }
                    if si_1 >= (*filedata).nchains
                        || *visited.offset(si_1 as isize) as libc::c_int != 0
                    {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"histogram chain is corrupt\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        break;
                    } else {
                        *visited
                            .offset(si_1 as isize) = 1 as libc::c_int as libc::c_char;
                        si_1 = *((*filedata).chains).offset(si_1 as isize);
                    }
                }
                hn = hn.wrapping_add(1);
                hn;
            }
            free(visited as *mut libc::c_void);
            counts = calloc(
                maxlength.wrapping_add(1 as libc::c_int as libc::c_ulong),
                ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong,
            ) as *mut libc::c_ulong;
            if counts.is_null() {
                free(lengths as *mut libc::c_void);
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Out of memory allocating space for histogram counts\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                current_block = 13991705295567883643;
            } else {
                hn = 0 as libc::c_int as libc::c_ulong;
                while hn < (*filedata).nbuckets {
                    let ref mut fresh36 = *counts
                        .offset(*lengths.offset(hn as isize) as isize);
                    *fresh36 = (*fresh36).wrapping_add(1);
                    let _ = *fresh36;
                    hn = hn.wrapping_add(1);
                    hn;
                }
                if (*filedata).nbuckets > 0 as libc::c_int as libc::c_ulong {
                    let mut i_0: libc::c_ulong = 0;
                    printf(
                        b"      0  %-10lu (%5.1f%%)\n\0" as *const u8
                            as *const libc::c_char,
                        *counts.offset(0 as libc::c_int as isize),
                        *counts.offset(0 as libc::c_int as isize) as libc::c_double
                            * 100.0f64 / (*filedata).nbuckets as libc::c_double,
                    );
                    i_0 = 1 as libc::c_int as libc::c_ulong;
                    while i_0 <= maxlength {
                        nzero_counts = nzero_counts
                            .wrapping_add(
                                (*counts.offset(i_0 as isize)).wrapping_mul(i_0),
                            );
                        printf(
                            b"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n\0" as *const u8
                                as *const libc::c_char,
                            i_0,
                            *counts.offset(i_0 as isize),
                            *counts.offset(i_0 as isize) as libc::c_double * 100.0f64
                                / (*filedata).nbuckets as libc::c_double,
                            nzero_counts as libc::c_double * 100.0f64
                                / nsyms as libc::c_double,
                        );
                        i_0 = i_0.wrapping_add(1);
                        i_0;
                    }
                }
                free(counts as *mut libc::c_void);
                free(lengths as *mut libc::c_void);
                current_block = 10778260831612459202;
            }
        }
    } else {
        current_block = 10778260831612459202;
    }
    match current_block {
        10778260831612459202 => {
            free((*filedata).buckets as *mut libc::c_void);
            (*filedata).buckets = 0 as *mut bfd_vma;
            (*filedata).nbuckets = 0 as libc::c_int as bfd_size_type;
            free((*filedata).chains as *mut libc::c_void);
            (*filedata).chains = 0 as *mut bfd_vma;
            if do_histogram as libc::c_int != 0 && !((*filedata).gnubuckets).is_null() {
                let mut lengths_0: *mut libc::c_ulong = 0 as *mut libc::c_ulong;
                let mut counts_0: *mut libc::c_ulong = 0 as *mut libc::c_ulong;
                let mut hn_0: libc::c_ulong = 0;
                let mut maxlength_0: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
                let mut nzero_counts_0: libc::c_ulong = 0 as libc::c_int
                    as libc::c_ulong;
                let mut nsyms_0: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
                printf(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"\nHistogram for `%s' bucket list length (total of %lu bucket):\n\0"
                            as *const u8 as *const libc::c_char,
                        b"\nHistogram for `%s' bucket list length (total of %lu buckets):\n\0"
                            as *const u8 as *const libc::c_char,
                        (*filedata).ngnubuckets,
                        5 as libc::c_int,
                    ),
                    if (*filedata).dynamic_info_DT_MIPS_XHASH != 0 {
                        b".MIPS.xhash\0" as *const u8 as *const libc::c_char
                    } else {
                        b".gnu.hash\0" as *const u8 as *const libc::c_char
                    },
                    (*filedata).ngnubuckets,
                );
                lengths_0 = calloc(
                    (*filedata).ngnubuckets,
                    ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong,
                ) as *mut libc::c_ulong;
                if lengths_0.is_null() {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Out of memory allocating space for gnu histogram buckets\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    current_block = 13991705295567883643;
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" Length  Number     %% of total  Coverage\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    hn_0 = 0 as libc::c_int as libc::c_ulong;
                    while hn_0 < (*filedata).ngnubuckets {
                        if *((*filedata).gnubuckets).offset(hn_0 as isize)
                            != 0 as libc::c_int as libc::c_ulong
                        {
                            let mut off: bfd_vma = 0;
                            let mut length: bfd_vma = 1 as libc::c_int as bfd_vma;
                            off = (*((*filedata).gnubuckets).offset(hn_0 as isize))
                                .wrapping_sub((*filedata).gnusymidx);
                            while off < (*filedata).ngnuchains
                                && *((*filedata).gnuchains).offset(off as isize)
                                    & 1 as libc::c_int as libc::c_ulong
                                    == 0 as libc::c_int as libc::c_ulong
                            {
                                length = length.wrapping_add(1);
                                length;
                                off = off.wrapping_add(1);
                                off;
                            }
                            *lengths_0.offset(hn_0 as isize) = length;
                            if length > maxlength_0 {
                                maxlength_0 = length;
                            }
                            nsyms_0 = nsyms_0.wrapping_add(length);
                        }
                        hn_0 = hn_0.wrapping_add(1);
                        hn_0;
                    }
                    counts_0 = calloc(
                        maxlength_0.wrapping_add(1 as libc::c_int as libc::c_ulong),
                        ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong,
                    ) as *mut libc::c_ulong;
                    if counts_0.is_null() {
                        free(lengths_0 as *mut libc::c_void);
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Out of memory allocating space for gnu histogram counts\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        current_block = 13991705295567883643;
                    } else {
                        hn_0 = 0 as libc::c_int as libc::c_ulong;
                        while hn_0 < (*filedata).ngnubuckets {
                            let ref mut fresh37 = *counts_0
                                .offset(*lengths_0.offset(hn_0 as isize) as isize);
                            *fresh37 = (*fresh37).wrapping_add(1);
                            let _ = *fresh37;
                            hn_0 = hn_0.wrapping_add(1);
                            hn_0;
                        }
                        if (*filedata).ngnubuckets > 0 as libc::c_int as libc::c_ulong {
                            let mut j: libc::c_ulong = 0;
                            printf(
                                b"      0  %-10lu (%5.1f%%)\n\0" as *const u8
                                    as *const libc::c_char,
                                *counts_0.offset(0 as libc::c_int as isize),
                                *counts_0.offset(0 as libc::c_int as isize)
                                    as libc::c_double * 100.0f64
                                    / (*filedata).ngnubuckets as libc::c_double,
                            );
                            j = 1 as libc::c_int as libc::c_ulong;
                            while j <= maxlength_0 {
                                nzero_counts_0 = nzero_counts_0
                                    .wrapping_add(
                                        (*counts_0.offset(j as isize)).wrapping_mul(j),
                                    );
                                printf(
                                    b"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n\0" as *const u8
                                        as *const libc::c_char,
                                    j,
                                    *counts_0.offset(j as isize),
                                    *counts_0.offset(j as isize) as libc::c_double * 100.0f64
                                        / (*filedata).ngnubuckets as libc::c_double,
                                    nzero_counts_0 as libc::c_double * 100.0f64
                                        / nsyms_0 as libc::c_double,
                                );
                                j = j.wrapping_add(1);
                                j;
                            }
                        }
                        free(counts_0 as *mut libc::c_void);
                        free(lengths_0 as *mut libc::c_void);
                        current_block = 17702298541784679949;
                    }
                }
            } else {
                current_block = 17702298541784679949;
            }
            match current_block {
                13991705295567883643 => {}
                _ => {
                    free((*filedata).gnubuckets as *mut libc::c_void);
                    (*filedata).gnubuckets = 0 as *mut bfd_vma;
                    (*filedata).ngnubuckets = 0 as libc::c_int as bfd_size_type;
                    free((*filedata).gnuchains as *mut libc::c_void);
                    (*filedata).gnuchains = 0 as *mut bfd_vma;
                    (*filedata).ngnuchains = 0 as libc::c_int as bfd_size_type;
                    free((*filedata).mipsxlat as *mut libc::c_void);
                    (*filedata).mipsxlat = 0 as *mut bfd_vma;
                    return 1 as libc::c_int != 0;
                }
            }
        }
        _ => {}
    }
    free((*filedata).gnubuckets as *mut libc::c_void);
    (*filedata).gnubuckets = 0 as *mut bfd_vma;
    (*filedata).ngnubuckets = 0 as libc::c_int as bfd_size_type;
    free((*filedata).gnuchains as *mut libc::c_void);
    (*filedata).gnuchains = 0 as *mut bfd_vma;
    (*filedata).ngnuchains = 0 as libc::c_int as bfd_size_type;
    free((*filedata).mipsxlat as *mut libc::c_void);
    (*filedata).mipsxlat = 0 as *mut bfd_vma;
    free((*filedata).buckets as *mut libc::c_void);
    (*filedata).buckets = 0 as *mut bfd_vma;
    (*filedata).nbuckets = 0 as libc::c_int as bfd_size_type;
    free((*filedata).chains as *mut libc::c_void);
    (*filedata).chains = 0 as *mut bfd_vma;
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn process_syminfo(mut filedata: *mut Filedata) -> bool {
    let mut i: libc::c_uint = 0;
    if ((*filedata).dynamic_syminfo).is_null() || !do_dynamic {
        return 1 as libc::c_int != 0;
    }
    if ((*filedata).dynamic_symbols).is_null() || ((*filedata).dynamic_strings).is_null()
    {
        return 0 as libc::c_int != 0;
    }
    if (*filedata).is_separate {
        printf(
            dcngettext(
                0 as *const libc::c_char,
                b"\nIn linked file '%s: the dynamic info segment at offset 0x%lx contains %d entry:\n\0"
                    as *const u8 as *const libc::c_char,
                b"\nIn linked file '%s: the dynamic info segment at offset 0x%lx contains %d entries:\n\0"
                    as *const u8 as *const libc::c_char,
                (*filedata).dynamic_syminfo_nent as libc::c_ulong,
                5 as libc::c_int,
            ),
            (*filedata).file_name,
            (*filedata).dynamic_syminfo_offset,
            (*filedata).dynamic_syminfo_nent,
        );
    } else {
        printf(
            dcngettext(
                0 as *const libc::c_char,
                b"\nDynamic info segment at offset 0x%lx contains %d entry:\n\0"
                    as *const u8 as *const libc::c_char,
                b"\nDynamic info segment at offset 0x%lx contains %d entries:\n\0"
                    as *const u8 as *const libc::c_char,
                (*filedata).dynamic_syminfo_nent as libc::c_ulong,
                5 as libc::c_int,
            ),
            (*filedata).dynamic_syminfo_offset,
            (*filedata).dynamic_syminfo_nent,
        );
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b" Num: Name                           BoundTo     Flags\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*filedata).dynamic_syminfo_nent {
        let mut flags_0: libc::c_ushort = (*((*filedata).dynamic_syminfo)
            .offset(i as isize))
            .si_flags;
        printf(b"%4d: \0" as *const u8 as *const libc::c_char, i);
        if i as libc::c_ulong >= (*filedata).num_dynamic_syms {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt index>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else if !((*filedata).dynamic_strings).is_null()
            && (*((*filedata).dynamic_symbols).offset(i as isize)).st_name
                < (*filedata).dynamic_strings_length
        {
            print_symbol(
                30 as libc::c_int,
                ((*filedata).dynamic_strings)
                    .offset(
                        (*((*filedata).dynamic_symbols).offset(i as isize)).st_name
                            as isize,
                    ),
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt: %19ld>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*((*filedata).dynamic_symbols).offset(i as isize)).st_name,
            );
        }
        putchar(' ' as i32);
        match (*((*filedata).dynamic_syminfo).offset(i as isize)).si_boundto
            as libc::c_int
        {
            65535 => {
                fputs(b"SELF       \0" as *const u8 as *const libc::c_char, stdout);
            }
            65534 => {
                fputs(b"PARENT     \0" as *const u8 as *const libc::c_char, stdout);
            }
            _ => {
                if (*((*filedata).dynamic_syminfo).offset(i as isize)).si_boundto
                    as libc::c_int > 0 as libc::c_int
                    && ((*((*filedata).dynamic_syminfo).offset(i as isize)).si_boundto
                        as libc::c_ulong) < (*filedata).dynamic_nent
                    && (!((*filedata).dynamic_strings).is_null()
                        && (*((*filedata).dynamic_section)
                            .offset(
                                (*((*filedata).dynamic_syminfo).offset(i as isize))
                                    .si_boundto as isize,
                            ))
                            .d_un
                            .d_val < (*filedata).dynamic_strings_length)
                {
                    print_symbol(
                        10 as libc::c_int,
                        ((*filedata).dynamic_strings)
                            .offset(
                                (*((*filedata).dynamic_section)
                                    .offset(
                                        (*((*filedata).dynamic_syminfo).offset(i as isize))
                                            .si_boundto as isize,
                                    ))
                                    .d_un
                                    .d_val as isize,
                            ),
                    );
                    putchar(' ' as i32);
                } else {
                    printf(
                        b"%-10d \0" as *const u8 as *const libc::c_char,
                        (*((*filedata).dynamic_syminfo).offset(i as isize)).si_boundto
                            as libc::c_int,
                    );
                }
            }
        }
        if flags_0 as libc::c_int & 0x1 as libc::c_int != 0 {
            printf(b" DIRECT\0" as *const u8 as *const libc::c_char);
        }
        if flags_0 as libc::c_int & 0x2 as libc::c_int != 0 {
            printf(b" PASSTHRU\0" as *const u8 as *const libc::c_char);
        }
        if flags_0 as libc::c_int & 0x4 as libc::c_int != 0 {
            printf(b" COPY\0" as *const u8 as *const libc::c_char);
        }
        if flags_0 as libc::c_int & 0x8 as libc::c_int != 0 {
            printf(b" LAZYLOAD\0" as *const u8 as *const libc::c_char);
        }
        puts(b"\0" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(1);
        i;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn target_specific_reloc_handling(
    mut filedata: *mut Filedata,
    mut reloc: *mut Elf_Internal_Rela,
    mut start: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut symtab: *mut Elf_Internal_Sym,
    mut num_syms: libc::c_ulong,
) -> bool {
    let mut current_block: u64;
    let mut reloc_type: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut sym_index: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    if !reloc.is_null() {
        reloc_type = get_reloc_type(filedata, (*reloc).r_info);
        sym_index = get_reloc_symindex((*reloc).r_info);
    }
    match (*filedata).file_header.e_machine as libc::c_int {
        105 | 4185 => {
            static mut saved_sym: *mut Elf_Internal_Sym = 0 as *const Elf_Internal_Sym
                as *mut Elf_Internal_Sym;
            if reloc.is_null() {
                saved_sym = 0 as *mut Elf_Internal_Sym;
                return 1 as libc::c_int != 0;
            }
            match reloc_type {
                10 | 12 => {
                    if uses_msp430x_relocs(filedata) {
                        current_block = 15864857819291709765;
                    } else {
                        current_block = 5373162655536212628;
                    }
                }
                21 | 23 => {
                    current_block = 5373162655536212628;
                }
                1 | 3 => {
                    current_block = 9272762965268863310;
                }
                5 | 9 | 11 => {
                    if uses_msp430x_relocs(filedata) {
                        current_block = 15864857819291709765;
                    } else {
                        current_block = 9272762965268863310;
                    }
                }
                2 | 15 | 22 => {
                    if !uses_msp430x_relocs(filedata) {
                        current_block = 15864857819291709765;
                    } else {
                        current_block = 9272762965268863310;
                    }
                }
                _ => {
                    if !saved_sym.is_null() {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Unhandled MSP430 reloc type found after SYM_DIFF reloc\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    current_block = 15864857819291709765;
                }
            }
            match current_block {
                15864857819291709765 => {}
                _ => {
                    match current_block {
                        9272762965268863310 => {
                            if !saved_sym.is_null() {
                                let mut value: bfd_vma = 0;
                                let mut reloc_size: libc::c_uint = 0 as libc::c_int
                                    as libc::c_uint;
                                let mut leb_ret: libc::c_int = 0 as libc::c_int;
                                match reloc_type {
                                    1 => {
                                        reloc_size = 4 as libc::c_int as libc::c_uint;
                                    }
                                    11 | 22 => {
                                        if (*reloc).r_offset
                                            < end.offset_from(start) as libc::c_long as size_t
                                        {
                                            read_leb128(
                                                start.offset((*reloc).r_offset as isize),
                                                end,
                                                0 as libc::c_int != 0,
                                                &mut reloc_size,
                                                &mut leb_ret,
                                            );
                                        }
                                    }
                                    _ => {
                                        reloc_size = 2 as libc::c_int as libc::c_uint;
                                    }
                                }
                                if leb_ret != 0 as libc::c_int
                                    || reloc_size == 0 as libc::c_int as libc::c_uint
                                    || reloc_size > 8 as libc::c_int as libc::c_uint
                                {
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"MSP430 ULEB128 field at 0x%lx contains invalid ULEB128 value\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        (*reloc).r_offset as libc::c_long,
                                    );
                                } else if sym_index >= num_syms {
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"MSP430 reloc contains invalid symbol index %lu\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        sym_index,
                                    );
                                } else {
                                    value = ((*reloc).r_addend)
                                        .wrapping_add(
                                            ((*symtab.offset(sym_index as isize)).st_value)
                                                .wrapping_sub((*saved_sym).st_value),
                                        );
                                    if start.offset((*reloc).r_offset as isize) >= start
                                        && start.offset((*reloc).r_offset as isize) < end
                                        && start
                                            .offset((*reloc).r_offset as isize)
                                            .offset(reloc_size as isize) <= end
                                    {
                                        byte_put
                                            .expect(
                                                "non-null function pointer",
                                            )(
                                            start.offset((*reloc).r_offset as isize),
                                            value,
                                            reloc_size,
                                        );
                                    } else {
                                        error(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"MSP430 sym diff reloc contains invalid offset: 0x%lx\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            (*reloc).r_offset as libc::c_long,
                                        );
                                    }
                                }
                                saved_sym = 0 as *mut Elf_Internal_Sym;
                                return 1 as libc::c_int != 0;
                            }
                        }
                        _ => {
                            if sym_index >= num_syms {
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    sym_index,
                                );
                            } else {
                                saved_sym = symtab.offset(sym_index as isize);
                            }
                            return 1 as libc::c_int != 0;
                        }
                    }
                }
            }
        }
        89 | 48879 => {
            static mut saved_sym_0: *mut Elf_Internal_Sym = 0 as *const Elf_Internal_Sym
                as *mut Elf_Internal_Sym;
            if reloc.is_null() {
                saved_sym_0 = 0 as *mut Elf_Internal_Sym;
                return 1 as libc::c_int != 0;
            }
            match reloc_type {
                34 => return 1 as libc::c_int != 0,
                33 => {
                    if sym_index >= num_syms {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            sym_index,
                        );
                    } else {
                        saved_sym_0 = symtab.offset(sym_index as isize);
                    }
                    return 1 as libc::c_int != 0;
                }
                1 | 2 => {
                    if !saved_sym_0.is_null() {
                        let mut reloc_size_0: libc::c_int = if reloc_type
                            == 1 as libc::c_int as libc::c_uint
                        {
                            4 as libc::c_int
                        } else {
                            2 as libc::c_int
                        };
                        let mut value_0: bfd_vma = 0;
                        if sym_index >= num_syms {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"MN10300 reloc contains invalid symbol index %lu\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                sym_index,
                            );
                        } else {
                            value_0 = ((*reloc).r_addend)
                                .wrapping_add(
                                    ((*symtab.offset(sym_index as isize)).st_value)
                                        .wrapping_sub((*saved_sym_0).st_value),
                                );
                            if start.offset((*reloc).r_offset as isize) >= start
                                && start.offset((*reloc).r_offset as isize) < end
                                && start
                                    .offset((*reloc).r_offset as isize)
                                    .offset(reloc_size_0 as isize) <= end
                            {
                                byte_put
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    start.offset((*reloc).r_offset as isize),
                                    value_0,
                                    reloc_size_0 as libc::c_uint,
                                );
                            } else {
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"MN10300 sym diff reloc contains invalid offset: 0x%lx\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    (*reloc).r_offset as libc::c_long,
                                );
                            }
                        }
                        saved_sym_0 = 0 as *mut Elf_Internal_Sym;
                        return 1 as libc::c_int != 0;
                    }
                }
                _ => {
                    if !saved_sym_0.is_null() {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Unhandled MN10300 reloc type found after SYM_DIFF reloc\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
            }
        }
        197 => {
            static mut saved_sym1: bfd_vma = 0 as libc::c_int as bfd_vma;
            static mut saved_sym2: bfd_vma = 0 as libc::c_int as bfd_vma;
            static mut value_1: bfd_vma = 0;
            if reloc.is_null() {
                saved_sym2 = 0 as libc::c_int as bfd_vma;
                saved_sym1 = saved_sym2;
                return 1 as libc::c_int != 0;
            }
            match reloc_type {
                128 => {
                    saved_sym1 = saved_sym2;
                    if sym_index >= num_syms {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"RL78_SYM reloc contains invalid symbol index %lu\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            sym_index,
                        );
                    } else {
                        saved_sym2 = (*symtab.offset(sym_index as isize)).st_value;
                        saved_sym2 = (saved_sym2 as libc::c_ulong)
                            .wrapping_add((*reloc).r_addend) as bfd_vma as bfd_vma;
                    }
                    return 1 as libc::c_int != 0;
                }
                131 => {
                    value_1 = saved_sym1.wrapping_sub(saved_sym2);
                    saved_sym1 = 0 as libc::c_int as bfd_vma;
                    saved_sym2 = saved_sym1;
                    return 1 as libc::c_int != 0;
                }
                65 => {
                    if start.offset((*reloc).r_offset as isize) >= start
                        && start.offset((*reloc).r_offset as isize) < end
                        && start
                            .offset((*reloc).r_offset as isize)
                            .offset(4 as libc::c_int as isize) <= end
                    {
                        byte_put
                            .expect(
                                "non-null function pointer",
                            )(
                            start.offset((*reloc).r_offset as isize),
                            value_1,
                            4 as libc::c_int as libc::c_uint,
                        );
                    } else {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"RL78 sym diff reloc contains invalid offset: 0x%lx\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*reloc).r_offset as libc::c_long,
                        );
                    }
                    value_1 = 0 as libc::c_int as bfd_vma;
                    return 1 as libc::c_int != 0;
                }
                67 => {
                    if start.offset((*reloc).r_offset as isize) >= start
                        && start.offset((*reloc).r_offset as isize) < end
                        && start
                            .offset((*reloc).r_offset as isize)
                            .offset(2 as libc::c_int as isize) <= end
                    {
                        byte_put
                            .expect(
                                "non-null function pointer",
                            )(
                            start.offset((*reloc).r_offset as isize),
                            value_1,
                            2 as libc::c_int as libc::c_uint,
                        );
                    } else {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"RL78 sym diff reloc contains invalid offset: 0x%lx\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*reloc).r_offset as libc::c_long,
                        );
                    }
                    value_1 = 0 as libc::c_int as bfd_vma;
                    return 1 as libc::c_int != 0;
                }
                _ => {}
            }
        }
        _ => {}
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn is_32bit_abs_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        3 | 6 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        4 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        7 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        19 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        183 => {
            return reloc_type == 258 as libc::c_int as libc::c_uint
                || reloc_type == 1 as libc::c_int as libc::c_uint;
        }
        247 => return reloc_type == 11 as libc::c_int as libc::c_uint,
        4643 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        36902 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        45 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        93 | 195 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        40 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        4183 | 83 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        106 => return reloc_type == 0x12 as libc::c_int as libc::c_uint,
        76 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        177 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        114 => return reloc_type == 15 as libc::c_int as libc::c_uint,
        252 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        21569 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        30288 | 85 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        30326 | 86 => return reloc_type == 12 as libc::c_int as libc::c_uint,
        23205 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        13104 | 84 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        222 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        48 | 46 | 47 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        50 => {
            return reloc_type == 0x64 as libc::c_int as libc::c_uint
                || reloc_type == 0x65 as libc::c_int as libc::c_uint
                || reloc_type == 0x24 as libc::c_int as libc::c_uint
                || reloc_type == 0x25 as libc::c_int as libc::c_uint;
        }
        33303 | 101 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        65210 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        138 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        65200 | 120 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        88 => return reloc_type == 34 as libc::c_int as libc::c_uint,
        70 | 53 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        19951 => {
            return reloc_type == 7 as libc::c_int as libc::c_uint
                || reloc_type == 6 as libc::c_int as libc::c_uint;
        }
        39 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        61453 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        174 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        189 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        8 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        80 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        57005 | 90 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        48879 | 89 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        223 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        4185 | 105 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        9520 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        167 => return reloc_type == 20 as libc::c_int as libc::c_uint,
        113 => return reloc_type == 12 as libc::c_int as libc::c_uint,
        65211 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        92 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        15 => {
            return reloc_type == 1 as libc::c_int as libc::c_uint
                || reloc_type == 2 as libc::c_int as libc::c_uint
                || reloc_type == 41 as libc::c_int as libc::c_uint;
        }
        91 | 99 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        21 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        20 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        144 => return reloc_type == 11 as libc::c_int as libc::c_uint,
        243 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        197 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        173 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        9 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        41872 | 22 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        135 => return reloc_type == 8 as libc::c_int as libc::c_uint,
        42 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        18 | 43 | 2 => {
            return reloc_type == 3 as libc::c_int as libc::c_uint
                || reloc_type == 23 as libc::c_int as libc::c_uint;
        }
        23 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        140 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        191 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        188 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        36992 | 87 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        36 => return reloc_type == 0x33 as libc::c_int as libc::c_uint,
        75 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        221 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        16727 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        62 | 180 | 181 => return reloc_type == 10 as libc::c_int as libc::c_uint,
        18056 | 116 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        115 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        44357 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        43975 | 94 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        220 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        _ => {
            static mut prev_warn: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            if prev_warn != (*filedata).file_header.e_machine as libc::c_uint {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_header.e_machine as libc::c_int,
                );
            }
            prev_warn = (*filedata).file_header.e_machine as libc::c_uint;
            return 0 as libc::c_int != 0;
        }
    };
}
unsafe extern "C" fn is_32bit_pcrel_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        3 | 6 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        4 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        183 => return reloc_type == 261 as libc::c_int as libc::c_uint,
        4643 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        36902 => return reloc_type == 10 as libc::c_int as libc::c_uint,
        93 | 195 => return reloc_type == 49 as libc::c_int as libc::c_uint,
        40 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        4183 | 83 => return reloc_type == 36 as libc::c_int as libc::c_uint,
        189 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        92 => return reloc_type == 9 as libc::c_int as libc::c_uint,
        15 => return reloc_type == 9 as libc::c_int as libc::c_uint,
        20 => return reloc_type == 26 as libc::c_int as libc::c_uint,
        21 => return reloc_type == 26 as libc::c_int as libc::c_uint,
        243 => return reloc_type == 57 as libc::c_int as libc::c_uint,
        41872 | 22 => return reloc_type == 5 as libc::c_int as libc::c_uint,
        42 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        18 | 43 | 2 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        23 => return reloc_type == 13 as libc::c_int as libc::c_uint,
        191 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        188 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        221 => return reloc_type == 6 as libc::c_int as libc::c_uint,
        62 | 180 | 181 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        75 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        43975 | 94 => return reloc_type == 14 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_64bit_abs_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        183 => return reloc_type == 257 as libc::c_int as libc::c_uint,
        36902 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        50 => {
            return reloc_type == 0x26 as libc::c_int as libc::c_uint
                || reloc_type == 0x27 as libc::c_int as libc::c_uint;
        }
        15 => return reloc_type == 80 as libc::c_int as libc::c_uint,
        21 => return reloc_type == 38 as libc::c_int as libc::c_uint,
        243 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        18 | 43 | 2 => {
            return reloc_type == 32 as libc::c_int as libc::c_uint
                || reloc_type == 54 as libc::c_int as libc::c_uint;
        }
        62 | 180 | 181 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        41872 | 22 => return reloc_type == 22 as libc::c_int as libc::c_uint,
        191 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        8 => return reloc_type == 18 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_64bit_pcrel_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        183 => return reloc_type == 260 as libc::c_int as libc::c_uint,
        36902 => return reloc_type == 11 as libc::c_int as libc::c_uint,
        50 => {
            return reloc_type == 0x4e as libc::c_int as libc::c_uint
                || reloc_type == 0x4f as libc::c_int as libc::c_uint;
        }
        15 => return reloc_type == 72 as libc::c_int as libc::c_uint,
        21 => return reloc_type == 44 as libc::c_int as libc::c_uint,
        18 | 43 | 2 => return reloc_type == 46 as libc::c_int as libc::c_uint,
        62 | 180 | 181 => return reloc_type == 24 as libc::c_int as libc::c_uint,
        41872 | 22 => return reloc_type == 23 as libc::c_int as libc::c_uint,
        191 => return reloc_type == 5 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_24bit_abs_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        57005 | 90 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        222 => return reloc_type == 5 as libc::c_int as libc::c_uint,
        220 => return reloc_type == 5 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_16bit_abs_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        45 | 93 | 195 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        4643 => return reloc_type == 5 as libc::c_int as libc::c_uint,
        4183 | 83 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        30288 | 85 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        222 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        48 | 46 | 47 => return reloc_type == R_H8_DIR16 as libc::c_int as libc::c_uint,
        33303 | 101 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        65200 | 120 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        57005 | 90 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        48879 | 89 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        105 => {
            if uses_msp430x_relocs(filedata) {
                return reloc_type == 2 as libc::c_int as libc::c_uint;
            }
        }
        4185 => {}
        167 => return reloc_type == 19 as libc::c_int as libc::c_uint,
        113 => return reloc_type == 13 as libc::c_int as libc::c_uint,
        65211 => return reloc_type == 9 as libc::c_int as libc::c_uint,
        92 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        243 => return reloc_type == 55 as libc::c_int as libc::c_uint,
        144 => return reloc_type == 8 as libc::c_int as libc::c_uint,
        140 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        221 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        18056 | 116 => return reloc_type == 2 as libc::c_int as libc::c_uint,
        115 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        220 => return reloc_type == 4 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    }
    return reloc_type == 5 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn is_8bit_abs_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 54 as libc::c_int as libc::c_uint,
        220 => return reloc_type == 1 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_6bit_abs_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 53 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_32bit_inplace_add_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 35 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_32bit_inplace_sub_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 39 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_64bit_inplace_add_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 36 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_64bit_inplace_sub_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 40 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_16bit_inplace_add_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 34 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_16bit_inplace_sub_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 38 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_8bit_inplace_add_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 33 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_8bit_inplace_sub_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 37 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_6bit_inplace_sub_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        243 => return reloc_type == 52 as libc::c_int as libc::c_uint,
        _ => return 0 as libc::c_int != 0,
    };
}
unsafe extern "C" fn is_none_reloc(
    mut filedata: *mut Filedata,
    mut reloc_type: libc::c_uint,
) -> bool {
    match (*filedata).file_header.e_machine as libc::c_int {
        3 | 4 | 4643 | 36902 | 113 | 45 | 195 | 93 | 40 | 116 | 76 | 222 | 50 | 181 | 180
        | 88 | 8 | 89 | 223 | 65211 | 92 | 15 | 21 | 20 | 243 | 22 | 41872 | 42 | 18 | 2
        | 43 | 191 | 188 | 140 | 62 | 18056 | 220 | 16727 => {
            return reloc_type == 0 as libc::c_int as libc::c_uint;
        }
        183 => {
            return reloc_type == 0 as libc::c_int as libc::c_uint
                || reloc_type == 256 as libc::c_int as libc::c_uint;
        }
        4183 | 83 => {
            return reloc_type == 0 as libc::c_int as libc::c_uint
                || reloc_type == 30 as libc::c_int as libc::c_uint
                || reloc_type == 31 as libc::c_int as libc::c_uint
                || reloc_type == 32 as libc::c_int as libc::c_uint;
        }
        174 => return reloc_type == 3 as libc::c_int as libc::c_uint,
        167 => {
            return reloc_type == 0 as libc::c_int as libc::c_uint
                || reloc_type == 204 as libc::c_int as libc::c_uint
                || reloc_type == 205 as libc::c_int as libc::c_uint
                || reloc_type == 206 as libc::c_int as libc::c_uint
                || reloc_type == 207 as libc::c_int as libc::c_uint;
        }
        144 => {
            return reloc_type == 0 as libc::c_int as libc::c_uint
                || reloc_type == 65 as libc::c_int as libc::c_uint
                || reloc_type == 66 as libc::c_int as libc::c_uint
                || reloc_type == 67 as libc::c_int as libc::c_uint;
        }
        43975 | 94 => {
            return reloc_type == 0 as libc::c_int as libc::c_uint
                || reloc_type == 17 as libc::c_int as libc::c_uint
                || reloc_type == 18 as libc::c_int as libc::c_uint
                || reloc_type == 19 as libc::c_int as libc::c_uint
                || reloc_type == 57 as libc::c_int as libc::c_uint
                || reloc_type == 58 as libc::c_int as libc::c_uint
                || reloc_type == 59 as libc::c_int as libc::c_uint
                || reloc_type == 60 as libc::c_int as libc::c_uint
                || reloc_type == 61 as libc::c_int as libc::c_uint
                || reloc_type == 62 as libc::c_int as libc::c_uint;
        }
        _ => {}
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn apply_relocations(
    mut filedata: *mut Filedata,
    mut section: *const Elf_Internal_Shdr,
    mut start: *mut libc::c_uchar,
    mut size: bfd_size_type,
    mut relocs_return: *mut *mut libc::c_void,
    mut num_relocs_return: *mut libc::c_ulong,
) -> bool {
    let mut relsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut end: *mut libc::c_uchar = start.offset(size as isize);
    if !relocs_return.is_null() {
        let ref mut fresh38 = *(relocs_return as *mut *mut Elf_Internal_Rela);
        *fresh38 = 0 as *mut Elf_Internal_Rela;
        *num_relocs_return = 0 as libc::c_int as libc::c_ulong;
    }
    if (*filedata).file_header.e_type as libc::c_int != 1 as libc::c_int {
        return 1 as libc::c_int != 0;
    }
    relsec = (*filedata).section_headers;
    while relsec
        < ((*filedata).section_headers).offset((*filedata).file_header.e_shnum as isize)
    {
        let mut is_rela: bool = false;
        let mut num_relocs: libc::c_ulong = 0;
        let mut relocs: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
        let mut rp: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
        let mut symsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut symtab: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        let mut num_syms: libc::c_ulong = 0;
        let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        if (*relsec).sh_type != 4 as libc::c_int as libc::c_uint
            && (*relsec).sh_type != 9 as libc::c_int as libc::c_uint
            || (*relsec).sh_info >= (*filedata).file_header.e_shnum
            || ((*filedata).section_headers).offset((*relsec).sh_info as isize)
                != section as *mut Elf_Internal_Shdr
            || (*relsec).sh_size == 0 as libc::c_int as libc::c_ulong
            || (*relsec).sh_link >= (*filedata).file_header.e_shnum
        {
            relsec = relsec.offset(1);
            relsec;
        } else {
            symsec = ((*filedata).section_headers).offset((*relsec).sh_link as isize);
            if (*symsec).sh_type != 2 as libc::c_int as libc::c_uint
                && (*symsec).sh_type != 11 as libc::c_int as libc::c_uint
            {
                return 0 as libc::c_int != 0;
            }
            is_rela = (*relsec).sh_type == 4 as libc::c_int as libc::c_uint;
            if is_rela {
                if !slurp_rela_relocs(
                    filedata,
                    (*relsec).sh_offset as libc::c_ulong,
                    (*relsec).sh_size,
                    &mut relocs,
                    &mut num_relocs,
                ) {
                    return 0 as libc::c_int != 0;
                }
            } else if !slurp_rel_relocs(
                filedata,
                (*relsec).sh_offset as libc::c_ulong,
                (*relsec).sh_size,
                &mut relocs,
                &mut num_relocs,
            ) {
                return 0 as libc::c_int != 0
            }
            if (*filedata).file_header.e_machine as libc::c_int == 42 as libc::c_int {
                is_rela = 0 as libc::c_int != 0;
            }
            symtab = get_elf_symbols(filedata, symsec, &mut num_syms);
            let mut current_block_74: u64;
            rp = relocs;
            while rp < relocs.offset(num_relocs as isize) {
                let mut addend: bfd_vma = 0;
                let mut reloc_type: libc::c_uint = 0;
                let mut reloc_size: libc::c_uint = 0;
                let mut reloc_inplace: bool = 0 as libc::c_int != 0;
                let mut reloc_subtract: bool = 0 as libc::c_int != 0;
                let mut rloc: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                let mut sym_index: libc::c_ulong = 0;
                reloc_type = get_reloc_type(filedata, (*rp).r_info);
                if !target_specific_reloc_handling(
                    filedata,
                    rp,
                    start,
                    end,
                    symtab,
                    num_syms,
                ) {
                    if !is_none_reloc(filedata, reloc_type) {
                        if is_32bit_abs_reloc(filedata, reloc_type) as libc::c_int != 0
                            || is_32bit_pcrel_reloc(filedata, reloc_type) as libc::c_int
                                != 0
                        {
                            reloc_size = 4 as libc::c_int as libc::c_uint;
                            current_block_74 = 17233182392562552756;
                        } else if is_64bit_abs_reloc(filedata, reloc_type) as libc::c_int
                            != 0
                            || is_64bit_pcrel_reloc(filedata, reloc_type) as libc::c_int
                                != 0
                        {
                            reloc_size = 8 as libc::c_int as libc::c_uint;
                            current_block_74 = 17233182392562552756;
                        } else if is_24bit_abs_reloc(filedata, reloc_type) {
                            reloc_size = 3 as libc::c_int as libc::c_uint;
                            current_block_74 = 17233182392562552756;
                        } else if is_16bit_abs_reloc(filedata, reloc_type) {
                            reloc_size = 2 as libc::c_int as libc::c_uint;
                            current_block_74 = 17233182392562552756;
                        } else if is_8bit_abs_reloc(filedata, reloc_type) as libc::c_int
                            != 0
                            || is_6bit_abs_reloc(filedata, reloc_type) as libc::c_int
                                != 0
                        {
                            reloc_size = 1 as libc::c_int as libc::c_uint;
                            current_block_74 = 17233182392562552756;
                        } else {
                            reloc_subtract = is_32bit_inplace_sub_reloc(
                                filedata,
                                reloc_type,
                            );
                            if reloc_subtract as libc::c_int != 0
                                || is_32bit_inplace_add_reloc(filedata, reloc_type)
                                    as libc::c_int != 0
                            {
                                reloc_size = 4 as libc::c_int as libc::c_uint;
                                reloc_inplace = 1 as libc::c_int != 0;
                                current_block_74 = 17233182392562552756;
                            } else {
                                reloc_subtract = is_64bit_inplace_sub_reloc(
                                    filedata,
                                    reloc_type,
                                );
                                if reloc_subtract as libc::c_int != 0
                                    || is_64bit_inplace_add_reloc(filedata, reloc_type)
                                        as libc::c_int != 0
                                {
                                    reloc_size = 8 as libc::c_int as libc::c_uint;
                                    reloc_inplace = 1 as libc::c_int != 0;
                                    current_block_74 = 17233182392562552756;
                                } else {
                                    reloc_subtract = is_16bit_inplace_sub_reloc(
                                        filedata,
                                        reloc_type,
                                    );
                                    if reloc_subtract as libc::c_int != 0
                                        || is_16bit_inplace_add_reloc(filedata, reloc_type)
                                            as libc::c_int != 0
                                    {
                                        reloc_size = 2 as libc::c_int as libc::c_uint;
                                        reloc_inplace = 1 as libc::c_int != 0;
                                        current_block_74 = 17233182392562552756;
                                    } else {
                                        reloc_subtract = is_8bit_inplace_sub_reloc(
                                            filedata,
                                            reloc_type,
                                        );
                                        if reloc_subtract as libc::c_int != 0
                                            || is_8bit_inplace_add_reloc(filedata, reloc_type)
                                                as libc::c_int != 0
                                        {
                                            reloc_size = 1 as libc::c_int as libc::c_uint;
                                            reloc_inplace = 1 as libc::c_int != 0;
                                            current_block_74 = 17233182392562552756;
                                        } else {
                                            reloc_subtract = is_6bit_inplace_sub_reloc(
                                                filedata,
                                                reloc_type,
                                            );
                                            if reloc_subtract {
                                                reloc_size = 1 as libc::c_int as libc::c_uint;
                                                reloc_inplace = 1 as libc::c_int != 0;
                                                current_block_74 = 17233182392562552756;
                                            } else {
                                                static mut prev_reloc: libc::c_uint = 0 as libc::c_int
                                                    as libc::c_uint;
                                                if reloc_type != prev_reloc {
                                                    warn(
                                                        dcgettext(
                                                            0 as *const libc::c_char,
                                                            b"unable to apply unsupported reloc type %d to section %s\n\0"
                                                                as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                        reloc_type,
                                                        printable_section_name(filedata, section),
                                                    );
                                                }
                                                prev_reloc = reloc_type;
                                                current_block_74 = 11042950489265723346;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        match current_block_74 {
                            11042950489265723346 => {}
                            _ => {
                                rloc = start.offset((*rp).r_offset as isize);
                                if !(rloc >= start && rloc < end
                                    && rloc.offset(reloc_size as isize) <= end)
                                {
                                    warn(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"skipping invalid relocation offset 0x%lx in section %s\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        (*rp).r_offset,
                                        printable_section_name(filedata, section),
                                    );
                                } else {
                                    sym_index = get_reloc_symindex((*rp).r_info);
                                    if sym_index >= num_syms {
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"skipping invalid relocation symbol index 0x%lx in section %s\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            sym_index,
                                            printable_section_name(filedata, section),
                                        );
                                    } else {
                                        sym = symtab.offset(sym_index as isize);
                                        if sym != symtab
                                            && (*sym).st_info as libc::c_int & 0xf as libc::c_int
                                                != 5 as libc::c_int
                                            && (*sym).st_info as libc::c_int & 0xf as libc::c_int
                                                > 3 as libc::c_int
                                        {
                                            warn(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"skipping unexpected symbol type %s in section %s relocation %ld\n\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                get_symbol_type(
                                                    filedata,
                                                    ((*sym).st_info as libc::c_int & 0xf as libc::c_int)
                                                        as libc::c_uint,
                                                ),
                                                printable_section_name(filedata, relsec),
                                                rp.offset_from(relocs) as libc::c_long,
                                            );
                                        } else {
                                            addend = 0 as libc::c_int as bfd_vma;
                                            if is_rela {
                                                addend = (addend as libc::c_ulong)
                                                    .wrapping_add((*rp).r_addend) as bfd_vma as bfd_vma;
                                            }
                                            if !is_rela
                                                || (*filedata).file_header.e_machine as libc::c_int
                                                    == 94 as libc::c_int
                                                    && reloc_type == 1 as libc::c_int as libc::c_uint
                                                || ((*filedata).file_header.e_machine as libc::c_int
                                                    == 91 as libc::c_int
                                                    || (*filedata).file_header.e_machine as libc::c_int
                                                        == 99 as libc::c_int)
                                                    && reloc_type == 1 as libc::c_int as libc::c_uint
                                                || ((*filedata).file_header.e_machine as libc::c_int
                                                    == 86 as libc::c_int
                                                    || (*filedata).file_header.e_machine as libc::c_int
                                                        == 0x7676 as libc::c_int)
                                                    && reloc_type == 12 as libc::c_int as libc::c_uint
                                                || reloc_inplace as libc::c_int != 0
                                            {
                                                if is_6bit_inplace_sub_reloc(filedata, reloc_type) {
                                                    addend = (addend as libc::c_ulong)
                                                        .wrapping_add(
                                                            byte_get
                                                                .expect("non-null function pointer")(rloc, reloc_size)
                                                                & 0x3f as libc::c_int as libc::c_ulong,
                                                        ) as bfd_vma as bfd_vma;
                                                } else {
                                                    addend = (addend as libc::c_ulong)
                                                        .wrapping_add(
                                                            byte_get
                                                                .expect("non-null function pointer")(rloc, reloc_size),
                                                        ) as bfd_vma as bfd_vma;
                                                }
                                            }
                                            if is_32bit_pcrel_reloc(filedata, reloc_type) as libc::c_int
                                                != 0
                                                || is_64bit_pcrel_reloc(filedata, reloc_type) as libc::c_int
                                                    != 0
                                            {
                                                if (*filedata).file_header.e_machine as libc::c_int
                                                    == 15 as libc::c_int
                                                {
                                                    addend = (addend as libc::c_ulong)
                                                        .wrapping_sub(8 as libc::c_int as libc::c_ulong) as bfd_vma
                                                        as bfd_vma;
                                                }
                                                byte_put
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(
                                                    rloc,
                                                    addend
                                                        .wrapping_add((*sym).st_value)
                                                        .wrapping_sub((*rp).r_offset),
                                                    reloc_size,
                                                );
                                            } else if is_6bit_abs_reloc(filedata, reloc_type)
                                                as libc::c_int != 0
                                                || is_6bit_inplace_sub_reloc(filedata, reloc_type)
                                                    as libc::c_int != 0
                                            {
                                                if reloc_subtract {
                                                    addend = (addend as libc::c_ulong)
                                                        .wrapping_sub((*sym).st_value) as bfd_vma as bfd_vma;
                                                } else {
                                                    addend = (addend as libc::c_ulong)
                                                        .wrapping_add((*sym).st_value) as bfd_vma as bfd_vma;
                                                }
                                                addend = addend & 0x3f as libc::c_int as libc::c_ulong
                                                    | byte_get
                                                        .expect("non-null function pointer")(rloc, reloc_size)
                                                        & 0xc0 as libc::c_int as libc::c_ulong;
                                                byte_put
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(rloc, addend, reloc_size);
                                            } else if reloc_subtract {
                                                byte_put
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(rloc, addend.wrapping_sub((*sym).st_value), reloc_size);
                                            } else {
                                                byte_put
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(rloc, addend.wrapping_add((*sym).st_value), reloc_size);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                rp = rp.offset(1);
                rp;
            }
            free(symtab as *mut libc::c_void);
            target_specific_reloc_handling(
                filedata,
                0 as *mut Elf_Internal_Rela,
                0 as *mut libc::c_uchar,
                0 as *mut libc::c_uchar,
                0 as *mut Elf_Internal_Sym,
                0 as libc::c_int as libc::c_ulong,
            );
            if !relocs_return.is_null() {
                let ref mut fresh39 = *(relocs_return as *mut *mut Elf_Internal_Rela);
                *fresh39 = relocs;
                *num_relocs_return = num_relocs;
            } else {
                free(relocs as *mut libc::c_void);
            }
            break;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_section_contents(
    mut section: *mut Elf_Internal_Shdr,
    mut filedata: *mut Filedata,
) -> *mut libc::c_char {
    let mut num_bytes: bfd_size_type = (*section).sh_size;
    if num_bytes == 0 as libc::c_int as libc::c_ulong
        || (*section).sh_type == 8 as libc::c_int as libc::c_uint
    {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Section '%s' has no data to dump.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
        );
        return 0 as *mut libc::c_char;
    }
    return get_data(
        0 as *mut libc::c_void,
        filedata,
        (*section).sh_offset as libc::c_ulong,
        1 as libc::c_int as bfd_size_type,
        num_bytes,
        dcgettext(
            0 as *const libc::c_char,
            b"section contents\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut libc::c_char;
}
unsafe extern "C" fn uncompress_section_contents(
    mut buffer: *mut *mut libc::c_uchar,
    mut uncompressed_size: dwarf_size_type,
    mut size: *mut dwarf_size_type,
) -> bool {
    let mut compressed_size: dwarf_size_type = *size;
    let mut compressed_buffer: *mut libc::c_uchar = *buffer;
    let mut uncompressed_buffer: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut strm: z_stream = z_stream {
        next_in: 0 as *mut Bytef,
        avail_in: 0,
        total_in: 0,
        next_out: 0 as *mut Bytef,
        avail_out: 0,
        total_out: 0,
        msg: 0 as *mut libc::c_char,
        state: 0 as *mut internal_state,
        zalloc: None,
        zfree: None,
        opaque: 0 as *mut libc::c_void,
        data_type: 0,
        adler: 0,
        reserved: 0,
    };
    let mut rc: libc::c_int = 0;
    memset(
        &mut strm as *mut z_stream as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<z_stream>() as libc::c_ulong,
    );
    strm.avail_in = compressed_size as uInt;
    strm.next_in = compressed_buffer as *mut Bytef;
    strm.avail_out = uncompressed_size as uInt;
    uncompressed_buffer = xmalloc(uncompressed_size) as *mut libc::c_uchar;
    rc = inflateInit_(
        &mut strm,
        b"1.2.11\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<z_stream>() as libc::c_ulong as libc::c_int,
    );
    while strm.avail_in > 0 as libc::c_int as libc::c_uint {
        if rc != 0 as libc::c_int {
            break;
        }
        strm
            .next_out = (uncompressed_buffer as *mut Bytef)
            .offset(
                uncompressed_size.wrapping_sub(strm.avail_out as libc::c_ulong) as isize,
            );
        rc = inflate(&mut strm, 4 as libc::c_int);
        if rc != 1 as libc::c_int {
            break;
        }
        rc = inflateReset(&mut strm);
    }
    if inflateEnd(&mut strm) != 0 as libc::c_int || rc != 0 as libc::c_int
        || strm.avail_out != 0 as libc::c_int as libc::c_uint
    {
        free(uncompressed_buffer as *mut libc::c_void);
        *buffer = 0 as *mut libc::c_uchar;
        return 0 as libc::c_int != 0;
    } else {
        *buffer = uncompressed_buffer;
        *size = uncompressed_size;
        return 1 as libc::c_int != 0;
    };
}
unsafe extern "C" fn dump_section_as_strings(
    mut section: *mut Elf_Internal_Shdr,
    mut filedata: *mut Filedata,
) -> bool {
    let mut state: mbstate_t = mbstate_t {
        __count: 0,
        __value: C2RustUnnamed { __wch: 0 },
    };
    let mut continuing: bool = false;
    let mut current_block: u64;
    let mut relsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut num_bytes: bfd_size_type = 0;
    let mut data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut real_start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut some_strings_shown: bool = false;
    start = get_section_contents(section, filedata) as *mut libc::c_uchar;
    real_start = start;
    if start.is_null() {
        return (*section).sh_size == 0 as libc::c_int as libc::c_ulong
            || (*section).sh_type == 8 as libc::c_int as libc::c_uint;
    }
    num_bytes = (*section).sh_size;
    if (*filedata).is_separate {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nString dump of section '%s' in linked file %s:\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
            (*filedata).file_name,
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nString dump of section '%s':\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
        );
    }
    if decompress_dumps {
        let mut new_size: dwarf_size_type = num_bytes;
        let mut uncompressed_size: dwarf_size_type = 0 as libc::c_int as dwarf_size_type;
        if (*section).sh_flags
            & ((1 as libc::c_int) << 11 as libc::c_int) as libc::c_ulong
            != 0 as libc::c_int as libc::c_ulong
        {
            let mut chdr: Elf_Internal_Chdr = Elf_Internal_Chdr {
                ch_type: 0,
                ch_size: 0,
                ch_addralign: 0,
            };
            let mut compression_header_size: libc::c_uint = get_compression_header(
                &mut chdr,
                start,
                num_bytes,
            );
            if compression_header_size == 0 as libc::c_int as libc::c_uint {
                current_block = 3617531036272013283;
            } else if chdr.ch_type != 1 as libc::c_int as libc::c_uint {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"section '%s' has unsupported compress type: %d\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    printable_section_name(filedata, section),
                    chdr.ch_type,
                );
                current_block = 3617531036272013283;
            } else {
                uncompressed_size = chdr.ch_size;
                start = start.offset(compression_header_size as isize);
                new_size = (new_size as libc::c_ulong)
                    .wrapping_sub(compression_header_size as libc::c_ulong)
                    as dwarf_size_type as dwarf_size_type;
                current_block = 14648156034262866959;
            }
        } else {
            if new_size > 12 as libc::c_int as libc::c_ulong
                && strcmp(
                    start as *mut libc::c_char,
                    b"ZLIB\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                uncompressed_size = *start.offset(4 as libc::c_int as isize)
                    as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(5 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(6 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(7 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(8 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(9 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(10 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(11 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                start = start.offset(12 as libc::c_int as isize);
                new_size = (new_size as libc::c_ulong)
                    .wrapping_sub(12 as libc::c_int as libc::c_ulong) as dwarf_size_type
                    as dwarf_size_type;
            }
            current_block = 14648156034262866959;
        }
        match current_block {
            14648156034262866959 => {
                if uncompressed_size != 0 {
                    if uncompress_section_contents(
                        &mut start,
                        uncompressed_size,
                        &mut new_size,
                    ) {
                        num_bytes = new_size;
                        current_block = 14434620278749266018;
                    } else {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Unable to decompress section %s\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            printable_section_name(filedata, section),
                        );
                        current_block = 3617531036272013283;
                    }
                } else {
                    start = real_start;
                    current_block = 14434620278749266018;
                }
            }
            _ => {}
        }
        match current_block {
            14434620278749266018 => {}
            _ => {
                free(real_start as *mut libc::c_void);
                return 0 as libc::c_int != 0;
            }
        }
    }
    relsec = (*filedata).section_headers;
    while relsec
        < ((*filedata).section_headers).offset((*filedata).file_header.e_shnum as isize)
    {
        if (*relsec).sh_type != 4 as libc::c_int as libc::c_uint
            && (*relsec).sh_type != 9 as libc::c_int as libc::c_uint
            || (*relsec).sh_info >= (*filedata).file_header.e_shnum
            || ((*filedata).section_headers).offset((*relsec).sh_info as isize)
                != section || (*relsec).sh_size == 0 as libc::c_int as libc::c_ulong
            || (*relsec).sh_link >= (*filedata).file_header.e_shnum
        {
            relsec = relsec.offset(1);
            relsec;
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Note: This section has relocations against it, but these have NOT been applied to this dump.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            break;
        }
    }
    data = start;
    end = start.offset(num_bytes as isize);
    some_strings_shown = 0 as libc::c_int != 0;
    state = mbstate_t {
        __count: 0,
        __value: C2RustUnnamed { __wch: 0 },
    };
    memset(
        &mut state as *mut mbstate_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,
    );
    continuing = 0 as libc::c_int != 0;
    while data < end {
        while _sch_istable[(*data as libc::c_int & 0xff as libc::c_int) as usize]
            as libc::c_int & _sch_isprint as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            data = data.offset(1);
            if data >= end {
                break;
            }
        }
        if data < end {
            let mut maxlen: size_t = end.offset_from(data) as libc::c_long as size_t;
            if continuing {
                printf(b"            \0" as *const u8 as *const libc::c_char);
                continuing = 0 as libc::c_int != 0;
            } else {
                printf(
                    b"  [%6lx]  \0" as *const u8 as *const libc::c_char,
                    data.offset_from(start) as libc::c_long as libc::c_ulong,
                );
            }
            if maxlen > 0 as libc::c_int as libc::c_ulong {
                let mut c: libc::c_char = 0 as libc::c_int as libc::c_char;
                while maxlen != 0 {
                    let fresh40 = data;
                    data = data.offset(1);
                    c = *fresh40 as libc::c_char;
                    if c as libc::c_int == 0 as libc::c_int {
                        break;
                    }
                    if c as libc::c_int == '\n' as i32 {
                        printf(b"\\n\n\0" as *const u8 as *const libc::c_char);
                        if *data as libc::c_int != 0 as libc::c_int {
                            continuing = 1 as libc::c_int != 0;
                        }
                        break;
                    } else if _sch_istable[(c as libc::c_int & 0xff as libc::c_int)
                        as usize] as libc::c_int
                        & _sch_iscntrl as libc::c_int as libc::c_ushort as libc::c_int
                        != 0
                    {
                        printf(
                            b"^%c\0" as *const u8 as *const libc::c_char,
                            c as libc::c_int + 0x40 as libc::c_int,
                        );
                    } else if _sch_istable[(c as libc::c_int & 0xff as libc::c_int)
                        as usize] as libc::c_int
                        & _sch_isprint as libc::c_int as libc::c_ushort as libc::c_int
                        != 0
                    {
                        putchar(c as libc::c_int);
                    } else {
                        let mut n: size_t = 0;
                        let mut w: wchar_t = 0;
                        printf(
                            b"%.1s\0" as *const u8 as *const libc::c_char,
                            data.offset(-(1 as libc::c_int as isize)),
                        );
                        n = mbrtowc(
                            &mut w,
                            data.offset(-(1 as libc::c_int as isize))
                                as *mut libc::c_char,
                            __ctype_get_mb_cur_max(),
                            &mut state,
                        );
                        if n != -(1 as libc::c_int) as size_t
                            && n != -(2 as libc::c_int) as size_t
                            && n > 0 as libc::c_int as libc::c_ulong
                        {
                            data = data
                                .offset(
                                    n.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                                );
                        }
                    }
                }
                if c as libc::c_int != '\n' as i32 {
                    putchar('\n' as i32);
                }
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt>\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                data = end;
            }
            some_strings_shown = 1 as libc::c_int != 0;
        }
    }
    if !some_strings_shown {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  No strings found in this section.\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    free(real_start as *mut libc::c_void);
    putchar('\n' as i32);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn dump_section_as_bytes(
    mut section: *mut Elf_Internal_Shdr,
    mut filedata: *mut Filedata,
    mut relocate: bool,
) -> bool {
    let mut current_block: u64;
    let mut relsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut bytes: bfd_size_type = 0;
    let mut section_size: bfd_size_type = 0;
    let mut addr: bfd_vma = 0;
    let mut data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut real_start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    start = get_section_contents(section, filedata) as *mut libc::c_uchar;
    real_start = start;
    if start.is_null() {
        return (*section).sh_size == 0 as libc::c_int as libc::c_ulong
            || (*section).sh_type == 8 as libc::c_int as libc::c_uint;
    }
    section_size = (*section).sh_size;
    if (*filedata).is_separate {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nHex dump of section '%s' in linked file %s:\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
            (*filedata).file_name,
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nHex dump of section '%s':\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
        );
    }
    if decompress_dumps {
        let mut new_size: dwarf_size_type = section_size;
        let mut uncompressed_size: dwarf_size_type = 0 as libc::c_int as dwarf_size_type;
        if (*section).sh_flags
            & ((1 as libc::c_int) << 11 as libc::c_int) as libc::c_ulong
            != 0 as libc::c_int as libc::c_ulong
        {
            let mut chdr: Elf_Internal_Chdr = Elf_Internal_Chdr {
                ch_type: 0,
                ch_size: 0,
                ch_addralign: 0,
            };
            let mut compression_header_size: libc::c_uint = get_compression_header(
                &mut chdr,
                start,
                section_size,
            );
            if compression_header_size == 0 as libc::c_int as libc::c_uint {
                current_block = 12843712199020754675;
            } else if chdr.ch_type != 1 as libc::c_int as libc::c_uint {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"section '%s' has unsupported compress type: %d\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    printable_section_name(filedata, section),
                    chdr.ch_type,
                );
                current_block = 12843712199020754675;
            } else {
                uncompressed_size = chdr.ch_size;
                start = start.offset(compression_header_size as isize);
                new_size = (new_size as libc::c_ulong)
                    .wrapping_sub(compression_header_size as libc::c_ulong)
                    as dwarf_size_type as dwarf_size_type;
                current_block = 14648156034262866959;
            }
        } else {
            if new_size > 12 as libc::c_int as libc::c_ulong
                && strcmp(
                    start as *mut libc::c_char,
                    b"ZLIB\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                uncompressed_size = *start.offset(4 as libc::c_int as isize)
                    as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(5 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(6 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(7 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(8 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(9 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(10 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                uncompressed_size <<= 8 as libc::c_int;
                uncompressed_size = (uncompressed_size as libc::c_ulong)
                    .wrapping_add(
                        *start.offset(11 as libc::c_int as isize) as libc::c_ulong,
                    ) as dwarf_size_type as dwarf_size_type;
                start = start.offset(12 as libc::c_int as isize);
                new_size = (new_size as libc::c_ulong)
                    .wrapping_sub(12 as libc::c_int as libc::c_ulong) as dwarf_size_type
                    as dwarf_size_type;
            }
            current_block = 14648156034262866959;
        }
        match current_block {
            12843712199020754675 => {}
            _ => {
                if uncompressed_size != 0 {
                    if uncompress_section_contents(
                        &mut start,
                        uncompressed_size,
                        &mut new_size,
                    ) {
                        section_size = new_size;
                        current_block = 9520865839495247062;
                    } else {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Unable to decompress section %s\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            printable_section_name(filedata, section),
                        );
                        current_block = 12843712199020754675;
                    }
                } else {
                    start = real_start;
                    current_block = 9520865839495247062;
                }
            }
        }
    } else {
        current_block = 9520865839495247062;
    }
    match current_block {
        9520865839495247062 => {
            if relocate {
                if !apply_relocations(
                    filedata,
                    section,
                    start,
                    section_size,
                    0 as *mut *mut libc::c_void,
                    0 as *mut libc::c_ulong,
                ) {
                    current_block = 12843712199020754675;
                } else {
                    current_block = 15512526488502093901;
                }
            } else {
                relsec = (*filedata).section_headers;
                while relsec
                    < ((*filedata).section_headers)
                        .offset((*filedata).file_header.e_shnum as isize)
                {
                    if (*relsec).sh_type != 4 as libc::c_int as libc::c_uint
                        && (*relsec).sh_type != 9 as libc::c_int as libc::c_uint
                        || (*relsec).sh_info >= (*filedata).file_header.e_shnum
                        || ((*filedata).section_headers)
                            .offset((*relsec).sh_info as isize) != section
                        || (*relsec).sh_size == 0 as libc::c_int as libc::c_ulong
                        || (*relsec).sh_link >= (*filedata).file_header.e_shnum
                    {
                        relsec = relsec.offset(1);
                        relsec;
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        break;
                    }
                }
                current_block = 15512526488502093901;
            }
            match current_block {
                12843712199020754675 => {}
                _ => {
                    addr = (*section).sh_addr;
                    bytes = section_size;
                    data = start;
                    while bytes != 0 {
                        let mut j: libc::c_int = 0;
                        let mut k: libc::c_int = 0;
                        let mut lbytes: libc::c_int = 0;
                        lbytes = (if bytes > 16 as libc::c_int as libc::c_ulong {
                            16 as libc::c_int as libc::c_ulong
                        } else {
                            bytes
                        }) as libc::c_int;
                        printf(
                            b"  0x%8.8lx \0" as *const u8 as *const libc::c_char,
                            addr,
                        );
                        j = 0 as libc::c_int;
                        while j < 16 as libc::c_int {
                            if j < lbytes {
                                printf(
                                    b"%2.2x\0" as *const u8 as *const libc::c_char,
                                    *data.offset(j as isize) as libc::c_int,
                                );
                            } else {
                                printf(b"  \0" as *const u8 as *const libc::c_char);
                            }
                            if j & 3 as libc::c_int == 3 as libc::c_int {
                                printf(b" \0" as *const u8 as *const libc::c_char);
                            }
                            j += 1;
                            j;
                        }
                        j = 0 as libc::c_int;
                        while j < lbytes {
                            k = *data.offset(j as isize) as libc::c_int;
                            if k >= ' ' as i32 && k < 0x7f as libc::c_int {
                                printf(b"%c\0" as *const u8 as *const libc::c_char, k);
                            } else {
                                printf(b".\0" as *const u8 as *const libc::c_char);
                            }
                            j += 1;
                            j;
                        }
                        putchar('\n' as i32);
                        data = data.offset(lbytes as isize);
                        addr = (addr as libc::c_ulong)
                            .wrapping_add(lbytes as libc::c_ulong) as bfd_vma as bfd_vma;
                        bytes = (bytes as libc::c_ulong)
                            .wrapping_sub(lbytes as libc::c_ulong) as bfd_size_type
                            as bfd_size_type;
                    }
                    free(real_start as *mut libc::c_void);
                    putchar('\n' as i32);
                    return 1 as libc::c_int != 0;
                }
            }
        }
        _ => {}
    }
    free(real_start as *mut libc::c_void);
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn shdr_to_ctf_sect(
    mut buf: *mut ctf_sect_t,
    mut shdr: *mut Elf_Internal_Shdr,
    mut filedata: *mut Filedata,
) -> *mut ctf_sect_t {
    (*buf)
        .cts_name = if shdr.is_null() {
        dcgettext(
            0 as *const libc::c_char,
            b"<none>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        )
    } else if ((*filedata).string_table).is_null() {
        dcgettext(
            0 as *const libc::c_char,
            b"<no-strings>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        )
    } else if (*shdr).sh_name as libc::c_ulong >= (*filedata).string_table_length {
        dcgettext(
            0 as *const libc::c_char,
            b"<corrupt>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        )
    } else {
        ((*filedata).string_table).offset((*shdr).sh_name as isize)
    };
    (*buf).cts_size = (*shdr).sh_size;
    (*buf).cts_entsize = (*shdr).sh_entsize;
    return buf;
}
unsafe extern "C" fn dump_ctf_indent_lines(
    mut _sect: ctf_sect_names_t,
    mut s: *mut libc::c_char,
    mut arg: *mut libc::c_void,
) -> *mut libc::c_char {
    let mut blanks: *const libc::c_char = arg as *const libc::c_char;
    let mut new_s: *mut libc::c_char = 0 as *mut libc::c_char;
    if asprintf(
        &mut new_s as *mut *mut libc::c_char,
        b"%s%s\0" as *const u8 as *const libc::c_char,
        blanks,
        s,
    ) < 0 as libc::c_int
    {
        return s;
    }
    return new_s;
}
unsafe extern "C" fn dump_ctf_errs(mut fp: *mut ctf_dict_t) {
    let mut it: *mut ctf_next_t = 0 as *mut ctf_next_t;
    let mut errtext: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut is_warning: libc::c_int = 0;
    let mut err: libc::c_int = 0;
    loop {
        errtext = ctf_errwarning_next(fp, &mut it, &mut is_warning, &mut err);
        if errtext.is_null() {
            break;
        }
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"%s: %s\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            if is_warning != 0 {
                dcgettext(
                    0 as *const libc::c_char,
                    b"warning\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                )
            } else {
                dcgettext(
                    0 as *const libc::c_char,
                    b"error\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                )
            },
            errtext,
        );
        free(errtext as *mut libc::c_void);
    }
    if err != ECTF_NEXT_END as libc::c_int {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"CTF error: cannot get CTF errors: `%s'\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            ctf_errmsg(err),
        );
    }
}
unsafe extern "C" fn dump_ctf_archive_member(
    mut ctf: *mut ctf_dict_t,
    mut name: *const libc::c_char,
    mut arg: *mut libc::c_void,
) -> libc::c_int {
    let mut parent: *mut ctf_dict_t = arg as *mut ctf_dict_t;
    let mut things: [*const libc::c_char; 8] = [
        b"Header\0" as *const u8 as *const libc::c_char,
        b"Labels\0" as *const u8 as *const libc::c_char,
        b"Data objects\0" as *const u8 as *const libc::c_char,
        b"Function objects\0" as *const u8 as *const libc::c_char,
        b"Variables\0" as *const u8 as *const libc::c_char,
        b"Types\0" as *const u8 as *const libc::c_char,
        b"Strings\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
    ];
    let mut thing: *mut *const libc::c_char = 0 as *mut *const libc::c_char;
    let mut i: size_t = 0;
    let mut err: libc::c_int = 0 as libc::c_int;
    if strcmp(name, b".ctf\0" as *const u8 as *const libc::c_char) != 0 as libc::c_int {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nCTF archive member: %s:\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            name,
        );
        ctf_import(ctf, parent);
    }
    i = 0 as libc::c_int as size_t;
    thing = things.as_mut_ptr();
    while **thing.offset(0 as libc::c_int as isize) != 0 {
        let mut s: *mut ctf_dump_state_t = 0 as *mut ctf_dump_state_t;
        let mut item: *mut libc::c_char = 0 as *mut libc::c_char;
        printf(b"\n  %s:\n\0" as *const u8 as *const libc::c_char, *thing);
        loop {
            item = ctf_dump(
                ctf,
                &mut s,
                i as ctf_sect_names_t,
                Some(
                    dump_ctf_indent_lines
                        as unsafe extern "C" fn(
                            ctf_sect_names_t,
                            *mut libc::c_char,
                            *mut libc::c_void,
                        ) -> *mut libc::c_char,
                ),
                b"    \0" as *const u8 as *const libc::c_char as *mut libc::c_void,
            );
            if item.is_null() {
                break;
            }
            printf(b"%s\n\0" as *const u8 as *const libc::c_char, item);
            free(item as *mut libc::c_void);
        }
        if ctf_errno(ctf) != 0 {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Iteration failed: %s, %s\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                *thing,
                ctf_errmsg(ctf_errno(ctf)),
            );
            err = 1 as libc::c_int;
            break;
        } else {
            thing = thing.offset(1);
            thing;
            i = i.wrapping_add(1);
            i;
        }
    }
    dump_ctf_errs(ctf);
    return err;
}
unsafe extern "C" fn dump_section_as_ctf(
    mut section: *mut Elf_Internal_Shdr,
    mut filedata: *mut Filedata,
) -> bool {
    let mut current_block: u64;
    let mut parent_sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symtab_sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut strtab_sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut symdata: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut strdata: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut parentdata: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ctfsect: ctf_sect_t = ctf_sect_t {
        cts_name: 0 as *const libc::c_char,
        cts_data: 0 as *const libc::c_void,
        cts_size: 0,
        cts_entsize: 0,
    };
    let mut symsect: ctf_sect_t = ctf_sect_t {
        cts_name: 0 as *const libc::c_char,
        cts_data: 0 as *const libc::c_void,
        cts_size: 0,
        cts_entsize: 0,
    };
    let mut strsect: ctf_sect_t = ctf_sect_t {
        cts_name: 0 as *const libc::c_char,
        cts_data: 0 as *const libc::c_void,
        cts_size: 0,
        cts_entsize: 0,
    };
    let mut parentsect: ctf_sect_t = ctf_sect_t {
        cts_name: 0 as *const libc::c_char,
        cts_data: 0 as *const libc::c_void,
        cts_size: 0,
        cts_entsize: 0,
    };
    let mut symsectp: *mut ctf_sect_t = 0 as *mut ctf_sect_t;
    let mut strsectp: *mut ctf_sect_t = 0 as *mut ctf_sect_t;
    let mut ctfa: *mut ctf_archive_t = 0 as *mut ctf_archive_t;
    let mut parenta: *mut ctf_archive_t = 0 as *mut ctf_archive_t;
    let mut lookparent: *mut ctf_archive_t = 0 as *mut ctf_archive_t;
    let mut parent: *mut ctf_dict_t = 0 as *mut ctf_dict_t;
    let mut err: libc::c_int = 0;
    let mut ret: bool = 0 as libc::c_int != 0;
    shdr_to_ctf_sect(&mut ctfsect, section, filedata);
    data = get_section_contents(section, filedata) as *mut libc::c_void;
    ctfsect.cts_data = data;
    if dump_ctf_symtab_name.is_null() {
        dump_ctf_symtab_name = strdup(b".dynsym\0" as *const u8 as *const libc::c_char);
    }
    if dump_ctf_strtab_name.is_null() {
        dump_ctf_strtab_name = strdup(b".dynstr\0" as *const u8 as *const libc::c_char);
    }
    if !dump_ctf_symtab_name.is_null()
        && *dump_ctf_symtab_name.offset(0 as libc::c_int as isize) as libc::c_int
            != 0 as libc::c_int
    {
        symtab_sec = find_section(filedata, dump_ctf_symtab_name);
        if symtab_sec.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"No symbol section named %s\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dump_ctf_symtab_name,
            );
            current_block = 5704304178431132408;
        } else {
            symdata = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*symtab_sec).sh_offset as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                (*symtab_sec).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"symbols\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            if symdata.is_null() {
                current_block = 5704304178431132408;
            } else {
                symsectp = shdr_to_ctf_sect(&mut symsect, symtab_sec, filedata);
                symsect.cts_data = symdata;
                current_block = 12039483399334584727;
            }
        }
    } else {
        current_block = 12039483399334584727;
    }
    match current_block {
        12039483399334584727 => {
            if !dump_ctf_strtab_name.is_null()
                && *dump_ctf_strtab_name.offset(0 as libc::c_int as isize) as libc::c_int
                    != 0 as libc::c_int
            {
                strtab_sec = find_section(filedata, dump_ctf_strtab_name);
                if strtab_sec.is_null() {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"No string table section named %s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dump_ctf_strtab_name,
                    );
                    current_block = 5704304178431132408;
                } else {
                    strdata = get_data(
                        0 as *mut libc::c_void,
                        filedata,
                        (*strtab_sec).sh_offset as libc::c_ulong,
                        1 as libc::c_int as bfd_size_type,
                        (*strtab_sec).sh_size,
                        dcgettext(
                            0 as *const libc::c_char,
                            b"strings\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    if strdata.is_null() {
                        current_block = 5704304178431132408;
                    } else {
                        strsectp = shdr_to_ctf_sect(&mut strsect, strtab_sec, filedata);
                        strsect.cts_data = strdata;
                        current_block = 2668756484064249700;
                    }
                }
            } else {
                current_block = 2668756484064249700;
            }
            match current_block {
                5704304178431132408 => {}
                _ => {
                    if !dump_ctf_parent_name.is_null() {
                        parent_sec = find_section(filedata, dump_ctf_parent_name);
                        if parent_sec.is_null() {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"No CTF parent section named %s\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dump_ctf_parent_name,
                            );
                            current_block = 5704304178431132408;
                        } else {
                            parentdata = get_data(
                                0 as *mut libc::c_void,
                                filedata,
                                (*parent_sec).sh_offset as libc::c_ulong,
                                1 as libc::c_int as bfd_size_type,
                                (*parent_sec).sh_size,
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"CTF parent\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            if parentdata.is_null() {
                                current_block = 5704304178431132408;
                            } else {
                                shdr_to_ctf_sect(&mut parentsect, parent_sec, filedata);
                                parentsect.cts_data = parentdata;
                                current_block = 15925075030174552612;
                            }
                        }
                    } else {
                        current_block = 15925075030174552612;
                    }
                    match current_block {
                        5704304178431132408 => {}
                        _ => {
                            ctfa = ctf_arc_bufopen(
                                &mut ctfsect,
                                symsectp,
                                strsectp,
                                &mut err,
                            );
                            if ctfa.is_null() {
                                dump_ctf_errs(0 as *mut ctf_dict_t);
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"CTF open failure: %s\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    ctf_errmsg(err),
                                );
                            } else {
                                ctf_arc_symsect_endianness(
                                    ctfa,
                                    ((*filedata).file_header.e_ident[5 as libc::c_int as usize]
                                        as libc::c_int != 2 as libc::c_int) as libc::c_int,
                                );
                                if !parentdata.is_null() {
                                    parenta = ctf_arc_bufopen(
                                        &mut parentsect,
                                        symsectp,
                                        strsectp,
                                        &mut err,
                                    );
                                    if parenta.is_null() {
                                        dump_ctf_errs(0 as *mut ctf_dict_t);
                                        error(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"CTF open failure: %s\n\0" as *const u8
                                                    as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            ctf_errmsg(err),
                                        );
                                        current_block = 5704304178431132408;
                                    } else {
                                        lookparent = parenta;
                                        current_block = 10692455896603418738;
                                    }
                                } else {
                                    lookparent = ctfa;
                                    current_block = 10692455896603418738;
                                }
                                match current_block {
                                    5704304178431132408 => {}
                                    _ => {
                                        parent = ctf_dict_open(
                                            lookparent,
                                            0 as *const libc::c_char,
                                            &mut err,
                                        );
                                        if parent.is_null() {
                                            dump_ctf_errs(0 as *mut ctf_dict_t);
                                            error(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"CTF open failure: %s\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                ctf_errmsg(err),
                                            );
                                        } else {
                                            ret = 1 as libc::c_int != 0;
                                            if (*filedata).is_separate {
                                                printf(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"\nDump of CTF section '%s' in linked file %s:\n\0"
                                                            as *const u8 as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    printable_section_name(filedata, section),
                                                    (*filedata).file_name,
                                                );
                                            } else {
                                                printf(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"\nDump of CTF section '%s':\n\0" as *const u8
                                                            as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    printable_section_name(filedata, section),
                                                );
                                            }
                                            err = ctf_archive_iter(
                                                ctfa,
                                                Some(
                                                    dump_ctf_archive_member
                                                        as unsafe extern "C" fn(
                                                            *mut ctf_dict_t,
                                                            *const libc::c_char,
                                                            *mut libc::c_void,
                                                        ) -> libc::c_int,
                                                ),
                                                parent as *mut libc::c_void,
                                            );
                                            if err != 0 as libc::c_int {
                                                dump_ctf_errs(0 as *mut ctf_dict_t);
                                                error(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"CTF member open failure: %s\n\0" as *const u8
                                                            as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    ctf_errmsg(err),
                                                );
                                                ret = 0 as libc::c_int != 0;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    ctf_dict_close(parent);
    ctf_close(ctfa);
    ctf_close(parenta);
    free(parentdata);
    free(data);
    free(symdata);
    free(strdata);
    return ret;
}
unsafe extern "C" fn load_specific_debug_section(
    mut debug: dwarf_section_display_enum,
    mut sec: *const Elf_Internal_Shdr,
    mut data: *mut libc::c_void,
) -> bool {
    let mut section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(debug as isize))
        .section;
    let mut buf: [libc::c_char; 64] = [0; 64];
    let mut filedata: *mut Filedata = data as *mut Filedata;
    if !((*section).start).is_null() {
        if strcmp((*section).filename, (*filedata).file_name) == 0 as libc::c_int {
            return 1 as libc::c_int != 0;
        }
        free((*section).start as *mut libc::c_void);
    }
    snprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        dcgettext(
            0 as *const libc::c_char,
            b"%s section data\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        (*section).name,
    );
    (*section).address = (*sec).sh_addr;
    (*section).filename = (*filedata).file_name;
    (*section)
        .start = get_data(
        0 as *mut libc::c_void,
        filedata,
        (*sec).sh_offset as libc::c_ulong,
        1 as libc::c_int as bfd_size_type,
        (*sec).sh_size,
        buf.as_mut_ptr(),
    ) as *mut libc::c_uchar;
    if ((*section).start).is_null() {
        (*section).size = 0 as libc::c_int as dwarf_size_type;
    } else {
        let mut start: *mut libc::c_uchar = (*section).start;
        let mut size: dwarf_size_type = (*sec).sh_size;
        let mut uncompressed_size: dwarf_size_type = 0 as libc::c_int as dwarf_size_type;
        if (*sec).sh_flags & ((1 as libc::c_int) << 11 as libc::c_int) as libc::c_ulong
            != 0 as libc::c_int as libc::c_ulong
        {
            let mut chdr: Elf_Internal_Chdr = Elf_Internal_Chdr {
                ch_type: 0,
                ch_size: 0,
                ch_addralign: 0,
            };
            let mut compression_header_size: libc::c_uint = 0;
            if size
                < (if is_32bit_elf as libc::c_int != 0 {
                    ::core::mem::size_of::<Elf32_External_Chdr>() as libc::c_ulong
                } else {
                    ::core::mem::size_of::<Elf64_External_Chdr>() as libc::c_ulong
                })
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"compressed section %s is too small to contain a compression header\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*section).name,
                );
                return 0 as libc::c_int != 0;
            }
            compression_header_size = get_compression_header(&mut chdr, start, size);
            if compression_header_size == 0 as libc::c_int as libc::c_uint {
                return 0 as libc::c_int != 0;
            }
            if chdr.ch_type != 1 as libc::c_int as libc::c_uint {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"section '%s' has unsupported compress type: %d\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*section).name,
                    chdr.ch_type,
                );
                return 0 as libc::c_int != 0;
            }
            uncompressed_size = chdr.ch_size;
            start = start.offset(compression_header_size as isize);
            size = (size as libc::c_ulong)
                .wrapping_sub(compression_header_size as libc::c_ulong)
                as dwarf_size_type as dwarf_size_type;
        } else if size > 12 as libc::c_int as libc::c_ulong
            && strcmp(
                start as *mut libc::c_char,
                b"ZLIB\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            uncompressed_size = *start.offset(4 as libc::c_int as isize)
                as dwarf_size_type;
            uncompressed_size <<= 8 as libc::c_int;
            uncompressed_size = (uncompressed_size as libc::c_ulong)
                .wrapping_add(*start.offset(5 as libc::c_int as isize) as libc::c_ulong)
                as dwarf_size_type as dwarf_size_type;
            uncompressed_size <<= 8 as libc::c_int;
            uncompressed_size = (uncompressed_size as libc::c_ulong)
                .wrapping_add(*start.offset(6 as libc::c_int as isize) as libc::c_ulong)
                as dwarf_size_type as dwarf_size_type;
            uncompressed_size <<= 8 as libc::c_int;
            uncompressed_size = (uncompressed_size as libc::c_ulong)
                .wrapping_add(*start.offset(7 as libc::c_int as isize) as libc::c_ulong)
                as dwarf_size_type as dwarf_size_type;
            uncompressed_size <<= 8 as libc::c_int;
            uncompressed_size = (uncompressed_size as libc::c_ulong)
                .wrapping_add(*start.offset(8 as libc::c_int as isize) as libc::c_ulong)
                as dwarf_size_type as dwarf_size_type;
            uncompressed_size <<= 8 as libc::c_int;
            uncompressed_size = (uncompressed_size as libc::c_ulong)
                .wrapping_add(*start.offset(9 as libc::c_int as isize) as libc::c_ulong)
                as dwarf_size_type as dwarf_size_type;
            uncompressed_size <<= 8 as libc::c_int;
            uncompressed_size = (uncompressed_size as libc::c_ulong)
                .wrapping_add(*start.offset(10 as libc::c_int as isize) as libc::c_ulong)
                as dwarf_size_type as dwarf_size_type;
            uncompressed_size <<= 8 as libc::c_int;
            uncompressed_size = (uncompressed_size as libc::c_ulong)
                .wrapping_add(*start.offset(11 as libc::c_int as isize) as libc::c_ulong)
                as dwarf_size_type as dwarf_size_type;
            start = start.offset(12 as libc::c_int as isize);
            size = (size as libc::c_ulong)
                .wrapping_sub(12 as libc::c_int as libc::c_ulong) as dwarf_size_type
                as dwarf_size_type;
        }
        if uncompressed_size != 0 {
            if uncompress_section_contents(&mut start, uncompressed_size, &mut size) {
                free((*section).start as *mut libc::c_void);
                (*section).start = start;
            } else {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unable to decompress section %s\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    printable_section_name(filedata, sec),
                );
                return 0 as libc::c_int != 0;
            }
        }
        (*section).size = size;
    }
    if ((*section).start).is_null() {
        return 0 as libc::c_int != 0;
    }
    if (*debug_displays.as_mut_ptr().offset(debug as isize)).relocate {
        if !apply_relocations(
            filedata,
            sec,
            (*section).start,
            (*section).size,
            &mut (*section).reloc_info,
            &mut (*section).num_relocs,
        ) {
            return 0 as libc::c_int != 0;
        }
    } else {
        (*section).reloc_info = 0 as *mut libc::c_void;
        (*section).num_relocs = 0 as libc::c_int as libc::c_ulong;
    }
    return 1 as libc::c_int != 0;
}
static mut section_subset: *mut libc::c_uint = 0 as *const libc::c_uint
    as *mut libc::c_uint;
unsafe extern "C" fn display_debug_section(
    mut shndx: libc::c_int,
    mut section: *mut Elf_Internal_Shdr,
    mut filedata: *mut Filedata,
) -> bool {
    let mut name: *mut libc::c_char = (if !section.is_null()
        && !((*filedata).string_table).is_null()
        && ((*section).sh_name as libc::c_ulong) < (*filedata).string_table_length
    {
        ((*filedata).string_table).offset((*section).sh_name as isize)
            as *const libc::c_char
    } else {
        b"\0" as *const u8 as *const libc::c_char
    }) as *mut libc::c_char;
    let mut print_name: *const libc::c_char = printable_section_name(filedata, section);
    let mut length: bfd_size_type = 0;
    let mut result: bool = 1 as libc::c_int != 0;
    let mut i: libc::c_int = 0;
    length = (*section).sh_size;
    if length == 0 as libc::c_int as libc::c_ulong {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nSection '%s' has no debugging data.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            print_name,
        );
        return 1 as libc::c_int != 0;
    }
    if (*section).sh_type == 8 as libc::c_int as libc::c_uint {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"section '%s' has the NOBITS type - its contents are unreliable.\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            print_name,
        );
        return 0 as libc::c_int != 0;
    }
    if startswith(name, b".gnu.linkonce.wi.\0" as *const u8 as *const libc::c_char) {
        name = b".debug_info\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    i = 0 as libc::c_int;
    while i < max as libc::c_int {
        let mut id: dwarf_section_display_enum = i as dwarf_section_display_enum;
        let mut display: *mut dwarf_section_display = debug_displays
            .as_mut_ptr()
            .offset(i as isize);
        let mut sec: *mut dwarf_section = &mut (*display).section;
        if strcmp((*sec).uncompressed_name, name) == 0 as libc::c_int
            || id as libc::c_uint == line as libc::c_int as libc::c_uint
                && startswith(
                    name,
                    b".debug_line.\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
            || strcmp((*sec).compressed_name, name) == 0 as libc::c_int
        {
            let mut secondary: bool = section != find_section(filedata, name);
            if secondary {
                free_debug_section(id);
            }
            if i == line as libc::c_int
                && startswith(
                    name,
                    b".debug_line.\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
            {
                (*sec).name = name;
            } else if strcmp((*sec).uncompressed_name, name) == 0 as libc::c_int {
                (*sec).name = (*sec).uncompressed_name;
            } else {
                (*sec).name = (*sec).compressed_name;
            }
            if load_specific_debug_section(id, section, filedata as *mut libc::c_void) {
                section_subset = find_cu_tu_set(
                    filedata as *mut libc::c_void,
                    shndx as libc::c_uint,
                );
                result = (result as libc::c_int
                    & ((*display).display)
                        .expect(
                            "non-null function pointer",
                        )(sec, filedata as *mut libc::c_void)) != 0;
                section_subset = 0 as *mut libc::c_uint;
                if secondary as libc::c_int != 0
                    || id as libc::c_uint != info as libc::c_int as libc::c_uint
                        && id as libc::c_uint != abbrev as libc::c_int as libc::c_uint
                        && id as libc::c_uint
                            != debug_addr as libc::c_int as libc::c_uint
                {
                    free_debug_section(id);
                }
            }
            break;
        } else {
            i += 1;
            i;
        }
    }
    if i == max as libc::c_int {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Unrecognized debug section: %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            print_name,
        );
        result = 0 as libc::c_int != 0;
    }
    return result;
}
unsafe extern "C" fn initialise_dumps_byname(mut filedata: *mut Filedata) {
    let mut cur: *mut dump_list_entry = 0 as *mut dump_list_entry;
    cur = dump_sects_byname;
    while !cur.is_null() {
        let mut i: libc::c_uint = 0;
        let mut any: bool = 0 as libc::c_int != 0;
        i = 0 as libc::c_int as libc::c_uint;
        while i < (*filedata).file_header.e_shnum {
            if !((*filedata).section_headers).offset(i as isize).is_null()
                && !((*filedata).string_table).is_null()
                && ((*((*filedata).section_headers).offset(i as isize)).sh_name
                    as libc::c_ulong) < (*filedata).string_table_length
                && strcmp(
                    ((*filedata).string_table)
                        .offset(
                            (*((*filedata).section_headers).offset(i as isize)).sh_name
                                as isize,
                        ),
                    (*cur).name,
                ) == 0 as libc::c_int
            {
                request_dump_bynumber(&mut (*filedata).dump, i, (*cur).type_0);
                any = 1 as libc::c_int != 0;
            }
            i = i.wrapping_add(1);
            i;
        }
        if !any && !(*filedata).is_separate {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Section '%s' was not dumped because it does not exist\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*cur).name,
            );
        }
        cur = (*cur).next;
    }
}
unsafe extern "C" fn process_section_contents(mut filedata: *mut Filedata) -> bool {
    let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_uint = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    if !do_dump {
        return 1 as libc::c_int != 0;
    }
    initialise_dumps_byname(filedata);
    i = 0 as libc::c_int as libc::c_uint;
    section = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum && i < (*filedata).dump.num_dump_sects {
        let mut dump: dump_type = *((*filedata).dump.dump_sects).offset(i as isize);
        if (*filedata).is_separate as libc::c_int != 0 && !process_links {
            dump = (dump as libc::c_int & (1 as libc::c_int) << 2 as libc::c_int)
                as dump_type;
        }
        if dump as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0 {
            if !dump_section_as_bytes(section, filedata, 0 as libc::c_int != 0) {
                res = 0 as libc::c_int != 0;
            }
        }
        if dump as libc::c_int & (1 as libc::c_int) << 4 as libc::c_int != 0 {
            if !dump_section_as_bytes(section, filedata, 1 as libc::c_int != 0) {
                res = 0 as libc::c_int != 0;
            }
        }
        if dump as libc::c_int & (1 as libc::c_int) << 3 as libc::c_int != 0 {
            if !dump_section_as_strings(section, filedata) {
                res = 0 as libc::c_int != 0;
            }
        }
        if dump as libc::c_int & (1 as libc::c_int) << 2 as libc::c_int != 0 {
            if !display_debug_section(i as libc::c_int, section, filedata) {
                res = 0 as libc::c_int != 0;
            }
        }
        if dump as libc::c_int & (1 as libc::c_int) << 5 as libc::c_int != 0 {
            if !dump_section_as_ctf(section, filedata) {
                res = 0 as libc::c_int != 0;
            }
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    if !(*filedata).is_separate {
        while i < (*filedata).dump.num_dump_sects {
            if *((*filedata).dump.dump_sects).offset(i as isize) != 0 {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Section %d was not dumped because it does not exist!\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    i,
                );
                res = 0 as libc::c_int != 0;
            }
            i = i.wrapping_add(1);
            i;
        }
    }
    return res;
}
unsafe extern "C" fn process_mips_fpe_exception(mut mask: libc::c_int) {
    if mask != 0 {
        let mut first: bool = 1 as libc::c_int != 0;
        if mask & 0x1 as libc::c_int != 0 {
            fputs(b"INEX\0" as *const u8 as *const libc::c_char, stdout);
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x2 as libc::c_int != 0 {
            printf(
                b"%sUFLO\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x4 as libc::c_int != 0 {
            printf(
                b"%sOFLO\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x8 as libc::c_int != 0 {
            printf(
                b"%sDIV0\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x10 as libc::c_int != 0 {
            printf(
                b"%sINVAL\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
        }
    } else {
        fputs(b"0\0" as *const u8 as *const libc::c_char, stdout);
    };
}
unsafe extern "C" fn display_tag_value(
    mut tag: libc::c_int,
    mut p: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut val: libc::c_ulong = 0;
    if tag > 0 as libc::c_int {
        printf(b"  Tag_unknown_%d: \0" as *const u8 as *const libc::c_char, tag);
    }
    if p >= end as *mut libc::c_uchar {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"<corrupt tag>\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else if tag & 1 as libc::c_int != 0 {
        let mut maxlen: size_t = (end.offset_from(p) as libc::c_long
            - 1 as libc::c_int as libc::c_long) as size_t;
        putchar('"' as i32);
        if maxlen > 0 as libc::c_int as libc::c_ulong {
            print_symbol(maxlen as libc::c_int, p as *const libc::c_char);
            p = p
                .offset(
                    (strnlen(p as *mut libc::c_char, maxlen))
                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt string tag>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            p = end as *mut libc::c_uchar;
        }
        printf(b"\"\n\0" as *const u8 as *const libc::c_char);
    } else {
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
        p = p.offset(_len as isize);
        val = _val;
        if val != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            15883 as libc::c_int as libc::c_ulong,
        );
        printf(b"%ld (0x%lx)\n\0" as *const u8 as *const libc::c_char, val, val);
    }
    if p <= end as *mut libc::c_uchar {} else {
        __assert_fail(
            b"p <= end\0" as *const u8 as *const libc::c_char,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            15887 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 83],
                &[libc::c_char; 83],
            >(
                b"unsigned char *display_tag_value(int, unsigned char *, const unsigned char *const)\0",
            ))
                .as_ptr(),
        );
    }
    'c_118906: {
        if p <= end as *mut libc::c_uchar {} else {
            __assert_fail(
                b"p <= end\0" as *const u8 as *const libc::c_char,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                15887 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 83],
                    &[libc::c_char; 83],
                >(
                    b"unsigned char *display_tag_value(int, unsigned char *, const unsigned char *const)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    return p;
}
unsafe extern "C" fn display_arc_attribute(
    mut p: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut tag: libc::c_uint = 0;
    let mut val: libc::c_uint = 0;
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
    p = p.offset(_len as isize);
    tag = _val as libc::c_uint;
    if tag as libc::c_ulong != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"readelf.c\0" as *const u8 as *const libc::c_char,
        15900 as libc::c_int as libc::c_ulong,
    );
    match tag {
        4 => {
            let mut _val_0: dwarf_vma = 0;
            let mut _len_0: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_0,
                &mut _status_0,
            );
            p = p.offset(_len_0 as isize);
            val = _val_0 as libc::c_uint;
            if val as libc::c_ulong != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                15905 as libc::c_int as libc::c_ulong,
            );
            printf(b"  Tag_ARC_PCS_config: \0" as *const u8 as *const libc::c_char);
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Absent/Non standard\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Bare metal/mwdt\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Bare metal/newlib\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                3 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Linux/uclibc\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                4 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Linux/glibc\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unknown\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
        }
        5 => {
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            p = p.offset(_len_1 as isize);
            val = _val_1 as libc::c_uint;
            if val as libc::c_ulong != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                15931 as libc::c_int as libc::c_ulong,
            );
            printf(b"  Tag_ARC_CPU_base: \0" as *const u8 as *const libc::c_char);
            match val {
                1 => {
                    printf(b"ARC6xx\n\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"ARC7xx\n\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    printf(b"ARCEM\n\0" as *const u8 as *const libc::c_char);
                }
                4 => {
                    printf(b"ARCHS\n\0" as *const u8 as *const libc::c_char);
                }
                0 | _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Absent\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
        }
        6 => {
            let mut _val_2: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_2: libc::c_int = 0;
            _val_2 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_2,
            );
            p = p.offset(_len_2 as isize);
            val = _val_2 as libc::c_uint;
            if val as libc::c_ulong != _val_2 {
                _status_2 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_2,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                15955 as libc::c_int as libc::c_ulong,
            );
            printf(b"  Tag_ARC_CPU_variation: \0" as *const u8 as *const libc::c_char);
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Absent\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    if val > 0 as libc::c_int as libc::c_uint
                        && val < 16 as libc::c_int as libc::c_uint
                    {
                        printf(b"Core%d\n\0" as *const u8 as *const libc::c_char, val);
                    } else {
                        printf(b"Unknown\n\0" as *const u8 as *const libc::c_char);
                    }
                }
            }
        }
        7 => {
            printf(b"  Tag_ARC_CPU_name: \0" as *const u8 as *const libc::c_char);
            p = display_tag_value(-(1 as libc::c_int), p, end);
        }
        8 => {
            let mut _val_3: dwarf_vma = 0;
            let mut _len_3: libc::c_uint = 0;
            let mut _status_3: libc::c_int = 0;
            _val_3 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_3,
                &mut _status_3,
            );
            p = p.offset(_len_3 as isize);
            val = _val_3 as libc::c_uint;
            if val as libc::c_ulong != _val_3 {
                _status_3 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_3,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                15978 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ARC_ABI_rf16: %s\n\0" as *const u8 as *const libc::c_char,
                if val != 0 {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"yes\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                } else {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"no\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                },
            );
        }
        9 => {
            let mut _val_4: dwarf_vma = 0;
            let mut _len_4: libc::c_uint = 0;
            let mut _status_4: libc::c_int = 0;
            _val_4 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_4,
                &mut _status_4,
            );
            p = p.offset(_len_4 as isize);
            val = _val_4 as libc::c_uint;
            if val as libc::c_ulong != _val_4 {
                _status_4 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_4,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                15983 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ARC_ABI_osver: v%d\n\0" as *const u8 as *const libc::c_char,
                val,
            );
        }
        11 | 10 => {
            let mut _val_5: dwarf_vma = 0;
            let mut _len_5: libc::c_uint = 0;
            let mut _status_5: libc::c_int = 0;
            _val_5 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_5,
                &mut _status_5,
            );
            p = p.offset(_len_5 as isize);
            val = _val_5 as libc::c_uint;
            if val as libc::c_ulong != _val_5 {
                _status_5 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_5,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                15989 as libc::c_int as libc::c_ulong,
            );
            printf(
                if tag == Tag_ARC_ABI_sda as libc::c_int as libc::c_uint {
                    b"  Tag_ARC_ABI_sda: \0" as *const u8 as *const libc::c_char
                } else {
                    b"  Tag_ARC_ABI_pic: \0" as *const u8 as *const libc::c_char
                },
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Absent\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(b"MWDT\n\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"GNU\n\0" as *const u8 as *const libc::c_char);
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unknown\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
        }
        12 => {
            let mut _val_6: dwarf_vma = 0;
            let mut _len_6: libc::c_uint = 0;
            let mut _status_6: libc::c_int = 0;
            _val_6 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_6,
                &mut _status_6,
            );
            p = p.offset(_len_6 as isize);
            val = _val_6 as libc::c_uint;
            if val as libc::c_ulong != _val_6 {
                _status_6 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_6,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16010 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ARC_ABI_tls: %s\n\0" as *const u8 as *const libc::c_char,
                if val != 0 {
                    b"r25\0" as *const u8 as *const libc::c_char
                } else {
                    b"none\0" as *const u8 as *const libc::c_char
                },
            );
        }
        13 => {
            let mut _val_7: dwarf_vma = 0;
            let mut _len_7: libc::c_uint = 0;
            let mut _status_7: libc::c_int = 0;
            _val_7 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_7,
                &mut _status_7,
            );
            p = p.offset(_len_7 as isize);
            val = _val_7 as libc::c_uint;
            if val as libc::c_ulong != _val_7 {
                _status_7 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_7,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16015 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ARC_ABI_enumsize: %s\n\0" as *const u8 as *const libc::c_char,
                if val != 0 {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"default\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                } else {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"smallest\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                },
            );
        }
        14 => {
            let mut _val_8: dwarf_vma = 0;
            let mut _len_8: libc::c_uint = 0;
            let mut _status_8: libc::c_int = 0;
            _val_8 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_8,
                &mut _status_8,
            );
            p = p.offset(_len_8 as isize);
            val = _val_8 as libc::c_uint;
            if val as libc::c_ulong != _val_8 {
                _status_8 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_8,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16021 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ARC_ABI_exceptions: %s\n\0" as *const u8 as *const libc::c_char,
                if val != 0 {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"OPTFP\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                } else {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"default\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                },
            );
        }
        15 => {
            let mut _val_9: dwarf_vma = 0;
            let mut _len_9: libc::c_uint = 0;
            let mut _status_9: libc::c_int = 0;
            _val_9 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_9,
                &mut _status_9,
            );
            p = p.offset(_len_9 as isize);
            val = _val_9 as libc::c_uint;
            if val as libc::c_ulong != _val_9 {
                _status_9 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_9,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16027 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ARC_ABI_double_size: %d\n\0" as *const u8 as *const libc::c_char,
                val,
            );
        }
        16 => {
            printf(b"  Tag_ARC_ISA_config: \0" as *const u8 as *const libc::c_char);
            p = display_tag_value(-(1 as libc::c_int), p, end);
        }
        17 => {
            printf(b"  Tag_ARC_ISA_apex: \0" as *const u8 as *const libc::c_char);
            p = display_tag_value(-(1 as libc::c_int), p, end);
        }
        18 => {
            let mut _val_10: dwarf_vma = 0;
            let mut _len_10: libc::c_uint = 0;
            let mut _status_10: libc::c_int = 0;
            _val_10 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_10,
                &mut _status_10,
            );
            p = p.offset(_len_10 as isize);
            val = _val_10 as libc::c_uint;
            if val as libc::c_ulong != _val_10 {
                _status_10 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_10,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16042 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ARC_ISA_mpy_option: %d\n\0" as *const u8 as *const libc::c_char,
                val,
            );
        }
        20 => {
            let mut _val_11: dwarf_vma = 0;
            let mut _len_11: libc::c_uint = 0;
            let mut _status_11: libc::c_int = 0;
            _val_11 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_11,
                &mut _status_11,
            );
            p = p.offset(_len_11 as isize);
            val = _val_11 as libc::c_uint;
            if val as libc::c_ulong != _val_11 {
                _status_11 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_11,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16047 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ARC_ATR_version: %d\n\0" as *const u8 as *const libc::c_char,
                val,
            );
        }
        _ => {
            return display_tag_value(
                (tag & 1 as libc::c_int as libc::c_uint) as libc::c_int,
                p,
                end,
            );
        }
    }
    return p;
}
static mut arm_attr_tag_CPU_arch: [*const libc::c_char; 22] = [
    b"Pre-v4\0" as *const u8 as *const libc::c_char,
    b"v4\0" as *const u8 as *const libc::c_char,
    b"v4T\0" as *const u8 as *const libc::c_char,
    b"v5T\0" as *const u8 as *const libc::c_char,
    b"v5TE\0" as *const u8 as *const libc::c_char,
    b"v5TEJ\0" as *const u8 as *const libc::c_char,
    b"v6\0" as *const u8 as *const libc::c_char,
    b"v6KZ\0" as *const u8 as *const libc::c_char,
    b"v6T2\0" as *const u8 as *const libc::c_char,
    b"v6K\0" as *const u8 as *const libc::c_char,
    b"v7\0" as *const u8 as *const libc::c_char,
    b"v6-M\0" as *const u8 as *const libc::c_char,
    b"v6S-M\0" as *const u8 as *const libc::c_char,
    b"v7E-M\0" as *const u8 as *const libc::c_char,
    b"v8\0" as *const u8 as *const libc::c_char,
    b"v8-R\0" as *const u8 as *const libc::c_char,
    b"v8-M.baseline\0" as *const u8 as *const libc::c_char,
    b"v8-M.mainline\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"\0" as *const u8 as *const libc::c_char,
    b"v8.1-M.mainline\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ARM_ISA_use: [*const libc::c_char; 2] = [
    b"No\0" as *const u8 as *const libc::c_char,
    b"Yes\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_THUMB_ISA_use: [*const libc::c_char; 4] = [
    b"No\0" as *const u8 as *const libc::c_char,
    b"Thumb-1\0" as *const u8 as *const libc::c_char,
    b"Thumb-2\0" as *const u8 as *const libc::c_char,
    b"Yes\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_FP_arch: [*const libc::c_char; 9] = [
    b"No\0" as *const u8 as *const libc::c_char,
    b"VFPv1\0" as *const u8 as *const libc::c_char,
    b"VFPv2\0" as *const u8 as *const libc::c_char,
    b"VFPv3\0" as *const u8 as *const libc::c_char,
    b"VFPv3-D16\0" as *const u8 as *const libc::c_char,
    b"VFPv4\0" as *const u8 as *const libc::c_char,
    b"VFPv4-D16\0" as *const u8 as *const libc::c_char,
    b"FP for ARMv8\0" as *const u8 as *const libc::c_char,
    b"FPv5/FP-D16 for ARMv8\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_WMMX_arch: [*const libc::c_char; 3] = [
    b"No\0" as *const u8 as *const libc::c_char,
    b"WMMXv1\0" as *const u8 as *const libc::c_char,
    b"WMMXv2\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_Advanced_SIMD_arch: [*const libc::c_char; 5] = [
    b"No\0" as *const u8 as *const libc::c_char,
    b"NEONv1\0" as *const u8 as *const libc::c_char,
    b"NEONv1 with Fused-MAC\0" as *const u8 as *const libc::c_char,
    b"NEON for ARMv8\0" as *const u8 as *const libc::c_char,
    b"NEON for ARMv8.1\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_PCS_config: [*const libc::c_char; 8] = [
    b"None\0" as *const u8 as *const libc::c_char,
    b"Bare platform\0" as *const u8 as *const libc::c_char,
    b"Linux application\0" as *const u8 as *const libc::c_char,
    b"Linux DSO\0" as *const u8 as *const libc::c_char,
    b"PalmOS 2004\0" as *const u8 as *const libc::c_char,
    b"PalmOS (reserved)\0" as *const u8 as *const libc::c_char,
    b"SymbianOS 2004\0" as *const u8 as *const libc::c_char,
    b"SymbianOS (reserved)\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_PCS_R9_use: [*const libc::c_char; 4] = [
    b"V6\0" as *const u8 as *const libc::c_char,
    b"SB\0" as *const u8 as *const libc::c_char,
    b"TLS\0" as *const u8 as *const libc::c_char,
    b"Unused\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_PCS_RW_data: [*const libc::c_char; 4] = [
    b"Absolute\0" as *const u8 as *const libc::c_char,
    b"PC-relative\0" as *const u8 as *const libc::c_char,
    b"SB-relative\0" as *const u8 as *const libc::c_char,
    b"None\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_PCS_RO_data: [*const libc::c_char; 3] = [
    b"Absolute\0" as *const u8 as *const libc::c_char,
    b"PC-relative\0" as *const u8 as *const libc::c_char,
    b"None\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_PCS_GOT_use: [*const libc::c_char; 3] = [
    b"None\0" as *const u8 as *const libc::c_char,
    b"direct\0" as *const u8 as *const libc::c_char,
    b"GOT-indirect\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_PCS_wchar_t: [*const libc::c_char; 5] = [
    b"None\0" as *const u8 as *const libc::c_char,
    b"??? 1\0" as *const u8 as *const libc::c_char,
    b"2\0" as *const u8 as *const libc::c_char,
    b"??? 3\0" as *const u8 as *const libc::c_char,
    b"4\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_FP_rounding: [*const libc::c_char; 2] = [
    b"Unused\0" as *const u8 as *const libc::c_char,
    b"Needed\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_FP_denormal: [*const libc::c_char; 3] = [
    b"Unused\0" as *const u8 as *const libc::c_char,
    b"Needed\0" as *const u8 as *const libc::c_char,
    b"Sign only\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_FP_exceptions: [*const libc::c_char; 2] = [
    b"Unused\0" as *const u8 as *const libc::c_char,
    b"Needed\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_FP_user_exceptions: [*const libc::c_char; 2] = [
    b"Unused\0" as *const u8 as *const libc::c_char,
    b"Needed\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_FP_number_model: [*const libc::c_char; 4] = [
    b"Unused\0" as *const u8 as *const libc::c_char,
    b"Finite\0" as *const u8 as *const libc::c_char,
    b"RTABI\0" as *const u8 as *const libc::c_char,
    b"IEEE 754\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_enum_size: [*const libc::c_char; 4] = [
    b"Unused\0" as *const u8 as *const libc::c_char,
    b"small\0" as *const u8 as *const libc::c_char,
    b"int\0" as *const u8 as *const libc::c_char,
    b"forced to int\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_HardFP_use: [*const libc::c_char; 4] = [
    b"As Tag_FP_arch\0" as *const u8 as *const libc::c_char,
    b"SP only\0" as *const u8 as *const libc::c_char,
    b"Reserved\0" as *const u8 as *const libc::c_char,
    b"Deprecated\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_VFP_args: [*const libc::c_char; 4] = [
    b"AAPCS\0" as *const u8 as *const libc::c_char,
    b"VFP registers\0" as *const u8 as *const libc::c_char,
    b"custom\0" as *const u8 as *const libc::c_char,
    b"compatible\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_WMMX_args: [*const libc::c_char; 3] = [
    b"AAPCS\0" as *const u8 as *const libc::c_char,
    b"WMMX registers\0" as *const u8 as *const libc::c_char,
    b"custom\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_optimization_goals: [*const libc::c_char; 7] = [
    b"None\0" as *const u8 as *const libc::c_char,
    b"Prefer Speed\0" as *const u8 as *const libc::c_char,
    b"Aggressive Speed\0" as *const u8 as *const libc::c_char,
    b"Prefer Size\0" as *const u8 as *const libc::c_char,
    b"Aggressive Size\0" as *const u8 as *const libc::c_char,
    b"Prefer Debug\0" as *const u8 as *const libc::c_char,
    b"Aggressive Debug\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_FP_optimization_goals: [*const libc::c_char; 7] = [
    b"None\0" as *const u8 as *const libc::c_char,
    b"Prefer Speed\0" as *const u8 as *const libc::c_char,
    b"Aggressive Speed\0" as *const u8 as *const libc::c_char,
    b"Prefer Size\0" as *const u8 as *const libc::c_char,
    b"Aggressive Size\0" as *const u8 as *const libc::c_char,
    b"Prefer Accuracy\0" as *const u8 as *const libc::c_char,
    b"Aggressive Accuracy\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_CPU_unaligned_access: [*const libc::c_char; 2] = [
    b"None\0" as *const u8 as *const libc::c_char,
    b"v6\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_FP_HP_extension: [*const libc::c_char; 2] = [
    b"Not Allowed\0" as *const u8 as *const libc::c_char,
    b"Allowed\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_ABI_FP_16bit_format: [*const libc::c_char; 3] = [
    b"None\0" as *const u8 as *const libc::c_char,
    b"IEEE 754\0" as *const u8 as *const libc::c_char,
    b"Alternative Format\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_DSP_extension: [*const libc::c_char; 2] = [
    b"Follow architecture\0" as *const u8 as *const libc::c_char,
    b"Allowed\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_MPextension_use: [*const libc::c_char; 2] = [
    b"Not Allowed\0" as *const u8 as *const libc::c_char,
    b"Allowed\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_DIV_use: [*const libc::c_char; 3] = [
    b"Allowed in Thumb-ISA, v7-R or v7-M\0" as *const u8 as *const libc::c_char,
    b"Not allowed\0" as *const u8 as *const libc::c_char,
    b"Allowed in v7-A with integer division extension\0" as *const u8
        as *const libc::c_char,
];
static mut arm_attr_tag_T2EE_use: [*const libc::c_char; 2] = [
    b"Not Allowed\0" as *const u8 as *const libc::c_char,
    b"Allowed\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_Virtualization_use: [*const libc::c_char; 4] = [
    b"Not Allowed\0" as *const u8 as *const libc::c_char,
    b"TrustZone\0" as *const u8 as *const libc::c_char,
    b"Virtualization Extensions\0" as *const u8 as *const libc::c_char,
    b"TrustZone and Virtualization Extensions\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_MPextension_use_legacy: [*const libc::c_char; 2] = [
    b"Not Allowed\0" as *const u8 as *const libc::c_char,
    b"Allowed\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_tag_MVE_arch: [*const libc::c_char; 3] = [
    b"No MVE\0" as *const u8 as *const libc::c_char,
    b"MVE Integer only\0" as *const u8 as *const libc::c_char,
    b"MVE Integer and FP\0" as *const u8 as *const libc::c_char,
];
static mut arm_attr_public_tags: [arm_attr_public_tag; 42] = [arm_attr_public_tag {
    tag: 0,
    name: 0 as *const libc::c_char,
    type_0: 0,
    table: 0 as *const *const libc::c_char,
}; 42];
unsafe extern "C" fn display_arm_attribute(
    mut p: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut tag: libc::c_uint = 0;
    let mut val: libc::c_uint = 0;
    let mut attr: *mut arm_attr_public_tag = 0 as *mut arm_attr_public_tag;
    let mut i: libc::c_uint = 0;
    let mut type_0: libc::c_uint = 0;
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
    p = p.offset(_len as isize);
    tag = _val as libc::c_uint;
    if tag as libc::c_ulong != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"readelf.c\0" as *const u8 as *const libc::c_char,
        16197 as libc::c_int as libc::c_ulong,
    );
    attr = 0 as *mut arm_attr_public_tag;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::core::mem::size_of::<[arm_attr_public_tag; 42]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<arm_attr_public_tag>() as libc::c_ulong)
    {
        if arm_attr_public_tags[i as usize].tag == tag {
            attr = &mut *arm_attr_public_tags.as_mut_ptr().offset(i as isize)
                as *mut arm_attr_public_tag;
            break;
        } else {
            i = i.wrapping_add(1);
            i;
        }
    }
    if !attr.is_null() {
        printf(b"  Tag_%s: \0" as *const u8 as *const libc::c_char, (*attr).name);
        match (*attr).type_0 {
            0 => {
                match tag {
                    7 => {
                        let mut _val_0: dwarf_vma = 0;
                        let mut _len_0: libc::c_uint = 0;
                        let mut _status_0: libc::c_int = 0;
                        _val_0 = read_leb128(
                            p,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_0,
                            &mut _status_0,
                        );
                        p = p.offset(_len_0 as isize);
                        val = _val_0 as libc::c_uint;
                        if val as libc::c_ulong != _val_0 {
                            _status_0 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_0,
                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                            16217 as libc::c_int as libc::c_ulong,
                        );
                        match val {
                            0 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"None\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            65 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Application\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            82 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Realtime\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            77 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Microcontroller\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            83 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Application or Realtime\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            _ => {
                                printf(
                                    b"??? (%d)\n\0" as *const u8 as *const libc::c_char,
                                    val,
                                );
                            }
                        }
                    }
                    24 => {
                        let mut _val_1: dwarf_vma = 0;
                        let mut _len_1: libc::c_uint = 0;
                        let mut _status_1: libc::c_int = 0;
                        _val_1 = read_leb128(
                            p,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_1,
                            &mut _status_1,
                        );
                        p = p.offset(_len_1 as isize);
                        val = _val_1 as libc::c_uint;
                        if val as libc::c_ulong != _val_1 {
                            _status_1 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_1,
                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                            16230 as libc::c_int as libc::c_ulong,
                        );
                        match val {
                            0 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"None\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            1 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"8-byte\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            2 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"4-byte\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            3 => {
                                printf(b"??? 3\n\0" as *const u8 as *const libc::c_char);
                            }
                            _ => {
                                if val <= 12 as libc::c_int as libc::c_uint {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"8-byte and up to %d-byte extended\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        (1 as libc::c_int) << val,
                                    );
                                } else {
                                    printf(
                                        b"??? (%d)\n\0" as *const u8 as *const libc::c_char,
                                        val,
                                    );
                                }
                            }
                        }
                    }
                    25 => {
                        let mut _val_2: dwarf_vma = 0;
                        let mut _len_2: libc::c_uint = 0;
                        let mut _status_2: libc::c_int = 0;
                        _val_2 = read_leb128(
                            p,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_2,
                            &mut _status_2,
                        );
                        p = p.offset(_len_2 as isize);
                        val = _val_2 as libc::c_uint;
                        if val as libc::c_ulong != _val_2 {
                            _status_2 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_2,
                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                            16248 as libc::c_int as libc::c_ulong,
                        );
                        match val {
                            0 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"None\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            1 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"8-byte, except leaf SP\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            2 => {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"8-byte\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                            }
                            3 => {
                                printf(b"??? 3\n\0" as *const u8 as *const libc::c_char);
                            }
                            _ => {
                                if val <= 12 as libc::c_int as libc::c_uint {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"8-byte and up to %d-byte extended\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        (1 as libc::c_int) << val,
                                    );
                                } else {
                                    printf(
                                        b"??? (%d)\n\0" as *const u8 as *const libc::c_char,
                                        val,
                                    );
                                }
                            }
                        }
                    }
                    32 => {
                        let mut _val_3: dwarf_vma = 0;
                        let mut _len_3: libc::c_uint = 0;
                        let mut _status_3: libc::c_int = 0;
                        _val_3 = read_leb128(
                            p,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_3,
                            &mut _status_3,
                        );
                        p = p.offset(_len_3 as isize);
                        val = _val_3 as libc::c_uint;
                        if val as libc::c_ulong != _val_3 {
                            _status_3 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_3,
                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                            16267 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"flag = %d, vendor = \0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            val,
                        );
                        if p
                            < end.offset(-(1 as libc::c_int as isize))
                                as *mut libc::c_uchar
                        {
                            let mut maxlen: size_t = (end.offset_from(p) as libc::c_long
                                - 1 as libc::c_int as libc::c_long) as size_t;
                            print_symbol(
                                maxlen as libc::c_int,
                                p as *const libc::c_char,
                            );
                            p = p
                                .offset(
                                    (strnlen(p as *mut libc::c_char, maxlen))
                                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                );
                        } else {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<corrupt>\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            p = end as *mut libc::c_uchar;
                        }
                        putchar('\n' as i32);
                    }
                    64 => {
                        if p < end as *mut libc::c_uchar {
                            p = p.offset(1);
                            p;
                        }
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"True\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    65 => {
                        let mut _val_4: dwarf_vma = 0;
                        let mut _len_4: libc::c_uint = 0;
                        let mut _status_4: libc::c_int = 0;
                        _val_4 = read_leb128(
                            p,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_4,
                            &mut _status_4,
                        );
                        p = p.offset(_len_4 as isize);
                        val = _val_4 as libc::c_uint;
                        if val as libc::c_ulong != _val_4 {
                            _status_4 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_4,
                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                            16293 as libc::c_int as libc::c_ulong,
                        );
                        if val == 6 as libc::c_int as libc::c_uint {
                            let mut _val_5: dwarf_vma = 0;
                            let mut _len_5: libc::c_uint = 0;
                            let mut _status_5: libc::c_int = 0;
                            _val_5 = read_leb128(
                                p,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_5,
                                &mut _status_5,
                            );
                            p = p.offset(_len_5 as isize);
                            val = _val_5 as libc::c_uint;
                            if val as libc::c_ulong != _val_5 {
                                _status_5 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_5,
                                b"readelf.c\0" as *const u8 as *const libc::c_char,
                                16296 as libc::c_int as libc::c_ulong,
                            );
                            if val as libc::c_ulong
                                >= (::core::mem::size_of::<[*const libc::c_char; 22]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::core::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                printf(
                                    b"??? (%d)\n\0" as *const u8 as *const libc::c_char,
                                    val,
                                );
                            } else {
                                printf(
                                    b"%s\n\0" as *const u8 as *const libc::c_char,
                                    arm_attr_tag_CPU_arch[val as usize],
                                );
                            }
                        } else {
                            printf(b"???\n\0" as *const u8 as *const libc::c_char);
                        }
                        while p < end as *mut libc::c_uchar
                            && {
                                let fresh41 = p;
                                p = p.offset(1);
                                *fresh41 as libc::c_int != '\0' as i32
                            }
                        {}
                    }
                    _ => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"<unknown: %d>\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            tag,
                        );
                    }
                }
                return p;
            }
            1 => return display_tag_value(-(1 as libc::c_int), p, end),
            2 => return display_tag_value(0 as libc::c_int, p, end),
            _ => {
                if (*attr).type_0 & 0x80 as libc::c_int as libc::c_uint != 0 {} else {
                    __assert_fail(
                        b"attr->type & 0x80\0" as *const u8 as *const libc::c_char,
                        b"readelf.c\0" as *const u8 as *const libc::c_char,
                        16320 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 82],
                            &[libc::c_char; 82],
                        >(
                            b"unsigned char *display_arm_attribute(unsigned char *, const unsigned char *const)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_121981: {
                    if (*attr).type_0 & 0x80 as libc::c_int as libc::c_uint != 0
                    {} else {
                        __assert_fail(
                            b"attr->type & 0x80\0" as *const u8 as *const libc::c_char,
                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                            16320 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 82],
                                &[libc::c_char; 82],
                            >(
                                b"unsigned char *display_arm_attribute(unsigned char *, const unsigned char *const)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
                let mut _val_6: dwarf_vma = 0;
                let mut _len_6: libc::c_uint = 0;
                let mut _status_6: libc::c_int = 0;
                _val_6 = read_leb128(
                    p,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_6,
                    &mut _status_6,
                );
                p = p.offset(_len_6 as isize);
                val = _val_6 as libc::c_uint;
                if val as libc::c_ulong != _val_6 {
                    _status_6 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_6,
                    b"readelf.c\0" as *const u8 as *const libc::c_char,
                    16321 as libc::c_int as libc::c_ulong,
                );
                type_0 = (*attr).type_0 & 0x7f as libc::c_int as libc::c_uint;
                if val >= type_0 {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                } else {
                    printf(
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        *((*attr).table).offset(val as isize),
                    );
                }
                return p;
            }
        }
    }
    return display_tag_value(tag as libc::c_int, p, end);
}
unsafe extern "C" fn display_gnu_attribute(
    mut p: *mut libc::c_uchar,
    mut display_proc_gnu_attribute: Option::<
        unsafe extern "C" fn(
            *mut libc::c_uchar,
            libc::c_uint,
            *const libc::c_uchar,
        ) -> *mut libc::c_uchar,
    >,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut tag: libc::c_uint = 0;
    let mut val: libc::c_uint = 0;
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
    p = p.offset(_len as isize);
    tag = _val as libc::c_uint;
    if tag as libc::c_ulong != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"readelf.c\0" as *const u8 as *const libc::c_char,
        16342 as libc::c_int as libc::c_ulong,
    );
    if tag == 32 as libc::c_int as libc::c_uint {
        let mut _val_0: dwarf_vma = 0;
        let mut _len_0: libc::c_uint = 0;
        let mut _status_0: libc::c_int = 0;
        _val_0 = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len_0, &mut _status_0);
        p = p.offset(_len_0 as isize);
        val = _val_0 as libc::c_uint;
        if val as libc::c_ulong != _val_0 {
            _status_0 |= 2 as libc::c_int;
        }
        report_leb_status(
            _status_0,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16348 as libc::c_int as libc::c_ulong,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"flag = %d, vendor = \0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            val,
        );
        if p == end as *mut libc::c_uchar {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt>\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"corrupt vendor attribute\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            if p < end.offset(-(1 as libc::c_int as isize)) as *mut libc::c_uchar {
                let mut maxlen: size_t = (end.offset_from(p) as libc::c_long
                    - 1 as libc::c_int as libc::c_long) as size_t;
                print_symbol(maxlen as libc::c_int, p as *const libc::c_char);
                p = p
                    .offset(
                        (strnlen(p as *mut libc::c_char, maxlen))
                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                p = end as *mut libc::c_uchar;
            }
            putchar('\n' as i32);
        }
        return p;
    }
    if tag & 2 as libc::c_int as libc::c_uint == 0 as libc::c_int as libc::c_uint
        && display_proc_gnu_attribute.is_some()
    {
        return display_proc_gnu_attribute
            .expect("non-null function pointer")(p, tag, end);
    }
    return display_tag_value(tag as libc::c_int, p, end);
}
unsafe extern "C" fn display_m68k_gnu_attribute(
    mut p: *mut libc::c_uchar,
    mut tag: libc::c_uint,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut val: libc::c_uint = 0;
    if tag == Tag_GNU_M68K_ABI_FP as libc::c_int as libc::c_uint {
        printf(b"  Tag_GNU_M68K_ABI_FP: \0" as *const u8 as *const libc::c_char);
        if p == end as *mut libc::c_uchar {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt>\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return p;
        }
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
        p = p.offset(_len as isize);
        val = _val as libc::c_uint;
        if val as libc::c_ulong != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16396 as libc::c_int as libc::c_ulong,
        );
        if val > 3 as libc::c_int as libc::c_uint {
            printf(b"(%#x), \0" as *const u8 as *const libc::c_char, val);
        }
        match val & 3 as libc::c_int as libc::c_uint {
            0 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unspecified hard/soft float\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            1 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"hard float\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            2 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"soft float\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            _ => {}
        }
        return p;
    }
    return display_tag_value(
        (tag & 1 as libc::c_int as libc::c_uint) as libc::c_int,
        p,
        end,
    );
}
unsafe extern "C" fn display_power_gnu_attribute(
    mut p: *mut libc::c_uchar,
    mut tag: libc::c_uint,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut val: libc::c_uint = 0;
    if tag == Tag_GNU_Power_ABI_FP as libc::c_int as libc::c_uint {
        printf(b"  Tag_GNU_Power_ABI_FP: \0" as *const u8 as *const libc::c_char);
        if p == end as *mut libc::c_uchar {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt>\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return p;
        }
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
        p = p.offset(_len as isize);
        val = _val as libc::c_uint;
        if val as libc::c_ulong != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16434 as libc::c_int as libc::c_ulong,
        );
        if val > 15 as libc::c_int as libc::c_uint {
            printf(b"(%#x), \0" as *const u8 as *const libc::c_char, val);
        }
        match val & 3 as libc::c_int as libc::c_uint {
            0 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unspecified hard/soft float, \0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            1 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"hard float, \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            2 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"soft float, \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            3 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"single-precision hard float, \0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            _ => {}
        }
        match val & 0xc as libc::c_int as libc::c_uint {
            0 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unspecified long double\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            4 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"128-bit IBM long double\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            8 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"64-bit long double\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            12 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"128-bit IEEE long double\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            _ => {}
        }
        return p;
    }
    if tag == Tag_GNU_Power_ABI_Vector as libc::c_int as libc::c_uint {
        printf(b"  Tag_GNU_Power_ABI_Vector: \0" as *const u8 as *const libc::c_char);
        if p == end as *mut libc::c_uchar {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt>\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return p;
        }
        let mut _val_0: dwarf_vma = 0;
        let mut _len_0: libc::c_uint = 0;
        let mut _status_0: libc::c_int = 0;
        _val_0 = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len_0, &mut _status_0);
        p = p.offset(_len_0 as isize);
        val = _val_0 as libc::c_uint;
        if val as libc::c_ulong != _val_0 {
            _status_0 |= 2 as libc::c_int;
        }
        report_leb_status(
            _status_0,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16481 as libc::c_int as libc::c_ulong,
        );
        if val > 3 as libc::c_int as libc::c_uint {
            printf(b"(%#x), \0" as *const u8 as *const libc::c_char, val);
        }
        match val & 3 as libc::c_int as libc::c_uint {
            0 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unspecified\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            1 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"generic\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            2 => {
                printf(b"AltiVec\n\0" as *const u8 as *const libc::c_char);
            }
            3 => {
                printf(b"SPE\n\0" as *const u8 as *const libc::c_char);
            }
            _ => {}
        }
        return p;
    }
    if tag == Tag_GNU_Power_ABI_Struct_Return as libc::c_int as libc::c_uint {
        printf(
            b"  Tag_GNU_Power_ABI_Struct_Return: \0" as *const u8 as *const libc::c_char,
        );
        if p == end as *mut libc::c_uchar {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt>\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return p;
        }
        let mut _val_1: dwarf_vma = 0;
        let mut _len_1: libc::c_uint = 0;
        let mut _status_1: libc::c_int = 0;
        _val_1 = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len_1, &mut _status_1);
        p = p.offset(_len_1 as isize);
        val = _val_1 as libc::c_uint;
        if val as libc::c_ulong != _val_1 {
            _status_1 |= 2 as libc::c_int;
        }
        report_leb_status(
            _status_1,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16512 as libc::c_int as libc::c_ulong,
        );
        if val > 2 as libc::c_int as libc::c_uint {
            printf(b"(%#x), \0" as *const u8 as *const libc::c_char, val);
        }
        match val & 3 as libc::c_int as libc::c_uint {
            0 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unspecified\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            1 => {
                printf(b"r3/r4\n\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"memory\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            3 => {
                printf(b"???\n\0" as *const u8 as *const libc::c_char);
            }
            _ => {}
        }
        return p;
    }
    return display_tag_value(
        (tag & 1 as libc::c_int as libc::c_uint) as libc::c_int,
        p,
        end,
    );
}
unsafe extern "C" fn display_s390_gnu_attribute(
    mut p: *mut libc::c_uchar,
    mut tag: libc::c_uint,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut val: libc::c_uint = 0;
    if tag == Tag_GNU_S390_ABI_Vector as libc::c_int as libc::c_uint {
        printf(b"  Tag_GNU_S390_ABI_Vector: \0" as *const u8 as *const libc::c_char);
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
        p = p.offset(_len as isize);
        val = _val as libc::c_uint;
        if val as libc::c_ulong != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16548 as libc::c_int as libc::c_ulong,
        );
        match val {
            0 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"any\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            1 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"software\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            2 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"hardware\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            _ => {
                printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
            }
        }
        return p;
    }
    return display_tag_value(
        (tag & 1 as libc::c_int as libc::c_uint) as libc::c_int,
        p,
        end,
    );
}
unsafe extern "C" fn display_sparc_hwcaps(mut mask: libc::c_uint) {
    if mask != 0 {
        let mut first: bool = 1 as libc::c_int != 0;
        if mask & 0x1 as libc::c_int as libc::c_uint != 0 {
            fputs(b"mul32\0" as *const u8 as *const libc::c_char, stdout);
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x2 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sdiv32\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x4 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sfsmuld\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x8 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sv8plus\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x10 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%spopc\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x20 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%svis\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x40 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%svis2\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x80 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sASIBlkInit\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x100 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sfmaf\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x400 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%svis3\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x800 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%shpc\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x1000 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%srandom\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x2000 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%strans\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x4000 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sfjfmau\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x8000 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sima\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x10000 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%scspare\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
    } else {
        fputc('0' as i32, stdout);
    }
    fputc('\n' as i32, stdout);
}
unsafe extern "C" fn display_sparc_hwcaps2(mut mask: libc::c_uint) {
    if mask != 0 {
        let mut first: bool = 1 as libc::c_int != 0;
        if mask & 0x1 as libc::c_int as libc::c_uint != 0 {
            fputs(b"fjathplus\0" as *const u8 as *const libc::c_char, stdout);
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x2 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%svis3b\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x4 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sadp\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x8 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%ssparc5\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x10 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%smwait\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x20 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sxmpmul\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x40 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sxmont2\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x80 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%snsec\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x1000 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sfjathhpc\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x2000 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sfjdes\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
        if mask & 0x10000 as libc::c_int as libc::c_uint != 0 {
            printf(
                b"%sfjaes\0" as *const u8 as *const libc::c_char,
                if first as libc::c_int != 0 {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b"|\0" as *const u8 as *const libc::c_char
                },
            );
            first = 0 as libc::c_int != 0;
        }
    } else {
        fputc('0' as i32, stdout);
    }
    fputc('\n' as i32, stdout);
}
unsafe extern "C" fn display_sparc_gnu_attribute(
    mut p: *mut libc::c_uchar,
    mut tag: libc::c_uint,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut val: libc::c_uint = 0;
    if tag == Tag_GNU_Sparc_HWCAPS as libc::c_int as libc::c_uint {
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
        p = p.offset(_len as isize);
        val = _val as libc::c_uint;
        if val as libc::c_ulong != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16660 as libc::c_int as libc::c_ulong,
        );
        printf(b"  Tag_GNU_Sparc_HWCAPS: \0" as *const u8 as *const libc::c_char);
        display_sparc_hwcaps(val);
        return p;
    }
    if tag == Tag_GNU_Sparc_HWCAPS2 as libc::c_int as libc::c_uint {
        let mut _val_0: dwarf_vma = 0;
        let mut _len_0: libc::c_uint = 0;
        let mut _status_0: libc::c_int = 0;
        _val_0 = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len_0, &mut _status_0);
        p = p.offset(_len_0 as isize);
        val = _val_0 as libc::c_uint;
        if val as libc::c_ulong != _val_0 {
            _status_0 |= 2 as libc::c_int;
        }
        report_leb_status(
            _status_0,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16667 as libc::c_int as libc::c_ulong,
        );
        printf(b"  Tag_GNU_Sparc_HWCAPS2: \0" as *const u8 as *const libc::c_char);
        display_sparc_hwcaps2(val);
        return p;
    }
    return display_tag_value(tag as libc::c_int, p, end);
}
unsafe extern "C" fn print_mips_fp_abi_value(mut val: libc::c_uint) {
    match val {
        0 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Hard or soft float\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        1 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Hard float (double precision)\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        2 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Hard float (single precision)\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        3 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Soft float\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        4 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Hard float (MIPS32r2 64-bit FPU 12 callee-saved)\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        5 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Hard float (32-bit CPU, Any FPU)\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        6 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Hard float (32-bit CPU, 64-bit FPU)\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        7 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Hard float compat (32-bit CPU, 64-bit FPU)\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        8 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"NaN 2008 compatibility\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        _ => {
            printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
        }
    };
}
unsafe extern "C" fn display_mips_gnu_attribute(
    mut p: *mut libc::c_uchar,
    mut tag: libc::c_uint,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    if tag == Tag_GNU_MIPS_ABI_FP as libc::c_int as libc::c_uint {
        let mut val: libc::c_uint = 0;
        printf(b"  Tag_GNU_MIPS_ABI_FP: \0" as *const u8 as *const libc::c_char);
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
        p = p.offset(_len as isize);
        val = _val as libc::c_uint;
        if val as libc::c_ulong != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16724 as libc::c_int as libc::c_ulong,
        );
        print_mips_fp_abi_value(val);
        return p;
    }
    if tag == Tag_GNU_MIPS_ABI_MSA as libc::c_int as libc::c_uint {
        let mut val_0: libc::c_uint = 0;
        printf(b"  Tag_GNU_MIPS_ABI_MSA: \0" as *const u8 as *const libc::c_char);
        let mut _val_0: dwarf_vma = 0;
        let mut _len_0: libc::c_uint = 0;
        let mut _status_0: libc::c_int = 0;
        _val_0 = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len_0, &mut _status_0);
        p = p.offset(_len_0 as isize);
        val_0 = _val_0 as libc::c_uint;
        if val_0 as libc::c_ulong != _val_0 {
            _status_0 |= 2 as libc::c_int;
        }
        report_leb_status(
            _status_0,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16734 as libc::c_int as libc::c_ulong,
        );
        match val_0 {
            0 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Any MSA or not\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            1 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"128-bit MSA\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            _ => {
                printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val_0);
            }
        }
        return p;
    }
    return display_tag_value(
        (tag & 1 as libc::c_int as libc::c_uint) as libc::c_int,
        p,
        end,
    );
}
unsafe extern "C" fn display_tic6x_attribute(
    mut p: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut tag: libc::c_uint = 0;
    let mut val: libc::c_uint = 0;
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
    p = p.offset(_len as isize);
    tag = _val as libc::c_uint;
    if tag as libc::c_ulong != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"readelf.c\0" as *const u8 as *const libc::c_char,
        16761 as libc::c_int as libc::c_ulong,
    );
    match tag {
        4 => {
            printf(b"  Tag_ISA: \0" as *const u8 as *const libc::c_char);
            let mut _val_0: dwarf_vma = 0;
            let mut _len_0: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_0,
                &mut _status_0,
            );
            p = p.offset(_len_0 as isize);
            val = _val_0 as libc::c_uint;
            if val as libc::c_ulong != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16767 as libc::c_int as libc::c_ulong,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"None\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(b"C62x\n\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    printf(b"C67x\n\0" as *const u8 as *const libc::c_char);
                }
                4 => {
                    printf(b"C67x+\n\0" as *const u8 as *const libc::c_char);
                }
                6 => {
                    printf(b"C64x\n\0" as *const u8 as *const libc::c_char);
                }
                7 => {
                    printf(b"C64x+\n\0" as *const u8 as *const libc::c_char);
                }
                8 => {
                    printf(b"C674x\n\0" as *const u8 as *const libc::c_char);
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        6 => {
            printf(b"  Tag_ABI_wchar_t: \0" as *const u8 as *const libc::c_char);
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            p = p.offset(_len_1 as isize);
            val = _val_1 as libc::c_uint;
            if val as libc::c_ulong != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16800 as libc::c_int as libc::c_ulong,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Not used\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"2 bytes\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"4 bytes\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        8 => {
            printf(
                b"  Tag_ABI_stack_align_needed: \0" as *const u8 as *const libc::c_char,
            );
            let mut _val_2: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_2: libc::c_int = 0;
            _val_2 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_2,
            );
            p = p.offset(_len_2 as isize);
            val = _val_2 as libc::c_uint;
            if val as libc::c_ulong != _val_2 {
                _status_2 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_2,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16820 as libc::c_int as libc::c_ulong,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"8-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"16-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        10 => {
            let mut _val_3: dwarf_vma = 0;
            let mut _len_3: libc::c_uint = 0;
            let mut _status_3: libc::c_int = 0;
            _val_3 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_3,
                &mut _status_3,
            );
            p = p.offset(_len_3 as isize);
            val = _val_3 as libc::c_uint;
            if val as libc::c_ulong != _val_3 {
                _status_3 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_3,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16836 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ABI_stack_align_preserved: \0" as *const u8
                    as *const libc::c_char,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"8-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"16-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        12 => {
            let mut _val_4: dwarf_vma = 0;
            let mut _len_4: libc::c_uint = 0;
            let mut _status_4: libc::c_int = 0;
            _val_4 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_4,
                &mut _status_4,
            );
            p = p.offset(_len_4 as isize);
            val = _val_4 as libc::c_uint;
            if val as libc::c_ulong != _val_4 {
                _status_4 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_4,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16853 as libc::c_int as libc::c_ulong,
            );
            printf(b"  Tag_ABI_DSBT: \0" as *const u8 as *const libc::c_char);
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"DSBT addressing not used\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"DSBT addressing used\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        14 => {
            let mut _val_5: dwarf_vma = 0;
            let mut _len_5: libc::c_uint = 0;
            let mut _status_5: libc::c_int = 0;
            _val_5 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_5,
                &mut _status_5,
            );
            p = p.offset(_len_5 as isize);
            val = _val_5 as libc::c_uint;
            if val as libc::c_ulong != _val_5 {
                _status_5 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_5,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16870 as libc::c_int as libc::c_ulong,
            );
            printf(b"  Tag_ABI_PID: \0" as *const u8 as *const libc::c_char);
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Data addressing position-dependent\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Data addressing position-independent, GOT near DP\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Data addressing position-independent, GOT far from DP\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        16 => {
            let mut _val_6: dwarf_vma = 0;
            let mut _len_6: libc::c_uint = 0;
            let mut _status_6: libc::c_int = 0;
            _val_6 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_6,
                &mut _status_6,
            );
            p = p.offset(_len_6 as isize);
            val = _val_6 as libc::c_uint;
            if val as libc::c_ulong != _val_6 {
                _status_6 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_6,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16890 as libc::c_int as libc::c_ulong,
            );
            printf(b"  Tag_ABI_PIC: \0" as *const u8 as *const libc::c_char);
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Code addressing position-dependent\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Code addressing position-independent\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        18 => {
            let mut _val_7: dwarf_vma = 0;
            let mut _len_7: libc::c_uint = 0;
            let mut _status_7: libc::c_int = 0;
            _val_7 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_7,
                &mut _status_7,
            );
            p = p.offset(_len_7 as isize);
            val = _val_7 as libc::c_uint;
            if val as libc::c_ulong != _val_7 {
                _status_7 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_7,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16907 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ABI_array_object_alignment: \0" as *const u8
                    as *const libc::c_char,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"8-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"4-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"16-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        20 => {
            let mut _val_8: dwarf_vma = 0;
            let mut _len_8: libc::c_uint = 0;
            let mut _status_8: libc::c_int = 0;
            _val_8 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_8,
                &mut _status_8,
            );
            p = p.offset(_len_8 as isize);
            val = _val_8 as libc::c_uint;
            if val as libc::c_ulong != _val_8 {
                _status_8 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_8,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16927 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"  Tag_ABI_array_object_align_expected: \0" as *const u8
                    as *const libc::c_char,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"8-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"4-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"16-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
            return p;
        }
        32 => {
            let mut _val_9: dwarf_vma = 0;
            let mut _len_9: libc::c_uint = 0;
            let mut _status_9: libc::c_int = 0;
            _val_9 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_9,
                &mut _status_9,
            );
            p = p.offset(_len_9 as isize);
            val = _val_9 as libc::c_uint;
            if val as libc::c_ulong != _val_9 {
                _status_9 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_9,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16948 as libc::c_int as libc::c_ulong,
            );
            printf(b"  Tag_ABI_compatibility: \0" as *const u8 as *const libc::c_char);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"flag = %d, vendor = \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                val,
            );
            if p < end.offset(-(1 as libc::c_int as isize)) as *mut libc::c_uchar {
                let mut maxlen: size_t = (end.offset_from(p) as libc::c_long
                    - 1 as libc::c_int as libc::c_long) as size_t;
                print_symbol(maxlen as libc::c_int, p as *const libc::c_char);
                p = p
                    .offset(
                        (strnlen(p as *mut libc::c_char, maxlen))
                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                p = end as *mut libc::c_uchar;
            }
            putchar('\n' as i32);
            return p;
        }
        67 => {
            printf(b"  Tag_ABI_conformance: \"\0" as *const u8 as *const libc::c_char);
            if p < end.offset(-(1 as libc::c_int as isize)) as *mut libc::c_uchar {
                let mut maxlen_0: size_t = (end.offset_from(p) as libc::c_long
                    - 1 as libc::c_int as libc::c_long) as size_t;
                print_symbol(maxlen_0 as libc::c_int, p as *const libc::c_char);
                p = p
                    .offset(
                        (strnlen(p as *mut libc::c_char, maxlen_0))
                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                p = end as *mut libc::c_uchar;
            }
            printf(b"\"\n\0" as *const u8 as *const libc::c_char);
            return p;
        }
        _ => {}
    }
    return display_tag_value(tag as libc::c_int, p, end);
}
unsafe extern "C" fn display_raw_attribute(
    mut p: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) {
    let mut addr: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut bytes: size_t = end.offset_from(p) as libc::c_long as size_t;
    if end >= p as *const libc::c_uchar {} else {
        __assert_fail(
            b"end >= p\0" as *const u8 as *const libc::c_char,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            16996 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 72],
                &[libc::c_char; 72],
            >(
                b"void display_raw_attribute(unsigned char *, const unsigned char *const)\0",
            ))
                .as_ptr(),
        );
    }
    'c_127577: {
        if end >= p as *const libc::c_uchar {} else {
            __assert_fail(
                b"end >= p\0" as *const u8 as *const libc::c_char,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                16996 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 72],
                    &[libc::c_char; 72],
                >(
                    b"void display_raw_attribute(unsigned char *, const unsigned char *const)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    while bytes != 0 {
        let mut j: libc::c_int = 0;
        let mut k: libc::c_int = 0;
        let mut lbytes: libc::c_int = (if bytes > 16 as libc::c_int as libc::c_ulong {
            16 as libc::c_int as libc::c_ulong
        } else {
            bytes
        }) as libc::c_int;
        printf(b"  0x%8.8lx \0" as *const u8 as *const libc::c_char, addr);
        j = 0 as libc::c_int;
        while j < 16 as libc::c_int {
            if j < lbytes {
                printf(
                    b"%2.2x\0" as *const u8 as *const libc::c_char,
                    *p.offset(j as isize) as libc::c_int,
                );
            } else {
                printf(b"  \0" as *const u8 as *const libc::c_char);
            }
            if j & 3 as libc::c_int == 3 as libc::c_int {
                printf(b" \0" as *const u8 as *const libc::c_char);
            }
            j += 1;
            j;
        }
        j = 0 as libc::c_int;
        while j < lbytes {
            k = *p.offset(j as isize) as libc::c_int;
            if k >= ' ' as i32 && k < 0x7f as libc::c_int {
                printf(b"%c\0" as *const u8 as *const libc::c_char, k);
            } else {
                printf(b".\0" as *const u8 as *const libc::c_char);
            }
            j += 1;
            j;
        }
        putchar('\n' as i32);
        p = p.offset(lbytes as isize);
        bytes = (bytes as libc::c_ulong).wrapping_sub(lbytes as libc::c_ulong) as size_t
            as size_t;
        addr = addr.wrapping_add(lbytes as libc::c_ulong);
    }
    putchar('\n' as i32);
}
unsafe extern "C" fn display_msp430_attribute(
    mut p: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut val: libc::c_uint = 0;
    let mut tag: libc::c_uint = 0;
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
    p = p.offset(_len as isize);
    tag = _val as libc::c_uint;
    if tag as libc::c_ulong != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"readelf.c\0" as *const u8 as *const libc::c_char,
        17042 as libc::c_int as libc::c_ulong,
    );
    match tag {
        4 => {
            printf(b"  Tag_ISA: \0" as *const u8 as *const libc::c_char);
            let mut _val_0: dwarf_vma = 0;
            let mut _len_0: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_0,
                &mut _status_0,
            );
            p = p.offset(_len_0 as isize);
            val = _val_0 as libc::c_uint;
            if val as libc::c_ulong != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17048 as libc::c_int as libc::c_ulong,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"None\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"MSP430\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"MSP430X\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
        }
        6 => {
            printf(b"  Tag_Code_Model: \0" as *const u8 as *const libc::c_char);
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            p = p.offset(_len_1 as isize);
            val = _val_1 as libc::c_uint;
            if val as libc::c_ulong != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17060 as libc::c_int as libc::c_ulong,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"None\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Small\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Large\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
        }
        8 => {
            printf(b"  Tag_Data_Model: \0" as *const u8 as *const libc::c_char);
            let mut _val_2: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_2: libc::c_int = 0;
            _val_2 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_2,
            );
            p = p.offset(_len_2 as isize);
            val = _val_2 as libc::c_uint;
            if val as libc::c_ulong != _val_2 {
                _status_2 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_2,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17072 as libc::c_int as libc::c_ulong,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"None\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Small\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Large\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                3 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Restricted Large\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(b"??? (%d)\n\0" as *const u8 as *const libc::c_char, val);
                }
            }
        }
        _ => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  <unknown tag %d>: \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                tag,
            );
            if tag & 1 as libc::c_int as libc::c_uint != 0 {
                putchar('"' as i32);
                if p < end.offset(-(1 as libc::c_int as isize)) as *mut libc::c_uchar {
                    let mut maxlen: size_t = (end.offset_from(p) as libc::c_long
                        - 1 as libc::c_int as libc::c_long) as size_t;
                    print_symbol(maxlen as libc::c_int, p as *const libc::c_char);
                    p = p
                        .offset(
                            (strnlen(p as *mut libc::c_char, maxlen))
                                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                        );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<corrupt>\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    p = end as *mut libc::c_uchar;
                }
                printf(b"\"\n\0" as *const u8 as *const libc::c_char);
            } else {
                let mut _val_3: dwarf_vma = 0;
                let mut _len_3: libc::c_uint = 0;
                let mut _status_3: libc::c_int = 0;
                _val_3 = read_leb128(
                    p,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_3,
                    &mut _status_3,
                );
                p = p.offset(_len_3 as isize);
                val = _val_3 as libc::c_uint;
                if val as libc::c_ulong != _val_3 {
                    _status_3 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_3,
                    b"readelf.c\0" as *const u8 as *const libc::c_char,
                    17105 as libc::c_int as libc::c_ulong,
                );
                printf(b"%d (0x%x)\n\0" as *const u8 as *const libc::c_char, val, val);
            }
        }
    }
    if p <= end as *mut libc::c_uchar {} else {
        __assert_fail(
            b"p <= end\0" as *const u8 as *const libc::c_char,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            17111 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 85],
                &[libc::c_char; 85],
            >(
                b"unsigned char *display_msp430_attribute(unsigned char *, const unsigned char *const)\0",
            ))
                .as_ptr(),
        );
    }
    'c_127629: {
        if p <= end as *mut libc::c_uchar {} else {
            __assert_fail(
                b"p <= end\0" as *const u8 as *const libc::c_char,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17111 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 85],
                    &[libc::c_char; 85],
                >(
                    b"unsigned char *display_msp430_attribute(unsigned char *, const unsigned char *const)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    return p;
}
unsafe extern "C" fn display_msp430_gnu_attribute(
    mut p: *mut libc::c_uchar,
    mut tag: libc::c_uint,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    if tag == Tag_GNU_MSP430_Data_Region as libc::c_int as libc::c_uint {
        let mut val: libc::c_uint = 0;
        printf(b"  Tag_GNU_MSP430_Data_Region: \0" as *const u8 as *const libc::c_char);
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
        p = p.offset(_len as isize);
        val = _val as libc::c_uint;
        if val as libc::c_ulong != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"readelf.c\0" as *const u8 as *const libc::c_char,
            17125 as libc::c_int as libc::c_ulong,
        );
        match val {
            2 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Any Region\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            1 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Lower Region Only\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            _ => {
                printf(b"??? (%u)\n\0" as *const u8 as *const libc::c_char, val);
            }
        }
        return p;
    }
    return display_tag_value(
        (tag & 1 as libc::c_int as libc::c_uint) as libc::c_int,
        p,
        end,
    );
}
static mut riscv_attr_tag: [riscv_attr_tag_t; 6] = [
    {
        let mut init = riscv_attr_tag_t {
            name: b"Tag_RISCV_arch\0" as *const u8 as *const libc::c_char,
            tag: Tag_RISCV_arch as libc::c_int as libc::c_uint,
        };
        init
    },
    {
        let mut init = riscv_attr_tag_t {
            name: b"Tag_RISCV_priv_spec\0" as *const u8 as *const libc::c_char,
            tag: Tag_RISCV_priv_spec as libc::c_int as libc::c_uint,
        };
        init
    },
    {
        let mut init = riscv_attr_tag_t {
            name: b"Tag_RISCV_priv_spec_minor\0" as *const u8 as *const libc::c_char,
            tag: Tag_RISCV_priv_spec_minor as libc::c_int as libc::c_uint,
        };
        init
    },
    {
        let mut init = riscv_attr_tag_t {
            name: b"Tag_RISCV_priv_spec_revision\0" as *const u8 as *const libc::c_char,
            tag: Tag_RISCV_priv_spec_revision as libc::c_int as libc::c_uint,
        };
        init
    },
    {
        let mut init = riscv_attr_tag_t {
            name: b"Tag_RISCV_unaligned_access\0" as *const u8 as *const libc::c_char,
            tag: Tag_RISCV_unaligned_access as libc::c_int as libc::c_uint,
        };
        init
    },
    {
        let mut init = riscv_attr_tag_t {
            name: b"Tag_RISCV_stack_align\0" as *const u8 as *const libc::c_char,
            tag: Tag_RISCV_stack_align as libc::c_int as libc::c_uint,
        };
        init
    },
];
unsafe extern "C" fn display_riscv_attribute(
    mut p: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut val: libc::c_uint = 0;
    let mut tag: libc::c_uint = 0;
    let mut attr: *mut riscv_attr_tag_t = 0 as *mut riscv_attr_tag_t;
    let mut i: libc::c_uint = 0;
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
    p = p.offset(_len as isize);
    tag = _val as libc::c_uint;
    if tag as libc::c_ulong != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"readelf.c\0" as *const u8 as *const libc::c_char,
        17169 as libc::c_int as libc::c_ulong,
    );
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::core::mem::size_of::<[riscv_attr_tag_t; 6]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<riscv_attr_tag_t>() as libc::c_ulong)
    {
        if riscv_attr_tag[i as usize].tag == tag {
            attr = &mut *riscv_attr_tag.as_mut_ptr().offset(i as isize)
                as *mut riscv_attr_tag_t;
            break;
        } else {
            i = i.wrapping_add(1);
            i;
        }
    }
    if !attr.is_null() {
        printf(b"  %s: \0" as *const u8 as *const libc::c_char, (*attr).name);
    } else {
        return display_tag_value(tag as libc::c_int, p, end)
    }
    match tag {
        8 | 10 | 12 => {
            let mut _val_0: dwarf_vma = 0;
            let mut _len_0: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_0,
                &mut _status_0,
            );
            p = p.offset(_len_0 as isize);
            val = _val_0 as libc::c_uint;
            if val as libc::c_ulong != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17191 as libc::c_int as libc::c_ulong,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"%u\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                val,
            );
        }
        6 => {
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            p = p.offset(_len_1 as isize);
            val = _val_1 as libc::c_uint;
            if val as libc::c_ulong != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17195 as libc::c_int as libc::c_ulong,
            );
            match val {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"No unaligned access\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unaligned access\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {}
            }
        }
        4 => {
            let mut _val_2: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_2: libc::c_int = 0;
            _val_2 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_2,
            );
            p = p.offset(_len_2 as isize);
            val = _val_2 as libc::c_uint;
            if val as libc::c_ulong != _val_2 {
                _status_2 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_2,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17207 as libc::c_int as libc::c_ulong,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"%u-bytes\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                val,
            );
        }
        5 => {
            p = display_tag_value(-(1 as libc::c_int), p, end);
        }
        _ => return display_tag_value(tag as libc::c_int, p, end),
    }
    return p;
}
unsafe extern "C" fn display_csky_attribute(
    mut p: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut tag: libc::c_uint = 0;
    let mut val: libc::c_uint = 0;
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(p, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
    p = p.offset(_len as isize);
    tag = _val as libc::c_uint;
    if tag as libc::c_ulong != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"readelf.c\0" as *const u8 as *const libc::c_char,
        17226 as libc::c_int as libc::c_ulong,
    );
    if tag >= Tag_CSKY_MAX as libc::c_int as libc::c_uint {
        return display_tag_value(-(1 as libc::c_int), p, end);
    }
    match tag {
        4 => {
            printf(b"  Tag_CSKY_ARCH_NAME:\t\t\0" as *const u8 as *const libc::c_char);
            return display_tag_value(-(1 as libc::c_int), p, end);
        }
        5 => {
            printf(b"  Tag_CSKY_CPU_NAME:\t\t\0" as *const u8 as *const libc::c_char);
            return display_tag_value(-(1 as libc::c_int), p, end);
        }
        6 => {
            printf(b"  Tag_CSKY_ISA_FLAGS:\t\t\0" as *const u8 as *const libc::c_char);
            return display_tag_value(0 as libc::c_int, p, end);
        }
        7 => {
            printf(b"  Tag_CSKY_ISA_EXT_FLAGS:\t\0" as *const u8 as *const libc::c_char);
            return display_tag_value(0 as libc::c_int, p, end);
        }
        8 => {
            printf(b"  Tag_CSKY_DSP_VERSION:\t\t\0" as *const u8 as *const libc::c_char);
            let mut _val_0: dwarf_vma = 0;
            let mut _len_0: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_0,
                &mut _status_0,
            );
            p = p.offset(_len_0 as isize);
            val = _val_0 as libc::c_uint;
            if val as libc::c_ulong != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17251 as libc::c_int as libc::c_ulong,
            );
            if val == VAL_CSKY_DSP_VERSION_EXTENSION as libc::c_int as libc::c_uint {
                printf(b"DSP Extension\n\0" as *const u8 as *const libc::c_char);
            } else if val == VAL_CSKY_DSP_VERSION_2 as libc::c_int as libc::c_uint {
                printf(b"DSP 2.0\n\0" as *const u8 as *const libc::c_char);
            }
        }
        9 => {
            printf(b"  Tag_CSKY_VDSP_VERSION:\t\0" as *const u8 as *const libc::c_char);
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            p = p.offset(_len_1 as isize);
            val = _val_1 as libc::c_uint;
            if val as libc::c_ulong != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17260 as libc::c_int as libc::c_ulong,
            );
            printf(b"VDSP Version %d\n\0" as *const u8 as *const libc::c_char, val);
        }
        16 => {
            printf(b"  Tag_CSKY_FPU_VERSION:\t\t\0" as *const u8 as *const libc::c_char);
            let mut _val_2: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_2: libc::c_int = 0;
            _val_2 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_2,
            );
            p = p.offset(_len_2 as isize);
            val = _val_2 as libc::c_uint;
            if val as libc::c_ulong != _val_2 {
                _status_2 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_2,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17266 as libc::c_int as libc::c_ulong,
            );
            if val == VAL_CSKY_FPU_VERSION_1 as libc::c_int as libc::c_uint {
                printf(b"ABIV1 FPU Version 1\n\0" as *const u8 as *const libc::c_char);
            } else if val == VAL_CSKY_FPU_VERSION_2 as libc::c_int as libc::c_uint {
                printf(b"FPU Version 2\n\0" as *const u8 as *const libc::c_char);
            }
        }
        17 => {
            printf(b"  Tag_CSKY_FPU_ABI:\t\t\0" as *const u8 as *const libc::c_char);
            let mut _val_3: dwarf_vma = 0;
            let mut _len_3: libc::c_uint = 0;
            let mut _status_3: libc::c_int = 0;
            _val_3 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_3,
                &mut _status_3,
            );
            p = p.offset(_len_3 as isize);
            val = _val_3 as libc::c_uint;
            if val as libc::c_ulong != _val_3 {
                _status_3 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_3,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17275 as libc::c_int as libc::c_ulong,
            );
            if val == VAL_CSKY_FPU_ABI_HARD as libc::c_int as libc::c_uint {
                printf(b"Hard\n\0" as *const u8 as *const libc::c_char);
            } else if val == VAL_CSKY_FPU_ABI_SOFTFP as libc::c_int as libc::c_uint {
                printf(b"SoftFP\n\0" as *const u8 as *const libc::c_char);
            } else if val == VAL_CSKY_FPU_ABI_SOFT as libc::c_int as libc::c_uint {
                printf(b"Soft\n\0" as *const u8 as *const libc::c_char);
            }
        }
        18 => {
            let mut _val_4: dwarf_vma = 0;
            let mut _len_4: libc::c_uint = 0;
            let mut _status_4: libc::c_int = 0;
            _val_4 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_4,
                &mut _status_4,
            );
            p = p.offset(_len_4 as isize);
            val = _val_4 as libc::c_uint;
            if val as libc::c_ulong != _val_4 {
                _status_4 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_4,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17284 as libc::c_int as libc::c_ulong,
            );
            if val == 1 as libc::c_int as libc::c_uint {
                printf(
                    b"  Tag_CSKY_FPU_ROUNDING:\t\0" as *const u8 as *const libc::c_char,
                );
                printf(b"Needed\n\0" as *const u8 as *const libc::c_char);
            }
        }
        19 => {
            let mut _val_5: dwarf_vma = 0;
            let mut _len_5: libc::c_uint = 0;
            let mut _status_5: libc::c_int = 0;
            _val_5 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_5,
                &mut _status_5,
            );
            p = p.offset(_len_5 as isize);
            val = _val_5 as libc::c_uint;
            if val as libc::c_ulong != _val_5 {
                _status_5 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_5,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17291 as libc::c_int as libc::c_ulong,
            );
            if val == 1 as libc::c_int as libc::c_uint {
                printf(
                    b"  Tag_CSKY_FPU_DENORMAL:\t\0" as *const u8 as *const libc::c_char,
                );
                printf(b"Needed\n\0" as *const u8 as *const libc::c_char);
            }
        }
        20 => {
            let mut _val_6: dwarf_vma = 0;
            let mut _len_6: libc::c_uint = 0;
            let mut _status_6: libc::c_int = 0;
            _val_6 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_6,
                &mut _status_6,
            );
            p = p.offset(_len_6 as isize);
            val = _val_6 as libc::c_uint;
            if val as libc::c_ulong != _val_6 {
                _status_6 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_6,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17298 as libc::c_int as libc::c_ulong,
            );
            if val == 1 as libc::c_int as libc::c_uint {
                printf(
                    b"  Tag_CSKY_FPU_Exception:\t\0" as *const u8 as *const libc::c_char,
                );
                printf(b"Needed\n\0" as *const u8 as *const libc::c_char);
            }
        }
        21 => {
            printf(
                b"  Tag_CSKY_FPU_NUMBER_MODULE:\t\0" as *const u8 as *const libc::c_char,
            );
            return display_tag_value(-(1 as libc::c_int), p, end);
        }
        22 => {
            printf(b"  Tag_CSKY_FPU_HARDFP:\t\t\0" as *const u8 as *const libc::c_char);
            let mut _val_7: dwarf_vma = 0;
            let mut _len_7: libc::c_uint = 0;
            let mut _status_7: libc::c_int = 0;
            _val_7 = read_leb128(
                p,
                end,
                0 as libc::c_int != 0,
                &mut _len_7,
                &mut _status_7,
            );
            p = p.offset(_len_7 as isize);
            val = _val_7 as libc::c_uint;
            if val as libc::c_ulong != _val_7 {
                _status_7 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_7,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                17309 as libc::c_int as libc::c_ulong,
            );
            if val & VAL_CSKY_FPU_HARDFP_HALF as libc::c_int as libc::c_uint != 0 {
                printf(b" Half\0" as *const u8 as *const libc::c_char);
            }
            if val & VAL_CSKY_FPU_HARDFP_SINGLE as libc::c_int as libc::c_uint != 0 {
                printf(b" Single\0" as *const u8 as *const libc::c_char);
            }
            if val & VAL_CSKY_FPU_HARDFP_DOUBLE as libc::c_int as libc::c_uint != 0 {
                printf(b" Double\0" as *const u8 as *const libc::c_char);
            }
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
        _ => return display_tag_value(tag as libc::c_int, p, end),
    }
    return p;
}
unsafe extern "C" fn process_attributes(
    mut filedata: *mut Filedata,
    mut public_name: *const libc::c_char,
    mut proc_type: libc::c_uint,
    mut display_pub_attribute: Option::<
        unsafe extern "C" fn(
            *mut libc::c_uchar,
            *const libc::c_uchar,
        ) -> *mut libc::c_uchar,
    >,
    mut display_proc_gnu_attribute: Option::<
        unsafe extern "C" fn(
            *mut libc::c_uchar,
            libc::c_uint,
            *const libc::c_uchar,
        ) -> *mut libc::c_uchar,
    >,
) -> bool {
    let mut sect: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_uint = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    i = 0 as libc::c_int as libc::c_uint;
    sect = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum {
        let mut contents: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        if !((*sect).sh_type != proc_type
            && (*sect).sh_type != 0x6ffffff5 as libc::c_int as libc::c_uint)
        {
            contents = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*sect).sh_offset as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                (*sect).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"attributes\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut libc::c_uchar;
            if contents.is_null() {
                res = 0 as libc::c_int != 0;
            } else {
                p = contents;
                if *p as libc::c_int != 'A' as i32 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unknown attributes version '%c'(%d) - expecting 'A'\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        *p as libc::c_int,
                        *p as libc::c_int,
                    );
                    res = 0 as libc::c_int != 0;
                } else {
                    let mut section_len: bfd_vma = 0;
                    section_len = ((*sect).sh_size)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong);
                    p = p.offset(1);
                    p;
                    while section_len > 0 as libc::c_int as libc::c_ulong {
                        let mut attr_len: bfd_vma = 0;
                        let mut namelen: libc::c_uint = 0;
                        let mut public_section: bool = false;
                        let mut gnu_section: bool = false;
                        if section_len <= 4 as libc::c_int as libc::c_ulong {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Tag section ends prematurely\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            res = 0 as libc::c_int != 0;
                            break;
                        } else {
                            attr_len = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(p, 4 as libc::c_int as libc::c_uint);
                            p = p.offset(4 as libc::c_int as isize);
                            if attr_len > section_len {
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Bad attribute length (%u > %u)\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    attr_len as libc::c_uint,
                                    section_len as libc::c_uint,
                                );
                                attr_len = section_len;
                                res = 0 as libc::c_int != 0;
                            } else if attr_len < 5 as libc::c_int as libc::c_ulong {
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Attribute length of %u is too small\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    attr_len as libc::c_uint,
                                );
                                res = 0 as libc::c_int != 0;
                                break;
                            }
                            section_len = (section_len as libc::c_ulong)
                                .wrapping_sub(attr_len) as bfd_vma as bfd_vma;
                            attr_len = (attr_len as libc::c_ulong)
                                .wrapping_sub(4 as libc::c_int as libc::c_ulong) as bfd_vma
                                as bfd_vma;
                            namelen = (strnlen(p as *mut libc::c_char, attr_len))
                                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                                as libc::c_uint;
                            if namelen == 0 as libc::c_int as libc::c_uint
                                || namelen as libc::c_ulong >= attr_len
                            {
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Corrupt attribute section name\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                res = 0 as libc::c_int != 0;
                                break;
                            } else {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Attribute Section: \0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                print_symbol(
                                    2147483647 as libc::c_int,
                                    p as *const libc::c_char,
                                );
                                putchar('\n' as i32);
                                if !public_name.is_null()
                                    && strcmp(p as *mut libc::c_char, public_name)
                                        == 0 as libc::c_int
                                {
                                    public_section = 1 as libc::c_int != 0;
                                } else {
                                    public_section = 0 as libc::c_int != 0;
                                }
                                if strcmp(
                                    p as *mut libc::c_char,
                                    b"gnu\0" as *const u8 as *const libc::c_char,
                                ) == 0 as libc::c_int
                                {
                                    gnu_section = 1 as libc::c_int != 0;
                                } else {
                                    gnu_section = 0 as libc::c_int != 0;
                                }
                                p = p.offset(namelen as isize);
                                attr_len = (attr_len as libc::c_ulong)
                                    .wrapping_sub(namelen as libc::c_ulong) as bfd_vma
                                    as bfd_vma;
                                while attr_len > 0 as libc::c_int as libc::c_ulong
                                    && p < contents.offset((*sect).sh_size as isize)
                                {
                                    let mut tag: libc::c_int = 0;
                                    let mut val: libc::c_uint = 0;
                                    let mut size: bfd_vma = 0;
                                    let mut end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                                    if attr_len < 6 as libc::c_int as libc::c_ulong {
                                        error(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"Unused bytes at end of section\n\0" as *const u8
                                                    as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                        );
                                        res = 0 as libc::c_int != 0;
                                        section_len = 0 as libc::c_int as bfd_vma;
                                        break;
                                    } else {
                                        let fresh42 = p;
                                        p = p.offset(1);
                                        tag = *fresh42 as libc::c_int;
                                        size = byte_get
                                            .expect(
                                                "non-null function pointer",
                                            )(p, 4 as libc::c_int as libc::c_uint);
                                        if size > attr_len {
                                            error(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"Bad subsection length (%u > %u)\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                size as libc::c_uint,
                                                attr_len as libc::c_uint,
                                            );
                                            res = 0 as libc::c_int != 0;
                                            size = attr_len;
                                        }
                                        if size < 6 as libc::c_int as libc::c_ulong {
                                            error(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"Bad subsection length (%u < 6)\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                size as libc::c_uint,
                                            );
                                            res = 0 as libc::c_int != 0;
                                            section_len = 0 as libc::c_int as bfd_vma;
                                            break;
                                        } else {
                                            attr_len = (attr_len as libc::c_ulong).wrapping_sub(size)
                                                as bfd_vma as bfd_vma;
                                            end = p
                                                .offset(size as isize)
                                                .offset(-(1 as libc::c_int as isize));
                                            if end <= contents.offset((*sect).sh_size as isize)
                                            {} else {
                                                __assert_fail(
                                                    b"end <= contents + sect->sh_size\0" as *const u8
                                                        as *const libc::c_char,
                                                    b"readelf.c\0" as *const u8 as *const libc::c_char,
                                                    17465 as libc::c_int as libc::c_uint,
                                                    (*::core::mem::transmute::<
                                                        &[u8; 209],
                                                        &[libc::c_char; 209],
                                                    >(
                                                        b"_Bool process_attributes(Filedata *, const char *, unsigned int, unsigned char *(*)(unsigned char *, const unsigned char *const), unsigned char *(*)(unsigned char *, unsigned int, const unsigned char *const))\0",
                                                    ))
                                                        .as_ptr(),
                                                );
                                            }
                                            'c_130399: {
                                                if end <= contents.offset((*sect).sh_size as isize)
                                                {} else {
                                                    __assert_fail(
                                                        b"end <= contents + sect->sh_size\0" as *const u8
                                                            as *const libc::c_char,
                                                        b"readelf.c\0" as *const u8 as *const libc::c_char,
                                                        17465 as libc::c_int as libc::c_uint,
                                                        (*::core::mem::transmute::<
                                                            &[u8; 209],
                                                            &[libc::c_char; 209],
                                                        >(
                                                            b"_Bool process_attributes(Filedata *, const char *, unsigned int, unsigned char *(*)(unsigned char *, const unsigned char *const), unsigned char *(*)(unsigned char *, unsigned int, const unsigned char *const))\0",
                                                        ))
                                                            .as_ptr(),
                                                    );
                                                }
                                            };
                                            p = p.offset(4 as libc::c_int as isize);
                                            let mut current_block_67: u64;
                                            match tag {
                                                1 => {
                                                    printf(
                                                        dcgettext(
                                                            0 as *const libc::c_char,
                                                            b"File Attributes\n\0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                    );
                                                    current_block_67 = 7419121793134201633;
                                                }
                                                2 => {
                                                    printf(
                                                        dcgettext(
                                                            0 as *const libc::c_char,
                                                            b"Section Attributes:\0" as *const u8
                                                                as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                    );
                                                    current_block_67 = 12444046981960701140;
                                                }
                                                3 => {
                                                    printf(
                                                        dcgettext(
                                                            0 as *const libc::c_char,
                                                            b"Symbol Attributes:\0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                    );
                                                    current_block_67 = 12444046981960701140;
                                                }
                                                _ => {
                                                    printf(
                                                        dcgettext(
                                                            0 as *const libc::c_char,
                                                            b"Unknown tag: %d\n\0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                        tag,
                                                    );
                                                    public_section = 0 as libc::c_int != 0;
                                                    current_block_67 = 7419121793134201633;
                                                }
                                            }
                                            match current_block_67 {
                                                12444046981960701140 => {
                                                    loop {
                                                        let mut _val: dwarf_vma = 0;
                                                        let mut _len: libc::c_uint = 0;
                                                        let mut _status: libc::c_int = 0;
                                                        _val = read_leb128(
                                                            p,
                                                            end,
                                                            0 as libc::c_int != 0,
                                                            &mut _len,
                                                            &mut _status,
                                                        );
                                                        p = p.offset(_len as isize);
                                                        val = _val as libc::c_uint;
                                                        if val as libc::c_ulong != _val {
                                                            _status |= 2 as libc::c_int;
                                                        }
                                                        report_leb_status(
                                                            _status,
                                                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                                                            17482 as libc::c_int as libc::c_ulong,
                                                        );
                                                        if val == 0 as libc::c_int as libc::c_uint {
                                                            break;
                                                        }
                                                        printf(b" %d\0" as *const u8 as *const libc::c_char, val);
                                                    }
                                                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                                                }
                                                _ => {}
                                            }
                                            if public_section as libc::c_int != 0
                                                && display_pub_attribute.is_some()
                                            {
                                                while p < end {
                                                    p = display_pub_attribute
                                                        .expect("non-null function pointer")(p, end);
                                                }
                                                if p == end {} else {
                                                    __assert_fail(
                                                        b"p == end\0" as *const u8 as *const libc::c_char,
                                                        b"readelf.c\0" as *const u8 as *const libc::c_char,
                                                        17499 as libc::c_int as libc::c_uint,
                                                        (*::core::mem::transmute::<
                                                            &[u8; 209],
                                                            &[libc::c_char; 209],
                                                        >(
                                                            b"_Bool process_attributes(Filedata *, const char *, unsigned int, unsigned char *(*)(unsigned char *, const unsigned char *const), unsigned char *(*)(unsigned char *, unsigned int, const unsigned char *const))\0",
                                                        ))
                                                            .as_ptr(),
                                                    );
                                                }
                                                'c_130161: {
                                                    if p == end {} else {
                                                        __assert_fail(
                                                            b"p == end\0" as *const u8 as *const libc::c_char,
                                                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                                                            17499 as libc::c_int as libc::c_uint,
                                                            (*::core::mem::transmute::<
                                                                &[u8; 209],
                                                                &[libc::c_char; 209],
                                                            >(
                                                                b"_Bool process_attributes(Filedata *, const char *, unsigned int, unsigned char *(*)(unsigned char *, const unsigned char *const), unsigned char *(*)(unsigned char *, unsigned int, const unsigned char *const))\0",
                                                            ))
                                                                .as_ptr(),
                                                        );
                                                    }
                                                };
                                            } else if gnu_section as libc::c_int != 0
                                                && display_proc_gnu_attribute.is_some()
                                            {
                                                while p < end {
                                                    p = display_gnu_attribute(
                                                        p,
                                                        display_proc_gnu_attribute,
                                                        end,
                                                    );
                                                }
                                                if p == end {} else {
                                                    __assert_fail(
                                                        b"p == end\0" as *const u8 as *const libc::c_char,
                                                        b"readelf.c\0" as *const u8 as *const libc::c_char,
                                                        17507 as libc::c_int as libc::c_uint,
                                                        (*::core::mem::transmute::<
                                                            &[u8; 209],
                                                            &[libc::c_char; 209],
                                                        >(
                                                            b"_Bool process_attributes(Filedata *, const char *, unsigned int, unsigned char *(*)(unsigned char *, const unsigned char *const), unsigned char *(*)(unsigned char *, unsigned int, const unsigned char *const))\0",
                                                        ))
                                                            .as_ptr(),
                                                    );
                                                }
                                                'c_130090: {
                                                    if p == end {} else {
                                                        __assert_fail(
                                                            b"p == end\0" as *const u8 as *const libc::c_char,
                                                            b"readelf.c\0" as *const u8 as *const libc::c_char,
                                                            17507 as libc::c_int as libc::c_uint,
                                                            (*::core::mem::transmute::<
                                                                &[u8; 209],
                                                                &[libc::c_char; 209],
                                                            >(
                                                                b"_Bool process_attributes(Filedata *, const char *, unsigned int, unsigned char *(*)(unsigned char *, const unsigned char *const), unsigned char *(*)(unsigned char *, unsigned int, const unsigned char *const))\0",
                                                            ))
                                                                .as_ptr(),
                                                        );
                                                    }
                                                };
                                            } else if p < end {
                                                printf(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"  Unknown attribute:\n\0" as *const u8
                                                            as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                );
                                                display_raw_attribute(p, end);
                                                p = end;
                                            } else {
                                                attr_len = 0 as libc::c_int as bfd_vma;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                free(contents as *mut libc::c_void);
            }
        }
        i = i.wrapping_add(1);
        i;
        sect = sect.offset(1);
        sect;
    }
    return res;
}
unsafe extern "C" fn print_mips_got_entry(
    mut data: *mut libc::c_uchar,
    mut pltgot: bfd_vma,
    mut addr: bfd_vma,
    mut data_end: *mut libc::c_uchar,
) -> bfd_vma {
    printf(b"  \0" as *const u8 as *const libc::c_char);
    print_vma(addr, LONG_HEX);
    printf(b" \0" as *const u8 as *const libc::c_char);
    if addr < pltgot.wrapping_add(0xfff0 as libc::c_int as libc::c_ulong) {
        printf(
            b"%6d(gp)\0" as *const u8 as *const libc::c_char,
            addr
                .wrapping_sub(pltgot)
                .wrapping_sub(0x7ff0 as libc::c_int as libc::c_ulong) as libc::c_int,
        );
    } else {
        printf(
            b"%10s\0" as *const u8 as *const libc::c_char,
            b"\0" as *const u8 as *const libc::c_char,
        );
    }
    printf(b" \0" as *const u8 as *const libc::c_char);
    if data.is_null() {
        printf(
            b"%*s\0" as *const u8 as *const libc::c_char,
            if is_32bit_elf as libc::c_int != 0 {
                8 as libc::c_int
            } else {
                16 as libc::c_int
            },
            dcgettext(
                0 as *const libc::c_char,
                b"<unknown>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else {
        let mut entry: bfd_vma = 0;
        let mut from: *mut libc::c_uchar = data
            .offset(addr as isize)
            .offset(-(pltgot as isize));
        if from
            .offset(
                (if is_32bit_elf as libc::c_int != 0 {
                    4 as libc::c_int
                } else {
                    8 as libc::c_int
                }) as isize,
            ) > data_end
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"MIPS GOT entry extends beyond the end of available data\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                b"%*s\0" as *const u8 as *const libc::c_char,
                if is_32bit_elf as libc::c_int != 0 {
                    8 as libc::c_int
                } else {
                    16 as libc::c_int
                },
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return -(1 as libc::c_int) as bfd_vma;
        } else {
            entry = byte_get
                .expect(
                    "non-null function pointer",
                )(
                data.offset(addr as isize).offset(-(pltgot as isize)),
                (if is_32bit_elf as libc::c_int != 0 {
                    4 as libc::c_int
                } else {
                    8 as libc::c_int
                }) as libc::c_uint,
            );
            print_vma(entry, LONG_HEX);
        }
    }
    return addr
        .wrapping_add(
            (if is_32bit_elf as libc::c_int != 0 {
                4 as libc::c_int
            } else {
                8 as libc::c_int
            }) as libc::c_ulong,
        );
}
unsafe extern "C" fn print_mips_pltgot_entry(
    mut data: *mut libc::c_uchar,
    mut pltgot: bfd_vma,
    mut addr: bfd_vma,
) -> bfd_vma {
    printf(b"  \0" as *const u8 as *const libc::c_char);
    print_vma(addr, LONG_HEX);
    printf(b" \0" as *const u8 as *const libc::c_char);
    if data.is_null() {
        printf(
            b"%*s\0" as *const u8 as *const libc::c_char,
            if is_32bit_elf as libc::c_int != 0 {
                8 as libc::c_int
            } else {
                16 as libc::c_int
            },
            dcgettext(
                0 as *const libc::c_char,
                b"<unknown>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else {
        let mut entry: bfd_vma = 0;
        entry = byte_get
            .expect(
                "non-null function pointer",
            )(
            data.offset(addr as isize).offset(-(pltgot as isize)),
            (if is_32bit_elf as libc::c_int != 0 {
                4 as libc::c_int
            } else {
                8 as libc::c_int
            }) as libc::c_uint,
        );
        print_vma(entry, LONG_HEX);
    }
    return addr
        .wrapping_add(
            (if is_32bit_elf as libc::c_int != 0 {
                4 as libc::c_int
            } else {
                8 as libc::c_int
            }) as libc::c_ulong,
        );
}
unsafe extern "C" fn print_mips_ases(mut mask: libc::c_uint) {
    if mask & 0x1 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tDSP ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x2 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tDSP R2 ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x2000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tDSP R3 ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x4 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tEnhanced VA Scheme\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x8 as libc::c_int as libc::c_uint != 0 {
        fputs(
            b"\n\tMCU (MicroController) ASE\0" as *const u8 as *const libc::c_char,
            stdout,
        );
    }
    if mask & 0x10 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tMDMX ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x20 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tMIPS-3D ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x40 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tMT ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x80 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tSmartMIPS ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x100 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tVZ ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x200 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tMSA ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x400 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tMIPS16 ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x800 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tMICROMIPS ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x1000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tXPA ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x4000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tMIPS16e2 ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x8000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tCRC ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x20000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tGINV ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x40000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tLoongson MMI ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x80000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tLoongson CAM ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x100000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tLoongson EXT ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask & 0x200000 as libc::c_int as libc::c_uint != 0 {
        fputs(b"\n\tLoongson EXT2 ASE\0" as *const u8 as *const libc::c_char, stdout);
    }
    if mask == 0 as libc::c_int as libc::c_uint {
        fprintf(
            stdout,
            b"\n\t%s\0" as *const u8 as *const libc::c_char,
            dcgettext(
                0 as *const libc::c_char,
                b"None\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else if mask & !(0x3effff as libc::c_int) as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        fprintf(
            stdout,
            b"\n\t%s (%x)\0" as *const u8 as *const libc::c_char,
            dcgettext(
                0 as *const libc::c_char,
                b"Unknown\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            mask & !(0x3effff as libc::c_int) as libc::c_uint,
        );
    }
}
unsafe extern "C" fn print_mips_isa_ext(mut isa_ext: libc::c_uint) {
    match isa_ext {
        0 => {
            fputs(
                dcgettext(
                    0 as *const libc::c_char,
                    b"None\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                stdout,
            );
        }
        1 => {
            fputs(b"RMI XLR\0" as *const u8 as *const libc::c_char, stdout);
        }
        19 => {
            fputs(
                b"Cavium Networks Octeon3\0" as *const u8 as *const libc::c_char,
                stdout,
            );
        }
        2 => {
            fputs(
                b"Cavium Networks Octeon2\0" as *const u8 as *const libc::c_char,
                stdout,
            );
        }
        3 => {
            fputs(
                b"Cavium Networks OcteonP\0" as *const u8 as *const libc::c_char,
                stdout,
            );
        }
        5 => {
            fputs(
                b"Cavium Networks Octeon\0" as *const u8 as *const libc::c_char,
                stdout,
            );
        }
        6 => {
            fputs(b"Toshiba R5900\0" as *const u8 as *const libc::c_char, stdout);
        }
        7 => {
            fputs(b"MIPS R4650\0" as *const u8 as *const libc::c_char, stdout);
        }
        8 => {
            fputs(b"LSI R4010\0" as *const u8 as *const libc::c_char, stdout);
        }
        9 => {
            fputs(b"NEC VR4100\0" as *const u8 as *const libc::c_char, stdout);
        }
        10 => {
            fputs(b"Toshiba R3900\0" as *const u8 as *const libc::c_char, stdout);
        }
        11 => {
            fputs(b"MIPS R10000\0" as *const u8 as *const libc::c_char, stdout);
        }
        12 => {
            fputs(b"Broadcom SB-1\0" as *const u8 as *const libc::c_char, stdout);
        }
        13 => {
            fputs(b"NEC VR4111/VR4181\0" as *const u8 as *const libc::c_char, stdout);
        }
        14 => {
            fputs(b"NEC VR4120\0" as *const u8 as *const libc::c_char, stdout);
        }
        15 => {
            fputs(b"NEC VR5400\0" as *const u8 as *const libc::c_char, stdout);
        }
        16 => {
            fputs(b"NEC VR5500\0" as *const u8 as *const libc::c_char, stdout);
        }
        17 => {
            fputs(
                b"ST Microelectronics Loongson 2E\0" as *const u8 as *const libc::c_char,
                stdout,
            );
        }
        18 => {
            fputs(
                b"ST Microelectronics Loongson 2F\0" as *const u8 as *const libc::c_char,
                stdout,
            );
        }
        20 => {
            fputs(
                b"Imagination interAptiv MR2\0" as *const u8 as *const libc::c_char,
                stdout,
            );
        }
        _ => {
            fprintf(
                stdout,
                b"%s (%d)\0" as *const u8 as *const libc::c_char,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unknown\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                isa_ext,
            );
        }
    };
}
unsafe extern "C" fn get_mips_reg_size(mut reg_size: libc::c_int) -> libc::c_int {
    return if reg_size == 0 as libc::c_int {
        0 as libc::c_int
    } else if reg_size == 0x1 as libc::c_int {
        32 as libc::c_int
    } else if reg_size == 0x2 as libc::c_int {
        64 as libc::c_int
    } else if reg_size == 0x3 as libc::c_int {
        128 as libc::c_int
    } else {
        -(1 as libc::c_int)
    };
}
unsafe extern "C" fn process_mips_specific(mut filedata: *mut Filedata) -> bool {
    let mut current_block: u64;
    let mut entry: *mut Elf_Internal_Dyn = 0 as *mut Elf_Internal_Dyn;
    let mut sect: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut liblist_offset: size_t = 0 as libc::c_int as size_t;
    let mut liblistno: size_t = 0 as libc::c_int as size_t;
    let mut conflictsno: size_t = 0 as libc::c_int as size_t;
    let mut options_offset: size_t = 0 as libc::c_int as size_t;
    let mut conflicts_offset: size_t = 0 as libc::c_int as size_t;
    let mut pltrelsz: size_t = 0 as libc::c_int as size_t;
    let mut pltrel: size_t = 0 as libc::c_int as size_t;
    let mut pltgot: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut mips_pltgot: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut jmprel: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut local_gotno: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut gotsym: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut symtabno: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut res: bool = 1 as libc::c_int != 0;
    if !process_attributes(
        filedata,
        0 as *const libc::c_char,
        0x6ffffff5 as libc::c_int as libc::c_uint,
        None,
        Some(
            display_mips_gnu_attribute
                as unsafe extern "C" fn(
                    *mut libc::c_uchar,
                    libc::c_uint,
                    *const libc::c_uchar,
                ) -> *mut libc::c_uchar,
        ),
    ) {
        res = 0 as libc::c_int != 0;
    }
    sect = find_section(
        filedata,
        b".MIPS.abiflags\0" as *const u8 as *const libc::c_char,
    );
    if !sect.is_null() {
        let mut abiflags_ext: *mut Elf_External_ABIFlags_v0 = 0
            as *mut Elf_External_ABIFlags_v0;
        let mut abiflags_in: Elf_Internal_ABIFlags_v0 = Elf_Internal_ABIFlags_v0 {
            version: 0,
            isa_level: 0,
            isa_rev: 0,
            gpr_size: 0,
            cpr1_size: 0,
            cpr2_size: 0,
            fp_abi: 0,
            isa_ext: 0,
            ases: 0,
            flags1: 0,
            flags2: 0,
        };
        if ::core::mem::size_of::<Elf_External_ABIFlags_v0>() as libc::c_ulong
            != (*sect).sh_size
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Corrupt MIPS ABI Flags section.\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            res = 0 as libc::c_int != 0;
        } else {
            abiflags_ext = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*sect).sh_offset as libc::c_ulong,
                1 as libc::c_int as bfd_size_type,
                (*sect).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"MIPS ABI Flags section\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut Elf_External_ABIFlags_v0;
            if !abiflags_ext.is_null() {
                abiflags_in
                    .version = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).version).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_ushort;
                abiflags_in
                    .isa_level = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).isa_level).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_uchar;
                abiflags_in
                    .isa_rev = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).isa_rev).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_uchar;
                abiflags_in
                    .gpr_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).gpr_size).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_uchar;
                abiflags_in
                    .cpr1_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).cpr1_size).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_uchar;
                abiflags_in
                    .cpr2_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).cpr2_size).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_uchar;
                abiflags_in
                    .fp_abi = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).fp_abi).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_uchar;
                abiflags_in
                    .isa_ext = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).isa_ext).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                abiflags_in
                    .ases = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).ases).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                abiflags_in
                    .flags1 = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).flags1).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                abiflags_in
                    .flags2 = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*abiflags_ext).flags2).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                printf(
                    b"\nMIPS ABI Flags Version: %d\n\0" as *const u8
                        as *const libc::c_char,
                    abiflags_in.version as libc::c_int,
                );
                printf(
                    b"\nISA: MIPS%d\0" as *const u8 as *const libc::c_char,
                    abiflags_in.isa_level as libc::c_int,
                );
                if abiflags_in.isa_rev as libc::c_int > 1 as libc::c_int {
                    printf(
                        b"r%d\0" as *const u8 as *const libc::c_char,
                        abiflags_in.isa_rev as libc::c_int,
                    );
                }
                printf(
                    b"\nGPR size: %d\0" as *const u8 as *const libc::c_char,
                    get_mips_reg_size(abiflags_in.gpr_size as libc::c_int),
                );
                printf(
                    b"\nCPR1 size: %d\0" as *const u8 as *const libc::c_char,
                    get_mips_reg_size(abiflags_in.cpr1_size as libc::c_int),
                );
                printf(
                    b"\nCPR2 size: %d\0" as *const u8 as *const libc::c_char,
                    get_mips_reg_size(abiflags_in.cpr2_size as libc::c_int),
                );
                fputs(b"\nFP ABI: \0" as *const u8 as *const libc::c_char, stdout);
                print_mips_fp_abi_value(abiflags_in.fp_abi as libc::c_uint);
                fputs(b"ISA Extension: \0" as *const u8 as *const libc::c_char, stdout);
                print_mips_isa_ext(abiflags_in.isa_ext as libc::c_uint);
                fputs(b"\nASEs:\0" as *const u8 as *const libc::c_char, stdout);
                print_mips_ases(abiflags_in.ases as libc::c_uint);
                printf(
                    b"\nFLAGS 1: %8.8lx\0" as *const u8 as *const libc::c_char,
                    abiflags_in.flags1,
                );
                printf(
                    b"\nFLAGS 2: %8.8lx\0" as *const u8 as *const libc::c_char,
                    abiflags_in.flags2,
                );
                fputc('\n' as i32, stdout);
                free(abiflags_ext as *mut libc::c_void);
            }
        }
    }
    if ((*filedata).dynamic_section).is_null() {
        sect = find_section(filedata, b".got\0" as *const u8 as *const libc::c_char);
        if !sect.is_null() {
            let mut data_end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut ent: bfd_vma = 0;
            let mut end: bfd_vma = 0;
            let mut addr_size: libc::c_int = 0;
            pltgot = (*sect).sh_addr;
            ent = pltgot;
            addr_size = if is_32bit_elf as libc::c_int != 0 {
                4 as libc::c_int
            } else {
                8 as libc::c_int
            };
            end = pltgot.wrapping_add((*sect).sh_size);
            data = get_data(
                0 as *mut libc::c_void,
                filedata,
                (*sect).sh_offset as libc::c_ulong,
                end.wrapping_sub(pltgot),
                1 as libc::c_int as bfd_size_type,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Global Offset Table data\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut libc::c_uchar;
            data_end = data.offset(end.wrapping_sub(pltgot) as isize);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nStatic GOT:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Canonical gp value: \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            print_vma(
                ent.wrapping_add(0x7ff0 as libc::c_int as libc::c_ulong),
                LONG_HEX,
            );
            printf(b"\n\n\0" as *const u8 as *const libc::c_char);
            if !data.is_null()
                && data
                    .offset(ent as isize)
                    .offset(-(pltgot as isize))
                    .offset(addr_size as isize) <= data_end
                && byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    data.offset(ent as isize).offset(-(pltgot as isize)),
                    addr_size as libc::c_uint,
                ) == 0 as libc::c_int as libc::c_ulong
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" Reserved entries:\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  %*s %10s %*s\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    addr_size * 2 as libc::c_int,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Address\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Access\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    addr_size * 2 as libc::c_int,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Value\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                ent = print_mips_got_entry(data, pltgot, ent, data_end);
                printf(b"\n\0" as *const u8 as *const libc::c_char);
                if ent == -(1 as libc::c_int) as bfd_vma {
                    current_block = 7209543634050581677;
                } else {
                    if !data.is_null()
                        && data
                            .offset(ent as isize)
                            .offset(-(pltgot as isize))
                            .offset(addr_size as isize) <= data_end
                        && byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            data.offset(ent as isize).offset(-(pltgot as isize)),
                            addr_size as libc::c_uint,
                        ) >> addr_size * 8 as libc::c_int - 1 as libc::c_int
                            != 0 as libc::c_int as libc::c_ulong
                    {
                        ent = print_mips_got_entry(data, pltgot, ent, data_end);
                        printf(b"\n\0" as *const u8 as *const libc::c_char);
                        if ent == -(1 as libc::c_int) as bfd_vma {
                            current_block = 7209543634050581677;
                        } else {
                            current_block = 10095721787123848864;
                        }
                    } else {
                        current_block = 10095721787123848864;
                    }
                    match current_block {
                        7209543634050581677 => {}
                        _ => {
                            printf(b"\n\0" as *const u8 as *const libc::c_char);
                            current_block = 13826291924415791078;
                        }
                    }
                }
            } else {
                current_block = 13826291924415791078;
            }
            match current_block {
                13826291924415791078 => {
                    if !data.is_null() && ent < end {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" Local entries:\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        printf(
                            b"  %*s %10s %*s\n\0" as *const u8 as *const libc::c_char,
                            addr_size * 2 as libc::c_int,
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Address\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Access\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            addr_size * 2 as libc::c_int,
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Value\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        loop {
                            if !(ent < end) {
                                current_block = 9859671972921157070;
                                break;
                            }
                            ent = print_mips_got_entry(data, pltgot, ent, data_end);
                            printf(b"\n\0" as *const u8 as *const libc::c_char);
                            if ent == -(1 as libc::c_int) as bfd_vma {
                                current_block = 7209543634050581677;
                                break;
                            }
                        }
                        match current_block {
                            7209543634050581677 => {}
                            _ => {
                                printf(b"\n\0" as *const u8 as *const libc::c_char);
                            }
                        }
                    }
                }
                _ => {}
            }
            free(data as *mut libc::c_void);
        }
        return res;
    } else {
        entry = (*filedata).dynamic_section;
        while entry
            < ((*filedata).dynamic_section).offset((*filedata).dynamic_nent as isize)
            && (*entry).d_tag != 0 as libc::c_int as libc::c_ulong
        {
            match (*entry).d_tag {
                1879048201 => {
                    liblist_offset = offset_from_vma(
                        filedata,
                        (*entry).d_un.d_val,
                        liblistno
                            .wrapping_mul(
                                ::core::mem::size_of::<Elf32_External_Lib>()
                                    as libc::c_ulong,
                            ),
                    ) as size_t;
                }
                1879048208 => {
                    liblistno = (*entry).d_un.d_val;
                }
                1879048233 => {
                    options_offset = offset_from_vma(
                        filedata,
                        (*entry).d_un.d_val,
                        0 as libc::c_int as bfd_size_type,
                    ) as size_t;
                }
                1879048200 => {
                    conflicts_offset = offset_from_vma(
                        filedata,
                        (*entry).d_un.d_val,
                        conflictsno
                            .wrapping_mul(
                                ::core::mem::size_of::<Elf32_External_Conflict>()
                                    as libc::c_ulong,
                            ),
                    ) as size_t;
                }
                1879048203 => {
                    conflictsno = (*entry).d_un.d_val;
                }
                3 => {
                    pltgot = (*entry).d_un.d_ptr;
                }
                1879048202 => {
                    local_gotno = (*entry).d_un.d_val;
                }
                1879048211 => {
                    gotsym = (*entry).d_un.d_val;
                }
                1879048209 => {
                    symtabno = (*entry).d_un.d_val;
                }
                1879048242 => {
                    mips_pltgot = (*entry).d_un.d_ptr;
                }
                20 => {
                    pltrel = (*entry).d_un.d_val;
                }
                2 => {
                    pltrelsz = (*entry).d_un.d_val;
                }
                23 => {
                    jmprel = (*entry).d_un.d_ptr;
                }
                _ => {}
            }
            entry = entry.offset(1);
            entry;
        }
        if liblist_offset != 0 as libc::c_int as libc::c_ulong
            && liblistno != 0 as libc::c_int as libc::c_ulong
            && do_dynamic as libc::c_int != 0
        {
            let mut elib: *mut Elf32_External_Lib = 0 as *mut Elf32_External_Lib;
            let mut cnt: size_t = 0;
            elib = get_data(
                0 as *mut libc::c_void,
                filedata,
                liblist_offset,
                ::core::mem::size_of::<Elf32_External_Lib>() as libc::c_ulong,
                liblistno,
                dcgettext(
                    0 as *const libc::c_char,
                    b"liblist section data\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut Elf32_External_Lib;
            if !elib.is_null() {
                printf(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"\nSection '.liblist' contains %lu entry:\n\0" as *const u8
                            as *const libc::c_char,
                        b"\nSection '.liblist' contains %lu entries:\n\0" as *const u8
                            as *const libc::c_char,
                        liblistno,
                        5 as libc::c_int,
                    ),
                    liblistno,
                );
                fputs(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"     Library              Time Stamp          Checksum   Version Flags\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    stdout,
                );
                cnt = 0 as libc::c_int as size_t;
                while cnt < liblistno {
                    let mut liblist: Elf32_Lib = Elf32_Lib {
                        l_name: 0,
                        l_time_stamp: 0,
                        l_checksum: 0,
                        l_version: 0,
                        l_flags: 0,
                    };
                    let mut atime: time_t = 0;
                    let mut timebuf: [libc::c_char; 128] = [0; 128];
                    let mut tmp: *mut tm = 0 as *mut tm;
                    liblist
                        .l_name = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*elib.offset(cnt as isize)).l_name).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                            as libc::c_uint,
                    );
                    atime = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*elib.offset(cnt as isize)).l_time_stamp).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                            as libc::c_uint,
                    ) as time_t;
                    liblist
                        .l_checksum = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*elib.offset(cnt as isize)).l_checksum).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                            as libc::c_uint,
                    );
                    liblist
                        .l_version = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*elib.offset(cnt as isize)).l_version).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                            as libc::c_uint,
                    );
                    liblist
                        .l_flags = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*elib.offset(cnt as isize)).l_flags).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                            as libc::c_uint,
                    );
                    tmp = gmtime(&mut atime);
                    snprintf(
                        timebuf.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
                        b"%04u-%02u-%02uT%02u:%02u:%02u\0" as *const u8
                            as *const libc::c_char,
                        (*tmp).tm_year + 1900 as libc::c_int,
                        (*tmp).tm_mon + 1 as libc::c_int,
                        (*tmp).tm_mday,
                        (*tmp).tm_hour,
                        (*tmp).tm_min,
                        (*tmp).tm_sec,
                    );
                    printf(b"%3lu: \0" as *const u8 as *const libc::c_char, cnt);
                    if !((*filedata).dynamic_strings).is_null()
                        && liblist.l_name < (*filedata).dynamic_strings_length
                    {
                        print_symbol(
                            20 as libc::c_int,
                            ((*filedata).dynamic_strings).offset(liblist.l_name as isize),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"<corrupt: %9ld>\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            liblist.l_name,
                        );
                    }
                    printf(
                        b" %s %#10lx %-7ld\0" as *const u8 as *const libc::c_char,
                        timebuf.as_mut_ptr(),
                        liblist.l_checksum,
                        liblist.l_version,
                    );
                    if liblist.l_flags == 0 as libc::c_int as libc::c_ulong {
                        puts(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" NONE\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        static mut l_flags_vals: [C2RustUnnamed_32; 6] = [
                            {
                                let mut init = C2RustUnnamed_32 {
                                    name: b" EXACT_MATCH\0" as *const u8 as *const libc::c_char,
                                    bit: 0x1 as libc::c_int,
                                };
                                init
                            },
                            {
                                let mut init = C2RustUnnamed_32 {
                                    name: b" IGNORE_INT_VER\0" as *const u8
                                        as *const libc::c_char,
                                    bit: 0x2 as libc::c_int,
                                };
                                init
                            },
                            {
                                let mut init = C2RustUnnamed_32 {
                                    name: b" REQUIRE_MINOR\0" as *const u8
                                        as *const libc::c_char,
                                    bit: 0x4 as libc::c_int,
                                };
                                init
                            },
                            {
                                let mut init = C2RustUnnamed_32 {
                                    name: b" EXPORTS\0" as *const u8 as *const libc::c_char,
                                    bit: 0x8 as libc::c_int,
                                };
                                init
                            },
                            {
                                let mut init = C2RustUnnamed_32 {
                                    name: b" DELAY_LOAD\0" as *const u8 as *const libc::c_char,
                                    bit: 0x10 as libc::c_int,
                                };
                                init
                            },
                            {
                                let mut init = C2RustUnnamed_32 {
                                    name: b" DELTA\0" as *const u8 as *const libc::c_char,
                                    bit: 0x20 as libc::c_int,
                                };
                                init
                            },
                        ];
                        let mut flags_0: libc::c_int = liblist.l_flags as libc::c_int;
                        let mut fcnt: size_t = 0;
                        fcnt = 0 as libc::c_int as size_t;
                        while fcnt
                            < (::core::mem::size_of::<[C2RustUnnamed_32; 6]>()
                                as libc::c_ulong)
                                .wrapping_div(
                                    ::core::mem::size_of::<C2RustUnnamed_32>() as libc::c_ulong,
                                )
                        {
                            if flags_0 & l_flags_vals[fcnt as usize].bit
                                != 0 as libc::c_int
                            {
                                fputs(l_flags_vals[fcnt as usize].name, stdout);
                                flags_0 ^= l_flags_vals[fcnt as usize].bit;
                            }
                            fcnt = fcnt.wrapping_add(1);
                            fcnt;
                        }
                        if flags_0 != 0 as libc::c_int {
                            printf(
                                b" %#x\0" as *const u8 as *const libc::c_char,
                                flags_0 as libc::c_uint,
                            );
                        }
                        puts(b"\0" as *const u8 as *const libc::c_char);
                    }
                    cnt = cnt.wrapping_add(1);
                    cnt;
                }
                free(elib as *mut libc::c_void);
            } else {
                res = 0 as libc::c_int != 0;
            }
        }
        if options_offset != 0 as libc::c_int as libc::c_ulong {
            let mut eopt: *mut Elf_External_Options = 0 as *mut Elf_External_Options;
            let mut offset: size_t = 0;
            let mut cnt_0: libc::c_int = 0;
            sect = (*filedata).section_headers;
            sect = find_section_by_type(
                filedata,
                0x7000000d as libc::c_int as libc::c_uint,
            );
            if sect.is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"No MIPS_OPTIONS header found\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            if (*sect).sh_size
                < ::core::mem::size_of::<Elf_External_Options>() as libc::c_ulong
            {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"The MIPS options section is too small.\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            eopt = get_data(
                0 as *mut libc::c_void,
                filedata,
                options_offset,
                1 as libc::c_int as bfd_size_type,
                (*sect).sh_size,
                dcgettext(
                    0 as *const libc::c_char,
                    b"options\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut Elf_External_Options;
            if !eopt.is_null() {
                let mut option: Elf_Internal_Options = Elf_Internal_Options {
                    kind: 0,
                    size: 0,
                    section: 0,
                    info: 0,
                };
                cnt_0 = 0 as libc::c_int;
                offset = cnt_0 as size_t;
                while offset
                    <= ((*sect).sh_size)
                        .wrapping_sub(
                            ::core::mem::size_of::<Elf_External_Options>()
                                as libc::c_ulong,
                        )
                {
                    let mut eoption: *mut Elf_External_Options = 0
                        as *mut Elf_External_Options;
                    let mut optsize: libc::c_uint = 0;
                    eoption = (eopt as *mut libc::c_char).offset(offset as isize)
                        as *mut Elf_External_Options;
                    optsize = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*eoption).size).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                            as libc::c_uint,
                    ) as libc::c_uint;
                    if (optsize as libc::c_ulong)
                        < ::core::mem::size_of::<Elf_External_Options>() as libc::c_ulong
                        || optsize as libc::c_ulong
                            > ((*sect).sh_size).wrapping_sub(offset)
                    {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Invalid size (%u) for MIPS option\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            optsize,
                        );
                        free(eopt as *mut libc::c_void);
                        return 0 as libc::c_int != 0;
                    }
                    offset = (offset as libc::c_ulong)
                        .wrapping_add(optsize as libc::c_ulong) as size_t as size_t;
                    cnt_0 += 1;
                    cnt_0;
                }
                printf(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"\nSection '%s' contains %d entry:\n\0" as *const u8
                            as *const libc::c_char,
                        b"\nSection '%s' contains %d entries:\n\0" as *const u8
                            as *const libc::c_char,
                        cnt_0 as libc::c_ulong,
                        5 as libc::c_int,
                    ),
                    printable_section_name(filedata, sect),
                    cnt_0,
                );
                offset = 0 as libc::c_int as size_t;
                let mut current_block_227: u64;
                loop {
                    let fresh43 = cnt_0;
                    cnt_0 = cnt_0 - 1;
                    if !(fresh43 > 0 as libc::c_int) {
                        break;
                    }
                    let mut len: size_t = 0;
                    let mut eoption_0: *mut Elf_External_Options = 0
                        as *mut Elf_External_Options;
                    eoption_0 = (eopt as *mut libc::c_char).offset(offset as isize)
                        as *mut Elf_External_Options;
                    option
                        .kind = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*eoption_0).kind).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                            as libc::c_uint,
                    ) as libc::c_uchar;
                    option
                        .size = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*eoption_0).size).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 1]>() as libc::c_ulong
                            as libc::c_uint,
                    ) as libc::c_uchar;
                    option
                        .section = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*eoption_0).section).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong
                            as libc::c_uint,
                    ) as uint16_t;
                    option
                        .info = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*eoption_0).info).as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                            as libc::c_uint,
                    ) as uint32_t;
                    match option.kind as libc::c_int {
                        0 => {
                            printf(
                                b" NULL       %d %x\0" as *const u8 as *const libc::c_char,
                                option.section as libc::c_int,
                                option.info,
                            );
                        }
                        1 => {
                            printf(
                                b" REGINFO    \0" as *const u8 as *const libc::c_char,
                            );
                            if (*filedata).file_header.e_machine as libc::c_int
                                == 8 as libc::c_int
                            {
                                let mut ereg: *mut Elf32_External_RegInfo = 0
                                    as *mut Elf32_External_RegInfo;
                                let mut reginfo: Elf32_RegInfo = Elf32_RegInfo {
                                    ri_gprmask: 0,
                                    ri_cprmask: [0; 4],
                                    ri_gp_value: 0,
                                };
                                if (option.size as libc::c_ulong)
                                    < (::core::mem::size_of::<Elf_External_Options>()
                                        as libc::c_ulong)
                                        .wrapping_add(
                                            ::core::mem::size_of::<Elf32_External_RegInfo>()
                                                as libc::c_ulong,
                                        )
                                {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"<corrupt>\n\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Truncated MIPS REGINFO option\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    cnt_0 = 0 as libc::c_int;
                                    current_block_227 = 16167632229894708628;
                                } else {
                                    ereg = eoption_0.offset(1 as libc::c_int as isize)
                                        as *mut Elf32_External_RegInfo;
                                    reginfo
                                        .ri_gprmask = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg).ri_gprmask).as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo
                                        .ri_cprmask[0 as libc::c_int
                                        as usize] = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg).ri_cprmask[0 as libc::c_int as usize])
                                            .as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo
                                        .ri_cprmask[1 as libc::c_int
                                        as usize] = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg).ri_cprmask[1 as libc::c_int as usize])
                                            .as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo
                                        .ri_cprmask[2 as libc::c_int
                                        as usize] = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg).ri_cprmask[2 as libc::c_int as usize])
                                            .as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo
                                        .ri_cprmask[3 as libc::c_int
                                        as usize] = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg).ri_cprmask[3 as libc::c_int as usize])
                                            .as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo
                                        .ri_gp_value = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg).ri_gp_value).as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    printf(
                                        b"GPR %08x  GP 0x%x\n\0" as *const u8
                                            as *const libc::c_char,
                                        reginfo.ri_gprmask,
                                        reginfo.ri_gp_value,
                                    );
                                    printf(
                                        b"            CPR0 %08x  CPR1 %08x  CPR2 %08x  CPR3 %08x\n\0"
                                            as *const u8 as *const libc::c_char,
                                        reginfo.ri_cprmask[0 as libc::c_int as usize],
                                        reginfo.ri_cprmask[1 as libc::c_int as usize],
                                        reginfo.ri_cprmask[2 as libc::c_int as usize],
                                        reginfo.ri_cprmask[3 as libc::c_int as usize],
                                    );
                                    current_block_227 = 15663981557480382173;
                                }
                            } else {
                                let mut ereg_0: *mut Elf64_External_RegInfo = 0
                                    as *mut Elf64_External_RegInfo;
                                let mut reginfo_0: Elf64_Internal_RegInfo = Elf64_Internal_RegInfo {
                                    ri_gprmask: 0,
                                    ri_pad: 0,
                                    ri_cprmask: [0; 4],
                                    ri_gp_value: 0,
                                };
                                if (option.size as libc::c_ulong)
                                    < (::core::mem::size_of::<Elf_External_Options>()
                                        as libc::c_ulong)
                                        .wrapping_add(
                                            ::core::mem::size_of::<Elf64_External_RegInfo>()
                                                as libc::c_ulong,
                                        )
                                {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"<corrupt>\n\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Truncated MIPS REGINFO option\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    cnt_0 = 0 as libc::c_int;
                                    current_block_227 = 16167632229894708628;
                                } else {
                                    ereg_0 = eoption_0.offset(1 as libc::c_int as isize)
                                        as *mut Elf64_External_RegInfo;
                                    reginfo_0
                                        .ri_gprmask = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg_0).ri_gprmask).as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo_0
                                        .ri_cprmask[0 as libc::c_int
                                        as usize] = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg_0).ri_cprmask[0 as libc::c_int as usize])
                                            .as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo_0
                                        .ri_cprmask[1 as libc::c_int
                                        as usize] = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg_0).ri_cprmask[1 as libc::c_int as usize])
                                            .as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo_0
                                        .ri_cprmask[2 as libc::c_int
                                        as usize] = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg_0).ri_cprmask[2 as libc::c_int as usize])
                                            .as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo_0
                                        .ri_cprmask[3 as libc::c_int
                                        as usize] = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg_0).ri_cprmask[3 as libc::c_int as usize])
                                            .as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                            as libc::c_ulong as libc::c_uint,
                                    ) as uint32_t;
                                    reginfo_0
                                        .ri_gp_value = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ((*ereg_0).ri_gp_value).as_mut_ptr(),
                                        ::core::mem::size_of::<[libc::c_uchar; 8]>()
                                            as libc::c_ulong as libc::c_uint,
                                    );
                                    printf(
                                        b"GPR %08x  GP 0x%lx\n\0" as *const u8
                                            as *const libc::c_char,
                                        reginfo_0.ri_gprmask,
                                        reginfo_0.ri_gp_value,
                                    );
                                    printf(
                                        b"            CPR0 %08x  CPR1 %08x  CPR2 %08x  CPR3 %08x\n\0"
                                            as *const u8 as *const libc::c_char,
                                        reginfo_0.ri_cprmask[0 as libc::c_int as usize],
                                        reginfo_0.ri_cprmask[1 as libc::c_int as usize],
                                        reginfo_0.ri_cprmask[2 as libc::c_int as usize],
                                        reginfo_0.ri_cprmask[3 as libc::c_int as usize],
                                    );
                                    current_block_227 = 15663981557480382173;
                                }
                            }
                            match current_block_227 {
                                16167632229894708628 => {}
                                _ => {
                                    offset = (offset as libc::c_ulong)
                                        .wrapping_add(option.size as libc::c_ulong) as size_t
                                        as size_t;
                                    continue;
                                }
                            }
                        }
                        2 => {
                            fputs(
                                b" EXCEPTIONS fpe_min(\0" as *const u8
                                    as *const libc::c_char,
                                stdout,
                            );
                            process_mips_fpe_exception(
                                (option.info & 0x1f as libc::c_int as libc::c_uint)
                                    as libc::c_int,
                            );
                            fputs(
                                b") fpe_max(\0" as *const u8 as *const libc::c_char,
                                stdout,
                            );
                            process_mips_fpe_exception(
                                ((option.info & 0x1f00 as libc::c_int as libc::c_uint)
                                    >> 8 as libc::c_int) as libc::c_int,
                            );
                            fputs(b")\0" as *const u8 as *const libc::c_char, stdout);
                            if option.info & 0x10000 as libc::c_int as libc::c_uint != 0
                            {
                                fputs(
                                    b" PAGE0\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x20000 as libc::c_int as libc::c_uint != 0
                            {
                                fputs(
                                    b" SMM\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x40000 as libc::c_int as libc::c_uint != 0
                            {
                                fputs(
                                    b" FPDBUG\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x80000 as libc::c_int as libc::c_uint != 0
                            {
                                fputs(
                                    b" DISMISS\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                        }
                        3 => {
                            fputs(
                                b" PAD       \0" as *const u8 as *const libc::c_char,
                                stdout,
                            );
                            if option.info & 0x1 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" PREFIX\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x2 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" POSTFIX\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x4 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" SYMBOL\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                        }
                        4 => {
                            fputs(
                                b" HWPATCH   \0" as *const u8 as *const libc::c_char,
                                stdout,
                            );
                            if option.info & 0x1 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" R4KEOP\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x2 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" R8KPFETCH\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x4 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" R5KEOP\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x8 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" R5KCVTL\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                        }
                        5 => {
                            fputs(
                                b" FILL       \0" as *const u8 as *const libc::c_char,
                                stdout,
                            );
                        }
                        6 => {
                            fputs(
                                b" TAGS       \0" as *const u8 as *const libc::c_char,
                                stdout,
                            );
                        }
                        7 => {
                            fputs(
                                b" HWAND     \0" as *const u8 as *const libc::c_char,
                                stdout,
                            );
                            if option.info & 0x1 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" R4KEOP_CHECKED\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x2 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" R4KEOP_CLEAN\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                        }
                        8 => {
                            fputs(
                                b" HWOR      \0" as *const u8 as *const libc::c_char,
                                stdout,
                            );
                            if option.info & 0x1 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" R4KEOP_CHECKED\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                            if option.info & 0x2 as libc::c_int as libc::c_uint != 0 {
                                fputs(
                                    b" R4KEOP_CLEAN\0" as *const u8 as *const libc::c_char,
                                    stdout,
                                );
                            }
                        }
                        9 => {
                            printf(
                                b" GP_GROUP  %#06x  self-contained %#06x\0" as *const u8
                                    as *const libc::c_char,
                                option.info & 0xffff as libc::c_int as libc::c_uint,
                                (option.info & 0xffff0000 as libc::c_uint)
                                    >> 16 as libc::c_int,
                            );
                        }
                        10 => {
                            printf(
                                b" IDENT     %#06x  self-contained %#06x\0" as *const u8
                                    as *const libc::c_char,
                                option.info & 0xffff as libc::c_int as libc::c_uint,
                                (option.info & 0xffff0000 as libc::c_uint)
                                    >> 16 as libc::c_int,
                            );
                        }
                        _ => {
                            printf(
                                b" %3d ???     %d %x\0" as *const u8 as *const libc::c_char,
                                option.kind as libc::c_int,
                                option.section as libc::c_int,
                                option.info,
                            );
                        }
                    }
                    len = ::core::mem::size_of::<Elf_External_Options>()
                        as libc::c_ulong;
                    while len < option.size as libc::c_ulong {
                        let mut datum: libc::c_uchar = *(eoption_0 as *mut libc::c_uchar)
                            .offset(len as isize);
                        if _sch_istable[(datum as libc::c_int & 0xff as libc::c_int)
                            as usize] as libc::c_int
                            & _sch_isprint as libc::c_int as libc::c_ushort
                                as libc::c_int != 0
                        {
                            printf(
                                b"%c\0" as *const u8 as *const libc::c_char,
                                datum as libc::c_int,
                            );
                        } else {
                            printf(
                                b"\\%03o\0" as *const u8 as *const libc::c_char,
                                datum as libc::c_int,
                            );
                        }
                        len = len.wrapping_add(1);
                        len;
                    }
                    fputs(b"\n\0" as *const u8 as *const libc::c_char, stdout);
                    offset = (offset as libc::c_ulong)
                        .wrapping_add(option.size as libc::c_ulong) as size_t as size_t;
                }
                free(eopt as *mut libc::c_void);
            } else {
                res = 0 as libc::c_int != 0;
            }
        }
        if conflicts_offset != 0 as libc::c_int as libc::c_ulong
            && conflictsno != 0 as libc::c_int as libc::c_ulong
        {
            let mut iconf: *mut Elf32_Conflict = 0 as *mut Elf32_Conflict;
            let mut cnt_1: size_t = 0;
            if ((*filedata).dynamic_symbols).is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"conflict list found without a dynamic symbol table\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            if conflictsno
                > ((*filedata).file_size)
                    .wrapping_div(
                        ::core::mem::size_of::<Elf32_Conflict>() as libc::c_ulong,
                    )
            {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Overlarge number of conflicts detected: %lx\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    conflictsno as libc::c_long,
                );
                return 0 as libc::c_int != 0;
            }
            iconf = cmalloc(
                conflictsno,
                ::core::mem::size_of::<Elf32_Conflict>() as libc::c_ulong,
            ) as *mut Elf32_Conflict;
            if iconf.is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Out of memory allocating space for dynamic conflicts\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            if is_32bit_elf {
                let mut econf32: *mut Elf32_External_Conflict = 0
                    as *mut Elf32_External_Conflict;
                econf32 = get_data(
                    0 as *mut libc::c_void,
                    filedata,
                    conflicts_offset,
                    ::core::mem::size_of::<Elf32_External_Conflict>() as libc::c_ulong,
                    conflictsno,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"conflict\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                ) as *mut Elf32_External_Conflict;
                if econf32.is_null() {
                    free(iconf as *mut libc::c_void);
                    return 0 as libc::c_int != 0;
                }
                cnt_1 = 0 as libc::c_int as size_t;
                while cnt_1 < conflictsno {
                    *iconf
                        .offset(
                            cnt_1 as isize,
                        ) = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        (*econf32.offset(cnt_1 as isize)).as_mut_ptr(),
                        ::core::mem::size_of::<Elf32_External_Conflict>()
                            as libc::c_ulong as libc::c_uint,
                    );
                    cnt_1 = cnt_1.wrapping_add(1);
                    cnt_1;
                }
                free(econf32 as *mut libc::c_void);
            } else {
                let mut econf64: *mut Elf64_External_Conflict = 0
                    as *mut Elf64_External_Conflict;
                econf64 = get_data(
                    0 as *mut libc::c_void,
                    filedata,
                    conflicts_offset,
                    ::core::mem::size_of::<Elf64_External_Conflict>() as libc::c_ulong,
                    conflictsno,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"conflict\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                ) as *mut Elf64_External_Conflict;
                if econf64.is_null() {
                    free(iconf as *mut libc::c_void);
                    return 0 as libc::c_int != 0;
                }
                cnt_1 = 0 as libc::c_int as size_t;
                while cnt_1 < conflictsno {
                    *iconf
                        .offset(
                            cnt_1 as isize,
                        ) = byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        (*econf64.offset(cnt_1 as isize)).as_mut_ptr(),
                        ::core::mem::size_of::<Elf64_External_Conflict>()
                            as libc::c_ulong as libc::c_uint,
                    );
                    cnt_1 = cnt_1.wrapping_add(1);
                    cnt_1;
                }
                free(econf64 as *mut libc::c_void);
            }
            printf(
                dcngettext(
                    0 as *const libc::c_char,
                    b"\nSection '.conflict' contains %lu entry:\n\0" as *const u8
                        as *const libc::c_char,
                    b"\nSection '.conflict' contains %lu entries:\n\0" as *const u8
                        as *const libc::c_char,
                    conflictsno,
                    5 as libc::c_int,
                ),
                conflictsno,
            );
            puts(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Num:    Index       Value  Name\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            cnt_1 = 0 as libc::c_int as size_t;
            while cnt_1 < conflictsno {
                printf(
                    b"%5lu: %8lu  \0" as *const u8 as *const libc::c_char,
                    cnt_1,
                    *iconf.offset(cnt_1 as isize),
                );
                if *iconf.offset(cnt_1 as isize) >= (*filedata).num_dynamic_syms {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<corrupt symbol index>\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                } else {
                    let mut psym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
                    psym = &mut *((*filedata).dynamic_symbols)
                        .offset(*iconf.offset(cnt_1 as isize) as isize)
                        as *mut Elf_Internal_Sym;
                    print_vma((*psym).st_value, FULL_HEX);
                    putchar(' ' as i32);
                    if !((*filedata).dynamic_strings).is_null()
                        && (*psym).st_name < (*filedata).dynamic_strings_length
                    {
                        print_symbol(
                            25 as libc::c_int,
                            ((*filedata).dynamic_strings)
                                .offset((*psym).st_name as isize),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"<corrupt: %14ld>\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*psym).st_name,
                        );
                    }
                }
                putchar('\n' as i32);
                cnt_1 = cnt_1.wrapping_add(1);
                cnt_1;
            }
            free(iconf as *mut libc::c_void);
        }
        if pltgot != 0 as libc::c_int as libc::c_ulong
            && local_gotno != 0 as libc::c_int as libc::c_ulong
        {
            let mut ent_0: bfd_vma = 0;
            let mut local_end: bfd_vma = 0;
            let mut global_end: bfd_vma = 0;
            let mut i: size_t = 0;
            let mut offset_0: size_t = 0;
            let mut data_0: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut data_end_0: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut addr_size_0: libc::c_int = 0;
            ent_0 = pltgot;
            addr_size_0 = if is_32bit_elf as libc::c_int != 0 {
                4 as libc::c_int
            } else {
                8 as libc::c_int
            };
            local_end = pltgot
                .wrapping_add(local_gotno.wrapping_mul(addr_size_0 as libc::c_ulong));
            if symtabno < gotsym {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    gotsym,
                    symtabno,
                );
                return 0 as libc::c_int != 0;
            }
            global_end = local_end
                .wrapping_add(
                    symtabno
                        .wrapping_sub(gotsym)
                        .wrapping_mul(addr_size_0 as libc::c_ulong),
                );
            if global_end < local_end {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Too many GOT symbols: %lu\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    symtabno,
                );
                return 0 as libc::c_int != 0;
            }
            offset_0 = offset_from_vma(filedata, pltgot, global_end.wrapping_sub(pltgot))
                as size_t;
            data_0 = get_data(
                0 as *mut libc::c_void,
                filedata,
                offset_0,
                global_end.wrapping_sub(pltgot),
                1 as libc::c_int as bfd_size_type,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Global Offset Table data\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut libc::c_uchar;
            data_end_0 = data_0.offset(global_end.wrapping_sub(pltgot) as isize);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\nPrimary GOT:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Canonical gp value: \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            print_vma(
                pltgot.wrapping_add(0x7ff0 as libc::c_int as libc::c_ulong),
                LONG_HEX,
            );
            printf(b"\n\n\0" as *const u8 as *const libc::c_char);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Reserved entries:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  %*s %10s %*s Purpose\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                addr_size_0 * 2 as libc::c_int,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Address\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dcgettext(
                    0 as *const libc::c_char,
                    b"Access\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                addr_size_0 * 2 as libc::c_int,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Initial\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            ent_0 = print_mips_got_entry(data_0, pltgot, ent_0, data_end_0);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Lazy resolver\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            if !(ent_0 == -(1 as libc::c_int) as bfd_vma) {
                if !data_0.is_null()
                    && data_0
                        .offset(ent_0 as isize)
                        .offset(-(pltgot as isize))
                        .offset(addr_size_0 as isize) <= data_end_0
                    && byte_get
                        .expect(
                            "non-null function pointer",
                        )(
                        data_0.offset(ent_0 as isize).offset(-(pltgot as isize)),
                        addr_size_0 as libc::c_uint,
                    ) >> addr_size_0 * 8 as libc::c_int - 1 as libc::c_int
                        != 0 as libc::c_int as libc::c_ulong
                {
                    ent_0 = print_mips_got_entry(data_0, pltgot, ent_0, data_end_0);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" Module pointer (GNU extension)\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    if ent_0 == -(1 as libc::c_int) as bfd_vma {
                        current_block = 10717863679851771302;
                    } else {
                        current_block = 15174492983169363256;
                    }
                } else {
                    current_block = 15174492983169363256;
                }
                match current_block {
                    10717863679851771302 => {}
                    _ => {
                        printf(b"\n\0" as *const u8 as *const libc::c_char);
                        if !data_0.is_null() && ent_0 < local_end {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" Local entries:\n\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            printf(
                                b"  %*s %10s %*s\n\0" as *const u8 as *const libc::c_char,
                                addr_size_0 * 2 as libc::c_int,
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Address\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Access\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                addr_size_0 * 2 as libc::c_int,
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Initial\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            loop {
                                if !(ent_0 < local_end) {
                                    current_block = 17939951368883298147;
                                    break;
                                }
                                ent_0 = print_mips_got_entry(
                                    data_0,
                                    pltgot,
                                    ent_0,
                                    data_end_0,
                                );
                                printf(b"\n\0" as *const u8 as *const libc::c_char);
                                if ent_0 == -(1 as libc::c_int) as bfd_vma {
                                    current_block = 10717863679851771302;
                                    break;
                                }
                            }
                            match current_block {
                                10717863679851771302 => {}
                                _ => {
                                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                                    current_block = 13499557289948866384;
                                }
                            }
                        } else {
                            current_block = 13499557289948866384;
                        }
                        match current_block {
                            10717863679851771302 => {}
                            _ => {
                                if !data_0.is_null() && gotsym < symtabno {
                                    let mut sym_width: libc::c_int = 0;
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" Global entries:\n\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    printf(
                                        b"  %*s %10s %*s %*s %-7s %3s %s\n\0" as *const u8
                                            as *const libc::c_char,
                                        addr_size_0 * 2 as libc::c_int,
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Address\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Access\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        addr_size_0 * 2 as libc::c_int,
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Initial\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        addr_size_0 * 2 as libc::c_int,
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Sym.Val.\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Type\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Ndx\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Name\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    sym_width = (if is_32bit_elf as libc::c_int != 0 {
                                        80 as libc::c_int
                                    } else {
                                        160 as libc::c_int
                                    }) - 28 as libc::c_int - addr_size_0 * 6 as libc::c_int
                                        - 1 as libc::c_int;
                                    i = gotsym;
                                    while i < symtabno {
                                        ent_0 = print_mips_got_entry(
                                            data_0,
                                            pltgot,
                                            ent_0,
                                            data_end_0,
                                        );
                                        printf(b" \0" as *const u8 as *const libc::c_char);
                                        if ((*filedata).dynamic_symbols).is_null() {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"<no dynamic symbols>\0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                            );
                                        } else if i < (*filedata).num_dynamic_syms {
                                            let mut psym_0: *mut Elf_Internal_Sym = ((*filedata)
                                                .dynamic_symbols)
                                                .offset(i as isize);
                                            print_vma((*psym_0).st_value, LONG_HEX);
                                            printf(
                                                b" %-7s %3s \0" as *const u8 as *const libc::c_char,
                                                get_symbol_type(
                                                    filedata,
                                                    ((*psym_0).st_info as libc::c_int & 0xf as libc::c_int)
                                                        as libc::c_uint,
                                                ),
                                                get_symbol_index_type(filedata, (*psym_0).st_shndx),
                                            );
                                            if !((*filedata).dynamic_strings).is_null()
                                                && (*psym_0).st_name < (*filedata).dynamic_strings_length
                                            {
                                                print_symbol(
                                                    sym_width,
                                                    ((*filedata).dynamic_strings)
                                                        .offset((*psym_0).st_name as isize),
                                                );
                                            } else {
                                                printf(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"<corrupt: %14ld>\0" as *const u8 as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    (*psym_0).st_name,
                                                );
                                            }
                                        } else {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"<symbol index %lu exceeds number of dynamic symbols>\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                i,
                                            );
                                        }
                                        printf(b"\n\0" as *const u8 as *const libc::c_char);
                                        if ent_0 == -(1 as libc::c_int) as bfd_vma {
                                            break;
                                        }
                                        i = i.wrapping_add(1);
                                        i;
                                    }
                                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                                }
                            }
                        }
                    }
                }
            }
            free(data_0 as *mut libc::c_void);
        }
        if mips_pltgot != 0 as libc::c_int as libc::c_ulong
            && jmprel != 0 as libc::c_int as libc::c_ulong
            && pltrel != 0 as libc::c_int as libc::c_ulong
            && pltrelsz != 0 as libc::c_int as libc::c_ulong
        {
            let mut ent_1: bfd_vma = 0;
            let mut end_0: bfd_vma = 0;
            let mut offset_1: size_t = 0;
            let mut rel_offset: size_t = 0;
            let mut count: libc::c_ulong = 0;
            let mut i_0: libc::c_ulong = 0;
            let mut data_1: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut addr_size_1: libc::c_int = 0;
            let mut sym_width_0: libc::c_int = 0;
            let mut rels: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
            rel_offset = offset_from_vma(filedata, jmprel, pltrelsz) as size_t;
            if pltrel == 7 as libc::c_int as libc::c_ulong {
                if !slurp_rela_relocs(
                    filedata,
                    rel_offset,
                    pltrelsz,
                    &mut rels,
                    &mut count,
                ) {
                    return 0 as libc::c_int != 0;
                }
            } else if !slurp_rel_relocs(
                filedata,
                rel_offset,
                pltrelsz,
                &mut rels,
                &mut count,
            ) {
                return 0 as libc::c_int != 0
            }
            ent_1 = mips_pltgot;
            addr_size_1 = if is_32bit_elf as libc::c_int != 0 {
                4 as libc::c_int
            } else {
                8 as libc::c_int
            };
            end_0 = mips_pltgot
                .wrapping_add(
                    (2 as libc::c_int as libc::c_ulong)
                        .wrapping_add(count)
                        .wrapping_mul(addr_size_1 as libc::c_ulong),
                );
            offset_1 = offset_from_vma(
                filedata,
                mips_pltgot,
                end_0.wrapping_sub(mips_pltgot),
            ) as size_t;
            data_1 = get_data(
                0 as *mut libc::c_void,
                filedata,
                offset_1,
                end_0.wrapping_sub(mips_pltgot),
                1 as libc::c_int as bfd_size_type,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Procedure Linkage Table data\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            ) as *mut libc::c_uchar;
            if data_1.is_null() {
                free(rels as *mut libc::c_void);
                return 0 as libc::c_int != 0;
            }
            printf(b"\nPLT GOT:\n\n\0" as *const u8 as *const libc::c_char);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Reserved entries:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  %*s %*s Purpose\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                addr_size_1 * 2 as libc::c_int,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Address\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                addr_size_1 * 2 as libc::c_int,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Initial\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            ent_1 = print_mips_pltgot_entry(data_1, mips_pltgot, ent_1);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" PLT lazy resolver\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            ent_1 = print_mips_pltgot_entry(data_1, mips_pltgot, ent_1);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Module pointer\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Entries:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                b"  %*s %*s %*s %-7s %3s %s\n\0" as *const u8 as *const libc::c_char,
                addr_size_1 * 2 as libc::c_int,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Address\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                addr_size_1 * 2 as libc::c_int,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Initial\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                addr_size_1 * 2 as libc::c_int,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Sym.Val.\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dcgettext(
                    0 as *const libc::c_char,
                    b"Type\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dcgettext(
                    0 as *const libc::c_char,
                    b"Ndx\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dcgettext(
                    0 as *const libc::c_char,
                    b"Name\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            sym_width_0 = (if is_32bit_elf as libc::c_int != 0 {
                80 as libc::c_int
            } else {
                160 as libc::c_int
            }) - 17 as libc::c_int - addr_size_1 * 6 as libc::c_int - 1 as libc::c_int;
            i_0 = 0 as libc::c_int as libc::c_ulong;
            while i_0 < count {
                let mut idx: libc::c_ulong = get_reloc_symindex(
                    (*rels.offset(i_0 as isize)).r_info,
                );
                ent_1 = print_mips_pltgot_entry(data_1, mips_pltgot, ent_1);
                printf(b" \0" as *const u8 as *const libc::c_char);
                if idx >= (*filedata).num_dynamic_syms {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<corrupt symbol index: %lu>\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        idx,
                    );
                } else {
                    let mut psym_1: *mut Elf_Internal_Sym = ((*filedata).dynamic_symbols)
                        .offset(idx as isize);
                    print_vma((*psym_1).st_value, LONG_HEX);
                    printf(
                        b" %-7s %3s \0" as *const u8 as *const libc::c_char,
                        get_symbol_type(
                            filedata,
                            ((*psym_1).st_info as libc::c_int & 0xf as libc::c_int)
                                as libc::c_uint,
                        ),
                        get_symbol_index_type(filedata, (*psym_1).st_shndx),
                    );
                    if !((*filedata).dynamic_strings).is_null()
                        && (*psym_1).st_name < (*filedata).dynamic_strings_length
                    {
                        print_symbol(
                            sym_width_0,
                            ((*filedata).dynamic_strings)
                                .offset((*psym_1).st_name as isize),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"<corrupt: %14ld>\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*psym_1).st_name,
                        );
                    }
                }
                printf(b"\n\0" as *const u8 as *const libc::c_char);
                i_0 = i_0.wrapping_add(1);
                i_0;
            }
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            free(data_1 as *mut libc::c_void);
            free(rels as *mut libc::c_void);
        }
        return res;
    };
}
unsafe extern "C" fn process_nds32_specific(mut filedata: *mut Filedata) -> bool {
    let mut sect: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    sect = find_section(
        filedata,
        b".nds32_e_flags\0" as *const u8 as *const libc::c_char,
    );
    if !sect.is_null() && (*sect).sh_size >= 4 as libc::c_int as libc::c_ulong {
        let mut buf: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut flag: libc::c_uint = 0;
        printf(b"\nNDS32 elf flags section:\n\0" as *const u8 as *const libc::c_char);
        buf = get_data(
            0 as *mut libc::c_void,
            filedata,
            (*sect).sh_offset as libc::c_ulong,
            1 as libc::c_int as bfd_size_type,
            4 as libc::c_int as bfd_size_type,
            dcgettext(
                0 as *const libc::c_char,
                b"NDS32 elf flags section\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        ) as *mut libc::c_uchar;
        if buf.is_null() {
            return 0 as libc::c_int != 0;
        }
        flag = byte_get
            .expect("non-null function pointer")(buf, 4 as libc::c_int as libc::c_uint)
            as libc::c_uint;
        free(buf as *mut libc::c_void);
        match flag & 0x3 as libc::c_int as libc::c_uint {
            0 => {
                printf(
                    b"(VEC_SIZE):\tNo entry.\n\0" as *const u8 as *const libc::c_char,
                );
            }
            1 => {
                printf(b"(VEC_SIZE):\t4 bytes\n\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                printf(b"(VEC_SIZE):\t16 bytes\n\0" as *const u8 as *const libc::c_char);
            }
            3 => {
                printf(b"(VEC_SIZE):\treserved\n\0" as *const u8 as *const libc::c_char);
            }
            _ => {}
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn process_gnu_liblist(mut filedata: *mut Filedata) -> bool {
    let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut string_sec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut elib: *mut Elf32_External_Lib = 0 as *mut Elf32_External_Lib;
    let mut strtab: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut strtab_size: size_t = 0;
    let mut cnt: size_t = 0;
    let mut num_liblist: libc::c_ulong = 0;
    let mut i: libc::c_uint = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    if !do_arch {
        return 1 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as libc::c_uint;
    section = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum {
        match (*section).sh_type {
            1879048183 => {
                if !((*section).sh_link >= (*filedata).file_header.e_shnum) {
                    elib = get_data(
                        0 as *mut libc::c_void,
                        filedata,
                        (*section).sh_offset as libc::c_ulong,
                        1 as libc::c_int as bfd_size_type,
                        (*section).sh_size,
                        dcgettext(
                            0 as *const libc::c_char,
                            b"liblist section data\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    ) as *mut Elf32_External_Lib;
                    if elib.is_null() {
                        res = 0 as libc::c_int != 0;
                    } else {
                        string_sec = ((*filedata).section_headers)
                            .offset((*section).sh_link as isize);
                        strtab = get_data(
                            0 as *mut libc::c_void,
                            filedata,
                            (*string_sec).sh_offset as libc::c_ulong,
                            1 as libc::c_int as bfd_size_type,
                            (*string_sec).sh_size,
                            dcgettext(
                                0 as *const libc::c_char,
                                b"liblist string table\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        ) as *mut libc::c_char;
                        if strtab.is_null()
                            || (*section).sh_entsize
                                != ::core::mem::size_of::<Elf32_External_Lib>()
                                    as libc::c_ulong
                        {
                            free(elib as *mut libc::c_void);
                            free(strtab as *mut libc::c_void);
                            res = 0 as libc::c_int != 0;
                        } else {
                            strtab_size = (*string_sec).sh_size;
                            num_liblist = ((*section).sh_size)
                                .wrapping_div(
                                    ::core::mem::size_of::<Elf32_External_Lib>()
                                        as libc::c_ulong,
                                );
                            printf(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"\nLibrary list section '%s' contains %lu entries:\n\0"
                                        as *const u8 as *const libc::c_char,
                                    b"\nLibrary list section '%s' contains %lu entries:\n\0"
                                        as *const u8 as *const libc::c_char,
                                    num_liblist,
                                    5 as libc::c_int,
                                ),
                                printable_section_name(filedata, section),
                                num_liblist,
                            );
                            puts(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"     Library              Time Stamp          Checksum   Version Flags\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            cnt = 0 as libc::c_int as size_t;
                            while cnt
                                < ((*section).sh_size)
                                    .wrapping_div(
                                        ::core::mem::size_of::<Elf32_External_Lib>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut liblist: Elf32_Lib = Elf32_Lib {
                                    l_name: 0,
                                    l_time_stamp: 0,
                                    l_checksum: 0,
                                    l_version: 0,
                                    l_flags: 0,
                                };
                                let mut atime: time_t = 0;
                                let mut timebuf: [libc::c_char; 128] = [0; 128];
                                let mut tmp: *mut tm = 0 as *mut tm;
                                liblist
                                    .l_name = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*elib.offset(cnt as isize)).l_name).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                atime = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*elib.offset(cnt as isize)).l_time_stamp).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                ) as time_t;
                                liblist
                                    .l_checksum = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*elib.offset(cnt as isize)).l_checksum).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                liblist
                                    .l_version = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*elib.offset(cnt as isize)).l_version).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                liblist
                                    .l_flags = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*elib.offset(cnt as isize)).l_flags).as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_uchar; 4]>()
                                        as libc::c_ulong as libc::c_uint,
                                );
                                tmp = gmtime(&mut atime);
                                snprintf(
                                    timebuf.as_mut_ptr(),
                                    ::core::mem::size_of::<[libc::c_char; 128]>()
                                        as libc::c_ulong,
                                    b"%04u-%02u-%02uT%02u:%02u:%02u\0" as *const u8
                                        as *const libc::c_char,
                                    (*tmp).tm_year + 1900 as libc::c_int,
                                    (*tmp).tm_mon + 1 as libc::c_int,
                                    (*tmp).tm_mday,
                                    (*tmp).tm_hour,
                                    (*tmp).tm_min,
                                    (*tmp).tm_sec,
                                );
                                printf(
                                    b"%3lu: \0" as *const u8 as *const libc::c_char,
                                    cnt,
                                );
                                if do_wide != 0 {
                                    printf(
                                        b"%-20s\0" as *const u8 as *const libc::c_char,
                                        if liblist.l_name < strtab_size {
                                            strtab.offset(liblist.l_name as isize)
                                        } else {
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            )
                                        },
                                    );
                                } else {
                                    printf(
                                        b"%-20.20s\0" as *const u8 as *const libc::c_char,
                                        if liblist.l_name < strtab_size {
                                            strtab.offset(liblist.l_name as isize)
                                        } else {
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            )
                                        },
                                    );
                                }
                                printf(
                                    b" %s %#010lx %-7ld %-7ld\n\0" as *const u8
                                        as *const libc::c_char,
                                    timebuf.as_mut_ptr(),
                                    liblist.l_checksum,
                                    liblist.l_version,
                                    liblist.l_flags,
                                );
                                cnt = cnt.wrapping_add(1);
                                cnt;
                            }
                            free(elib as *mut libc::c_void);
                            free(strtab as *mut libc::c_void);
                        }
                    }
                }
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    return res;
}
unsafe extern "C" fn get_note_type(
    mut filedata: *mut Filedata,
    mut e_type: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    if (*filedata).file_header.e_type as libc::c_int == 4 as libc::c_int {
        match e_type {
            6 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_AUXV (auxiliary vector)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PRSTATUS (prstatus structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            2 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_FPREGSET (floating point registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            3 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PRPSINFO (prpsinfo structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            4 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_TASKSTRUCT (task structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            4278190080 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_GDB_TDESC (GDB XML target description)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1189489535 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PRXFPREG (user_xfpregs structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            256 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_VMX (ppc Altivec registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            258 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_VSX (ppc VSX registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            259 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TAR (ppc TAR register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            260 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_PPR (ppc PPR register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            261 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_DSCR (ppc DSCR register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            262 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_EBB (ppc EBB registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            263 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_PMU (ppc PMU registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            264 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TM_CGPR (ppc checkpointed GPR registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            265 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TM_CFPR (ppc checkpointed floating point registers)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            266 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TM_CVMX (ppc checkpointed Altivec registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            267 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TM_CVSX (ppc checkpointed VSX registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            268 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TM_SPR (ppc TM special purpose registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            269 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TM_CTAR (ppc checkpointed TAR register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            270 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TM_CPPR (ppc checkpointed PPR register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            271 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PPC_TM_CDSCR (ppc checkpointed DSCR register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            512 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_386_TLS (x86 TLS information)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            513 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_386_IOPERM (x86 I/O permissions)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            514 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_X86_XSTATE (x86 XSAVE extended state)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            515 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_X86_CET (x86 CET state)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            768 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_HIGH_GPRS (s390 upper register halves)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            769 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_TIMER (s390 timer register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            770 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_TODCMP (s390 TOD comparator register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            771 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_TODPREG (s390 TOD programmable register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            772 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_CTRS (s390 control registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            773 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_PREFIX (s390 prefix register)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            774 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_LAST_BREAK (s390 last breaking event address)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            775 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_SYSTEM_CALL (s390 system call restart data)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            776 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_TDB (s390 transaction diagnostic block)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            777 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_VXRS_LOW (s390 vector registers 0-15 upper half)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            778 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_VXRS_HIGH (s390 vector registers 16-31)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            779 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_GS_CB (s390 guarded-storage registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            780 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_S390_GS_BC (s390 guarded-storage broadcast control)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1024 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARM_VFP (arm VFP registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1025 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARM_TLS (AArch TLS registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1026 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARM_HW_BREAK (AArch hardware breakpoint registers)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1027 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARM_HW_WATCH (AArch hardware watchpoint registers)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1029 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARM_SVE (AArch SVE registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1030 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARM_PAC_MASK (AArch pointer authentication code masks)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1033 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARM_TAGGED_ADDR_CTRL (AArch tagged address control)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1536 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARC_V2 (ARC HS accumulator/extra registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            2304 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_RISCV_CSR (RISC-V control and status registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            10 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PSTATUS (pstatus structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            12 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_FPREGS (floating point registers)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            13 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_PSINFO (psinfo structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            16 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_LWPSTATUS (lwpstatus_t structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            17 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_LWPSINFO (lwpsinfo_t structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            18 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_WIN32PSTATUS (win32_pstatus structure)\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1397311305 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_SIGINFO (siginfo_t data)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            1179208773 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_FILE (mapped files)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            4278190081 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_MEMTAG (memory tags)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            _ => {}
        }
    } else {
        match e_type {
            1 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_VERSION (version)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            2 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"NT_ARCH (architecture)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            256 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"OPEN\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            257 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"func\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            4 => {
                return dcgettext(
                    0 as *const libc::c_char,
                    b"GO BUILDID\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                );
            }
            _ => {}
        }
    }
    snprintf(
        buff.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        dcgettext(
            0 as *const libc::c_char,
            b"Unknown note type: (0x%08x)\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        e_type,
    );
    return buff.as_mut_ptr();
}
unsafe extern "C" fn print_core_note(mut pnote: *mut Elf_Internal_Note) -> bool {
    let mut addr_size: libc::c_uint = (if is_32bit_elf as libc::c_int != 0 {
        4 as libc::c_int
    } else {
        8 as libc::c_int
    }) as libc::c_uint;
    let mut count: bfd_vma = 0;
    let mut page_size: bfd_vma = 0;
    let mut descdata: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut filenames: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut descend: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if (*pnote).type_0 != 0x46494c45 as libc::c_int as libc::c_ulong {
        if do_wide != 0 {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
        return 1 as libc::c_int != 0;
    }
    if (*pnote).descsz
        < (2 as libc::c_int as libc::c_uint).wrapping_mul(addr_size) as libc::c_ulong
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"    Malformed note - too short for header\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    descdata = (*pnote).descdata as *mut libc::c_uchar;
    descend = descdata.offset((*pnote).descsz as isize);
    if *descdata
        .offset(
            ((*pnote).descsz).wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
        ) as libc::c_int != '\0' as i32
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"    Malformed note - does not end with \\0\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    count = byte_get.expect("non-null function pointer")(descdata, addr_size);
    descdata = descdata.offset(addr_size as isize);
    page_size = byte_get.expect("non-null function pointer")(descdata, addr_size);
    descdata = descdata.offset(addr_size as isize);
    if count
        > (-(1 as libc::c_int) as bfd_vma)
            .wrapping_sub(
                (2 as libc::c_int as libc::c_uint).wrapping_mul(addr_size)
                    as libc::c_ulong,
            )
            .wrapping_div(
                (3 as libc::c_int as libc::c_uint).wrapping_mul(addr_size)
                    as libc::c_ulong,
            )
        || (*pnote).descsz
            < ((2 as libc::c_int as libc::c_uint).wrapping_mul(addr_size)
                as libc::c_ulong)
                .wrapping_add(
                    count
                        .wrapping_mul(3 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(addr_size as libc::c_ulong),
                )
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"    Malformed note - too short for supplied file count\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"    Page size: \0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    print_vma(page_size, DEC);
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"    %*s%*s%*s\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        (2 as libc::c_int as libc::c_uint)
            .wrapping_add((2 as libc::c_int as libc::c_uint).wrapping_mul(addr_size))
            as libc::c_int,
        dcgettext(
            0 as *const libc::c_char,
            b"Start\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        (4 as libc::c_int as libc::c_uint)
            .wrapping_add((2 as libc::c_int as libc::c_uint).wrapping_mul(addr_size))
            as libc::c_int,
        dcgettext(
            0 as *const libc::c_char,
            b"End\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        (4 as libc::c_int as libc::c_uint)
            .wrapping_add((2 as libc::c_int as libc::c_uint).wrapping_mul(addr_size))
            as libc::c_int,
        dcgettext(
            0 as *const libc::c_char,
            b"Page Offset\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    filenames = descdata
        .offset(
            count
                .wrapping_mul(3 as libc::c_int as libc::c_ulong)
                .wrapping_mul(addr_size as libc::c_ulong) as isize,
        );
    loop {
        let fresh44 = count;
        count = count.wrapping_sub(1);
        if !(fresh44 > 0 as libc::c_int as libc::c_ulong) {
            break;
        }
        let mut start: bfd_vma = 0;
        let mut end: bfd_vma = 0;
        let mut file_ofs: bfd_vma = 0;
        if filenames == descend {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    Malformed note - filenames end too early\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
        start = byte_get.expect("non-null function pointer")(descdata, addr_size);
        descdata = descdata.offset(addr_size as isize);
        end = byte_get.expect("non-null function pointer")(descdata, addr_size);
        descdata = descdata.offset(addr_size as isize);
        file_ofs = byte_get.expect("non-null function pointer")(descdata, addr_size);
        descdata = descdata.offset(addr_size as isize);
        printf(b"    \0" as *const u8 as *const libc::c_char);
        print_vma(start, FULL_HEX);
        printf(b"  \0" as *const u8 as *const libc::c_char);
        print_vma(end, FULL_HEX);
        printf(b"  \0" as *const u8 as *const libc::c_char);
        print_vma(file_ofs, FULL_HEX);
        printf(b"\n        %s\n\0" as *const u8 as *const libc::c_char, filenames);
        filenames = filenames
            .offset(
                (1 as libc::c_int as libc::c_ulong)
                    .wrapping_add(strlen(filenames as *mut libc::c_char)) as isize,
            );
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_gnu_elf_note_type(
    mut e_type: libc::c_uint,
) -> *const libc::c_char {
    match e_type {
        1 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_GNU_ABI_TAG (ABI version tag)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        2 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_GNU_HWCAP (DSO-supplied software HWCAP info)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        3 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_GNU_BUILD_ID (unique build ID bitstring)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        4 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_GNU_GOLD_VERSION (gold version)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        5 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_GNU_PROPERTY_TYPE_0\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        256 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_GNU_BUILD_ATTRIBUTE_OPEN\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        257 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_GNU_BUILD_ATTRIBUTE_FUNC\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        _ => {
            static mut buff: [libc::c_char; 64] = [0; 64];
            snprintf(
                buff.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unknown note type: (0x%08x)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                e_type,
            );
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn decode_x86_compat_isa(mut bitmask: libc::c_uint) {
    while bitmask != 0 {
        let mut bit: libc::c_uint = bitmask & bitmask.wrapping_neg();
        bitmask &= !bit;
        match bit {
            1 => {
                printf(b"i486\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                printf(b"586\0" as *const u8 as *const libc::c_char);
            }
            4 => {
                printf(b"686\0" as *const u8 as *const libc::c_char);
            }
            8 => {
                printf(b"SSE\0" as *const u8 as *const libc::c_char);
            }
            16 => {
                printf(b"SSE2\0" as *const u8 as *const libc::c_char);
            }
            32 => {
                printf(b"SSE3\0" as *const u8 as *const libc::c_char);
            }
            64 => {
                printf(b"SSSE3\0" as *const u8 as *const libc::c_char);
            }
            128 => {
                printf(b"SSE4_1\0" as *const u8 as *const libc::c_char);
            }
            256 => {
                printf(b"SSE4_2\0" as *const u8 as *const libc::c_char);
            }
            512 => {
                printf(b"AVX\0" as *const u8 as *const libc::c_char);
            }
            1024 => {
                printf(b"AVX2\0" as *const u8 as *const libc::c_char);
            }
            2048 => {
                printf(b"AVX512F\0" as *const u8 as *const libc::c_char);
            }
            4096 => {
                printf(b"AVX512CD\0" as *const u8 as *const libc::c_char);
            }
            8192 => {
                printf(b"AVX512ER\0" as *const u8 as *const libc::c_char);
            }
            16384 => {
                printf(b"AVX512PF\0" as *const u8 as *const libc::c_char);
            }
            32768 => {
                printf(b"AVX512VL\0" as *const u8 as *const libc::c_char);
            }
            65536 => {
                printf(b"AVX512DQ\0" as *const u8 as *const libc::c_char);
            }
            131072 => {
                printf(b"AVX512BW\0" as *const u8 as *const libc::c_char);
            }
            _ => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    bit,
                );
            }
        }
        if bitmask != 0 {
            printf(b", \0" as *const u8 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn decode_x86_compat_2_isa(mut bitmask: libc::c_uint) {
    if bitmask == 0 {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"<None>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return;
    }
    while bitmask != 0 {
        let mut bit: libc::c_uint = bitmask & bitmask.wrapping_neg();
        bitmask &= !bit;
        match bit {
            1 => {
                printf(b"CMOV\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                printf(b"SSE\0" as *const u8 as *const libc::c_char);
            }
            4 => {
                printf(b"SSE2\0" as *const u8 as *const libc::c_char);
            }
            8 => {
                printf(b"SSE3\0" as *const u8 as *const libc::c_char);
            }
            16 => {
                printf(b"SSSE3\0" as *const u8 as *const libc::c_char);
            }
            32 => {
                printf(b"SSE4_1\0" as *const u8 as *const libc::c_char);
            }
            64 => {
                printf(b"SSE4_2\0" as *const u8 as *const libc::c_char);
            }
            128 => {
                printf(b"AVX\0" as *const u8 as *const libc::c_char);
            }
            256 => {
                printf(b"AVX2\0" as *const u8 as *const libc::c_char);
            }
            512 => {
                printf(b"FMA\0" as *const u8 as *const libc::c_char);
            }
            1024 => {
                printf(b"AVX512F\0" as *const u8 as *const libc::c_char);
            }
            2048 => {
                printf(b"AVX512CD\0" as *const u8 as *const libc::c_char);
            }
            4096 => {
                printf(b"AVX512ER\0" as *const u8 as *const libc::c_char);
            }
            8192 => {
                printf(b"AVX512PF\0" as *const u8 as *const libc::c_char);
            }
            16384 => {
                printf(b"AVX512VL\0" as *const u8 as *const libc::c_char);
            }
            32768 => {
                printf(b"AVX512DQ\0" as *const u8 as *const libc::c_char);
            }
            65536 => {
                printf(b"AVX512BW\0" as *const u8 as *const libc::c_char);
            }
            131072 => {
                printf(b"AVX512_4FMAPS\0" as *const u8 as *const libc::c_char);
            }
            262144 => {
                printf(b"AVX512_4VNNIW\0" as *const u8 as *const libc::c_char);
            }
            524288 => {
                printf(b"AVX512_BITALG\0" as *const u8 as *const libc::c_char);
            }
            1048576 => {
                printf(b"AVX512_IFMA\0" as *const u8 as *const libc::c_char);
            }
            2097152 => {
                printf(b"AVX512_VBMI\0" as *const u8 as *const libc::c_char);
            }
            4194304 => {
                printf(b"AVX512_VBMI2\0" as *const u8 as *const libc::c_char);
            }
            8388608 => {
                printf(b"AVX512_VNNI\0" as *const u8 as *const libc::c_char);
            }
            16777216 => {
                printf(b"AVX512_BF16\0" as *const u8 as *const libc::c_char);
            }
            _ => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    bit,
                );
            }
        }
        if bitmask != 0 {
            printf(b", \0" as *const u8 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn decode_x86_isa(mut bitmask: libc::c_uint) {
    while bitmask != 0 {
        let mut bit: libc::c_uint = bitmask & bitmask.wrapping_neg();
        bitmask &= !bit;
        match bit {
            1 => {
                printf(b"x86-64-baseline\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                printf(b"x86-64-v2\0" as *const u8 as *const libc::c_char);
            }
            4 => {
                printf(b"x86-64-v3\0" as *const u8 as *const libc::c_char);
            }
            8 => {
                printf(b"x86-64-v4\0" as *const u8 as *const libc::c_char);
            }
            _ => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    bit,
                );
            }
        }
        if bitmask != 0 {
            printf(b", \0" as *const u8 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn decode_x86_feature_1(mut bitmask: libc::c_uint) {
    if bitmask == 0 {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"<None>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return;
    }
    while bitmask != 0 {
        let mut bit: libc::c_uint = bitmask & bitmask.wrapping_neg();
        bitmask &= !bit;
        match bit {
            1 => {
                printf(b"IBT\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                printf(b"SHSTK\0" as *const u8 as *const libc::c_char);
            }
            4 => {
                printf(b"LAM_U48\0" as *const u8 as *const libc::c_char);
            }
            8 => {
                printf(b"LAM_U57\0" as *const u8 as *const libc::c_char);
            }
            _ => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    bit,
                );
            }
        }
        if bitmask != 0 {
            printf(b", \0" as *const u8 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn decode_x86_feature_2(mut bitmask: libc::c_uint) {
    if bitmask == 0 {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"<None>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return;
    }
    while bitmask != 0 {
        let mut bit: libc::c_uint = bitmask & bitmask.wrapping_neg();
        bitmask &= !bit;
        match bit {
            1 => {
                printf(b"x86\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                printf(b"x87\0" as *const u8 as *const libc::c_char);
            }
            4 => {
                printf(b"MMX\0" as *const u8 as *const libc::c_char);
            }
            8 => {
                printf(b"XMM\0" as *const u8 as *const libc::c_char);
            }
            16 => {
                printf(b"YMM\0" as *const u8 as *const libc::c_char);
            }
            32 => {
                printf(b"ZMM\0" as *const u8 as *const libc::c_char);
            }
            1024 => {
                printf(b"TMM\0" as *const u8 as *const libc::c_char);
            }
            2048 => {
                printf(b"MASK\0" as *const u8 as *const libc::c_char);
            }
            64 => {
                printf(b"FXSR\0" as *const u8 as *const libc::c_char);
            }
            128 => {
                printf(b"XSAVE\0" as *const u8 as *const libc::c_char);
            }
            256 => {
                printf(b"XSAVEOPT\0" as *const u8 as *const libc::c_char);
            }
            512 => {
                printf(b"XSAVEC\0" as *const u8 as *const libc::c_char);
            }
            _ => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    bit,
                );
            }
        }
        if bitmask != 0 {
            printf(b", \0" as *const u8 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn decode_aarch64_feature_1_and(mut bitmask: libc::c_uint) {
    while bitmask != 0 {
        let mut bit: libc::c_uint = bitmask & bitmask.wrapping_neg();
        bitmask &= !bit;
        match bit {
            1 => {
                printf(b"BTI\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                printf(b"PAC\0" as *const u8 as *const libc::c_char);
            }
            _ => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown: %x>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    bit,
                );
            }
        }
        if bitmask != 0 {
            printf(b", \0" as *const u8 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn print_gnu_property_note(
    mut filedata: *mut Filedata,
    mut pnote: *mut Elf_Internal_Note,
) {
    let mut current_block: u64;
    let mut ptr: *mut libc::c_uchar = (*pnote).descdata as *mut libc::c_uchar;
    let mut ptr_end: *mut libc::c_uchar = ptr.offset((*pnote).descsz as isize);
    let mut size: libc::c_uint = (if is_32bit_elf as libc::c_int != 0 {
        4 as libc::c_int
    } else {
        8 as libc::c_int
    }) as libc::c_uint;
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"      Properties: \0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    if (*pnote).descsz < 8 as libc::c_int as libc::c_ulong
        || ((*pnote).descsz).wrapping_rem(size as libc::c_ulong)
            != 0 as libc::c_int as libc::c_ulong
    {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*pnote).descsz,
        );
        return;
    }
    while ptr < ptr_end {
        let mut j: libc::c_uint = 0;
        let mut type_0: libc::c_uint = 0;
        let mut datasz: libc::c_uint = 0;
        if (ptr_end.offset_from(ptr) as libc::c_long as size_t)
            < 8 as libc::c_int as libc::c_ulong
        {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<corrupt descsz: %#lx>\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*pnote).descsz,
            );
            break;
        } else {
            type_0 = byte_get
                .expect(
                    "non-null function pointer",
                )(ptr, 4 as libc::c_int as libc::c_uint) as libc::c_uint;
            datasz = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ptr.offset(4 as libc::c_int as isize),
                4 as libc::c_int as libc::c_uint,
            ) as libc::c_uint;
            ptr = ptr.offset(8 as libc::c_int as isize);
            if datasz as libc::c_ulong
                > ptr_end.offset_from(ptr) as libc::c_long as size_t
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt type (%#x) datasz: %#x>\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    type_0,
                    datasz,
                );
                break;
            } else {
                if type_0 >= 0xc0000000 as libc::c_uint
                    && type_0 <= 0xdfffffff as libc::c_uint
                {
                    if (*filedata).file_header.e_machine as libc::c_int
                        == 62 as libc::c_int
                        || (*filedata).file_header.e_machine as libc::c_int
                            == 6 as libc::c_int
                        || (*filedata).file_header.e_machine as libc::c_int
                            == 3 as libc::c_int
                    {
                        let mut bitmask: libc::c_uint = 0;
                        if datasz == 4 as libc::c_int as libc::c_uint {
                            bitmask = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(ptr, 4 as libc::c_int as libc::c_uint) as libc::c_uint;
                        } else {
                            bitmask = 0 as libc::c_int as libc::c_uint;
                        }
                        match type_0 {
                            3221291010 => {
                                current_block = 6937293303264252002;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            3221258242 => {
                                current_block = 4530114373393559824;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            3221225474 => {
                                current_block = 6819903158616397303;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            3221291009 => {
                                current_block = 18170946786868537150;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            3221258241 => {
                                current_block = 4501186290806573642;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            3221225472 => {
                                current_block = 13649104060595152350;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            3221225473 => {
                                current_block = 3365690133718090369;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            3221291008 => {
                                current_block = 14664779412704525457;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            3221258240 => {
                                current_block = 10312750082670657018;
                                match current_block {
                                    10312750082670657018 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    4530114373393559824 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                    6819903158616397303 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_1(bitmask);
                                        }
                                    }
                                    18170946786868537150 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    4501186290806573642 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 feature needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 feature needed: \0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            decode_x86_feature_2(bitmask);
                                        }
                                    }
                                    13649104060595152350 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    3365690133718090369 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA needed: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA needed: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_isa(bitmask);
                                        }
                                    }
                                    14664779412704525457 => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_compat_2_isa(bitmask);
                                        }
                                    }
                                    _ => {
                                        if datasz != 4 as libc::c_int as libc::c_uint {
                                            printf(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"x86 ISA used: <corrupt length: %#x> \0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                datasz,
                                            );
                                        } else {
                                            printf(
                                                b"x86 ISA used: \0" as *const u8 as *const libc::c_char,
                                            );
                                            decode_x86_isa(bitmask);
                                        }
                                    }
                                }
                                current_block = 7008450787086210450;
                            }
                            _ => {
                                current_block = 17167606947040001567;
                            }
                        }
                    } else if (*filedata).file_header.e_machine as libc::c_int
                        == 183 as libc::c_int
                    {
                        if type_0 == 0xc0000000 as libc::c_uint {
                            printf(
                                b"AArch64 feature: \0" as *const u8 as *const libc::c_char,
                            );
                            if datasz != 4 as libc::c_int as libc::c_uint {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"<corrupt length: %#x> \0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    datasz,
                                );
                            } else {
                                decode_aarch64_feature_1_and(
                                    byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(ptr, 4 as libc::c_int as libc::c_uint) as libc::c_uint,
                                );
                            }
                            current_block = 7008450787086210450;
                        } else {
                            current_block = 17167606947040001567;
                        }
                    } else {
                        current_block = 17167606947040001567;
                    }
                } else {
                    match type_0 {
                        1 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"stack size: \0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            if datasz != size {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"<corrupt length: %#x> \0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    datasz,
                                );
                            } else {
                                printf(
                                    b"%#lx\0" as *const u8 as *const libc::c_char,
                                    byte_get.expect("non-null function pointer")(ptr, size),
                                );
                            }
                            current_block = 7008450787086210450;
                        }
                        2 => {
                            printf(
                                b"no copy on protected \0" as *const u8
                                    as *const libc::c_char,
                            );
                            if datasz != 0 {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"<corrupt length: %#x> \0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    datasz,
                                );
                            }
                            current_block = 7008450787086210450;
                        }
                        _ => {
                            if type_0 >= 0xb0000000 as libc::c_uint
                                && type_0 <= 0xb0007fff as libc::c_uint
                                || type_0 >= 0xb0008000 as libc::c_uint
                                    && type_0 <= 0xb000ffff as libc::c_uint
                            {
                                if type_0 <= 0xb0007fff as libc::c_uint {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"UINT32_AND (%#x): \0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        type_0,
                                    );
                                } else {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"UINT32_OR (%#x): \0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        type_0,
                                    );
                                }
                                if datasz != 4 as libc::c_int as libc::c_uint {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"<corrupt length: %#x> \0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        datasz,
                                    );
                                } else {
                                    printf(
                                        b"%#x\0" as *const u8 as *const libc::c_char,
                                        byte_get
                                            .expect(
                                                "non-null function pointer",
                                            )(ptr, 4 as libc::c_int as libc::c_uint) as libc::c_uint,
                                    );
                                }
                                current_block = 7008450787086210450;
                            } else {
                                current_block = 17167606947040001567;
                            }
                        }
                    }
                }
                match current_block {
                    17167606947040001567 => {
                        if type_0 < 0xc0000000 as libc::c_uint {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<unknown type %#x data: \0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                type_0,
                            );
                        } else if type_0 < 0xe0000000 as libc::c_uint {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<processor-specific type %#x data: \0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                type_0,
                            );
                        } else {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<application-specific type %#x data: \0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                type_0,
                            );
                        }
                        j = 0 as libc::c_int as libc::c_uint;
                        while j < datasz {
                            printf(
                                b"%02x \0" as *const u8 as *const libc::c_char,
                                *ptr.offset(j as isize) as libc::c_int & 0xff as libc::c_int,
                            );
                            j = j.wrapping_add(1);
                            j;
                        }
                        printf(b">\0" as *const u8 as *const libc::c_char);
                    }
                    _ => {}
                }
                ptr = ptr
                    .offset(
                        (datasz
                            .wrapping_add(
                                size.wrapping_sub(1 as libc::c_int as libc::c_uint),
                            ) & !size.wrapping_sub(1 as libc::c_int as libc::c_uint))
                            as isize,
                    );
                if ptr == ptr_end {
                    break;
                }
                if do_wide != 0 {
                    printf(b", \0" as *const u8 as *const libc::c_char);
                } else {
                    printf(b"\n\t\0" as *const u8 as *const libc::c_char);
                }
            }
        }
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn print_gnu_note(
    mut filedata: *mut Filedata,
    mut pnote: *mut Elf_Internal_Note,
) -> bool {
    match (*pnote).type_0 {
        3 => {
            let mut i: libc::c_ulong = 0;
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    Build ID: \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            i = 0 as libc::c_int as libc::c_ulong;
            while i < (*pnote).descsz {
                printf(
                    b"%02x\0" as *const u8 as *const libc::c_char,
                    *((*pnote).descdata).offset(i as isize) as libc::c_int
                        & 0xff as libc::c_int,
                );
                i = i.wrapping_add(1);
                i;
            }
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
        1 => {
            let mut os: libc::c_ulong = 0;
            let mut major: libc::c_ulong = 0;
            let mut minor: libc::c_ulong = 0;
            let mut subminor: libc::c_ulong = 0;
            let mut osname: *const libc::c_char = 0 as *const libc::c_char;
            if (*pnote).descsz < 16 as libc::c_int as libc::c_ulong {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"    <corrupt GNU_ABI_TAG>\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                os = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (*pnote).descdata as *mut libc::c_uchar,
                    4 as libc::c_int as libc::c_uint,
                );
                major = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*pnote).descdata as *mut libc::c_uchar)
                        .offset(4 as libc::c_int as isize),
                    4 as libc::c_int as libc::c_uint,
                );
                minor = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*pnote).descdata as *mut libc::c_uchar)
                        .offset(8 as libc::c_int as isize),
                    4 as libc::c_int as libc::c_uint,
                );
                subminor = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*pnote).descdata as *mut libc::c_uchar)
                        .offset(12 as libc::c_int as isize),
                    4 as libc::c_int as libc::c_uint,
                );
                match os {
                    0 => {
                        osname = b"Linux\0" as *const u8 as *const libc::c_char;
                    }
                    1 => {
                        osname = b"Hurd\0" as *const u8 as *const libc::c_char;
                    }
                    2 => {
                        osname = b"Solaris\0" as *const u8 as *const libc::c_char;
                    }
                    3 => {
                        osname = b"FreeBSD\0" as *const u8 as *const libc::c_char;
                    }
                    4 => {
                        osname = b"NetBSD\0" as *const u8 as *const libc::c_char;
                    }
                    5 => {
                        osname = b"Syllable\0" as *const u8 as *const libc::c_char;
                    }
                    6 => {
                        osname = b"NaCl\0" as *const u8 as *const libc::c_char;
                    }
                    _ => {
                        osname = b"Unknown\0" as *const u8 as *const libc::c_char;
                    }
                }
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"    OS: %s, ABI: %ld.%ld.%ld\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    osname,
                    major,
                    minor,
                    subminor,
                );
            }
        }
        4 => {
            let mut i_0: libc::c_ulong = 0;
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    Version: \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            i_0 = 0 as libc::c_int as libc::c_ulong;
            while i_0 < (*pnote).descsz
                && *((*pnote).descdata).offset(i_0 as isize) as libc::c_int
                    != '\0' as i32
            {
                printf(
                    b"%c\0" as *const u8 as *const libc::c_char,
                    *((*pnote).descdata).offset(i_0 as isize) as libc::c_int,
                );
                i_0 = i_0.wrapping_add(1);
                i_0;
            }
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
        2 => {
            let mut num_entries: libc::c_ulong = 0;
            let mut mask: libc::c_ulong = 0;
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"      Hardware Capabilities: \0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            if (*pnote).descsz < 8 as libc::c_int as libc::c_ulong {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt GNU_HWCAP>\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int != 0;
            }
            num_entries = byte_get
                .expect(
                    "non-null function pointer",
                )(
                (*pnote).descdata as *mut libc::c_uchar,
                4 as libc::c_int as libc::c_uint,
            );
            mask = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*pnote).descdata as *mut libc::c_uchar)
                    .offset(4 as libc::c_int as isize),
                4 as libc::c_int as libc::c_uint,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"num entries: %ld, enabled mask: %lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                num_entries,
                mask,
            );
        }
        5 => {
            print_gnu_property_note(filedata, pnote);
        }
        _ => {
            let mut i_1: libc::c_ulong = 0;
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    Description data: \0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            i_1 = 0 as libc::c_int as libc::c_ulong;
            while i_1 < (*pnote).descsz {
                printf(
                    b"%02x \0" as *const u8 as *const libc::c_char,
                    *((*pnote).descdata).offset(i_1 as isize) as libc::c_int
                        & 0xff as libc::c_int,
                );
                i_1 = i_1.wrapping_add(1);
                i_1;
            }
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_v850_elf_note_type(
    mut n_type: v850_notes,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    match n_type as libc::c_uint {
        1 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"Alignment of 8-byte objects\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        2 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"Sizeof double and long double\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        3 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"Type of FPU support needed\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        4 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"Use of SIMD instructions\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        5 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"Use of cache\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        6 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"Use of MMU\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        _ => {
            snprintf(
                buff.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unknown note type: (0x%08x)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                n_type as libc::c_uint,
            );
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn print_v850_note(mut pnote: *mut Elf_Internal_Note) -> bool {
    let mut val: libc::c_uint = 0;
    if (*pnote).descsz != 4 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    val = byte_get
        .expect(
            "non-null function pointer",
        )((*pnote).descdata as *mut libc::c_uchar, (*pnote).descsz as libc::c_uint)
        as libc::c_uint;
    if val == 0 as libc::c_int as libc::c_uint {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"not set\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 1 as libc::c_int != 0;
    }
    match (*pnote).type_0 {
        1 => {
            match val {
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"4-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 1 as libc::c_int != 0;
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"8-byte\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 1 as libc::c_int != 0;
                }
                _ => {}
            }
        }
        2 => {
            match val {
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"4-bytes\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 1 as libc::c_int != 0;
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"8-bytes\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 1 as libc::c_int != 0;
                }
                _ => {}
            }
        }
        3 => {
            match val {
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"FPU-2.0\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 1 as libc::c_int != 0;
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"FPU-3.0\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 1 as libc::c_int != 0;
                }
                _ => {}
            }
        }
        6 | 5 | 4 => {
            if val == 0x1 as libc::c_int as libc::c_uint {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"yes\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 1 as libc::c_int != 0;
            }
        }
        _ => {}
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"unknown value: %x\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        val,
    );
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn process_netbsd_elf_note(mut pnote: *mut Elf_Internal_Note) -> bool {
    let mut version: libc::c_uint = 0;
    match (*pnote).type_0 {
        1 => {
            if !((*pnote).descsz < 1 as libc::c_int as libc::c_ulong) {
                version = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (*pnote).descdata as *mut libc::c_uchar,
                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_uint;
                if version
                    .wrapping_div(10000 as libc::c_int as libc::c_uint)
                    .wrapping_rem(100 as libc::c_int as libc::c_uint) != 0
                {
                    printf(
                        b"  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u%s%c)\n\0" as *const u8
                            as *const libc::c_char,
                        (*pnote).descsz,
                        version,
                        version.wrapping_div(100000000 as libc::c_int as libc::c_uint),
                        version
                            .wrapping_div(1000000 as libc::c_int as libc::c_uint)
                            .wrapping_rem(100 as libc::c_int as libc::c_uint),
                        if version
                            .wrapping_div(10000 as libc::c_int as libc::c_uint)
                            .wrapping_rem(100 as libc::c_int as libc::c_uint)
                            > 26 as libc::c_int as libc::c_uint
                        {
                            b"Z\0" as *const u8 as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                        ('A' as i32 as libc::c_uint)
                            .wrapping_add(
                                version
                                    .wrapping_div(10000 as libc::c_int as libc::c_uint)
                                    .wrapping_rem(26 as libc::c_int as libc::c_uint),
                            ),
                    );
                } else {
                    printf(
                        b"  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u.%u)\n\0" as *const u8
                            as *const libc::c_char,
                        (*pnote).descsz,
                        version,
                        version.wrapping_div(100000000 as libc::c_int as libc::c_uint),
                        version
                            .wrapping_div(1000000 as libc::c_int as libc::c_uint)
                            .wrapping_rem(100 as libc::c_int as libc::c_uint),
                        version
                            .wrapping_div(100 as libc::c_int as libc::c_uint)
                            .wrapping_rem(100 as libc::c_int as libc::c_uint),
                    );
                }
                return 1 as libc::c_int != 0;
            }
        }
        5 => {
            printf(
                b"  NetBSD\t\t0x%08lx\tMARCH <%s>\n\0" as *const u8
                    as *const libc::c_char,
                (*pnote).descsz,
                (*pnote).descdata,
            );
            return 1 as libc::c_int != 0;
        }
        3 => {
            if !((*pnote).descsz < 1 as libc::c_int as libc::c_ulong) {
                version = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    (*pnote).descdata as *mut libc::c_uchar,
                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                        as libc::c_uint,
                ) as libc::c_uint;
                printf(
                    b"  NetBSD\t\t0x%08lx\tPaX <%s%s%s%s%s%s>\n\0" as *const u8
                        as *const libc::c_char,
                    (*pnote).descsz,
                    if version & 0x1 as libc::c_int as libc::c_uint != 0 {
                        b"+mprotect\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                    if version & 0x2 as libc::c_int as libc::c_uint != 0 {
                        b"-mprotect\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                    if version & 0x4 as libc::c_int as libc::c_uint != 0 {
                        b"+guard\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                    if version & 0x8 as libc::c_int as libc::c_uint != 0 {
                        b"-guard\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                    if version & 0x10 as libc::c_int as libc::c_uint != 0 {
                        b"+ASLR\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                    if version & 0x20 as libc::c_int as libc::c_uint != 0 {
                        b"-ASLR\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
                return 1 as libc::c_int != 0;
            }
        }
        _ => {}
    }
    printf(
        b"  NetBSD\t0x%08lx\tUnknown note type: (0x%08lx)\n\0" as *const u8
            as *const libc::c_char,
        (*pnote).descsz,
        (*pnote).type_0,
    );
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn get_freebsd_elfcore_note_type(
    mut filedata: *mut Filedata,
    mut e_type: libc::c_uint,
) -> *const libc::c_char {
    match e_type {
        7 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_THRMISC (thrmisc structure)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        8 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_PROC (proc data)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        9 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_FILES (files data)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        10 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_VMMAP (vmmap data)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        11 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_GROUPS (groups data)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        12 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_UMASK (umask data)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        13 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_RLIMIT (rlimit data)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        14 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_OSREL (osreldate data)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        15 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_PSSTRINGS (ps_strings data)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        16 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PROCSTAT_AUXV (auxv data)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        17 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_PTLWPINFO (ptrace_lwpinfo structure)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        _ => {}
    }
    return get_note_type(filedata, e_type);
}
unsafe extern "C" fn get_netbsd_elfcore_note_type(
    mut filedata: *mut Filedata,
    mut e_type: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    match e_type {
        1 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NetBSD procinfo structure\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        2 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NetBSD ELF auxiliary vector data\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        24 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"PT_LWPSTATUS (ptrace_lwpstatus structure)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        _ => {
            if e_type < 32 as libc::c_int as libc::c_uint {
                snprintf(
                    buff.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unknown note type: (0x%08x)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    e_type,
                );
                return buff.as_mut_ptr();
            }
        }
    }
    match (*filedata).file_header.e_machine as libc::c_int {
        41 | 36902 | 2 | 18 | 43 => {
            match e_type {
                32 => {
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"PT_GETREGS (reg structure)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                34 => {
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"PT_GETFPREGS (fpreg structure)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                _ => {}
            }
        }
        42 => {
            match e_type {
                33 => {
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"PT___GETREGS40 (old reg structure)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                35 => {
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"PT_GETREGS (reg structure)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                37 => {
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"PT_GETFPREGS (fpreg structure)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                _ => {}
            }
        }
        _ => {
            match e_type {
                33 => {
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"PT_GETREGS (reg structure)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                35 => {
                    return dcgettext(
                        0 as *const libc::c_char,
                        b"PT_GETFPREGS (fpreg structure)\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                _ => {}
            }
        }
    }
    snprintf(
        buff.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"PT_FIRSTMACH+%d\0" as *const u8 as *const libc::c_char,
        e_type.wrapping_sub(32 as libc::c_int as libc::c_uint),
    );
    return buff.as_mut_ptr();
}
unsafe extern "C" fn get_stapsdt_note_type(
    mut e_type: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    match e_type {
        3 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_STAPSDT (SystemTap probe descriptors)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        _ => {}
    }
    snprintf(
        buff.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        dcgettext(
            0 as *const libc::c_char,
            b"Unknown note type: (0x%08x)\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        e_type,
    );
    return buff.as_mut_ptr();
}
unsafe extern "C" fn print_stapsdt_note(mut pnote: *mut Elf_Internal_Note) -> bool {
    let mut len: size_t = 0;
    let mut maxlen: size_t = 0;
    let mut addr_size: libc::c_ulong = (if is_32bit_elf as libc::c_int != 0 {
        4 as libc::c_int
    } else {
        8 as libc::c_int
    }) as libc::c_ulong;
    let mut data: *mut libc::c_char = (*pnote).descdata;
    let mut data_end: *mut libc::c_char = ((*pnote).descdata)
        .offset((*pnote).descsz as isize);
    let mut pc: bfd_vma = 0;
    let mut base_addr: bfd_vma = 0;
    let mut semaphore: bfd_vma = 0;
    let mut provider: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut probe: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut arg_fmt: *mut libc::c_char = 0 as *mut libc::c_char;
    if !((*pnote).descsz < addr_size.wrapping_mul(3 as libc::c_int as libc::c_ulong)) {
        pc = byte_get
            .expect(
                "non-null function pointer",
            )(data as *mut libc::c_uchar, addr_size as libc::c_uint);
        data = data.offset(addr_size as isize);
        base_addr = byte_get
            .expect(
                "non-null function pointer",
            )(data as *mut libc::c_uchar, addr_size as libc::c_uint);
        data = data.offset(addr_size as isize);
        semaphore = byte_get
            .expect(
                "non-null function pointer",
            )(data as *mut libc::c_uchar, addr_size as libc::c_uint);
        data = data.offset(addr_size as isize);
        if !(data >= data_end) {
            maxlen = data_end.offset_from(data) as libc::c_long as size_t;
            len = strnlen(data, maxlen);
            if len < maxlen {
                provider = data;
                data = data
                    .offset(
                        len.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                    );
                if !(data >= data_end) {
                    maxlen = data_end.offset_from(data) as libc::c_long as size_t;
                    len = strnlen(data, maxlen);
                    if len < maxlen {
                        probe = data;
                        data = data
                            .offset(
                                len.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                            );
                        if !(data >= data_end) {
                            maxlen = data_end.offset_from(data) as libc::c_long
                                as size_t;
                            len = strnlen(data, maxlen);
                            if len < maxlen {
                                arg_fmt = data;
                                data = data
                                    .offset(
                                        len.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                    );
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"    Provider: %s\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    provider,
                                );
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"    Name: %s\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    probe,
                                );
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"    Location: \0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                print_vma(pc, FULL_HEX);
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b", Base: \0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                print_vma(base_addr, FULL_HEX);
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b", Semaphore: \0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                print_vma(semaphore, FULL_HEX);
                                printf(b"\n\0" as *const u8 as *const libc::c_char);
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"    Arguments: %s\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    arg_fmt,
                                );
                                return data == data_end;
                            }
                        }
                    }
                }
            }
        }
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  <corrupt - note is too small>\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    error(
        dcgettext(
            0 as *const libc::c_char,
            b"corrupt stapdt note - the data size is too small\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn get_ia64_vms_note_type(
    mut e_type: libc::c_uint,
) -> *const libc::c_char {
    static mut buff: [libc::c_char; 64] = [0; 64];
    match e_type {
        1 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_MHD (module header)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        2 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_LNM (language name)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        3 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_SRC (source files)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        4 => return b"NT_VMS_TITLE\0" as *const u8 as *const libc::c_char,
        5 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_EIDC (consistency check)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        6 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_FPMODE (FP mode)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        101 => return b"NT_VMS_LINKTIME\0" as *const u8 as *const libc::c_char,
        102 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_IMGNAM (image name)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        103 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_IMGID (image id)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        104 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_LINKID (link id)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        105 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_IMGBID (build id)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        106 => {
            return dcgettext(
                0 as *const libc::c_char,
                b"NT_VMS_GSTNAM (sym table name)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        107 => return b"NT_VMS_ORIG_DYN\0" as *const u8 as *const libc::c_char,
        108 => return b"NT_VMS_PATCHTIME\0" as *const u8 as *const libc::c_char,
        _ => {
            snprintf(
                buff.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unknown note type: (0x%08x)\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                e_type,
            );
            return buff.as_mut_ptr();
        }
    };
}
unsafe extern "C" fn print_ia64_vms_note(mut pnote: *mut Elf_Internal_Note) -> bool {
    let mut l: libc::c_int = 0;
    let mut current_block: u64;
    let mut maxlen: libc::c_int = (*pnote).descsz as libc::c_int;
    if !(maxlen < 2 as libc::c_int || maxlen as libc::c_ulong != (*pnote).descsz) {
        match (*pnote).type_0 {
            1 => {
                if maxlen <= 36 as libc::c_int {
                    current_block = 2468414873323865433;
                } else {
                    l = strnlen(
                        ((*pnote).descdata).offset(34 as libc::c_int as isize),
                        (maxlen - 34 as libc::c_int) as size_t,
                    ) as libc::c_int;
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"    Creation date  : %.17s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*pnote).descdata,
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"    Last patch date: %.17s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        ((*pnote).descdata).offset(17 as libc::c_int as isize),
                    );
                    if (l + 34 as libc::c_int) < maxlen {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"    Module name    : %s\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            ((*pnote).descdata).offset(34 as libc::c_int as isize),
                        );
                        if (l + 35 as libc::c_int) < maxlen {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"    Module version : %s\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ((*pnote).descdata)
                                    .offset(34 as libc::c_int as isize)
                                    .offset(l as isize)
                                    .offset(1 as libc::c_int as isize),
                            );
                        } else {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"    Module version : <missing>\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"    Module name    : <missing>\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"    Module version : <missing>\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    current_block = 6450636197030046351;
                }
            }
            2 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"   Language: %.*s\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    maxlen,
                    (*pnote).descdata,
                );
                current_block = 6450636197030046351;
            }
            6 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"   Floating Point mode: \0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                if maxlen < 8 as libc::c_int {
                    current_block = 2468414873323865433;
                } else {
                    printf(
                        b"0x%016lx\n\0" as *const u8 as *const libc::c_char,
                        byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            (*pnote).descdata as *mut libc::c_uchar,
                            8 as libc::c_int as libc::c_uint,
                        ),
                    );
                    current_block = 6450636197030046351;
                }
            }
            101 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"   Link time: \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                if maxlen < 8 as libc::c_int {
                    current_block = 2468414873323865433;
                } else {
                    print_vms_time(
                        byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            (*pnote).descdata as *mut libc::c_uchar,
                            8 as libc::c_int as libc::c_uint,
                        ) as bfd_int64_t,
                    );
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                    current_block = 6450636197030046351;
                }
            }
            108 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"   Patch time: \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                if maxlen < 8 as libc::c_int {
                    current_block = 2468414873323865433;
                } else {
                    print_vms_time(
                        byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            (*pnote).descdata as *mut libc::c_uchar,
                            8 as libc::c_int as libc::c_uint,
                        ) as bfd_int64_t,
                    );
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                    current_block = 6450636197030046351;
                }
            }
            107 => {
                if maxlen < 34 as libc::c_int {
                    current_block = 2468414873323865433;
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   Major id: %u,  minor id: %u\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            (*pnote).descdata as *mut libc::c_uchar,
                            4 as libc::c_int as libc::c_uint,
                        ) as libc::c_uint,
                        byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*pnote).descdata as *mut libc::c_uchar)
                                .offset(4 as libc::c_int as isize),
                            4 as libc::c_int as libc::c_uint,
                        ) as libc::c_uint,
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   Last modified  : \0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    print_vms_time(
                        byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*pnote).descdata as *mut libc::c_uchar)
                                .offset(8 as libc::c_int as isize),
                            8 as libc::c_int as libc::c_uint,
                        ) as bfd_int64_t,
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\n   Link flags  : \0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    printf(
                        b"0x%016lx\n\0" as *const u8 as *const libc::c_char,
                        byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*pnote).descdata as *mut libc::c_uchar)
                                .offset(16 as libc::c_int as isize),
                            8 as libc::c_int as libc::c_uint,
                        ),
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   Header flags: 0x%08x\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        byte_get
                            .expect(
                                "non-null function pointer",
                            )(
                            ((*pnote).descdata as *mut libc::c_uchar)
                                .offset(24 as libc::c_int as isize),
                            4 as libc::c_int as libc::c_uint,
                        ) as libc::c_uint,
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   Image id    : %.*s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        maxlen - 32 as libc::c_int,
                        ((*pnote).descdata).offset(32 as libc::c_int as isize),
                    );
                    current_block = 6450636197030046351;
                }
            }
            102 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"    Image name: %.*s\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    maxlen,
                    (*pnote).descdata,
                );
                current_block = 6450636197030046351;
            }
            106 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"    Global symbol table name: %.*s\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    maxlen,
                    (*pnote).descdata,
                );
                current_block = 6450636197030046351;
            }
            103 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"    Image id: %.*s\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    maxlen,
                    (*pnote).descdata,
                );
                current_block = 6450636197030046351;
            }
            104 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"    Linker id: %.*s\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    maxlen,
                    (*pnote).descdata,
                );
                current_block = 6450636197030046351;
            }
            _ => return 0 as libc::c_int != 0,
        }
        match current_block {
            2468414873323865433 => {}
            _ => return 1 as libc::c_int != 0,
        }
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  <corrupt - data size is too small>\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    error(
        dcgettext(
            0 as *const libc::c_char,
            b"corrupt IA64 note: data size is too small\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub static mut ba_cache: build_attr_cache = build_attr_cache {
    filedata: 0 as *const Filedata as *mut Filedata,
    strtab: 0 as *const libc::c_char as *mut libc::c_char,
    strtablen: 0,
    symtab: 0 as *const Elf_Internal_Sym as *mut Elf_Internal_Sym,
    nsyms: 0,
};
unsafe extern "C" fn get_symbol_for_build_attribute(
    mut filedata: *mut Filedata,
    mut offset: libc::c_ulong,
    mut is_open_attr: bool,
    mut pname: *mut *const libc::c_char,
) -> *mut Elf_Internal_Sym {
    let mut saved_sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    if !((*filedata).section_headers).is_null()
        && ((ba_cache.filedata).is_null() || filedata != ba_cache.filedata)
    {
        let mut symsec: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        free(ba_cache.strtab as *mut libc::c_void);
        ba_cache.strtab = 0 as *mut libc::c_char;
        free(ba_cache.symtab as *mut libc::c_void);
        ba_cache.symtab = 0 as *mut Elf_Internal_Sym;
        symsec = (*filedata).section_headers;
        while symsec
            < ((*filedata).section_headers)
                .offset((*filedata).file_header.e_shnum as isize)
        {
            if (*symsec).sh_type == 2 as libc::c_int as libc::c_uint
                && get_symtab(
                    filedata,
                    symsec,
                    &mut ba_cache.symtab,
                    &mut ba_cache.nsyms,
                    &mut ba_cache.strtab,
                    &mut ba_cache.strtablen,
                ) as libc::c_int != 0
            {
                break;
            }
            symsec = symsec.offset(1);
            symsec;
        }
        ba_cache.filedata = filedata;
    }
    if (ba_cache.symtab).is_null() {
        return 0 as *mut Elf_Internal_Sym;
    }
    let mut current_block_21: u64;
    sym = ba_cache.symtab;
    while sym < (ba_cache.symtab).offset(ba_cache.nsyms as isize) {
        if (*sym).st_value == offset {
            if !((*sym).st_name >= ba_cache.strtablen) {
                if !(*(ba_cache.strtab).offset((*sym).st_name as isize) as libc::c_int
                    == 0 as libc::c_int)
                {
                    if !(*(ba_cache.strtab).offset((*sym).st_name as isize)
                        as libc::c_int == '$' as i32
                        && *(ba_cache.strtab)
                            .offset(
                                ((*sym).st_name)
                                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                            ) as libc::c_int != 0 as libc::c_int
                        && *(ba_cache.strtab)
                            .offset(
                                ((*sym).st_name)
                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,
                            ) as libc::c_int == 0 as libc::c_int)
                    {
                        if is_open_attr {
                            match (*sym).st_info as libc::c_int & 0xf as libc::c_int {
                                1 | 4 => {
                                    current_block_21 = 10699341499861486892;
                                    match current_block_21 {
                                        11307063007268554308 => {
                                            match (*sym).st_info as libc::c_uint >> 4 as libc::c_int {
                                                1 => {
                                                    if saved_sym.is_null()
                                                        || (*saved_sym).st_info as libc::c_int & 0xf as libc::c_int
                                                            != 1 as libc::c_int
                                                    {
                                                        saved_sym = sym;
                                                    }
                                                }
                                                0 => {
                                                    if saved_sym.is_null() {
                                                        saved_sym = sym;
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        _ => {
                                            saved_sym = sym;
                                            if (*sym).st_size != 0 {
                                                sym = (ba_cache.symtab).offset(ba_cache.nsyms as isize);
                                            }
                                        }
                                    }
                                }
                                2 => {}
                                _ => {
                                    current_block_21 = 11307063007268554308;
                                    match current_block_21 {
                                        11307063007268554308 => {
                                            match (*sym).st_info as libc::c_uint >> 4 as libc::c_int {
                                                1 => {
                                                    if saved_sym.is_null()
                                                        || (*saved_sym).st_info as libc::c_int & 0xf as libc::c_int
                                                            != 1 as libc::c_int
                                                    {
                                                        saved_sym = sym;
                                                    }
                                                }
                                                0 => {
                                                    if saved_sym.is_null() {
                                                        saved_sym = sym;
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        _ => {
                                            saved_sym = sym;
                                            if (*sym).st_size != 0 {
                                                sym = (ba_cache.symtab).offset(ba_cache.nsyms as isize);
                                            }
                                        }
                                    }
                                }
                            }
                        } else if !((*sym).st_info as libc::c_int & 0xf as libc::c_int
                            != 2 as libc::c_int)
                        {
                            saved_sym = sym;
                            break;
                        }
                    }
                }
            }
        }
        sym = sym.offset(1);
        sym;
    }
    if !saved_sym.is_null() && !pname.is_null() {
        *pname = (ba_cache.strtab).offset((*saved_sym).st_name as isize);
    }
    return saved_sym;
}
unsafe extern "C" fn same_section(
    mut filedata: *mut Filedata,
    mut addr1: libc::c_ulong,
    mut addr2: libc::c_ulong,
) -> bool {
    let mut a1: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut a2: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    a1 = find_section_by_address(filedata, addr1);
    a2 = find_section_by_address(filedata, addr2);
    return a1 == a2 && !a1.is_null();
}
unsafe extern "C" fn print_gnu_build_attribute_description(
    mut pnote: *mut Elf_Internal_Note,
    mut filedata: *mut Filedata,
) -> bool {
    static mut global_offset: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    static mut global_end: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    static mut func_offset: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    static mut func_end: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut start: libc::c_ulong = 0;
    let mut end: libc::c_ulong = 0;
    let mut is_open_attr: bool = (*pnote).type_0
        == 0x100 as libc::c_int as libc::c_ulong;
    match (*pnote).descsz {
        0 => {
            if is_open_attr {
                if global_end > global_offset {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"    Applies to region from %#lx to %#lx\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        global_offset,
                        global_end,
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"    Applies to region from %#lx\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        global_offset,
                    );
                }
            } else if func_end > func_offset {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"    Applies to region from %#lx to %#lx\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    func_offset,
                    func_end,
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"    Applies to region from %#lx\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    func_offset,
                );
            }
            return 1 as libc::c_int != 0;
        }
        4 => {
            start = byte_get
                .expect(
                    "non-null function pointer",
                )(
                (*pnote).descdata as *mut libc::c_uchar,
                4 as libc::c_int as libc::c_uint,
            );
            end = 0 as libc::c_int as libc::c_ulong;
        }
        8 => {
            start = byte_get
                .expect(
                    "non-null function pointer",
                )(
                (*pnote).descdata as *mut libc::c_uchar,
                4 as libc::c_int as libc::c_uint,
            );
            end = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*pnote).descdata as *mut libc::c_uchar)
                    .offset(4 as libc::c_int as isize),
                4 as libc::c_int as libc::c_uint,
            );
        }
        16 => {
            start = byte_get
                .expect(
                    "non-null function pointer",
                )(
                (*pnote).descdata as *mut libc::c_uchar,
                8 as libc::c_int as libc::c_uint,
            );
            end = byte_get
                .expect(
                    "non-null function pointer",
                )(
                ((*pnote).descdata as *mut libc::c_uchar)
                    .offset(8 as libc::c_int as isize),
                8 as libc::c_int as libc::c_uint,
            );
        }
        _ => {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    <invalid description size: %lx>\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*pnote).descsz,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    <invalid descsz>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
    }
    name = 0 as *const libc::c_char;
    sym = get_symbol_for_build_attribute(filedata, start, is_open_attr, &mut name);
    if sym.is_null() && is_open_attr as libc::c_int != 0 {
        sym = get_symbol_for_build_attribute(
            filedata,
            start.wrapping_add(2 as libc::c_int as libc::c_ulong),
            is_open_attr,
            &mut name,
        );
    }
    if end == 0 as libc::c_int as libc::c_ulong && !sym.is_null()
        && (*sym).st_size > 0 as libc::c_int as libc::c_ulong
    {
        end = start.wrapping_add((*sym).st_size);
    }
    if is_open_attr {
        if global_end > 0 as libc::c_int as libc::c_ulong
            && start
                > (if global_end
                    .wrapping_add(16 as libc::c_int as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) >= global_end
                {
                    global_end
                        .wrapping_add(
                            (16 as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
                        ) & !((16 as libc::c_int - 1 as libc::c_int) as bfd_vma)
                } else {
                    !(0 as libc::c_int as bfd_vma)
                }) && same_section(filedata, start, global_end) as libc::c_int != 0
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Gap in build notes detected from %#lx to %#lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                global_end.wrapping_add(1 as libc::c_int as libc::c_ulong),
                start.wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
        }
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"    Applies to region from %#lx\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            start,
        );
        global_offset = start;
        if end != 0 {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" to %#lx\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                end,
            );
            global_end = end;
        }
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"    Applies to region from %#lx\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            start,
        );
        func_offset = start;
        if end != 0 {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" to %#lx\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                end,
            );
            func_end = end;
        }
    }
    if !sym.is_null() && !name.is_null() {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b" (%s)\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            name,
        );
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn print_gnu_build_attribute_name(
    mut pnote: *mut Elf_Internal_Note,
) -> bool {
    static mut string_expected: [libc::c_char; 2] = [
        '$' as i32 as libc::c_char,
        0 as libc::c_int as libc::c_char,
    ];
    static mut number_expected: [libc::c_char; 2] = [
        '*' as i32 as libc::c_char,
        0 as libc::c_int as libc::c_char,
    ];
    static mut bool_expected: [libc::c_char; 3] = [
        '+' as i32 as libc::c_char,
        '!' as i32 as libc::c_char,
        0 as libc::c_int as libc::c_char,
    ];
    let mut name_type: libc::c_char = 0;
    let mut name_attribute: libc::c_char = 0;
    let mut expected_types: *const libc::c_char = 0 as *const libc::c_char;
    let mut name: *const libc::c_char = (*pnote).namedata;
    let mut text: *const libc::c_char = 0 as *const libc::c_char;
    let mut left: libc::c_int = 0;
    if name.is_null() || (*pnote).namesz < 2 as libc::c_int as libc::c_ulong {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt name field in GNU build attribute note: size = %ld\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*pnote).namesz,
        );
        print_symbol(
            -(20 as libc::c_int),
            dcgettext(
                0 as *const libc::c_char,
                b"  <corrupt name>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    if do_wide != 0 {
        left = 28 as libc::c_int;
    } else {
        left = 20 as libc::c_int;
    }
    if *name.offset(0 as libc::c_int as isize) as libc::c_int == 'G' as i32
        && *name.offset(1 as libc::c_int as isize) as libc::c_int == 'A' as i32
    {
        if (*pnote).namesz < 4 as libc::c_int as libc::c_ulong {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"corrupt name field in GNU build attribute note: size = %ld\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*pnote).namesz,
            );
            print_symbol(
                -(20 as libc::c_int),
                dcgettext(
                    0 as *const libc::c_char,
                    b"  <corrupt name>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
        printf(b"GA\0" as *const u8 as *const libc::c_char);
        name = name.offset(2 as libc::c_int as isize);
        left -= 2 as libc::c_int;
    }
    name_type = *name;
    match name_type as libc::c_int {
        42 | 36 | 43 | 33 => {
            printf(b"%c\0" as *const u8 as *const libc::c_char, *name as libc::c_int);
            left -= 1;
            left;
        }
        _ => {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"unrecognised attribute type in name field: %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                name_type as libc::c_int,
            );
            print_symbol(
                -(20 as libc::c_int),
                dcgettext(
                    0 as *const libc::c_char,
                    b"<unknown name type>\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
    }
    name = name.offset(1);
    name;
    text = 0 as *const libc::c_char;
    name_attribute = *name;
    match name_attribute as libc::c_int {
        1 => {
            text = dcgettext(
                0 as *const libc::c_char,
                b"<version>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            expected_types = string_expected.as_ptr();
            name = name.offset(1);
            name;
        }
        2 => {
            text = dcgettext(
                0 as *const libc::c_char,
                b"<stack prot>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            expected_types = b"!+*\0" as *const u8 as *const libc::c_char;
            name = name.offset(1);
            name;
        }
        3 => {
            text = dcgettext(
                0 as *const libc::c_char,
                b"<relro>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            expected_types = bool_expected.as_ptr();
            name = name.offset(1);
            name;
        }
        4 => {
            text = dcgettext(
                0 as *const libc::c_char,
                b"<stack size>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            expected_types = number_expected.as_ptr();
            name = name.offset(1);
            name;
        }
        5 => {
            text = dcgettext(
                0 as *const libc::c_char,
                b"<tool>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            expected_types = string_expected.as_ptr();
            name = name.offset(1);
            name;
        }
        6 => {
            text = dcgettext(
                0 as *const libc::c_char,
                b"<ABI>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            expected_types = b"$*\0" as *const u8 as *const libc::c_char;
            name = name.offset(1);
            name;
        }
        7 => {
            text = dcgettext(
                0 as *const libc::c_char,
                b"<PIC>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            expected_types = number_expected.as_ptr();
            name = name.offset(1);
            name;
        }
        8 => {
            text = dcgettext(
                0 as *const libc::c_char,
                b"<short enum>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            expected_types = bool_expected.as_ptr();
            name = name.offset(1);
            name;
        }
        _ => {
            if _sch_istable[(*name as libc::c_int & 0xff as libc::c_int) as usize]
                as libc::c_int
                & _sch_isprint as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                let mut len: libc::c_int = (strnlen(
                    name,
                    ((*pnote).namesz)
                        .wrapping_sub(
                            name.offset_from((*pnote).namedata) as libc::c_long
                                as libc::c_ulong,
                        ),
                ))
                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
                if len > left && do_wide == 0 {
                    len = left;
                }
                printf(b"%.*s:\0" as *const u8 as *const libc::c_char, len, name);
                left -= len;
                name = name.offset(len as isize);
            } else {
                static mut tmpbuf: [libc::c_char; 128] = [0; 128];
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"unrecognised byte in name field: %d\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    *name as libc::c_int,
                );
                sprintf(
                    tmpbuf.as_mut_ptr(),
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown:_%d>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    *name as libc::c_int,
                );
                text = tmpbuf.as_mut_ptr();
                name = name.offset(1);
                name;
            }
            expected_types = b"*$!+\0" as *const u8 as *const libc::c_char;
        }
    }
    if !text.is_null() {
        left -= printf(b"%s\0" as *const u8 as *const libc::c_char, text);
    }
    if (strchr(expected_types, name_type as libc::c_int)).is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"attribute does not have an expected type (%c)\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            name_type as libc::c_int,
        );
    }
    if name.offset_from((*pnote).namedata) as libc::c_long as libc::c_ulong
        > (*pnote).namesz
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt name field: namesz: %lu but parsing gets to %ld\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*pnote).namesz,
            name.offset_from((*pnote).namedata) as libc::c_long,
        );
        return 0 as libc::c_int != 0;
    }
    if left < 1 as libc::c_int && do_wide == 0 {
        return 1 as libc::c_int != 0;
    }
    match name_type as libc::c_int {
        42 => {
            let mut bytes: libc::c_uint = 0;
            let mut val: libc::c_ulonglong = 0 as libc::c_int as libc::c_ulonglong;
            let mut shift: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            let mut decoded: *mut libc::c_char = 0 as *mut libc::c_char;
            bytes = ((*pnote).namesz)
                .wrapping_sub(
                    name.offset_from((*pnote).namedata) as libc::c_long as libc::c_ulong,
                ) as libc::c_uint;
            if bytes > 0 as libc::c_int as libc::c_uint {
                bytes = bytes.wrapping_sub(1);
                bytes;
            }
            if bytes as libc::c_ulong
                > ::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong
            {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"corrupt numeric name field: too many bytes in the value: %x\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    bytes,
                );
                bytes = ::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong
                    as libc::c_uint;
            }
            loop {
                let fresh45 = bytes;
                bytes = bytes.wrapping_sub(1);
                if !(fresh45 != 0) {
                    break;
                }
                let fresh46 = name;
                name = name.offset(1);
                let mut byte: libc::c_ulonglong = (*fresh46 as libc::c_int
                    & 0xff as libc::c_int) as libc::c_ulonglong;
                val |= byte << shift;
                shift = shift.wrapping_add(8 as libc::c_int as libc::c_uint);
            }
            match name_attribute as libc::c_int {
                7 => {
                    match val {
                        0 => {
                            decoded = b"static\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        1 => {
                            decoded = b"pic\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        2 => {
                            decoded = b"PIC\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        3 => {
                            decoded = b"pie\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        4 => {
                            decoded = b"PIE\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        _ => {}
                    }
                }
                2 => {
                    match val {
                        0 => {
                            decoded = b"off\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        1 => {
                            decoded = b"on\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        2 => {
                            decoded = b"all\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        3 => {
                            decoded = b"strong\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        4 => {
                            decoded = b"explicit\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
            if !decoded.is_null() {
                print_symbol(-left, decoded);
                left = 0 as libc::c_int;
            } else if val == 0 as libc::c_int as libc::c_ulonglong {
                printf(b"0x0\0" as *const u8 as *const libc::c_char);
                left -= 3 as libc::c_int;
            } else if do_wide != 0 {
                left -= printf(b"0x%llx\0" as *const u8 as *const libc::c_char, val);
            } else {
                left
                    -= printf(
                        b"0x%-.*llx\0" as *const u8 as *const libc::c_char,
                        left,
                        val,
                    );
            }
        }
        36 => {
            left = (left as libc::c_uint).wrapping_sub(print_symbol(-left, name))
                as libc::c_int as libc::c_int;
        }
        43 => {
            left = (left as libc::c_uint)
                .wrapping_sub(
                    print_symbol(-left, b"true\0" as *const u8 as *const libc::c_char),
                ) as libc::c_int as libc::c_int;
        }
        33 => {
            left = (left as libc::c_uint)
                .wrapping_sub(
                    print_symbol(-left, b"false\0" as *const u8 as *const libc::c_char),
                ) as libc::c_int as libc::c_int;
        }
        _ => {}
    }
    if do_wide != 0 && left > 0 as libc::c_int {
        printf(
            b"%-*s\0" as *const u8 as *const libc::c_char,
            left,
            b" \0" as *const u8 as *const libc::c_char,
        );
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn process_note(
    mut pnote: *mut Elf_Internal_Note,
    mut filedata: *mut Filedata,
) -> bool {
    let mut name: *const libc::c_char = if (*pnote).namesz != 0 {
        (*pnote).namedata as *const libc::c_char
    } else {
        b"(NONE)\0" as *const u8 as *const libc::c_char
    };
    let mut nt: *const libc::c_char = 0 as *const libc::c_char;
    if (*pnote).namesz == 0 as libc::c_int as libc::c_ulong {
        nt = get_note_type(filedata, (*pnote).type_0 as libc::c_uint);
    } else if startswith(
        (*pnote).namedata,
        b"GNU\0" as *const u8 as *const libc::c_char,
    ) {
        nt = get_gnu_elf_note_type((*pnote).type_0 as libc::c_uint);
    } else if startswith(
        (*pnote).namedata,
        b"FreeBSD\0" as *const u8 as *const libc::c_char,
    ) {
        nt = get_freebsd_elfcore_note_type(filedata, (*pnote).type_0 as libc::c_uint);
    } else if startswith(
        (*pnote).namedata,
        b"NetBSD-CORE\0" as *const u8 as *const libc::c_char,
    ) {
        nt = get_netbsd_elfcore_note_type(filedata, (*pnote).type_0 as libc::c_uint);
    } else if startswith(
        (*pnote).namedata,
        b"NetBSD\0" as *const u8 as *const libc::c_char,
    ) {
        return process_netbsd_elf_note(pnote)
    } else if startswith(
        (*pnote).namedata,
        b"PaX\0" as *const u8 as *const libc::c_char,
    ) {
        return process_netbsd_elf_note(pnote)
    } else if startswith(
        (*pnote).namedata,
        b"SPU/\0" as *const u8 as *const libc::c_char,
    ) {
        nt = ((*pnote).namedata).offset(4 as libc::c_int as isize);
        name = b"SPU\0" as *const u8 as *const libc::c_char;
    } else if startswith(
        (*pnote).namedata,
        b"IPF/VMS\0" as *const u8 as *const libc::c_char,
    ) {
        nt = get_ia64_vms_note_type((*pnote).type_0 as libc::c_uint);
    } else if startswith(
        (*pnote).namedata,
        b"stapsdt\0" as *const u8 as *const libc::c_char,
    ) {
        nt = get_stapsdt_note_type((*pnote).type_0 as libc::c_uint);
    } else {
        nt = get_note_type(filedata, (*pnote).type_0 as libc::c_uint);
    }
    printf(b"  \0" as *const u8 as *const libc::c_char);
    if (startswith((*pnote).namedata, b"GA\0" as *const u8 as *const libc::c_char)
        as libc::c_int != 0
        && !(strchr(
            b"*$!+\0" as *const u8 as *const libc::c_char,
            *((*pnote).namedata).offset(2 as libc::c_int as isize) as libc::c_int,
        ))
            .is_null()
        || !(strchr(
            b"*$!+\0" as *const u8 as *const libc::c_char,
            *((*pnote).namedata).offset(0 as libc::c_int as isize) as libc::c_int,
        ))
            .is_null())
        && ((*pnote).type_0 == 0x100 as libc::c_int as libc::c_ulong
            || (*pnote).type_0 == 0x101 as libc::c_int as libc::c_ulong)
    {
        print_gnu_build_attribute_name(pnote);
    } else {
        print_symbol(-(20 as libc::c_int), name);
    }
    if do_wide != 0 {
        printf(
            b" 0x%08lx\t%s\t\0" as *const u8 as *const libc::c_char,
            (*pnote).descsz,
            nt,
        );
    } else {
        printf(
            b" 0x%08lx\t%s\n\0" as *const u8 as *const libc::c_char,
            (*pnote).descsz,
            nt,
        );
    }
    if startswith((*pnote).namedata, b"IPF/VMS\0" as *const u8 as *const libc::c_char) {
        return print_ia64_vms_note(pnote)
    } else if startswith(
        (*pnote).namedata,
        b"GNU\0" as *const u8 as *const libc::c_char,
    ) {
        return print_gnu_note(filedata, pnote)
    } else if startswith(
        (*pnote).namedata,
        b"stapsdt\0" as *const u8 as *const libc::c_char,
    ) {
        return print_stapsdt_note(pnote)
    } else if startswith(
        (*pnote).namedata,
        b"CORE\0" as *const u8 as *const libc::c_char,
    ) {
        return print_core_note(pnote)
    } else if (startswith((*pnote).namedata, b"GA\0" as *const u8 as *const libc::c_char)
        as libc::c_int != 0
        && !(strchr(
            b"*$!+\0" as *const u8 as *const libc::c_char,
            *((*pnote).namedata).offset(2 as libc::c_int as isize) as libc::c_int,
        ))
            .is_null()
        || !(strchr(
            b"*$!+\0" as *const u8 as *const libc::c_char,
            *((*pnote).namedata).offset(0 as libc::c_int as isize) as libc::c_int,
        ))
            .is_null())
        && ((*pnote).type_0 == 0x100 as libc::c_int as libc::c_ulong
            || (*pnote).type_0 == 0x101 as libc::c_int as libc::c_ulong)
    {
        return print_gnu_build_attribute_description(pnote, filedata)
    }
    if (*pnote).descsz != 0 {
        let mut i: libc::c_ulong = 0;
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"   description data: \0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        i = 0 as libc::c_int as libc::c_ulong;
        while i < (*pnote).descsz {
            printf(
                b"%02x \0" as *const u8 as *const libc::c_char,
                *((*pnote).descdata).offset(i as isize) as libc::c_int
                    & 0xff as libc::c_int,
            );
            i = i.wrapping_add(1);
            i;
        }
        if do_wide == 0 {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
    }
    if do_wide != 0 {
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn process_notes_at(
    mut filedata: *mut Filedata,
    mut section: *mut Elf_Internal_Shdr,
    mut offset: bfd_vma,
    mut length: bfd_vma,
    mut align: bfd_vma,
) -> bool {
    let mut pnotes: *mut Elf_External_Note = 0 as *mut Elf_External_Note;
    let mut external: *mut Elf_External_Note = 0 as *mut Elf_External_Note;
    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut res: bool = 1 as libc::c_int != 0;
    if length <= 0 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    if !section.is_null() {
        pnotes = get_section_contents(section, filedata) as *mut Elf_External_Note;
        if !pnotes.is_null() {
            if !apply_relocations(
                filedata,
                section,
                pnotes as *mut libc::c_uchar,
                length,
                0 as *mut *mut libc::c_void,
                0 as *mut libc::c_ulong,
            ) {
                free(pnotes as *mut libc::c_void);
                return 0 as libc::c_int != 0;
            }
        }
    } else {
        pnotes = get_data(
            0 as *mut libc::c_void,
            filedata,
            offset,
            1 as libc::c_int as bfd_size_type,
            length,
            dcgettext(
                0 as *const libc::c_char,
                b"notes\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        ) as *mut Elf_External_Note;
    }
    if pnotes.is_null() {
        return 0 as libc::c_int != 0;
    }
    external = pnotes;
    if (*filedata).is_separate {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"In linked file '%s': \0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_name,
        );
    } else {
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    if !section.is_null() {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Displaying notes found in: %s\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            printable_section_name(filedata, section),
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Displaying notes found at file offset 0x%08lx with length 0x%08lx:\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            offset,
            length,
        );
    }
    if align < 4 as libc::c_int as libc::c_ulong {
        align = 4 as libc::c_int as bfd_vma;
    } else if align != 4 as libc::c_int as libc::c_ulong
        && align != 8 as libc::c_int as libc::c_ulong
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Corrupt note: alignment %ld, expecting 4 or 8\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            align as libc::c_long,
        );
        free(pnotes as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  %-20s %-10s\tDescription\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        dcgettext(
            0 as *const libc::c_char,
            b"Owner\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        dcgettext(
            0 as *const libc::c_char,
            b"Data size\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    end = (pnotes as *mut libc::c_char).offset(length as isize);
    while (external as *mut libc::c_char) < end {
        let mut inote: Elf_Internal_Note = Elf_Internal_Note {
            namesz: 0,
            descsz: 0,
            type_0: 0,
            namedata: 0 as *mut libc::c_char,
            descdata: 0 as *mut libc::c_char,
            descpos: 0,
        };
        let mut min_notesz: size_t = 0;
        let mut next: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut temp: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut data_remaining: size_t = end.offset_from(external as *mut libc::c_char)
            as libc::c_long as size_t;
        if !is_ia64_vms(filedata) {
            min_notesz = 12 as libc::c_ulong;
            if data_remaining < min_notesz {
                warn(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"Corrupt note: only %ld byte remains, not enough for a full note\n\0"
                            as *const u8 as *const libc::c_char,
                        b"Corrupt note: only %ld bytes remain, not enough for a full note\n\0"
                            as *const u8 as *const libc::c_char,
                        data_remaining,
                        5 as libc::c_int,
                    ),
                    data_remaining as libc::c_long,
                );
                break;
            } else {
                data_remaining = (data_remaining as libc::c_ulong)
                    .wrapping_sub(min_notesz) as size_t as size_t;
                inote
                    .type_0 = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*external).type_0).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                inote
                    .namesz = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*external).namesz).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                inote.namedata = ((*external).name).as_mut_ptr();
                inote
                    .descsz = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*external).descsz).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong
                        as libc::c_uint,
                );
                inote
                    .descdata = (external as *mut libc::c_char)
                    .offset(
                        ((12 as libc::c_ulong)
                            .wrapping_add(inote.namesz)
                            .wrapping_add(
                                align.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            ) & !align.wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            as isize,
                    );
                inote
                    .descpos = offset
                    .wrapping_add(
                        (inote.descdata).offset_from(pnotes as *mut libc::c_char)
                            as libc::c_long as libc::c_ulong,
                    );
                next = (external as *mut libc::c_char)
                    .offset(
                        (((12 as libc::c_ulong)
                            .wrapping_add(inote.namesz)
                            .wrapping_add(
                                align.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            ) & !align.wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            .wrapping_add(inote.descsz)
                            .wrapping_add(
                                align.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            ) & !align.wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            as isize,
                    );
            }
        } else {
            let mut vms_external: *mut Elf64_External_VMS_Note = 0
                as *mut Elf64_External_VMS_Note;
            min_notesz = 24 as libc::c_ulong;
            if data_remaining < min_notesz {
                warn(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"Corrupt note: only %ld byte remains, not enough for a full note\n\0"
                            as *const u8 as *const libc::c_char,
                        b"Corrupt note: only %ld bytes remain, not enough for a full note\n\0"
                            as *const u8 as *const libc::c_char,
                        data_remaining,
                        5 as libc::c_int,
                    ),
                    data_remaining as libc::c_long,
                );
                break;
            } else {
                data_remaining = (data_remaining as libc::c_ulong)
                    .wrapping_sub(min_notesz) as size_t as size_t;
                vms_external = external as *mut Elf64_External_VMS_Note;
                inote
                    .type_0 = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*vms_external).type_0).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                        as libc::c_uint,
                );
                inote
                    .namesz = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*vms_external).namesz).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                        as libc::c_uint,
                );
                inote.namedata = ((*vms_external).name).as_mut_ptr();
                inote
                    .descsz = byte_get
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*vms_external).descsz).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong
                        as libc::c_uint,
                );
                inote
                    .descdata = (inote.namedata)
                    .offset(
                        ((inote.namesz)
                            .wrapping_add(
                                (1 as libc::c_int as bfd_vma) << 3 as libc::c_int,
                            )
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                            & ((1 as libc::c_int as bfd_vma) << 3 as libc::c_int)
                                .wrapping_neg()) as isize,
                    );
                inote
                    .descpos = offset
                    .wrapping_add(
                        (inote.descdata).offset_from(pnotes as *mut libc::c_char)
                            as libc::c_long as libc::c_ulong,
                    );
                next = (inote.descdata)
                    .offset(
                        ((inote.descsz)
                            .wrapping_add(
                                (1 as libc::c_int as bfd_vma) << 3 as libc::c_int,
                            )
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                            & ((1 as libc::c_int as bfd_vma) << 3 as libc::c_int)
                                .wrapping_neg()) as isize,
                    );
            }
        }
        if ((inote.descdata).offset_from(inote.namedata) as libc::c_long as size_t)
            < inote.namesz
            || (inote.descdata).offset_from(inote.namedata) as libc::c_long as size_t
                > data_remaining
            || (next.offset_from(inote.descdata) as libc::c_long as size_t)
                < inote.descsz
            || next.offset_from(inote.descdata) as libc::c_long as size_t
                > data_remaining
                    .wrapping_sub(
                        (inote.descdata).offset_from(inote.namedata) as libc::c_long
                            as size_t,
                    )
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"note with invalid namesz and/or descsz found at offset 0x%lx\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (external as *mut libc::c_char).offset_from(pnotes as *mut libc::c_char)
                    as libc::c_long as libc::c_ulong,
            );
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx, alignment: %u\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                inote.type_0,
                inote.namesz,
                inote.descsz,
                align as libc::c_int,
            );
            break;
        } else {
            external = next as *mut Elf_External_Note;
            if inote.namesz > 0 as libc::c_int as libc::c_ulong
                && *(inote.namedata)
                    .offset(
                        (inote.namesz).wrapping_sub(1 as libc::c_int as libc::c_ulong)
                            as isize,
                    ) as libc::c_int != '\0' as i32
            {
                if (inote.descdata).offset_from(inote.namedata) as libc::c_long as size_t
                    == inote.namesz
                {
                    temp = malloc(
                        (inote.namesz).wrapping_add(1 as libc::c_int as libc::c_ulong),
                    ) as *mut libc::c_char;
                    if temp.is_null() {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Out of memory allocating space for inote name\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        res = 0 as libc::c_int != 0;
                        break;
                    } else {
                        memcpy(
                            temp as *mut libc::c_void,
                            inote.namedata as *const libc::c_void,
                            inote.namesz,
                        );
                        inote.namedata = temp;
                    }
                }
                *(inote.namedata)
                    .offset(inote.namesz as isize) = 0 as libc::c_int as libc::c_char;
            }
            if !process_note(&mut inote, filedata) {
                res = 0 as libc::c_int != 0;
            }
            free(temp as *mut libc::c_void);
            temp = 0 as *mut libc::c_char;
        }
    }
    free(pnotes as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn process_corefile_note_segments(
    mut filedata: *mut Filedata,
) -> bool {
    let mut segment: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut i: libc::c_uint = 0;
    let mut res: bool = 1 as libc::c_int != 0;
    if !get_program_headers(filedata) {
        return 1 as libc::c_int != 0;
    }
    i = 0 as libc::c_int as libc::c_uint;
    segment = (*filedata).program_headers;
    while i < (*filedata).file_header.e_phnum {
        if (*segment).p_type == 4 as libc::c_int as libc::c_ulong {
            if !process_notes_at(
                filedata,
                0 as *mut Elf_Internal_Shdr,
                (*segment).p_offset,
                (*segment).p_filesz,
                (*segment).p_align,
            ) {
                res = 0 as libc::c_int != 0;
            }
        }
        i = i.wrapping_add(1);
        i;
        segment = segment.offset(1);
        segment;
    }
    return res;
}
unsafe extern "C" fn process_v850_notes(
    mut filedata: *mut Filedata,
    mut offset: bfd_vma,
    mut length: bfd_vma,
) -> bool {
    let mut pnotes: *mut Elf_External_Note = 0 as *mut Elf_External_Note;
    let mut external: *mut Elf_External_Note = 0 as *mut Elf_External_Note;
    let mut end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut res: bool = 1 as libc::c_int != 0;
    if length <= 0 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    pnotes = get_data(
        0 as *mut libc::c_void,
        filedata,
        offset,
        1 as libc::c_int as bfd_size_type,
        length,
        dcgettext(
            0 as *const libc::c_char,
            b"v850 notes\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as *mut Elf_External_Note;
    if pnotes.is_null() {
        return 0 as libc::c_int != 0;
    }
    external = pnotes;
    end = (pnotes as *mut libc::c_char).offset(length as isize);
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\nDisplaying contents of Renesas V850 notes section at offset 0x%lx with length 0x%lx:\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        offset,
        length,
    );
    while (external as *mut libc::c_char)
        .offset(::core::mem::size_of::<Elf_External_Note>() as libc::c_ulong as isize)
        < end
    {
        let mut next: *mut Elf_External_Note = 0 as *mut Elf_External_Note;
        let mut inote: Elf_Internal_Note = Elf_Internal_Note {
            namesz: 0,
            descsz: 0,
            type_0: 0,
            namedata: 0 as *mut libc::c_char,
            descdata: 0 as *mut libc::c_char,
            descpos: 0,
        };
        inote
            .type_0 = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).type_0).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        inote
            .namesz = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).namesz).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        inote.namedata = ((*external).name).as_mut_ptr();
        inote
            .descsz = byte_get
            .expect(
                "non-null function pointer",
            )(
            ((*external).descsz).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        inote
            .descdata = (inote.namedata)
            .offset(
                ((inote.namesz)
                    .wrapping_add((1 as libc::c_int as bfd_vma) << 2 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    & ((1 as libc::c_int as bfd_vma) << 2 as libc::c_int).wrapping_neg())
                    as isize,
            );
        inote
            .descpos = offset
            .wrapping_add(
                (inote.descdata).offset_from(pnotes as *mut libc::c_char) as libc::c_long
                    as libc::c_ulong,
            );
        if inote.descdata < pnotes as *mut libc::c_char || inote.descdata >= end {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Corrupt note: name size is too big: %lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                inote.namesz,
            );
            inote.descdata = inote.namedata;
            inote.namesz = 0 as libc::c_int as libc::c_ulong;
        }
        next = (inote.descdata)
            .offset(
                ((inote.descsz)
                    .wrapping_add((1 as libc::c_int as bfd_vma) << 2 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    & ((1 as libc::c_int as bfd_vma) << 2 as libc::c_int).wrapping_neg())
                    as isize,
            ) as *mut Elf_External_Note;
        if next as *mut libc::c_char > end
            || (next as *mut libc::c_char) < pnotes as *mut libc::c_char
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"corrupt descsz found in note at offset 0x%lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (external as *mut libc::c_char).offset_from(pnotes as *mut libc::c_char)
                    as libc::c_long as libc::c_ulong,
            );
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                inote.type_0,
                inote.namesz,
                inote.descsz,
            );
            break;
        } else {
            external = next;
            if (inote.namedata).offset(inote.namesz as isize) > end
                || (inote.namedata).offset(inote.namesz as isize) < inote.namedata
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"corrupt namesz found in note at offset 0x%lx\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (external as *mut libc::c_char)
                        .offset_from(pnotes as *mut libc::c_char) as libc::c_long
                        as libc::c_ulong,
                );
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    inote.type_0,
                    inote.namesz,
                    inote.descsz,
                );
                break;
            } else {
                printf(
                    b"  %s: \0" as *const u8 as *const libc::c_char,
                    get_v850_elf_note_type(inote.type_0 as v850_notes),
                );
                if !print_v850_note(&mut inote) {
                    res = 0 as libc::c_int != 0;
                    printf(
                        b"<corrupt sizes: namesz: %lx, descsz: %lx>\n\0" as *const u8
                            as *const libc::c_char,
                        inote.namesz,
                        inote.descsz,
                    );
                }
            }
        }
    }
    free(pnotes as *mut libc::c_void);
    return res;
}
unsafe extern "C" fn process_note_sections(mut filedata: *mut Filedata) -> bool {
    let mut section: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: libc::c_ulong = 0;
    let mut n: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut res: bool = 1 as libc::c_int != 0;
    i = 0 as libc::c_int as libc::c_ulong;
    section = (*filedata).section_headers;
    while i < (*filedata).file_header.e_shnum as libc::c_ulong && !section.is_null() {
        if (*section).sh_type == 7 as libc::c_int as libc::c_uint {
            if !process_notes_at(
                filedata,
                section,
                (*section).sh_offset as bfd_vma,
                (*section).sh_size,
                (*section).sh_addralign,
            ) {
                res = 0 as libc::c_int != 0;
            }
            n = n.wrapping_add(1);
            n;
        }
        if ((*filedata).file_header.e_machine as libc::c_int == 36 as libc::c_int
            || (*filedata).file_header.e_machine as libc::c_int == 87 as libc::c_int
            || (*filedata).file_header.e_machine as libc::c_int == 0x9080 as libc::c_int)
            && (*section).sh_type == 0xa0000000 as libc::c_uint
        {
            if !process_v850_notes(
                filedata,
                (*section).sh_offset as bfd_vma,
                (*section).sh_size,
            ) {
                res = 0 as libc::c_int != 0;
            }
            n = n.wrapping_add(1);
            n;
        }
        i = i.wrapping_add(1);
        i;
        section = section.offset(1);
        section;
    }
    if n == 0 as libc::c_int as libc::c_uint {
        return process_corefile_note_segments(filedata);
    }
    return res;
}
unsafe extern "C" fn process_notes(mut filedata: *mut Filedata) -> bool {
    if !do_notes {
        return 1 as libc::c_int != 0;
    }
    if (*filedata).file_header.e_type as libc::c_int != 4 as libc::c_int {
        return process_note_sections(filedata);
    }
    if (*filedata).file_header.e_phnum > 0 as libc::c_int as libc::c_uint {
        return process_corefile_note_segments(filedata);
    }
    if (*filedata).is_separate {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"No notes found in linked file '%s'.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_name,
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"No notes found file.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn display_public_gnu_attributes(
    mut start: *mut libc::c_uchar,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Unknown GNU attribute: %s\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        start,
    );
    start = start
        .offset(
            strnlen(
                start as *mut libc::c_char,
                end.offset_from(start) as libc::c_long as size_t,
            ) as isize,
        );
    display_raw_attribute(start, end);
    return end as *mut libc::c_uchar;
}
unsafe extern "C" fn display_generic_attribute(
    mut start: *mut libc::c_uchar,
    mut tag: libc::c_uint,
    end: *const libc::c_uchar,
) -> *mut libc::c_uchar {
    if tag == 0 as libc::c_int as libc::c_uint {
        return end as *mut libc::c_uchar;
    }
    return display_tag_value(tag as libc::c_int, start, end);
}
unsafe extern "C" fn process_arch_specific(mut filedata: *mut Filedata) -> bool {
    if !do_arch {
        return 1 as libc::c_int != 0;
    }
    match (*filedata).file_header.e_machine as libc::c_int {
        45 | 93 | 195 => {
            return process_attributes(
                filedata,
                b"ARC\0" as *const u8 as *const libc::c_char,
                0x70000001 as libc::c_int as libc::c_uint,
                Some(
                    display_arc_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
                Some(
                    display_generic_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        40 => {
            return process_attributes(
                filedata,
                b"aeabi\0" as *const u8 as *const libc::c_char,
                0x70000003 as libc::c_int as libc::c_uint,
                Some(
                    display_arm_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
                Some(
                    display_generic_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        8 | 10 => return process_mips_specific(filedata),
        105 => {
            return process_attributes(
                filedata,
                b"mspabi\0" as *const u8 as *const libc::c_char,
                0x70000003 as libc::c_int as libc::c_uint,
                Some(
                    display_msp430_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
                Some(
                    display_msp430_gnu_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        243 => {
            return process_attributes(
                filedata,
                b"riscv\0" as *const u8 as *const libc::c_char,
                0x70000003 as libc::c_int as libc::c_uint,
                Some(
                    display_riscv_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
                Some(
                    display_generic_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        167 => return process_nds32_specific(filedata),
        4 => {
            return process_attributes(
                filedata,
                0 as *const libc::c_char,
                0x6ffffff5 as libc::c_int as libc::c_uint,
                None,
                Some(
                    display_m68k_gnu_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        20 | 21 => {
            return process_attributes(
                filedata,
                0 as *const libc::c_char,
                0x6ffffff5 as libc::c_int as libc::c_uint,
                None,
                Some(
                    display_power_gnu_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        22 | 41872 => {
            return process_attributes(
                filedata,
                0 as *const libc::c_char,
                0x6ffffff5 as libc::c_int as libc::c_uint,
                None,
                Some(
                    display_s390_gnu_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        2 | 18 | 43 => {
            return process_attributes(
                filedata,
                0 as *const libc::c_char,
                0x6ffffff5 as libc::c_int as libc::c_uint,
                None,
                Some(
                    display_sparc_gnu_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        140 => {
            return process_attributes(
                filedata,
                b"c6xabi\0" as *const u8 as *const libc::c_char,
                0x70000003 as libc::c_int as libc::c_uint,
                Some(
                    display_tic6x_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
                Some(
                    display_generic_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
        252 => {
            return process_attributes(
                filedata,
                b"csky\0" as *const u8 as *const libc::c_char,
                0x70000001 as libc::c_int as libc::c_uint,
                Some(
                    display_csky_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
                None,
            );
        }
        _ => {
            return process_attributes(
                filedata,
                b"gnu\0" as *const u8 as *const libc::c_char,
                0x6ffffff5 as libc::c_int as libc::c_uint,
                Some(
                    display_public_gnu_attributes
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
                Some(
                    display_generic_attribute
                        as unsafe extern "C" fn(
                            *mut libc::c_uchar,
                            libc::c_uint,
                            *const libc::c_uchar,
                        ) -> *mut libc::c_uchar,
                ),
            );
        }
    };
}
unsafe extern "C" fn get_file_header(mut filedata: *mut Filedata) -> bool {
    if fread(
        ((*filedata).file_header.e_ident).as_mut_ptr() as *mut libc::c_void,
        16 as libc::c_int as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        (*filedata).handle,
    ) != 1 as libc::c_int as libc::c_ulong
    {
        return 0 as libc::c_int != 0;
    }
    match (*filedata).file_header.e_ident[5 as libc::c_int as usize] as libc::c_int {
        2 => {
            byte_get = Some(
                byte_get_big_endian
                    as unsafe extern "C" fn(
                        *const libc::c_uchar,
                        libc::c_uint,
                    ) -> elf_vma,
            );
            byte_put = Some(
                byte_put_big_endian
                    as unsafe extern "C" fn(
                        *mut libc::c_uchar,
                        elf_vma,
                        libc::c_uint,
                    ) -> (),
            );
        }
        0 | 1 | _ => {
            byte_get = Some(
                byte_get_little_endian
                    as unsafe extern "C" fn(
                        *const libc::c_uchar,
                        libc::c_uint,
                    ) -> elf_vma,
            );
            byte_put = Some(
                byte_put_little_endian
                    as unsafe extern "C" fn(
                        *mut libc::c_uchar,
                        elf_vma,
                        libc::c_uint,
                    ) -> (),
            );
        }
    }
    is_32bit_elf = (*filedata).file_header.e_ident[4 as libc::c_int as usize]
        as libc::c_int != 2 as libc::c_int;
    if is_32bit_elf {
        let mut ehdr32: Elf32_External_Ehdr = Elf32_External_Ehdr {
            e_ident: [0; 16],
            e_type: [0; 2],
            e_machine: [0; 2],
            e_version: [0; 4],
            e_entry: [0; 4],
            e_phoff: [0; 4],
            e_shoff: [0; 4],
            e_flags: [0; 4],
            e_ehsize: [0; 2],
            e_phentsize: [0; 2],
            e_phnum: [0; 2],
            e_shentsize: [0; 2],
            e_shnum: [0; 2],
            e_shstrndx: [0; 2],
        };
        if fread(
            (ehdr32.e_type).as_mut_ptr() as *mut libc::c_void,
            (::core::mem::size_of::<Elf32_External_Ehdr>() as libc::c_ulong)
                .wrapping_sub(16 as libc::c_int as libc::c_ulong),
            1 as libc::c_int as libc::c_ulong,
            (*filedata).handle,
        ) != 1 as libc::c_int as libc::c_ulong
        {
            return 0 as libc::c_int != 0;
        }
        (*filedata)
            .file_header
            .e_type = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_type).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_ushort;
        (*filedata)
            .file_header
            .e_machine = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_machine).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_ushort;
        (*filedata)
            .file_header
            .e_version = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_version).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_entry = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_entry).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_phoff = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_phoff).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_shoff = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_shoff).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_flags = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_flags).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_ehsize = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_ehsize).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_phentsize = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_phentsize).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_phnum = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_phnum).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_shentsize = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_shentsize).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_shnum = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_shnum).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_shstrndx = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr32.e_shstrndx).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
    } else {
        let mut ehdr64: Elf64_External_Ehdr = Elf64_External_Ehdr {
            e_ident: [0; 16],
            e_type: [0; 2],
            e_machine: [0; 2],
            e_version: [0; 4],
            e_entry: [0; 8],
            e_phoff: [0; 8],
            e_shoff: [0; 8],
            e_flags: [0; 4],
            e_ehsize: [0; 2],
            e_phentsize: [0; 2],
            e_phnum: [0; 2],
            e_shentsize: [0; 2],
            e_shnum: [0; 2],
            e_shstrndx: [0; 2],
        };
        if (::core::mem::size_of::<bfd_vma>() as libc::c_ulong)
            < 8 as libc::c_int as libc::c_ulong
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"This instance of readelf has been built without support for a\n64 bit data type and so it cannot read 64 bit ELF files.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
        if fread(
            (ehdr64.e_type).as_mut_ptr() as *mut libc::c_void,
            (::core::mem::size_of::<Elf64_External_Ehdr>() as libc::c_ulong)
                .wrapping_sub(16 as libc::c_int as libc::c_ulong),
            1 as libc::c_int as libc::c_ulong,
            (*filedata).handle,
        ) != 1 as libc::c_int as libc::c_ulong
        {
            return 0 as libc::c_int != 0;
        }
        (*filedata)
            .file_header
            .e_type = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_type).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_ushort;
        (*filedata)
            .file_header
            .e_machine = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_machine).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_ushort;
        (*filedata)
            .file_header
            .e_version = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_version).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_entry = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_entry).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_phoff = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_phoff).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_shoff = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_shoff).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 8]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_flags = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_flags).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 4]>() as libc::c_ulong as libc::c_uint,
        );
        (*filedata)
            .file_header
            .e_ehsize = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_ehsize).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_phentsize = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_phentsize).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_phnum = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_phnum).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_shentsize = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_shentsize).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_shnum = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_shnum).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
        (*filedata)
            .file_header
            .e_shstrndx = byte_get
            .expect(
                "non-null function pointer",
            )(
            (ehdr64.e_shstrndx).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_uchar; 2]>() as libc::c_ulong as libc::c_uint,
        ) as libc::c_uint;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn free_filedata(mut filedata: *mut Filedata) {
    free((*filedata).program_interpreter as *mut libc::c_void);
    free((*filedata).program_headers as *mut libc::c_void);
    free((*filedata).section_headers as *mut libc::c_void);
    free((*filedata).string_table as *mut libc::c_void);
    free((*filedata).dump.dump_sects as *mut libc::c_void);
    free((*filedata).dynamic_strings as *mut libc::c_void);
    free((*filedata).dynamic_symbols as *mut libc::c_void);
    free((*filedata).dynamic_syminfo as *mut libc::c_void);
    free((*filedata).dynamic_section as *mut libc::c_void);
    while !((*filedata).symtab_shndx_list).is_null() {
        let mut next: *mut elf_section_list = (*(*filedata).symtab_shndx_list).next;
        free((*filedata).symtab_shndx_list as *mut libc::c_void);
        (*filedata).symtab_shndx_list = next;
    }
    free((*filedata).section_headers_groups as *mut libc::c_void);
    if !((*filedata).section_groups).is_null() {
        let mut i: size_t = 0;
        let mut g: *mut group_list = 0 as *mut group_list;
        let mut next_0: *mut group_list = 0 as *mut group_list;
        i = 0 as libc::c_int as size_t;
        while i < (*filedata).group_count {
            g = (*((*filedata).section_groups).offset(i as isize)).root;
            while !g.is_null() {
                next_0 = (*g).next;
                free(g as *mut libc::c_void);
                g = next_0;
            }
            i = i.wrapping_add(1);
            i;
        }
        free((*filedata).section_groups as *mut libc::c_void);
    }
    memset(
        &mut (*filedata).section_headers as *mut *mut Elf_Internal_Shdr
            as *mut libc::c_void,
        0 as libc::c_int,
        (::core::mem::size_of::<Filedata>() as libc::c_ulong)
            .wrapping_sub(136 as libc::c_ulong),
    );
}
unsafe extern "C" fn close_file(mut filedata: *mut Filedata) {
    if !filedata.is_null() {
        if !((*filedata).handle).is_null() {
            fclose((*filedata).handle);
        }
        free(filedata as *mut libc::c_void);
    }
}
unsafe extern "C" fn open_file(
    mut pathname: *const libc::c_char,
    mut is_separate: bool,
) -> *mut Filedata {
    let mut statbuf: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut filedata: *mut Filedata = 0 as *mut Filedata;
    if !(stat(pathname, &mut statbuf) < 0 as libc::c_int
        || !(statbuf.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o100000 as libc::c_int as libc::c_uint))
    {
        filedata = calloc(
            1 as libc::c_int as libc::c_ulong,
            ::core::mem::size_of::<Filedata>() as libc::c_ulong,
        ) as *mut Filedata;
        if !filedata.is_null() {
            (*filedata)
                .handle = fopen(pathname, b"rb\0" as *const u8 as *const libc::c_char);
            if !((*filedata).handle).is_null() {
                (*filedata).file_size = statbuf.st_size as bfd_size_type;
                (*filedata).file_name = pathname;
                (*filedata).is_separate = is_separate;
                if get_file_header(filedata) {
                    if get_section_headers(filedata, 0 as libc::c_int != 0) {
                        return filedata;
                    }
                }
            }
        }
    }
    if !filedata.is_null() {
        if !((*filedata).handle).is_null() {
            fclose((*filedata).handle);
        }
        free(filedata as *mut libc::c_void);
    }
    return 0 as *mut Filedata;
}
unsafe extern "C" fn initialise_dump_sects(mut filedata: *mut Filedata) {
    if (*filedata).dump.num_dump_sects > cmdline.num_dump_sects {
        memset(
            (*filedata).dump.dump_sects as *mut libc::c_void,
            0 as libc::c_int,
            ((*filedata).dump.num_dump_sects as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<dump_type>() as libc::c_ulong),
        );
    }
    if cmdline.num_dump_sects > 0 as libc::c_int as libc::c_uint {
        if (*filedata).dump.num_dump_sects == 0 as libc::c_int as libc::c_uint {
            request_dump_bynumber(
                &mut (*filedata).dump,
                cmdline.num_dump_sects,
                0 as libc::c_int as dump_type,
            );
        }
        if (*filedata).dump.num_dump_sects >= cmdline.num_dump_sects {} else {
            __assert_fail(
                b"filedata->dump.num_dump_sects >= cmdline.num_dump_sects\0" as *const u8
                    as *const libc::c_char,
                b"readelf.c\0" as *const u8 as *const libc::c_char,
                21420 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 39],
                    &[libc::c_char; 39],
                >(b"void initialise_dump_sects(Filedata *)\0"))
                    .as_ptr(),
            );
        }
        'c_150389: {
            if (*filedata).dump.num_dump_sects >= cmdline.num_dump_sects {} else {
                __assert_fail(
                    b"filedata->dump.num_dump_sects >= cmdline.num_dump_sects\0"
                        as *const u8 as *const libc::c_char,
                    b"readelf.c\0" as *const u8 as *const libc::c_char,
                    21420 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 39],
                        &[libc::c_char; 39],
                    >(b"void initialise_dump_sects(Filedata *)\0"))
                        .as_ptr(),
                );
            }
        };
        memcpy(
            (*filedata).dump.dump_sects as *mut libc::c_void,
            cmdline.dump_sects as *const libc::c_void,
            (cmdline.num_dump_sects as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<dump_type>() as libc::c_ulong),
        );
    }
}
unsafe extern "C" fn process_object(mut filedata: *mut Filedata) -> bool {
    let mut have_separate_files: bool = false;
    let mut i: libc::c_uint = 0;
    let mut res: bool = false;
    if !get_file_header(filedata) {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"%s: Failed to read file header\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_name,
        );
        return 0 as libc::c_int != 0;
    }
    i = (::core::mem::size_of::<[bfd_vma; 16]>() as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<bfd_vma>() as libc::c_ulong)
        as libc::c_uint;
    loop {
        let fresh47 = i;
        i = i.wrapping_sub(1);
        if !(fresh47 != 0) {
            break;
        }
        (*filedata).version_info[i as usize] = 0 as libc::c_int as bfd_vma;
    }
    i = (::core::mem::size_of::<[bfd_vma; 32]>() as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<bfd_vma>() as libc::c_ulong)
        as libc::c_uint;
    loop {
        let fresh48 = i;
        i = i.wrapping_sub(1);
        if !(fresh48 != 0) {
            break;
        }
        (*filedata).dynamic_info[i as usize] = 0 as libc::c_int as bfd_vma;
    }
    (*filedata).dynamic_info_DT_GNU_HASH = 0 as libc::c_int as bfd_vma;
    (*filedata).dynamic_info_DT_MIPS_XHASH = 0 as libc::c_int as bfd_vma;
    if show_name {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nFile: %s\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*filedata).file_name,
        );
    }
    initialise_dump_sects(filedata);
    get_section_headers(filedata, 1 as libc::c_int != 0);
    if !process_file_header(filedata) {
        res = 0 as libc::c_int != 0;
    } else {
        free((*filedata).section_headers as *mut libc::c_void);
        (*filedata).section_headers = 0 as *mut Elf_Internal_Shdr;
        if !process_section_headers(filedata) {
            do_arch = 0 as libc::c_int != 0;
            do_dump = do_arch;
            do_version = do_dump;
            do_unwind = do_version;
            if !do_using_dynamic {
                do_reloc = 0 as libc::c_int != 0;
                do_dyn_syms = do_reloc;
                do_syms = do_dyn_syms;
            }
        }
        if !process_section_groups(filedata) {
            do_unwind = 0 as libc::c_int != 0;
        }
        process_program_headers(filedata);
        res = process_dynamic_section(filedata);
        if !process_relocs(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if !process_unwind(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if !process_symbol_table(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if !process_lto_symbol_tables(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if !process_syminfo(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if !process_version_sections(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if (*filedata).file_header.e_shstrndx != 0 as libc::c_int as libc::c_uint {
            have_separate_files = load_separate_debug_files(
                filedata as *mut libc::c_void,
                (*filedata).file_name,
            );
        } else {
            have_separate_files = 0 as libc::c_int != 0;
        }
        if !process_section_contents(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if have_separate_files {
            let mut d: *mut separate_info = 0 as *mut separate_info;
            d = first_separate_info;
            while !d.is_null() {
                initialise_dump_sects((*d).handle as *mut Filedata);
                if process_links as libc::c_int != 0
                    && !process_file_header((*d).handle as *mut Filedata)
                {
                    res = 0 as libc::c_int != 0;
                } else if !process_section_headers((*d).handle as *mut Filedata) {
                    res = 0 as libc::c_int != 0;
                } else if !process_section_contents((*d).handle as *mut Filedata) {
                    res = 0 as libc::c_int != 0;
                } else if process_links {
                    if !process_section_groups((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                    process_program_headers((*d).handle as *mut Filedata);
                    if !process_dynamic_section((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                    if !process_relocs((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                    if !process_unwind((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                    if !process_symbol_table((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                    if !process_lto_symbol_tables((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                    if !process_syminfo((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                    if !process_version_sections((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                    if !process_notes((*d).handle as *mut Filedata) {
                        res = 0 as libc::c_int != 0;
                    }
                }
                d = (*d).next;
            }
        }
        if !process_notes(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if !process_gnu_liblist(filedata) {
            res = 0 as libc::c_int != 0;
        }
        if !process_arch_specific(filedata) {
            res = 0 as libc::c_int != 0;
        }
    }
    free_filedata(filedata);
    free_debug_memory();
    return res;
}
unsafe extern "C" fn process_archive(
    mut filedata: *mut Filedata,
    mut is_thin_archive: bool,
) -> bool {
    let mut current_block: u64;
    let mut arch: archive_info = archive_info {
        file_name: 0 as *mut libc::c_char,
        file: 0 as *mut FILE,
        index_num: 0,
        index_array: 0 as *mut elf_vma,
        sym_table: 0 as *mut libc::c_char,
        sym_size: 0,
        longnames: 0 as *mut libc::c_char,
        longnames_size: 0,
        nested_member_origin: 0,
        next_arhdr_offset: 0,
        is_thin_archive: 0,
        uses_64bit_indices: 0,
        arhdr: ar_hdr {
            ar_name: [0; 16],
            ar_date: [0; 12],
            ar_uid: [0; 6],
            ar_gid: [0; 6],
            ar_mode: [0; 8],
            ar_size: [0; 10],
            ar_fmag: [0; 2],
        },
    };
    let mut nested_arch: archive_info = archive_info {
        file_name: 0 as *mut libc::c_char,
        file: 0 as *mut FILE,
        index_num: 0,
        index_array: 0 as *mut elf_vma,
        sym_table: 0 as *mut libc::c_char,
        sym_size: 0,
        longnames: 0 as *mut libc::c_char,
        longnames_size: 0,
        nested_member_origin: 0,
        next_arhdr_offset: 0,
        is_thin_archive: 0,
        uses_64bit_indices: 0,
        arhdr: ar_hdr {
            ar_name: [0; 16],
            ar_date: [0; 12],
            ar_uid: [0; 6],
            ar_gid: [0; 6],
            ar_mode: [0; 8],
            ar_size: [0; 10],
            ar_fmag: [0; 2],
        },
    };
    let mut got: size_t = 0;
    let mut ret: bool = 1 as libc::c_int != 0;
    show_name = 1 as libc::c_int != 0;
    arch.file_name = 0 as *mut libc::c_char;
    arch.file = 0 as *mut FILE;
    arch.index_array = 0 as *mut elf_vma;
    arch.sym_table = 0 as *mut libc::c_char;
    arch.longnames = 0 as *mut libc::c_char;
    nested_arch.file_name = 0 as *mut libc::c_char;
    nested_arch.file = 0 as *mut FILE;
    nested_arch.index_array = 0 as *mut elf_vma;
    nested_arch.sym_table = 0 as *mut libc::c_char;
    nested_arch.longnames = 0 as *mut libc::c_char;
    if setup_archive(
        &mut arch,
        (*filedata).file_name,
        (*filedata).handle,
        (*filedata).file_size as off_t,
        is_thin_archive as libc::c_int,
        do_archive_index as libc::c_int,
    ) != 0 as libc::c_int
    {
        ret = 0 as libc::c_int != 0;
    } else {
        if do_archive_index {
            if (arch.sym_table).is_null() {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"%s: unable to dump the index as none was found\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_name,
                );
                current_block = 3123434771885419771;
            } else {
                let mut i: libc::c_ulong = 0;
                let mut l: libc::c_ulong = 0;
                let mut current_pos: libc::c_ulong = 0;
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Index of archive %s: (%lu entries, 0x%lx bytes in the symbol table)\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*filedata).file_name,
                    arch.index_num,
                    arch.sym_size,
                );
                current_pos = ftell((*filedata).handle) as libc::c_ulong;
                l = 0 as libc::c_int as libc::c_ulong;
                i = l;
                while i < arch.index_num {
                    if i == 0 as libc::c_int as libc::c_ulong
                        || i > 0 as libc::c_int as libc::c_ulong
                            && *(arch.index_array).offset(i as isize)
                                != *(arch.index_array)
                                    .offset(
                                        i.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                                    )
                    {
                        let mut member_name: *mut libc::c_char = get_archive_member_name_at(
                            &mut arch,
                            *(arch.index_array).offset(i as isize),
                            &mut nested_arch,
                        );
                        if !member_name.is_null() {
                            let mut qualified_name: *mut libc::c_char = make_qualified_name(
                                &mut arch,
                                &mut nested_arch,
                                member_name,
                            );
                            if !qualified_name.is_null() {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Contents of binary %s at offset \0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    qualified_name,
                                );
                                print_vma(
                                    *(arch.index_array).offset(i as isize),
                                    PREFIX_HEX,
                                );
                                putchar('\n' as i32);
                                free(qualified_name as *mut libc::c_void);
                            }
                            free(member_name as *mut libc::c_void);
                        }
                    }
                    if l >= arch.sym_size {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"%s: end of the symbol table reached before the end of the index\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*filedata).file_name,
                        );
                        ret = 0 as libc::c_int != 0;
                        break;
                    } else {
                        printf(
                            b"\t%.*s\n\0" as *const u8 as *const libc::c_char,
                            (arch.sym_size).wrapping_sub(l) as libc::c_int,
                            (arch.sym_table).offset(l as isize),
                        );
                        l = l
                            .wrapping_add(
                                (strnlen(
                                    (arch.sym_table).offset(l as isize),
                                    (arch.sym_size).wrapping_sub(l),
                                ))
                                    .wrapping_add(1 as libc::c_int as libc::c_ulong),
                            );
                        i = i.wrapping_add(1);
                        i;
                    }
                }
                if arch.uses_64bit_indices != 0 {
                    l = l.wrapping_add(7 as libc::c_int as libc::c_ulong)
                        & !(7 as libc::c_int) as libc::c_ulong;
                } else {
                    l = l.wrapping_add(l & 1 as libc::c_int as libc::c_ulong);
                }
                if l < arch.sym_size {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"%s: %ld byte remains in the symbol table, but without corresponding entries in the index table\n\0"
                                as *const u8 as *const libc::c_char,
                            b"%s: %ld bytes remain in the symbol table, but without corresponding entries in the index table\n\0"
                                as *const u8 as *const libc::c_char,
                            (arch.sym_size).wrapping_sub(l),
                            5 as libc::c_int,
                        ),
                        (*filedata).file_name,
                        (arch.sym_size).wrapping_sub(l),
                    );
                    ret = 0 as libc::c_int != 0;
                }
                if fseek(
                    (*filedata).handle,
                    current_pos as libc::c_long,
                    0 as libc::c_int,
                ) != 0 as libc::c_int
                {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%s: failed to seek back to start of object files in the archive\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*filedata).file_name,
                    );
                    ret = 0 as libc::c_int != 0;
                    current_block = 3885667202033955547;
                } else {
                    current_block = 3123434771885419771;
                }
            }
            match current_block {
                3885667202033955547 => {}
                _ => {
                    if !do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
                        && !do_segments && !do_header && !do_dump && !do_version
                        && !do_histogram && !do_debugging && !do_arch && !do_notes
                        && !do_section_groups && !do_dyn_syms
                    {
                        ret = 1 as libc::c_int != 0;
                        current_block = 3885667202033955547;
                    } else {
                        current_block = 17784502470059252271;
                    }
                }
            }
        } else {
            current_block = 17784502470059252271;
        }
        match current_block {
            3885667202033955547 => {}
            _ => {
                loop {
                    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut namelen: size_t = 0;
                    let mut qualified_name_0: *mut libc::c_char = 0 as *mut libc::c_char;
                    if fseek(
                        (*filedata).handle,
                        arch.next_arhdr_offset as libc::c_long,
                        0 as libc::c_int,
                    ) != 0 as libc::c_int
                    {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"%s: failed to seek to next archive header\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            arch.file_name,
                        );
                        ret = 0 as libc::c_int != 0;
                        break;
                    } else {
                        got = fread(
                            &mut arch.arhdr as *mut ar_hdr as *mut libc::c_void,
                            1 as libc::c_int as libc::c_ulong,
                            ::core::mem::size_of::<ar_hdr>() as libc::c_ulong,
                            (*filedata).handle,
                        );
                        if got != ::core::mem::size_of::<ar_hdr>() as libc::c_ulong {
                            if got == 0 as libc::c_int as libc::c_ulong {
                                break;
                            }
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"%s: failed to read archive header\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                arch.file_name,
                            );
                            ret = 0 as libc::c_int != 0;
                            break;
                        } else if memcmp(
                            (arch.arhdr.ar_fmag).as_mut_ptr() as *const libc::c_void,
                            b"`\n\0" as *const u8 as *const libc::c_char
                                as *const libc::c_void,
                            2 as libc::c_int as libc::c_ulong,
                        ) != 0 as libc::c_int
                        {
                            error(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"%s: did not find a valid archive header\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                arch.file_name,
                            );
                            ret = 0 as libc::c_int != 0;
                            break;
                        } else {
                            arch
                                .next_arhdr_offset = (arch.next_arhdr_offset)
                                .wrapping_add(
                                    ::core::mem::size_of::<ar_hdr>() as libc::c_ulong,
                                );
                            (*filedata)
                                .archive_file_size = strtoul(
                                (arch.arhdr.ar_size).as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            );
                            if (*filedata).archive_file_size
                                & 0o1 as libc::c_int as libc::c_ulong != 0
                            {
                                (*filedata)
                                    .archive_file_size = ((*filedata).archive_file_size)
                                    .wrapping_add(1);
                                (*filedata).archive_file_size;
                            }
                            name = get_archive_member_name(&mut arch, &mut nested_arch);
                            if name.is_null() {
                                error(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"%s: bad archive file name\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    arch.file_name,
                                );
                                ret = 0 as libc::c_int != 0;
                                break;
                            } else {
                                namelen = strlen(name);
                                qualified_name_0 = make_qualified_name(
                                    &mut arch,
                                    &mut nested_arch,
                                    name,
                                );
                                if qualified_name_0.is_null() {
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"%s: bad archive file name\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        arch.file_name,
                                    );
                                    free(name as *mut libc::c_void);
                                    ret = 0 as libc::c_int != 0;
                                    break;
                                } else {
                                    if is_thin_archive as libc::c_int != 0
                                        && arch.nested_member_origin
                                            == 0 as libc::c_int as libc::c_ulong
                                    {
                                        let mut member_filedata: *mut Filedata = 0 as *mut Filedata;
                                        let mut member_file_name: *mut libc::c_char = adjust_relative_path(
                                            (*filedata).file_name,
                                            name,
                                            namelen,
                                        );
                                        free(name as *mut libc::c_void);
                                        if member_file_name.is_null() {
                                            free(qualified_name_0 as *mut libc::c_void);
                                            ret = 0 as libc::c_int != 0;
                                            break;
                                        } else {
                                            member_filedata = open_file(
                                                member_file_name,
                                                0 as libc::c_int != 0,
                                            );
                                            if member_filedata.is_null() {
                                                error(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"Input file '%s' is not readable.\n\0" as *const u8
                                                            as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    member_file_name,
                                                );
                                                free(member_file_name as *mut libc::c_void);
                                                free(qualified_name_0 as *mut libc::c_void);
                                                ret = 0 as libc::c_int != 0;
                                                break;
                                            } else {
                                                (*filedata).archive_file_offset = arch.nested_member_origin;
                                                (*member_filedata).file_name = qualified_name_0;
                                                rewind((*member_filedata).handle);
                                                if !process_object(member_filedata) {
                                                    ret = 0 as libc::c_int != 0;
                                                }
                                                close_file(member_filedata);
                                                free(member_file_name as *mut libc::c_void);
                                            }
                                        }
                                    } else if is_thin_archive {
                                        let mut thin_filedata: Filedata = Filedata {
                                            file_name: 0 as *const libc::c_char,
                                            is_separate: false,
                                            handle: 0 as *mut FILE,
                                            file_size: 0,
                                            file_header: Elf_Internal_Ehdr {
                                                e_ident: [0; 16],
                                                e_entry: 0,
                                                e_phoff: 0,
                                                e_shoff: 0,
                                                e_version: 0,
                                                e_flags: 0,
                                                e_type: 0,
                                                e_machine: 0,
                                                e_ehsize: 0,
                                                e_phentsize: 0,
                                                e_phnum: 0,
                                                e_shentsize: 0,
                                                e_shnum: 0,
                                                e_shstrndx: 0,
                                            },
                                            archive_file_offset: 0,
                                            archive_file_size: 0,
                                            section_headers: 0 as *mut Elf_Internal_Shdr,
                                            program_headers: 0 as *mut Elf_Internal_Phdr,
                                            string_table: 0 as *mut libc::c_char,
                                            string_table_length: 0,
                                            dynamic_addr: 0,
                                            dynamic_size: 0,
                                            dynamic_nent: 0,
                                            dynamic_section: 0 as *mut Elf_Internal_Dyn,
                                            dynamic_strtab_section: 0 as *mut Elf_Internal_Shdr,
                                            dynamic_strings: 0 as *mut libc::c_char,
                                            dynamic_strings_length: 0,
                                            dynamic_symtab_section: 0 as *mut Elf_Internal_Shdr,
                                            num_dynamic_syms: 0,
                                            dynamic_symbols: 0 as *mut Elf_Internal_Sym,
                                            version_info: [0; 16],
                                            dynamic_syminfo_nent: 0,
                                            dynamic_syminfo: 0 as *mut Elf_Internal_Syminfo,
                                            dynamic_syminfo_offset: 0,
                                            nbuckets: 0,
                                            nchains: 0,
                                            buckets: 0 as *mut bfd_vma,
                                            chains: 0 as *mut bfd_vma,
                                            ngnubuckets: 0,
                                            ngnuchains: 0,
                                            gnubuckets: 0 as *mut bfd_vma,
                                            gnuchains: 0 as *mut bfd_vma,
                                            mipsxlat: 0 as *mut bfd_vma,
                                            gnusymidx: 0,
                                            program_interpreter: 0 as *mut libc::c_char,
                                            dynamic_info: [0; 32],
                                            dynamic_info_DT_GNU_HASH: 0,
                                            dynamic_info_DT_MIPS_XHASH: 0,
                                            symtab_shndx_list: 0 as *mut elf_section_list,
                                            group_count: 0,
                                            section_groups: 0 as *mut group,
                                            section_headers_groups: 0 as *mut *mut group,
                                            dump: dump_data {
                                                dump_sects: 0 as *const dump_type as *mut dump_type,
                                                num_dump_sects: 0,
                                            },
                                        };
                                        memset(
                                            &mut thin_filedata as *mut Filedata as *mut libc::c_void,
                                            0 as libc::c_int,
                                            ::core::mem::size_of::<Filedata>() as libc::c_ulong,
                                        );
                                        if (nested_arch.file).is_null() {
                                            error(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"%s: contains corrupt thin archive: %s\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                qualified_name_0,
                                                name,
                                            );
                                            free(qualified_name_0 as *mut libc::c_void);
                                            free(name as *mut libc::c_void);
                                            ret = 0 as libc::c_int != 0;
                                            break;
                                        } else {
                                            free(name as *mut libc::c_void);
                                            (*filedata)
                                                .archive_file_offset = (arch.nested_member_origin)
                                                .wrapping_add(
                                                    ::core::mem::size_of::<ar_hdr>() as libc::c_ulong,
                                                );
                                            if fseek(
                                                nested_arch.file,
                                                (*filedata).archive_file_offset as libc::c_long,
                                                0 as libc::c_int,
                                            ) != 0 as libc::c_int
                                            {
                                                error(
                                                    dcgettext(
                                                        0 as *const libc::c_char,
                                                        b"%s: failed to seek to archive member.\n\0" as *const u8
                                                            as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    nested_arch.file_name,
                                                );
                                                free(qualified_name_0 as *mut libc::c_void);
                                                ret = 0 as libc::c_int != 0;
                                                break;
                                            } else {
                                                thin_filedata.handle = nested_arch.file;
                                                thin_filedata.file_name = qualified_name_0;
                                                if !process_object(&mut thin_filedata) {
                                                    ret = 0 as libc::c_int != 0;
                                                }
                                            }
                                        }
                                    } else {
                                        free(name as *mut libc::c_void);
                                        (*filedata).archive_file_offset = arch.next_arhdr_offset;
                                        (*filedata).file_name = qualified_name_0;
                                        if !process_object(filedata) {
                                            ret = 0 as libc::c_int != 0;
                                        }
                                        arch
                                            .next_arhdr_offset = (arch.next_arhdr_offset)
                                            .wrapping_add((*filedata).archive_file_size);
                                        if arch.next_arhdr_offset < (*filedata).archive_file_size {
                                            arch
                                                .next_arhdr_offset = (1 as libc::c_ulong).wrapping_neg();
                                        }
                                    }
                                    free(qualified_name_0 as *mut libc::c_void);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if !(nested_arch.file).is_null() {
        fclose(nested_arch.file);
    }
    release_archive(&mut nested_arch);
    release_archive(&mut arch);
    return ret;
}
unsafe extern "C" fn process_file(mut file_name: *mut libc::c_char) -> bool {
    let mut filedata: *mut Filedata = 0 as *mut Filedata;
    let mut statbuf: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut armag: [libc::c_char; 8] = [0; 8];
    let mut ret: bool = 1 as libc::c_int != 0;
    if stat(file_name, &mut statbuf) < 0 as libc::c_int {
        if *__errno_location() == 2 as libc::c_int {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"'%s': No such file\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                file_name,
            );
        } else {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Could not locate '%s'.  System error message: %s\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                file_name,
                strerror(*__errno_location()),
            );
        }
        return 0 as libc::c_int != 0;
    }
    if !(statbuf.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint)
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"'%s' is not an ordinary file\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            file_name,
        );
        return 0 as libc::c_int != 0;
    }
    filedata = calloc(
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<Filedata>() as libc::c_ulong,
    ) as *mut Filedata;
    if filedata.is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory allocating file data structure\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int != 0;
    }
    (*filedata).file_name = file_name;
    (*filedata).handle = fopen(file_name, b"rb\0" as *const u8 as *const libc::c_char);
    if ((*filedata).handle).is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Input file '%s' is not readable.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            file_name,
        );
        free(filedata as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    if fread(
        armag.as_mut_ptr() as *mut libc::c_void,
        8 as libc::c_int as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        (*filedata).handle,
    ) != 1 as libc::c_int as libc::c_ulong
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"%s: Failed to read file's magic number\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            file_name,
        );
        fclose((*filedata).handle);
        free(filedata as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    (*filedata).file_size = statbuf.st_size as bfd_size_type;
    (*filedata).is_separate = 0 as libc::c_int != 0;
    if memcmp(
        armag.as_mut_ptr() as *const libc::c_void,
        b"!<arch>\n\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        8 as libc::c_int as libc::c_ulong,
    ) == 0 as libc::c_int
    {
        if !process_archive(filedata, 0 as libc::c_int != 0) {
            ret = 0 as libc::c_int != 0;
        }
    } else if memcmp(
        armag.as_mut_ptr() as *const libc::c_void,
        b"!<thin>\n\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        8 as libc::c_int as libc::c_ulong,
    ) == 0 as libc::c_int
    {
        if !process_archive(filedata, 1 as libc::c_int != 0) {
            ret = 0 as libc::c_int != 0;
        }
    } else {
        if do_archive_index as libc::c_int != 0 && !check_all {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"File %s is not an archive so its index cannot be displayed.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                file_name,
            );
        }
        rewind((*filedata).handle);
        (*filedata).archive_file_offset = 0 as libc::c_int as libc::c_ulong;
        (*filedata).archive_file_size = (*filedata).archive_file_offset;
        if !process_object(filedata) {
            ret = 0 as libc::c_int != 0;
        }
    }
    fclose((*filedata).handle);
    free((*filedata).section_headers as *mut libc::c_void);
    free((*filedata).program_headers as *mut libc::c_void);
    free((*filedata).string_table as *mut libc::c_void);
    free((*filedata).dump.dump_sects as *mut libc::c_void);
    free(filedata as *mut libc::c_void);
    free(ba_cache.strtab as *mut libc::c_void);
    ba_cache.strtab = 0 as *mut libc::c_char;
    free(ba_cache.symtab as *mut libc::c_void);
    ba_cache.symtab = 0 as *mut Elf_Internal_Sym;
    ba_cache.filedata = 0 as *mut Filedata;
    return ret;
}
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut err: libc::c_int = 0;
    setlocale(5 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
    setlocale(0 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
    bindtextdomain(
        b"binutils\0" as *const u8 as *const libc::c_char,
        b"/usr/local/share/locale\0" as *const u8 as *const libc::c_char,
    );
    textdomain(b"binutils\0" as *const u8 as *const libc::c_char);
    expandargv(&mut argc, &mut argv);
    parse_args(&mut cmdline, argc, argv);
    if optind < argc - 1 as libc::c_int {
        show_name = 1 as libc::c_int != 0;
    } else if optind >= argc {
        do_checks = 1 as libc::c_int != 0;
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Nothing to do.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        usage(stderr);
    }
    err = 0 as libc::c_int;
    while optind < argc {
        let fresh49 = optind;
        optind = optind + 1;
        if !process_file(*argv.offset(fresh49 as isize)) {
            err = 1 as libc::c_int;
        }
    }
    free(cmdline.dump_sects as *mut libc::c_void);
    free(dump_ctf_symtab_name as *mut libc::c_void);
    free(dump_ctf_strtab_name as *mut libc::c_void);
    free(dump_ctf_parent_name as *mut libc::c_void);
    return if err != 0 { 1 as libc::c_int } else { 0 as libc::c_int };
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::core::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
unsafe extern "C" fn run_static_initializers() {
    flags = [
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"WRITE\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"ALLOC\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"EXEC\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"MERGE\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"STRINGS\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"INFO LINK\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"LINK ORDER\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"OS NONCONF\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"GROUP\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"TLS\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"SHORT\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"NORECOV\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"VMS_GLOBAL\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"VMS_OVERLAID\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"VMS_SHARED\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"VMS_VECTOR\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"VMS_ALLOC_64BIT\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"VMS_PROTECTED\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 14]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"EXCLUDE\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"ORDERED\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"COMPRESSED\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"ENTRYSECT\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"ARM_PURECODE\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 13]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"COMDEF\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"GNU_MBIND\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"VLE\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_28 {
                str_0: b"GNU_RETAIN\0" as *const u8 as *const libc::c_char,
                len: (::core::mem::size_of::<[libc::c_char; 11]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
            };
            init
        },
    ];
    arm_attr_public_tags = [
        {
            let mut init = arm_attr_public_tag {
                tag: 4 as libc::c_int as libc::c_uint,
                name: b"CPU_raw_name\0" as *const u8 as *const libc::c_char,
                type_0: 1 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 5 as libc::c_int as libc::c_uint,
                name: b"CPU_name\0" as *const u8 as *const libc::c_char,
                type_0: 1 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 6 as libc::c_int as libc::c_uint,
                name: b"CPU_arch\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 22]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_CPU_arch.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 7 as libc::c_int as libc::c_uint,
                name: b"CPU_arch_profile\0" as *const u8 as *const libc::c_char,
                type_0: 0 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 8 as libc::c_int as libc::c_uint,
                name: b"ARM_ISA_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ARM_ISA_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 9 as libc::c_int as libc::c_uint,
                name: b"THUMB_ISA_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 4]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_THUMB_ISA_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 10 as libc::c_int as libc::c_uint,
                name: b"FP_arch\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 9]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_FP_arch.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 11 as libc::c_int as libc::c_uint,
                name: b"WMMX_arch\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 3]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_WMMX_arch.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 12 as libc::c_int as libc::c_uint,
                name: b"Advanced_SIMD_arch\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 5]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_Advanced_SIMD_arch.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 13 as libc::c_int as libc::c_uint,
                name: b"PCS_config\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 8]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_PCS_config.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 14 as libc::c_int as libc::c_uint,
                name: b"ABI_PCS_R9_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 4]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_PCS_R9_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 15 as libc::c_int as libc::c_uint,
                name: b"ABI_PCS_RW_data\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 4]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_PCS_RW_data.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 16 as libc::c_int as libc::c_uint,
                name: b"ABI_PCS_RO_data\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 3]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_PCS_RO_data.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 17 as libc::c_int as libc::c_uint,
                name: b"ABI_PCS_GOT_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 3]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_PCS_GOT_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 18 as libc::c_int as libc::c_uint,
                name: b"ABI_PCS_wchar_t\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 5]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_PCS_wchar_t.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 19 as libc::c_int as libc::c_uint,
                name: b"ABI_FP_rounding\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_FP_rounding.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 20 as libc::c_int as libc::c_uint,
                name: b"ABI_FP_denormal\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 3]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_FP_denormal.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 21 as libc::c_int as libc::c_uint,
                name: b"ABI_FP_exceptions\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_FP_exceptions.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 22 as libc::c_int as libc::c_uint,
                name: b"ABI_FP_user_exceptions\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_FP_user_exceptions.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 23 as libc::c_int as libc::c_uint,
                name: b"ABI_FP_number_model\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 4]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_FP_number_model.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 24 as libc::c_int as libc::c_uint,
                name: b"ABI_align_needed\0" as *const u8 as *const libc::c_char,
                type_0: 0 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 25 as libc::c_int as libc::c_uint,
                name: b"ABI_align_preserved\0" as *const u8 as *const libc::c_char,
                type_0: 0 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 26 as libc::c_int as libc::c_uint,
                name: b"ABI_enum_size\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 4]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_enum_size.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 27 as libc::c_int as libc::c_uint,
                name: b"ABI_HardFP_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 4]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_HardFP_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 28 as libc::c_int as libc::c_uint,
                name: b"ABI_VFP_args\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 4]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_VFP_args.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 29 as libc::c_int as libc::c_uint,
                name: b"ABI_WMMX_args\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 3]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_WMMX_args.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 30 as libc::c_int as libc::c_uint,
                name: b"ABI_optimization_goals\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 7]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_optimization_goals.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 31 as libc::c_int as libc::c_uint,
                name: b"ABI_FP_optimization_goals\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 7]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_FP_optimization_goals.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 32 as libc::c_int as libc::c_uint,
                name: b"compatibility\0" as *const u8 as *const libc::c_char,
                type_0: 0 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 34 as libc::c_int as libc::c_uint,
                name: b"CPU_unaligned_access\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_CPU_unaligned_access.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 36 as libc::c_int as libc::c_uint,
                name: b"FP_HP_extension\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_FP_HP_extension.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 38 as libc::c_int as libc::c_uint,
                name: b"ABI_FP_16bit_format\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 3]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_ABI_FP_16bit_format.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 42 as libc::c_int as libc::c_uint,
                name: b"MPextension_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_MPextension_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 44 as libc::c_int as libc::c_uint,
                name: b"DIV_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 3]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_DIV_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 46 as libc::c_int as libc::c_uint,
                name: b"DSP_extension\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_DSP_extension.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 48 as libc::c_int as libc::c_uint,
                name: b"MVE_arch\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 3]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_MVE_arch.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 64 as libc::c_int as libc::c_uint,
                name: b"nodefaults\0" as *const u8 as *const libc::c_char,
                type_0: 0 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 65 as libc::c_int as libc::c_uint,
                name: b"also_compatible_with\0" as *const u8 as *const libc::c_char,
                type_0: 0 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 66 as libc::c_int as libc::c_uint,
                name: b"T2EE_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_T2EE_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 67 as libc::c_int as libc::c_uint,
                name: b"conformance\0" as *const u8 as *const libc::c_char,
                type_0: 1 as libc::c_int as libc::c_uint,
                table: 0 as *const *const libc::c_char,
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 68 as libc::c_int as libc::c_uint,
                name: b"Virtualization_use\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 4]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_Virtualization_use.as_ptr(),
            };
            init
        },
        {
            let mut init = arm_attr_public_tag {
                tag: 70 as libc::c_int as libc::c_uint,
                name: b"MPextension_use_legacy\0" as *const u8 as *const libc::c_char,
                type_0: (0x80 as libc::c_int as libc::c_ulong
                    | (::core::mem::size_of::<[*const libc::c_char; 2]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )) as libc::c_uint,
                table: arm_attr_tag_MPextension_use_legacy.as_ptr(),
            };
            init
        },
    ];
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
