extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn asprintf(
        __ptr: *mut *mut libc::c_char,
        __fmt: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn puts(__s: *const libc::c_char) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strnlen(__string: *const libc::c_char, __maxlen: size_t) -> size_t;
    fn dcgettext(
        __domainname: *const libc::c_char,
        __msgid: *const libc::c_char,
        __category: libc::c_int,
    ) -> *mut libc::c_char;
    fn dcngettext(
        __domainname: *const libc::c_char,
        __msgid1: *const libc::c_char,
        __msgid2: *const libc::c_char,
        __n: libc::c_ulong,
        __category: libc::c_int,
    ) -> *mut libc::c_char;
    fn lrealpath(_: *const libc::c_char) -> *mut libc::c_char;
    fn concat(_: *const libc::c_char, _: ...) -> *mut libc::c_char;
    fn xexit(status: libc::c_int) -> !;
    fn xmalloc(_: size_t) -> *mut libc::c_void;
    fn xrealloc(_: *mut libc::c_void, _: size_t) -> *mut libc::c_void;
    fn xcalloc(_: size_t, _: size_t) -> *mut libc::c_void;
    fn error(_: *const libc::c_char, _: ...);
    fn warn(_: *const libc::c_char, _: ...);
    static mut byte_get: Option::<
        unsafe extern "C" fn(*const libc::c_uchar, libc::c_uint) -> elf_vma,
    >;
    fn byte_get_signed(_: *const libc::c_uchar, _: libc::c_uint) -> elf_vma;
    fn byte_get_little_endian(_: *const libc::c_uchar, _: libc::c_uint) -> elf_vma;
    fn get_DW_TAG_name(tag: libc::c_uint) -> *const libc::c_char;
    fn get_DW_AT_name(attr: libc::c_uint) -> *const libc::c_char;
    fn get_DW_FORM_name(form: libc::c_uint) -> *const libc::c_char;
    fn get_DW_IDX_name(idx: libc::c_uint) -> *const libc::c_char;
    fn get_DW_UT_name(ut: libc::c_uint) -> *const libc::c_char;
    fn load_debug_section(_: dwarf_section_display_enum, _: *mut libc::c_void) -> bool;
    fn free_debug_section(_: dwarf_section_display_enum);
    fn close_debug_file(_: *mut libc::c_void);
    fn open_debug_file(_: *const libc::c_char) -> *mut libc::c_void;
    fn reloc_at(_: *mut dwarf_section, _: dwarf_vma) -> bool;
    static _sch_istable: [libc::c_ushort; 256];
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
}
pub type size_t = libc::c_ulong;
pub type __uint16_t = libc::c_ushort;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type __compar_fn_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type bfd_size_type = libc::c_ulong;
pub type bfd_architecture = libc::c_uint;
pub const bfd_arch_last: bfd_architecture = 88;
pub const bfd_arch_csky: bfd_architecture = 87;
pub const bfd_arch_nfp: bfd_architecture = 86;
pub const bfd_arch_pru: bfd_architecture = 85;
pub const bfd_arch_wasm32: bfd_architecture = 84;
pub const bfd_arch_visium: bfd_architecture = 83;
pub const bfd_arch_nios2: bfd_architecture = 82;
pub const bfd_arch_aarch64: bfd_architecture = 81;
pub const bfd_arch_tilegx: bfd_architecture = 80;
pub const bfd_arch_tilepro: bfd_architecture = 79;
pub const bfd_arch_microblaze: bfd_architecture = 78;
pub const bfd_arch_lm32: bfd_architecture = 77;
pub const bfd_arch_z80: bfd_architecture = 76;
pub const bfd_arch_xtensa: bfd_architecture = 75;
pub const bfd_arch_xgate: bfd_architecture = 74;
pub const bfd_arch_xc16x: bfd_architecture = 73;
pub const bfd_arch_msp430: bfd_architecture = 72;
pub const bfd_arch_xstormy16: bfd_architecture = 71;
pub const bfd_arch_mmix: bfd_architecture = 70;
pub const bfd_arch_score: bfd_architecture = 69;
pub const bfd_arch_s390: bfd_architecture = 68;
pub const bfd_arch_rx: bfd_architecture = 67;
pub const bfd_arch_rl78: bfd_architecture = 66;
pub const bfd_arch_riscv: bfd_architecture = 65;
pub const bfd_arch_cris: bfd_architecture = 64;
pub const bfd_arch_crx: bfd_architecture = 63;
pub const bfd_arch_cr16: bfd_architecture = 62;
pub const bfd_arch_bfin: bfd_architecture = 61;
pub const bfd_arch_avr: bfd_architecture = 60;
pub const bfd_arch_pj: bfd_architecture = 59;
pub const bfd_arch_mt: bfd_architecture = 58;
pub const bfd_arch_epiphany: bfd_architecture = 57;
pub const bfd_arch_bpf: bfd_architecture = 56;
pub const bfd_arch_iq2000: bfd_architecture = 55;
pub const bfd_arch_ip2k: bfd_architecture = 54;
pub const bfd_arch_ia64: bfd_architecture = 53;
pub const bfd_arch_metag: bfd_architecture = 52;
pub const bfd_arch_mep: bfd_architecture = 51;
pub const bfd_arch_mcore: bfd_architecture = 50;
pub const bfd_arch_ft32: bfd_architecture = 49;
pub const bfd_arch_moxie: bfd_architecture = 48;
pub const bfd_arch_frv: bfd_architecture = 47;
pub const bfd_arch_fr30: bfd_architecture = 46;
pub const bfd_arch_mn10300: bfd_architecture = 45;
pub const bfd_arch_mn10200: bfd_architecture = 44;
pub const bfd_arch_m32r: bfd_architecture = 43;
pub const bfd_arch_m32c: bfd_architecture = 42;
pub const bfd_arch_arc: bfd_architecture = 41;
pub const bfd_arch_v850_rh850: bfd_architecture = 40;
pub const bfd_arch_v850: bfd_architecture = 39;
pub const bfd_arch_tic6x: bfd_architecture = 38;
pub const bfd_arch_tic54x: bfd_architecture = 37;
pub const bfd_arch_tic4x: bfd_architecture = 36;
pub const bfd_arch_tic30: bfd_architecture = 35;
pub const bfd_arch_ns32k: bfd_architecture = 34;
pub const bfd_arch_nds32: bfd_architecture = 33;
pub const bfd_arch_arm: bfd_architecture = 32;
pub const bfd_arch_alpha: bfd_architecture = 31;
pub const bfd_arch_sh: bfd_architecture = 30;
pub const bfd_arch_z8k: bfd_architecture = 29;
pub const bfd_arch_s12z: bfd_architecture = 28;
pub const bfd_arch_m9s12xg: bfd_architecture = 27;
pub const bfd_arch_m9s12x: bfd_architecture = 26;
pub const bfd_arch_m68hc12: bfd_architecture = 25;
pub const bfd_arch_m68hc11: bfd_architecture = 24;
pub const bfd_arch_dlx: bfd_architecture = 23;
pub const bfd_arch_d30v: bfd_architecture = 22;
pub const bfd_arch_d10v: bfd_architecture = 21;
pub const bfd_arch_hppa: bfd_architecture = 20;
pub const bfd_arch_rs6000: bfd_architecture = 19;
pub const bfd_arch_powerpc: bfd_architecture = 18;
pub const bfd_arch_pdp11: bfd_architecture = 17;
pub const bfd_arch_h8300: bfd_architecture = 16;
pub const bfd_arch_pyramid: bfd_architecture = 15;
pub const bfd_arch_m98k: bfd_architecture = 14;
pub const bfd_arch_convex: bfd_architecture = 13;
pub const bfd_arch_romp: bfd_architecture = 12;
pub const bfd_arch_iamcu: bfd_architecture = 11;
pub const bfd_arch_k1om: bfd_architecture = 10;
pub const bfd_arch_l1om: bfd_architecture = 9;
pub const bfd_arch_i386: bfd_architecture = 8;
pub const bfd_arch_mips: bfd_architecture = 7;
pub const bfd_arch_spu: bfd_architecture = 6;
pub const bfd_arch_sparc: bfd_architecture = 5;
pub const bfd_arch_or1k: bfd_architecture = 4;
pub const bfd_arch_vax: bfd_architecture = 3;
pub const bfd_arch_m68k: bfd_architecture = 2;
pub const bfd_arch_obscure: bfd_architecture = 1;
pub const bfd_arch_unknown: bfd_architecture = 0;
pub type elf_vma = libc::c_ulong;
pub type dwarf_tag = libc::c_uint;
pub const DW_TAG_PGI_interface_block: dwarf_tag = 40992;
pub const DW_TAG_PGI_kanji_type: dwarf_tag = 40960;
pub const DW_TAG_upc_relaxed_type: dwarf_tag = 34663;
pub const DW_TAG_upc_strict_type: dwarf_tag = 34662;
pub const DW_TAG_upc_shared_type: dwarf_tag = 34661;
pub const DW_TAG_GNU_call_site_parameter: dwarf_tag = 16650;
pub const DW_TAG_GNU_call_site: dwarf_tag = 16649;
pub const DW_TAG_GNU_formal_parameter_pack: dwarf_tag = 16648;
pub const DW_TAG_GNU_template_parameter_pack: dwarf_tag = 16647;
pub const DW_TAG_GNU_template_template_param: dwarf_tag = 16646;
pub const DW_TAG_GNU_EINCL: dwarf_tag = 16645;
pub const DW_TAG_GNU_BINCL: dwarf_tag = 16644;
pub const DW_TAG_class_template: dwarf_tag = 16643;
pub const DW_TAG_function_template: dwarf_tag = 16642;
pub const DW_TAG_format_label: dwarf_tag = 16641;
pub const DW_TAG_HP_Bliss_field_set: dwarf_tag = 16530;
pub const DW_TAG_HP_Bliss_field: dwarf_tag = 16529;
pub const DW_TAG_HP_array_descriptor: dwarf_tag = 16528;
pub const DW_TAG_MIPS_loop: dwarf_tag = 16513;
pub const DW_TAG_hi_user: dwarf_tag = 65535;
pub const DW_TAG_lo_user: dwarf_tag = 16512;
pub const DW_TAG_immutable_type: dwarf_tag = 75;
pub const DW_TAG_skeleton_unit: dwarf_tag = 74;
pub const DW_TAG_call_site_parameter: dwarf_tag = 73;
pub const DW_TAG_call_site: dwarf_tag = 72;
pub const DW_TAG_atomic_type: dwarf_tag = 71;
pub const DW_TAG_dynamic_type: dwarf_tag = 70;
pub const DW_TAG_generic_subrange: dwarf_tag = 69;
pub const DW_TAG_coarray_type: dwarf_tag = 68;
pub const DW_TAG_template_alias: dwarf_tag = 67;
pub const DW_TAG_rvalue_reference_type: dwarf_tag = 66;
pub const DW_TAG_type_unit: dwarf_tag = 65;
pub const DW_TAG_shared_type: dwarf_tag = 64;
pub const DW_TAG_condition: dwarf_tag = 63;
pub const DW_TAG_imported_unit: dwarf_tag = 61;
pub const DW_TAG_partial_unit: dwarf_tag = 60;
pub const DW_TAG_unspecified_type: dwarf_tag = 59;
pub const DW_TAG_imported_module: dwarf_tag = 58;
pub const DW_TAG_namespace: dwarf_tag = 57;
pub const DW_TAG_interface_type: dwarf_tag = 56;
pub const DW_TAG_restrict_type: dwarf_tag = 55;
pub const DW_TAG_dwarf_procedure: dwarf_tag = 54;
pub const DW_TAG_volatile_type: dwarf_tag = 53;
pub const DW_TAG_variable: dwarf_tag = 52;
pub const DW_TAG_variant_part: dwarf_tag = 51;
pub const DW_TAG_try_block: dwarf_tag = 50;
pub const DW_TAG_thrown_type: dwarf_tag = 49;
pub const DW_TAG_template_value_param: dwarf_tag = 48;
pub const DW_TAG_template_type_param: dwarf_tag = 47;
pub const DW_TAG_subprogram: dwarf_tag = 46;
pub const DW_TAG_packed_type: dwarf_tag = 45;
pub const DW_TAG_namelist_item: dwarf_tag = 44;
pub const DW_TAG_namelist: dwarf_tag = 43;
pub const DW_TAG_friend: dwarf_tag = 42;
pub const DW_TAG_file_type: dwarf_tag = 41;
pub const DW_TAG_enumerator: dwarf_tag = 40;
pub const DW_TAG_constant: dwarf_tag = 39;
pub const DW_TAG_const_type: dwarf_tag = 38;
pub const DW_TAG_catch_block: dwarf_tag = 37;
pub const DW_TAG_base_type: dwarf_tag = 36;
pub const DW_TAG_access_declaration: dwarf_tag = 35;
pub const DW_TAG_with_stmt: dwarf_tag = 34;
pub const DW_TAG_subrange_type: dwarf_tag = 33;
pub const DW_TAG_set_type: dwarf_tag = 32;
pub const DW_TAG_ptr_to_member_type: dwarf_tag = 31;
pub const DW_TAG_module: dwarf_tag = 30;
pub const DW_TAG_inlined_subroutine: dwarf_tag = 29;
pub const DW_TAG_inheritance: dwarf_tag = 28;
pub const DW_TAG_common_inclusion: dwarf_tag = 27;
pub const DW_TAG_common_block: dwarf_tag = 26;
pub const DW_TAG_variant: dwarf_tag = 25;
pub const DW_TAG_unspecified_parameters: dwarf_tag = 24;
pub const DW_TAG_union_type: dwarf_tag = 23;
pub const DW_TAG_typedef: dwarf_tag = 22;
pub const DW_TAG_subroutine_type: dwarf_tag = 21;
pub const DW_TAG_structure_type: dwarf_tag = 19;
pub const DW_TAG_string_type: dwarf_tag = 18;
pub const DW_TAG_compile_unit: dwarf_tag = 17;
pub const DW_TAG_reference_type: dwarf_tag = 16;
pub const DW_TAG_pointer_type: dwarf_tag = 15;
pub const DW_TAG_member: dwarf_tag = 13;
pub const DW_TAG_lexical_block: dwarf_tag = 11;
pub const DW_TAG_label: dwarf_tag = 10;
pub const DW_TAG_imported_declaration: dwarf_tag = 8;
pub const DW_TAG_formal_parameter: dwarf_tag = 5;
pub const DW_TAG_enumeration_type: dwarf_tag = 4;
pub const DW_TAG_entry_point: dwarf_tag = 3;
pub const DW_TAG_class_type: dwarf_tag = 2;
pub const DW_TAG_array_type: dwarf_tag = 1;
pub const DW_TAG_padding: dwarf_tag = 0;
pub type dwarf_form = libc::c_uint;
pub const DW_FORM_GNU_strp_alt: dwarf_form = 7969;
pub const DW_FORM_GNU_ref_alt: dwarf_form = 7968;
pub const DW_FORM_GNU_str_index: dwarf_form = 7938;
pub const DW_FORM_GNU_addr_index: dwarf_form = 7937;
pub const DW_FORM_addrx4: dwarf_form = 44;
pub const DW_FORM_addrx3: dwarf_form = 43;
pub const DW_FORM_addrx2: dwarf_form = 42;
pub const DW_FORM_addrx1: dwarf_form = 41;
pub const DW_FORM_strx4: dwarf_form = 40;
pub const DW_FORM_strx3: dwarf_form = 39;
pub const DW_FORM_strx2: dwarf_form = 38;
pub const DW_FORM_strx1: dwarf_form = 37;
pub const DW_FORM_ref_sup8: dwarf_form = 36;
pub const DW_FORM_rnglistx: dwarf_form = 35;
pub const DW_FORM_loclistx: dwarf_form = 34;
pub const DW_FORM_implicit_const: dwarf_form = 33;
pub const DW_FORM_line_strp: dwarf_form = 31;
pub const DW_FORM_data16: dwarf_form = 30;
pub const DW_FORM_strp_sup: dwarf_form = 29;
pub const DW_FORM_ref_sup4: dwarf_form = 28;
pub const DW_FORM_addrx: dwarf_form = 27;
pub const DW_FORM_strx: dwarf_form = 26;
pub const DW_FORM_ref_sig8: dwarf_form = 32;
pub const DW_FORM_flag_present: dwarf_form = 25;
pub const DW_FORM_exprloc: dwarf_form = 24;
pub const DW_FORM_sec_offset: dwarf_form = 23;
pub const DW_FORM_indirect: dwarf_form = 22;
pub const DW_FORM_ref_udata: dwarf_form = 21;
pub const DW_FORM_ref8: dwarf_form = 20;
pub const DW_FORM_ref4: dwarf_form = 19;
pub const DW_FORM_ref2: dwarf_form = 18;
pub const DW_FORM_ref1: dwarf_form = 17;
pub const DW_FORM_ref_addr: dwarf_form = 16;
pub const DW_FORM_udata: dwarf_form = 15;
pub const DW_FORM_strp: dwarf_form = 14;
pub const DW_FORM_sdata: dwarf_form = 13;
pub const DW_FORM_flag: dwarf_form = 12;
pub const DW_FORM_data1: dwarf_form = 11;
pub const DW_FORM_block1: dwarf_form = 10;
pub const DW_FORM_block: dwarf_form = 9;
pub const DW_FORM_string: dwarf_form = 8;
pub const DW_FORM_data8: dwarf_form = 7;
pub const DW_FORM_data4: dwarf_form = 6;
pub const DW_FORM_data2: dwarf_form = 5;
pub const DW_FORM_block4: dwarf_form = 4;
pub const DW_FORM_block2: dwarf_form = 3;
pub const DW_FORM_addr: dwarf_form = 1;
pub type dwarf_attribute = libc::c_uint;
pub const DW_AT_APPLE_property: dwarf_attribute = 16365;
pub const DW_AT_APPLE_objc_complete_type: dwarf_attribute = 16364;
pub const DW_AT_APPLE_property_attribute: dwarf_attribute = 16363;
pub const DW_AT_APPLE_property_setter: dwarf_attribute = 16362;
pub const DW_AT_APPLE_property_getter: dwarf_attribute = 16361;
pub const DW_AT_APPLE_property_name: dwarf_attribute = 16360;
pub const DW_AT_APPLE_omit_frame_ptr: dwarf_attribute = 16359;
pub const DW_AT_APPLE_runtime_class: dwarf_attribute = 16358;
pub const DW_AT_APPLE_major_runtime_vers: dwarf_attribute = 16357;
pub const DW_AT_APPLE_block: dwarf_attribute = 16356;
pub const DW_AT_APPLE_isa: dwarf_attribute = 16355;
pub const DW_AT_APPLE_flags: dwarf_attribute = 16354;
pub const DW_AT_APPLE_optimized: dwarf_attribute = 16353;
pub const DW_AT_PGI_lstride: dwarf_attribute = 14850;
pub const DW_AT_PGI_soffset: dwarf_attribute = 14849;
pub const DW_AT_PGI_lbase: dwarf_attribute = 14848;
pub const DW_AT_upc_threads_scaled: dwarf_attribute = 12816;
pub const DW_AT_GNU_bias: dwarf_attribute = 8965;
pub const DW_AT_GNU_denominator: dwarf_attribute = 8964;
pub const DW_AT_GNU_numerator: dwarf_attribute = 8963;
pub const DW_AT_GNAT_descriptive_type: dwarf_attribute = 8962;
pub const DW_AT_use_GNAT_descriptive_type: dwarf_attribute = 8961;
pub const DW_AT_VMS_rtnbeg_pd_address: dwarf_attribute = 8705;
pub const DW_AT_GNU_entry_view: dwarf_attribute = 8504;
pub const DW_AT_GNU_locviews: dwarf_attribute = 8503;
pub const DW_AT_GNU_discriminator: dwarf_attribute = 8502;
pub const DW_AT_GNU_pubtypes: dwarf_attribute = 8501;
pub const DW_AT_GNU_pubnames: dwarf_attribute = 8500;
pub const DW_AT_GNU_addr_base: dwarf_attribute = 8499;
pub const DW_AT_GNU_ranges_base: dwarf_attribute = 8498;
pub const DW_AT_GNU_dwo_id: dwarf_attribute = 8497;
pub const DW_AT_GNU_dwo_name: dwarf_attribute = 8496;
pub const DW_AT_GNU_deleted: dwarf_attribute = 8474;
pub const DW_AT_GNU_macros: dwarf_attribute = 8473;
pub const DW_AT_GNU_all_source_call_sites: dwarf_attribute = 8472;
pub const DW_AT_GNU_all_call_sites: dwarf_attribute = 8471;
pub const DW_AT_GNU_all_tail_call_sites: dwarf_attribute = 8470;
pub const DW_AT_GNU_tail_call: dwarf_attribute = 8469;
pub const DW_AT_GNU_call_site_target_clobbered: dwarf_attribute = 8468;
pub const DW_AT_GNU_call_site_target: dwarf_attribute = 8467;
pub const DW_AT_GNU_call_site_data_value: dwarf_attribute = 8466;
pub const DW_AT_GNU_call_site_value: dwarf_attribute = 8465;
pub const DW_AT_GNU_template_name: dwarf_attribute = 8464;
pub const DW_AT_GNU_odr_signature: dwarf_attribute = 8463;
pub const DW_AT_GNU_shared_locks_required: dwarf_attribute = 8462;
pub const DW_AT_GNU_exclusive_locks_required: dwarf_attribute = 8461;
pub const DW_AT_GNU_locks_excluded: dwarf_attribute = 8460;
pub const DW_AT_GNU_pt_guarded: dwarf_attribute = 8459;
pub const DW_AT_GNU_guarded: dwarf_attribute = 8458;
pub const DW_AT_GNU_pt_guarded_by: dwarf_attribute = 8457;
pub const DW_AT_GNU_guarded_by: dwarf_attribute = 8456;
pub const DW_AT_GNU_vector: dwarf_attribute = 8455;
pub const DW_AT_body_end: dwarf_attribute = 8454;
pub const DW_AT_body_begin: dwarf_attribute = 8453;
pub const DW_AT_src_coords: dwarf_attribute = 8452;
pub const DW_AT_mac_info: dwarf_attribute = 8451;
pub const DW_AT_src_info: dwarf_attribute = 8450;
pub const DW_AT_sf_names: dwarf_attribute = 8449;
pub const DW_AT_HP_is_result_param: dwarf_attribute = 8233;
pub const DW_AT_HP_default_location: dwarf_attribute = 8227;
pub const DW_AT_HP_definition_points: dwarf_attribute = 8226;
pub const DW_AT_HP_widened_byte_size: dwarf_attribute = 8225;
pub const DW_AT_HP_unit_size: dwarf_attribute = 8224;
pub const DW_AT_HP_unit_name: dwarf_attribute = 8223;
pub const DW_AT_HP_prof_flags: dwarf_attribute = 8219;
pub const DW_AT_HP_linkage_name: dwarf_attribute = 8218;
pub const DW_AT_HP_all_variables_modifiable: dwarf_attribute = 8217;
pub const DW_AT_HP_cold_region_high_pc: dwarf_attribute = 8216;
pub const DW_AT_HP_cold_region_low_pc: dwarf_attribute = 8215;
pub const DW_AT_HP_opt_flags: dwarf_attribute = 8214;
pub const DW_AT_HP_prof_version_id: dwarf_attribute = 8213;
pub const DW_AT_HP_opt_level: dwarf_attribute = 8212;
pub const DW_AT_HP_pass_by_reference: dwarf_attribute = 8211;
pub const DW_AT_HP_raw_data_ptr: dwarf_attribute = 8210;
pub const DW_AT_HP_proc_per_section: dwarf_attribute = 8209;
pub const DW_AT_HP_actuals_stmt_list: dwarf_attribute = 8208;
pub const DW_AT_HP_epilogue: dwarf_attribute = 8200;
pub const DW_AT_HP_prologue: dwarf_attribute = 8197;
pub const DW_AT_HP_unmodifiable: dwarf_attribute = 8193;
pub const DW_AT_HP_block_index: dwarf_attribute = 8192;
pub const DW_AT_MIPS_has_inlines: dwarf_attribute = 8203;
pub const DW_AT_MIPS_clone_origin: dwarf_attribute = 8202;
pub const DW_AT_MIPS_abstract_name: dwarf_attribute = 8201;
pub const DW_AT_MIPS_stride: dwarf_attribute = 8200;
pub const DW_AT_MIPS_linkage_name: dwarf_attribute = 8199;
pub const DW_AT_MIPS_software_pipeline_depth: dwarf_attribute = 8198;
pub const DW_AT_MIPS_loop_unroll_factor: dwarf_attribute = 8197;
pub const DW_AT_MIPS_epilog_begin: dwarf_attribute = 8196;
pub const DW_AT_MIPS_tail_loop_begin: dwarf_attribute = 8195;
pub const DW_AT_MIPS_loop_begin: dwarf_attribute = 8194;
pub const DW_AT_MIPS_fde: dwarf_attribute = 8193;
pub const DW_AT_hi_user: dwarf_attribute = 16383;
pub const DW_AT_lo_user: dwarf_attribute = 8192;
pub const DW_AT_loclists_base: dwarf_attribute = 140;
pub const DW_AT_defaulted: dwarf_attribute = 139;
pub const DW_AT_deleted: dwarf_attribute = 138;
pub const DW_AT_export_symbols: dwarf_attribute = 137;
pub const DW_AT_alignment: dwarf_attribute = 136;
pub const DW_AT_noreturn: dwarf_attribute = 135;
pub const DW_AT_call_data_value: dwarf_attribute = 134;
pub const DW_AT_call_data_location: dwarf_attribute = 133;
pub const DW_AT_call_target_clobbered: dwarf_attribute = 132;
pub const DW_AT_call_target: dwarf_attribute = 131;
pub const DW_AT_call_tail_call: dwarf_attribute = 130;
pub const DW_AT_call_pc: dwarf_attribute = 129;
pub const DW_AT_call_parameter: dwarf_attribute = 128;
pub const DW_AT_call_origin: dwarf_attribute = 127;
pub const DW_AT_call_value: dwarf_attribute = 126;
pub const DW_AT_call_return_pc: dwarf_attribute = 125;
pub const DW_AT_call_all_tail_calls: dwarf_attribute = 124;
pub const DW_AT_call_all_source_calls: dwarf_attribute = 123;
pub const DW_AT_call_all_calls: dwarf_attribute = 122;
pub const DW_AT_macros: dwarf_attribute = 121;
pub const DW_AT_rvalue_reference: dwarf_attribute = 120;
pub const DW_AT_reference: dwarf_attribute = 119;
pub const DW_AT_dwo_name: dwarf_attribute = 118;
pub const DW_AT_rnglists_base: dwarf_attribute = 116;
pub const DW_AT_addr_base: dwarf_attribute = 115;
pub const DW_AT_str_offsets_base: dwarf_attribute = 114;
pub const DW_AT_rank: dwarf_attribute = 113;
pub const DW_AT_string_length_byte_size: dwarf_attribute = 112;
pub const DW_AT_string_length_bit_size: dwarf_attribute = 111;
pub const DW_AT_linkage_name: dwarf_attribute = 110;
pub const DW_AT_enum_class: dwarf_attribute = 109;
pub const DW_AT_const_expr: dwarf_attribute = 108;
pub const DW_AT_data_bit_offset: dwarf_attribute = 107;
pub const DW_AT_main_subprogram: dwarf_attribute = 106;
pub const DW_AT_signature: dwarf_attribute = 105;
pub const DW_AT_recursive: dwarf_attribute = 104;
pub const DW_AT_pure: dwarf_attribute = 103;
pub const DW_AT_elemental: dwarf_attribute = 102;
pub const DW_AT_endianity: dwarf_attribute = 101;
pub const DW_AT_object_pointer: dwarf_attribute = 100;
pub const DW_AT_explicit: dwarf_attribute = 99;
pub const DW_AT_threads_scaled: dwarf_attribute = 98;
pub const DW_AT_mutable: dwarf_attribute = 97;
pub const DW_AT_picture_string: dwarf_attribute = 96;
pub const DW_AT_digit_count: dwarf_attribute = 95;
pub const DW_AT_decimal_sign: dwarf_attribute = 94;
pub const DW_AT_small: dwarf_attribute = 93;
pub const DW_AT_decimal_scale: dwarf_attribute = 92;
pub const DW_AT_binary_scale: dwarf_attribute = 91;
pub const DW_AT_description: dwarf_attribute = 90;
pub const DW_AT_call_line: dwarf_attribute = 89;
pub const DW_AT_call_file: dwarf_attribute = 88;
pub const DW_AT_call_column: dwarf_attribute = 87;
pub const DW_AT_trampoline: dwarf_attribute = 86;
pub const DW_AT_ranges: dwarf_attribute = 85;
pub const DW_AT_extension: dwarf_attribute = 84;
pub const DW_AT_use_UTF8: dwarf_attribute = 83;
pub const DW_AT_entry_pc: dwarf_attribute = 82;
pub const DW_AT_byte_stride: dwarf_attribute = 81;
pub const DW_AT_data_location: dwarf_attribute = 80;
pub const DW_AT_associated: dwarf_attribute = 79;
pub const DW_AT_allocated: dwarf_attribute = 78;
pub const DW_AT_vtable_elem_location: dwarf_attribute = 77;
pub const DW_AT_virtuality: dwarf_attribute = 76;
pub const DW_AT_variable_parameter: dwarf_attribute = 75;
pub const DW_AT_use_location: dwarf_attribute = 74;
pub const DW_AT_type: dwarf_attribute = 73;
pub const DW_AT_static_link: dwarf_attribute = 72;
pub const DW_AT_specification: dwarf_attribute = 71;
pub const DW_AT_segment: dwarf_attribute = 70;
pub const DW_AT_priority: dwarf_attribute = 69;
pub const DW_AT_namelist_items: dwarf_attribute = 68;
pub const DW_AT_macro_info: dwarf_attribute = 67;
pub const DW_AT_identifier_case: dwarf_attribute = 66;
pub const DW_AT_friend: dwarf_attribute = 65;
pub const DW_AT_frame_base: dwarf_attribute = 64;
pub const DW_AT_external: dwarf_attribute = 63;
pub const DW_AT_encoding: dwarf_attribute = 62;
pub const DW_AT_discr_list: dwarf_attribute = 61;
pub const DW_AT_declaration: dwarf_attribute = 60;
pub const DW_AT_decl_line: dwarf_attribute = 59;
pub const DW_AT_decl_file: dwarf_attribute = 58;
pub const DW_AT_decl_column: dwarf_attribute = 57;
pub const DW_AT_data_member_location: dwarf_attribute = 56;
pub const DW_AT_count: dwarf_attribute = 55;
pub const DW_AT_calling_convention: dwarf_attribute = 54;
pub const DW_AT_base_types: dwarf_attribute = 53;
pub const DW_AT_artificial: dwarf_attribute = 52;
pub const DW_AT_address_class: dwarf_attribute = 51;
pub const DW_AT_accessibility: dwarf_attribute = 50;
pub const DW_AT_abstract_origin: dwarf_attribute = 49;
pub const DW_AT_upper_bound: dwarf_attribute = 47;
pub const DW_AT_bit_stride: dwarf_attribute = 46;
pub const DW_AT_start_scope: dwarf_attribute = 44;
pub const DW_AT_return_addr: dwarf_attribute = 42;
pub const DW_AT_prototyped: dwarf_attribute = 39;
pub const DW_AT_producer: dwarf_attribute = 37;
pub const DW_AT_lower_bound: dwarf_attribute = 34;
pub const DW_AT_is_optional: dwarf_attribute = 33;
pub const DW_AT_inline: dwarf_attribute = 32;
pub const DW_AT_default_value: dwarf_attribute = 30;
pub const DW_AT_containing_type: dwarf_attribute = 29;
pub const DW_AT_const_value: dwarf_attribute = 28;
pub const DW_AT_comp_dir: dwarf_attribute = 27;
pub const DW_AT_common_reference: dwarf_attribute = 26;
pub const DW_AT_string_length: dwarf_attribute = 25;
pub const DW_AT_import: dwarf_attribute = 24;
pub const DW_AT_visibility: dwarf_attribute = 23;
pub const DW_AT_discr_value: dwarf_attribute = 22;
pub const DW_AT_discr: dwarf_attribute = 21;
pub const DW_AT_member: dwarf_attribute = 20;
pub const DW_AT_language: dwarf_attribute = 19;
pub const DW_AT_high_pc: dwarf_attribute = 18;
pub const DW_AT_low_pc: dwarf_attribute = 17;
pub const DW_AT_stmt_list: dwarf_attribute = 16;
pub const DW_AT_element_list: dwarf_attribute = 15;
pub const DW_AT_bit_size: dwarf_attribute = 13;
pub const DW_AT_bit_offset: dwarf_attribute = 12;
pub const DW_AT_byte_size: dwarf_attribute = 11;
pub const DW_AT_subscr_data: dwarf_attribute = 10;
pub const DW_AT_ordering: dwarf_attribute = 9;
pub const DW_AT_name: dwarf_attribute = 3;
pub const DW_AT_location: dwarf_attribute = 2;
pub const DW_AT_sibling: dwarf_attribute = 1;
pub type dwarf_location_atom = libc::c_uint;
pub const DW_OP_AARCH64_operation: dwarf_location_atom = 234;
pub const DW_OP_PGI_omp_thread_num: dwarf_location_atom = 248;
pub const DW_OP_HP_tls: dwarf_location_atom = 230;
pub const DW_OP_HP_unmod_range: dwarf_location_atom = 229;
pub const DW_OP_HP_mod_range: dwarf_location_atom = 228;
pub const DW_OP_HP_fltconst8: dwarf_location_atom = 227;
pub const DW_OP_HP_fltconst4: dwarf_location_atom = 226;
pub const DW_OP_HP_is_value: dwarf_location_atom = 225;
pub const DW_OP_HP_unknown: dwarf_location_atom = 224;
pub const DW_OP_GNU_variable_value: dwarf_location_atom = 253;
pub const DW_OP_GNU_const_index: dwarf_location_atom = 252;
pub const DW_OP_GNU_addr_index: dwarf_location_atom = 251;
pub const DW_OP_GNU_parameter_ref: dwarf_location_atom = 250;
pub const DW_OP_GNU_reinterpret: dwarf_location_atom = 249;
pub const DW_OP_GNU_convert: dwarf_location_atom = 247;
pub const DW_OP_GNU_deref_type: dwarf_location_atom = 246;
pub const DW_OP_GNU_regval_type: dwarf_location_atom = 245;
pub const DW_OP_GNU_const_type: dwarf_location_atom = 244;
pub const DW_OP_GNU_entry_value: dwarf_location_atom = 243;
pub const DW_OP_GNU_implicit_pointer: dwarf_location_atom = 242;
pub const DW_OP_GNU_encoded_addr: dwarf_location_atom = 241;
pub const DW_OP_GNU_uninit: dwarf_location_atom = 240;
pub const DW_OP_GNU_push_tls_address: dwarf_location_atom = 224;
pub const DW_OP_hi_user: dwarf_location_atom = 255;
pub const DW_OP_lo_user: dwarf_location_atom = 224;
pub const DW_OP_reinterpret: dwarf_location_atom = 169;
pub const DW_OP_convert: dwarf_location_atom = 168;
pub const DW_OP_xderef_type: dwarf_location_atom = 167;
pub const DW_OP_deref_type: dwarf_location_atom = 166;
pub const DW_OP_regval_type: dwarf_location_atom = 165;
pub const DW_OP_const_type: dwarf_location_atom = 164;
pub const DW_OP_entry_value: dwarf_location_atom = 163;
pub const DW_OP_constx: dwarf_location_atom = 162;
pub const DW_OP_addrx: dwarf_location_atom = 161;
pub const DW_OP_implicit_pointer: dwarf_location_atom = 160;
pub const DW_OP_stack_value: dwarf_location_atom = 159;
pub const DW_OP_implicit_value: dwarf_location_atom = 158;
pub const DW_OP_bit_piece: dwarf_location_atom = 157;
pub const DW_OP_call_frame_cfa: dwarf_location_atom = 156;
pub const DW_OP_form_tls_address: dwarf_location_atom = 155;
pub const DW_OP_call_ref: dwarf_location_atom = 154;
pub const DW_OP_call4: dwarf_location_atom = 153;
pub const DW_OP_call2: dwarf_location_atom = 152;
pub const DW_OP_push_object_address: dwarf_location_atom = 151;
pub const DW_OP_nop: dwarf_location_atom = 150;
pub const DW_OP_xderef_size: dwarf_location_atom = 149;
pub const DW_OP_deref_size: dwarf_location_atom = 148;
pub const DW_OP_piece: dwarf_location_atom = 147;
pub const DW_OP_bregx: dwarf_location_atom = 146;
pub const DW_OP_fbreg: dwarf_location_atom = 145;
pub const DW_OP_regx: dwarf_location_atom = 144;
pub const DW_OP_breg31: dwarf_location_atom = 143;
pub const DW_OP_breg30: dwarf_location_atom = 142;
pub const DW_OP_breg29: dwarf_location_atom = 141;
pub const DW_OP_breg28: dwarf_location_atom = 140;
pub const DW_OP_breg27: dwarf_location_atom = 139;
pub const DW_OP_breg26: dwarf_location_atom = 138;
pub const DW_OP_breg25: dwarf_location_atom = 137;
pub const DW_OP_breg24: dwarf_location_atom = 136;
pub const DW_OP_breg23: dwarf_location_atom = 135;
pub const DW_OP_breg22: dwarf_location_atom = 134;
pub const DW_OP_breg21: dwarf_location_atom = 133;
pub const DW_OP_breg20: dwarf_location_atom = 132;
pub const DW_OP_breg19: dwarf_location_atom = 131;
pub const DW_OP_breg18: dwarf_location_atom = 130;
pub const DW_OP_breg17: dwarf_location_atom = 129;
pub const DW_OP_breg16: dwarf_location_atom = 128;
pub const DW_OP_breg15: dwarf_location_atom = 127;
pub const DW_OP_breg14: dwarf_location_atom = 126;
pub const DW_OP_breg13: dwarf_location_atom = 125;
pub const DW_OP_breg12: dwarf_location_atom = 124;
pub const DW_OP_breg11: dwarf_location_atom = 123;
pub const DW_OP_breg10: dwarf_location_atom = 122;
pub const DW_OP_breg9: dwarf_location_atom = 121;
pub const DW_OP_breg8: dwarf_location_atom = 120;
pub const DW_OP_breg7: dwarf_location_atom = 119;
pub const DW_OP_breg6: dwarf_location_atom = 118;
pub const DW_OP_breg5: dwarf_location_atom = 117;
pub const DW_OP_breg4: dwarf_location_atom = 116;
pub const DW_OP_breg3: dwarf_location_atom = 115;
pub const DW_OP_breg2: dwarf_location_atom = 114;
pub const DW_OP_breg1: dwarf_location_atom = 113;
pub const DW_OP_breg0: dwarf_location_atom = 112;
pub const DW_OP_reg31: dwarf_location_atom = 111;
pub const DW_OP_reg30: dwarf_location_atom = 110;
pub const DW_OP_reg29: dwarf_location_atom = 109;
pub const DW_OP_reg28: dwarf_location_atom = 108;
pub const DW_OP_reg27: dwarf_location_atom = 107;
pub const DW_OP_reg26: dwarf_location_atom = 106;
pub const DW_OP_reg25: dwarf_location_atom = 105;
pub const DW_OP_reg24: dwarf_location_atom = 104;
pub const DW_OP_reg23: dwarf_location_atom = 103;
pub const DW_OP_reg22: dwarf_location_atom = 102;
pub const DW_OP_reg21: dwarf_location_atom = 101;
pub const DW_OP_reg20: dwarf_location_atom = 100;
pub const DW_OP_reg19: dwarf_location_atom = 99;
pub const DW_OP_reg18: dwarf_location_atom = 98;
pub const DW_OP_reg17: dwarf_location_atom = 97;
pub const DW_OP_reg16: dwarf_location_atom = 96;
pub const DW_OP_reg15: dwarf_location_atom = 95;
pub const DW_OP_reg14: dwarf_location_atom = 94;
pub const DW_OP_reg13: dwarf_location_atom = 93;
pub const DW_OP_reg12: dwarf_location_atom = 92;
pub const DW_OP_reg11: dwarf_location_atom = 91;
pub const DW_OP_reg10: dwarf_location_atom = 90;
pub const DW_OP_reg9: dwarf_location_atom = 89;
pub const DW_OP_reg8: dwarf_location_atom = 88;
pub const DW_OP_reg7: dwarf_location_atom = 87;
pub const DW_OP_reg6: dwarf_location_atom = 86;
pub const DW_OP_reg5: dwarf_location_atom = 85;
pub const DW_OP_reg4: dwarf_location_atom = 84;
pub const DW_OP_reg3: dwarf_location_atom = 83;
pub const DW_OP_reg2: dwarf_location_atom = 82;
pub const DW_OP_reg1: dwarf_location_atom = 81;
pub const DW_OP_reg0: dwarf_location_atom = 80;
pub const DW_OP_lit31: dwarf_location_atom = 79;
pub const DW_OP_lit30: dwarf_location_atom = 78;
pub const DW_OP_lit29: dwarf_location_atom = 77;
pub const DW_OP_lit28: dwarf_location_atom = 76;
pub const DW_OP_lit27: dwarf_location_atom = 75;
pub const DW_OP_lit26: dwarf_location_atom = 74;
pub const DW_OP_lit25: dwarf_location_atom = 73;
pub const DW_OP_lit24: dwarf_location_atom = 72;
pub const DW_OP_lit23: dwarf_location_atom = 71;
pub const DW_OP_lit22: dwarf_location_atom = 70;
pub const DW_OP_lit21: dwarf_location_atom = 69;
pub const DW_OP_lit20: dwarf_location_atom = 68;
pub const DW_OP_lit19: dwarf_location_atom = 67;
pub const DW_OP_lit18: dwarf_location_atom = 66;
pub const DW_OP_lit17: dwarf_location_atom = 65;
pub const DW_OP_lit16: dwarf_location_atom = 64;
pub const DW_OP_lit15: dwarf_location_atom = 63;
pub const DW_OP_lit14: dwarf_location_atom = 62;
pub const DW_OP_lit13: dwarf_location_atom = 61;
pub const DW_OP_lit12: dwarf_location_atom = 60;
pub const DW_OP_lit11: dwarf_location_atom = 59;
pub const DW_OP_lit10: dwarf_location_atom = 58;
pub const DW_OP_lit9: dwarf_location_atom = 57;
pub const DW_OP_lit8: dwarf_location_atom = 56;
pub const DW_OP_lit7: dwarf_location_atom = 55;
pub const DW_OP_lit6: dwarf_location_atom = 54;
pub const DW_OP_lit5: dwarf_location_atom = 53;
pub const DW_OP_lit4: dwarf_location_atom = 52;
pub const DW_OP_lit3: dwarf_location_atom = 51;
pub const DW_OP_lit2: dwarf_location_atom = 50;
pub const DW_OP_lit1: dwarf_location_atom = 49;
pub const DW_OP_lit0: dwarf_location_atom = 48;
pub const DW_OP_skip: dwarf_location_atom = 47;
pub const DW_OP_ne: dwarf_location_atom = 46;
pub const DW_OP_lt: dwarf_location_atom = 45;
pub const DW_OP_le: dwarf_location_atom = 44;
pub const DW_OP_gt: dwarf_location_atom = 43;
pub const DW_OP_ge: dwarf_location_atom = 42;
pub const DW_OP_eq: dwarf_location_atom = 41;
pub const DW_OP_bra: dwarf_location_atom = 40;
pub const DW_OP_xor: dwarf_location_atom = 39;
pub const DW_OP_shra: dwarf_location_atom = 38;
pub const DW_OP_shr: dwarf_location_atom = 37;
pub const DW_OP_shl: dwarf_location_atom = 36;
pub const DW_OP_plus_uconst: dwarf_location_atom = 35;
pub const DW_OP_plus: dwarf_location_atom = 34;
pub const DW_OP_or: dwarf_location_atom = 33;
pub const DW_OP_not: dwarf_location_atom = 32;
pub const DW_OP_neg: dwarf_location_atom = 31;
pub const DW_OP_mul: dwarf_location_atom = 30;
pub const DW_OP_mod: dwarf_location_atom = 29;
pub const DW_OP_minus: dwarf_location_atom = 28;
pub const DW_OP_div: dwarf_location_atom = 27;
pub const DW_OP_and: dwarf_location_atom = 26;
pub const DW_OP_abs: dwarf_location_atom = 25;
pub const DW_OP_xderef: dwarf_location_atom = 24;
pub const DW_OP_rot: dwarf_location_atom = 23;
pub const DW_OP_swap: dwarf_location_atom = 22;
pub const DW_OP_pick: dwarf_location_atom = 21;
pub const DW_OP_over: dwarf_location_atom = 20;
pub const DW_OP_drop: dwarf_location_atom = 19;
pub const DW_OP_dup: dwarf_location_atom = 18;
pub const DW_OP_consts: dwarf_location_atom = 17;
pub const DW_OP_constu: dwarf_location_atom = 16;
pub const DW_OP_const8s: dwarf_location_atom = 15;
pub const DW_OP_const8u: dwarf_location_atom = 14;
pub const DW_OP_const4s: dwarf_location_atom = 13;
pub const DW_OP_const4u: dwarf_location_atom = 12;
pub const DW_OP_const2s: dwarf_location_atom = 11;
pub const DW_OP_const2u: dwarf_location_atom = 10;
pub const DW_OP_const1s: dwarf_location_atom = 9;
pub const DW_OP_const1u: dwarf_location_atom = 8;
pub const DW_OP_deref: dwarf_location_atom = 6;
pub const DW_OP_addr: dwarf_location_atom = 3;
pub type dwarf_type = libc::c_uint;
pub const DW_ATE_HP_VAX_complex_float_d: dwarf_type = 144;
pub const DW_ATE_HP_VAX_complex_float: dwarf_type = 143;
pub const DW_ATE_HP_unsigned_fixed: dwarf_type = 142;
pub const DW_ATE_HP_signed_fixed: dwarf_type = 141;
pub const DW_ATE_HP_edited: dwarf_type = 140;
pub const DW_ATE_HP_zoned_decimal: dwarf_type = 139;
pub const DW_ATE_HP_packed_decimal: dwarf_type = 138;
pub const DW_ATE_HP_VAX_float_d: dwarf_type = 137;
pub const DW_ATE_HP_VAX_float: dwarf_type = 136;
pub const DW_ATE_HP_imaginary_float128: dwarf_type = 134;
pub const DW_ATE_HP_imaginary_float80: dwarf_type = 133;
pub const DW_ATE_HP_floathpintel: dwarf_type = 132;
pub const DW_ATE_HP_complex_float128: dwarf_type = 131;
pub const DW_ATE_HP_float128: dwarf_type = 130;
pub const DW_ATE_HP_complex_float80: dwarf_type = 129;
pub const DW_ATE_HP_float80: dwarf_type = 128;
pub const DW_ATE_hi_user: dwarf_type = 255;
pub const DW_ATE_lo_user: dwarf_type = 128;
pub const DW_ATE_ASCII: dwarf_type = 18;
pub const DW_ATE_UCS: dwarf_type = 17;
pub const DW_ATE_UTF: dwarf_type = 16;
pub const DW_ATE_decimal_float: dwarf_type = 15;
pub const DW_ATE_unsigned_fixed: dwarf_type = 14;
pub const DW_ATE_signed_fixed: dwarf_type = 13;
pub const DW_ATE_edited: dwarf_type = 12;
pub const DW_ATE_numeric_string: dwarf_type = 11;
pub const DW_ATE_packed_decimal: dwarf_type = 10;
pub const DW_ATE_imaginary_float: dwarf_type = 9;
pub const DW_ATE_unsigned_char: dwarf_type = 8;
pub const DW_ATE_unsigned: dwarf_type = 7;
pub const DW_ATE_signed_char: dwarf_type = 6;
pub const DW_ATE_signed: dwarf_type = 5;
pub const DW_ATE_float: dwarf_type = 4;
pub const DW_ATE_complex_float: dwarf_type = 3;
pub const DW_ATE_boolean: dwarf_type = 2;
pub const DW_ATE_address: dwarf_type = 1;
pub const DW_ATE_void: dwarf_type = 0;
pub type dwarf_call_frame_info = libc::c_uint;
pub const DW_CFA_GNU_negative_offset_extended: dwarf_call_frame_info = 47;
pub const DW_CFA_GNU_args_size: dwarf_call_frame_info = 46;
pub const DW_CFA_AARCH64_negate_ra_state: dwarf_call_frame_info = 45;
pub const DW_CFA_GNU_window_save: dwarf_call_frame_info = 45;
pub const DW_CFA_MIPS_advance_loc8: dwarf_call_frame_info = 29;
pub const DW_CFA_hi_user: dwarf_call_frame_info = 63;
pub const DW_CFA_lo_user: dwarf_call_frame_info = 28;
pub const DW_CFA_val_expression: dwarf_call_frame_info = 22;
pub const DW_CFA_val_offset_sf: dwarf_call_frame_info = 21;
pub const DW_CFA_val_offset: dwarf_call_frame_info = 20;
pub const DW_CFA_def_cfa_offset_sf: dwarf_call_frame_info = 19;
pub const DW_CFA_def_cfa_sf: dwarf_call_frame_info = 18;
pub const DW_CFA_offset_extended_sf: dwarf_call_frame_info = 17;
pub const DW_CFA_expression: dwarf_call_frame_info = 16;
pub const DW_CFA_def_cfa_expression: dwarf_call_frame_info = 15;
pub const DW_CFA_def_cfa_offset: dwarf_call_frame_info = 14;
pub const DW_CFA_def_cfa_register: dwarf_call_frame_info = 13;
pub const DW_CFA_def_cfa: dwarf_call_frame_info = 12;
pub const DW_CFA_restore_state: dwarf_call_frame_info = 11;
pub const DW_CFA_remember_state: dwarf_call_frame_info = 10;
pub const DW_CFA_register: dwarf_call_frame_info = 9;
pub const DW_CFA_same_value: dwarf_call_frame_info = 8;
pub const DW_CFA_undefined: dwarf_call_frame_info = 7;
pub const DW_CFA_restore_extended: dwarf_call_frame_info = 6;
pub const DW_CFA_offset_extended: dwarf_call_frame_info = 5;
pub const DW_CFA_advance_loc4: dwarf_call_frame_info = 4;
pub const DW_CFA_advance_loc2: dwarf_call_frame_info = 3;
pub const DW_CFA_advance_loc1: dwarf_call_frame_info = 2;
pub const DW_CFA_set_loc: dwarf_call_frame_info = 1;
pub const DW_CFA_nop: dwarf_call_frame_info = 0;
pub const DW_CFA_restore: dwarf_call_frame_info = 192;
pub const DW_CFA_offset: dwarf_call_frame_info = 128;
pub const DW_CFA_advance_loc: dwarf_call_frame_info = 64;
pub type dwarf_unit_type = libc::c_uint;
pub const DW_UT_hi_user: dwarf_unit_type = 255;
pub const DW_UT_lo_user: dwarf_unit_type = 128;
pub const DW_UT_split_type: dwarf_unit_type = 6;
pub const DW_UT_split_compile: dwarf_unit_type = 5;
pub const DW_UT_skeleton: dwarf_unit_type = 4;
pub const DW_UT_partial: dwarf_unit_type = 3;
pub const DW_UT_type: dwarf_unit_type = 2;
pub const DW_UT_compile: dwarf_unit_type = 1;
pub type dwarf_decimal_sign_encoding = libc::c_uint;
pub const DW_DS_trailing_separate: dwarf_decimal_sign_encoding = 5;
pub const DW_DS_leading_separate: dwarf_decimal_sign_encoding = 4;
pub const DW_DS_trailing_overpunch: dwarf_decimal_sign_encoding = 3;
pub const DW_DS_leading_overpunch: dwarf_decimal_sign_encoding = 2;
pub const DW_DS_unsigned: dwarf_decimal_sign_encoding = 1;
pub type dwarf_endianity_encoding = libc::c_uint;
pub const DW_END_hi_user: dwarf_endianity_encoding = 255;
pub const DW_END_lo_user: dwarf_endianity_encoding = 64;
pub const DW_END_little: dwarf_endianity_encoding = 2;
pub const DW_END_big: dwarf_endianity_encoding = 1;
pub const DW_END_default: dwarf_endianity_encoding = 0;
pub type dwarf_access_attribute = libc::c_uint;
pub const DW_ACCESS_private: dwarf_access_attribute = 3;
pub const DW_ACCESS_protected: dwarf_access_attribute = 2;
pub const DW_ACCESS_public: dwarf_access_attribute = 1;
pub type dwarf_visibility_attribute = libc::c_uint;
pub const DW_VIS_qualified: dwarf_visibility_attribute = 3;
pub const DW_VIS_exported: dwarf_visibility_attribute = 2;
pub const DW_VIS_local: dwarf_visibility_attribute = 1;
pub type dwarf_virtuality_attribute = libc::c_uint;
pub const DW_VIRTUALITY_pure_virtual: dwarf_virtuality_attribute = 2;
pub const DW_VIRTUALITY_virtual: dwarf_virtuality_attribute = 1;
pub const DW_VIRTUALITY_none: dwarf_virtuality_attribute = 0;
pub type dwarf_id_case = libc::c_uint;
pub const DW_ID_case_insensitive: dwarf_id_case = 3;
pub const DW_ID_down_case: dwarf_id_case = 2;
pub const DW_ID_up_case: dwarf_id_case = 1;
pub const DW_ID_case_sensitive: dwarf_id_case = 0;
pub type dwarf_calling_convention = libc::c_uint;
pub const DW_CC_GDB_IBM_OpenCL: dwarf_calling_convention = 255;
pub const DW_CC_GNU_borland_fastcall_i386: dwarf_calling_convention = 65;
pub const DW_CC_GNU_renesas_sh: dwarf_calling_convention = 64;
pub const DW_CC_hi_user: dwarf_calling_convention = 255;
pub const DW_CC_lo_user: dwarf_calling_convention = 64;
pub const DW_CC_pass_by_value: dwarf_calling_convention = 5;
pub const DW_CC_pass_by_reference: dwarf_calling_convention = 4;
pub const DW_CC_nocall: dwarf_calling_convention = 3;
pub const DW_CC_program: dwarf_calling_convention = 2;
pub const DW_CC_normal: dwarf_calling_convention = 1;
pub type dwarf_inline_attribute = libc::c_uint;
pub const DW_INL_declared_inlined: dwarf_inline_attribute = 3;
pub const DW_INL_declared_not_inlined: dwarf_inline_attribute = 2;
pub const DW_INL_inlined: dwarf_inline_attribute = 1;
pub const DW_INL_not_inlined: dwarf_inline_attribute = 0;
pub type dwarf_discrim_list = libc::c_uint;
pub const DW_DSC_range: dwarf_discrim_list = 1;
pub const DW_DSC_label: dwarf_discrim_list = 0;
pub type dwarf_line_number_ops = libc::c_uint;
pub const DW_LNS_set_isa: dwarf_line_number_ops = 12;
pub const DW_LNS_set_epilogue_begin: dwarf_line_number_ops = 11;
pub const DW_LNS_set_prologue_end: dwarf_line_number_ops = 10;
pub const DW_LNS_fixed_advance_pc: dwarf_line_number_ops = 9;
pub const DW_LNS_const_add_pc: dwarf_line_number_ops = 8;
pub const DW_LNS_set_basic_block: dwarf_line_number_ops = 7;
pub const DW_LNS_negate_stmt: dwarf_line_number_ops = 6;
pub const DW_LNS_set_column: dwarf_line_number_ops = 5;
pub const DW_LNS_set_file: dwarf_line_number_ops = 4;
pub const DW_LNS_advance_line: dwarf_line_number_ops = 3;
pub const DW_LNS_advance_pc: dwarf_line_number_ops = 2;
pub const DW_LNS_copy: dwarf_line_number_ops = 1;
pub const DW_LNS_extended_op: dwarf_line_number_ops = 0;
pub type dwarf_line_number_x_ops = libc::c_uint;
pub const DW_LNE_hi_user: dwarf_line_number_x_ops = 255;
pub const DW_LNE_lo_user: dwarf_line_number_x_ops = 128;
pub const DW_LNE_HP_source_file_correlation: dwarf_line_number_x_ops = 128;
pub const DW_LNE_HP_define_proc: dwarf_line_number_x_ops = 32;
pub const DW_LNE_HP_negate_front_end_logical: dwarf_line_number_x_ops = 25;
pub const DW_LNE_HP_negate_function_exit: dwarf_line_number_x_ops = 24;
pub const DW_LNE_HP_negate_post_semantics: dwarf_line_number_x_ops = 23;
pub const DW_LNE_HP_set_sequence: dwarf_line_number_x_ops = 22;
pub const DW_LNE_HP_set_routine_name: dwarf_line_number_x_ops = 21;
pub const DW_LNE_HP_set_file_line_column: dwarf_line_number_x_ops = 20;
pub const DW_LNE_HP_pop_context: dwarf_line_number_x_ops = 19;
pub const DW_LNE_HP_push_context: dwarf_line_number_x_ops = 18;
pub const DW_LNE_HP_negate_is_UV_update: dwarf_line_number_x_ops = 17;
pub const DW_LNE_set_discriminator: dwarf_line_number_x_ops = 4;
pub const DW_LNE_define_file: dwarf_line_number_x_ops = 3;
pub const DW_LNE_set_address: dwarf_line_number_x_ops = 2;
pub const DW_LNE_end_sequence: dwarf_line_number_x_ops = 1;
pub type dwarf_line_number_hp_sfc_ops = libc::c_uint;
pub const DW_LNE_HP_SFC_associate: dwarf_line_number_hp_sfc_ops = 3;
pub const DW_LNE_HP_SFC_set_listing_line: dwarf_line_number_hp_sfc_ops = 2;
pub const DW_LNE_HP_SFC_formfeed: dwarf_line_number_hp_sfc_ops = 1;
pub type dwarf_line_number_content_type = libc::c_uint;
pub const DW_LNCT_hi_user: dwarf_line_number_content_type = 16383;
pub const DW_LNCT_lo_user: dwarf_line_number_content_type = 8192;
pub const DW_LNCT_MD5: dwarf_line_number_content_type = 5;
pub const DW_LNCT_size: dwarf_line_number_content_type = 4;
pub const DW_LNCT_timestamp: dwarf_line_number_content_type = 3;
pub const DW_LNCT_directory_index: dwarf_line_number_content_type = 2;
pub const DW_LNCT_path: dwarf_line_number_content_type = 1;
pub type dwarf_location_list_entry_type = libc::c_uint;
pub const DW_LLE_GNU_start_length_entry: dwarf_location_list_entry_type = 3;
pub const DW_LLE_GNU_start_end_entry: dwarf_location_list_entry_type = 2;
pub const DW_LLE_GNU_base_address_selection_entry: dwarf_location_list_entry_type = 1;
pub const DW_LLE_GNU_end_of_list_entry: dwarf_location_list_entry_type = 0;
pub const DW_LLE_GNU_view_pair: dwarf_location_list_entry_type = 9;
pub const DW_LLE_start_length: dwarf_location_list_entry_type = 8;
pub const DW_LLE_start_end: dwarf_location_list_entry_type = 7;
pub const DW_LLE_base_address: dwarf_location_list_entry_type = 6;
pub const DW_LLE_default_location: dwarf_location_list_entry_type = 5;
pub const DW_LLE_offset_pair: dwarf_location_list_entry_type = 4;
pub const DW_LLE_startx_length: dwarf_location_list_entry_type = 3;
pub const DW_LLE_startx_endx: dwarf_location_list_entry_type = 2;
pub const DW_LLE_base_addressx: dwarf_location_list_entry_type = 1;
pub const DW_LLE_end_of_list: dwarf_location_list_entry_type = 0;
pub type dwarf_source_language = libc::c_uint;
pub const DW_LANG_Rust_old: dwarf_source_language = 36864;
pub const DW_LANG_HP_Assembler: dwarf_source_language = 32775;
pub const DW_LANG_HP_IMacro: dwarf_source_language = 32774;
pub const DW_LANG_HP_Pascal91: dwarf_source_language = 32773;
pub const DW_LANG_HP_Basic91: dwarf_source_language = 32772;
pub const DW_LANG_HP_Bliss: dwarf_source_language = 32771;
pub const DW_LANG_Upc: dwarf_source_language = 34661;
pub const DW_LANG_Mips_Assembler: dwarf_source_language = 32769;
pub const DW_LANG_hi_user: dwarf_source_language = 65535;
pub const DW_LANG_lo_user: dwarf_source_language = 32768;
pub const DW_LANG_RenderScript: dwarf_source_language = 36;
pub const DW_LANG_Fortran08: dwarf_source_language = 35;
pub const DW_LANG_Fortran03: dwarf_source_language = 34;
pub const DW_LANG_C_plus_plus_14: dwarf_source_language = 33;
pub const DW_LANG_Dylan: dwarf_source_language = 32;
pub const DW_LANG_Julia: dwarf_source_language = 31;
pub const DW_LANG_Swift: dwarf_source_language = 30;
pub const DW_LANG_C11: dwarf_source_language = 29;
pub const DW_LANG_Rust: dwarf_source_language = 28;
pub const DW_LANG_OCaml: dwarf_source_language = 27;
pub const DW_LANG_C_plus_plus_11: dwarf_source_language = 26;
pub const DW_LANG_C_plus_plus_03: dwarf_source_language = 25;
pub const DW_LANG_Haskell: dwarf_source_language = 24;
pub const DW_LANG_Modula3: dwarf_source_language = 23;
pub const DW_LANG_Go: dwarf_source_language = 22;
pub const DW_LANG_OpenCL: dwarf_source_language = 21;
pub const DW_LANG_Python: dwarf_source_language = 20;
pub const DW_LANG_D: dwarf_source_language = 19;
pub const DW_LANG_UPC: dwarf_source_language = 18;
pub const DW_LANG_ObjC_plus_plus: dwarf_source_language = 17;
pub const DW_LANG_ObjC: dwarf_source_language = 16;
pub const DW_LANG_PLI: dwarf_source_language = 15;
pub const DW_LANG_Fortran95: dwarf_source_language = 14;
pub const DW_LANG_Ada95: dwarf_source_language = 13;
pub const DW_LANG_C99: dwarf_source_language = 12;
pub const DW_LANG_Java: dwarf_source_language = 11;
pub const DW_LANG_Modula2: dwarf_source_language = 10;
pub const DW_LANG_Pascal83: dwarf_source_language = 9;
pub const DW_LANG_Fortran90: dwarf_source_language = 8;
pub const DW_LANG_Fortran77: dwarf_source_language = 7;
pub const DW_LANG_Cobol85: dwarf_source_language = 6;
pub const DW_LANG_Cobol74: dwarf_source_language = 5;
pub const DW_LANG_C_plus_plus: dwarf_source_language = 4;
pub const DW_LANG_Ada83: dwarf_source_language = 3;
pub const DW_LANG_C: dwarf_source_language = 2;
pub const DW_LANG_C89: dwarf_source_language = 1;
pub type dwarf_macinfo_record_type = libc::c_uint;
pub const DW_MACINFO_vendor_ext: dwarf_macinfo_record_type = 255;
pub const DW_MACINFO_end_file: dwarf_macinfo_record_type = 4;
pub const DW_MACINFO_start_file: dwarf_macinfo_record_type = 3;
pub const DW_MACINFO_undef: dwarf_macinfo_record_type = 2;
pub const DW_MACINFO_define: dwarf_macinfo_record_type = 1;
pub type dwarf_defaulted_attribute = libc::c_uint;
pub const DW_DEFAULTED_out_of_class: dwarf_defaulted_attribute = 2;
pub const DW_DEFAULTED_in_class: dwarf_defaulted_attribute = 1;
pub const DW_DEFAULTED_no: dwarf_defaulted_attribute = 0;
pub type dwarf_macro_record_type = libc::c_uint;
pub const DW_MACRO_GNU_hi_user: dwarf_macro_record_type = 255;
pub const DW_MACRO_GNU_lo_user: dwarf_macro_record_type = 224;
pub const DW_MACRO_GNU_transparent_include_alt: dwarf_macro_record_type = 10;
pub const DW_MACRO_GNU_undef_indirect_alt: dwarf_macro_record_type = 9;
pub const DW_MACRO_GNU_define_indirect_alt: dwarf_macro_record_type = 8;
pub const DW_MACRO_GNU_transparent_include: dwarf_macro_record_type = 7;
pub const DW_MACRO_GNU_undef_indirect: dwarf_macro_record_type = 6;
pub const DW_MACRO_GNU_define_indirect: dwarf_macro_record_type = 5;
pub const DW_MACRO_GNU_end_file: dwarf_macro_record_type = 4;
pub const DW_MACRO_GNU_start_file: dwarf_macro_record_type = 3;
pub const DW_MACRO_GNU_undef: dwarf_macro_record_type = 2;
pub const DW_MACRO_GNU_define: dwarf_macro_record_type = 1;
pub const DW_MACRO_hi_user: dwarf_macro_record_type = 255;
pub const DW_MACRO_lo_user: dwarf_macro_record_type = 224;
pub const DW_MACRO_undef_strx: dwarf_macro_record_type = 12;
pub const DW_MACRO_define_strx: dwarf_macro_record_type = 11;
pub const DW_MACRO_import_sup: dwarf_macro_record_type = 10;
pub const DW_MACRO_undef_sup: dwarf_macro_record_type = 9;
pub const DW_MACRO_define_sup: dwarf_macro_record_type = 8;
pub const DW_MACRO_import: dwarf_macro_record_type = 7;
pub const DW_MACRO_undef_strp: dwarf_macro_record_type = 6;
pub const DW_MACRO_define_strp: dwarf_macro_record_type = 5;
pub const DW_MACRO_end_file: dwarf_macro_record_type = 4;
pub const DW_MACRO_start_file: dwarf_macro_record_type = 3;
pub const DW_MACRO_undef: dwarf_macro_record_type = 2;
pub const DW_MACRO_define: dwarf_macro_record_type = 1;
pub type dwarf_range_list_entry = libc::c_uint;
pub const DW_RLE_start_length: dwarf_range_list_entry = 7;
pub const DW_RLE_start_end: dwarf_range_list_entry = 6;
pub const DW_RLE_base_address: dwarf_range_list_entry = 5;
pub const DW_RLE_offset_pair: dwarf_range_list_entry = 4;
pub const DW_RLE_startx_length: dwarf_range_list_entry = 3;
pub const DW_RLE_startx_endx: dwarf_range_list_entry = 2;
pub const DW_RLE_base_addressx: dwarf_range_list_entry = 1;
pub const DW_RLE_end_of_list: dwarf_range_list_entry = 0;
pub type dwarf_sect = libc::c_uint;
pub const DW_SECT_MAX: dwarf_sect = 8;
pub const DW_SECT_MACRO: dwarf_sect = 8;
pub const DW_SECT_MACINFO: dwarf_sect = 7;
pub const DW_SECT_STR_OFFSETS: dwarf_sect = 6;
pub const DW_SECT_LOC: dwarf_sect = 5;
pub const DW_SECT_LINE: dwarf_sect = 4;
pub const DW_SECT_ABBREV: dwarf_sect = 3;
pub const DW_SECT_TYPES: dwarf_sect = 2;
pub const DW_SECT_INFO: dwarf_sect = 1;
pub type dwarf_vma = libc::c_ulong;
pub type dwarf_signed_vma = libc::c_long;
pub type dwarf_size_type = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DWARF2_Internal_LineInfo {
    pub li_length: dwarf_vma,
    pub li_version: libc::c_ushort,
    pub li_address_size: libc::c_uchar,
    pub li_segment_size: libc::c_uchar,
    pub li_prologue_length: dwarf_vma,
    pub li_min_insn_length: libc::c_uchar,
    pub li_max_ops_per_insn: libc::c_uchar,
    pub li_default_is_stmt: libc::c_uchar,
    pub li_line_base: libc::c_int,
    pub li_line_range: libc::c_uchar,
    pub li_opcode_base: libc::c_uchar,
    pub li_offset_size: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DWARF2_Internal_PubNames {
    pub pn_length: dwarf_vma,
    pub pn_version: libc::c_ushort,
    pub pn_offset: dwarf_vma,
    pub pn_size: dwarf_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DWARF2_Internal_CompUnit {
    pub cu_length: dwarf_vma,
    pub cu_version: libc::c_ushort,
    pub cu_abbrev_offset: dwarf_vma,
    pub cu_pointer_size: libc::c_uchar,
    pub cu_unit_type: dwarf_unit_type,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DWARF2_Internal_ARange {
    pub ar_length: dwarf_vma,
    pub ar_version: libc::c_ushort,
    pub ar_info_offset: dwarf_vma,
    pub ar_pointer_size: libc::c_uchar,
    pub ar_segment_size: libc::c_uchar,
}
pub type dwarf_section_display_enum = libc::c_uint;
pub const max: dwarf_section_display_enum = 44;
pub const separate_debug_str: dwarf_section_display_enum = 43;
pub const debug_sup: dwarf_section_display_enum = 42;
pub const gnu_debugaltlink: dwarf_section_display_enum = 41;
pub const gnu_debuglink: dwarf_section_display_enum = 40;
pub const dwp_tu_index: dwarf_section_display_enum = 39;
pub const dwp_cu_index: dwarf_section_display_enum = 38;
pub const debug_addr: dwarf_section_display_enum = 37;
pub const str_index_dwo: dwarf_section_display_enum = 36;
pub const str_index: dwarf_section_display_enum = 35;
pub const str_dwo: dwarf_section_display_enum = 34;
pub const macinfo_dwo: dwarf_section_display_enum = 33;
pub const macro_dwo: dwarf_section_display_enum = 32;
pub const loc_dwo: dwarf_section_display_enum = 31;
pub const line_dwo: dwarf_section_display_enum = 30;
pub const types_dwo: dwarf_section_display_enum = 29;
pub const abbrev_dwo: dwarf_section_display_enum = 28;
pub const info_dwo: dwarf_section_display_enum = 27;
pub const trace_aranges: dwarf_section_display_enum = 26;
pub const trace_abbrev: dwarf_section_display_enum = 25;
pub const trace_info: dwarf_section_display_enum = 24;
pub const debug_names: dwarf_section_display_enum = 23;
pub const gdb_index: dwarf_section_display_enum = 22;
pub const weaknames: dwarf_section_display_enum = 21;
pub const types: dwarf_section_display_enum = 20;
pub const static_vars: dwarf_section_display_enum = 19;
pub const static_func: dwarf_section_display_enum = 18;
pub const rnglists: dwarf_section_display_enum = 17;
pub const ranges: dwarf_section_display_enum = 16;
pub const gnu_pubtypes: dwarf_section_display_enum = 15;
pub const pubtypes: dwarf_section_display_enum = 14;
pub const loclists: dwarf_section_display_enum = 13;
pub const loc: dwarf_section_display_enum = 12;
pub const line_str: dwarf_section_display_enum = 11;
pub const str: dwarf_section_display_enum = 10;
pub const macro_0: dwarf_section_display_enum = 9;
pub const macinfo: dwarf_section_display_enum = 8;
pub const eh_frame: dwarf_section_display_enum = 7;
pub const gnu_pubnames: dwarf_section_display_enum = 6;
pub const pubnames: dwarf_section_display_enum = 5;
pub const line: dwarf_section_display_enum = 4;
pub const info: dwarf_section_display_enum = 3;
pub const frame: dwarf_section_display_enum = 2;
pub const aranges: dwarf_section_display_enum = 1;
pub const abbrev: dwarf_section_display_enum = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_section {
    pub uncompressed_name: *const libc::c_char,
    pub compressed_name: *const libc::c_char,
    pub name: *const libc::c_char,
    pub filename: *const libc::c_char,
    pub start: *mut libc::c_uchar,
    pub address: dwarf_vma,
    pub size: dwarf_size_type,
    pub abbrev_sec: dwarf_section_display_enum,
    pub reloc_info: *mut libc::c_void,
    pub num_relocs: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_section_display {
    pub section: dwarf_section,
    pub display: Option::<
        unsafe extern "C" fn(*mut dwarf_section, *mut libc::c_void) -> libc::c_int,
    >,
    pub enabled: *mut libc::c_int,
    pub relocate: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cu_tu_set {
    pub signature: uint64_t,
    pub section_offsets: [dwarf_vma; 8],
    pub section_sizes: [size_t; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_vmatoa_buf {
    pub place: [libc::c_char; 64],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct debug_info {
    pub pointer_size: libc::c_uint,
    pub offset_size: libc::c_uint,
    pub dwarf_version: libc::c_int,
    pub cu_offset: dwarf_vma,
    pub base_address: dwarf_vma,
    pub addr_base: dwarf_vma,
    pub ranges_base: dwarf_vma,
    pub loc_offsets: *mut dwarf_vma,
    pub loc_views: *mut dwarf_vma,
    pub have_frame_base: *mut libc::c_int,
    pub num_loc_offsets: libc::c_uint,
    pub max_loc_offsets: libc::c_uint,
    pub num_loc_views: libc::c_uint,
    pub range_lists: *mut dwarf_vma,
    pub num_range_lists: libc::c_uint,
    pub max_range_lists: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct abbrev_entry {
    pub number: libc::c_ulong,
    pub tag: libc::c_ulong,
    pub children: libc::c_int,
    pub first_attr: *mut abbrev_attr,
    pub last_attr: *mut abbrev_attr,
    pub next: *mut abbrev_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct abbrev_attr {
    pub attribute: libc::c_ulong,
    pub form: libc::c_ulong,
    pub implicit_const: dwarf_signed_vma,
    pub next: *mut abbrev_attr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct abbrev_map {
    pub start: dwarf_vma,
    pub end: dwarf_vma,
    pub list: *mut abbrev_list,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct abbrev_list {
    pub first_abbrev: *mut abbrev_entry,
    pub last_abbrev: *mut abbrev_entry,
    pub abbrev_base: dwarf_vma,
    pub abbrev_offset: dwarf_vma,
    pub next: *mut abbrev_list,
    pub start_of_next_abbrevs: *mut libc::c_uchar,
}
pub type dwarf_regname_lookup_ftype = Option::<
    unsafe extern "C" fn(libc::c_uint) -> *const libc::c_char,
>;
pub type dwo_type = libc::c_uint;
pub const DWO_ID: dwo_type = 2;
pub const DWO_DIR: dwo_type = 1;
pub const DWO_NAME: dwo_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwo_info {
    pub type_0: dwo_type,
    pub value: *const libc::c_char,
    pub cu_offset: dwarf_vma,
    pub next: *mut dwo_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct separate_info {
    pub handle: *mut libc::c_void,
    pub filename: *const libc::c_char,
    pub next: *mut separate_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct File_Entry {
    pub name: *mut libc::c_uchar,
    pub directory_index: libc::c_uint,
    pub modification_date: libc::c_uint,
    pub length: libc::c_uint,
}
pub type SMR = State_Machine_Registers;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct State_Machine_Registers {
    pub address: dwarf_vma,
    pub view: libc::c_uint,
    pub file: libc::c_uint,
    pub line: libc::c_uint,
    pub column: libc::c_uint,
    pub is_stmt: libc::c_int,
    pub basic_block: libc::c_int,
    pub op_index: libc::c_uchar,
    pub end_sequence: libc::c_uchar,
    pub last_file_entry: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct abbrev_lookup_entry {
    pub abbrev_tag: dwarf_vma,
    pub abbrev_lookup_ptr: *mut libc::c_uchar,
}
pub const _sch_isprint: C2RustUnnamed = 16;
pub type gdb_index_symbol_kind = libc::c_uint;
pub const GDB_INDEX_SYMBOL_KIND_UNUSED7: gdb_index_symbol_kind = 7;
pub const GDB_INDEX_SYMBOL_KIND_UNUSED6: gdb_index_symbol_kind = 6;
pub const GDB_INDEX_SYMBOL_KIND_UNUSED5: gdb_index_symbol_kind = 5;
pub const GDB_INDEX_SYMBOL_KIND_OTHER: gdb_index_symbol_kind = 4;
pub const GDB_INDEX_SYMBOL_KIND_FUNCTION: gdb_index_symbol_kind = 3;
pub const GDB_INDEX_SYMBOL_KIND_VARIABLE: gdb_index_symbol_kind = 2;
pub const GDB_INDEX_SYMBOL_KIND_TYPE: gdb_index_symbol_kind = 1;
pub const GDB_INDEX_SYMBOL_KIND_NONE: gdb_index_symbol_kind = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct range_entry {
    pub ranges_offset: dwarf_vma,
    pub debug_info_p: *mut debug_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Frame_Chunk {
    pub next: *mut Frame_Chunk,
    pub chunk_start: *mut libc::c_uchar,
    pub ncols: libc::c_uint,
    pub col_type: *mut libc::c_short,
    pub col_offset: *mut libc::c_int,
    pub augmentation: *mut libc::c_char,
    pub code_factor: libc::c_uint,
    pub data_factor: libc::c_int,
    pub pc_begin: dwarf_vma,
    pub pc_range: dwarf_vma,
    pub cfa_reg: libc::c_uint,
    pub cfa_offset: dwarf_vma,
    pub ra: libc::c_uint,
    pub fde_encoding: libc::c_uchar,
    pub cfa_exp: libc::c_uchar,
    pub ptr_size: libc::c_uchar,
    pub segment_size: libc::c_uchar,
}
pub type check_func_type = Option::<
    unsafe extern "C" fn(*const libc::c_char, *mut libc::c_void) -> bool,
>;
pub type parse_func_type = Option::<
    unsafe extern "C" fn(*mut dwarf_section, *mut libc::c_void) -> *const libc::c_char,
>;
pub type Build_id_data = build_id_data;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct build_id_data {
    pub len: bfd_size_type,
    pub data: *const libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct debug_dump_long_opts {
    pub option: *const libc::c_char,
    pub variable: *mut libc::c_int,
    pub val: libc::c_int,
}
pub type C2RustUnnamed = libc::c_uint;
pub const _sch_isbasic: C2RustUnnamed = 3088;
pub const _sch_iscppsp: C2RustUnnamed = 3072;
pub const _sch_isgraph: C2RustUnnamed = 172;
pub const _sch_isidnum: C2RustUnnamed = 516;
pub const _sch_isalnum: C2RustUnnamed = 140;
pub const _sch_isalpha: C2RustUnnamed = 136;
pub const _sch_isnvsp: C2RustUnnamed = 2048;
pub const _sch_isvsp: C2RustUnnamed = 1024;
pub const _sch_isidst: C2RustUnnamed = 512;
pub const _sch_isxdigit: C2RustUnnamed = 256;
pub const _sch_isupper: C2RustUnnamed = 128;
pub const _sch_isspace: C2RustUnnamed = 64;
pub const _sch_ispunct: C2RustUnnamed = 32;
pub const _sch_islower: C2RustUnnamed = 8;
pub const _sch_isdigit: C2RustUnnamed = 4;
pub const _sch_iscntrl: C2RustUnnamed = 2;
pub const _sch_isblank: C2RustUnnamed = 1;
#[inline]
unsafe extern "C" fn putchar(mut __c: libc::c_int) -> libc::c_int {
    return putc(__c, stdout);
}
#[inline]
unsafe extern "C" fn startswith(
    mut str_0: *const libc::c_char,
    mut prefix: *const libc::c_char,
) -> bool {
    return strncmp(str_0, prefix, strlen(prefix)) == 0 as libc::c_int;
}
#[no_mangle]
pub static mut debug_displays: [dwarf_section_display; 44] = unsafe {
    [
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_abbrev\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_abbrev\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_abbrev
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_abbrevs as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_aranges\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_aranges\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_aranges
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_aranges as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_frame\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_frame\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_frames
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_frames as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_info\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_info\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_info
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_info as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_line\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_line\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_lines
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_lines as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_pubnames\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_pubnames\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_pubnames
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_pubnames as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_gnu_pubnames\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_gnu_pubnames\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_gnu_pubnames
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_pubnames as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".eh_frame\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_frames
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_frames as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_macinfo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_macinfo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_macinfo
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_macinfo as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_macro\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_macro\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_macro
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_macinfo as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_str\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_str\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_str
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_str as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_line_str\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_line_str\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_str
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_str as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_loc\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_loc\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_loc
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_loc as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_loclists\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_loclists\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_loc
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_loc as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_pubtypes\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_pubtypes\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_pubnames
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_pubtypes as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_gnu_pubtypes\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_gnu_pubtypes\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_gnu_pubnames
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_pubtypes as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_ranges\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_ranges\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_ranges
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_ranges as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_rnglists\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_rnglists\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_ranges
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_ranges as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_static_func\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_static_func\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_not_supported
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: 0 as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_static_vars\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_static_vars\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_not_supported
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: 0 as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_types\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_types\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_types
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_info as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_weaknames\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_weaknames\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_not_supported
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: 0 as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".gdb_index\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_gdb_index
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_gdb_index as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_names\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_names
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_gdb_index as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".trace_info\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: trace_abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_trace_info
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_trace_info as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".trace_abbrev\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_abbrev
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_trace_abbrevs as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".trace_aranges\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_aranges
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_trace_aranges as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_info.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_info.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev_dwo,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_info
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_info as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_abbrev.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_abbrev.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_abbrev
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_abbrevs as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_types.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_types.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev_dwo,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_types
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_info as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_line.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_line.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_lines
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_lines as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_loc.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_loc.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_loc
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_loc as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_macro.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_macro.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_macro
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_macinfo as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_macinfo.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_macinfo.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_macinfo
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_macinfo as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_str.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_str.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_str
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_str as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_str_offsets\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_str_offsets\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_str_offsets
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_str_offsets as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_str_offsets.dwo\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_str_offsets.dwo\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_str_offsets
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_str_offsets as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_addr\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_addr\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_addr
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_addr as *const libc::c_int as *mut libc::c_int,
                relocate: 1 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_cu_index\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_cu_index
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_cu_index as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_tu_index\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_cu_index
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_cu_index as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".gnu_debuglink\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_links
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_links as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".gnu_debugaltlink\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_links
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_links as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_sup\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b"\0" as *const u8 as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_sup
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_links as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
        {
            let mut init = dwarf_section_display {
                section: {
                    let mut init = dwarf_section {
                        uncompressed_name: b".debug_str\0" as *const u8
                            as *const libc::c_char,
                        compressed_name: b".zdebug_str\0" as *const u8
                            as *const libc::c_char,
                        name: 0 as *const libc::c_char,
                        filename: 0 as *const libc::c_char,
                        start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
                        address: 0 as libc::c_int as dwarf_vma,
                        size: 0 as libc::c_int as dwarf_size_type,
                        abbrev_sec: abbrev,
                        reloc_info: 0 as *const libc::c_void as *mut libc::c_void,
                        num_relocs: 0 as libc::c_int as libc::c_ulong,
                    };
                    init
                },
                display: Some(
                    display_debug_str
                        as unsafe extern "C" fn(
                            *mut dwarf_section,
                            *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                enabled: &do_debug_str as *const libc::c_int as *mut libc::c_int,
                relocate: 0 as libc::c_int != 0,
            };
            init
        },
    ]
};
#[no_mangle]
pub static mut first_separate_info: *mut separate_info = 0 as *const separate_info
    as *mut separate_info;
#[no_mangle]
pub static mut eh_addr_size: libc::c_uint = 0;
#[no_mangle]
pub static mut do_debug_info: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_abbrevs: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_lines: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_pubnames: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_pubtypes: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_aranges: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_ranges: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_frames: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_frames_interp: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_macinfo: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_str: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_str_offsets: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_loc: libc::c_int = 0;
#[no_mangle]
pub static mut do_gdb_index: libc::c_int = 0;
#[no_mangle]
pub static mut do_trace_info: libc::c_int = 0;
#[no_mangle]
pub static mut do_trace_abbrevs: libc::c_int = 0;
#[no_mangle]
pub static mut do_trace_aranges: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_addr: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_cu_index: libc::c_int = 0;
#[no_mangle]
pub static mut do_wide: libc::c_int = 0;
#[no_mangle]
pub static mut do_debug_links: libc::c_int = 0;
#[no_mangle]
pub static mut do_follow_links: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut do_checks: bool = false;
#[no_mangle]
pub static mut dwarf_cutoff_level: libc::c_int = -(1 as libc::c_int);
#[no_mangle]
pub static mut dwarf_start_die: libc::c_ulong = 0;
#[no_mangle]
pub static mut dwarf_check: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub unsafe extern "C" fn init_dwarf_regnames_by_elf_machine_code(
    mut e_machine: libc::c_uint,
) {
    dwarf_regnames_lookup_func = None;
    match e_machine {
        3 => {
            init_dwarf_regnames_i386();
        }
        6 => {
            init_dwarf_regnames_iamcu();
        }
        62 | 180 | 181 => {
            init_dwarf_regnames_x86_64();
        }
        183 => {
            init_dwarf_regnames_aarch64();
        }
        22 => {
            init_dwarf_regnames_s390();
        }
        243 => {
            init_dwarf_regnames_riscv();
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn init_dwarf_regnames_by_bfd_arch_and_mach(
    mut arch: bfd_architecture,
    mut mach: libc::c_ulong,
) {
    dwarf_regnames_lookup_func = None;
    match arch as libc::c_uint {
        8 => {
            match mach {
                8 | 9 | 16 | 17 => {
                    init_dwarf_regnames_x86_64();
                }
                _ => {
                    init_dwarf_regnames_i386();
                }
            }
        }
        11 => {
            init_dwarf_regnames_iamcu();
        }
        81 => {
            init_dwarf_regnames_aarch64();
        }
        68 => {
            init_dwarf_regnames_s390();
        }
        65 => {
            init_dwarf_regnames_riscv();
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn load_separate_debug_files(
    mut file: *mut libc::c_void,
    mut filename: *const libc::c_char,
) -> bool {
    if do_follow_links == 0 && do_debug_links == 0 {
        return 0 as libc::c_int != 0;
    }
    if load_debug_section(str, file) as libc::c_int != 0
        && load_debug_section(abbrev, file) as libc::c_int != 0
        && load_debug_section(info, file) as libc::c_int != 0
    {
        free_dwo_info();
        if process_debug_info(
            &mut (*debug_displays.as_mut_ptr().offset(info as libc::c_int as isize))
                .section,
            file,
            abbrev,
            1 as libc::c_int != 0,
            0 as libc::c_int != 0,
        ) {
            let mut introduced: bool = 0 as libc::c_int != 0;
            let mut dwinfo: *mut dwo_info = 0 as *mut dwo_info;
            let mut dir: *const libc::c_char = 0 as *const libc::c_char;
            let mut id: *const libc::c_char = 0 as *const libc::c_char;
            let mut name: *const libc::c_char = 0 as *const libc::c_char;
            dwinfo = first_dwo_info;
            while !dwinfo.is_null() {
                match (*dwinfo).type_0 as libc::c_uint {
                    0 => {
                        if !name.is_null() {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Multiple DWO_NAMEs encountered for the same CU\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        name = (*dwinfo).value;
                    }
                    1 => {
                        dir = (*dwinfo).value;
                    }
                    2 => {
                        if !id.is_null() {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"multiple DWO_IDs encountered for the same CU\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        id = (*dwinfo).value;
                    }
                    _ => {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Unexpected DWO INFO type\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
                if !name.is_null()
                    && (((*dwinfo).next).is_null()
                        || (*(*dwinfo).next).cu_offset != (*dwinfo).cu_offset)
                {
                    if do_debug_links != 0 {
                        if !introduced {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"The %s section contains link(s) to dwo file(s):\n\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                (*debug_displays
                                    .as_mut_ptr()
                                    .offset(info as libc::c_int as isize))
                                    .section
                                    .uncompressed_name,
                            );
                            introduced = 1 as libc::c_int != 0;
                        }
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Name:      %s\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            name,
                        );
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Directory: %s\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            if !dir.is_null() {
                                dir
                            } else {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"<not-found>\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ) as *const libc::c_char
                            },
                        );
                        if !id.is_null() {
                            display_data(
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"  ID:       \0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                ) as bfd_size_type,
                                id as *mut libc::c_uchar,
                                8 as libc::c_int as bfd_size_type,
                            );
                        } else {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  ID:        <not specified>\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        printf(b"\n\n\0" as *const u8 as *const libc::c_char);
                    }
                    if do_follow_links != 0 {
                        load_dwo_file(filename, name, dir, id);
                    }
                    id = 0 as *const libc::c_char;
                    dir = id;
                    name = dir;
                }
                dwinfo = (*dwinfo).next;
            }
        }
    }
    if do_follow_links == 0 {
        return 0 as libc::c_int != 0;
    }
    check_for_and_load_links(file, filename);
    if !first_separate_info.is_null() {
        return 1 as libc::c_int != 0;
    }
    do_follow_links = 0 as libc::c_int;
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn free_debug_memory() {
    let mut i: libc::c_uint = 0;
    free_all_abbrevs();
    free(cu_abbrev_map as *mut libc::c_void);
    cu_abbrev_map = 0 as *mut abbrev_map;
    next_free_abbrev_map_entry = 0 as libc::c_int as libc::c_ulong;
    free(shndx_pool as *mut libc::c_void);
    shndx_pool = 0 as *mut libc::c_uint;
    shndx_pool_size = 0 as libc::c_int as libc::c_uint;
    shndx_pool_used = 0 as libc::c_int as libc::c_uint;
    free(cu_sets as *mut libc::c_void);
    cu_sets = 0 as *mut cu_tu_set;
    cu_count = 0 as libc::c_int;
    free(tu_sets as *mut libc::c_void);
    tu_sets = 0 as *mut cu_tu_set;
    tu_count = 0 as libc::c_int;
    memset(
        level_type_signed.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[bool; 256]>() as libc::c_ulong,
    );
    cu_tu_indexes_read = -(1 as libc::c_int);
    i = 0 as libc::c_int as libc::c_uint;
    while i < max as libc::c_int as libc::c_uint {
        free_debug_section(i as dwarf_section_display_enum);
        i = i.wrapping_add(1);
        i;
    }
    if !debug_information.is_null() {
        i = 0 as libc::c_int as libc::c_uint;
        while i < alloc_num_debug_info_entries {
            if (*debug_information.offset(i as isize)).max_loc_offsets != 0 {
                free(
                    (*debug_information.offset(i as isize)).loc_offsets
                        as *mut libc::c_void,
                );
                free(
                    (*debug_information.offset(i as isize)).have_frame_base
                        as *mut libc::c_void,
                );
            }
            if (*debug_information.offset(i as isize)).max_range_lists != 0 {
                free(
                    (*debug_information.offset(i as isize)).range_lists
                        as *mut libc::c_void,
                );
            }
            i = i.wrapping_add(1);
            i;
        }
        free(debug_information as *mut libc::c_void);
        debug_information = 0 as *mut debug_info;
        num_debug_info_entries = 0 as libc::c_int as libc::c_uint;
        alloc_num_debug_info_entries = num_debug_info_entries;
    }
    let mut d: *mut separate_info = 0 as *mut separate_info;
    let mut next: *mut separate_info = 0 as *mut separate_info;
    d = first_separate_info;
    while !d.is_null() {
        close_debug_file((*d).handle);
        free((*d).filename as *mut libc::c_void);
        next = (*d).next;
        free(d as *mut libc::c_void);
        d = next;
    }
    first_separate_info = 0 as *mut separate_info;
    free_dwo_info();
}
#[no_mangle]
pub unsafe extern "C" fn dwarf_select_sections_by_names(mut names: *const libc::c_char) {
    static mut opts_table: [debug_dump_long_opts; 26] = unsafe {
        [
            {
                let mut init = debug_dump_long_opts {
                    option: b"Ranges\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_ranges as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"abbrev\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_abbrevs as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"addr\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_addr as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"aranges\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_aranges as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"cu_index\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_cu_index as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"decodedline\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_lines as *const libc::c_int as *mut libc::c_int,
                    val: 2 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"follow-links\0" as *const u8 as *const libc::c_char,
                    variable: &do_follow_links as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"frames\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_frames as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"frames-interp\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_frames_interp as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"gdb_index\0" as *const u8 as *const libc::c_char,
                    variable: &do_gdb_index as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"info\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_info as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"line\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_lines as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"links\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_links as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"loc\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_loc as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"macro\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_macinfo as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"no-follow-links\0" as *const u8 as *const libc::c_char,
                    variable: &do_follow_links as *const libc::c_int as *mut libc::c_int,
                    val: 0 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"pubnames\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_pubnames as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"pubtypes\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_pubtypes as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"ranges\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_aranges as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"rawline\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_lines as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"str\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_str as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"str-offsets\0" as *const u8 as *const libc::c_char,
                    variable: &do_debug_str_offsets as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"trace_abbrev\0" as *const u8 as *const libc::c_char,
                    variable: &do_trace_abbrevs as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"trace_aranges\0" as *const u8 as *const libc::c_char,
                    variable: &do_trace_aranges as *const libc::c_int
                        as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: b"trace_info\0" as *const u8 as *const libc::c_char,
                    variable: &do_trace_info as *const libc::c_int as *mut libc::c_int,
                    val: 1 as libc::c_int,
                };
                init
            },
            {
                let mut init = debug_dump_long_opts {
                    option: 0 as *const libc::c_char,
                    variable: 0 as *const libc::c_int as *mut libc::c_int,
                    val: 0 as libc::c_int,
                };
                init
            },
        ]
    };
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    p = names;
    while *p != 0 {
        let mut entry: *const debug_dump_long_opts = 0 as *const debug_dump_long_opts;
        entry = opts_table.as_ptr();
        while !((*entry).option).is_null() {
            let mut len: size_t = strlen((*entry).option);
            if strncmp(p, (*entry).option, len) == 0 as libc::c_int
                && (*p.offset(len as isize) as libc::c_int == ',' as i32
                    || *p.offset(len as isize) as libc::c_int == '\0' as i32)
            {
                *(*entry).variable = (*entry).val;
                if do_debug_frames_interp != 0 {
                    do_debug_frames = 1 as libc::c_int;
                }
                p = p.offset(len as isize);
                break;
            } else {
                entry = entry.offset(1);
                entry;
            }
        }
        if ((*entry).option).is_null() {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unrecognized debug option '%s'\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                p,
            );
            p = strchr(p, ',' as i32);
            if p.is_null() {
                break;
            }
        }
        if *p as libc::c_int == ',' as i32 {
            p = p.offset(1);
            p;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn dwarf_select_sections_by_letters(
    mut letters: *const libc::c_char,
) {
    let mut lindex: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    while *letters.offset(lindex as isize) != 0 {
        let mut current_block_23: u64;
        let fresh0 = lindex;
        lindex = lindex.wrapping_add(1);
        match *letters.offset(fresh0 as isize) as libc::c_int {
            65 => {
                do_debug_addr = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            97 => {
                do_debug_abbrevs = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            99 => {
                do_debug_cu_index = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            70 => {
                do_debug_frames_interp = 1 as libc::c_int;
                current_block_23 = 1647006333057394571;
            }
            102 => {
                current_block_23 = 1647006333057394571;
            }
            103 => {
                do_gdb_index = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            105 => {
                do_debug_info = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            75 => {
                do_follow_links = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            78 => {
                do_follow_links = 0 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            107 => {
                do_debug_links = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            108 => {
                do_debug_lines |= 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            76 => {
                do_debug_lines |= 2 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            109 => {
                do_debug_macinfo = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            79 => {
                do_debug_str_offsets = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            111 => {
                do_debug_loc = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            112 => {
                do_debug_pubnames = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            82 => {
                do_debug_ranges = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            114 => {
                do_debug_aranges = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            115 => {
                do_debug_str = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            84 => {
                do_trace_aranges = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            116 => {
                do_debug_pubtypes = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            85 => {
                do_trace_info = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            117 => {
                do_trace_abbrevs = 1 as libc::c_int;
                current_block_23 = 9520865839495247062;
            }
            _ => {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unrecognized debug option '%s'\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    letters,
                );
                current_block_23 = 9520865839495247062;
            }
        }
        match current_block_23 {
            1647006333057394571 => {
                do_debug_frames = 1 as libc::c_int;
            }
            _ => {}
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn dwarf_select_sections_all() {
    do_debug_info = 1 as libc::c_int;
    do_debug_abbrevs = 1 as libc::c_int;
    do_debug_lines = 1 as libc::c_int;
    do_debug_pubnames = 1 as libc::c_int;
    do_debug_pubtypes = 1 as libc::c_int;
    do_debug_aranges = 1 as libc::c_int;
    do_debug_ranges = 1 as libc::c_int;
    do_debug_frames = 1 as libc::c_int;
    do_debug_macinfo = 1 as libc::c_int;
    do_debug_str = 1 as libc::c_int;
    do_debug_loc = 1 as libc::c_int;
    do_gdb_index = 1 as libc::c_int;
    do_trace_info = 1 as libc::c_int;
    do_trace_abbrevs = 1 as libc::c_int;
    do_trace_aranges = 1 as libc::c_int;
    do_debug_addr = 1 as libc::c_int;
    do_debug_cu_index = 1 as libc::c_int;
    do_follow_links = 1 as libc::c_int;
    do_debug_links = 1 as libc::c_int;
    do_debug_str_offsets = 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn find_cu_tu_set(
    mut file: *mut libc::c_void,
    mut shndx: libc::c_uint,
) -> *mut libc::c_uint {
    let mut i: libc::c_uint = 0;
    if !load_cu_tu_indexes(file) {
        return 0 as *mut libc::c_uint;
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < shndx_pool_used {
        if *shndx_pool.offset(i as isize) == shndx {
            break;
        }
        i = i.wrapping_add(1);
        i;
    }
    if i >= shndx_pool_used {
        return 0 as *mut libc::c_uint;
    }
    while i > 0 as libc::c_int as libc::c_uint
        && *shndx_pool.offset(i.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)
            != 0 as libc::c_int as libc::c_uint
    {
        i = i.wrapping_sub(1);
        i;
    }
    return shndx_pool.offset(i as isize);
}
#[no_mangle]
pub unsafe extern "C" fn cmalloc(
    mut nmemb: size_t,
    mut size: size_t,
) -> *mut libc::c_void {
    if nmemb >= (!(0 as libc::c_int as size_t)).wrapping_div(size) {
        return 0 as *mut libc::c_void;
    }
    return xmalloc(nmemb.wrapping_mul(size));
}
#[no_mangle]
pub unsafe extern "C" fn xcalloc2(
    mut nmemb: size_t,
    mut size: size_t,
) -> *mut libc::c_void {
    if nmemb >= (!(0 as libc::c_int as size_t)).wrapping_div(size) {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Attempt to allocate a zero'ed array with an excessive number of elements: 0x%lx\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            nmemb as libc::c_long,
        );
        xexit(1 as libc::c_int);
    }
    return xcalloc(nmemb, size);
}
#[no_mangle]
pub unsafe extern "C" fn xcmalloc(
    mut nmemb: size_t,
    mut size: size_t,
) -> *mut libc::c_void {
    if nmemb >= (!(0 as libc::c_int as size_t)).wrapping_div(size) {
        fprintf(
            stderr,
            dcgettext(
                0 as *const libc::c_char,
                b"Attempt to allocate an array with an excessive number of elements: 0x%lx\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            nmemb as libc::c_long,
        );
        xexit(1 as libc::c_int);
    }
    return xmalloc(nmemb.wrapping_mul(size));
}
#[no_mangle]
pub unsafe extern "C" fn xcrealloc(
    mut ptr: *mut libc::c_void,
    mut nmemb: size_t,
    mut size: size_t,
) -> *mut libc::c_void {
    if nmemb >= (!(0 as libc::c_int as size_t)).wrapping_div(size) {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Attempt to re-allocate an array with an excessive number of elements: 0x%lx\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            nmemb as libc::c_long,
        );
        xexit(1 as libc::c_int);
    }
    return xrealloc(ptr, nmemb.wrapping_mul(size));
}
#[no_mangle]
pub unsafe extern "C" fn read_leb128(
    mut data: *mut libc::c_uchar,
    end: *const libc::c_uchar,
    mut sign: bool,
    mut length_return: *mut libc::c_uint,
    mut status_return: *mut libc::c_int,
) -> dwarf_vma {
    let mut result: dwarf_vma = 0 as libc::c_int as dwarf_vma;
    let mut num_read: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut shift: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut status: libc::c_int = 1 as libc::c_int;
    while data < end as *mut libc::c_uchar {
        let fresh1 = data;
        data = data.offset(1);
        let mut byte: libc::c_uchar = *fresh1;
        let mut lost: libc::c_uchar = 0;
        let mut mask: libc::c_uchar = 0;
        num_read = num_read.wrapping_add(1);
        num_read;
        if (shift as libc::c_ulong)
            < (8 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
        {
            result
                |= ((byte as libc::c_int & 0x7f as libc::c_int) as dwarf_vma) << shift;
            lost = (byte as libc::c_ulong ^ result >> shift) as libc::c_uchar;
            mask = (0x7f as libc::c_int as libc::c_ulong
                ^ (0x7f as libc::c_int as dwarf_vma) << shift >> shift) as libc::c_uchar;
            shift = shift.wrapping_add(7 as libc::c_int as libc::c_uint);
        } else {
            lost = byte;
            mask = 0x7f as libc::c_int as libc::c_uchar;
        }
        if lost as libc::c_int & mask as libc::c_int
            != (if sign as libc::c_int != 0
                && (result as dwarf_signed_vma) < 0 as libc::c_int as libc::c_long
            {
                mask as libc::c_int
            } else {
                0 as libc::c_int
            })
        {
            status |= 2 as libc::c_int;
        }
        if !(byte as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int) {
            continue;
        }
        status &= !(1 as libc::c_int);
        if sign as libc::c_int != 0
            && (shift as libc::c_ulong)
                < (8 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
            && byte as libc::c_int & 0x40 as libc::c_int != 0
        {
            result |= ((1 as libc::c_int as dwarf_vma) << shift).wrapping_neg();
        }
        break;
    }
    if !length_return.is_null() {
        *length_return = num_read;
    }
    if !status_return.is_null() {
        *status_return = status;
    }
    return result;
}
#[inline]
unsafe extern "C" fn report_leb_status(
    mut status: libc::c_int,
    mut file: *const libc::c_char,
    mut lnum: libc::c_ulong,
) {
    if status & 1 as libc::c_int != 0 as libc::c_int {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"%s:%lu: end of data encountered whilst reading LEB\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            file,
            lnum,
        );
    } else if status & 2 as libc::c_int != 0 as libc::c_int {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"%s:%lu: read LEB value is too large to store in destination variable\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            file,
            lnum,
        );
    }
}
unsafe extern "C" fn regname(
    mut regno: libc::c_uint,
    mut name_only_p: libc::c_int,
) -> *const libc::c_char {
    static mut reg: [libc::c_char; 64] = [0; 64];
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    if dwarf_regnames_lookup_func.is_some() {
        name = dwarf_regnames_lookup_func.expect("non-null function pointer")(regno);
    }
    if !name.is_null() {
        if name_only_p != 0 {
            return name;
        }
        snprintf(
            reg.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"r%d (%s)\0" as *const u8 as *const libc::c_char,
            regno,
            name,
        );
    } else {
        snprintf(
            reg.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"r%d\0" as *const u8 as *const libc::c_char,
            regno,
        );
    }
    return reg.as_mut_ptr();
}
unsafe extern "C" fn regname_internal_by_table_only(
    mut regno: libc::c_uint,
) -> *const libc::c_char {
    if !dwarf_regnames.is_null() && regno < dwarf_regnames_count
        && !(*dwarf_regnames.offset(regno as isize)).is_null()
    {
        return *dwarf_regnames.offset(regno as isize);
    }
    return 0 as *const libc::c_char;
}
static mut have_frame_base: libc::c_int = 0;
static mut need_base_address: libc::c_int = 0;
static mut num_debug_info_entries: libc::c_uint = 0 as libc::c_int as libc::c_uint;
static mut alloc_num_debug_info_entries: libc::c_uint = 0 as libc::c_int as libc::c_uint;
static mut debug_information: *mut debug_info = 0 as *const debug_info
    as *mut debug_info;
static mut first_dwo_info: *mut dwo_info = 0 as *const dwo_info as *mut dwo_info;
static mut need_dwo_info: bool = false;
static mut vm1: dwarf_vma = -(1 as libc::c_int) as dwarf_vma;
static mut shndx_pool: *mut libc::c_uint = 0 as *const libc::c_uint as *mut libc::c_uint;
static mut shndx_pool_size: libc::c_uint = 0 as libc::c_int as libc::c_uint;
static mut shndx_pool_used: libc::c_uint = 0 as libc::c_int as libc::c_uint;
static mut cu_count: libc::c_int = 0 as libc::c_int;
static mut tu_count: libc::c_int = 0 as libc::c_int;
static mut cu_sets: *mut cu_tu_set = 0 as *const cu_tu_set as *mut cu_tu_set;
static mut tu_sets: *mut cu_tu_set = 0 as *const cu_tu_set as *mut cu_tu_set;
unsafe extern "C" fn load_cu_tu_indexes(mut file: *mut libc::c_void) -> bool {
    if cu_tu_indexes_read == -(1 as libc::c_int) {
        cu_tu_indexes_read = 1 as libc::c_int;
        if load_debug_section_with_follow(dwp_cu_index, file) {
            if process_cu_tu_index(
                &mut (*debug_displays
                    .as_mut_ptr()
                    .offset(dwp_cu_index as libc::c_int as isize))
                    .section,
                0 as libc::c_int,
            ) == 0
            {
                cu_tu_indexes_read = 0 as libc::c_int;
            }
        }
        if load_debug_section_with_follow(dwp_tu_index, file) {
            if process_cu_tu_index(
                &mut (*debug_displays
                    .as_mut_ptr()
                    .offset(dwp_tu_index as libc::c_int as isize))
                    .section,
                0 as libc::c_int,
            ) == 0
            {
                cu_tu_indexes_read = 0 as libc::c_int;
            }
        }
    }
    return cu_tu_indexes_read != 0;
}
static mut level_type_signed: [bool; 256] = [false; 256];
unsafe extern "C" fn size_of_encoded_value(mut encoding: libc::c_int) -> libc::c_uint {
    match encoding & 0x7 as libc::c_int {
        2 => return 2 as libc::c_int as libc::c_uint,
        3 => return 4 as libc::c_int as libc::c_uint,
        4 => return 8 as libc::c_int as libc::c_uint,
        0 | _ => return eh_addr_size,
    };
}
unsafe extern "C" fn get_encoded_value(
    mut pdata: *mut *mut libc::c_uchar,
    mut encoding: libc::c_int,
    mut section: *mut dwarf_section,
    mut end: *mut libc::c_uchar,
) -> dwarf_vma {
    let mut data: *mut libc::c_uchar = *pdata;
    let mut size: libc::c_uint = size_of_encoded_value(encoding);
    let mut val: dwarf_vma = 0;
    if data >= end
        || size as libc::c_ulong > end.offset_from(data) as libc::c_long as size_t
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Encoded value extends past end of section\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        *pdata = end;
        return 0 as libc::c_int as dwarf_vma;
    }
    if size > 8 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Encoded size of %d is too large to read\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            size,
        );
        *pdata = end;
        return 0 as libc::c_int as dwarf_vma;
    }
    if size == 0 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Encoded size of 0 is too small to read\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        *pdata = end;
        return 0 as libc::c_int as dwarf_vma;
    }
    if encoding & 0x8 as libc::c_int != 0 {
        val = byte_get_signed(data, size);
    } else {
        val = byte_get.expect("non-null function pointer")(data, size);
    }
    if encoding & 0x70 as libc::c_int == 0x10 as libc::c_int {
        val = (val as libc::c_ulong)
            .wrapping_add(
                ((*section).address)
                    .wrapping_add(
                        data.offset_from((*section).start) as libc::c_long
                            as libc::c_ulong,
                    ),
            ) as dwarf_vma as dwarf_vma;
    }
    *pdata = data.offset(size as isize);
    return val;
}
unsafe extern "C" fn dwarf_vmatoa_1(
    mut fmtch: *const libc::c_char,
    mut value: dwarf_vma,
    mut num_bytes: libc::c_uint,
) -> *const libc::c_char {
    static mut buf_pos: libc::c_int = 0 as libc::c_int;
    static mut buf: [dwarf_vmatoa_buf; 16] = [dwarf_vmatoa_buf { place: [0; 64] }; 16];
    let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
    let fresh2 = buf_pos;
    buf_pos = buf_pos + 1;
    ret = (buf[fresh2 as usize].place).as_mut_ptr();
    buf_pos = (buf_pos as libc::c_ulong)
        .wrapping_rem(
            (::core::mem::size_of::<[dwarf_vmatoa_buf; 16]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<dwarf_vmatoa_buf>() as libc::c_ulong,
                ),
        ) as libc::c_int as libc::c_int;
    if num_bytes != 0 {
        snprintf(
            ret,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            b"%16.16lx\0" as *const u8 as *const libc::c_char,
            value,
        );
        if num_bytes > 8 as libc::c_int as libc::c_uint {
            num_bytes = 8 as libc::c_int as libc::c_uint;
        }
        return ret
            .offset(
                (16 as libc::c_int as libc::c_uint)
                    .wrapping_sub(
                        (2 as libc::c_int as libc::c_uint).wrapping_mul(num_bytes),
                    ) as isize,
            );
    } else {
        let mut fmt: [libc::c_char; 32] = [0; 32];
        if !fmtch.is_null() {
            sprintf(
                fmt.as_mut_ptr(),
                b"%%%s%s\0" as *const u8 as *const libc::c_char,
                b"l\0" as *const u8 as *const libc::c_char,
                fmtch,
            );
        } else {
            sprintf(
                fmt.as_mut_ptr(),
                b"%%%s\0" as *const u8 as *const libc::c_char,
                b"l\0" as *const u8 as *const libc::c_char,
            );
        }
        snprintf(
            ret,
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
            fmt.as_mut_ptr(),
            value,
        );
        return ret;
    };
}
#[inline]
unsafe extern "C" fn dwarf_vmatoa(
    mut fmtch: *const libc::c_char,
    mut value: dwarf_vma,
) -> *const libc::c_char {
    return dwarf_vmatoa_1(fmtch, value, 0 as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn print_dwarf_vma(mut value: dwarf_vma, mut num_bytes: libc::c_uint) {
    printf(
        b"%s \0" as *const u8 as *const libc::c_char,
        dwarf_vmatoa_1(0 as *const libc::c_char, value, num_bytes),
    );
}
unsafe extern "C" fn print_dwarf_view(
    mut value: dwarf_vma,
    mut num_bytes: libc::c_uint,
    mut force: libc::c_int,
) {
    let mut len: libc::c_int = 0;
    if num_bytes == 0 {
        len = 4 as libc::c_int;
    } else {
        len = num_bytes.wrapping_mul(2 as libc::c_int as libc::c_uint) as libc::c_int;
    }
    if value == value {} else {
        __assert_fail(
            b"value == (unsigned long) value\0" as *const u8 as *const libc::c_char,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            307 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 52],
                &[libc::c_char; 52],
            >(b"void print_dwarf_view(dwarf_vma, unsigned int, int)\0"))
                .as_ptr(),
        );
    }
    'c_56000: {
        if value == value {} else {
            __assert_fail(
                b"value == (unsigned long) value\0" as *const u8 as *const libc::c_char,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                307 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 52],
                    &[libc::c_char; 52],
                >(b"void print_dwarf_view(dwarf_vma, unsigned int, int)\0"))
                    .as_ptr(),
            );
        }
    };
    if value != 0 || force != 0 {
        printf(
            b"v%0*lx \0" as *const u8 as *const libc::c_char,
            len - 1 as libc::c_int,
            value,
        );
    } else {
        printf(
            b"%*s\0" as *const u8 as *const libc::c_char,
            len + 1 as libc::c_int,
            b"\0" as *const u8 as *const libc::c_char,
        );
    };
}
static mut state_machine_regs: SMR = SMR {
    address: 0,
    view: 0,
    file: 0,
    line: 0,
    column: 0,
    is_stmt: 0,
    basic_block: 0,
    op_index: 0,
    end_sequence: 0,
    last_file_entry: 0,
};
unsafe extern "C" fn reset_state_machine(mut is_stmt: libc::c_int) {
    state_machine_regs.address = 0 as libc::c_int as dwarf_vma;
    state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
    state_machine_regs.op_index = 0 as libc::c_int as libc::c_uchar;
    state_machine_regs.file = 1 as libc::c_int as libc::c_uint;
    state_machine_regs.line = 1 as libc::c_int as libc::c_uint;
    state_machine_regs.column = 0 as libc::c_int as libc::c_uint;
    state_machine_regs.is_stmt = is_stmt;
    state_machine_regs.basic_block = 0 as libc::c_int;
    state_machine_regs.end_sequence = 0 as libc::c_int as libc::c_uchar;
    state_machine_regs.last_file_entry = 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn process_extended_line_op(
    mut data: *mut libc::c_uchar,
    mut is_stmt: libc::c_int,
    mut end: *mut libc::c_uchar,
) -> size_t {
    let mut op_code: libc::c_uchar = 0;
    let mut len: size_t = 0;
    let mut header_len: size_t = 0;
    let mut name: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut orig_data: *mut libc::c_uchar = data;
    let mut adr: dwarf_vma = 0;
    let mut val: dwarf_vma = 0;
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(data, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
    data = data.offset(_len as isize);
    len = _val;
    if len != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"dwarf.c\0" as *const u8 as *const libc::c_char,
        472 as libc::c_int as libc::c_ulong,
    );
    header_len = data.offset_from(orig_data) as libc::c_long as size_t;
    if len == 0 as libc::c_int as libc::c_ulong || data >= end
        || len > end.offset_from(data) as libc::c_long as size_t
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Badly formed extended line op encountered!\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return header_len;
    }
    let fresh3 = data;
    data = data.offset(1);
    op_code = *fresh3;
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Extended opcode %d: \0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        op_code as libc::c_int,
    );
    match op_code as libc::c_int {
        1 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"End of Sequence\n\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            reset_state_machine(is_stmt);
        }
        2 => {
            if len.wrapping_sub(1 as libc::c_int as libc::c_ulong)
                > 8 as libc::c_int as libc::c_ulong
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Length (%lu) of DW_LNE_set_address op is too long\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    len.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                );
                adr = 0 as libc::c_int as dwarf_vma;
            } else {
                let mut amount: size_t = len
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong);
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount,
                            5 as libc::c_int,
                        ),
                        amount as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail: size_t = end.offset_from(data) as libc::c_long as size_t;
                if data > end {
                    avail = 0 as libc::c_int as size_t;
                }
                if amount > avail {
                    amount = avail;
                }
                if amount == 0 as libc::c_int as libc::c_ulong {
                    adr = 0 as libc::c_int as dwarf_vma;
                } else {
                    adr = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount as libc::c_uint);
                }
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"set Address to 0x%s\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, adr),
            );
            state_machine_regs.address = adr;
            state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
            state_machine_regs.op_index = 0 as libc::c_int as libc::c_uchar;
        }
        3 => {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"define new File Table entry\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Entry\tDir\tTime\tSize\tName\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            state_machine_regs
                .last_file_entry = (state_machine_regs.last_file_entry).wrapping_add(1);
            printf(
                b"   %d\t\0" as *const u8 as *const libc::c_char,
                state_machine_regs.last_file_entry,
            );
            let mut l: size_t = 0;
            name = data;
            l = strnlen(
                data as *mut libc::c_char,
                end.offset_from(data) as libc::c_long as size_t,
            );
            data = data.offset(l as isize);
            if data < end {
                data = data.offset(1);
                data;
            }
            let mut _val_0: dwarf_vma = 0;
            let mut _len_0: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_0,
                &mut _status_0,
            );
            data = data.offset(_len_0 as isize);
            val = _val_0;
            if val != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                521 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"%s\t\0" as *const u8 as *const libc::c_char,
                dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
            );
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            data = data.offset(_len_1 as isize);
            val = _val_1;
            if val != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                523 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"%s\t\0" as *const u8 as *const libc::c_char,
                dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
            );
            let mut _val_2: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_2: libc::c_int = 0;
            _val_2 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_2,
            );
            data = data.offset(_len_2 as isize);
            val = _val_2;
            if val != _val_2 {
                _status_2 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_2,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                525 as libc::c_int as libc::c_ulong,
            );
            printf(
                b"%s\t\0" as *const u8 as *const libc::c_char,
                dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
            );
            printf(
                b"%.*s\n\n\0" as *const u8 as *const libc::c_char,
                l as libc::c_int,
                name,
            );
            if data.offset_from(orig_data) as libc::c_long as size_t
                != len.wrapping_add(header_len) || data >= end
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"DW_LNE_define_file: Bad opcode length\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
        }
        4 => {
            let mut _val_3: dwarf_vma = 0;
            let mut _len_3: libc::c_uint = 0;
            let mut _status_3: libc::c_int = 0;
            _val_3 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_3,
                &mut _status_3,
            );
            data = data.offset(_len_3 as isize);
            val = _val_3;
            if val != _val_3 {
                _status_3 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_3,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                535 as libc::c_int as libc::c_ulong,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"set Discriminator to %s\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
            );
        }
        17 => {
            printf(
                b"DW_LNE_HP_negate_is_UV_update\n\0" as *const u8 as *const libc::c_char,
            );
        }
        18 => {
            printf(b"DW_LNE_HP_push_context\n\0" as *const u8 as *const libc::c_char);
        }
        19 => {
            printf(b"DW_LNE_HP_pop_context\n\0" as *const u8 as *const libc::c_char);
        }
        20 => {
            printf(
                b"DW_LNE_HP_set_file_line_column\n\0" as *const u8 as *const libc::c_char,
            );
        }
        21 => {
            printf(
                b"DW_LNE_HP_set_routine_name\n\0" as *const u8 as *const libc::c_char,
            );
        }
        22 => {
            printf(b"DW_LNE_HP_set_sequence\n\0" as *const u8 as *const libc::c_char);
        }
        23 => {
            printf(
                b"DW_LNE_HP_negate_post_semantics\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        24 => {
            printf(
                b"DW_LNE_HP_negate_function_exit\n\0" as *const u8 as *const libc::c_char,
            );
        }
        25 => {
            printf(
                b"DW_LNE_HP_negate_front_end_logical\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        32 => {
            printf(b"DW_LNE_HP_define_proc\n\0" as *const u8 as *const libc::c_char);
        }
        128 => {
            let mut edata: *mut libc::c_uchar = data
                .offset(len as isize)
                .offset(-(1 as libc::c_int as isize));
            printf(
                b"DW_LNE_HP_source_file_correlation\n\0" as *const u8
                    as *const libc::c_char,
            );
            while data < edata {
                let mut opc: libc::c_uint = 0;
                let mut _val_4: dwarf_vma = 0;
                let mut _len_4: libc::c_uint = 0;
                let mut _status_4: libc::c_int = 0;
                _val_4 = read_leb128(
                    data,
                    edata,
                    0 as libc::c_int != 0,
                    &mut _len_4,
                    &mut _status_4,
                );
                data = data.offset(_len_4 as isize);
                opc = _val_4 as libc::c_uint;
                if opc as libc::c_ulong != _val_4 {
                    _status_4 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_4,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    580 as libc::c_int as libc::c_ulong,
                );
                match opc {
                    1 => {
                        printf(
                            b"    DW_LNE_HP_SFC_formfeed\n\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    2 => {
                        let mut _val_5: dwarf_vma = 0;
                        let mut _len_5: libc::c_uint = 0;
                        let mut _status_5: libc::c_int = 0;
                        _val_5 = read_leb128(
                            data,
                            edata,
                            0 as libc::c_int != 0,
                            &mut _len_5,
                            &mut _status_5,
                        );
                        data = data.offset(_len_5 as isize);
                        val = _val_5;
                        if val != _val_5 {
                            _status_5 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_5,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            588 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            b"    DW_LNE_HP_SFC_set_listing_line (%s)\n\0" as *const u8
                                as *const libc::c_char,
                            dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
                        );
                    }
                    3 => {
                        printf(
                            b"    DW_LNE_HP_SFC_associate \0" as *const u8
                                as *const libc::c_char,
                        );
                        let mut _val_6: dwarf_vma = 0;
                        let mut _len_6: libc::c_uint = 0;
                        let mut _status_6: libc::c_int = 0;
                        _val_6 = read_leb128(
                            data,
                            edata,
                            0 as libc::c_int != 0,
                            &mut _len_6,
                            &mut _status_6,
                        );
                        data = data.offset(_len_6 as isize);
                        val = _val_6;
                        if val != _val_6 {
                            _status_6 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_6,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            594 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            b"(%s\0" as *const u8 as *const libc::c_char,
                            dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
                        );
                        let mut _val_7: dwarf_vma = 0;
                        let mut _len_7: libc::c_uint = 0;
                        let mut _status_7: libc::c_int = 0;
                        _val_7 = read_leb128(
                            data,
                            edata,
                            0 as libc::c_int != 0,
                            &mut _len_7,
                            &mut _status_7,
                        );
                        data = data.offset(_len_7 as isize);
                        val = _val_7;
                        if val != _val_7 {
                            _status_7 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_7,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            596 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            b",%s\0" as *const u8 as *const libc::c_char,
                            dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
                        );
                        let mut _val_8: dwarf_vma = 0;
                        let mut _len_8: libc::c_uint = 0;
                        let mut _status_8: libc::c_int = 0;
                        _val_8 = read_leb128(
                            data,
                            edata,
                            0 as libc::c_int != 0,
                            &mut _len_8,
                            &mut _status_8,
                        );
                        data = data.offset(_len_8 as isize);
                        val = _val_8;
                        if val != _val_8 {
                            _status_8 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_8,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            598 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            b",%s)\n\0" as *const u8 as *const libc::c_char,
                            dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
                        );
                    }
                    _ => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"    UNKNOWN DW_LNE_HP_SFC opcode (%u)\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            opc,
                        );
                        data = edata;
                    }
                }
            }
        }
        _ => {
            let mut rlen: libc::c_uint = len
                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint;
            if op_code as libc::c_int >= DW_LNE_lo_user as libc::c_int {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"user defined: \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"UNKNOWN: \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"length %d [\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                rlen,
            );
            while rlen != 0 {
                let fresh4 = data;
                data = data.offset(1);
                printf(
                    b" %02x\0" as *const u8 as *const libc::c_char,
                    *fresh4 as libc::c_int,
                );
                rlen = rlen.wrapping_sub(1);
                rlen;
            }
            printf(b"]\n\0" as *const u8 as *const libc::c_char);
        }
    }
    return len.wrapping_add(header_len);
}
unsafe extern "C" fn fetch_indirect_string(
    mut offset: dwarf_vma,
) -> *const libc::c_uchar {
    let mut section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(str as libc::c_int as isize))
        .section;
    let mut ret: *const libc::c_uchar = 0 as *const libc::c_uchar;
    if ((*section).start).is_null() {
        return dcgettext(
            0 as *const libc::c_char,
            b"<no .debug_str section>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ) as *const libc::c_uchar;
    }
    if offset >= (*section).size {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"DW_FORM_strp offset too big: 0x%s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, offset),
        );
        return dcgettext(
            0 as *const libc::c_char,
            b"<offset is too big>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ) as *const libc::c_uchar;
    }
    ret = ((*section).start).offset(offset as isize);
    if strnlen(ret as *const libc::c_char, ((*section).size).wrapping_sub(offset))
        == ((*section).size).wrapping_sub(offset)
    {
        ret = dcgettext(
            0 as *const libc::c_char,
            b"<no NUL byte at end of .debug_str section>\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ) as *const libc::c_uchar;
    }
    return ret;
}
unsafe extern "C" fn fetch_indirect_line_string(
    mut offset: dwarf_vma,
) -> *const libc::c_uchar {
    let mut section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(line_str as libc::c_int as isize))
        .section;
    let mut ret: *const libc::c_uchar = 0 as *const libc::c_uchar;
    if ((*section).start).is_null() {
        return dcgettext(
            0 as *const libc::c_char,
            b"<no .debug_line_str section>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ) as *const libc::c_uchar;
    }
    if offset >= (*section).size {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"DW_FORM_line_strp offset too big: 0x%s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, offset),
        );
        return dcgettext(
            0 as *const libc::c_char,
            b"<offset is too big>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ) as *const libc::c_uchar;
    }
    ret = ((*section).start).offset(offset as isize);
    if strnlen(ret as *const libc::c_char, ((*section).size).wrapping_sub(offset))
        == ((*section).size).wrapping_sub(offset)
    {
        ret = dcgettext(
            0 as *const libc::c_char,
            b"<no NUL byte at end of .debug_line_str section>\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ) as *const libc::c_uchar;
    }
    return ret;
}
unsafe extern "C" fn fetch_indexed_string(
    mut idx: dwarf_vma,
    mut this_set: *mut cu_tu_set,
    mut offset_size: dwarf_vma,
    mut dwo: bool,
) -> *const libc::c_char {
    let mut str_sec_idx: dwarf_section_display_enum = (if dwo as libc::c_int != 0 {
        str_dwo as libc::c_int
    } else {
        str as libc::c_int
    }) as dwarf_section_display_enum;
    let mut idx_sec_idx: dwarf_section_display_enum = (if dwo as libc::c_int != 0 {
        str_index_dwo as libc::c_int
    } else {
        str_index as libc::c_int
    }) as dwarf_section_display_enum;
    let mut index_section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(idx_sec_idx as isize))
        .section;
    let mut str_section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(str_sec_idx as isize))
        .section;
    let mut index_offset: dwarf_vma = 0;
    let mut str_offset: dwarf_vma = 0;
    let mut ret: *const libc::c_char = 0 as *const libc::c_char;
    let mut curr: *mut libc::c_uchar = (*index_section).start;
    let mut end: *mut libc::c_uchar = curr.offset((*index_section).size as isize);
    let mut length: dwarf_vma = 0;
    if ((*index_section).start).is_null() {
        return if dwo as libc::c_int != 0 {
            dcgettext(
                0 as *const libc::c_char,
                b"<no .debug_str_offsets.dwo section>\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            )
        } else {
            dcgettext(
                0 as *const libc::c_char,
                b"<no .debug_str_offsets section>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        };
    }
    if ((*str_section).start).is_null() {
        return if dwo as libc::c_int != 0 {
            dcgettext(
                0 as *const libc::c_char,
                b"<no .debug_str.dwo section>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        } else {
            dcgettext(
                0 as *const libc::c_char,
                b"<no .debug_str section>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            )
        };
    }
    let mut amount: size_t = 4 as libc::c_int as size_t;
    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount,
                5 as libc::c_int,
            ),
            amount as libc::c_int,
            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
        );
        amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
    }
    let mut avail: size_t = end.offset_from(curr) as libc::c_long as size_t;
    if curr > end {
        avail = 0 as libc::c_int as size_t;
    }
    if amount > avail {
        amount = avail;
    }
    if amount == 0 as libc::c_int as libc::c_ulong {
        length = 0 as libc::c_int as dwarf_vma;
    } else {
        length = byte_get
            .expect("non-null function pointer")(curr, amount as libc::c_uint);
    }
    curr = curr.offset(amount as isize);
    if length == 0xffffffff as libc::c_uint as libc::c_ulong {
        if offset_size != 8 as libc::c_int as libc::c_ulong {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Expected offset size of 8 but given %s\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, offset_size),
            );
        }
        let mut amount_0: size_t = 8 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_0,
                    5 as libc::c_int,
                ),
                amount_0 as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail_0: size_t = end.offset_from(curr) as libc::c_long as size_t;
        if curr > end {
            avail_0 = 0 as libc::c_int as size_t;
        }
        if amount_0 > avail_0 {
            amount_0 = avail_0;
        }
        if amount_0 == 0 as libc::c_int as libc::c_ulong {
            length = 0 as libc::c_int as dwarf_vma;
        } else {
            length = byte_get
                .expect("non-null function pointer")(curr, amount_0 as libc::c_uint);
        }
        curr = curr.offset(amount_0 as isize);
    } else if offset_size != 4 as libc::c_int as libc::c_ulong {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Expected offset size of 4 but given %s\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, offset_size),
        );
    }
    if length == 0 as libc::c_int as libc::c_ulong {
        curr = (*index_section).start;
        length = (*index_section).size;
    } else {
        if end.offset_from(curr) as libc::c_long >= 4 as libc::c_int as libc::c_long {
            curr = curr.offset(4 as libc::c_int as isize);
        } else {
            curr = end;
        }
        if length >= 4 as libc::c_int as libc::c_ulong {
            length = (length as libc::c_ulong)
                .wrapping_sub(4 as libc::c_int as libc::c_ulong) as dwarf_vma
                as dwarf_vma;
        } else {
            length = 0 as libc::c_int as dwarf_vma;
        }
        if !this_set.is_null()
            && (*this_set).section_sizes[DW_SECT_STR_OFFSETS as libc::c_int as usize]
                < length
        {
            length = (*this_set)
                .section_sizes[DW_SECT_STR_OFFSETS as libc::c_int as usize];
        }
        if length > end.offset_from(curr) as libc::c_long as dwarf_vma {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"index table size too large for section %s vs %s\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, length),
                dwarf_vmatoa(
                    b"x\0" as *const u8 as *const libc::c_char,
                    (*index_section).size,
                ),
            );
            length = end.offset_from(curr) as libc::c_long as dwarf_vma;
        }
        if length < offset_size {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"index table size %s is too small\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, length),
            );
            return dcgettext(
                0 as *const libc::c_char,
                b"<table too small>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
        }
    }
    index_offset = idx.wrapping_mul(offset_size);
    if !this_set.is_null() {
        index_offset = (index_offset as libc::c_ulong)
            .wrapping_add(
                (*this_set).section_offsets[DW_SECT_STR_OFFSETS as libc::c_int as usize],
            ) as dwarf_vma as dwarf_vma;
    }
    if index_offset >= length || length.wrapping_sub(index_offset) < offset_size {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"DW_FORM_GNU_str_index offset too big: 0x%s vs 0x%s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, index_offset),
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, length),
        );
        return dcgettext(
            0 as *const libc::c_char,
            b"<index offset is too big>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        );
    }
    str_offset = byte_get
        .expect(
            "non-null function pointer",
        )(curr.offset(index_offset as isize), offset_size as libc::c_uint);
    str_offset = (str_offset as libc::c_ulong).wrapping_sub((*str_section).address)
        as dwarf_vma as dwarf_vma;
    if str_offset >= (*str_section).size {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"DW_FORM_GNU_str_index indirect offset too big: 0x%s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, str_offset),
        );
        return dcgettext(
            0 as *const libc::c_char,
            b"<indirect index offset is too big>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        );
    }
    ret = ((*str_section).start as *const libc::c_char).offset(str_offset as isize);
    if strnlen(ret, ((*str_section).size).wrapping_sub(str_offset))
        == ((*str_section).size).wrapping_sub(str_offset)
    {
        ret = dcgettext(
            0 as *const libc::c_char,
            b"<no NUL byte at end of section>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ) as *const libc::c_char;
    }
    return ret;
}
unsafe extern "C" fn fetch_indexed_value(
    mut offset: dwarf_vma,
    mut bytes: dwarf_vma,
) -> *const libc::c_char {
    let mut section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(debug_addr as libc::c_int as isize))
        .section;
    if ((*section).start).is_null() {
        return dcgettext(
            0 as *const libc::c_char,
            b"<no .debug_addr section>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        );
    }
    if offset.wrapping_add(bytes) > (*section).size {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Offset into section %s too big: 0x%s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, offset),
        );
        return b"<offset too big>\0" as *const u8 as *const libc::c_char;
    }
    return dwarf_vmatoa(
        b"x\0" as *const u8 as *const libc::c_char,
        byte_get
            .expect(
                "non-null function pointer",
            )(((*section).start).offset(offset as isize), bytes as libc::c_uint),
    );
}
static mut abbrev_lists: *mut abbrev_list = 0 as *const abbrev_list as *mut abbrev_list;
static mut cu_abbrev_map: *mut abbrev_map = 0 as *const abbrev_map as *mut abbrev_map;
static mut num_abbrev_map_entries: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
static mut next_free_abbrev_map_entry: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
unsafe extern "C" fn record_abbrev_list_for_cu(
    mut start: dwarf_vma,
    mut end: dwarf_vma,
    mut list: *mut abbrev_list,
) {
    if cu_abbrev_map.is_null() {
        num_abbrev_map_entries = 8 as libc::c_int as libc::c_ulong;
        cu_abbrev_map = xmalloc(
            num_abbrev_map_entries
                .wrapping_mul(::core::mem::size_of::<abbrev_map>() as libc::c_ulong),
        ) as *mut abbrev_map;
    } else if next_free_abbrev_map_entry == num_abbrev_map_entries {
        num_abbrev_map_entries = num_abbrev_map_entries
            .wrapping_add(8 as libc::c_int as libc::c_ulong);
        cu_abbrev_map = xrealloc(
            cu_abbrev_map as *mut libc::c_void,
            num_abbrev_map_entries
                .wrapping_mul(::core::mem::size_of::<abbrev_map>() as libc::c_ulong),
        ) as *mut abbrev_map;
    }
    (*cu_abbrev_map.offset(next_free_abbrev_map_entry as isize)).start = start;
    (*cu_abbrev_map.offset(next_free_abbrev_map_entry as isize)).end = end;
    let ref mut fresh5 = (*cu_abbrev_map.offset(next_free_abbrev_map_entry as isize))
        .list;
    *fresh5 = list;
    next_free_abbrev_map_entry = next_free_abbrev_map_entry.wrapping_add(1);
    next_free_abbrev_map_entry;
}
unsafe extern "C" fn free_all_abbrevs() {
    let mut list: *mut abbrev_list = 0 as *mut abbrev_list;
    list = abbrev_lists;
    while !list.is_null() {
        let mut next: *mut abbrev_list = (*list).next;
        let mut abbrv: *mut abbrev_entry = 0 as *mut abbrev_entry;
        abbrv = (*list).first_abbrev;
        while !abbrv.is_null() {
            let mut next_abbrev: *mut abbrev_entry = (*abbrv).next;
            let mut attr: *mut abbrev_attr = 0 as *mut abbrev_attr;
            attr = (*abbrv).first_attr;
            while !attr.is_null() {
                let mut next_attr: *mut abbrev_attr = (*attr).next;
                free(attr as *mut libc::c_void);
                attr = next_attr;
            }
            free(abbrv as *mut libc::c_void);
            abbrv = next_abbrev;
        }
        free(list as *mut libc::c_void);
        list = next;
    }
    abbrev_lists = 0 as *mut abbrev_list;
}
unsafe extern "C" fn new_abbrev_list(
    mut abbrev_base: dwarf_vma,
    mut abbrev_offset: dwarf_vma,
) -> *mut abbrev_list {
    let mut list: *mut abbrev_list = xcalloc(
        ::core::mem::size_of::<abbrev_list>() as libc::c_ulong,
        1 as libc::c_int as size_t,
    ) as *mut abbrev_list;
    (*list).abbrev_base = abbrev_base;
    (*list).abbrev_offset = abbrev_offset;
    (*list).next = abbrev_lists;
    abbrev_lists = list;
    return list;
}
unsafe extern "C" fn find_abbrev_list_by_abbrev_offset(
    mut abbrev_base: dwarf_vma,
    mut abbrev_offset: dwarf_vma,
) -> *mut abbrev_list {
    let mut list: *mut abbrev_list = 0 as *mut abbrev_list;
    list = abbrev_lists;
    while !list.is_null() {
        if (*list).abbrev_base == abbrev_base && (*list).abbrev_offset == abbrev_offset {
            return list;
        }
        list = (*list).next;
    }
    return 0 as *mut abbrev_list;
}
unsafe extern "C" fn find_abbrev_map_by_offset(
    mut offset: dwarf_vma,
) -> *mut abbrev_map {
    let mut i: libc::c_ulong = 0;
    i = 0 as libc::c_int as libc::c_ulong;
    while i < next_free_abbrev_map_entry {
        if (*cu_abbrev_map.offset(i as isize)).start <= offset
            && (*cu_abbrev_map.offset(i as isize)).end > offset
        {
            return cu_abbrev_map.offset(i as isize);
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as *mut abbrev_map;
}
unsafe extern "C" fn add_abbrev(
    mut number: libc::c_ulong,
    mut tag: libc::c_ulong,
    mut children: libc::c_int,
    mut list: *mut abbrev_list,
) {
    let mut entry: *mut abbrev_entry = 0 as *mut abbrev_entry;
    entry = xmalloc(::core::mem::size_of::<abbrev_entry>() as libc::c_ulong)
        as *mut abbrev_entry;
    (*entry).number = number;
    (*entry).tag = tag;
    (*entry).children = children;
    (*entry).first_attr = 0 as *mut abbrev_attr;
    (*entry).last_attr = 0 as *mut abbrev_attr;
    (*entry).next = 0 as *mut abbrev_entry;
    if !list.is_null() {} else {
        __assert_fail(
            b"list != NULL\0" as *const u8 as *const libc::c_char,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            990 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 66],
                &[libc::c_char; 66],
            >(b"void add_abbrev(unsigned long, unsigned long, int, abbrev_list *)\0"))
                .as_ptr(),
        );
    }
    'c_42160: {
        if !list.is_null() {} else {
            __assert_fail(
                b"list != NULL\0" as *const u8 as *const libc::c_char,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                990 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 66],
                    &[libc::c_char; 66],
                >(
                    b"void add_abbrev(unsigned long, unsigned long, int, abbrev_list *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if ((*list).first_abbrev).is_null() {
        (*list).first_abbrev = entry;
    } else {
        (*(*list).last_abbrev).next = entry;
    }
    (*list).last_abbrev = entry;
}
unsafe extern "C" fn add_abbrev_attr(
    mut attribute: libc::c_ulong,
    mut form: libc::c_ulong,
    mut implicit_const: dwarf_signed_vma,
    mut list: *mut abbrev_list,
) {
    let mut attr: *mut abbrev_attr = 0 as *mut abbrev_attr;
    attr = xmalloc(::core::mem::size_of::<abbrev_attr>() as libc::c_ulong)
        as *mut abbrev_attr;
    (*attr).attribute = attribute;
    (*attr).form = form;
    (*attr).implicit_const = implicit_const;
    (*attr).next = 0 as *mut abbrev_attr;
    if !list.is_null() && !((*list).last_abbrev).is_null() {} else {
        __assert_fail(
            b"list != NULL && list->last_abbrev != NULL\0" as *const u8
                as *const libc::c_char,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            1015 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 84],
                &[libc::c_char; 84],
            >(
                b"void add_abbrev_attr(unsigned long, unsigned long, dwarf_signed_vma, abbrev_list *)\0",
            ))
                .as_ptr(),
        );
    }
    'c_41782: {
        if !list.is_null() && !((*list).last_abbrev).is_null() {} else {
            __assert_fail(
                b"list != NULL && list->last_abbrev != NULL\0" as *const u8
                    as *const libc::c_char,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                1015 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 84],
                    &[libc::c_char; 84],
                >(
                    b"void add_abbrev_attr(unsigned long, unsigned long, dwarf_signed_vma, abbrev_list *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if ((*(*list).last_abbrev).first_attr).is_null() {
        (*(*list).last_abbrev).first_attr = attr;
    } else {
        (*(*(*list).last_abbrev).last_attr).next = attr;
    }
    (*(*list).last_abbrev).last_attr = attr;
}
unsafe extern "C" fn process_abbrev_set(
    mut section: *mut dwarf_section,
    mut abbrev_base: dwarf_vma,
    mut abbrev_size: dwarf_vma,
    mut abbrev_offset: dwarf_vma,
    mut list: *mut abbrev_list,
) -> *mut libc::c_uchar {
    if abbrev_base >= (*section).size
        || abbrev_size > ((*section).size).wrapping_sub(abbrev_base)
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            abbrev_base.wrapping_add(abbrev_size),
            (*section).size,
        );
        return 0 as *mut libc::c_uchar;
    }
    if abbrev_offset >= abbrev_size {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            abbrev_offset,
            abbrev_size,
        );
        return 0 as *mut libc::c_uchar;
    }
    let mut start: *mut libc::c_uchar = ((*section).start).offset(abbrev_base as isize);
    let mut end: *mut libc::c_uchar = start.offset(abbrev_size as isize);
    start = start.offset(abbrev_offset as isize);
    while start < end {
        let mut entry: libc::c_ulong = 0;
        let mut tag: libc::c_ulong = 0;
        let mut attribute: libc::c_ulong = 0;
        let mut children: libc::c_int = 0;
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(start, end, 0 as libc::c_int != 0, &mut _len, &mut _status);
        start = start.offset(_len as isize);
        entry = _val;
        if entry != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            1066 as libc::c_int as libc::c_ulong,
        );
        if start == end {
            return 0 as *mut libc::c_uchar;
        }
        if entry == 0 as libc::c_int as libc::c_ulong {
            return start;
        }
        let mut _val_0: dwarf_vma = 0;
        let mut _len_0: libc::c_uint = 0;
        let mut _status_0: libc::c_int = 0;
        _val_0 = read_leb128(
            start,
            end,
            0 as libc::c_int != 0,
            &mut _len_0,
            &mut _status_0,
        );
        start = start.offset(_len_0 as isize);
        tag = _val_0;
        if tag != _val_0 {
            _status_0 |= 2 as libc::c_int;
        }
        report_leb_status(
            _status_0,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            1076 as libc::c_int as libc::c_ulong,
        );
        if start == end {
            return 0 as *mut libc::c_uchar;
        }
        let fresh6 = start;
        start = start.offset(1);
        children = *fresh6 as libc::c_int;
        add_abbrev(entry, tag, children, list);
        loop {
            let mut form: libc::c_ulong = 0;
            let mut implicit_const: dwarf_signed_vma = -(1 as libc::c_int)
                as dwarf_signed_vma;
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                start,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            start = start.offset(_len_1 as isize);
            attribute = _val_1;
            if attribute != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                1090 as libc::c_int as libc::c_ulong,
            );
            if start == end {
                break;
            }
            let mut _val_2: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_2: libc::c_int = 0;
            _val_2 = read_leb128(
                start,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_2,
            );
            start = start.offset(_len_2 as isize);
            form = _val_2;
            if form != _val_2 {
                _status_2 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_2,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                1094 as libc::c_int as libc::c_ulong,
            );
            if start == end {
                break;
            }
            if form == DW_FORM_implicit_const as libc::c_int as libc::c_ulong {
                let mut _val_3: dwarf_signed_vma = 0;
                let mut _len_3: libc::c_uint = 0;
                let mut _status_3: libc::c_int = 0;
                _val_3 = read_leb128(
                    start,
                    end,
                    1 as libc::c_int != 0,
                    &mut _len_3,
                    &mut _status_3,
                ) as dwarf_signed_vma;
                start = start.offset(_len_3 as isize);
                implicit_const = _val_3;
                if implicit_const != _val_3 {
                    _status_3 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_3,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1100 as libc::c_int as libc::c_ulong,
                );
                if start == end {
                    break;
                }
            }
            add_abbrev_attr(attribute, form, implicit_const, list);
            if !(attribute != 0 as libc::c_int as libc::c_ulong) {
                break;
            }
        }
    }
    error(
        dcgettext(
            0 as *const libc::c_char,
            b".debug_abbrev section not zero terminated\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    return 0 as *mut libc::c_uchar;
}
unsafe extern "C" fn get_TAG_name(mut tag: libc::c_ulong) -> *const libc::c_char {
    let mut name: *const libc::c_char = get_DW_TAG_name(tag as libc::c_uint);
    if name.is_null() {
        static mut buffer: [libc::c_char; 100] = [0; 100];
        if tag >= DW_TAG_lo_user as libc::c_int as libc::c_ulong
            && tag <= DW_TAG_hi_user as libc::c_int as libc::c_ulong
        {
            snprintf(
                buffer.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"User TAG value: %#lx\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                tag,
            );
        } else {
            snprintf(
                buffer.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unknown TAG value: %#lx\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                tag,
            );
        }
        return buffer.as_mut_ptr();
    }
    return name;
}
unsafe extern "C" fn get_FORM_name(mut form: libc::c_ulong) -> *const libc::c_char {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    if form == 0 as libc::c_int as libc::c_ulong {
        return b"DW_FORM value: 0\0" as *const u8 as *const libc::c_char;
    }
    name = get_DW_FORM_name(form as libc::c_uint);
    if name.is_null() {
        static mut buffer: [libc::c_char; 100] = [0; 100];
        snprintf(
            buffer.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            dcgettext(
                0 as *const libc::c_char,
                b"Unknown FORM value: %lx\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            form,
        );
        return buffer.as_mut_ptr();
    }
    return name;
}
unsafe extern "C" fn get_IDX_name(mut idx: libc::c_ulong) -> *const libc::c_char {
    let mut name: *const libc::c_char = get_DW_IDX_name(idx as libc::c_uint);
    if name.is_null() {
        static mut buffer: [libc::c_char; 100] = [0; 100];
        snprintf(
            buffer.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            dcgettext(
                0 as *const libc::c_char,
                b"Unknown IDX value: %lx\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            idx,
        );
        return buffer.as_mut_ptr();
    }
    return name;
}
unsafe extern "C" fn display_block(
    mut data: *mut libc::c_uchar,
    mut length: dwarf_vma,
    end: *const libc::c_uchar,
    mut delimiter: libc::c_char,
) -> *mut libc::c_uchar {
    let mut maxlen: dwarf_vma = 0;
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"%c%s byte block: \0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        delimiter as libc::c_int,
        dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, length),
    );
    if data > end as *mut libc::c_uchar {
        return end as *mut libc::c_uchar;
    }
    maxlen = end.offset_from(data) as libc::c_long as dwarf_vma;
    length = if length > maxlen { maxlen } else { length };
    loop {
        let fresh7 = length;
        length = length.wrapping_sub(1);
        if !(fresh7 != 0) {
            break;
        }
        let fresh8 = data;
        data = data.offset(1);
        printf(
            b"%lx \0" as *const u8 as *const libc::c_char,
            byte_get
                .expect(
                    "non-null function pointer",
                )(fresh8, 1 as libc::c_int as libc::c_uint),
        );
    }
    return data;
}
unsafe extern "C" fn decode_location_expression(
    mut data: *mut libc::c_uchar,
    mut pointer_size: libc::c_uint,
    mut offset_size: libc::c_uint,
    mut dwarf_version: libc::c_int,
    mut length: dwarf_vma,
    mut cu_offset: dwarf_vma,
    mut section: *mut dwarf_section,
) -> libc::c_int {
    let mut op: libc::c_uint = 0;
    let mut uvalue: dwarf_vma = 0;
    let mut svalue: dwarf_signed_vma = 0;
    let mut end: *mut libc::c_uchar = data.offset(length as isize);
    let mut need_frame_base: libc::c_int = 0 as libc::c_int;
    while data < end {
        let fresh9 = data;
        data = data.offset(1);
        op = *fresh9 as libc::c_uint;
        match op {
            3 => {
                let mut amount: size_t = pointer_size as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount,
                            5 as libc::c_int,
                        ),
                        amount as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail: size_t = end.offset_from(data) as libc::c_long as size_t;
                if data > end {
                    avail = 0 as libc::c_int as size_t;
                }
                if amount > avail {
                    amount = avail;
                }
                if amount == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount as libc::c_uint);
                }
                data = data.offset(amount as isize);
                printf(
                    b"DW_OP_addr: %s\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            6 => {
                printf(b"DW_OP_deref\0" as *const u8 as *const libc::c_char);
            }
            8 => {
                let mut amount_0: size_t = 1 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_0,
                            5 as libc::c_int,
                        ),
                        amount_0 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_0: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_0 = 0 as libc::c_int as size_t;
                }
                if amount_0 > avail_0 {
                    amount_0 = avail_0;
                }
                if amount_0 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_0 as libc::c_uint);
                }
                data = data.offset(amount_0 as isize);
                printf(
                    b"DW_OP_const1u: %lu\0" as *const u8 as *const libc::c_char,
                    uvalue,
                );
            }
            9 => {
                let mut amount_1: size_t = 1 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_1
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_1,
                            5 as libc::c_int,
                        ),
                        amount_1 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_1 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_1: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_1 = 0 as libc::c_int as size_t;
                }
                if amount_1 > avail_1 {
                    amount_1 = avail_1;
                }
                if amount_1 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_1 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_1 as isize);
                printf(
                    b"DW_OP_const1s: %ld\0" as *const u8 as *const libc::c_char,
                    svalue,
                );
            }
            10 => {
                let mut amount_2: size_t = 2 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_2 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_2,
                            5 as libc::c_int,
                        ),
                        amount_2 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_2 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_2: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_2 = 0 as libc::c_int as size_t;
                }
                if amount_2 > avail_2 {
                    amount_2 = avail_2;
                }
                if amount_2 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_2 as libc::c_uint);
                }
                data = data.offset(amount_2 as isize);
                printf(
                    b"DW_OP_const2u: %lu\0" as *const u8 as *const libc::c_char,
                    uvalue,
                );
            }
            11 => {
                let mut amount_3: size_t = 2 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_3
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_3,
                            5 as libc::c_int,
                        ),
                        amount_3 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_3 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_3: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_3 = 0 as libc::c_int as size_t;
                }
                if amount_3 > avail_3 {
                    amount_3 = avail_3;
                }
                if amount_3 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_3 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_3 as isize);
                printf(
                    b"DW_OP_const2s: %ld\0" as *const u8 as *const libc::c_char,
                    svalue,
                );
            }
            12 => {
                let mut amount_4: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_4 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_4,
                            5 as libc::c_int,
                        ),
                        amount_4 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_4 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_4: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_4 = 0 as libc::c_int as size_t;
                }
                if amount_4 > avail_4 {
                    amount_4 = avail_4;
                }
                if amount_4 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_4 as libc::c_uint);
                }
                data = data.offset(amount_4 as isize);
                printf(
                    b"DW_OP_const4u: %lu\0" as *const u8 as *const libc::c_char,
                    uvalue,
                );
            }
            13 => {
                let mut amount_5: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_5
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_5,
                            5 as libc::c_int,
                        ),
                        amount_5 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_5 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_5: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_5 = 0 as libc::c_int as size_t;
                }
                if amount_5 > avail_5 {
                    amount_5 = avail_5;
                }
                if amount_5 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_5 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_5 as isize);
                printf(
                    b"DW_OP_const4s: %ld\0" as *const u8 as *const libc::c_char,
                    svalue,
                );
            }
            14 => {
                let mut amount_6: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_6 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_6,
                            5 as libc::c_int,
                        ),
                        amount_6 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_6 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_6: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_6 = 0 as libc::c_int as size_t;
                }
                if amount_6 > avail_6 {
                    amount_6 = avail_6;
                }
                if amount_6 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_6 as libc::c_uint);
                }
                data = data.offset(amount_6 as isize);
                printf(
                    b"DW_OP_const8u: %lu \0" as *const u8 as *const libc::c_char,
                    uvalue,
                );
                let mut amount_7: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_7 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_7,
                            5 as libc::c_int,
                        ),
                        amount_7 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_7 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_7: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_7 = 0 as libc::c_int as size_t;
                }
                if amount_7 > avail_7 {
                    amount_7 = avail_7;
                }
                if amount_7 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_7 as libc::c_uint);
                }
                data = data.offset(amount_7 as isize);
                printf(b"%lu\0" as *const u8 as *const libc::c_char, uvalue);
            }
            15 => {
                let mut amount_8: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_8
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_8,
                            5 as libc::c_int,
                        ),
                        amount_8 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_8 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_8: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_8 = 0 as libc::c_int as size_t;
                }
                if amount_8 > avail_8 {
                    amount_8 = avail_8;
                }
                if amount_8 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_8 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_8 as isize);
                printf(
                    b"DW_OP_const8s: %ld \0" as *const u8 as *const libc::c_char,
                    svalue,
                );
                let mut amount_9: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_9
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_9,
                            5 as libc::c_int,
                        ),
                        amount_9 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_9 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_9: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_9 = 0 as libc::c_int as size_t;
                }
                if amount_9 > avail_9 {
                    amount_9 = avail_9;
                }
                if amount_9 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_9 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_9 as isize);
                printf(b"%ld\0" as *const u8 as *const libc::c_char, svalue);
            }
            16 => {
                let mut _val: dwarf_vma = 0;
                let mut _len: libc::c_uint = 0;
                let mut _status: libc::c_int = 0;
                _val = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len,
                    &mut _status,
                );
                data = data.offset(_len as isize);
                uvalue = _val;
                if uvalue != _val {
                    _status |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1256 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_constu: %s\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            17 => {
                let mut _val_0: dwarf_signed_vma = 0;
                let mut _len_0: libc::c_uint = 0;
                let mut _status_0: libc::c_int = 0;
                _val_0 = read_leb128(
                    data,
                    end,
                    1 as libc::c_int != 0,
                    &mut _len_0,
                    &mut _status_0,
                ) as dwarf_signed_vma;
                data = data.offset(_len_0 as isize);
                svalue = _val_0;
                if svalue != _val_0 {
                    _status_0 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_0,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1260 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_consts: %s\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(
                        b"d\0" as *const u8 as *const libc::c_char,
                        svalue as dwarf_vma,
                    ),
                );
            }
            18 => {
                printf(b"DW_OP_dup\0" as *const u8 as *const libc::c_char);
            }
            19 => {
                printf(b"DW_OP_drop\0" as *const u8 as *const libc::c_char);
            }
            20 => {
                printf(b"DW_OP_over\0" as *const u8 as *const libc::c_char);
            }
            21 => {
                let mut amount_10: size_t = 1 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_10 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_10,
                            5 as libc::c_int,
                        ),
                        amount_10 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_10 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_10: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_10 = 0 as libc::c_int as size_t;
                }
                if amount_10 > avail_10 {
                    amount_10 = avail_10;
                }
                if amount_10 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_10 as libc::c_uint);
                }
                data = data.offset(amount_10 as isize);
                printf(b"DW_OP_pick: %ld\0" as *const u8 as *const libc::c_char, uvalue);
            }
            22 => {
                printf(b"DW_OP_swap\0" as *const u8 as *const libc::c_char);
            }
            23 => {
                printf(b"DW_OP_rot\0" as *const u8 as *const libc::c_char);
            }
            24 => {
                printf(b"DW_OP_xderef\0" as *const u8 as *const libc::c_char);
            }
            25 => {
                printf(b"DW_OP_abs\0" as *const u8 as *const libc::c_char);
            }
            26 => {
                printf(b"DW_OP_and\0" as *const u8 as *const libc::c_char);
            }
            27 => {
                printf(b"DW_OP_div\0" as *const u8 as *const libc::c_char);
            }
            28 => {
                printf(b"DW_OP_minus\0" as *const u8 as *const libc::c_char);
            }
            29 => {
                printf(b"DW_OP_mod\0" as *const u8 as *const libc::c_char);
            }
            30 => {
                printf(b"DW_OP_mul\0" as *const u8 as *const libc::c_char);
            }
            31 => {
                printf(b"DW_OP_neg\0" as *const u8 as *const libc::c_char);
            }
            32 => {
                printf(b"DW_OP_not\0" as *const u8 as *const libc::c_char);
            }
            33 => {
                printf(b"DW_OP_or\0" as *const u8 as *const libc::c_char);
            }
            34 => {
                printf(b"DW_OP_plus\0" as *const u8 as *const libc::c_char);
            }
            35 => {
                let mut _val_1: dwarf_vma = 0;
                let mut _len_1: libc::c_uint = 0;
                let mut _status_1: libc::c_int = 0;
                _val_1 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_1,
                    &mut _status_1,
                );
                data = data.offset(_len_1 as isize);
                uvalue = _val_1;
                if uvalue != _val_1 {
                    _status_1 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_1,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1316 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_plus_uconst: %s\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            36 => {
                printf(b"DW_OP_shl\0" as *const u8 as *const libc::c_char);
            }
            37 => {
                printf(b"DW_OP_shr\0" as *const u8 as *const libc::c_char);
            }
            38 => {
                printf(b"DW_OP_shra\0" as *const u8 as *const libc::c_char);
            }
            39 => {
                printf(b"DW_OP_xor\0" as *const u8 as *const libc::c_char);
            }
            40 => {
                let mut amount_11: size_t = 2 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_11
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_11,
                            5 as libc::c_int,
                        ),
                        amount_11 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_11 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_11: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_11 = 0 as libc::c_int as size_t;
                }
                if amount_11 > avail_11 {
                    amount_11 = avail_11;
                }
                if amount_11 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_11 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_11 as isize);
                printf(b"DW_OP_bra: %ld\0" as *const u8 as *const libc::c_char, svalue);
            }
            41 => {
                printf(b"DW_OP_eq\0" as *const u8 as *const libc::c_char);
            }
            42 => {
                printf(b"DW_OP_ge\0" as *const u8 as *const libc::c_char);
            }
            43 => {
                printf(b"DW_OP_gt\0" as *const u8 as *const libc::c_char);
            }
            44 => {
                printf(b"DW_OP_le\0" as *const u8 as *const libc::c_char);
            }
            45 => {
                printf(b"DW_OP_lt\0" as *const u8 as *const libc::c_char);
            }
            46 => {
                printf(b"DW_OP_ne\0" as *const u8 as *const libc::c_char);
            }
            47 => {
                let mut amount_12: size_t = 2 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_12
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_12,
                            5 as libc::c_int,
                        ),
                        amount_12 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_12 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_12: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_12 = 0 as libc::c_int as size_t;
                }
                if amount_12 > avail_12 {
                    amount_12 = avail_12;
                }
                if amount_12 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_12 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_12 as isize);
                printf(b"DW_OP_skip: %ld\0" as *const u8 as *const libc::c_char, svalue);
            }
            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63
            | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78
            | 79 => {
                printf(
                    b"DW_OP_lit%d\0" as *const u8 as *const libc::c_char,
                    op.wrapping_sub(DW_OP_lit0 as libc::c_int as libc::c_uint),
                );
            }
            80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95
            | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108
            | 109 | 110 | 111 => {
                printf(
                    b"DW_OP_reg%d (%s)\0" as *const u8 as *const libc::c_char,
                    op.wrapping_sub(DW_OP_reg0 as libc::c_int as libc::c_uint),
                    regname(
                        op.wrapping_sub(DW_OP_reg0 as libc::c_int as libc::c_uint),
                        1 as libc::c_int,
                    ),
                );
            }
            112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124
            | 125 | 126 | 127 | 128 | 129 | 130 | 131 | 132 | 133 | 134 | 135 | 136 | 137
            | 138 | 139 | 140 | 141 | 142 | 143 => {
                let mut _val_2: dwarf_signed_vma = 0;
                let mut _len_2: libc::c_uint = 0;
                let mut _status_2: libc::c_int = 0;
                _val_2 = read_leb128(
                    data,
                    end,
                    1 as libc::c_int != 0,
                    &mut _len_2,
                    &mut _status_2,
                ) as dwarf_signed_vma;
                data = data.offset(_len_2 as isize);
                svalue = _val_2;
                if svalue != _val_2 {
                    _status_2 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_2,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1461 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_breg%d (%s): %s\0" as *const u8 as *const libc::c_char,
                    op.wrapping_sub(DW_OP_breg0 as libc::c_int as libc::c_uint),
                    regname(
                        op.wrapping_sub(DW_OP_breg0 as libc::c_int as libc::c_uint),
                        1 as libc::c_int,
                    ),
                    dwarf_vmatoa(
                        b"d\0" as *const u8 as *const libc::c_char,
                        svalue as dwarf_vma,
                    ),
                );
            }
            144 => {
                let mut _val_3: dwarf_vma = 0;
                let mut _len_3: libc::c_uint = 0;
                let mut _status_3: libc::c_int = 0;
                _val_3 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_3,
                    &mut _status_3,
                );
                data = data.offset(_len_3 as isize);
                uvalue = _val_3;
                if uvalue != _val_3 {
                    _status_3 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_3,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1467 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_regx: %s (%s)\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, uvalue),
                    regname(uvalue as libc::c_uint, 1 as libc::c_int),
                );
            }
            145 => {
                need_frame_base = 1 as libc::c_int;
                let mut _val_4: dwarf_signed_vma = 0;
                let mut _len_4: libc::c_uint = 0;
                let mut _status_4: libc::c_int = 0;
                _val_4 = read_leb128(
                    data,
                    end,
                    1 as libc::c_int != 0,
                    &mut _len_4,
                    &mut _status_4,
                ) as dwarf_signed_vma;
                data = data.offset(_len_4 as isize);
                svalue = _val_4;
                if svalue != _val_4 {
                    _status_4 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_4,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1473 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_fbreg: %s\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(
                        b"d\0" as *const u8 as *const libc::c_char,
                        svalue as dwarf_vma,
                    ),
                );
            }
            146 => {
                let mut _val_5: dwarf_vma = 0;
                let mut _len_5: libc::c_uint = 0;
                let mut _status_5: libc::c_int = 0;
                _val_5 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_5,
                    &mut _status_5,
                );
                data = data.offset(_len_5 as isize);
                uvalue = _val_5;
                if uvalue != _val_5 {
                    _status_5 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_5,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1477 as libc::c_int as libc::c_ulong,
                );
                let mut _val_6: dwarf_signed_vma = 0;
                let mut _len_6: libc::c_uint = 0;
                let mut _status_6: libc::c_int = 0;
                _val_6 = read_leb128(
                    data,
                    end,
                    1 as libc::c_int != 0,
                    &mut _len_6,
                    &mut _status_6,
                ) as dwarf_signed_vma;
                data = data.offset(_len_6 as isize);
                svalue = _val_6;
                if svalue != _val_6 {
                    _status_6 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_6,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1478 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_bregx: %s (%s) %s\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, uvalue),
                    regname(uvalue as libc::c_uint, 1 as libc::c_int),
                    dwarf_vmatoa(
                        b"d\0" as *const u8 as *const libc::c_char,
                        svalue as dwarf_vma,
                    ),
                );
            }
            147 => {
                let mut _val_7: dwarf_vma = 0;
                let mut _len_7: libc::c_uint = 0;
                let mut _status_7: libc::c_int = 0;
                _val_7 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_7,
                    &mut _status_7,
                );
                data = data.offset(_len_7 as isize);
                uvalue = _val_7;
                if uvalue != _val_7 {
                    _status_7 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_7,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1484 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_piece: %s\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            148 => {
                let mut amount_13: size_t = 1 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_13 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_13,
                            5 as libc::c_int,
                        ),
                        amount_13 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_13 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_13: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_13 = 0 as libc::c_int as size_t;
                }
                if amount_13 > avail_13 {
                    amount_13 = avail_13;
                }
                if amount_13 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_13 as libc::c_uint);
                }
                data = data.offset(amount_13 as isize);
                printf(
                    b"DW_OP_deref_size: %ld\0" as *const u8 as *const libc::c_char,
                    uvalue as libc::c_long,
                );
            }
            149 => {
                let mut amount_14: size_t = 1 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_14 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_14,
                            5 as libc::c_int,
                        ),
                        amount_14 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_14 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_14: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_14 = 0 as libc::c_int as size_t;
                }
                if amount_14 > avail_14 {
                    amount_14 = avail_14;
                }
                if amount_14 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_14 as libc::c_uint);
                }
                data = data.offset(amount_14 as isize);
                printf(
                    b"DW_OP_xderef_size: %ld\0" as *const u8 as *const libc::c_char,
                    uvalue as libc::c_long,
                );
            }
            150 => {
                printf(b"DW_OP_nop\0" as *const u8 as *const libc::c_char);
            }
            151 => {
                printf(
                    b"DW_OP_push_object_address\0" as *const u8 as *const libc::c_char,
                );
            }
            152 => {
                let mut amount_15: size_t = 2 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_15
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_15,
                            5 as libc::c_int,
                        ),
                        amount_15 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_15 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_15: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_15 = 0 as libc::c_int as size_t;
                }
                if amount_15 > avail_15 {
                    amount_15 = avail_15;
                }
                if amount_15 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_15 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_15 as isize);
                printf(
                    b"DW_OP_call2: <0x%s>\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        (svalue as libc::c_ulong).wrapping_add(cu_offset),
                    ),
                );
            }
            153 => {
                let mut amount_16: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong)
                    < amount_16
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_16,
                            5 as libc::c_int,
                        ),
                        amount_16 as libc::c_int,
                        ::core::mem::size_of::<dwarf_signed_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_16 = ::core::mem::size_of::<dwarf_signed_vma>()
                        as libc::c_ulong;
                }
                let mut avail_16: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_16 = 0 as libc::c_int as size_t;
                }
                if amount_16 > avail_16 {
                    amount_16 = avail_16;
                }
                if amount_16 == 0 as libc::c_int as libc::c_ulong {
                    svalue = 0 as libc::c_int as dwarf_signed_vma;
                } else {
                    svalue = byte_get_signed(data, amount_16 as libc::c_uint)
                        as dwarf_signed_vma;
                }
                data = data.offset(amount_16 as isize);
                printf(
                    b"DW_OP_call4: <0x%s>\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        (svalue as libc::c_ulong).wrapping_add(cu_offset),
                    ),
                );
            }
            154 => {
                if dwarf_version == -(1 as libc::c_int) {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(DW_OP_call_ref in frame info)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return need_frame_base;
                }
                if dwarf_version == 2 as libc::c_int {
                    let mut amount_17: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_17
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_17,
                                5 as libc::c_int,
                            ),
                            amount_17 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_17 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_17: size_t = end.offset_from(data) as libc::c_long
                        as size_t;
                    if data > end {
                        avail_17 = 0 as libc::c_int as size_t;
                    }
                    if amount_17 > avail_17 {
                        amount_17 = avail_17;
                    }
                    if amount_17 == 0 as libc::c_int as libc::c_ulong {
                        uvalue = 0 as libc::c_int as dwarf_vma;
                    } else {
                        uvalue = byte_get
                            .expect(
                                "non-null function pointer",
                            )(data, amount_17 as libc::c_uint);
                    }
                    data = data.offset(amount_17 as isize);
                } else {
                    let mut amount_18: size_t = offset_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_18
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_18,
                                5 as libc::c_int,
                            ),
                            amount_18 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_18 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_18: size_t = end.offset_from(data) as libc::c_long
                        as size_t;
                    if data > end {
                        avail_18 = 0 as libc::c_int as size_t;
                    }
                    if amount_18 > avail_18 {
                        amount_18 = avail_18;
                    }
                    if amount_18 == 0 as libc::c_int as libc::c_ulong {
                        uvalue = 0 as libc::c_int as dwarf_vma;
                    } else {
                        uvalue = byte_get
                            .expect(
                                "non-null function pointer",
                            )(data, amount_18 as libc::c_uint);
                    }
                    data = data.offset(amount_18 as isize);
                }
                printf(
                    b"DW_OP_call_ref: <0x%s>\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            155 => {
                printf(b"DW_OP_form_tls_address\0" as *const u8 as *const libc::c_char);
            }
            156 => {
                printf(b"DW_OP_call_frame_cfa\0" as *const u8 as *const libc::c_char);
            }
            157 => {
                printf(b"DW_OP_bit_piece: \0" as *const u8 as *const libc::c_char);
                let mut _val_8: dwarf_vma = 0;
                let mut _len_8: libc::c_uint = 0;
                let mut _status_8: libc::c_int = 0;
                _val_8 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_8,
                    &mut _status_8,
                );
                data = data.offset(_len_8 as isize);
                uvalue = _val_8;
                if uvalue != _val_8 {
                    _status_8 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_8,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1544 as libc::c_int as libc::c_ulong,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"size: %s \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, uvalue),
                );
                let mut _val_9: dwarf_vma = 0;
                let mut _len_9: libc::c_uint = 0;
                let mut _status_9: libc::c_int = 0;
                _val_9 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_9,
                    &mut _status_9,
                );
                data = data.offset(_len_9 as isize);
                uvalue = _val_9;
                if uvalue != _val_9 {
                    _status_9 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_9,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1546 as libc::c_int as libc::c_ulong,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"offset: %s \0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            159 => {
                printf(b"DW_OP_stack_value\0" as *const u8 as *const libc::c_char);
            }
            158 => {
                printf(b"DW_OP_implicit_value\0" as *const u8 as *const libc::c_char);
                let mut _val_10: dwarf_vma = 0;
                let mut _len_10: libc::c_uint = 0;
                let mut _status_10: libc::c_int = 0;
                _val_10 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_10,
                    &mut _status_10,
                );
                data = data.offset(_len_10 as isize);
                uvalue = _val_10;
                if uvalue != _val_10 {
                    _status_10 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_10,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1557 as libc::c_int as libc::c_ulong,
                );
                data = display_block(data, uvalue, end, ' ' as i32 as libc::c_char);
            }
            224 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"DW_OP_GNU_push_tls_address or DW_OP_HP_unknown\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            240 => {
                printf(b"DW_OP_GNU_uninit\0" as *const u8 as *const libc::c_char);
            }
            241 => {
                let mut encoding: libc::c_int = 0 as libc::c_int;
                let mut addr: dwarf_vma = 0;
                if data < end {
                    let fresh10 = data;
                    data = data.offset(1);
                    encoding = *fresh10 as libc::c_int;
                }
                addr = get_encoded_value(&mut data, encoding, section, end);
                printf(
                    b"DW_OP_GNU_encoded_addr: fmt:%02x addr:\0" as *const u8
                        as *const libc::c_char,
                    encoding,
                );
                print_dwarf_vma(addr, pointer_size);
            }
            160 | 242 => {
                if dwarf_version == -(1 as libc::c_int) {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(%s in frame info)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        if op == DW_OP_implicit_pointer as libc::c_int as libc::c_uint {
                            b"DW_OP_implicit_pointer\0" as *const u8
                                as *const libc::c_char
                        } else {
                            b"DW_OP_GNU_implicit_pointer\0" as *const u8
                                as *const libc::c_char
                        },
                    );
                    return need_frame_base;
                }
                if dwarf_version == 2 as libc::c_int {
                    let mut amount_19: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_19
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_19,
                                5 as libc::c_int,
                            ),
                            amount_19 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_19 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_19: size_t = end.offset_from(data) as libc::c_long
                        as size_t;
                    if data > end {
                        avail_19 = 0 as libc::c_int as size_t;
                    }
                    if amount_19 > avail_19 {
                        amount_19 = avail_19;
                    }
                    if amount_19 == 0 as libc::c_int as libc::c_ulong {
                        uvalue = 0 as libc::c_int as dwarf_vma;
                    } else {
                        uvalue = byte_get
                            .expect(
                                "non-null function pointer",
                            )(data, amount_19 as libc::c_uint);
                    }
                    data = data.offset(amount_19 as isize);
                } else {
                    let mut amount_20: size_t = offset_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_20
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_20,
                                5 as libc::c_int,
                            ),
                            amount_20 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_20 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_20: size_t = end.offset_from(data) as libc::c_long
                        as size_t;
                    if data > end {
                        avail_20 = 0 as libc::c_int as size_t;
                    }
                    if amount_20 > avail_20 {
                        amount_20 = avail_20;
                    }
                    if amount_20 == 0 as libc::c_int as libc::c_ulong {
                        uvalue = 0 as libc::c_int as dwarf_vma;
                    } else {
                        uvalue = byte_get
                            .expect(
                                "non-null function pointer",
                            )(data, amount_20 as libc::c_uint);
                    }
                    data = data.offset(amount_20 as isize);
                }
                let mut _val_11: dwarf_signed_vma = 0;
                let mut _len_11: libc::c_uint = 0;
                let mut _status_11: libc::c_int = 0;
                _val_11 = read_leb128(
                    data,
                    end,
                    1 as libc::c_int != 0,
                    &mut _len_11,
                    &mut _status_11,
                ) as dwarf_signed_vma;
                data = data.offset(_len_11 as isize);
                svalue = _val_11;
                if svalue != _val_11 {
                    _status_11 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_11,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1603 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"%s: <0x%s> %s\0" as *const u8 as *const libc::c_char,
                    if op == DW_OP_implicit_pointer as libc::c_int as libc::c_uint {
                        b"DW_OP_implicit_pointer\0" as *const u8 as *const libc::c_char
                    } else {
                        b"DW_OP_GNU_implicit_pointer\0" as *const u8
                            as *const libc::c_char
                    },
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                    dwarf_vmatoa(
                        b"d\0" as *const u8 as *const libc::c_char,
                        svalue as dwarf_vma,
                    ),
                );
            }
            163 | 243 => {
                let mut _val_12: dwarf_vma = 0;
                let mut _len_12: libc::c_uint = 0;
                let mut _status_12: libc::c_int = 0;
                _val_12 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_12,
                    &mut _status_12,
                );
                data = data.offset(_len_12 as isize);
                uvalue = _val_12;
                if uvalue != _val_12 {
                    _status_12 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_12,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1612 as libc::c_int as libc::c_ulong,
                );
                if uvalue > end.offset_from(data) as libc::c_long as dwarf_vma {
                    uvalue = end.offset_from(data) as libc::c_long as dwarf_vma;
                }
                printf(
                    b"%s: (\0" as *const u8 as *const libc::c_char,
                    if op == DW_OP_entry_value as libc::c_int as libc::c_uint {
                        b"DW_OP_entry_value\0" as *const u8 as *const libc::c_char
                    } else {
                        b"DW_OP_GNU_entry_value\0" as *const u8 as *const libc::c_char
                    },
                );
                if decode_location_expression(
                    data,
                    pointer_size,
                    offset_size,
                    dwarf_version,
                    uvalue,
                    cu_offset,
                    section,
                ) != 0
                {
                    need_frame_base = 1 as libc::c_int;
                }
                putchar(')' as i32);
                data = data.offset(uvalue as isize);
            }
            164 | 244 => {
                let mut _val_13: dwarf_vma = 0;
                let mut _len_13: libc::c_uint = 0;
                let mut _status_13: libc::c_int = 0;
                _val_13 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_13,
                    &mut _status_13,
                );
                data = data.offset(_len_13 as isize);
                uvalue = _val_13;
                if uvalue != _val_13 {
                    _status_13 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_13,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1627 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"%s: <0x%s> \0" as *const u8 as *const libc::c_char,
                    if op == DW_OP_const_type as libc::c_int as libc::c_uint {
                        b"DW_OP_const_type\0" as *const u8 as *const libc::c_char
                    } else {
                        b"DW_OP_GNU_const_type\0" as *const u8 as *const libc::c_char
                    },
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        cu_offset.wrapping_add(uvalue),
                    ),
                );
                let mut amount_21: size_t = 1 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_21 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_21,
                            5 as libc::c_int,
                        ),
                        amount_21 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_21 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_21: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_21 = 0 as libc::c_int as size_t;
                }
                if amount_21 > avail_21 {
                    amount_21 = avail_21;
                }
                if amount_21 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_21 as libc::c_uint);
                }
                data = data.offset(amount_21 as isize);
                data = display_block(data, uvalue, end, ' ' as i32 as libc::c_char);
            }
            165 | 245 => {
                let mut _val_14: dwarf_vma = 0;
                let mut _len_14: libc::c_uint = 0;
                let mut _status_14: libc::c_int = 0;
                _val_14 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_14,
                    &mut _status_14,
                );
                data = data.offset(_len_14 as isize);
                uvalue = _val_14;
                if uvalue != _val_14 {
                    _status_14 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_14,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1637 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"%s: %s (%s)\0" as *const u8 as *const libc::c_char,
                    if op == DW_OP_regval_type as libc::c_int as libc::c_uint {
                        b"DW_OP_regval_type\0" as *const u8 as *const libc::c_char
                    } else {
                        b"DW_OP_GNU_regval_type\0" as *const u8 as *const libc::c_char
                    },
                    dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, uvalue),
                    regname(uvalue as libc::c_uint, 1 as libc::c_int),
                );
                let mut _val_15: dwarf_vma = 0;
                let mut _len_15: libc::c_uint = 0;
                let mut _status_15: libc::c_int = 0;
                _val_15 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_15,
                    &mut _status_15,
                );
                data = data.offset(_len_15 as isize);
                uvalue = _val_15;
                if uvalue != _val_15 {
                    _status_15 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_15,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1642 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b" <0x%s>\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        cu_offset.wrapping_add(uvalue),
                    ),
                );
            }
            166 | 246 => {
                let mut amount_22: size_t = 1 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_22 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_22,
                            5 as libc::c_int,
                        ),
                        amount_22 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_22 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_22: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_22 = 0 as libc::c_int as size_t;
                }
                if amount_22 > avail_22 {
                    amount_22 = avail_22;
                }
                if amount_22 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_22 as libc::c_uint);
                }
                data = data.offset(amount_22 as isize);
                printf(
                    b"%s: %ld\0" as *const u8 as *const libc::c_char,
                    if op == DW_OP_deref_type as libc::c_int as libc::c_uint {
                        b"DW_OP_deref_type\0" as *const u8 as *const libc::c_char
                    } else {
                        b"DW_OP_GNU_deref_type\0" as *const u8 as *const libc::c_char
                    },
                    uvalue as libc::c_long,
                );
                let mut _val_16: dwarf_vma = 0;
                let mut _len_16: libc::c_uint = 0;
                let mut _status_16: libc::c_int = 0;
                _val_16 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_16,
                    &mut _status_16,
                );
                data = data.offset(_len_16 as isize);
                uvalue = _val_16;
                if uvalue != _val_16 {
                    _status_16 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_16,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1652 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b" <0x%s>\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        cu_offset.wrapping_add(uvalue),
                    ),
                );
            }
            168 | 247 => {
                let mut _val_17: dwarf_vma = 0;
                let mut _len_17: libc::c_uint = 0;
                let mut _status_17: libc::c_int = 0;
                _val_17 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_17,
                    &mut _status_17,
                );
                data = data.offset(_len_17 as isize);
                uvalue = _val_17;
                if uvalue != _val_17 {
                    _status_17 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_17,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1657 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"%s <0x%s>\0" as *const u8 as *const libc::c_char,
                    if op == DW_OP_convert as libc::c_int as libc::c_uint {
                        b"DW_OP_convert\0" as *const u8 as *const libc::c_char
                    } else {
                        b"DW_OP_GNU_convert\0" as *const u8 as *const libc::c_char
                    },
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        if uvalue != 0 {
                            cu_offset.wrapping_add(uvalue)
                        } else {
                            0 as libc::c_int as libc::c_ulong
                        },
                    ),
                );
            }
            169 | 249 => {
                let mut _val_18: dwarf_vma = 0;
                let mut _len_18: libc::c_uint = 0;
                let mut _status_18: libc::c_int = 0;
                _val_18 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_18,
                    &mut _status_18,
                );
                data = data.offset(_len_18 as isize);
                uvalue = _val_18;
                if uvalue != _val_18 {
                    _status_18 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_18,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1664 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"%s <0x%s>\0" as *const u8 as *const libc::c_char,
                    if op == DW_OP_reinterpret as libc::c_int as libc::c_uint {
                        b"DW_OP_reinterpret\0" as *const u8 as *const libc::c_char
                    } else {
                        b"DW_OP_GNU_reinterpret\0" as *const u8 as *const libc::c_char
                    },
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        if uvalue != 0 {
                            cu_offset.wrapping_add(uvalue)
                        } else {
                            0 as libc::c_int as libc::c_ulong
                        },
                    ),
                );
            }
            250 => {
                let mut amount_23: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_23 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_23,
                            5 as libc::c_int,
                        ),
                        amount_23 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_23 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_23: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_23 = 0 as libc::c_int as size_t;
                }
                if amount_23 > avail_23 {
                    amount_23 = avail_23;
                }
                if amount_23 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_23 as libc::c_uint);
                }
                data = data.offset(amount_23 as isize);
                printf(
                    b"DW_OP_GNU_parameter_ref: <0x%s>\0" as *const u8
                        as *const libc::c_char,
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        cu_offset.wrapping_add(uvalue),
                    ),
                );
            }
            251 => {
                let mut _val_19: dwarf_vma = 0;
                let mut _len_19: libc::c_uint = 0;
                let mut _status_19: libc::c_int = 0;
                _val_19 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_19,
                    &mut _status_19,
                );
                data = data.offset(_len_19 as isize);
                uvalue = _val_19;
                if uvalue != _val_19 {
                    _status_19 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_19,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1676 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_GNU_addr_index <0x%s>\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            252 => {
                let mut _val_20: dwarf_vma = 0;
                let mut _len_20: libc::c_uint = 0;
                let mut _status_20: libc::c_int = 0;
                _val_20 = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_20,
                    &mut _status_20,
                );
                data = data.offset(_len_20 as isize);
                uvalue = _val_20;
                if uvalue != _val_20 {
                    _status_20 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_20,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    1680 as libc::c_int as libc::c_ulong,
                );
                printf(
                    b"DW_OP_GNU_const_index <0x%s>\0" as *const u8
                        as *const libc::c_char,
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            253 => {
                if dwarf_version == -(1 as libc::c_int) {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(DW_OP_GNU_variable_value in frame info)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return need_frame_base;
                }
                if dwarf_version == 2 as libc::c_int {
                    let mut amount_24: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_24
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_24,
                                5 as libc::c_int,
                            ),
                            amount_24 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_24 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_24: size_t = end.offset_from(data) as libc::c_long
                        as size_t;
                    if data > end {
                        avail_24 = 0 as libc::c_int as size_t;
                    }
                    if amount_24 > avail_24 {
                        amount_24 = avail_24;
                    }
                    if amount_24 == 0 as libc::c_int as libc::c_ulong {
                        uvalue = 0 as libc::c_int as dwarf_vma;
                    } else {
                        uvalue = byte_get
                            .expect(
                                "non-null function pointer",
                            )(data, amount_24 as libc::c_uint);
                    }
                    data = data.offset(amount_24 as isize);
                } else {
                    let mut amount_25: size_t = offset_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_25
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_25,
                                5 as libc::c_int,
                            ),
                            amount_25 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_25 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_25: size_t = end.offset_from(data) as libc::c_long
                        as size_t;
                    if data > end {
                        avail_25 = 0 as libc::c_int as size_t;
                    }
                    if amount_25 > avail_25 {
                        amount_25 = avail_25;
                    }
                    if amount_25 == 0 as libc::c_int as libc::c_ulong {
                        uvalue = 0 as libc::c_int as dwarf_vma;
                    } else {
                        uvalue = byte_get
                            .expect(
                                "non-null function pointer",
                            )(data, amount_25 as libc::c_uint);
                    }
                    data = data.offset(amount_25 as isize);
                }
                printf(
                    b"DW_OP_GNU_variable_value: <0x%s>\0" as *const u8
                        as *const libc::c_char,
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            225 => {
                printf(b"DW_OP_HP_is_value\0" as *const u8 as *const libc::c_char);
            }
            226 => {
                printf(b"DW_OP_HP_fltconst4\0" as *const u8 as *const libc::c_char);
            }
            227 => {
                printf(b"DW_OP_HP_fltconst8\0" as *const u8 as *const libc::c_char);
            }
            228 => {
                printf(b"DW_OP_HP_mod_range\0" as *const u8 as *const libc::c_char);
            }
            229 => {
                printf(b"DW_OP_HP_unmod_range\0" as *const u8 as *const libc::c_char);
            }
            230 => {
                printf(b"DW_OP_HP_tls\0" as *const u8 as *const libc::c_char);
            }
            248 => {
                printf(
                    b"DW_OP_PGI_omp_thread_num\0" as *const u8 as *const libc::c_char,
                );
            }
            _ => {
                if op >= DW_OP_lo_user as libc::c_int as libc::c_uint
                    && op <= DW_OP_hi_user as libc::c_int as libc::c_uint
                {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(User defined location op 0x%x)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        op,
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(Unknown location op 0x%x)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        op,
                    );
                }
                return need_frame_base;
            }
        }
        if data < end {
            printf(b"; \0" as *const u8 as *const libc::c_char);
        }
    }
    return need_frame_base;
}
unsafe extern "C" fn find_cu_tu_set_v2(
    mut cu_offset: dwarf_vma,
    mut do_types: libc::c_int,
) -> *mut cu_tu_set {
    let mut p: *mut cu_tu_set = 0 as *mut cu_tu_set;
    let mut nsets: libc::c_uint = 0;
    let mut dw_sect: libc::c_uint = 0;
    if do_types != 0 {
        p = tu_sets;
        nsets = tu_count as libc::c_uint;
        dw_sect = DW_SECT_TYPES as libc::c_int as libc::c_uint;
    } else {
        p = cu_sets;
        nsets = cu_count as libc::c_uint;
        dw_sect = DW_SECT_INFO as libc::c_int as libc::c_uint;
    }
    while nsets > 0 as libc::c_int as libc::c_uint {
        if (*p).section_offsets[dw_sect as usize] == cu_offset {
            return p;
        }
        p = p.offset(1);
        p;
        nsets = nsets.wrapping_sub(1);
        nsets;
    }
    return 0 as *mut cu_tu_set;
}
unsafe extern "C" fn fetch_alt_indirect_string(
    mut offset: dwarf_vma,
) -> *const libc::c_char {
    let mut i: *mut separate_info = 0 as *mut separate_info;
    if do_follow_links == 0 {
        return b"\0" as *const u8 as *const libc::c_char;
    }
    if first_separate_info.is_null() {
        return dcgettext(
            0 as *const libc::c_char,
            b"<no links available>\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        );
    }
    i = first_separate_info;
    while !i.is_null() {
        let mut section: *mut dwarf_section = 0 as *mut dwarf_section;
        let mut ret: *const libc::c_char = 0 as *const libc::c_char;
        if load_debug_section(separate_debug_str, (*i).handle) {
            section = &mut (*debug_displays
                .as_mut_ptr()
                .offset(separate_debug_str as libc::c_int as isize))
                .section;
            if !((*section).start).is_null() {
                if !(offset >= (*section).size) {
                    ret = ((*section).start).offset(offset as isize)
                        as *const libc::c_char;
                    if strnlen(ret, ((*section).size).wrapping_sub(offset))
                        == ((*section).size).wrapping_sub(offset)
                    {
                        return dcgettext(
                            0 as *const libc::c_char,
                            b"<no NUL byte at end of alt .debug_str section>\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        );
                    }
                    return ret;
                }
            }
        }
        i = (*i).next;
    }
    warn(
        dcgettext(
            0 as *const libc::c_char,
            b"DW_FORM_GNU_strp_alt offset (%s) too big or no string sections available\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, offset),
    );
    return dcgettext(
        0 as *const libc::c_char,
        b"<offset is too big>\0" as *const u8 as *const libc::c_char,
        5 as libc::c_int,
    );
}
unsafe extern "C" fn get_AT_name(mut attribute: libc::c_ulong) -> *const libc::c_char {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    if attribute == 0 as libc::c_int as libc::c_ulong {
        return b"DW_AT value: 0\0" as *const u8 as *const libc::c_char;
    }
    if attribute == DW_AT_MIPS_fde as libc::c_int as libc::c_ulong {
        return b"DW_AT_MIPS_fde or DW_AT_HP_unmodifiable\0" as *const u8
            as *const libc::c_char;
    }
    name = get_DW_AT_name(attribute as libc::c_uint);
    if name.is_null() {
        static mut buffer: [libc::c_char; 100] = [0; 100];
        snprintf(
            buffer.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            dcgettext(
                0 as *const libc::c_char,
                b"Unknown AT value: %lx\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            attribute,
        );
        return buffer.as_mut_ptr();
    }
    return name;
}
unsafe extern "C" fn add_dwo_info(
    mut value: *const libc::c_char,
    mut cu_offset: dwarf_vma,
    mut type_0: dwo_type,
) {
    let mut dwinfo: *mut dwo_info = xmalloc(
        ::core::mem::size_of::<dwo_info>() as libc::c_ulong,
    ) as *mut dwo_info;
    (*dwinfo).type_0 = type_0;
    (*dwinfo).value = value;
    (*dwinfo).cu_offset = cu_offset;
    (*dwinfo).next = first_dwo_info;
    first_dwo_info = dwinfo;
}
unsafe extern "C" fn add_dwo_name(
    mut name: *const libc::c_char,
    mut cu_offset: dwarf_vma,
) {
    add_dwo_info(name, cu_offset, DWO_NAME);
}
unsafe extern "C" fn add_dwo_dir(
    mut dir: *const libc::c_char,
    mut cu_offset: dwarf_vma,
) {
    add_dwo_info(dir, cu_offset, DWO_DIR);
}
unsafe extern "C" fn add_dwo_id(mut id: *const libc::c_char, mut cu_offset: dwarf_vma) {
    add_dwo_info(id, cu_offset, DWO_ID);
}
unsafe extern "C" fn free_dwo_info() {
    let mut dwinfo: *mut dwo_info = 0 as *mut dwo_info;
    let mut next: *mut dwo_info = 0 as *mut dwo_info;
    dwinfo = first_dwo_info;
    while !dwinfo.is_null() {
        next = (*dwinfo).next;
        free(dwinfo as *mut libc::c_void);
        dwinfo = next;
    }
    first_dwo_info = 0 as *mut dwo_info;
}
#[inline]
unsafe extern "C" fn check_uvalue(
    mut start: *const libc::c_uchar,
    mut uvalue: dwarf_vma,
    mut end: *const libc::c_uchar,
) -> dwarf_vma {
    let mut max_uvalue: dwarf_vma = end.offset_from(start) as libc::c_long as dwarf_vma;
    if uvalue > max_uvalue {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Corrupt attribute block length: %lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            uvalue as libc::c_long,
        );
        uvalue = max_uvalue;
    }
    return uvalue;
}
unsafe extern "C" fn skip_attr_bytes(
    mut form: libc::c_ulong,
    mut data: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut pointer_size: dwarf_vma,
    mut offset_size: dwarf_vma,
    mut dwarf_version: libc::c_int,
    mut value_return: *mut dwarf_vma,
) -> *mut libc::c_uchar {
    let mut svalue: dwarf_signed_vma = 0;
    let mut uvalue: dwarf_vma = 0 as libc::c_int as dwarf_vma;
    let mut inc: dwarf_vma = 0 as libc::c_int as dwarf_vma;
    *value_return = 0 as libc::c_int as dwarf_vma;
    match form {
        16 => {
            if dwarf_version == 2 as libc::c_int {
                let mut amount: size_t = pointer_size;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount,
                            5 as libc::c_int,
                        ),
                        amount as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail: size_t = end.offset_from(data) as libc::c_long as size_t;
                if data > end {
                    avail = 0 as libc::c_int as size_t;
                }
                if amount > avail {
                    amount = avail;
                }
                if amount == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount as libc::c_uint);
                }
                data = data.offset(amount as isize);
            } else if dwarf_version > 2 as libc::c_int {
                let mut amount_0: size_t = offset_size;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_0,
                            5 as libc::c_int,
                        ),
                        amount_0 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_0: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_0 = 0 as libc::c_int as size_t;
                }
                if amount_0 > avail_0 {
                    amount_0 = avail_0;
                }
                if amount_0 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_0 as libc::c_uint);
                }
                data = data.offset(amount_0 as isize);
            } else {
                return 0 as *mut libc::c_uchar
            }
        }
        1 => {
            let mut amount_1: size_t = pointer_size;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_1: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_1 as libc::c_uint);
            }
            data = data.offset(amount_1 as isize);
        }
        14 | 31 | 23 | 7968 | 7969 => {
            let mut amount_2: size_t = offset_size;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_2: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_2 as libc::c_uint);
            }
            data = data.offset(amount_2 as isize);
        }
        25 => {
            uvalue = 1 as libc::c_int as dwarf_vma;
        }
        17 | 12 | 11 | 37 | 41 => {
            let mut amount_3: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_3 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_3,
                        5 as libc::c_int,
                    ),
                    amount_3 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_3 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_3: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_3 = 0 as libc::c_int as size_t;
            }
            if amount_3 > avail_3 {
                amount_3 = avail_3;
            }
            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_3 as libc::c_uint);
            }
            data = data.offset(amount_3 as isize);
        }
        39 | 43 => {
            let mut amount_4: size_t = 3 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_4 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_4,
                        5 as libc::c_int,
                    ),
                    amount_4 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_4 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_4: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_4 = 0 as libc::c_int as size_t;
            }
            if amount_4 > avail_4 {
                amount_4 = avail_4;
            }
            if amount_4 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_4 as libc::c_uint);
            }
            data = data.offset(amount_4 as isize);
        }
        18 | 5 | 38 | 42 => {
            let mut amount_5: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_5 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_5,
                        5 as libc::c_int,
                    ),
                    amount_5 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_5 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_5: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_5 = 0 as libc::c_int as size_t;
            }
            if amount_5 > avail_5 {
                amount_5 = avail_5;
            }
            if amount_5 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_5 as libc::c_uint);
            }
            data = data.offset(amount_5 as isize);
        }
        19 | 6 | 40 | 44 => {
            let mut amount_6: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_6 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_6,
                        5 as libc::c_int,
                    ),
                    amount_6 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_6 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_6: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_6 = 0 as libc::c_int as size_t;
            }
            if amount_6 > avail_6 {
                amount_6 = avail_6;
            }
            if amount_6 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_6 as libc::c_uint);
            }
            data = data.offset(amount_6 as isize);
        }
        13 => {
            let mut _val: dwarf_signed_vma = 0;
            let mut _len: libc::c_uint = 0;
            let mut _status: libc::c_int = 0;
            _val = read_leb128(data, end, 1 as libc::c_int != 0, &mut _len, &mut _status)
                as dwarf_signed_vma;
            data = data.offset(_len as isize);
            svalue = _val;
            if svalue != _val {
                _status |= 2 as libc::c_int;
            }
            report_leb_status(
                _status,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                1992 as libc::c_int as libc::c_ulong,
            );
            uvalue = svalue as dwarf_vma;
        }
        21 | 15 | 7938 | 26 | 7937 | 27 => {
            let mut _val_0: dwarf_vma = 0;
            let mut _len_0: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_0,
                &mut _status_0,
            );
            data = data.offset(_len_0 as isize);
            uvalue = _val_0;
            if uvalue != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                2002 as libc::c_int as libc::c_ulong,
            );
        }
        20 => {
            let mut amount_7: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_7 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_7,
                        5 as libc::c_int,
                    ),
                    amount_7 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_7 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_7: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_7 = 0 as libc::c_int as size_t;
            }
            if amount_7 > avail_7 {
                amount_7 = avail_7;
            }
            if amount_7 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_7 as libc::c_uint);
            }
            data = data.offset(amount_7 as isize);
        }
        7 | 32 => {
            inc = 8 as libc::c_int as dwarf_vma;
        }
        30 => {
            inc = 16 as libc::c_int as dwarf_vma;
        }
        8 => {
            inc = (strnlen(
                data as *mut libc::c_char,
                end.offset_from(data) as libc::c_long as size_t,
            ))
                .wrapping_add(1 as libc::c_int as libc::c_ulong);
        }
        9 | 24 => {
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            data = data.offset(_len_1 as isize);
            uvalue = _val_1;
            if uvalue != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                2024 as libc::c_int as libc::c_ulong,
            );
            inc = uvalue;
        }
        10 => {
            let mut amount_8: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_8 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_8,
                        5 as libc::c_int,
                    ),
                    amount_8 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_8 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_8: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_8 = 0 as libc::c_int as size_t;
            }
            if amount_8 > avail_8 {
                amount_8 = avail_8;
            }
            if amount_8 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_8 as libc::c_uint);
            }
            data = data.offset(amount_8 as isize);
            inc = uvalue;
        }
        3 => {
            let mut amount_9: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_9 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_9,
                        5 as libc::c_int,
                    ),
                    amount_9 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_9 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_9: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_9 = 0 as libc::c_int as size_t;
            }
            if amount_9 > avail_9 {
                amount_9 = avail_9;
            }
            if amount_9 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_9 as libc::c_uint);
            }
            data = data.offset(amount_9 as isize);
            inc = uvalue;
        }
        4 => {
            let mut amount_10: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_10 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_10,
                        5 as libc::c_int,
                    ),
                    amount_10 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_10 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_10: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_10 = 0 as libc::c_int as size_t;
            }
            if amount_10 > avail_10 {
                amount_10 = avail_10;
            }
            if amount_10 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect(
                        "non-null function pointer",
                    )(data, amount_10 as libc::c_uint);
            }
            data = data.offset(amount_10 as isize);
            inc = uvalue;
        }
        22 => {
            let mut _val_2: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_2: libc::c_int = 0;
            _val_2 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_2,
            );
            data = data.offset(_len_2 as isize);
            form = _val_2;
            if form != _val_2 {
                _status_2 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_2,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                2044 as libc::c_int as libc::c_ulong,
            );
            if form == DW_FORM_implicit_const as libc::c_int as libc::c_ulong {
                let mut _len_3: libc::c_uint = 0;
                read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_3,
                    0 as *mut libc::c_int,
                );
                data = data.offset(_len_3 as isize);
            }
            return skip_attr_bytes(
                form,
                data,
                end,
                pointer_size,
                offset_size,
                dwarf_version,
                value_return,
            );
        }
        _ => return 0 as *mut libc::c_uchar,
    }
    *value_return = uvalue;
    if inc <= end.offset_from(data) as libc::c_long as dwarf_vma {
        data = data.offset(inc as isize);
    } else {
        data = end;
    }
    return data;
}
unsafe extern "C" fn get_type_abbrev_from_form(
    mut form: libc::c_ulong,
    mut uvalue: libc::c_ulong,
    mut cu_offset: dwarf_vma,
    mut section: *const dwarf_section,
    mut abbrev_num_return: *mut libc::c_ulong,
    mut data_return: *mut *mut libc::c_uchar,
    mut map_return: *mut *mut abbrev_map,
) -> *mut abbrev_entry {
    let mut abbrev_number: libc::c_ulong = 0;
    let mut map: *mut abbrev_map = 0 as *mut abbrev_map;
    let mut entry: *mut abbrev_entry = 0 as *mut abbrev_entry;
    let mut data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if !abbrev_num_return.is_null() {
        *abbrev_num_return = 0 as libc::c_int as libc::c_ulong;
    }
    if !data_return.is_null() {
        *data_return = 0 as *mut libc::c_uchar;
    }
    match form {
        7968 | 32 => return 0 as *mut abbrev_entry,
        16 => {
            if uvalue >= (*section).size {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unable to resolve ref_addr form: uvalue %lx > section size %lx (%s)\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    uvalue,
                    (*section).size as libc::c_long,
                    (*section).name,
                );
                return 0 as *mut abbrev_entry;
            }
        }
        28 | 36 => {}
        17 | 18 | 19 | 20 | 21 => {
            if uvalue.wrapping_add(cu_offset) > (*section).size {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unable to resolve ref form: uvalue %lx + cu_offset %lx > section size %lx\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    uvalue,
                    cu_offset as libc::c_long,
                    (*section).size as libc::c_long,
                );
                return 0 as *mut abbrev_entry;
            }
            uvalue = uvalue.wrapping_add(cu_offset);
        }
        _ => {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unexpected form %lx encountered whilst finding abbreviation for type\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                form,
            );
            return 0 as *mut abbrev_entry;
        }
    }
    data = ((*section).start).offset(uvalue as isize);
    map = find_abbrev_map_by_offset(uvalue);
    if map.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to find abbreviations for CU offset %#lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            uvalue,
        );
        return 0 as *mut abbrev_entry;
    }
    if ((*map).list).is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Empty abbreviation list encountered for CU offset %lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            uvalue,
        );
        return 0 as *mut abbrev_entry;
    }
    if !map_return.is_null() {
        if form == DW_FORM_ref_addr as libc::c_int as libc::c_ulong {
            *map_return = map;
        } else {
            *map_return = 0 as *mut abbrev_map;
        }
    }
    let mut _val: dwarf_vma = 0;
    let mut _len: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(
        data,
        ((*section).start).offset((*section).size as isize),
        0 as libc::c_int != 0,
        &mut _len,
        &mut _status,
    );
    data = data.offset(_len as isize);
    abbrev_number = _val;
    if abbrev_number != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"dwarf.c\0" as *const u8 as *const libc::c_char,
        2147 as libc::c_int as libc::c_ulong,
    );
    entry = (*(*map).list).first_abbrev;
    while !entry.is_null() {
        if (*entry).number == abbrev_number {
            break;
        }
        entry = (*entry).next;
    }
    if !abbrev_num_return.is_null() {
        *abbrev_num_return = abbrev_number;
    }
    if !data_return.is_null() {
        *data_return = data;
    }
    if entry.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to find entry for abbreviation %lu\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            abbrev_number,
        );
    }
    return entry;
}
unsafe extern "C" fn get_type_signedness(
    mut entry: *mut abbrev_entry,
    mut section: *const dwarf_section,
    mut data: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut cu_offset: dwarf_vma,
    mut pointer_size: dwarf_vma,
    mut offset_size: dwarf_vma,
    mut dwarf_version: libc::c_int,
    mut is_signed: *mut bool,
    mut nesting: libc::c_uint,
) {
    let mut attr: *mut abbrev_attr = 0 as *mut abbrev_attr;
    *is_signed = 0 as libc::c_int != 0;
    if nesting > 20 as libc::c_int as libc::c_uint {
        return;
    }
    attr = (*entry).first_attr;
    while !attr.is_null() && (*attr).attribute != 0 {
        let mut orig_data: *mut libc::c_uchar = data;
        let mut uvalue: dwarf_vma = 0 as libc::c_int as dwarf_vma;
        data = skip_attr_bytes(
            (*attr).form,
            data,
            end,
            pointer_size,
            offset_size,
            dwarf_version,
            &mut uvalue,
        );
        if data.is_null() {
            return;
        }
        match (*attr).attribute {
            110 | 3 => {
                if do_wide != 0 {
                    if (*attr).form == DW_FORM_strp as libc::c_int as libc::c_ulong {
                        printf(
                            b", %s\0" as *const u8 as *const libc::c_char,
                            fetch_indirect_string(uvalue),
                        );
                    } else if (*attr).form
                        == DW_FORM_string as libc::c_int as libc::c_ulong
                    {
                        printf(
                            b", %.*s\0" as *const u8 as *const libc::c_char,
                            end.offset_from(orig_data) as libc::c_long as libc::c_int,
                            orig_data,
                        );
                    }
                }
            }
            73 => {
                let mut type_abbrev: *mut abbrev_entry = 0 as *mut abbrev_entry;
                let mut type_data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                let mut map: *mut abbrev_map = 0 as *mut abbrev_map;
                type_abbrev = get_type_abbrev_from_form(
                    (*attr).form,
                    uvalue,
                    cu_offset,
                    section,
                    0 as *mut libc::c_ulong,
                    &mut type_data,
                    &mut map,
                );
                if !type_abbrev.is_null() {
                    get_type_signedness(
                        type_abbrev,
                        section,
                        type_data,
                        if !map.is_null() {
                            ((*section).start).offset((*map).end as isize)
                        } else {
                            end
                        },
                        if !map.is_null() { (*map).start } else { cu_offset },
                        pointer_size,
                        offset_size,
                        dwarf_version,
                        is_signed,
                        nesting.wrapping_add(1 as libc::c_int as libc::c_uint),
                    );
                }
            }
            62 => {
                match uvalue {
                    1 | 2 | 7 | 8 | 14 => {
                        *is_signed = 0 as libc::c_int != 0;
                    }
                    3 | 4 | 5 | 6 | 9 | 15 | 13 | _ => {
                        *is_signed = 1 as libc::c_int != 0;
                    }
                }
            }
            _ => {}
        }
        attr = (*attr).next;
    }
}
unsafe extern "C" fn read_and_print_leb128(
    mut data: *mut libc::c_uchar,
    mut bytes_read: *mut libc::c_uint,
    mut end: *const libc::c_uchar,
    mut is_signed: bool,
) {
    let mut status: libc::c_int = 0;
    let mut val: dwarf_vma = read_leb128(data, end, is_signed, bytes_read, &mut status);
    if status != 0 as libc::c_int {
        report_leb_status(
            status,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            2281 as libc::c_int as libc::c_ulong,
        );
    } else {
        printf(
            b"%s\0" as *const u8 as *const libc::c_char,
            dwarf_vmatoa(
                if is_signed as libc::c_int != 0 {
                    b"d\0" as *const u8 as *const libc::c_char
                } else {
                    b"u\0" as *const u8 as *const libc::c_char
                },
                val,
            ),
        );
    };
}
unsafe extern "C" fn display_discr_list(
    mut form: libc::c_ulong,
    mut uvalue: dwarf_vma,
    mut data: *mut libc::c_uchar,
    mut end: *const libc::c_uchar,
    mut level: libc::c_int,
) {
    if uvalue == 0 as libc::c_int as libc::c_ulong {
        printf(b"[default]\0" as *const u8 as *const libc::c_char);
        return;
    }
    match form {
        9 | 10 | 3 | 4 => {
            data = data.offset(-(uvalue as isize));
        }
        _ => {
            printf(b"<corrupt>\n\0" as *const u8 as *const libc::c_char);
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"corrupt discr_list - not using a block form\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return;
        }
    }
    if uvalue < 2 as libc::c_int as libc::c_ulong {
        printf(b"<corrupt>\n\0" as *const u8 as *const libc::c_char);
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt discr_list - block not long enough\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return;
    }
    let mut is_signed: bool = if level > 0 as libc::c_int
        && level <= (1 as libc::c_int) << 8 as libc::c_int
    {
        level_type_signed[(level - 1 as libc::c_int) as usize] as libc::c_int
    } else {
        0 as libc::c_int
    } != 0;
    printf(b"(\0" as *const u8 as *const libc::c_char);
    while uvalue != 0 {
        let mut discriminant: libc::c_uchar = 0;
        let mut bytes_read: libc::c_uint = 0;
        let mut amount: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
        }
        let mut avail: size_t = end.offset_from(data) as libc::c_long as size_t;
        if data > end as *mut libc::c_uchar {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            discriminant = 0 as libc::c_int as libc::c_uchar;
        } else {
            discriminant = byte_get
                .expect("non-null function pointer")(data, amount as libc::c_uint)
                as libc::c_uchar;
        }
        data = data.offset(amount as isize);
        uvalue = uvalue.wrapping_sub(1);
        uvalue;
        if uvalue > 0 as libc::c_int as libc::c_ulong {} else {
            __assert_fail(
                b"uvalue > 0\0" as *const u8 as *const libc::c_char,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                2334 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 95],
                    &[libc::c_char; 95],
                >(
                    b"void display_discr_list(unsigned long, dwarf_vma, unsigned char *, const unsigned char *, int)\0",
                ))
                    .as_ptr(),
            );
        }
        'c_29282: {
            if uvalue > 0 as libc::c_int as libc::c_ulong {} else {
                __assert_fail(
                    b"uvalue > 0\0" as *const u8 as *const libc::c_char,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    2334 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 95],
                        &[libc::c_char; 95],
                    >(
                        b"void display_discr_list(unsigned long, dwarf_vma, unsigned char *, const unsigned char *, int)\0",
                    ))
                        .as_ptr(),
                );
            }
        };
        match discriminant as libc::c_int {
            0 => {
                printf(b"label \0" as *const u8 as *const libc::c_char);
                read_and_print_leb128(data, &mut bytes_read, end, is_signed);
                if bytes_read as libc::c_ulong <= uvalue
                    && bytes_read > 0 as libc::c_int as libc::c_uint
                {} else {
                    __assert_fail(
                        b"bytes_read <= uvalue && bytes_read > 0\0" as *const u8
                            as *const libc::c_char,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        2340 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 95],
                            &[libc::c_char; 95],
                        >(
                            b"void display_discr_list(unsigned long, dwarf_vma, unsigned char *, const unsigned char *, int)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_29209: {
                    if bytes_read as libc::c_ulong <= uvalue
                        && bytes_read > 0 as libc::c_int as libc::c_uint
                    {} else {
                        __assert_fail(
                            b"bytes_read <= uvalue && bytes_read > 0\0" as *const u8
                                as *const libc::c_char,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            2340 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 95],
                                &[libc::c_char; 95],
                            >(
                                b"void display_discr_list(unsigned long, dwarf_vma, unsigned char *, const unsigned char *, int)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
                uvalue = (uvalue as libc::c_ulong)
                    .wrapping_sub(bytes_read as libc::c_ulong) as dwarf_vma as dwarf_vma;
                data = data.offset(bytes_read as isize);
            }
            1 => {
                printf(b"range \0" as *const u8 as *const libc::c_char);
                read_and_print_leb128(data, &mut bytes_read, end, is_signed);
                if bytes_read as libc::c_ulong <= uvalue
                    && bytes_read > 0 as libc::c_int as libc::c_uint
                {} else {
                    __assert_fail(
                        b"bytes_read <= uvalue && bytes_read > 0\0" as *const u8
                            as *const libc::c_char,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        2348 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 95],
                            &[libc::c_char; 95],
                        >(
                            b"void display_discr_list(unsigned long, dwarf_vma, unsigned char *, const unsigned char *, int)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_29129: {
                    if bytes_read as libc::c_ulong <= uvalue
                        && bytes_read > 0 as libc::c_int as libc::c_uint
                    {} else {
                        __assert_fail(
                            b"bytes_read <= uvalue && bytes_read > 0\0" as *const u8
                                as *const libc::c_char,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            2348 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 95],
                                &[libc::c_char; 95],
                            >(
                                b"void display_discr_list(unsigned long, dwarf_vma, unsigned char *, const unsigned char *, int)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
                uvalue = (uvalue as libc::c_ulong)
                    .wrapping_sub(bytes_read as libc::c_ulong) as dwarf_vma as dwarf_vma;
                data = data.offset(bytes_read as isize);
                printf(b"..\0" as *const u8 as *const libc::c_char);
                read_and_print_leb128(data, &mut bytes_read, end, is_signed);
                if bytes_read as libc::c_ulong <= uvalue
                    && bytes_read > 0 as libc::c_int as libc::c_uint
                {} else {
                    __assert_fail(
                        b"bytes_read <= uvalue && bytes_read > 0\0" as *const u8
                            as *const libc::c_char,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        2354 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 95],
                            &[libc::c_char; 95],
                        >(
                            b"void display_discr_list(unsigned long, dwarf_vma, unsigned char *, const unsigned char *, int)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_28992: {
                    if bytes_read as libc::c_ulong <= uvalue
                        && bytes_read > 0 as libc::c_int as libc::c_uint
                    {} else {
                        __assert_fail(
                            b"bytes_read <= uvalue && bytes_read > 0\0" as *const u8
                                as *const libc::c_char,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            2354 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 95],
                                &[libc::c_char; 95],
                            >(
                                b"void display_discr_list(unsigned long, dwarf_vma, unsigned char *, const unsigned char *, int)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
                uvalue = (uvalue as libc::c_ulong)
                    .wrapping_sub(bytes_read as libc::c_ulong) as dwarf_vma as dwarf_vma;
                data = data.offset(bytes_read as isize);
            }
            _ => {
                printf(b"<corrupt>\n\0" as *const u8 as *const libc::c_char);
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"corrupt discr_list - unrecognized discriminant byte %#x\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    discriminant as libc::c_int,
                );
                return;
            }
        }
        if uvalue != 0 {
            printf(b", \0" as *const u8 as *const libc::c_char);
        }
    }
    if is_signed {
        printf(b")(signed)\0" as *const u8 as *const libc::c_char);
    } else {
        printf(b")(unsigned)\0" as *const u8 as *const libc::c_char);
    };
}
unsafe extern "C" fn read_and_display_attr_value(
    mut attribute: libc::c_ulong,
    mut form: libc::c_ulong,
    mut implicit_const: dwarf_signed_vma,
    mut start: *mut libc::c_uchar,
    mut data: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut cu_offset: dwarf_vma,
    mut pointer_size: dwarf_vma,
    mut offset_size: dwarf_vma,
    mut dwarf_version: libc::c_int,
    mut debug_info_p: *mut debug_info,
    mut do_loc: libc::c_int,
    mut section: *mut dwarf_section,
    mut this_set: *mut cu_tu_set,
    mut delimiter: libc::c_char,
    mut level: libc::c_int,
) -> *mut libc::c_uchar {
    let mut current_block: u64;
    let mut svalue: dwarf_signed_vma = 0;
    let mut uvalue: dwarf_vma = 0 as libc::c_int as dwarf_vma;
    let mut uvalue_hi: dwarf_vma = 0 as libc::c_int as dwarf_vma;
    let mut block_start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut orig_data: *mut libc::c_uchar = data;
    if data > end
        || data == end && form != DW_FORM_flag_present as libc::c_int as libc::c_ulong
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Corrupt attribute\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return data;
    }
    if do_wide != 0 && do_loc == 0 {
        let mut name: *const libc::c_char = get_FORM_name(form);
        if *name.offset(0 as libc::c_int as isize) as libc::c_int == 'D' as i32 {
            name = name.offset(8 as libc::c_int as isize);
        }
        printf(
            b"%c(%s)\0" as *const u8 as *const libc::c_char,
            delimiter as libc::c_int,
            name,
        );
    }
    match form {
        16 => {
            if dwarf_version == 2 as libc::c_int {
                let mut amount: size_t = pointer_size;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount,
                            5 as libc::c_int,
                        ),
                        amount as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail: size_t = end.offset_from(data) as libc::c_long as size_t;
                if data > end {
                    avail = 0 as libc::c_int as size_t;
                }
                if amount > avail {
                    amount = avail;
                }
                if amount == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount as libc::c_uint);
                }
                data = data.offset(amount as isize);
            } else if dwarf_version > 2 as libc::c_int {
                let mut amount_0: size_t = offset_size;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_0,
                            5 as libc::c_int,
                        ),
                        amount_0 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_0: size_t = end.offset_from(data) as libc::c_long
                    as size_t;
                if data > end {
                    avail_0 = 0 as libc::c_int as size_t;
                }
                if amount_0 > avail_0 {
                    amount_0 = avail_0;
                }
                if amount_0 == 0 as libc::c_int as libc::c_ulong {
                    uvalue = 0 as libc::c_int as dwarf_vma;
                } else {
                    uvalue = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount_0 as libc::c_uint);
                }
                data = data.offset(amount_0 as isize);
            } else {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Internal error: DW_FORM_ref_addr is not supported in DWARF version 1.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
        }
        1 => {
            let mut amount_1: size_t = pointer_size;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_1: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_1 as libc::c_uint);
            }
            data = data.offset(amount_1 as isize);
        }
        29 | 14 | 31 | 23 | 7968 | 7969 => {
            let mut amount_2: size_t = offset_size;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_2: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_2 as libc::c_uint);
            }
            data = data.offset(amount_2 as isize);
        }
        25 => {
            uvalue = 1 as libc::c_int as dwarf_vma;
        }
        17 | 12 | 11 | 37 | 41 => {
            let mut amount_3: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_3 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_3,
                        5 as libc::c_int,
                    ),
                    amount_3 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_3 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_3: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_3 = 0 as libc::c_int as size_t;
            }
            if amount_3 > avail_3 {
                amount_3 = avail_3;
            }
            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_3 as libc::c_uint);
            }
            data = data.offset(amount_3 as isize);
        }
        18 | 5 | 38 | 42 => {
            let mut amount_4: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_4 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_4,
                        5 as libc::c_int,
                    ),
                    amount_4 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_4 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_4: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_4 = 0 as libc::c_int as size_t;
            }
            if amount_4 > avail_4 {
                amount_4 = avail_4;
            }
            if amount_4 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_4 as libc::c_uint);
            }
            data = data.offset(amount_4 as isize);
        }
        39 | 43 => {
            let mut amount_5: size_t = 3 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_5 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_5,
                        5 as libc::c_int,
                    ),
                    amount_5 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_5 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_5: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_5 = 0 as libc::c_int as size_t;
            }
            if amount_5 > avail_5 {
                amount_5 = avail_5;
            }
            if amount_5 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_5 as libc::c_uint);
            }
            data = data.offset(amount_5 as isize);
        }
        28 | 19 | 6 | 40 | 44 => {
            let mut amount_6: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_6 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_6,
                        5 as libc::c_int,
                    ),
                    amount_6 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_6 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_6: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_6 = 0 as libc::c_int as size_t;
            }
            if amount_6 > avail_6 {
                amount_6 = avail_6;
            }
            if amount_6 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_6 as libc::c_uint);
            }
            data = data.offset(amount_6 as isize);
        }
        36 | 20 | 7 | 32 => {
            let mut amount_7: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_7 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_7,
                        5 as libc::c_int,
                    ),
                    amount_7 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_7 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_7: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_7 = 0 as libc::c_int as size_t;
            }
            if amount_7 > avail_7 {
                amount_7 = avail_7;
            }
            if amount_7 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_7 as libc::c_uint);
            }
            data = data.offset(amount_7 as isize);
        }
        30 => {
            let mut amount_8: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_8 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_8,
                        5 as libc::c_int,
                    ),
                    amount_8 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_8 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_8: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_8 = 0 as libc::c_int as size_t;
            }
            if amount_8 > avail_8 {
                amount_8 = avail_8;
            }
            if amount_8 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect("non-null function pointer")(data, amount_8 as libc::c_uint);
            }
            data = data.offset(amount_8 as isize);
            let mut amount_9: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_9 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_9,
                        5 as libc::c_int,
                    ),
                    amount_9 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_9 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_9: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_9 = 0 as libc::c_int as size_t;
            }
            if amount_9 > avail_9 {
                amount_9 = avail_9;
            }
            if amount_9 == 0 as libc::c_int as libc::c_ulong {
                uvalue_hi = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue_hi = byte_get
                    .expect("non-null function pointer")(data, amount_9 as libc::c_uint);
            }
            data = data.offset(amount_9 as isize);
            if byte_get
                != Some(
                    byte_get_little_endian
                        as unsafe extern "C" fn(
                            *const libc::c_uchar,
                            libc::c_uint,
                        ) -> elf_vma,
                )
            {
                let mut utmp: dwarf_vma = uvalue;
                uvalue = uvalue_hi;
                uvalue_hi = utmp;
            }
        }
        13 => {
            let mut _val: dwarf_signed_vma = 0;
            let mut _len: libc::c_uint = 0;
            let mut _status: libc::c_int = 0;
            _val = read_leb128(data, end, 1 as libc::c_int != 0, &mut _len, &mut _status)
                as dwarf_signed_vma;
            data = data.offset(_len as isize);
            svalue = _val;
            if svalue != _val {
                _status |= 2 as libc::c_int;
            }
            report_leb_status(
                _status,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                2495 as libc::c_int as libc::c_ulong,
            );
            uvalue = svalue as dwarf_vma;
        }
        7938 | 26 | 21 | 15 | 7937 | 27 => {
            let mut _val_0: dwarf_vma = 0;
            let mut _len_0: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_0,
                &mut _status_0,
            );
            data = data.offset(_len_0 as isize);
            uvalue = _val_0;
            if uvalue != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                2505 as libc::c_int as libc::c_ulong,
            );
        }
        22 => {
            let mut _val_1: dwarf_vma = 0;
            let mut _len_1: libc::c_uint = 0;
            let mut _status_1: libc::c_int = 0;
            _val_1 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_1,
                &mut _status_1,
            );
            data = data.offset(_len_1 as isize);
            form = _val_1;
            if form != _val_1 {
                _status_1 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_1,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                2509 as libc::c_int as libc::c_ulong,
            );
            if do_loc == 0 {
                printf(
                    b"%c%s\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    get_FORM_name(form),
                );
            }
            if form == DW_FORM_implicit_const as libc::c_int as libc::c_ulong {
                let mut _val_2: dwarf_signed_vma = 0;
                let mut _len_2: libc::c_uint = 0;
                let mut _status_2: libc::c_int = 0;
                _val_2 = read_leb128(
                    data,
                    end,
                    1 as libc::c_int != 0,
                    &mut _len_2,
                    &mut _status_2,
                ) as dwarf_signed_vma;
                data = data.offset(_len_2 as isize);
                implicit_const = _val_2;
                if implicit_const != _val_2 {
                    _status_2 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_2,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    2513 as libc::c_int as libc::c_ulong,
                );
            }
            return read_and_display_attr_value(
                attribute,
                form,
                implicit_const,
                start,
                data,
                end,
                cu_offset,
                pointer_size,
                offset_size,
                dwarf_version,
                debug_info_p,
                do_loc,
                section,
                this_set,
                delimiter,
                level,
            );
        }
        33 => {
            uvalue = implicit_const as dwarf_vma;
        }
        _ => {}
    }
    match form {
        16 => {
            if do_loc == 0 {
                printf(
                    b"%c<0x%s>\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            current_block = 14706934040029935270;
        }
        7968 => {
            if do_loc == 0 {
                if do_wide != 0 {
                    printf(
                        b"%c<0x%s>\0" as *const u8 as *const libc::c_char,
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                    );
                } else {
                    printf(
                        b"%c<alt 0x%s>\0" as *const u8 as *const libc::c_char,
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                    );
                }
            }
            current_block = 14706934040029935270;
        }
        17 | 18 | 19 | 28 | 21 => {
            if do_loc == 0 {
                printf(
                    b"%c<0x%s>\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        uvalue.wrapping_add(cu_offset),
                    ),
                );
            }
            current_block = 14706934040029935270;
        }
        6 | 1 | 23 => {
            if do_loc == 0 {
                printf(
                    b"%c0x%s\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            current_block = 14706934040029935270;
        }
        25 | 12 | 11 | 5 | 13 | 15 => {
            if do_loc == 0 {
                printf(
                    b"%c%s\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    dwarf_vmatoa(b"d\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            current_block = 14706934040029935270;
        }
        33 => {
            if do_loc == 0 {
                printf(
                    b"%c%s\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    dwarf_vmatoa(
                        b"d\0" as *const u8 as *const libc::c_char,
                        implicit_const as dwarf_vma,
                    ),
                );
            }
            current_block = 14706934040029935270;
        }
        36 | 20 | 7 => {
            if do_loc == 0 {
                let mut utmp_0: dwarf_vma = uvalue;
                if form == DW_FORM_ref8 as libc::c_int as libc::c_ulong {
                    utmp_0 = (utmp_0 as libc::c_ulong).wrapping_add(cu_offset)
                        as dwarf_vma as dwarf_vma;
                }
                printf(
                    b"%c0x%s\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, utmp_0),
                );
            }
            current_block = 14706934040029935270;
        }
        30 => {
            if do_loc == 0 {
                printf(
                    b" 0x%s%s\0" as *const u8 as *const libc::c_char,
                    if uvalue_hi == 0 as libc::c_int as libc::c_ulong {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            uvalue_hi,
                        )
                    },
                    dwarf_vmatoa_1(
                        b"x\0" as *const u8 as *const libc::c_char,
                        uvalue,
                        (if uvalue_hi == 0 as libc::c_int as libc::c_ulong {
                            0 as libc::c_int
                        } else {
                            8 as libc::c_int
                        }) as libc::c_uint,
                    ),
                );
            }
            current_block = 14706934040029935270;
        }
        8 => {
            if do_loc == 0 {
                printf(
                    b"%c%.*s\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    end.offset_from(data) as libc::c_long as libc::c_int,
                    data,
                );
            }
            data = data
                .offset(
                    strnlen(
                        data as *mut libc::c_char,
                        end.offset_from(data) as libc::c_long as size_t,
                    ) as isize,
                );
            if data < end {
                data = data.offset(1);
                data;
            }
            current_block = 14706934040029935270;
        }
        9 | 24 => {
            let mut _val_3: dwarf_vma = 0;
            let mut _len_3: libc::c_uint = 0;
            let mut _status_3: libc::c_int = 0;
            _val_3 = read_leb128(
                data,
                end,
                0 as libc::c_int != 0,
                &mut _len_3,
                &mut _status_3,
            );
            data = data.offset(_len_3 as isize);
            uvalue = _val_3;
            if uvalue != _val_3 {
                _status_3 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_3,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                2605 as libc::c_int as libc::c_ulong,
            );
            current_block = 12930012581268167828;
        }
        10 => {
            let mut amount_10: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_10 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_10,
                        5 as libc::c_int,
                    ),
                    amount_10 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_10 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_10: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_10 = 0 as libc::c_int as size_t;
            }
            if amount_10 > avail_10 {
                amount_10 = avail_10;
            }
            if amount_10 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect(
                        "non-null function pointer",
                    )(data, amount_10 as libc::c_uint);
            }
            data = data.offset(amount_10 as isize);
            current_block = 12930012581268167828;
        }
        3 => {
            let mut amount_11: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_11 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_11,
                        5 as libc::c_int,
                    ),
                    amount_11 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_11 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_11: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_11 = 0 as libc::c_int as size_t;
            }
            if amount_11 > avail_11 {
                amount_11 = avail_11;
            }
            if amount_11 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect(
                        "non-null function pointer",
                    )(data, amount_11 as libc::c_uint);
            }
            data = data.offset(amount_11 as isize);
            current_block = 12930012581268167828;
        }
        4 => {
            let mut amount_12: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_12 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_12,
                        5 as libc::c_int,
                    ),
                    amount_12 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_12 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_12: size_t = end.offset_from(data) as libc::c_long as size_t;
            if data > end {
                avail_12 = 0 as libc::c_int as size_t;
            }
            if amount_12 > avail_12 {
                amount_12 = avail_12;
            }
            if amount_12 == 0 as libc::c_int as libc::c_ulong {
                uvalue = 0 as libc::c_int as dwarf_vma;
            } else {
                uvalue = byte_get
                    .expect(
                        "non-null function pointer",
                    )(data, amount_12 as libc::c_uint);
            }
            data = data.offset(amount_12 as isize);
            current_block = 12930012581268167828;
        }
        14 => {
            if do_loc == 0 {
                if do_wide != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(offset: 0x%s): %s\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_indirect_string(uvalue),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(indirect string, offset: 0x%s): %s\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_indirect_string(uvalue),
                    );
                }
            }
            current_block = 14706934040029935270;
        }
        31 => {
            if do_loc == 0 {
                if do_wide != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(offset: 0x%s): %s\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_indirect_line_string(uvalue),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(indirect line string, offset: 0x%s): %s\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_indirect_line_string(uvalue),
                    );
                }
            }
            current_block = 14706934040029935270;
        }
        7938 | 26 | 37 | 38 | 39 | 40 => {
            if do_loc == 0 {
                let mut suffix: *const libc::c_char = strrchr(
                    (*section).name,
                    '.' as i32,
                );
                let mut dwo: bool = !suffix.is_null()
                    && strcmp(suffix, b".dwo\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int;
                if do_wide != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(offset: 0x%s): %s\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_indexed_string(uvalue, this_set, offset_size, dwo),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(indexed string: 0x%s): %s\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_indexed_string(uvalue, this_set, offset_size, dwo),
                    );
                }
            }
            current_block = 14706934040029935270;
        }
        7969 => {
            if do_loc == 0 {
                if do_wide != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(offset: 0x%s) %s\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_alt_indirect_string(uvalue),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(alt indirect string, offset: 0x%s) %s\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_alt_indirect_string(uvalue),
                    );
                }
            }
            current_block = 14706934040029935270;
        }
        22 => {
            current_block = 14706934040029935270;
        }
        32 => {
            if do_loc == 0 {
                printf(
                    b"%c%s: 0x%s\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    if do_wide != 0 {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b"signature\0" as *const u8 as *const libc::c_char
                    },
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                );
            }
            current_block = 14706934040029935270;
        }
        7937 | 27 | 41 | 42 | 43 | 44 => {
            if do_loc == 0 {
                let mut base: dwarf_vma = 0;
                let mut offset: dwarf_vma = 0;
                if debug_info_p.is_null() {
                    base = 0 as libc::c_int as dwarf_vma;
                } else if (*debug_info_p).addr_base
                    == -(1 as libc::c_int) as libc::c_uint as libc::c_ulong
                {
                    base = 0 as libc::c_int as dwarf_vma;
                } else {
                    base = (*debug_info_p).addr_base;
                }
                offset = base.wrapping_add(uvalue.wrapping_mul(pointer_size));
                if do_wide != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(index: 0x%s): %s\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_indexed_value(offset, pointer_size),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"%c(addr_index: 0x%s): %s\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        delimiter as libc::c_int,
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        fetch_indexed_value(offset, pointer_size),
                    );
                }
            }
            current_block = 14706934040029935270;
        }
        29 => {
            if do_loc == 0 {
                printf(
                    b"%c<0x%s>\0" as *const u8 as *const libc::c_char,
                    delimiter as libc::c_int,
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        uvalue.wrapping_add(cu_offset),
                    ),
                );
            }
            current_block = 14706934040029935270;
        }
        _ => {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Unrecognized form: 0x%lx\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                form,
            );
            current_block = 14706934040029935270;
        }
    }
    match current_block {
        12930012581268167828 => {
            block_start = data;
            if block_start >= end {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Block ends prematurely\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                uvalue = 0 as libc::c_int as dwarf_vma;
                block_start = end;
            }
            uvalue = check_uvalue(block_start, uvalue, end);
            if do_loc != 0 {
                data = block_start.offset(uvalue as isize);
            } else {
                data = display_block(block_start, uvalue, end, delimiter);
            }
        }
        _ => {}
    }
    if (do_loc != 0 || do_debug_loc != 0 || do_debug_ranges != 0)
        && num_debug_info_entries == 0 as libc::c_int as libc::c_uint
        && !debug_info_p.is_null()
    {
        let mut current_block_434: u64;
        match attribute {
            64 => {
                have_frame_base = 1 as libc::c_int;
                current_block_434 = 6591843457861946431;
            }
            2 | 8503 | 25 | 42 | 56 | 77 | 70 | 72 | 74 | 126 | 8465 | 134 | 8466 | 131
            | 8467 | 132 | 8468 => {
                current_block_434 = 6591843457861946431;
            }
            17 => {
                if need_base_address != 0 {
                    (*debug_info_p).base_address = uvalue;
                }
                current_block_434 = 10770532911212200937;
            }
            8499 | 115 => {
                (*debug_info_p).addr_base = uvalue;
                current_block_434 = 10770532911212200937;
            }
            8498 => {
                (*debug_info_p).ranges_base = uvalue;
                current_block_434 = 10770532911212200937;
            }
            85 => {
                if dwarf_version < 4 as libc::c_int
                    && (form == DW_FORM_data4 as libc::c_int as libc::c_ulong
                        || form == DW_FORM_data8 as libc::c_int as libc::c_ulong)
                    || form == DW_FORM_sec_offset as libc::c_int as libc::c_ulong
                {
                    let mut lmax_0: libc::c_uint = (*debug_info_p).max_range_lists;
                    let mut num_0: libc::c_uint = (*debug_info_p).num_range_lists;
                    if lmax_0 == 0 as libc::c_int as libc::c_uint || num_0 >= lmax_0 {
                        lmax_0 = lmax_0
                            .wrapping_add(1024 as libc::c_int as libc::c_uint);
                        (*debug_info_p)
                            .range_lists = xcrealloc(
                            (*debug_info_p).range_lists as *mut libc::c_void,
                            lmax_0 as size_t,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong,
                        ) as *mut dwarf_vma;
                        (*debug_info_p).max_range_lists = lmax_0;
                    }
                    *((*debug_info_p).range_lists).offset(num_0 as isize) = uvalue;
                    (*debug_info_p)
                        .num_range_lists = ((*debug_info_p).num_range_lists)
                        .wrapping_add(1);
                    (*debug_info_p).num_range_lists;
                }
                current_block_434 = 10770532911212200937;
            }
            8496 | 118 => {
                if need_dwo_info {
                    match form {
                        14 => {
                            add_dwo_name(
                                fetch_indirect_string(uvalue) as *const libc::c_char,
                                cu_offset,
                            );
                        }
                        7969 => {
                            add_dwo_name(fetch_alt_indirect_string(uvalue), cu_offset);
                        }
                        7938 | 26 | 37 | 38 | 39 | 40 => {
                            add_dwo_name(
                                fetch_indexed_string(
                                    uvalue,
                                    this_set,
                                    offset_size,
                                    0 as libc::c_int != 0,
                                ),
                                cu_offset,
                            );
                        }
                        8 => {
                            add_dwo_name(orig_data as *const libc::c_char, cu_offset);
                        }
                        _ => {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Unsupported form (%s) for attribute %s\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                get_FORM_name(form),
                                get_AT_name(attribute),
                            );
                        }
                    }
                }
                current_block_434 = 10770532911212200937;
            }
            27 => {
                if need_dwo_info {
                    match form {
                        14 => {
                            add_dwo_dir(
                                fetch_indirect_string(uvalue) as *const libc::c_char,
                                cu_offset,
                            );
                        }
                        7969 => {
                            add_dwo_dir(fetch_alt_indirect_string(uvalue), cu_offset);
                        }
                        31 => {
                            add_dwo_dir(
                                fetch_indirect_line_string(uvalue) as *const libc::c_char,
                                cu_offset,
                            );
                        }
                        7938 | 26 | 37 | 38 | 39 | 40 => {
                            add_dwo_dir(
                                fetch_indexed_string(
                                    uvalue,
                                    this_set,
                                    offset_size,
                                    0 as libc::c_int != 0,
                                ),
                                cu_offset,
                            );
                        }
                        8 => {
                            add_dwo_dir(orig_data as *const libc::c_char, cu_offset);
                        }
                        _ => {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Unsupported form (%s) for attribute %s\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                get_FORM_name(form),
                                get_AT_name(attribute),
                            );
                        }
                    }
                }
                current_block_434 = 10770532911212200937;
            }
            8497 => {
                if need_dwo_info {
                    match form {
                        7 => {
                            add_dwo_id(
                                data.offset(-(8 as libc::c_int as isize))
                                    as *const libc::c_char,
                                cu_offset,
                            );
                        }
                        _ => {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Unsupported form (%s) for attribute %s\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                get_FORM_name(form),
                                get_AT_name(attribute),
                            );
                        }
                    }
                }
                current_block_434 = 10770532911212200937;
            }
            _ => {
                current_block_434 = 10770532911212200937;
            }
        }
        match current_block_434 {
            6591843457861946431 => {
                if dwarf_version < 4 as libc::c_int
                    && (form == DW_FORM_data4 as libc::c_int as libc::c_ulong
                        || form == DW_FORM_data8 as libc::c_int as libc::c_ulong)
                    || form == DW_FORM_sec_offset as libc::c_int as libc::c_ulong
                {
                    let mut lmax: libc::c_uint = (*debug_info_p).max_loc_offsets;
                    let mut num: libc::c_uint = (*debug_info_p).num_loc_offsets;
                    if lmax == 0 as libc::c_int as libc::c_uint || num >= lmax {
                        lmax = lmax.wrapping_add(1024 as libc::c_int as libc::c_uint);
                        (*debug_info_p)
                            .loc_offsets = xcrealloc(
                            (*debug_info_p).loc_offsets as *mut libc::c_void,
                            lmax as size_t,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong,
                        ) as *mut dwarf_vma;
                        (*debug_info_p)
                            .loc_views = xcrealloc(
                            (*debug_info_p).loc_views as *mut libc::c_void,
                            lmax as size_t,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong,
                        ) as *mut dwarf_vma;
                        (*debug_info_p)
                            .have_frame_base = xcrealloc(
                            (*debug_info_p).have_frame_base as *mut libc::c_void,
                            lmax as size_t,
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ) as *mut libc::c_int;
                        (*debug_info_p).max_loc_offsets = lmax;
                    }
                    if !this_set.is_null() {
                        uvalue = (uvalue as libc::c_ulong)
                            .wrapping_add(
                                (*this_set)
                                    .section_offsets[DW_SECT_LOC as libc::c_int as usize],
                            ) as dwarf_vma as dwarf_vma;
                    }
                    *((*debug_info_p).have_frame_base)
                        .offset(num as isize) = have_frame_base;
                    if attribute != DW_AT_GNU_locviews as libc::c_int as libc::c_ulong {
                        if (*debug_info_p).num_loc_offsets
                            > (*debug_info_p).num_loc_views
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"More location offset attributes than DW_AT_GNU_locview attributes\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        } else {
                            *((*debug_info_p).loc_offsets).offset(num as isize) = uvalue;
                            (*debug_info_p)
                                .num_loc_offsets = ((*debug_info_p).num_loc_offsets)
                                .wrapping_add(1);
                            (*debug_info_p).num_loc_offsets;
                        }
                    } else {
                        if (*debug_info_p).num_loc_views <= num {} else {
                            __assert_fail(
                                b"debug_info_p->num_loc_views <= num\0" as *const u8
                                    as *const libc::c_char,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                2821 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 254],
                                    &[libc::c_char; 254],
                                >(
                                    b"unsigned char *read_and_display_attr_value(unsigned long, unsigned long, dwarf_signed_vma, unsigned char *, unsigned char *, unsigned char *, dwarf_vma, dwarf_vma, dwarf_vma, int, debug_info *, int, struct dwarf_section *, struct cu_tu_set *, char, int)\0",
                                ))
                                    .as_ptr(),
                            );
                        }
                        'c_36527: {
                            if (*debug_info_p).num_loc_views <= num {} else {
                                __assert_fail(
                                    b"debug_info_p->num_loc_views <= num\0" as *const u8
                                        as *const libc::c_char,
                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                    2821 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 254],
                                        &[libc::c_char; 254],
                                    >(
                                        b"unsigned char *read_and_display_attr_value(unsigned long, unsigned long, dwarf_signed_vma, unsigned char *, unsigned char *, unsigned char *, dwarf_vma, dwarf_vma, dwarf_vma, int, debug_info *, int, struct dwarf_section *, struct cu_tu_set *, char, int)\0",
                                    ))
                                        .as_ptr(),
                                );
                            }
                        };
                        num = (*debug_info_p).num_loc_views;
                        if num > (*debug_info_p).num_loc_offsets {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"More DW_AT_GNU_locview attributes than location offset attributes\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        } else {
                            *((*debug_info_p).loc_views).offset(num as isize) = uvalue;
                            (*debug_info_p)
                                .num_loc_views = ((*debug_info_p).num_loc_views)
                                .wrapping_add(1);
                            (*debug_info_p).num_loc_views;
                        }
                    }
                }
            }
            _ => {}
        }
    }
    if do_loc != 0 || attribute == 0 as libc::c_int as libc::c_ulong {
        return data;
    }
    let mut current_block_618: u64;
    match attribute {
        73 => {
            if level >= 0 as libc::c_int
                && level < (1 as libc::c_int) << 8 as libc::c_int
                && uvalue < end.offset_from(start) as libc::c_long as size_t
            {
                let mut is_signed: bool = 0 as libc::c_int != 0;
                let mut type_abbrev: *mut abbrev_entry = 0 as *mut abbrev_entry;
                let mut type_data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                let mut map: *mut abbrev_map = 0 as *mut abbrev_map;
                type_abbrev = get_type_abbrev_from_form(
                    form,
                    uvalue,
                    cu_offset,
                    section,
                    0 as *mut libc::c_ulong,
                    &mut type_data,
                    &mut map,
                );
                if !type_abbrev.is_null() {
                    get_type_signedness(
                        type_abbrev,
                        section,
                        type_data,
                        if !map.is_null() {
                            ((*section).start).offset((*map).end as isize)
                        } else {
                            end
                        },
                        if !map.is_null() { (*map).start } else { cu_offset },
                        pointer_size,
                        offset_size,
                        dwarf_version,
                        &mut is_signed,
                        0 as libc::c_int as libc::c_uint,
                    );
                }
                level_type_signed[level as usize] = is_signed;
            }
            current_block_618 = 708898072365708035;
        }
        32 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(not inlined)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(inlined)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(declared as inline but ignored)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                3 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(declared as inline and inlined)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  (Unknown inline attribute value: %s)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                    );
                }
            }
            current_block_618 = 708898072365708035;
        }
        19 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                1 => {
                    printf(b"(ANSI C)\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"(non-ANSI C)\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    printf(b"(Ada)\0" as *const u8 as *const libc::c_char);
                }
                4 => {
                    printf(b"(C++)\0" as *const u8 as *const libc::c_char);
                }
                5 => {
                    printf(b"(Cobol 74)\0" as *const u8 as *const libc::c_char);
                }
                6 => {
                    printf(b"(Cobol 85)\0" as *const u8 as *const libc::c_char);
                }
                7 => {
                    printf(b"(FORTRAN 77)\0" as *const u8 as *const libc::c_char);
                }
                8 => {
                    printf(b"(Fortran 90)\0" as *const u8 as *const libc::c_char);
                }
                9 => {
                    printf(b"(ANSI Pascal)\0" as *const u8 as *const libc::c_char);
                }
                10 => {
                    printf(b"(Modula 2)\0" as *const u8 as *const libc::c_char);
                }
                11 => {
                    printf(b"(Java)\0" as *const u8 as *const libc::c_char);
                }
                12 => {
                    printf(b"(ANSI C99)\0" as *const u8 as *const libc::c_char);
                }
                13 => {
                    printf(b"(ADA 95)\0" as *const u8 as *const libc::c_char);
                }
                14 => {
                    printf(b"(Fortran 95)\0" as *const u8 as *const libc::c_char);
                }
                15 => {
                    printf(b"(PLI)\0" as *const u8 as *const libc::c_char);
                }
                16 => {
                    printf(b"(Objective C)\0" as *const u8 as *const libc::c_char);
                }
                17 => {
                    printf(b"(Objective C++)\0" as *const u8 as *const libc::c_char);
                }
                18 => {
                    printf(
                        b"(Unified Parallel C)\0" as *const u8 as *const libc::c_char,
                    );
                }
                19 => {
                    printf(b"(D)\0" as *const u8 as *const libc::c_char);
                }
                20 => {
                    printf(b"(Python)\0" as *const u8 as *const libc::c_char);
                }
                21 => {
                    printf(b"(OpenCL)\0" as *const u8 as *const libc::c_char);
                }
                22 => {
                    printf(b"(Go)\0" as *const u8 as *const libc::c_char);
                }
                23 => {
                    printf(b"(Modula 3)\0" as *const u8 as *const libc::c_char);
                }
                24 => {
                    printf(b"(Haskell)\0" as *const u8 as *const libc::c_char);
                }
                25 => {
                    printf(b"(C++03)\0" as *const u8 as *const libc::c_char);
                }
                26 => {
                    printf(b"(C++11)\0" as *const u8 as *const libc::c_char);
                }
                27 => {
                    printf(b"(OCaml)\0" as *const u8 as *const libc::c_char);
                }
                28 => {
                    printf(b"(Rust)\0" as *const u8 as *const libc::c_char);
                }
                29 => {
                    printf(b"(C11)\0" as *const u8 as *const libc::c_char);
                }
                30 => {
                    printf(b"(Swift)\0" as *const u8 as *const libc::c_char);
                }
                31 => {
                    printf(b"(Julia)\0" as *const u8 as *const libc::c_char);
                }
                32 => {
                    printf(b"(Dylan)\0" as *const u8 as *const libc::c_char);
                }
                33 => {
                    printf(b"(C++14)\0" as *const u8 as *const libc::c_char);
                }
                34 => {
                    printf(b"(Fortran 03)\0" as *const u8 as *const libc::c_char);
                }
                35 => {
                    printf(b"(Fortran 08)\0" as *const u8 as *const libc::c_char);
                }
                36 => {
                    printf(b"(RenderScript)\0" as *const u8 as *const libc::c_char);
                }
                32769 => {
                    printf(b"(MIPS assembler)\0" as *const u8 as *const libc::c_char);
                }
                34661 => {
                    printf(
                        b"(Unified Parallel C)\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {
                    if uvalue >= DW_LANG_lo_user as libc::c_int as libc::c_ulong
                        && uvalue <= DW_LANG_hi_user as libc::c_int as libc::c_ulong
                    {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(implementation defined: %s)\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            dwarf_vmatoa(
                                b"x\0" as *const u8 as *const libc::c_char,
                                uvalue,
                            ),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(Unknown: %s)\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            dwarf_vmatoa(
                                b"x\0" as *const u8 as *const libc::c_char,
                                uvalue,
                            ),
                        );
                    }
                }
            }
            current_block_618 = 708898072365708035;
        }
        62 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                0 => {
                    printf(b"(void)\0" as *const u8 as *const libc::c_char);
                }
                1 => {
                    printf(b"(machine address)\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"(boolean)\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    printf(b"(complex float)\0" as *const u8 as *const libc::c_char);
                }
                4 => {
                    printf(b"(float)\0" as *const u8 as *const libc::c_char);
                }
                5 => {
                    printf(b"(signed)\0" as *const u8 as *const libc::c_char);
                }
                6 => {
                    printf(b"(signed char)\0" as *const u8 as *const libc::c_char);
                }
                7 => {
                    printf(b"(unsigned)\0" as *const u8 as *const libc::c_char);
                }
                8 => {
                    printf(b"(unsigned char)\0" as *const u8 as *const libc::c_char);
                }
                9 => {
                    printf(b"(imaginary float)\0" as *const u8 as *const libc::c_char);
                }
                15 => {
                    printf(b"(decimal float)\0" as *const u8 as *const libc::c_char);
                }
                10 => {
                    printf(b"(packed_decimal)\0" as *const u8 as *const libc::c_char);
                }
                11 => {
                    printf(b"(numeric_string)\0" as *const u8 as *const libc::c_char);
                }
                12 => {
                    printf(b"(edited)\0" as *const u8 as *const libc::c_char);
                }
                13 => {
                    printf(b"(signed_fixed)\0" as *const u8 as *const libc::c_char);
                }
                14 => {
                    printf(b"(unsigned_fixed)\0" as *const u8 as *const libc::c_char);
                }
                16 => {
                    printf(b"(unicode string)\0" as *const u8 as *const libc::c_char);
                }
                17 => {
                    printf(b"(UCS)\0" as *const u8 as *const libc::c_char);
                }
                18 => {
                    printf(b"(ASCII)\0" as *const u8 as *const libc::c_char);
                }
                128 => {
                    printf(b"(HP_float80)\0" as *const u8 as *const libc::c_char);
                }
                129 => {
                    printf(
                        b"(HP_complex_float80)\0" as *const u8 as *const libc::c_char,
                    );
                }
                130 => {
                    printf(b"(HP_float128)\0" as *const u8 as *const libc::c_char);
                }
                131 => {
                    printf(
                        b"(HP_complex_float128)\0" as *const u8 as *const libc::c_char,
                    );
                }
                132 => {
                    printf(b"(HP_floathpintel)\0" as *const u8 as *const libc::c_char);
                }
                133 => {
                    printf(
                        b"(HP_imaginary_float80)\0" as *const u8 as *const libc::c_char,
                    );
                }
                134 => {
                    printf(
                        b"(HP_imaginary_float128)\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {
                    if uvalue >= DW_ATE_lo_user as libc::c_int as libc::c_ulong
                        && uvalue <= DW_ATE_hi_user as libc::c_int as libc::c_ulong
                    {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(user defined type)\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(unknown type)\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
            }
            current_block_618 = 708898072365708035;
        }
        50 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                1 => {
                    printf(b"(public)\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"(protected)\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    printf(b"(private)\0" as *const u8 as *const libc::c_char);
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(unknown accessibility)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            current_block_618 = 708898072365708035;
        }
        23 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                1 => {
                    printf(b"(local)\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"(exported)\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    printf(b"(qualified)\0" as *const u8 as *const libc::c_char);
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(unknown visibility)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            current_block_618 = 708898072365708035;
        }
        101 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                0 => {
                    printf(b"(default)\0" as *const u8 as *const libc::c_char);
                }
                1 => {
                    printf(b"(big)\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"(little)\0" as *const u8 as *const libc::c_char);
                }
                _ => {
                    if uvalue >= DW_END_lo_user as libc::c_int as libc::c_ulong
                        && uvalue <= DW_END_hi_user as libc::c_int as libc::c_ulong
                    {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(user specified)\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(unknown endianity)\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
            }
            current_block_618 = 708898072365708035;
        }
        76 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                0 => {
                    printf(b"(none)\0" as *const u8 as *const libc::c_char);
                }
                1 => {
                    printf(b"(virtual)\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"(pure_virtual)\0" as *const u8 as *const libc::c_char);
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(unknown virtuality)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            current_block_618 = 708898072365708035;
        }
        66 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                0 => {
                    printf(b"(case_sensitive)\0" as *const u8 as *const libc::c_char);
                }
                1 => {
                    printf(b"(up_case)\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"(down_case)\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    printf(b"(case_insensitive)\0" as *const u8 as *const libc::c_char);
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(unknown case)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            current_block_618 = 708898072365708035;
        }
        54 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                1 => {
                    printf(b"(normal)\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    printf(b"(program)\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    printf(b"(nocall)\0" as *const u8 as *const libc::c_char);
                }
                4 => {
                    printf(b"(pass by ref)\0" as *const u8 as *const libc::c_char);
                }
                5 => {
                    printf(b"(pass by value)\0" as *const u8 as *const libc::c_char);
                }
                64 => {
                    printf(b"(Rensas SH)\0" as *const u8 as *const libc::c_char);
                }
                65 => {
                    printf(
                        b"(Borland fastcall i386)\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {
                    if uvalue >= DW_CC_lo_user as libc::c_int as libc::c_ulong
                        && uvalue <= DW_CC_hi_user as libc::c_int as libc::c_ulong
                    {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(user defined)\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(unknown convention)\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                }
            }
            current_block_618 = 708898072365708035;
        }
        9 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                255 | 18446744073709551615 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(undefined)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                0 => {
                    printf(b"(row major)\0" as *const u8 as *const libc::c_char);
                }
                1 => {
                    printf(b"(column major)\0" as *const u8 as *const libc::c_char);
                }
                _ => {}
            }
            current_block_618 = 708898072365708035;
        }
        94 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(unsigned)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(leading overpunch)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                3 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(trailing overpunch)\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                4 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(leading separate)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                5 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(trailing separate)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(unrecognised)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            current_block_618 = 708898072365708035;
        }
        139 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            match uvalue {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(no)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                1 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(in class)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                2 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(out of class)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                _ => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(unrecognised)\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
            current_block_618 = 708898072365708035;
        }
        61 => {
            printf(b"\t\0" as *const u8 as *const libc::c_char);
            display_discr_list(form, uvalue, data, end, level);
            current_block_618 = 708898072365708035;
        }
        64 => {
            have_frame_base = 1 as libc::c_int;
            current_block_618 = 5967075976693087900;
        }
        2 | 25 | 42 | 56 | 77 | 70 | 72 | 74 | 126 | 8465 | 134 | 8466 | 131 | 8467 | 132
        | 8468 => {
            current_block_618 = 5967075976693087900;
        }
        78 | 79 | 80 | 81 | 47 | 34 => {
            current_block_618 = 15294025108016136422;
        }
        107 | 11 | 13 | 112 | 111 | 46 => {
            if form == DW_FORM_exprloc as libc::c_int as libc::c_ulong {
                printf(b"\t(\0" as *const u8 as *const libc::c_char);
                decode_location_expression(
                    block_start,
                    pointer_size as libc::c_uint,
                    offset_size as libc::c_uint,
                    dwarf_version,
                    uvalue,
                    cu_offset,
                    section,
                );
                printf(b")\0" as *const u8 as *const libc::c_char);
            }
            current_block_618 = 708898072365708035;
        }
        24 => {
            let mut abbrev_number: libc::c_ulong = 0;
            let mut entry: *mut abbrev_entry = 0 as *mut abbrev_entry;
            entry = get_type_abbrev_from_form(
                form,
                uvalue,
                cu_offset,
                section,
                &mut abbrev_number,
                0 as *mut *mut libc::c_uchar,
                0 as *mut *mut abbrev_map,
            );
            if entry.is_null() {
                if form != DW_FORM_GNU_ref_alt as libc::c_int as libc::c_ulong {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Offset %s used as value for DW_AT_import attribute of DIE at offset 0x%lx is too big.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, uvalue),
                        orig_data.offset_from((*section).start) as libc::c_long
                            as libc::c_ulong,
                    );
                }
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"\t[Abbrev Number: %ld\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abbrev_number,
                );
                printf(
                    b" (%s)\0" as *const u8 as *const libc::c_char,
                    get_TAG_name((*entry).tag),
                );
                printf(b"]\0" as *const u8 as *const libc::c_char);
            }
            current_block_618 = 708898072365708035;
        }
        _ => {
            current_block_618 = 708898072365708035;
        }
    }
    match current_block_618 {
        5967075976693087900 => {
            if dwarf_version < 4 as libc::c_int
                && (form == DW_FORM_data4 as libc::c_int as libc::c_ulong
                    || form == DW_FORM_data8 as libc::c_int as libc::c_ulong)
                || form == DW_FORM_sec_offset as libc::c_int as libc::c_ulong
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" (location list)\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            current_block_618 = 15294025108016136422;
        }
        _ => {}
    }
    match current_block_618 {
        15294025108016136422 => {
            if !block_start.is_null() {
                let mut need_frame_base: libc::c_int = 0;
                printf(b"\t(\0" as *const u8 as *const libc::c_char);
                need_frame_base = decode_location_expression(
                    block_start,
                    pointer_size as libc::c_uint,
                    offset_size as libc::c_uint,
                    dwarf_version,
                    uvalue,
                    cu_offset,
                    section,
                );
                printf(b")\0" as *const u8 as *const libc::c_char);
                if need_frame_base != 0 && have_frame_base == 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" [without DW_AT_frame_base]\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
            }
        }
        _ => {}
    }
    return data;
}
unsafe extern "C" fn read_and_display_attr(
    mut attribute: libc::c_ulong,
    mut form: libc::c_ulong,
    mut implicit_const: dwarf_signed_vma,
    mut start: *mut libc::c_uchar,
    mut data: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut cu_offset: dwarf_vma,
    mut pointer_size: dwarf_vma,
    mut offset_size: dwarf_vma,
    mut dwarf_version: libc::c_int,
    mut debug_info_p: *mut debug_info,
    mut do_loc: libc::c_int,
    mut section: *mut dwarf_section,
    mut this_set: *mut cu_tu_set,
    mut level: libc::c_int,
) -> *mut libc::c_uchar {
    if do_loc == 0 {
        printf(
            b"   %-18s:\0" as *const u8 as *const libc::c_char,
            get_AT_name(attribute),
        );
    }
    data = read_and_display_attr_value(
        attribute,
        form,
        implicit_const,
        start,
        data,
        end,
        cu_offset,
        pointer_size,
        offset_size,
        dwarf_version,
        debug_info_p,
        do_loc,
        section,
        this_set,
        ' ' as i32 as libc::c_char,
        level,
    );
    if do_loc == 0 {
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    return data;
}
unsafe extern "C" fn load_debug_section_with_follow(
    mut sec_enum: dwarf_section_display_enum,
    mut handle: *mut libc::c_void,
) -> bool {
    if load_debug_section(sec_enum, handle) {
        if ((*debug_displays.as_mut_ptr().offset(sec_enum as isize)).section.filename)
            .is_null()
        {
            let mut i: *mut separate_info = 0 as *mut separate_info;
            i = first_separate_info;
            while !i.is_null() {
                if (*i).handle == handle {
                    let ref mut fresh11 = (*debug_displays
                        .as_mut_ptr()
                        .offset(sec_enum as isize))
                        .section
                        .filename;
                    *fresh11 = (*i).filename;
                    break;
                } else {
                    i = (*i).next;
                }
            }
        }
        return 1 as libc::c_int != 0;
    }
    if do_follow_links != 0 {
        let mut i_0: *mut separate_info = 0 as *mut separate_info;
        i_0 = first_separate_info;
        while !i_0.is_null() {
            if load_debug_section(sec_enum, (*i_0).handle) {
                let ref mut fresh12 = (*debug_displays
                    .as_mut_ptr()
                    .offset(sec_enum as isize))
                    .section
                    .filename;
                *fresh12 = (*i_0).filename;
                return 1 as libc::c_int != 0;
            }
            i_0 = (*i_0).next;
        }
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn introduce(mut section: *mut dwarf_section, mut raw: bool) {
    if raw {
        if do_follow_links != 0 && !((*section).filename).is_null() {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Raw dump of debug contents of section %s (loaded from %s):\n\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                (*section).filename,
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Raw dump of debug contents of section %s:\n\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
            );
        }
    } else if do_follow_links != 0 && !((*section).filename).is_null() {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Contents of the %s section (loaded from %s):\n\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
            (*section).filename,
        );
    } else {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Contents of the %s section:\n\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
    };
}
unsafe extern "C" fn process_debug_info(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
    mut abbrev_sec: dwarf_section_display_enum,
    mut do_loc: bool,
    mut do_types: bool,
) -> bool {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = start.offset((*section).size as isize);
    let mut section_begin: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut unit: libc::c_uint = 0;
    let mut num_units: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    section_begin = start;
    num_units = 0 as libc::c_int as libc::c_uint;
    while section_begin < end {
        let mut length: dwarf_vma = 0;
        let mut amount: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = end.offset_from(section_begin) as libc::c_long as size_t;
        if section_begin > end {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            length = 0 as libc::c_int as dwarf_vma;
        } else {
            length = byte_get
                .expect(
                    "non-null function pointer",
                )(section_begin, amount as libc::c_uint);
        }
        section_begin = section_begin.offset(amount as isize);
        if length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_0: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_0,
                        5 as libc::c_int,
                    ),
                    amount_0 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_0: size_t = end.offset_from(section_begin) as libc::c_long
                as size_t;
            if section_begin > end {
                avail_0 = 0 as libc::c_int as size_t;
            }
            if amount_0 > avail_0 {
                amount_0 = avail_0;
            }
            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                length = 0 as libc::c_int as dwarf_vma;
            } else {
                length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(section_begin, amount_0 as libc::c_uint);
            }
            section_begin = section_begin.offset(amount_0 as isize);
        } else if length >= 0xfffffff0 as libc::c_uint as libc::c_ulong
            && length < 0xffffffff as libc::c_uint as libc::c_ulong
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Reserved length value (0x%s) found in section %s\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, length),
                (*section).name,
            );
            return 0 as libc::c_int != 0;
        }
        if length > end.offset_from(section_begin) as libc::c_long as size_t {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Corrupt unit length (0x%s) found in section %s\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, length),
                (*section).name,
            );
            return 0 as libc::c_int != 0;
        }
        section_begin = section_begin.offset(length as isize);
        num_units = num_units.wrapping_add(1);
        num_units;
    }
    if num_units == 0 as libc::c_int as libc::c_uint {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"No comp units in %s section ?\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int != 0;
    }
    if (do_loc as libc::c_int != 0 || do_debug_loc != 0 || do_debug_ranges != 0)
        && num_debug_info_entries == 0 as libc::c_int as libc::c_uint && !do_types
    {
        debug_information = cmalloc(
            num_units as size_t,
            ::core::mem::size_of::<debug_info>() as libc::c_ulong,
        ) as *mut debug_info;
        if debug_information.is_null() {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Not enough memory for a debug info array of %u entries\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                num_units,
            );
            num_debug_info_entries = 0 as libc::c_int as libc::c_uint;
            alloc_num_debug_info_entries = num_debug_info_entries;
            return 0 as libc::c_int != 0;
        }
        memset(
            debug_information as *mut libc::c_void,
            0 as libc::c_int,
            (num_units as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<debug_info>() as libc::c_ulong),
        );
        alloc_num_debug_info_entries = num_units;
    }
    if !do_loc {
        load_debug_section_with_follow(str, file);
        load_debug_section_with_follow(line_str, file);
        load_debug_section_with_follow(str_dwo, file);
        load_debug_section_with_follow(str_index, file);
        load_debug_section_with_follow(str_index_dwo, file);
        load_debug_section_with_follow(debug_addr, file);
    }
    load_debug_section_with_follow(abbrev_sec, file);
    if ((*debug_displays.as_mut_ptr().offset(abbrev_sec as isize)).section.start)
        .is_null()
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to locate %s section!\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*debug_displays.as_mut_ptr().offset(abbrev_sec as isize))
                .section
                .uncompressed_name,
        );
        return 0 as libc::c_int != 0;
    }
    if !do_loc && dwarf_start_die == 0 as libc::c_int as libc::c_ulong {
        introduce(section, 0 as libc::c_int != 0);
    }
    free_all_abbrevs();
    free(cu_abbrev_map as *mut libc::c_void);
    cu_abbrev_map = 0 as *mut abbrev_map;
    next_free_abbrev_map_entry = 0 as libc::c_int as libc::c_ulong;
    section_begin = start;
    while start < end {
        let mut compunit: DWARF2_Internal_CompUnit = DWARF2_Internal_CompUnit {
            cu_length: 0,
            cu_version: 0,
            cu_abbrev_offset: 0,
            cu_pointer_size: 0,
            cu_unit_type: 0 as dwarf_unit_type,
        };
        let mut hdrptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut abbrev_base: dwarf_vma = 0;
        let mut abbrev_size: size_t = 0;
        let mut cu_offset: dwarf_vma = 0;
        let mut offset_size: libc::c_uint = 0;
        let mut this_set: *mut cu_tu_set = 0 as *mut cu_tu_set;
        let mut list: *mut abbrev_list = 0 as *mut abbrev_list;
        let mut end_cu: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        hdrptr = start;
        cu_offset = start.offset_from(section_begin) as libc::c_long as dwarf_vma;
        let mut amount_1: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_1 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_1,
                    5 as libc::c_int,
                ),
                amount_1 as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount_1 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail_1: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_1 = 0 as libc::c_int as size_t;
        }
        if amount_1 > avail_1 {
            amount_1 = avail_1;
        }
        if amount_1 == 0 as libc::c_int as libc::c_ulong {
            compunit.cu_length = 0 as libc::c_int as dwarf_vma;
        } else {
            compunit
                .cu_length = byte_get
                .expect("non-null function pointer")(hdrptr, amount_1 as libc::c_uint);
        }
        hdrptr = hdrptr.offset(amount_1 as isize);
        if compunit.cu_length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_2: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_2: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
            if hdrptr > end {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                compunit.cu_length = 0 as libc::c_int as dwarf_vma;
            } else {
                compunit
                    .cu_length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_2 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_2 as isize);
            offset_size = 8 as libc::c_int as libc::c_uint;
        } else {
            offset_size = 4 as libc::c_int as libc::c_uint;
        }
        end_cu = hdrptr.offset(compunit.cu_length as isize);
        let mut amount_3: size_t = 2 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong) < amount_3 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_3,
                    5 as libc::c_int,
                ),
                amount_3 as libc::c_int,
                ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong as libc::c_int,
            );
            amount_3 = ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong;
        }
        let mut avail_3: size_t = end_cu.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end_cu {
            avail_3 = 0 as libc::c_int as size_t;
        }
        if amount_3 > avail_3 {
            amount_3 = avail_3;
        }
        if amount_3 == 0 as libc::c_int as libc::c_ulong {
            compunit.cu_version = 0 as libc::c_int as libc::c_ushort;
        } else {
            compunit
                .cu_version = byte_get
                .expect("non-null function pointer")(hdrptr, amount_3 as libc::c_uint)
                as libc::c_ushort;
        }
        hdrptr = hdrptr.offset(amount_3 as isize);
        this_set = find_cu_tu_set_v2(cu_offset, do_types as libc::c_int);
        if (compunit.cu_version as libc::c_int) < 5 as libc::c_int {
            compunit.cu_unit_type = DW_UT_compile;
            compunit.cu_pointer_size = -(1 as libc::c_int) as libc::c_uchar;
        } else {
            let mut amount_4: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_unit_type>() as libc::c_ulong) < amount_4 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_4,
                        5 as libc::c_int,
                    ),
                    amount_4 as libc::c_int,
                    ::core::mem::size_of::<dwarf_unit_type>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_4 = ::core::mem::size_of::<dwarf_unit_type>() as libc::c_ulong;
            }
            let mut avail_4: size_t = end_cu.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > end_cu {
                avail_4 = 0 as libc::c_int as size_t;
            }
            if amount_4 > avail_4 {
                amount_4 = avail_4;
            }
            if amount_4 == 0 as libc::c_int as libc::c_ulong {
                compunit.cu_unit_type = 0 as dwarf_unit_type;
            } else {
                compunit
                    .cu_unit_type = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_4 as libc::c_uint) as dwarf_unit_type;
            }
            hdrptr = hdrptr.offset(amount_4 as isize);
            do_types = compunit.cu_unit_type as libc::c_uint
                == DW_UT_type as libc::c_int as libc::c_uint;
            let mut amount_5: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_5 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_5,
                        5 as libc::c_int,
                    ),
                    amount_5 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_5 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
            }
            let mut avail_5: size_t = end_cu.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > end_cu {
                avail_5 = 0 as libc::c_int as size_t;
            }
            if amount_5 > avail_5 {
                amount_5 = avail_5;
            }
            if amount_5 == 0 as libc::c_int as libc::c_ulong {
                compunit.cu_pointer_size = 0 as libc::c_int as libc::c_uchar;
            } else {
                compunit
                    .cu_pointer_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_5 as libc::c_uint) as libc::c_uchar;
            }
            hdrptr = hdrptr.offset(amount_5 as isize);
        }
        let mut amount_6: size_t = offset_size as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_6 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_6,
                    5 as libc::c_int,
                ),
                amount_6 as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount_6 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail_6: size_t = end_cu.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end_cu {
            avail_6 = 0 as libc::c_int as size_t;
        }
        if amount_6 > avail_6 {
            amount_6 = avail_6;
        }
        if amount_6 == 0 as libc::c_int as libc::c_ulong {
            compunit.cu_abbrev_offset = 0 as libc::c_int as dwarf_vma;
        } else {
            compunit
                .cu_abbrev_offset = byte_get
                .expect("non-null function pointer")(hdrptr, amount_6 as libc::c_uint);
        }
        hdrptr = hdrptr.offset(amount_6 as isize);
        if compunit.cu_unit_type as libc::c_uint
            == DW_UT_split_compile as libc::c_int as libc::c_uint
            || compunit.cu_unit_type as libc::c_uint
                == DW_UT_skeleton as libc::c_int as libc::c_uint
        {
            let mut dwo_id: uint64_t = 0;
            let mut amount_7: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint64_t>() as libc::c_ulong) < amount_7 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_7,
                        5 as libc::c_int,
                    ),
                    amount_7 as libc::c_int,
                    ::core::mem::size_of::<uint64_t>() as libc::c_ulong as libc::c_int,
                );
                amount_7 = ::core::mem::size_of::<uint64_t>() as libc::c_ulong;
            }
            let mut avail_7: size_t = end_cu.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > end_cu {
                avail_7 = 0 as libc::c_int as size_t;
            }
            if amount_7 > avail_7 {
                amount_7 = avail_7;
            }
            if amount_7 == 0 as libc::c_int as libc::c_ulong {
                dwo_id = 0 as libc::c_int as uint64_t;
            } else {
                dwo_id = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_7 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_7 as isize);
        }
        if this_set.is_null() {
            abbrev_base = 0 as libc::c_int as dwarf_vma;
            abbrev_size = (*debug_displays.as_mut_ptr().offset(abbrev_sec as isize))
                .section
                .size;
        } else {
            abbrev_base = (*this_set)
                .section_offsets[DW_SECT_ABBREV as libc::c_int as usize];
            abbrev_size = (*this_set)
                .section_sizes[DW_SECT_ABBREV as libc::c_int as usize];
        }
        list = find_abbrev_list_by_abbrev_offset(abbrev_base, compunit.cu_abbrev_offset);
        if list.is_null() {
            let mut next: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            list = new_abbrev_list(abbrev_base, compunit.cu_abbrev_offset);
            next = process_abbrev_set(
                &mut (*debug_displays.as_mut_ptr().offset(abbrev_sec as isize)).section,
                abbrev_base,
                abbrev_size,
                compunit.cu_abbrev_offset,
                list,
            );
            (*list).start_of_next_abbrevs = next;
        }
        start = end_cu;
        record_abbrev_list_for_cu(
            cu_offset,
            start.offset_from(section_begin) as libc::c_long as dwarf_vma,
            list,
        );
    }
    start = section_begin;
    unit = 0 as libc::c_int as libc::c_uint;
    while start < end {
        let mut compunit_0: DWARF2_Internal_CompUnit = DWARF2_Internal_CompUnit {
            cu_length: 0,
            cu_version: 0,
            cu_abbrev_offset: 0,
            cu_pointer_size: 0,
            cu_unit_type: 0 as dwarf_unit_type,
        };
        let mut hdrptr_0: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut tags: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut level: libc::c_int = 0;
        let mut last_level: libc::c_int = 0;
        let mut saved_level: libc::c_int = 0;
        let mut cu_offset_0: dwarf_vma = 0;
        let mut offset_size_0: libc::c_uint = 0;
        let mut signature: dwarf_vma = 0 as libc::c_int as dwarf_vma;
        let mut type_offset: dwarf_vma = 0 as libc::c_int as dwarf_vma;
        let mut this_set_0: *mut cu_tu_set = 0 as *mut cu_tu_set;
        let mut abbrev_base_0: dwarf_vma = 0;
        let mut abbrev_size_0: size_t = 0;
        let mut list_0: *mut abbrev_list = 0 as *mut abbrev_list;
        let mut end_cu_0: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        hdrptr_0 = start;
        cu_offset_0 = start.offset_from(section_begin) as libc::c_long as dwarf_vma;
        let mut amount_8: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_8 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_8,
                    5 as libc::c_int,
                ),
                amount_8 as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount_8 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail_8: size_t = end.offset_from(hdrptr_0) as libc::c_long as size_t;
        if hdrptr_0 > end {
            avail_8 = 0 as libc::c_int as size_t;
        }
        if amount_8 > avail_8 {
            amount_8 = avail_8;
        }
        if amount_8 == 0 as libc::c_int as libc::c_ulong {
            compunit_0.cu_length = 0 as libc::c_int as dwarf_vma;
        } else {
            compunit_0
                .cu_length = byte_get
                .expect("non-null function pointer")(hdrptr_0, amount_8 as libc::c_uint);
        }
        hdrptr_0 = hdrptr_0.offset(amount_8 as isize);
        if compunit_0.cu_length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_9: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_9 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_9,
                        5 as libc::c_int,
                    ),
                    amount_9 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_9 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_9: size_t = end.offset_from(hdrptr_0) as libc::c_long
                as size_t;
            if hdrptr_0 > end {
                avail_9 = 0 as libc::c_int as size_t;
            }
            if amount_9 > avail_9 {
                amount_9 = avail_9;
            }
            if amount_9 == 0 as libc::c_int as libc::c_ulong {
                compunit_0.cu_length = 0 as libc::c_int as dwarf_vma;
            } else {
                compunit_0
                    .cu_length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr_0, amount_9 as libc::c_uint);
            }
            hdrptr_0 = hdrptr_0.offset(amount_9 as isize);
            offset_size_0 = 8 as libc::c_int as libc::c_uint;
        } else {
            offset_size_0 = 4 as libc::c_int as libc::c_uint;
        }
        end_cu_0 = hdrptr_0.offset(compunit_0.cu_length as isize);
        let mut amount_10: size_t = 2 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong) < amount_10 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_10,
                    5 as libc::c_int,
                ),
                amount_10 as libc::c_int,
                ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong as libc::c_int,
            );
            amount_10 = ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong;
        }
        let mut avail_10: size_t = end_cu_0.offset_from(hdrptr_0) as libc::c_long
            as size_t;
        if hdrptr_0 > end_cu_0 {
            avail_10 = 0 as libc::c_int as size_t;
        }
        if amount_10 > avail_10 {
            amount_10 = avail_10;
        }
        if amount_10 == 0 as libc::c_int as libc::c_ulong {
            compunit_0.cu_version = 0 as libc::c_int as libc::c_ushort;
        } else {
            compunit_0
                .cu_version = byte_get
                .expect("non-null function pointer")(hdrptr_0, amount_10 as libc::c_uint)
                as libc::c_ushort;
        }
        hdrptr_0 = hdrptr_0.offset(amount_10 as isize);
        this_set_0 = find_cu_tu_set_v2(cu_offset_0, do_types as libc::c_int);
        if (compunit_0.cu_version as libc::c_int) < 5 as libc::c_int {
            compunit_0.cu_unit_type = DW_UT_compile;
            compunit_0.cu_pointer_size = -(1 as libc::c_int) as libc::c_uchar;
        } else {
            let mut amount_11: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_unit_type>() as libc::c_ulong) < amount_11 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_11,
                        5 as libc::c_int,
                    ),
                    amount_11 as libc::c_int,
                    ::core::mem::size_of::<dwarf_unit_type>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_11 = ::core::mem::size_of::<dwarf_unit_type>() as libc::c_ulong;
            }
            let mut avail_11: size_t = end_cu_0.offset_from(hdrptr_0) as libc::c_long
                as size_t;
            if hdrptr_0 > end_cu_0 {
                avail_11 = 0 as libc::c_int as size_t;
            }
            if amount_11 > avail_11 {
                amount_11 = avail_11;
            }
            if amount_11 == 0 as libc::c_int as libc::c_ulong {
                compunit_0.cu_unit_type = 0 as dwarf_unit_type;
            } else {
                compunit_0
                    .cu_unit_type = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr_0, amount_11 as libc::c_uint) as dwarf_unit_type;
            }
            hdrptr_0 = hdrptr_0.offset(amount_11 as isize);
            do_types = compunit_0.cu_unit_type as libc::c_uint
                == DW_UT_type as libc::c_int as libc::c_uint;
            let mut amount_12: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_12 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_12,
                        5 as libc::c_int,
                    ),
                    amount_12 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_12 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
            }
            let mut avail_12: size_t = end_cu_0.offset_from(hdrptr_0) as libc::c_long
                as size_t;
            if hdrptr_0 > end_cu_0 {
                avail_12 = 0 as libc::c_int as size_t;
            }
            if amount_12 > avail_12 {
                amount_12 = avail_12;
            }
            if amount_12 == 0 as libc::c_int as libc::c_ulong {
                compunit_0.cu_pointer_size = 0 as libc::c_int as libc::c_uchar;
            } else {
                compunit_0
                    .cu_pointer_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr_0, amount_12 as libc::c_uint) as libc::c_uchar;
            }
            hdrptr_0 = hdrptr_0.offset(amount_12 as isize);
        }
        let mut amount_13: size_t = offset_size_0 as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_13 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_13,
                    5 as libc::c_int,
                ),
                amount_13 as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount_13 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail_13: size_t = end_cu_0.offset_from(hdrptr_0) as libc::c_long
            as size_t;
        if hdrptr_0 > end_cu_0 {
            avail_13 = 0 as libc::c_int as size_t;
        }
        if amount_13 > avail_13 {
            amount_13 = avail_13;
        }
        if amount_13 == 0 as libc::c_int as libc::c_ulong {
            compunit_0.cu_abbrev_offset = 0 as libc::c_int as dwarf_vma;
        } else {
            compunit_0
                .cu_abbrev_offset = byte_get
                .expect(
                    "non-null function pointer",
                )(hdrptr_0, amount_13 as libc::c_uint);
        }
        hdrptr_0 = hdrptr_0.offset(amount_13 as isize);
        if this_set_0.is_null() {
            abbrev_base_0 = 0 as libc::c_int as dwarf_vma;
            abbrev_size_0 = (*debug_displays.as_mut_ptr().offset(abbrev_sec as isize))
                .section
                .size;
        } else {
            abbrev_base_0 = (*this_set_0)
                .section_offsets[DW_SECT_ABBREV as libc::c_int as usize];
            abbrev_size_0 = (*this_set_0)
                .section_sizes[DW_SECT_ABBREV as libc::c_int as usize];
        }
        if (compunit_0.cu_version as libc::c_int) < 5 as libc::c_int {
            let mut amount_14: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_14 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_14,
                        5 as libc::c_int,
                    ),
                    amount_14 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_14 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
            }
            let mut avail_14: size_t = end_cu_0.offset_from(hdrptr_0) as libc::c_long
                as size_t;
            if hdrptr_0 > end_cu_0 {
                avail_14 = 0 as libc::c_int as size_t;
            }
            if amount_14 > avail_14 {
                amount_14 = avail_14;
            }
            if amount_14 == 0 as libc::c_int as libc::c_ulong {
                compunit_0.cu_pointer_size = 0 as libc::c_int as libc::c_uchar;
            } else {
                compunit_0
                    .cu_pointer_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr_0, amount_14 as libc::c_uint) as libc::c_uchar;
            }
            hdrptr_0 = hdrptr_0.offset(amount_14 as isize);
        }
        let mut do_dwo_id: bool = 0 as libc::c_int != 0;
        let mut dwo_id_0: uint64_t = 0 as libc::c_int as uint64_t;
        if compunit_0.cu_unit_type as libc::c_uint
            == DW_UT_split_compile as libc::c_int as libc::c_uint
            || compunit_0.cu_unit_type as libc::c_uint
                == DW_UT_skeleton as libc::c_int as libc::c_uint
        {
            let mut amount_15: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint64_t>() as libc::c_ulong) < amount_15 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_15,
                        5 as libc::c_int,
                    ),
                    amount_15 as libc::c_int,
                    ::core::mem::size_of::<uint64_t>() as libc::c_ulong as libc::c_int,
                );
                amount_15 = ::core::mem::size_of::<uint64_t>() as libc::c_ulong;
            }
            let mut avail_15: size_t = end_cu_0.offset_from(hdrptr_0) as libc::c_long
                as size_t;
            if hdrptr_0 > end_cu_0 {
                avail_15 = 0 as libc::c_int as size_t;
            }
            if amount_15 > avail_15 {
                amount_15 = avail_15;
            }
            if amount_15 == 0 as libc::c_int as libc::c_ulong {
                dwo_id_0 = 0 as libc::c_int as uint64_t;
            } else {
                dwo_id_0 = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr_0, amount_15 as libc::c_uint);
            }
            hdrptr_0 = hdrptr_0.offset(amount_15 as isize);
            do_dwo_id = 1 as libc::c_int != 0;
        }
        if (compunit_0.cu_pointer_size as libc::c_int) < 2 as libc::c_int
            || compunit_0.cu_pointer_size as libc::c_int > 8 as libc::c_int
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Invalid pointer size (%d) in compunit header, using %d instead\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                compunit_0.cu_pointer_size as libc::c_int,
                offset_size_0,
            );
            compunit_0.cu_pointer_size = offset_size_0 as libc::c_uchar;
        }
        if do_types {
            let mut amount_16: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_16 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_16,
                        5 as libc::c_int,
                    ),
                    amount_16 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_16 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_16: size_t = end_cu_0.offset_from(hdrptr_0) as libc::c_long
                as size_t;
            if hdrptr_0 > end_cu_0 {
                avail_16 = 0 as libc::c_int as size_t;
            }
            if amount_16 > avail_16 {
                amount_16 = avail_16;
            }
            if amount_16 == 0 as libc::c_int as libc::c_ulong {
                signature = 0 as libc::c_int as dwarf_vma;
            } else {
                signature = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr_0, amount_16 as libc::c_uint);
            }
            hdrptr_0 = hdrptr_0.offset(amount_16 as isize);
            let mut amount_17: size_t = offset_size_0 as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_17 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_17,
                        5 as libc::c_int,
                    ),
                    amount_17 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_17 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_17: size_t = end_cu_0.offset_from(hdrptr_0) as libc::c_long
                as size_t;
            if hdrptr_0 > end_cu_0 {
                avail_17 = 0 as libc::c_int as size_t;
            }
            if amount_17 > avail_17 {
                amount_17 = avail_17;
            }
            if amount_17 == 0 as libc::c_int as libc::c_ulong {
                type_offset = 0 as libc::c_int as dwarf_vma;
            } else {
                type_offset = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr_0, amount_17 as libc::c_uint);
            }
            hdrptr_0 = hdrptr_0.offset(amount_17 as isize);
        }
        if dwarf_start_die
            >= end_cu_0.offset_from(section_begin) as libc::c_long as size_t
        {
            start = end_cu_0;
        } else {
            if (do_loc as libc::c_int != 0 || do_debug_loc != 0 || do_debug_ranges != 0)
                && num_debug_info_entries == 0 as libc::c_int as libc::c_uint
                && alloc_num_debug_info_entries > unit && !do_types
            {
                (*debug_information.offset(unit as isize)).cu_offset = cu_offset_0;
                (*debug_information.offset(unit as isize))
                    .pointer_size = compunit_0.cu_pointer_size as libc::c_uint;
                (*debug_information.offset(unit as isize)).offset_size = offset_size_0;
                (*debug_information.offset(unit as isize))
                    .dwarf_version = compunit_0.cu_version as libc::c_int;
                (*debug_information.offset(unit as isize))
                    .base_address = 0 as libc::c_int as dwarf_vma;
                (*debug_information.offset(unit as isize))
                    .addr_base = -(1 as libc::c_int) as libc::c_uint as dwarf_vma;
                (*debug_information.offset(unit as isize))
                    .ranges_base = -(1 as libc::c_int) as libc::c_uint as dwarf_vma;
                let ref mut fresh13 = (*debug_information.offset(unit as isize))
                    .loc_offsets;
                *fresh13 = 0 as *mut dwarf_vma;
                let ref mut fresh14 = (*debug_information.offset(unit as isize))
                    .have_frame_base;
                *fresh14 = 0 as *mut libc::c_int;
                (*debug_information.offset(unit as isize))
                    .max_loc_offsets = 0 as libc::c_int as libc::c_uint;
                (*debug_information.offset(unit as isize))
                    .num_loc_offsets = 0 as libc::c_int as libc::c_uint;
                let ref mut fresh15 = (*debug_information.offset(unit as isize))
                    .range_lists;
                *fresh15 = 0 as *mut dwarf_vma;
                (*debug_information.offset(unit as isize))
                    .max_range_lists = 0 as libc::c_int as libc::c_uint;
                (*debug_information.offset(unit as isize))
                    .num_range_lists = 0 as libc::c_int as libc::c_uint;
            }
            if !do_loc && dwarf_start_die == 0 as libc::c_int as libc::c_ulong {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Compilation Unit @ offset 0x%s:\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, cu_offset_0),
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"   Length:        0x%s (%s)\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        compunit_0.cu_length,
                    ),
                    if offset_size_0 == 8 as libc::c_int as libc::c_uint {
                        b"64-bit\0" as *const u8 as *const libc::c_char
                    } else {
                        b"32-bit\0" as *const u8 as *const libc::c_char
                    },
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"   Version:       %d\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    compunit_0.cu_version as libc::c_int,
                );
                if compunit_0.cu_version as libc::c_int >= 5 as libc::c_int {
                    let mut name: *const libc::c_char = get_DW_UT_name(
                        compunit_0.cu_unit_type as libc::c_uint,
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   Unit Type:     %s (%x)\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        if !name.is_null() {
                            name
                        } else {
                            b"???\0" as *const u8 as *const libc::c_char
                        },
                        compunit_0.cu_unit_type as libc::c_uint,
                    );
                }
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"   Abbrev Offset: 0x%s\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        compunit_0.cu_abbrev_offset,
                    ),
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"   Pointer Size:  %d\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    compunit_0.cu_pointer_size as libc::c_int,
                );
                if do_types {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   Signature:     0x%s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            signature,
                        ),
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   Type Offset:   0x%s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            type_offset,
                        ),
                    );
                }
                if do_dwo_id {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   DWO ID:        0x%s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            dwo_id_0,
                        ),
                    );
                }
                if !this_set_0.is_null() {
                    let mut offsets: *mut dwarf_vma = ((*this_set_0).section_offsets)
                        .as_mut_ptr();
                    let mut sizes: *mut size_t = ((*this_set_0).section_sizes)
                        .as_mut_ptr();
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"   Section contributions:\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"    .debug_abbrev.dwo:       0x%s  0x%s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            *offsets.offset(DW_SECT_ABBREV as libc::c_int as isize),
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            *sizes.offset(DW_SECT_ABBREV as libc::c_int as isize),
                        ),
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"    .debug_line.dwo:         0x%s  0x%s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            *offsets.offset(DW_SECT_LINE as libc::c_int as isize),
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            *sizes.offset(DW_SECT_LINE as libc::c_int as isize),
                        ),
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"    .debug_loc.dwo:          0x%s  0x%s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            *offsets.offset(DW_SECT_LOC as libc::c_int as isize),
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            *sizes.offset(DW_SECT_LOC as libc::c_int as isize),
                        ),
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"    .debug_str_offsets.dwo:  0x%s  0x%s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            *offsets.offset(DW_SECT_STR_OFFSETS as libc::c_int as isize),
                        ),
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            *sizes.offset(DW_SECT_STR_OFFSETS as libc::c_int as isize),
                        ),
                    );
                }
            }
            tags = hdrptr_0;
            start = end_cu_0;
            if (compunit_0.cu_version as libc::c_int) < 2 as libc::c_int
                || compunit_0.cu_version as libc::c_int > 5 as libc::c_int
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"CU at offset %s contains corrupt or unsupported version number: %d.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        cu_offset_0,
                    ),
                    compunit_0.cu_version as libc::c_int,
                );
            } else if compunit_0.cu_unit_type as libc::c_uint
                != DW_UT_compile as libc::c_int as libc::c_uint
                && compunit_0.cu_unit_type as libc::c_uint
                    != DW_UT_partial as libc::c_int as libc::c_uint
                && compunit_0.cu_unit_type as libc::c_uint
                    != DW_UT_type as libc::c_int as libc::c_uint
                && compunit_0.cu_unit_type as libc::c_uint
                    != DW_UT_split_compile as libc::c_int as libc::c_uint
                && compunit_0.cu_unit_type as libc::c_uint
                    != DW_UT_skeleton as libc::c_int as libc::c_uint
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"CU at offset %s contains corrupt or unsupported unit type: %d.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    dwarf_vmatoa(
                        b"x\0" as *const u8 as *const libc::c_char,
                        cu_offset_0,
                    ),
                    compunit_0.cu_unit_type as libc::c_uint,
                );
            } else {
                list_0 = find_abbrev_list_by_abbrev_offset(
                    abbrev_base_0,
                    compunit_0.cu_abbrev_offset,
                );
                if list_0.is_null() {
                    let mut next_0: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                    list_0 = new_abbrev_list(abbrev_base_0, compunit_0.cu_abbrev_offset);
                    next_0 = process_abbrev_set(
                        &mut (*debug_displays.as_mut_ptr().offset(abbrev_sec as isize))
                            .section,
                        abbrev_base_0,
                        abbrev_size_0,
                        compunit_0.cu_abbrev_offset,
                        list_0,
                    );
                    (*list_0).start_of_next_abbrevs = next_0;
                }
                level = 0 as libc::c_int;
                last_level = level;
                saved_level = -(1 as libc::c_int);
                while tags < start {
                    let mut abbrev_number: libc::c_ulong = 0;
                    let mut die_offset: libc::c_ulong = 0;
                    let mut entry: *mut abbrev_entry = 0 as *mut abbrev_entry;
                    let mut attr: *mut abbrev_attr = 0 as *mut abbrev_attr;
                    let mut do_printing: libc::c_int = 1 as libc::c_int;
                    die_offset = tags.offset_from(section_begin) as libc::c_long
                        as libc::c_ulong;
                    let mut _val: dwarf_vma = 0;
                    let mut _len: libc::c_uint = 0;
                    let mut _status: libc::c_int = 0;
                    _val = read_leb128(
                        tags,
                        start,
                        0 as libc::c_int != 0,
                        &mut _len,
                        &mut _status,
                    );
                    tags = tags.offset(_len as isize);
                    abbrev_number = _val;
                    if abbrev_number != _val {
                        _status |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        3837 as libc::c_int as libc::c_ulong,
                    );
                    if abbrev_number == 0 as libc::c_int as libc::c_ulong {
                        if level == 0 as libc::c_int && start == end {
                            let mut chk: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                            chk = tags;
                            while chk < start {
                                if *chk as libc::c_int != 0 as libc::c_int {
                                    break;
                                }
                                chk = chk.offset(1);
                                chk;
                            }
                            if chk == start {
                                break;
                            }
                        }
                        if !do_loc && die_offset >= dwarf_start_die
                            && (dwarf_cutoff_level == -(1 as libc::c_int)
                                || level < dwarf_cutoff_level)
                        {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" <%d><%lx>: Abbrev Number: 0\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                level,
                                die_offset,
                            );
                        }
                        level -= 1;
                        level;
                        if level < 0 as libc::c_int {
                            static mut num_bogus_warns: libc::c_uint = 0 as libc::c_int
                                as libc::c_uint;
                            if num_bogus_warns < 3 as libc::c_int as libc::c_uint {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Bogus end-of-siblings marker detected at offset %lx in %s section\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    die_offset,
                                    (*section).name,
                                );
                                num_bogus_warns = num_bogus_warns.wrapping_add(1);
                                num_bogus_warns;
                                if num_bogus_warns == 3 as libc::c_int as libc::c_uint {
                                    warn(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Further warnings about bogus end-of-sibling markers suppressed\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                }
                            }
                        }
                        if dwarf_start_die != 0 as libc::c_int as libc::c_ulong
                            && level < saved_level
                        {
                            return 1 as libc::c_int != 0;
                        }
                    } else {
                        if !do_loc {
                            if dwarf_start_die != 0 as libc::c_int as libc::c_ulong
                                && die_offset < dwarf_start_die
                            {
                                do_printing = 0 as libc::c_int;
                            } else {
                                if dwarf_start_die != 0 as libc::c_int as libc::c_ulong
                                    && die_offset == dwarf_start_die
                                {
                                    saved_level = level;
                                }
                                do_printing = (dwarf_cutoff_level == -(1 as libc::c_int)
                                    || level < dwarf_cutoff_level) as libc::c_int;
                                if do_printing != 0 {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" <%d><%lx>: Abbrev Number: %lu\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        level,
                                        die_offset,
                                        abbrev_number,
                                    );
                                } else if dwarf_cutoff_level == -(1 as libc::c_int)
                                    || last_level < dwarf_cutoff_level
                                {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" <%d><%lx>: ...\n\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        level,
                                        die_offset,
                                    );
                                }
                                last_level = level;
                            }
                        }
                        if list_0.is_null() {
                            continue;
                        }
                        entry = (*list_0).first_abbrev;
                        while !entry.is_null() {
                            if (*entry).number == abbrev_number {
                                break;
                            }
                            entry = (*entry).next;
                        }
                        if entry.is_null() {
                            if !do_loc && do_printing != 0 {
                                printf(b"\n\0" as *const u8 as *const libc::c_char);
                                fflush(stdout);
                            }
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                die_offset,
                                abbrev_number,
                            );
                            return 0 as libc::c_int != 0;
                        }
                        if !do_loc && do_printing != 0 {
                            printf(
                                b" (%s)\n\0" as *const u8 as *const libc::c_char,
                                get_TAG_name((*entry).tag),
                            );
                        }
                        match (*entry).tag {
                            17 => {
                                need_base_address = 1 as libc::c_int;
                                need_dwo_info = do_loc;
                            }
                            3 | 46 => {
                                need_base_address = 0 as libc::c_int;
                                have_frame_base = 0 as libc::c_int;
                            }
                            _ => {
                                need_base_address = 0 as libc::c_int;
                            }
                        }
                        let mut debug_info_p: *mut debug_info = if !debug_information
                            .is_null() && unit < alloc_num_debug_info_entries
                        {
                            debug_information.offset(unit as isize)
                        } else {
                            0 as *mut debug_info
                        };
                        if debug_info_p.is_null()
                            || (*debug_info_p).num_loc_offsets
                                == (*debug_info_p).num_loc_views
                        {} else {
                            __assert_fail(
                                b"!debug_info_p || (debug_info_p->num_loc_offsets == debug_info_p->num_loc_views)\0"
                                    as *const u8 as *const libc::c_char,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                3947 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 104],
                                    &[libc::c_char; 104],
                                >(
                                    b"_Bool process_debug_info(struct dwarf_section *, void *, enum dwarf_section_display_enum, _Bool, _Bool)\0",
                                ))
                                    .as_ptr(),
                            );
                        }
                        'c_41016: {
                            if debug_info_p.is_null()
                                || (*debug_info_p).num_loc_offsets
                                    == (*debug_info_p).num_loc_views
                            {} else {
                                __assert_fail(
                                    b"!debug_info_p || (debug_info_p->num_loc_offsets == debug_info_p->num_loc_views)\0"
                                        as *const u8 as *const libc::c_char,
                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                    3947 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 104],
                                        &[libc::c_char; 104],
                                    >(
                                        b"_Bool process_debug_info(struct dwarf_section *, void *, enum dwarf_section_display_enum, _Bool, _Bool)\0",
                                    ))
                                        .as_ptr(),
                                );
                            }
                        };
                        attr = (*entry).first_attr;
                        while !attr.is_null() && (*attr).attribute != 0 {
                            if !do_loc && do_printing != 0 {
                                printf(
                                    b"    <%lx>\0" as *const u8 as *const libc::c_char,
                                    tags.offset_from(section_begin) as libc::c_long
                                        as libc::c_ulong,
                                );
                            }
                            tags = read_and_display_attr(
                                (*attr).attribute,
                                (*attr).form,
                                (*attr).implicit_const,
                                section_begin,
                                tags,
                                start,
                                cu_offset_0,
                                compunit_0.cu_pointer_size as dwarf_vma,
                                offset_size_0 as dwarf_vma,
                                compunit_0.cu_version as libc::c_int,
                                debug_info_p,
                                (do_loc as libc::c_int != 0 || do_printing == 0)
                                    as libc::c_int,
                                section,
                                this_set_0,
                                level,
                            );
                            attr = (*attr).next;
                        }
                        if !debug_info_p.is_null() {
                            match ((*debug_info_p).num_loc_offsets)
                                .wrapping_sub((*debug_info_p).num_loc_views)
                            {
                                1 => {
                                    *((*debug_info_p).loc_views)
                                        .offset((*debug_info_p).num_loc_views as isize) = vm1;
                                    (*debug_info_p)
                                        .num_loc_views = ((*debug_info_p).num_loc_views)
                                        .wrapping_add(1);
                                    (*debug_info_p).num_loc_views;
                                    if (*debug_info_p).num_loc_views
                                        == (*debug_info_p).num_loc_offsets
                                    {} else {
                                        __assert_fail(
                                            b"debug_info_p->num_loc_views == debug_info_p->num_loc_offsets\0"
                                                as *const u8 as *const libc::c_char,
                                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                            3983 as libc::c_int as libc::c_uint,
                                            (*::core::mem::transmute::<
                                                &[u8; 104],
                                                &[libc::c_char; 104],
                                            >(
                                                b"_Bool process_debug_info(struct dwarf_section *, void *, enum dwarf_section_display_enum, _Bool, _Bool)\0",
                                            ))
                                                .as_ptr(),
                                        );
                                    }
                                    'c_19212: {
                                        if (*debug_info_p).num_loc_views
                                            == (*debug_info_p).num_loc_offsets
                                        {} else {
                                            __assert_fail(
                                                b"debug_info_p->num_loc_views == debug_info_p->num_loc_offsets\0"
                                                    as *const u8 as *const libc::c_char,
                                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                                3983 as libc::c_int as libc::c_uint,
                                                (*::core::mem::transmute::<
                                                    &[u8; 104],
                                                    &[libc::c_char; 104],
                                                >(
                                                    b"_Bool process_debug_info(struct dwarf_section *, void *, enum dwarf_section_display_enum, _Bool, _Bool)\0",
                                                ))
                                                    .as_ptr(),
                                            );
                                        }
                                    };
                                }
                                0 => {}
                                4294967295 => {
                                    warn(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"DIE has locviews without loclist\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    (*debug_info_p)
                                        .num_loc_views = ((*debug_info_p).num_loc_views)
                                        .wrapping_sub(1);
                                    (*debug_info_p).num_loc_views;
                                }
                                _ => {
                                    __assert_fail(
                                        b"0\0" as *const u8 as *const libc::c_char,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        3995 as libc::c_int as libc::c_uint,
                                        (*::core::mem::transmute::<
                                            &[u8; 104],
                                            &[libc::c_char; 104],
                                        >(
                                            b"_Bool process_debug_info(struct dwarf_section *, void *, enum dwarf_section_display_enum, _Bool, _Bool)\0",
                                        ))
                                            .as_ptr(),
                                    );
                                    'c_19132: {
                                        __assert_fail(
                                            b"0\0" as *const u8 as *const libc::c_char,
                                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                            3995 as libc::c_int as libc::c_uint,
                                            (*::core::mem::transmute::<
                                                &[u8; 104],
                                                &[libc::c_char; 104],
                                            >(
                                                b"_Bool process_debug_info(struct dwarf_section *, void *, enum dwarf_section_display_enum, _Bool, _Bool)\0",
                                            ))
                                                .as_ptr(),
                                        );
                                    };
                                }
                            }
                        }
                        if (*entry).children != 0 {
                            level += 1;
                            level;
                        }
                    }
                }
            }
        }
        unit = unit.wrapping_add(1);
        unit;
    }
    if (do_loc as libc::c_int != 0 || do_debug_loc != 0 || do_debug_ranges != 0)
        && num_debug_info_entries == 0 as libc::c_int as libc::c_uint && !do_types
    {
        if num_units > alloc_num_debug_info_entries {
            num_debug_info_entries = alloc_num_debug_info_entries;
        } else {
            num_debug_info_entries = num_units;
        }
    }
    if !do_loc {
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn load_debug_info(mut file: *mut libc::c_void) -> libc::c_uint {
    if num_debug_info_entries == -(1 as libc::c_int) as libc::c_uint {
        return 0 as libc::c_int as libc::c_uint;
    }
    if num_debug_info_entries > 0 as libc::c_int as libc::c_uint {
        return num_debug_info_entries;
    }
    load_cu_tu_indexes(file);
    if load_debug_section_with_follow(info, file) as libc::c_int != 0
        && process_debug_info(
            &mut (*debug_displays.as_mut_ptr().offset(info as libc::c_int as isize))
                .section,
            file,
            abbrev,
            1 as libc::c_int != 0,
            0 as libc::c_int != 0,
        ) as libc::c_int != 0
    {
        return num_debug_info_entries;
    }
    if load_debug_section_with_follow(info_dwo, file) as libc::c_int != 0
        && process_debug_info(
            &mut (*debug_displays.as_mut_ptr().offset(info_dwo as libc::c_int as isize))
                .section,
            file,
            abbrev_dwo,
            1 as libc::c_int != 0,
            0 as libc::c_int != 0,
        ) as libc::c_int != 0
    {
        return num_debug_info_entries;
    }
    num_debug_info_entries = -(1 as libc::c_int) as libc::c_uint;
    return 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn read_debug_line_header(
    mut section: *mut dwarf_section,
    mut data: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut linfo: *mut DWARF2_Internal_LineInfo,
    mut end_of_sequence: *mut *mut libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut hdrptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    hdrptr = data;
    let mut amount: size_t = 4 as libc::c_int as size_t;
    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount,
                5 as libc::c_int,
            ),
            amount as libc::c_int,
            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
        );
        amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
    }
    let mut avail: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end {
        avail = 0 as libc::c_int as size_t;
    }
    if amount > avail {
        amount = avail;
    }
    if amount == 0 as libc::c_int as libc::c_ulong {
        (*linfo).li_length = 0 as libc::c_int as dwarf_vma;
    } else {
        (*linfo)
            .li_length = byte_get
            .expect("non-null function pointer")(hdrptr, amount as libc::c_uint);
    }
    hdrptr = hdrptr.offset(amount as isize);
    if (*linfo).li_length == 0xffffffff as libc::c_uint as libc::c_ulong {
        let mut amount_0: size_t = 8 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_0,
                    5 as libc::c_int,
                ),
                amount_0 as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail_0: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_0 = 0 as libc::c_int as size_t;
        }
        if amount_0 > avail_0 {
            amount_0 = avail_0;
        }
        if amount_0 == 0 as libc::c_int as libc::c_ulong {
            (*linfo).li_length = 0 as libc::c_int as dwarf_vma;
        } else {
            (*linfo)
                .li_length = byte_get
                .expect("non-null function pointer")(hdrptr, amount_0 as libc::c_uint);
        }
        hdrptr = hdrptr.offset(amount_0 as isize);
        (*linfo).li_offset_size = 8 as libc::c_int as libc::c_uint;
    } else {
        (*linfo).li_offset_size = 4 as libc::c_int as libc::c_uint;
    }
    if (*linfo).li_length > end.offset_from(hdrptr) as libc::c_long as size_t {
        if reloc_at(
            section,
            (hdrptr.offset_from((*section).start) as libc::c_long
                - (*linfo).li_offset_size as libc::c_long) as dwarf_vma,
        ) {
            (*linfo).li_length = end.offset_from(hdrptr) as libc::c_long as dwarf_vma;
        } else {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The length field (0x%lx) in the debug_line header is wrong - the section is too small\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*linfo).li_length as libc::c_long,
            );
            return 0 as *mut libc::c_uchar;
        }
    }
    end = hdrptr.offset((*linfo).li_length as isize);
    let mut amount_1: size_t = 2 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong) < amount_1 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_1,
                5 as libc::c_int,
            ),
            amount_1 as libc::c_int,
            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong as libc::c_int,
        );
        amount_1 = ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong;
    }
    let mut avail_1: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end {
        avail_1 = 0 as libc::c_int as size_t;
    }
    if amount_1 > avail_1 {
        amount_1 = avail_1;
    }
    if amount_1 == 0 as libc::c_int as libc::c_ulong {
        (*linfo).li_version = 0 as libc::c_int as libc::c_ushort;
    } else {
        (*linfo)
            .li_version = byte_get
            .expect("non-null function pointer")(hdrptr, amount_1 as libc::c_uint)
            as libc::c_ushort;
    }
    hdrptr = hdrptr.offset(amount_1 as isize);
    if (*linfo).li_version as libc::c_int != 2 as libc::c_int
        && (*linfo).li_version as libc::c_int != 3 as libc::c_int
        && (*linfo).li_version as libc::c_int != 4 as libc::c_int
        && (*linfo).li_version as libc::c_int != 5 as libc::c_int
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Only DWARF version 2, 3, 4 and 5 line info is currently supported.\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as *mut libc::c_uchar;
    }
    if (*linfo).li_version as libc::c_int >= 5 as libc::c_int {
        let mut amount_2: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_2 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_2,
                    5 as libc::c_int,
                ),
                amount_2 as libc::c_int,
                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
            );
            amount_2 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
        }
        let mut avail_2: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_2 = 0 as libc::c_int as size_t;
        }
        if amount_2 > avail_2 {
            amount_2 = avail_2;
        }
        if amount_2 == 0 as libc::c_int as libc::c_ulong {
            (*linfo).li_address_size = 0 as libc::c_int as libc::c_uchar;
        } else {
            (*linfo)
                .li_address_size = byte_get
                .expect("non-null function pointer")(hdrptr, amount_2 as libc::c_uint)
                as libc::c_uchar;
        }
        hdrptr = hdrptr.offset(amount_2 as isize);
        let mut amount_3: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_3 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_3,
                    5 as libc::c_int,
                ),
                amount_3 as libc::c_int,
                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
            );
            amount_3 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
        }
        let mut avail_3: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_3 = 0 as libc::c_int as size_t;
        }
        if amount_3 > avail_3 {
            amount_3 = avail_3;
        }
        if amount_3 == 0 as libc::c_int as libc::c_ulong {
            (*linfo).li_segment_size = 0 as libc::c_int as libc::c_uchar;
        } else {
            (*linfo)
                .li_segment_size = byte_get
                .expect("non-null function pointer")(hdrptr, amount_3 as libc::c_uint)
                as libc::c_uchar;
        }
        hdrptr = hdrptr.offset(amount_3 as isize);
        if (*linfo).li_segment_size as libc::c_int != 0 as libc::c_int {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The %s section contains unsupported segment selector size: %d.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                (*linfo).li_segment_size as libc::c_int,
            );
            return 0 as *mut libc::c_uchar;
        }
    }
    let mut amount_4: size_t = (*linfo).li_offset_size as size_t;
    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_4 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_4,
                5 as libc::c_int,
            ),
            amount_4 as libc::c_int,
            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
        );
        amount_4 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
    }
    let mut avail_4: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end {
        avail_4 = 0 as libc::c_int as size_t;
    }
    if amount_4 > avail_4 {
        amount_4 = avail_4;
    }
    if amount_4 == 0 as libc::c_int as libc::c_ulong {
        (*linfo).li_prologue_length = 0 as libc::c_int as dwarf_vma;
    } else {
        (*linfo)
            .li_prologue_length = byte_get
            .expect("non-null function pointer")(hdrptr, amount_4 as libc::c_uint);
    }
    hdrptr = hdrptr.offset(amount_4 as isize);
    let mut amount_5: size_t = 1 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_5 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_5,
                5 as libc::c_int,
            ),
            amount_5 as libc::c_int,
            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
        );
        amount_5 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
    }
    let mut avail_5: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end {
        avail_5 = 0 as libc::c_int as size_t;
    }
    if amount_5 > avail_5 {
        amount_5 = avail_5;
    }
    if amount_5 == 0 as libc::c_int as libc::c_ulong {
        (*linfo).li_min_insn_length = 0 as libc::c_int as libc::c_uchar;
    } else {
        (*linfo)
            .li_min_insn_length = byte_get
            .expect("non-null function pointer")(hdrptr, amount_5 as libc::c_uint)
            as libc::c_uchar;
    }
    hdrptr = hdrptr.offset(amount_5 as isize);
    if (*linfo).li_version as libc::c_int >= 4 as libc::c_int {
        let mut amount_6: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_6 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_6,
                    5 as libc::c_int,
                ),
                amount_6 as libc::c_int,
                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
            );
            amount_6 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
        }
        let mut avail_6: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_6 = 0 as libc::c_int as size_t;
        }
        if amount_6 > avail_6 {
            amount_6 = avail_6;
        }
        if amount_6 == 0 as libc::c_int as libc::c_ulong {
            (*linfo).li_max_ops_per_insn = 0 as libc::c_int as libc::c_uchar;
        } else {
            (*linfo)
                .li_max_ops_per_insn = byte_get
                .expect("non-null function pointer")(hdrptr, amount_6 as libc::c_uint)
                as libc::c_uchar;
        }
        hdrptr = hdrptr.offset(amount_6 as isize);
        if (*linfo).li_max_ops_per_insn as libc::c_int == 0 as libc::c_int {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Invalid maximum operations per insn.\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as *mut libc::c_uchar;
        }
    } else {
        (*linfo).li_max_ops_per_insn = 1 as libc::c_int as libc::c_uchar;
    }
    let mut amount_7: size_t = 1 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_7 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_7,
                5 as libc::c_int,
            ),
            amount_7 as libc::c_int,
            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
        );
        amount_7 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
    }
    let mut avail_7: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end {
        avail_7 = 0 as libc::c_int as size_t;
    }
    if amount_7 > avail_7 {
        amount_7 = avail_7;
    }
    if amount_7 == 0 as libc::c_int as libc::c_ulong {
        (*linfo).li_default_is_stmt = 0 as libc::c_int as libc::c_uchar;
    } else {
        (*linfo)
            .li_default_is_stmt = byte_get
            .expect("non-null function pointer")(hdrptr, amount_7 as libc::c_uint)
            as libc::c_uchar;
    }
    hdrptr = hdrptr.offset(amount_7 as isize);
    let mut amount_8: size_t = 1 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_int>() as libc::c_ulong) < amount_8 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_8,
                5 as libc::c_int,
            ),
            amount_8 as libc::c_int,
            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int,
        );
        amount_8 = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong;
    }
    let mut avail_8: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end {
        avail_8 = 0 as libc::c_int as size_t;
    }
    if amount_8 > avail_8 {
        amount_8 = avail_8;
    }
    if amount_8 == 0 as libc::c_int as libc::c_ulong {
        (*linfo).li_line_base = 0 as libc::c_int;
    } else {
        (*linfo)
            .li_line_base = byte_get_signed(hdrptr, amount_8 as libc::c_uint)
            as libc::c_int;
    }
    hdrptr = hdrptr.offset(amount_8 as isize);
    let mut amount_9: size_t = 1 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_9 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_9,
                5 as libc::c_int,
            ),
            amount_9 as libc::c_int,
            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
        );
        amount_9 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
    }
    let mut avail_9: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end {
        avail_9 = 0 as libc::c_int as size_t;
    }
    if amount_9 > avail_9 {
        amount_9 = avail_9;
    }
    if amount_9 == 0 as libc::c_int as libc::c_ulong {
        (*linfo).li_line_range = 0 as libc::c_int as libc::c_uchar;
    } else {
        (*linfo)
            .li_line_range = byte_get
            .expect("non-null function pointer")(hdrptr, amount_9 as libc::c_uint)
            as libc::c_uchar;
    }
    hdrptr = hdrptr.offset(amount_9 as isize);
    let mut amount_10: size_t = 1 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_10 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_10,
                5 as libc::c_int,
            ),
            amount_10 as libc::c_int,
            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
        );
        amount_10 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
    }
    let mut avail_10: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end {
        avail_10 = 0 as libc::c_int as size_t;
    }
    if amount_10 > avail_10 {
        amount_10 = avail_10;
    }
    if amount_10 == 0 as libc::c_int as libc::c_ulong {
        (*linfo).li_opcode_base = 0 as libc::c_int as libc::c_uchar;
    } else {
        (*linfo)
            .li_opcode_base = byte_get
            .expect("non-null function pointer")(hdrptr, amount_10 as libc::c_uint)
            as libc::c_uchar;
    }
    hdrptr = hdrptr.offset(amount_10 as isize);
    *end_of_sequence = end;
    return hdrptr;
}
unsafe extern "C" fn display_formatted_table(
    mut data: *mut libc::c_uchar,
    mut start: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut linfo: *const DWARF2_Internal_LineInfo,
    mut section: *mut dwarf_section,
    mut is_dir: bool,
) -> *mut libc::c_uchar {
    let mut format_start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut format_count: libc::c_uchar = 0;
    let mut format: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut formati: libc::c_uchar = 0;
    let mut data_count: dwarf_vma = 0;
    let mut datai: dwarf_vma = 0;
    let mut namepass: libc::c_uint = 0;
    let mut last_entry: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut table_name: *const libc::c_char = if is_dir as libc::c_int != 0 {
        b"Directory Table\0" as *const u8 as *const libc::c_char
    } else {
        b"File Name Table\0" as *const u8 as *const libc::c_char
    };
    let mut amount: size_t = 1 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount,
                5 as libc::c_int,
            ),
            amount as libc::c_int,
            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
        );
        amount = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
    }
    let mut avail: size_t = end.offset_from(data) as libc::c_long as size_t;
    if data > end {
        avail = 0 as libc::c_int as size_t;
    }
    if amount > avail {
        amount = avail;
    }
    if amount == 0 as libc::c_int as libc::c_ulong {
        format_count = 0 as libc::c_int as libc::c_uchar;
    } else {
        format_count = byte_get
            .expect("non-null function pointer")(data, amount as libc::c_uint)
            as libc::c_uchar;
    }
    data = data.offset(amount as isize);
    if do_checks as libc::c_int != 0 && format_count as libc::c_int > 5 as libc::c_int {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unexpectedly large number of columns in the %s (%u)\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            table_name,
            format_count as libc::c_int,
        );
    }
    format_start = data;
    formati = 0 as libc::c_int as libc::c_uchar;
    while (formati as libc::c_int) < format_count as libc::c_int {
        let mut _len: libc::c_uint = 0;
        read_leb128(data, end, 0 as libc::c_int != 0, &mut _len, 0 as *mut libc::c_int);
        data = data.offset(_len as isize);
        let mut _len_0: libc::c_uint = 0;
        read_leb128(
            data,
            end,
            0 as libc::c_int != 0,
            &mut _len_0,
            0 as *mut libc::c_int,
        );
        data = data.offset(_len_0 as isize);
        if data >= end {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"%s: Corrupt format description entry\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                table_name,
            );
            return data;
        }
        formati = formati.wrapping_add(1);
        formati;
    }
    let mut _val: dwarf_vma = 0;
    let mut _len_1: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(data, end, 0 as libc::c_int != 0, &mut _len_1, &mut _status);
    data = data.offset(_len_1 as isize);
    data_count = _val;
    if data_count != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"dwarf.c\0" as *const u8 as *const libc::c_char,
        4189 as libc::c_int as libc::c_ulong,
    );
    if data_count == 0 as libc::c_int as libc::c_ulong {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\n The %s is empty.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            table_name,
        );
        return data;
    } else if data >= end {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"%s: Corrupt entry count - expected %s but none found\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            table_name,
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, data_count),
        );
        return data;
    } else if format_count as libc::c_int == 0 as libc::c_int {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"%s: format count is zero, but the table is not empty\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            table_name,
        );
        return end;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\n The %s (offset 0x%lx, lines %s, columns %u):\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        table_name,
        data.offset_from(start) as libc::c_long,
        dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, data_count),
        format_count as libc::c_int,
    );
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Entry\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    namepass = 0 as libc::c_int as libc::c_uint;
    while namepass < 2 as libc::c_int as libc::c_uint {
        format = format_start;
        formati = 0 as libc::c_int as libc::c_uchar;
        while (formati as libc::c_int) < format_count as libc::c_int {
            let mut content_type: dwarf_vma = 0;
            let mut _val_0: dwarf_vma = 0;
            let mut _len_2: libc::c_uint = 0;
            let mut _status_0: libc::c_int = 0;
            _val_0 = read_leb128(
                format,
                end,
                0 as libc::c_int != 0,
                &mut _len_2,
                &mut _status_0,
            );
            format = format.offset(_len_2 as isize);
            content_type = _val_0;
            if content_type != _val_0 {
                _status_0 |= 2 as libc::c_int;
            }
            report_leb_status(
                _status_0,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                4222 as libc::c_int as libc::c_ulong,
            );
            if (content_type == DW_LNCT_path as libc::c_int as libc::c_ulong)
                as libc::c_int
                == (namepass == 1 as libc::c_int as libc::c_uint) as libc::c_int
            {
                match content_type {
                    1 => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\tName\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    2 => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\tDir\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    3 => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\tTime\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    4 => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\tSize\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    5 => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\tMD5\t\t\t\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    _ => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\t(Unknown format content type %s)\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            dwarf_vmatoa(
                                b"u\0" as *const u8 as *const libc::c_char,
                                content_type,
                            ),
                        );
                    }
                }
            }
            let mut _len_3: libc::c_uint = 0;
            read_leb128(
                format,
                end,
                0 as libc::c_int != 0,
                &mut _len_3,
                0 as *mut libc::c_int,
            );
            format = format.offset(_len_3 as isize);
            formati = formati.wrapping_add(1);
            formati;
        }
        namepass = namepass.wrapping_add(1);
        namepass;
    }
    putchar('\n' as i32);
    datai = 0 as libc::c_int as dwarf_vma;
    while datai < data_count {
        let mut datapass: *mut libc::c_uchar = data;
        let fresh16 = last_entry;
        last_entry = last_entry.wrapping_add(1);
        printf(b"  %d\0" as *const u8 as *const libc::c_char, fresh16);
        namepass = 0 as libc::c_int as libc::c_uint;
        while namepass < 2 as libc::c_int as libc::c_uint {
            format = format_start;
            data = datapass;
            formati = 0 as libc::c_int as libc::c_uchar;
            while (formati as libc::c_int) < format_count as libc::c_int {
                let mut content_type_0: dwarf_vma = 0;
                let mut form: dwarf_vma = 0;
                let mut _val_1: dwarf_vma = 0;
                let mut _len_4: libc::c_uint = 0;
                let mut _status_1: libc::c_int = 0;
                _val_1 = read_leb128(
                    format,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_4,
                    &mut _status_1,
                );
                format = format.offset(_len_4 as isize);
                content_type_0 = _val_1;
                if content_type_0 != _val_1 {
                    _status_1 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_1,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    4264 as libc::c_int as libc::c_ulong,
                );
                let mut _val_2: dwarf_vma = 0;
                let mut _len_5: libc::c_uint = 0;
                let mut _status_2: libc::c_int = 0;
                _val_2 = read_leb128(
                    format,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_5,
                    &mut _status_2,
                );
                format = format.offset(_len_5 as isize);
                form = _val_2;
                if form != _val_2 {
                    _status_2 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_2,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    4265 as libc::c_int as libc::c_ulong,
                );
                data = read_and_display_attr_value(
                    0 as libc::c_int as libc::c_ulong,
                    form,
                    0 as libc::c_int as dwarf_signed_vma,
                    start,
                    data,
                    end,
                    0 as libc::c_int as dwarf_vma,
                    0 as libc::c_int as dwarf_vma,
                    (*linfo).li_offset_size as dwarf_vma,
                    (*linfo).li_version as libc::c_int,
                    0 as *mut debug_info,
                    ((content_type_0 == DW_LNCT_path as libc::c_int as libc::c_ulong)
                        as libc::c_int
                        != (namepass == 1 as libc::c_int as libc::c_uint) as libc::c_int)
                        as libc::c_int,
                    section,
                    0 as *mut cu_tu_set,
                    '\t' as i32 as libc::c_char,
                    -(1 as libc::c_int),
                );
                formati = formati.wrapping_add(1);
                formati;
            }
            namepass = namepass.wrapping_add(1);
            namepass;
        }
        if data >= end
            && datai < data_count.wrapping_sub(1 as libc::c_int as libc::c_ulong)
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\n%s: Corrupt entries list\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                table_name,
            );
            return data;
        }
        putchar('\n' as i32);
        datai = datai.wrapping_add(1);
        datai;
    }
    return data;
}
unsafe extern "C" fn display_debug_sup(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = ((*section).start)
        .offset((*section).size as isize);
    let mut version: libc::c_uint = 0;
    let mut is_supplementary: libc::c_char = 0;
    let mut sup_filename: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut sup_filename_len: size_t = 0;
    let mut num_read: libc::c_uint = 0;
    let mut status: libc::c_int = 0;
    let mut checksum_len: dwarf_vma = 0;
    introduce(section, 1 as libc::c_int != 0);
    if (*section).size < 4 as libc::c_int as libc::c_ulong {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt .debug_sup section: size is too small\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int;
    }
    let mut amount: size_t = 2 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount,
                5 as libc::c_int,
            ),
            amount as libc::c_int,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
        );
        amount = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
    }
    let mut avail: size_t = end.offset_from(start) as libc::c_long as size_t;
    if start > end {
        avail = 0 as libc::c_int as size_t;
    }
    if amount > avail {
        amount = avail;
    }
    if amount == 0 as libc::c_int as libc::c_ulong {
        version = 0 as libc::c_int as libc::c_uint;
    } else {
        version = byte_get
            .expect("non-null function pointer")(start, amount as libc::c_uint)
            as libc::c_uint;
    }
    start = start.offset(amount as isize);
    if version < 5 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt .debug_sup section: version < 5\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    let mut amount_0: size_t = 1 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_char>() as libc::c_ulong) < amount_0 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_0,
                5 as libc::c_int,
            ),
            amount_0 as libc::c_int,
            ::core::mem::size_of::<libc::c_char>() as libc::c_ulong as libc::c_int,
        );
        amount_0 = ::core::mem::size_of::<libc::c_char>() as libc::c_ulong;
    }
    let mut avail_0: size_t = end.offset_from(start) as libc::c_long as size_t;
    if start > end {
        avail_0 = 0 as libc::c_int as size_t;
    }
    if amount_0 > avail_0 {
        amount_0 = avail_0;
    }
    if amount_0 == 0 as libc::c_int as libc::c_ulong {
        is_supplementary = 0 as libc::c_int as libc::c_char;
    } else {
        is_supplementary = byte_get
            .expect("non-null function pointer")(start, amount_0 as libc::c_uint)
            as libc::c_char;
    }
    start = start.offset(amount_0 as isize);
    if is_supplementary as libc::c_int != 0 as libc::c_int
        && is_supplementary as libc::c_int != 1 as libc::c_int
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt .debug_sup section: is_supplementary not 0 or 1\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    sup_filename = start;
    if is_supplementary as libc::c_int != 0
        && *sup_filename.offset(0 as libc::c_int as isize) as libc::c_int
            != 0 as libc::c_int
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt .debug_sup section: filename not empty in supplementary section\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    sup_filename_len = strnlen(
        start as *const libc::c_char,
        end.offset_from(start) as libc::c_long as size_t,
    );
    if sup_filename_len == end.offset_from(start) as libc::c_long as size_t {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt .debug_sup section: filename is not NUL terminated\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int;
    }
    start = start
        .offset(
            sup_filename_len.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
        );
    checksum_len = read_leb128(
        start,
        end,
        0 as libc::c_int != 0,
        &mut num_read,
        &mut status,
    );
    if status != 0 {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt .debug_sup section: bad LEB128 field for checksum length\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        checksum_len = 0 as libc::c_int as dwarf_vma;
    }
    start = start.offset(num_read as isize);
    if checksum_len > end.offset_from(start) as libc::c_long as dwarf_vma {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt .debug_sup section: checksum length is longer than the remaining section length\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        checksum_len = end.offset_from(start) as libc::c_long as dwarf_vma;
    } else if checksum_len < end.offset_from(start) as libc::c_long as dwarf_vma {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"corrupt .debug_sup section: there are 0x%lx extra, unused bytes at the end of the section\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (end.offset_from(start) as libc::c_long as libc::c_ulong)
                .wrapping_sub(checksum_len) as libc::c_long,
        );
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Version:      %u\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        version,
    );
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Is Supp:      %u\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        is_supplementary as libc::c_int,
    );
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Filename:     %s\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        sup_filename,
    );
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Checksum Len: %lu\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        checksum_len as libc::c_long,
    );
    if checksum_len > 0 as libc::c_int as libc::c_ulong {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Checksum:     \0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        loop {
            let fresh17 = checksum_len;
            checksum_len = checksum_len.wrapping_sub(1);
            if !(fresh17 != 0) {
                break;
            }
            let fresh18 = start;
            start = start.offset(1);
            printf(
                b"0x%x \0" as *const u8 as *const libc::c_char,
                *fresh18 as libc::c_int,
            );
        }
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_lines_raw(
    mut section: *mut dwarf_section,
    mut data: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut verbose_view: libc::c_int = 0 as libc::c_int;
    introduce(section, 1 as libc::c_int != 0);
    while data < end {
        static mut saved_linfo: DWARF2_Internal_LineInfo = DWARF2_Internal_LineInfo {
            li_length: 0,
            li_version: 0,
            li_address_size: 0,
            li_segment_size: 0,
            li_prologue_length: 0,
            li_min_insn_length: 0,
            li_max_ops_per_insn: 0,
            li_default_is_stmt: 0,
            li_line_base: 0,
            li_line_range: 0,
            li_opcode_base: 0,
            li_offset_size: 0,
        };
        let mut linfo: DWARF2_Internal_LineInfo = DWARF2_Internal_LineInfo {
            li_length: 0,
            li_version: 0,
            li_address_size: 0,
            li_segment_size: 0,
            li_prologue_length: 0,
            li_min_insn_length: 0,
            li_max_ops_per_insn: 0,
            li_default_is_stmt: 0,
            li_line_base: 0,
            li_line_range: 0,
            li_opcode_base: 0,
            li_offset_size: 0,
        };
        let mut standard_opcodes: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut end_of_sequence: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut i: libc::c_int = 0;
        if startswith(
            (*section).name,
            b".debug_line.\0" as *const u8 as *const libc::c_char,
        ) as libc::c_int != 0
            && strcmp(
                (*section).name,
                b".debug_line.dwo\0" as *const u8 as *const libc::c_char,
            ) != 0 as libc::c_int
        {
            end_of_sequence = end;
            standard_opcodes = 0 as *mut libc::c_uchar;
            linfo = saved_linfo;
            if linfo.li_line_range as libc::c_int == 0 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Partial .debug_line. section encountered without a prior full .debug_line section\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int;
            }
            reset_state_machine(linfo.li_default_is_stmt as libc::c_int);
        } else {
            let mut hdrptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            hdrptr = read_debug_line_header(
                section,
                data,
                end,
                &mut linfo,
                &mut end_of_sequence,
            );
            if hdrptr.is_null() {
                return 0 as libc::c_int;
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Offset:                      0x%lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                data.offset_from(start) as libc::c_long,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Length:                      %ld\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                linfo.li_length as libc::c_long,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  DWARF Version:               %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                linfo.li_version as libc::c_int,
            );
            if linfo.li_version as libc::c_int >= 5 as libc::c_int {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Address size (bytes):        %d\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    linfo.li_address_size as libc::c_int,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Segment selector (bytes):    %d\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    linfo.li_segment_size as libc::c_int,
                );
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Prologue Length:             %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                linfo.li_prologue_length as libc::c_int,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Minimum Instruction Length:  %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                linfo.li_min_insn_length as libc::c_int,
            );
            if linfo.li_version as libc::c_int >= 4 as libc::c_int {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Maximum Ops per Instruction: %d\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    linfo.li_max_ops_per_insn as libc::c_int,
                );
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Initial value of 'is_stmt':  %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                linfo.li_default_is_stmt as libc::c_int,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Line Base:                   %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                linfo.li_line_base,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Line Range:                  %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                linfo.li_line_range as libc::c_int,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Opcode Base:                 %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                linfo.li_opcode_base as libc::c_int,
            );
            if linfo.li_line_range as libc::c_int == 0 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Line range of 0 is invalid, using 1 instead\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                linfo.li_line_range = 1 as libc::c_int as libc::c_uchar;
            }
            reset_state_machine(linfo.li_default_is_stmt as libc::c_int);
            standard_opcodes = hdrptr;
            if standard_opcodes.offset(linfo.li_opcode_base as libc::c_int as isize)
                >= end
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Line Base extends beyond end of section\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int;
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\n Opcodes:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            i = 1 as libc::c_int;
            while i < linfo.li_opcode_base as libc::c_int {
                printf(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"  Opcode %d has %d arg\n\0" as *const u8
                            as *const libc::c_char,
                        b"  Opcode %d has %d args\n\0" as *const u8
                            as *const libc::c_char,
                        *standard_opcodes.offset((i - 1 as libc::c_int) as isize)
                            as libc::c_ulong,
                        5 as libc::c_int,
                    ),
                    i,
                    *standard_opcodes.offset((i - 1 as libc::c_int) as isize)
                        as libc::c_int,
                );
                i += 1;
                i;
            }
            data = standard_opcodes
                .offset(linfo.li_opcode_base as libc::c_int as isize)
                .offset(-(1 as libc::c_int as isize));
            if linfo.li_version as libc::c_int >= 5 as libc::c_int {
                load_debug_section_with_follow(line_str, file);
                data = display_formatted_table(
                    data,
                    start,
                    end,
                    &mut linfo,
                    section,
                    1 as libc::c_int != 0,
                );
                data = display_formatted_table(
                    data,
                    start,
                    end,
                    &mut linfo,
                    section,
                    0 as libc::c_int != 0,
                );
            } else {
                if *data as libc::c_int == 0 as libc::c_int {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\n The Directory Table is empty.\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                } else {
                    let mut last_dir_entry: libc::c_uint = 0 as libc::c_int
                        as libc::c_uint;
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\n The Directory Table (offset 0x%lx):\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        data.offset_from(start) as libc::c_long,
                    );
                    while data < end && *data as libc::c_int != 0 as libc::c_int {
                        last_dir_entry = last_dir_entry.wrapping_add(1);
                        printf(
                            b"  %d\t%.*s\n\0" as *const u8 as *const libc::c_char,
                            last_dir_entry,
                            end.offset_from(data) as libc::c_long as libc::c_int,
                            data,
                        );
                        data = data
                            .offset(
                                strnlen(
                                    data as *mut libc::c_char,
                                    end.offset_from(data) as libc::c_long as size_t,
                                ) as isize,
                            );
                        if data < end {
                            data = data.offset(1);
                            data;
                        }
                    }
                    if data >= end.offset(-(1 as libc::c_int as isize)) {
                        break;
                    }
                }
                if data < end {
                    data = data.offset(1);
                    data;
                }
                if data >= end || *data as libc::c_int == 0 as libc::c_int {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\n The File Name Table is empty.\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\n The File Name Table (offset 0x%lx):\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        data.offset_from(start) as libc::c_long,
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  Entry\tDir\tTime\tSize\tName\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    while data < end && *data as libc::c_int != 0 as libc::c_int {
                        let mut name: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                        let mut val: dwarf_vma = 0;
                        state_machine_regs
                            .last_file_entry = (state_machine_regs.last_file_entry)
                            .wrapping_add(1);
                        printf(
                            b"  %d\t\0" as *const u8 as *const libc::c_char,
                            state_machine_regs.last_file_entry,
                        );
                        name = data;
                        data = data
                            .offset(
                                strnlen(
                                    data as *mut libc::c_char,
                                    end.offset_from(data) as libc::c_long as size_t,
                                ) as isize,
                            );
                        if data < end {
                            data = data.offset(1);
                            data;
                        }
                        let mut _val: dwarf_vma = 0;
                        let mut _len: libc::c_uint = 0;
                        let mut _status: libc::c_int = 0;
                        _val = read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len,
                            &mut _status,
                        );
                        data = data.offset(_len as isize);
                        val = _val;
                        if val != _val {
                            _status |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            4517 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            b"%s\t\0" as *const u8 as *const libc::c_char,
                            dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
                        );
                        let mut _val_0: dwarf_vma = 0;
                        let mut _len_0: libc::c_uint = 0;
                        let mut _status_0: libc::c_int = 0;
                        _val_0 = read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_0,
                            &mut _status_0,
                        );
                        data = data.offset(_len_0 as isize);
                        val = _val_0;
                        if val != _val_0 {
                            _status_0 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_0,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            4519 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            b"%s\t\0" as *const u8 as *const libc::c_char,
                            dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
                        );
                        let mut _val_1: dwarf_vma = 0;
                        let mut _len_1: libc::c_uint = 0;
                        let mut _status_1: libc::c_int = 0;
                        _val_1 = read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_1,
                            &mut _status_1,
                        );
                        data = data.offset(_len_1 as isize);
                        val = _val_1;
                        if val != _val_1 {
                            _status_1 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_1,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            4521 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            b"%s\t\0" as *const u8 as *const libc::c_char,
                            dwarf_vmatoa(b"u\0" as *const u8 as *const libc::c_char, val),
                        );
                        printf(
                            b"%.*s\n\0" as *const u8 as *const libc::c_char,
                            end.offset_from(name) as libc::c_long as libc::c_int,
                            name,
                        );
                        if !(data >= end) {
                            continue;
                        }
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Corrupt file name table entry\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        break;
                    }
                }
                if data < end {
                    data = data.offset(1);
                    data;
                }
            }
            putchar('\n' as i32);
            saved_linfo = linfo;
        }
        if data >= end_of_sequence {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" No Line Number Statements.\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b" Line Number Statements:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            while data < end_of_sequence {
                let mut op_code: libc::c_uchar = 0;
                let mut adv: dwarf_signed_vma = 0;
                let mut uladv: dwarf_vma = 0;
                printf(
                    b"  [0x%08lx]\0" as *const u8 as *const libc::c_char,
                    data.offset_from(start) as libc::c_long,
                );
                let fresh19 = data;
                data = data.offset(1);
                op_code = *fresh19;
                if op_code as libc::c_int >= linfo.li_opcode_base as libc::c_int {
                    op_code = (op_code as libc::c_int
                        - linfo.li_opcode_base as libc::c_int) as libc::c_uchar;
                    uladv = (op_code as libc::c_int / linfo.li_line_range as libc::c_int)
                        as dwarf_vma;
                    if linfo.li_max_ops_per_insn as libc::c_int == 1 as libc::c_int {
                        uladv = (uladv as libc::c_ulong)
                            .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                            as dwarf_vma as dwarf_vma;
                        state_machine_regs
                            .address = (state_machine_regs.address as libc::c_ulong)
                            .wrapping_add(uladv) as dwarf_vma as dwarf_vma;
                        if uladv != 0 {
                            state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                        }
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Special opcode %d: advance Address by %s to 0x%s%s\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            op_code as libc::c_int,
                            dwarf_vmatoa(
                                b"u\0" as *const u8 as *const libc::c_char,
                                uladv,
                            ),
                            dwarf_vmatoa(
                                b"x\0" as *const u8 as *const libc::c_char,
                                state_machine_regs.address,
                            ),
                            if verbose_view != 0 && uladv != 0 {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" (reset view)\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ) as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                        );
                    } else {
                        let mut addrdelta: libc::c_uint = (state_machine_regs.op_index
                            as libc::c_ulong)
                            .wrapping_add(uladv)
                            .wrapping_div(linfo.li_max_ops_per_insn as libc::c_ulong)
                            .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                            as libc::c_uint;
                        state_machine_regs
                            .address = (state_machine_regs.address as libc::c_ulong)
                            .wrapping_add(addrdelta as libc::c_ulong) as dwarf_vma
                            as dwarf_vma;
                        state_machine_regs
                            .op_index = (state_machine_regs.op_index as libc::c_ulong)
                            .wrapping_add(uladv)
                            .wrapping_rem(linfo.li_max_ops_per_insn as libc::c_ulong)
                            as libc::c_uchar;
                        if addrdelta != 0 {
                            state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                        }
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Special opcode %d: advance Address by %s to 0x%s[%d]%s\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            op_code as libc::c_int,
                            dwarf_vmatoa(
                                b"u\0" as *const u8 as *const libc::c_char,
                                uladv,
                            ),
                            dwarf_vmatoa(
                                b"x\0" as *const u8 as *const libc::c_char,
                                state_machine_regs.address,
                            ),
                            state_machine_regs.op_index as libc::c_int,
                            if verbose_view != 0 && addrdelta != 0 {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" (reset view)\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ) as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                        );
                    }
                    adv = (op_code as libc::c_int % linfo.li_line_range as libc::c_int
                        + linfo.li_line_base) as dwarf_signed_vma;
                    state_machine_regs
                        .line = (state_machine_regs.line as libc::c_long + adv)
                        as libc::c_uint;
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" and Line by %s to %d\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        dwarf_vmatoa(
                            b"d\0" as *const u8 as *const libc::c_char,
                            adv as dwarf_vma,
                        ),
                        state_machine_regs.line,
                    );
                    if verbose_view != 0 || state_machine_regs.view != 0 {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" (view %u)\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            state_machine_regs.view,
                        );
                    } else {
                        putchar('\n' as i32);
                    }
                    state_machine_regs.view = (state_machine_regs.view).wrapping_add(1);
                    state_machine_regs.view;
                } else {
                    match op_code as libc::c_int {
                        0 => {
                            data = data
                                .offset(
                                    process_extended_line_op(
                                        data,
                                        linfo.li_default_is_stmt as libc::c_int,
                                        end,
                                    ) as isize,
                                );
                        }
                        1 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Copy\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            if verbose_view != 0 || state_machine_regs.view != 0 {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b" (view %u)\n\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    state_machine_regs.view,
                                );
                            } else {
                                putchar('\n' as i32);
                            }
                            state_machine_regs
                                .view = (state_machine_regs.view).wrapping_add(1);
                            state_machine_regs.view;
                        }
                        2 => {
                            let mut _val_2: dwarf_vma = 0;
                            let mut _len_2: libc::c_uint = 0;
                            let mut _status_2: libc::c_int = 0;
                            _val_2 = read_leb128(
                                data,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_2,
                                &mut _status_2,
                            );
                            data = data.offset(_len_2 as isize);
                            uladv = _val_2;
                            if uladv != _val_2 {
                                _status_2 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_2,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                4626 as libc::c_int as libc::c_ulong,
                            );
                            if linfo.li_max_ops_per_insn as libc::c_int
                                == 1 as libc::c_int
                            {
                                uladv = (uladv as libc::c_ulong)
                                    .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                                    as dwarf_vma as dwarf_vma;
                                state_machine_regs
                                    .address = (state_machine_regs.address as libc::c_ulong)
                                    .wrapping_add(uladv) as dwarf_vma as dwarf_vma;
                                if uladv != 0 {
                                    state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                                }
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"  Advance PC by %s to 0x%s%s\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    dwarf_vmatoa(
                                        b"u\0" as *const u8 as *const libc::c_char,
                                        uladv,
                                    ),
                                    dwarf_vmatoa(
                                        b"x\0" as *const u8 as *const libc::c_char,
                                        state_machine_regs.address,
                                    ),
                                    if verbose_view != 0 && uladv != 0 {
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" (reset view)\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ) as *const libc::c_char
                                    } else {
                                        b"\0" as *const u8 as *const libc::c_char
                                    },
                                );
                            } else {
                                let mut addrdelta_0: libc::c_uint = (state_machine_regs
                                    .op_index as libc::c_ulong)
                                    .wrapping_add(uladv)
                                    .wrapping_div(linfo.li_max_ops_per_insn as libc::c_ulong)
                                    .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                                    as libc::c_uint;
                                state_machine_regs
                                    .address = (state_machine_regs.address as libc::c_ulong)
                                    .wrapping_add(addrdelta_0 as libc::c_ulong) as dwarf_vma
                                    as dwarf_vma;
                                state_machine_regs
                                    .op_index = (state_machine_regs.op_index as libc::c_ulong)
                                    .wrapping_add(uladv)
                                    .wrapping_rem(linfo.li_max_ops_per_insn as libc::c_ulong)
                                    as libc::c_uchar;
                                if addrdelta_0 != 0 {
                                    state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                                }
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"  Advance PC by %s to 0x%s[%d]%s\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    dwarf_vmatoa(
                                        b"u\0" as *const u8 as *const libc::c_char,
                                        uladv,
                                    ),
                                    dwarf_vmatoa(
                                        b"x\0" as *const u8 as *const libc::c_char,
                                        state_machine_regs.address,
                                    ),
                                    state_machine_regs.op_index as libc::c_int,
                                    if verbose_view != 0 && addrdelta_0 != 0 {
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" (reset view)\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ) as *const libc::c_char
                                    } else {
                                        b"\0" as *const u8 as *const libc::c_char
                                    },
                                );
                            }
                        }
                        3 => {
                            let mut _val_3: dwarf_signed_vma = 0;
                            let mut _len_3: libc::c_uint = 0;
                            let mut _status_3: libc::c_int = 0;
                            _val_3 = read_leb128(
                                data,
                                end,
                                1 as libc::c_int != 0,
                                &mut _len_3,
                                &mut _status_3,
                            ) as dwarf_signed_vma;
                            data = data.offset(_len_3 as isize);
                            adv = _val_3;
                            if adv != _val_3 {
                                _status_3 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_3,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                4662 as libc::c_int as libc::c_ulong,
                            );
                            state_machine_regs
                                .line = (state_machine_regs.line as libc::c_long + adv)
                                as libc::c_uint;
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Advance Line by %s to %d\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dwarf_vmatoa(
                                    b"d\0" as *const u8 as *const libc::c_char,
                                    adv as dwarf_vma,
                                ),
                                state_machine_regs.line,
                            );
                        }
                        4 => {
                            let mut _val_4: dwarf_vma = 0;
                            let mut _len_4: libc::c_uint = 0;
                            let mut _status_4: libc::c_int = 0;
                            _val_4 = read_leb128(
                                data,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_4,
                                &mut _status_4,
                            );
                            data = data.offset(_len_4 as isize);
                            uladv = _val_4;
                            if uladv != _val_4 {
                                _status_4 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_4,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                4670 as libc::c_int as libc::c_ulong,
                            );
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Set File Name to entry %s in the File Name Table\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dwarf_vmatoa(
                                    b"u\0" as *const u8 as *const libc::c_char,
                                    uladv,
                                ),
                            );
                            state_machine_regs.file = uladv as libc::c_uint;
                        }
                        5 => {
                            let mut _val_5: dwarf_vma = 0;
                            let mut _len_5: libc::c_uint = 0;
                            let mut _status_5: libc::c_int = 0;
                            _val_5 = read_leb128(
                                data,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_5,
                                &mut _status_5,
                            );
                            data = data.offset(_len_5 as isize);
                            uladv = _val_5;
                            if uladv != _val_5 {
                                _status_5 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_5,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                4677 as libc::c_int as libc::c_ulong,
                            );
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Set column to %s\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dwarf_vmatoa(
                                    b"u\0" as *const u8 as *const libc::c_char,
                                    uladv,
                                ),
                            );
                            state_machine_regs.column = uladv as libc::c_uint;
                        }
                        6 => {
                            adv = state_machine_regs.is_stmt as dwarf_signed_vma;
                            adv = (adv == 0) as libc::c_int as dwarf_signed_vma;
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Set is_stmt to %s\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dwarf_vmatoa(
                                    b"d\0" as *const u8 as *const libc::c_char,
                                    adv as dwarf_vma,
                                ),
                            );
                            state_machine_regs.is_stmt = adv as libc::c_int;
                        }
                        7 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Set basic block\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            state_machine_regs.basic_block = 1 as libc::c_int;
                        }
                        8 => {
                            uladv = ((255 as libc::c_int
                                - linfo.li_opcode_base as libc::c_int)
                                / linfo.li_line_range as libc::c_int) as dwarf_vma;
                            if linfo.li_max_ops_per_insn != 0 {
                                uladv = (uladv as libc::c_ulong)
                                    .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                                    as dwarf_vma as dwarf_vma;
                                state_machine_regs
                                    .address = (state_machine_regs.address as libc::c_ulong)
                                    .wrapping_add(uladv) as dwarf_vma as dwarf_vma;
                                if uladv != 0 {
                                    state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                                }
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"  Advance PC by constant %s to 0x%s%s\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    dwarf_vmatoa(
                                        b"u\0" as *const u8 as *const libc::c_char,
                                        uladv,
                                    ),
                                    dwarf_vmatoa(
                                        b"x\0" as *const u8 as *const libc::c_char,
                                        state_machine_regs.address,
                                    ),
                                    if verbose_view != 0 && uladv != 0 {
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" (reset view)\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ) as *const libc::c_char
                                    } else {
                                        b"\0" as *const u8 as *const libc::c_char
                                    },
                                );
                            } else {
                                let mut addrdelta_1: libc::c_uint = (state_machine_regs
                                    .op_index as libc::c_ulong)
                                    .wrapping_add(uladv)
                                    .wrapping_div(linfo.li_max_ops_per_insn as libc::c_ulong)
                                    .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                                    as libc::c_uint;
                                state_machine_regs
                                    .address = (state_machine_regs.address as libc::c_ulong)
                                    .wrapping_add(addrdelta_1 as libc::c_ulong) as dwarf_vma
                                    as dwarf_vma;
                                state_machine_regs
                                    .op_index = (state_machine_regs.op_index as libc::c_ulong)
                                    .wrapping_add(uladv)
                                    .wrapping_rem(linfo.li_max_ops_per_insn as libc::c_ulong)
                                    as libc::c_uchar;
                                if addrdelta_1 != 0 {
                                    state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                                }
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"  Advance PC by constant %s to 0x%s[%d]%s\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    dwarf_vmatoa(
                                        b"u\0" as *const u8 as *const libc::c_char,
                                        uladv,
                                    ),
                                    dwarf_vmatoa(
                                        b"x\0" as *const u8 as *const libc::c_char,
                                        state_machine_regs.address,
                                    ),
                                    state_machine_regs.op_index as libc::c_int,
                                    if verbose_view != 0 && addrdelta_1 != 0 {
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" (reset view)\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ) as *const libc::c_char
                                    } else {
                                        b"\0" as *const u8 as *const libc::c_char
                                    },
                                );
                            }
                        }
                        9 => {
                            let mut amount: size_t = 2 as libc::c_int as size_t;
                            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                                < amount
                            {
                                error(
                                    dcngettext(
                                        0 as *const libc::c_char,
                                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        amount,
                                        5 as libc::c_int,
                                    ),
                                    amount as libc::c_int,
                                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                        as libc::c_int,
                                );
                                amount = ::core::mem::size_of::<dwarf_vma>()
                                    as libc::c_ulong;
                            }
                            let mut avail: size_t = end.offset_from(data) as libc::c_long
                                as size_t;
                            if data > end {
                                avail = 0 as libc::c_int as size_t;
                            }
                            if amount > avail {
                                amount = avail;
                            }
                            if amount == 0 as libc::c_int as libc::c_ulong {
                                uladv = 0 as libc::c_int as dwarf_vma;
                            } else {
                                uladv = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(data, amount as libc::c_uint);
                            }
                            data = data.offset(amount as isize);
                            state_machine_regs
                                .address = (state_machine_regs.address as libc::c_ulong)
                                .wrapping_add(uladv) as dwarf_vma as dwarf_vma;
                            state_machine_regs
                                .op_index = 0 as libc::c_int as libc::c_uchar;
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Advance PC by fixed size amount %s to 0x%s\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dwarf_vmatoa(
                                    b"u\0" as *const u8 as *const libc::c_char,
                                    uladv,
                                ),
                                dwarf_vmatoa(
                                    b"x\0" as *const u8 as *const libc::c_char,
                                    state_machine_regs.address,
                                ),
                            );
                        }
                        10 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Set prologue_end to true\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        11 => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Set epilogue_begin to true\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        12 => {
                            let mut _val_6: dwarf_vma = 0;
                            let mut _len_6: libc::c_uint = 0;
                            let mut _status_6: libc::c_int = 0;
                            _val_6 = read_leb128(
                                data,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_6,
                                &mut _status_6,
                            );
                            data = data.offset(_len_6 as isize);
                            uladv = _val_6;
                            if uladv != _val_6 {
                                _status_6 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_6,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                4750 as libc::c_int as libc::c_ulong,
                            );
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Set ISA to %s\n\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dwarf_vmatoa(
                                    b"u\0" as *const u8 as *const libc::c_char,
                                    uladv,
                                ),
                            );
                        }
                        _ => {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  Unknown opcode %d with operands: \0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                op_code as libc::c_int,
                            );
                            if !standard_opcodes.is_null() {
                                i = *standard_opcodes
                                    .offset(
                                        (op_code as libc::c_int - 1 as libc::c_int) as isize,
                                    ) as libc::c_int;
                                while i > 0 as libc::c_int {
                                    let mut _val_7: dwarf_vma = 0;
                                    let mut _len_7: libc::c_uint = 0;
                                    let mut _status_7: libc::c_int = 0;
                                    _val_7 = read_leb128(
                                        data,
                                        end,
                                        0 as libc::c_int != 0,
                                        &mut _len_7,
                                        &mut _status_7,
                                    );
                                    data = data.offset(_len_7 as isize);
                                    uladv = _val_7;
                                    if uladv != _val_7 {
                                        _status_7 |= 2 as libc::c_int;
                                    }
                                    report_leb_status(
                                        _status_7,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        4760 as libc::c_int as libc::c_ulong,
                                    );
                                    printf(
                                        b"0x%s%s\0" as *const u8 as *const libc::c_char,
                                        dwarf_vmatoa(
                                            b"x\0" as *const u8 as *const libc::c_char,
                                            uladv,
                                        ),
                                        if i == 1 as libc::c_int {
                                            b"\0" as *const u8 as *const libc::c_char
                                        } else {
                                            b", \0" as *const u8 as *const libc::c_char
                                        },
                                    );
                                    i -= 1;
                                    i;
                                }
                            }
                            putchar('\n' as i32);
                        }
                    }
                }
            }
            putchar('\n' as i32);
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_lines_decoded(
    mut section: *mut dwarf_section,
    mut start: *mut libc::c_uchar,
    mut data: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut fileptr: *mut libc::c_void,
) -> libc::c_int {
    static mut saved_linfo: DWARF2_Internal_LineInfo = DWARF2_Internal_LineInfo {
        li_length: 0,
        li_version: 0,
        li_address_size: 0,
        li_segment_size: 0,
        li_prologue_length: 0,
        li_min_insn_length: 0,
        li_max_ops_per_insn: 0,
        li_default_is_stmt: 0,
        li_line_base: 0,
        li_line_range: 0,
        li_opcode_base: 0,
        li_offset_size: 0,
    };
    introduce(section, 0 as libc::c_int != 0);
    while data < end {
        let mut linfo: DWARF2_Internal_LineInfo = DWARF2_Internal_LineInfo {
            li_length: 0,
            li_version: 0,
            li_address_size: 0,
            li_segment_size: 0,
            li_prologue_length: 0,
            li_min_insn_length: 0,
            li_max_ops_per_insn: 0,
            li_default_is_stmt: 0,
            li_line_base: 0,
            li_line_range: 0,
            li_opcode_base: 0,
            li_offset_size: 0,
        };
        let mut standard_opcodes: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut end_of_sequence: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut i: libc::c_int = 0;
        let mut file_table: *mut File_Entry = 0 as *mut File_Entry;
        let mut n_files: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        let mut directory_table: *mut *mut libc::c_uchar = 0 as *mut *mut libc::c_uchar;
        let mut n_directories: dwarf_vma = 0 as libc::c_int as dwarf_vma;
        if startswith(
            (*section).name,
            b".debug_line.\0" as *const u8 as *const libc::c_char,
        ) as libc::c_int != 0
            && strcmp(
                (*section).name,
                b".debug_line.dwo\0" as *const u8 as *const libc::c_char,
            ) != 0 as libc::c_int
        {
            end_of_sequence = end;
            standard_opcodes = 0 as *mut libc::c_uchar;
            linfo = saved_linfo;
            if linfo.li_line_range as libc::c_int == 0 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Partial .debug_line. section encountered without a prior full .debug_line section\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int;
            }
            reset_state_machine(linfo.li_default_is_stmt as libc::c_int);
        } else {
            let mut hdrptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            hdrptr = read_debug_line_header(
                section,
                data,
                end,
                &mut linfo,
                &mut end_of_sequence,
            );
            if hdrptr.is_null() {
                return 0 as libc::c_int;
            }
            if linfo.li_line_range as libc::c_int == 0 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Line range of 0 is invalid, using 1 instead\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                linfo.li_line_range = 1 as libc::c_int as libc::c_uchar;
            }
            reset_state_machine(linfo.li_default_is_stmt as libc::c_int);
            standard_opcodes = hdrptr;
            data = standard_opcodes
                .offset(linfo.li_opcode_base as libc::c_int as isize)
                .offset(-(1 as libc::c_int as isize));
            if data >= end {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"opcode base of %d extends beyond end of section\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    linfo.li_opcode_base as libc::c_int,
                );
                return 0 as libc::c_int;
            }
            if linfo.li_version as libc::c_int >= 5 as libc::c_int {
                let mut format_start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                let mut format_count: libc::c_uchar = 0;
                let mut format: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                let mut formati: dwarf_vma = 0;
                let mut entryi: dwarf_vma = 0;
                load_debug_section_with_follow(line_str, fileptr);
                let mut amount: size_t = 1 as libc::c_int as size_t;
                if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount,
                            5 as libc::c_int,
                        ),
                        amount as libc::c_int,
                        ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
                }
                let mut avail: size_t = end.offset_from(data) as libc::c_long as size_t;
                if data > end {
                    avail = 0 as libc::c_int as size_t;
                }
                if amount > avail {
                    amount = avail;
                }
                if amount == 0 as libc::c_int as libc::c_ulong {
                    format_count = 0 as libc::c_int as libc::c_uchar;
                } else {
                    format_count = byte_get
                        .expect(
                            "non-null function pointer",
                        )(data, amount as libc::c_uint) as libc::c_uchar;
                }
                data = data.offset(amount as isize);
                if do_checks as libc::c_int != 0
                    && format_count as libc::c_int > 1 as libc::c_int
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unexpectedly large number of columns in the directory name table (%u)\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        format_count as libc::c_int,
                    );
                }
                format_start = data;
                formati = 0 as libc::c_int as dwarf_vma;
                while formati < format_count as libc::c_ulong {
                    let mut _len: libc::c_uint = 0;
                    read_leb128(
                        data,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len,
                        0 as *mut libc::c_int,
                    );
                    data = data.offset(_len as isize);
                    let mut _len_0: libc::c_uint = 0;
                    read_leb128(
                        data,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_0,
                        0 as *mut libc::c_int,
                    );
                    data = data.offset(_len_0 as isize);
                    formati = formati.wrapping_add(1);
                    formati;
                }
                let mut _val: dwarf_vma = 0;
                let mut _len_1: libc::c_uint = 0;
                let mut _status: libc::c_int = 0;
                _val = read_leb128(
                    data,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_1,
                    &mut _status,
                );
                data = data.offset(_len_1 as isize);
                n_directories = _val;
                if n_directories != _val {
                    _status |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    4873 as libc::c_int as libc::c_ulong,
                );
                if data >= end {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Corrupt directories list\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    break;
                } else {
                    if n_directories == 0 as libc::c_int as libc::c_ulong {
                        directory_table = 0 as *mut *mut libc::c_uchar;
                    } else {
                        directory_table = xmalloc(
                            n_directories
                                .wrapping_mul(
                                    ::core::mem::size_of::<*mut libc::c_uchar>()
                                        as libc::c_ulong,
                                ),
                        ) as *mut *mut libc::c_uchar;
                    }
                    entryi = 0 as libc::c_int as dwarf_vma;
                    while entryi < n_directories {
                        let mut pathp: *mut *mut libc::c_uchar = &mut *directory_table
                            .offset(entryi as isize) as *mut *mut libc::c_uchar;
                        format = format_start;
                        formati = 0 as libc::c_int as dwarf_vma;
                        while formati < format_count as libc::c_ulong {
                            let mut content_type: dwarf_vma = 0;
                            let mut form: dwarf_vma = 0;
                            let mut uvalue: dwarf_vma = 0;
                            let mut _val_0: dwarf_vma = 0;
                            let mut _len_2: libc::c_uint = 0;
                            let mut _status_0: libc::c_int = 0;
                            _val_0 = read_leb128(
                                format,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_2,
                                &mut _status_0,
                            );
                            format = format.offset(_len_2 as isize);
                            content_type = _val_0;
                            if content_type != _val_0 {
                                _status_0 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_0,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                4896 as libc::c_int as libc::c_ulong,
                            );
                            let mut _val_1: dwarf_vma = 0;
                            let mut _len_3: libc::c_uint = 0;
                            let mut _status_1: libc::c_int = 0;
                            _val_1 = read_leb128(
                                format,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_3,
                                &mut _status_1,
                            );
                            format = format.offset(_len_3 as isize);
                            form = _val_1;
                            if form != _val_1 {
                                _status_1 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_1,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                4897 as libc::c_int as libc::c_ulong,
                            );
                            if data >= end {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Corrupt directories list\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                break;
                            } else {
                                match content_type {
                                    1 => {
                                        match form {
                                            8 => {
                                                *pathp = data;
                                            }
                                            31 => {
                                                let mut amount_0: size_t = linfo.li_offset_size as size_t;
                                                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                                                    < amount_0
                                                {
                                                    error(
                                                        dcngettext(
                                                            0 as *const libc::c_char,
                                                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                                as *const u8 as *const libc::c_char,
                                                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                                as *const u8 as *const libc::c_char,
                                                            amount_0,
                                                            5 as libc::c_int,
                                                        ),
                                                        amount_0 as libc::c_int,
                                                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                                            as libc::c_int,
                                                    );
                                                    amount_0 = ::core::mem::size_of::<dwarf_vma>()
                                                        as libc::c_ulong;
                                                }
                                                let mut avail_0: size_t = end.offset_from(data)
                                                    as libc::c_long as size_t;
                                                if data > end {
                                                    avail_0 = 0 as libc::c_int as size_t;
                                                }
                                                if amount_0 > avail_0 {
                                                    amount_0 = avail_0;
                                                }
                                                if amount_0 == 0 as libc::c_int as libc::c_ulong {
                                                    uvalue = 0 as libc::c_int as dwarf_vma;
                                                } else {
                                                    uvalue = byte_get
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(data, amount_0 as libc::c_uint);
                                                }
                                                *pathp = fetch_indirect_line_string(uvalue)
                                                    as *mut libc::c_uchar;
                                            }
                                            _ => {}
                                        }
                                    }
                                    _ => {}
                                }
                                data = read_and_display_attr_value(
                                    0 as libc::c_int as libc::c_ulong,
                                    form,
                                    0 as libc::c_int as dwarf_signed_vma,
                                    start,
                                    data,
                                    end,
                                    0 as libc::c_int as dwarf_vma,
                                    0 as libc::c_int as dwarf_vma,
                                    linfo.li_offset_size as dwarf_vma,
                                    linfo.li_version as libc::c_int,
                                    0 as *mut debug_info,
                                    1 as libc::c_int,
                                    section,
                                    0 as *mut cu_tu_set,
                                    '\t' as i32 as libc::c_char,
                                    -(1 as libc::c_int),
                                );
                                formati = formati.wrapping_add(1);
                                formati;
                            }
                        }
                        if data >= end {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Corrupt directories list\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            break;
                        } else {
                            entryi = entryi.wrapping_add(1);
                            entryi;
                        }
                    }
                    let mut amount_1: size_t = 1 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
                        < amount_1
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_1,
                                5 as libc::c_int,
                            ),
                            amount_1 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_1 = ::core::mem::size_of::<libc::c_uchar>()
                            as libc::c_ulong;
                    }
                    let mut avail_1: size_t = end.offset_from(data) as libc::c_long
                        as size_t;
                    if data > end {
                        avail_1 = 0 as libc::c_int as size_t;
                    }
                    if amount_1 > avail_1 {
                        amount_1 = avail_1;
                    }
                    if amount_1 == 0 as libc::c_int as libc::c_ulong {
                        format_count = 0 as libc::c_int as libc::c_uchar;
                    } else {
                        format_count = byte_get
                            .expect(
                                "non-null function pointer",
                            )(data, amount_1 as libc::c_uint) as libc::c_uchar;
                    }
                    data = data.offset(amount_1 as isize);
                    if do_checks as libc::c_int != 0
                        && format_count as libc::c_int > 5 as libc::c_int
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Unexpectedly large number of columns in the file name table (%u)\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            format_count as libc::c_int,
                        );
                    }
                    format_start = data;
                    formati = 0 as libc::c_int as dwarf_vma;
                    while formati < format_count as libc::c_ulong {
                        let mut _len_4: libc::c_uint = 0;
                        read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_4,
                            0 as *mut libc::c_int,
                        );
                        data = data.offset(_len_4 as isize);
                        let mut _len_5: libc::c_uint = 0;
                        read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_5,
                            0 as *mut libc::c_int,
                        );
                        data = data.offset(_len_5 as isize);
                        formati = formati.wrapping_add(1);
                        formati;
                    }
                    let mut _val_2: dwarf_vma = 0;
                    let mut _len_6: libc::c_uint = 0;
                    let mut _status_2: libc::c_int = 0;
                    _val_2 = read_leb128(
                        data,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_6,
                        &mut _status_2,
                    );
                    data = data.offset(_len_6 as isize);
                    n_files = _val_2 as libc::c_uint;
                    if n_files as libc::c_ulong != _val_2 {
                        _status_2 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_2,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        4947 as libc::c_int as libc::c_ulong,
                    );
                    if data >= end && n_files > 0 as libc::c_int as libc::c_uint {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Corrupt file name list\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        break;
                    } else {
                        if n_files == 0 as libc::c_int as libc::c_uint {
                            file_table = 0 as *mut File_Entry;
                        } else {
                            file_table = xcalloc(
                                1 as libc::c_int as size_t,
                                (n_files as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<File_Entry>() as libc::c_ulong,
                                    ),
                            ) as *mut File_Entry;
                        }
                        entryi = 0 as libc::c_int as dwarf_vma;
                        while entryi < n_files as libc::c_ulong {
                            let mut file: *mut File_Entry = &mut *file_table
                                .offset(entryi as isize) as *mut File_Entry;
                            format = format_start;
                            formati = 0 as libc::c_int as dwarf_vma;
                            while formati < format_count as libc::c_ulong {
                                let mut content_type_0: dwarf_vma = 0;
                                let mut form_0: dwarf_vma = 0;
                                let mut uvalue_0: dwarf_vma = 0;
                                let mut tmp: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                                let mut _val_3: dwarf_vma = 0;
                                let mut _len_7: libc::c_uint = 0;
                                let mut _status_3: libc::c_int = 0;
                                _val_3 = read_leb128(
                                    format,
                                    end,
                                    0 as libc::c_int != 0,
                                    &mut _len_7,
                                    &mut _status_3,
                                );
                                format = format.offset(_len_7 as isize);
                                content_type_0 = _val_3;
                                if content_type_0 != _val_3 {
                                    _status_3 |= 2 as libc::c_int;
                                }
                                report_leb_status(
                                    _status_3,
                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                    4971 as libc::c_int as libc::c_ulong,
                                );
                                let mut _val_4: dwarf_vma = 0;
                                let mut _len_8: libc::c_uint = 0;
                                let mut _status_4: libc::c_int = 0;
                                _val_4 = read_leb128(
                                    format,
                                    end,
                                    0 as libc::c_int != 0,
                                    &mut _len_8,
                                    &mut _status_4,
                                );
                                format = format.offset(_len_8 as isize);
                                form_0 = _val_4;
                                if form_0 != _val_4 {
                                    _status_4 |= 2 as libc::c_int;
                                }
                                report_leb_status(
                                    _status_4,
                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                    4972 as libc::c_int as libc::c_ulong,
                                );
                                if data >= end {
                                    warn(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Corrupt file name list\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    break;
                                } else {
                                    match content_type_0 {
                                        1 => {
                                            match form_0 {
                                                8 => {
                                                    (*file).name = data;
                                                }
                                                31 => {
                                                    let mut amount_2: size_t = linfo.li_offset_size as size_t;
                                                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                                                        < amount_2
                                                    {
                                                        error(
                                                            dcngettext(
                                                                0 as *const libc::c_char,
                                                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                amount_2,
                                                                5 as libc::c_int,
                                                            ),
                                                            amount_2 as libc::c_int,
                                                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                                                as libc::c_int,
                                                        );
                                                        amount_2 = ::core::mem::size_of::<dwarf_vma>()
                                                            as libc::c_ulong;
                                                    }
                                                    let mut avail_2: size_t = end.offset_from(data)
                                                        as libc::c_long as size_t;
                                                    if data > end {
                                                        avail_2 = 0 as libc::c_int as size_t;
                                                    }
                                                    if amount_2 > avail_2 {
                                                        amount_2 = avail_2;
                                                    }
                                                    if amount_2 == 0 as libc::c_int as libc::c_ulong {
                                                        uvalue_0 = 0 as libc::c_int as dwarf_vma;
                                                    } else {
                                                        uvalue_0 = byte_get
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(data, amount_2 as libc::c_uint);
                                                    }
                                                    (*file)
                                                        .name = fetch_indirect_line_string(uvalue_0)
                                                        as *mut libc::c_uchar;
                                                }
                                                _ => {}
                                            }
                                        }
                                        2 => {
                                            match form_0 {
                                                11 => {
                                                    let mut amount_3: size_t = 1 as libc::c_int as size_t;
                                                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                                                        < amount_3
                                                    {
                                                        error(
                                                            dcngettext(
                                                                0 as *const libc::c_char,
                                                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                amount_3,
                                                                5 as libc::c_int,
                                                            ),
                                                            amount_3 as libc::c_int,
                                                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                                                as libc::c_int,
                                                        );
                                                        amount_3 = ::core::mem::size_of::<libc::c_uint>()
                                                            as libc::c_ulong;
                                                    }
                                                    let mut avail_3: size_t = end.offset_from(data)
                                                        as libc::c_long as size_t;
                                                    if data > end {
                                                        avail_3 = 0 as libc::c_int as size_t;
                                                    }
                                                    if amount_3 > avail_3 {
                                                        amount_3 = avail_3;
                                                    }
                                                    if amount_3 == 0 as libc::c_int as libc::c_ulong {
                                                        (*file).directory_index = 0 as libc::c_int as libc::c_uint;
                                                    } else {
                                                        (*file)
                                                            .directory_index = byte_get
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(data, amount_3 as libc::c_uint) as libc::c_uint;
                                                    }
                                                }
                                                5 => {
                                                    let mut amount_4: size_t = 2 as libc::c_int as size_t;
                                                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                                                        < amount_4
                                                    {
                                                        error(
                                                            dcngettext(
                                                                0 as *const libc::c_char,
                                                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                amount_4,
                                                                5 as libc::c_int,
                                                            ),
                                                            amount_4 as libc::c_int,
                                                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                                                as libc::c_int,
                                                        );
                                                        amount_4 = ::core::mem::size_of::<libc::c_uint>()
                                                            as libc::c_ulong;
                                                    }
                                                    let mut avail_4: size_t = end.offset_from(data)
                                                        as libc::c_long as size_t;
                                                    if data > end {
                                                        avail_4 = 0 as libc::c_int as size_t;
                                                    }
                                                    if amount_4 > avail_4 {
                                                        amount_4 = avail_4;
                                                    }
                                                    if amount_4 == 0 as libc::c_int as libc::c_ulong {
                                                        (*file).directory_index = 0 as libc::c_int as libc::c_uint;
                                                    } else {
                                                        (*file)
                                                            .directory_index = byte_get
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(data, amount_4 as libc::c_uint) as libc::c_uint;
                                                    }
                                                }
                                                15 => {
                                                    tmp = data;
                                                    let mut _val_5: dwarf_vma = 0;
                                                    let mut _len_9: libc::c_uint = 0;
                                                    let mut _status_5: libc::c_int = 0;
                                                    _val_5 = read_leb128(
                                                        tmp,
                                                        end,
                                                        0 as libc::c_int != 0,
                                                        &mut _len_9,
                                                        &mut _status_5,
                                                    );
                                                    tmp = tmp.offset(_len_9 as isize);
                                                    (*file).directory_index = _val_5 as libc::c_uint;
                                                    if (*file).directory_index as libc::c_ulong != _val_5 {
                                                        _status_5 |= 2 as libc::c_int;
                                                    }
                                                    report_leb_status(
                                                        _status_5,
                                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                                        5008 as libc::c_int as libc::c_ulong,
                                                    );
                                                }
                                                _ => {}
                                            }
                                        }
                                        _ => {}
                                    }
                                    data = read_and_display_attr_value(
                                        0 as libc::c_int as libc::c_ulong,
                                        form_0,
                                        0 as libc::c_int as dwarf_signed_vma,
                                        start,
                                        data,
                                        end,
                                        0 as libc::c_int as dwarf_vma,
                                        0 as libc::c_int as dwarf_vma,
                                        linfo.li_offset_size as dwarf_vma,
                                        linfo.li_version as libc::c_int,
                                        0 as *mut debug_info,
                                        1 as libc::c_int,
                                        section,
                                        0 as *mut cu_tu_set,
                                        '\t' as i32 as libc::c_char,
                                        -(1 as libc::c_int),
                                    );
                                    formati = formati.wrapping_add(1);
                                    formati;
                                }
                            }
                            if data >= end {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Corrupt file name list\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                break;
                            } else {
                                entryi = entryi.wrapping_add(1);
                                entryi;
                            }
                        }
                    }
                }
            } else {
                if *data as libc::c_int != 0 as libc::c_int {
                    let mut ptr_directory_table: *mut libc::c_uchar = data;
                    while data < end && *data as libc::c_int != 0 as libc::c_int {
                        data = data
                            .offset(
                                strnlen(
                                    data as *mut libc::c_char,
                                    end.offset_from(data) as libc::c_long as size_t,
                                ) as isize,
                            );
                        if data < end {
                            data = data.offset(1);
                            data;
                        }
                        n_directories = n_directories.wrapping_add(1);
                        n_directories;
                    }
                    if data >= end {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"directory table ends unexpectedly\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        n_directories = 0 as libc::c_int as dwarf_vma;
                        break;
                    } else {
                        directory_table = xmalloc(
                            n_directories
                                .wrapping_mul(
                                    ::core::mem::size_of::<*mut libc::c_uchar>()
                                        as libc::c_ulong,
                                ),
                        ) as *mut *mut libc::c_uchar;
                        i = 0 as libc::c_int;
                        while *ptr_directory_table as libc::c_int != 0 as libc::c_int {
                            let ref mut fresh20 = *directory_table.offset(i as isize);
                            *fresh20 = ptr_directory_table;
                            ptr_directory_table = ptr_directory_table
                                .offset(
                                    (strlen(ptr_directory_table as *mut libc::c_char))
                                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                );
                            i += 1;
                            i;
                        }
                    }
                }
                data = data.offset(1);
                data;
                if data < end && *data as libc::c_int != 0 as libc::c_int {
                    let mut ptr_file_name_table: *mut libc::c_uchar = data;
                    while data < end && *data as libc::c_int != 0 as libc::c_int {
                        data = data
                            .offset(
                                strnlen(
                                    data as *mut libc::c_char,
                                    end.offset_from(data) as libc::c_long as size_t,
                                ) as isize,
                            );
                        if data < end {
                            data = data.offset(1);
                            data;
                        }
                        let mut _len_10: libc::c_uint = 0;
                        read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_10,
                            0 as *mut libc::c_int,
                        );
                        data = data.offset(_len_10 as isize);
                        let mut _len_11: libc::c_uint = 0;
                        read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_11,
                            0 as *mut libc::c_int,
                        );
                        data = data.offset(_len_11 as isize);
                        let mut _len_12: libc::c_uint = 0;
                        read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_12,
                            0 as *mut libc::c_int,
                        );
                        data = data.offset(_len_12 as isize);
                        n_files = n_files.wrapping_add(1);
                        n_files;
                    }
                    if data >= end {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"file table ends unexpectedly\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        n_files = 0 as libc::c_int as libc::c_uint;
                        break;
                    } else {
                        file_table = xmalloc(
                            (n_files as libc::c_ulong)
                                .wrapping_mul(
                                    ::core::mem::size_of::<File_Entry>() as libc::c_ulong,
                                ),
                        ) as *mut File_Entry;
                        i = 0 as libc::c_int;
                        while *ptr_file_name_table as libc::c_int != 0 as libc::c_int {
                            let ref mut fresh21 = (*file_table.offset(i as isize)).name;
                            *fresh21 = ptr_file_name_table;
                            ptr_file_name_table = ptr_file_name_table
                                .offset(
                                    (strlen(ptr_file_name_table as *mut libc::c_char))
                                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                );
                            let mut _val_6: dwarf_vma = 0;
                            let mut _len_13: libc::c_uint = 0;
                            let mut _status_6: libc::c_int = 0;
                            _val_6 = read_leb128(
                                ptr_file_name_table,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_13,
                                &mut _status_6,
                            );
                            ptr_file_name_table = ptr_file_name_table
                                .offset(_len_13 as isize);
                            (*file_table.offset(i as isize))
                                .directory_index = _val_6 as libc::c_uint;
                            if (*file_table.offset(i as isize)).directory_index
                                as libc::c_ulong != _val_6
                            {
                                _status_6 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_6,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                5102 as libc::c_int as libc::c_ulong,
                            );
                            let mut _val_7: dwarf_vma = 0;
                            let mut _len_14: libc::c_uint = 0;
                            let mut _status_7: libc::c_int = 0;
                            _val_7 = read_leb128(
                                ptr_file_name_table,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_14,
                                &mut _status_7,
                            );
                            ptr_file_name_table = ptr_file_name_table
                                .offset(_len_14 as isize);
                            (*file_table.offset(i as isize))
                                .modification_date = _val_7 as libc::c_uint;
                            if (*file_table.offset(i as isize)).modification_date
                                as libc::c_ulong != _val_7
                            {
                                _status_7 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_7,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                5104 as libc::c_int as libc::c_ulong,
                            );
                            let mut _val_8: dwarf_vma = 0;
                            let mut _len_15: libc::c_uint = 0;
                            let mut _status_8: libc::c_int = 0;
                            _val_8 = read_leb128(
                                ptr_file_name_table,
                                end,
                                0 as libc::c_int != 0,
                                &mut _len_15,
                                &mut _status_8,
                            );
                            ptr_file_name_table = ptr_file_name_table
                                .offset(_len_15 as isize);
                            (*file_table.offset(i as isize))
                                .length = _val_8 as libc::c_uint;
                            if (*file_table.offset(i as isize)).length as libc::c_ulong
                                != _val_8
                            {
                                _status_8 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_8,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                5106 as libc::c_int as libc::c_ulong,
                            );
                            i += 1;
                            i;
                        }
                        i = 0 as libc::c_int;
                    }
                }
                data = data.offset(1);
                data;
            }
            if file_table.is_null() {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"CU: No directory table\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else if directory_table.is_null() {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"CU: %s:\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*file_table.offset(0 as libc::c_int as isize)).name,
                );
            } else {
                let mut ix: libc::c_uint = (*file_table
                    .offset(0 as libc::c_int as isize))
                    .directory_index;
                let mut directory: *const libc::c_char = 0 as *const libc::c_char;
                if ix == 0 as libc::c_int as libc::c_uint {
                    directory = b".\0" as *const u8 as *const libc::c_char;
                } else if n_directories == 0 as libc::c_int as libc::c_ulong {
                    directory = dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    );
                } else if ix as libc::c_ulong > n_directories {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"directory index %u > number of directories %s\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        ix,
                        dwarf_vmatoa(
                            b"u\0" as *const u8 as *const libc::c_char,
                            n_directories,
                        ),
                    );
                    directory = dcgettext(
                        0 as *const libc::c_char,
                        b"<corrupt>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    );
                } else {
                    directory = *directory_table
                        .offset(
                            ix.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                        ) as *mut libc::c_char;
                }
                if do_wide != 0 || strlen(directory) < 76 as libc::c_int as libc::c_ulong
                {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"CU: %s/%s:\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        directory,
                        (*file_table.offset(0 as libc::c_int as isize)).name,
                    );
                } else {
                    printf(
                        b"%s:\n\0" as *const u8 as *const libc::c_char,
                        (*file_table.offset(0 as libc::c_int as isize)).name,
                    );
                }
            }
            if n_files > 0 as libc::c_int as libc::c_uint {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"File name                            Line number    Starting address    View    Stmt\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"CU: Empty file name table\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            saved_linfo = linfo;
        }
        while data < end_of_sequence {
            let mut op_code: libc::c_uchar = 0;
            let mut xop: libc::c_int = 0;
            let mut adv: libc::c_int = 0;
            let mut uladv: libc::c_ulong = 0;
            let mut is_special_opcode: libc::c_int = 0 as libc::c_int;
            let fresh22 = data;
            data = data.offset(1);
            op_code = *fresh22;
            xop = op_code as libc::c_int;
            if op_code as libc::c_int >= linfo.li_opcode_base as libc::c_int {
                op_code = (op_code as libc::c_int - linfo.li_opcode_base as libc::c_int)
                    as libc::c_uchar;
                uladv = (op_code as libc::c_int / linfo.li_line_range as libc::c_int)
                    as libc::c_ulong;
                if linfo.li_max_ops_per_insn as libc::c_int == 1 as libc::c_int {
                    uladv = uladv
                        .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong);
                    state_machine_regs
                        .address = (state_machine_regs.address as libc::c_ulong)
                        .wrapping_add(uladv) as dwarf_vma as dwarf_vma;
                    if uladv != 0 {
                        state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                    }
                } else {
                    let mut addrdelta: libc::c_uint = (state_machine_regs.op_index
                        as libc::c_ulong)
                        .wrapping_add(uladv)
                        .wrapping_div(linfo.li_max_ops_per_insn as libc::c_ulong)
                        .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                        as libc::c_uint;
                    state_machine_regs
                        .address = (state_machine_regs.address as libc::c_ulong)
                        .wrapping_add(addrdelta as libc::c_ulong) as dwarf_vma
                        as dwarf_vma;
                    state_machine_regs
                        .op_index = (state_machine_regs.op_index as libc::c_ulong)
                        .wrapping_add(uladv)
                        .wrapping_rem(linfo.li_max_ops_per_insn as libc::c_ulong)
                        as libc::c_uchar;
                    if addrdelta != 0 {
                        state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                    }
                }
                adv = op_code as libc::c_int % linfo.li_line_range as libc::c_int
                    + linfo.li_line_base;
                state_machine_regs
                    .line = (state_machine_regs.line).wrapping_add(adv as libc::c_uint);
                is_special_opcode = 1 as libc::c_int;
            } else {
                match op_code as libc::c_int {
                    0 => {
                        let mut ext_op_code_len: libc::c_uint = 0;
                        let mut ext_op_code: libc::c_uchar = 0;
                        let mut op_code_end: *mut libc::c_uchar = 0
                            as *mut libc::c_uchar;
                        let mut op_code_data: *mut libc::c_uchar = data;
                        let mut _val_9: dwarf_vma = 0;
                        let mut _len_16: libc::c_uint = 0;
                        let mut _status_9: libc::c_int = 0;
                        _val_9 = read_leb128(
                            op_code_data,
                            end_of_sequence,
                            0 as libc::c_int != 0,
                            &mut _len_16,
                            &mut _status_9,
                        );
                        op_code_data = op_code_data.offset(_len_16 as isize);
                        ext_op_code_len = _val_9 as libc::c_uint;
                        if ext_op_code_len as libc::c_ulong != _val_9 {
                            _status_9 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_9,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            5206 as libc::c_int as libc::c_ulong,
                        );
                        op_code_end = op_code_data.offset(ext_op_code_len as isize);
                        if ext_op_code_len == 0 as libc::c_int as libc::c_uint
                            || op_code_end > end_of_sequence
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Badly formed extended line op encountered!\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        } else {
                            let fresh23 = op_code_data;
                            op_code_data = op_code_data.offset(1);
                            ext_op_code = *fresh23;
                            xop = ext_op_code as libc::c_int;
                            xop = -xop;
                            match ext_op_code as libc::c_int {
                                2 => {
                                    let mut amount_5: size_t = op_code_end
                                        .offset_from(op_code_data) as libc::c_long as size_t;
                                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                                        < amount_5
                                    {
                                        error(
                                            dcngettext(
                                                0 as *const libc::c_char,
                                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                    as *const u8 as *const libc::c_char,
                                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                    as *const u8 as *const libc::c_char,
                                                amount_5,
                                                5 as libc::c_int,
                                            ),
                                            amount_5 as libc::c_int,
                                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                                as libc::c_int,
                                        );
                                        amount_5 = ::core::mem::size_of::<dwarf_vma>()
                                            as libc::c_ulong;
                                    }
                                    let mut avail_5: size_t = op_code_end
                                        .offset_from(op_code_data) as libc::c_long as size_t;
                                    if op_code_data > op_code_end {
                                        avail_5 = 0 as libc::c_int as size_t;
                                    }
                                    if amount_5 > avail_5 {
                                        amount_5 = avail_5;
                                    }
                                    if amount_5 == 0 as libc::c_int as libc::c_ulong {
                                        state_machine_regs.address = 0 as libc::c_int as dwarf_vma;
                                    } else {
                                        state_machine_regs
                                            .address = byte_get
                                            .expect(
                                                "non-null function pointer",
                                            )(op_code_data, amount_5 as libc::c_uint);
                                    }
                                    op_code_data = op_code_data.offset(amount_5 as isize);
                                    state_machine_regs
                                        .op_index = 0 as libc::c_int as libc::c_uchar;
                                    state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                                }
                                3 => {
                                    file_table = xrealloc(
                                        file_table as *mut libc::c_void,
                                        (n_files.wrapping_add(1 as libc::c_int as libc::c_uint)
                                            as libc::c_ulong)
                                            .wrapping_mul(
                                                ::core::mem::size_of::<File_Entry>() as libc::c_ulong,
                                            ),
                                    ) as *mut File_Entry;
                                    state_machine_regs
                                        .last_file_entry = (state_machine_regs.last_file_entry)
                                        .wrapping_add(1);
                                    state_machine_regs.last_file_entry;
                                    let ref mut fresh24 = (*file_table.offset(n_files as isize))
                                        .name;
                                    *fresh24 = op_code_data;
                                    op_code_data = op_code_data
                                        .offset(
                                            (strlen(op_code_data as *mut libc::c_char))
                                                .wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                        );
                                    let mut _val_10: dwarf_vma = 0;
                                    let mut _len_17: libc::c_uint = 0;
                                    let mut _status_10: libc::c_int = 0;
                                    _val_10 = read_leb128(
                                        op_code_data,
                                        op_code_end,
                                        0 as libc::c_int != 0,
                                        &mut _len_17,
                                        &mut _status_10,
                                    );
                                    op_code_data = op_code_data.offset(_len_17 as isize);
                                    (*file_table.offset(n_files as isize))
                                        .directory_index = _val_10 as libc::c_uint;
                                    if (*file_table.offset(n_files as isize)).directory_index
                                        as libc::c_ulong != _val_10
                                    {
                                        _status_10 |= 2 as libc::c_int;
                                    }
                                    report_leb_status(
                                        _status_10,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        5240 as libc::c_int as libc::c_ulong,
                                    );
                                    let mut _val_11: dwarf_vma = 0;
                                    let mut _len_18: libc::c_uint = 0;
                                    let mut _status_11: libc::c_int = 0;
                                    _val_11 = read_leb128(
                                        op_code_data,
                                        op_code_end,
                                        0 as libc::c_int != 0,
                                        &mut _len_18,
                                        &mut _status_11,
                                    );
                                    op_code_data = op_code_data.offset(_len_18 as isize);
                                    (*file_table.offset(n_files as isize))
                                        .modification_date = _val_11 as libc::c_uint;
                                    if (*file_table.offset(n_files as isize)).modification_date
                                        as libc::c_ulong != _val_11
                                    {
                                        _status_11 |= 2 as libc::c_int;
                                    }
                                    report_leb_status(
                                        _status_11,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        5243 as libc::c_int as libc::c_ulong,
                                    );
                                    let mut _val_12: dwarf_vma = 0;
                                    let mut _len_19: libc::c_uint = 0;
                                    let mut _status_12: libc::c_int = 0;
                                    _val_12 = read_leb128(
                                        op_code_data,
                                        op_code_end,
                                        0 as libc::c_int != 0,
                                        &mut _len_19,
                                        &mut _status_12,
                                    );
                                    op_code_data = op_code_data.offset(_len_19 as isize);
                                    (*file_table.offset(n_files as isize))
                                        .length = _val_12 as libc::c_uint;
                                    if (*file_table.offset(n_files as isize)).length
                                        as libc::c_ulong != _val_12
                                    {
                                        _status_12 |= 2 as libc::c_int;
                                    }
                                    report_leb_status(
                                        _status_12,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        5246 as libc::c_int as libc::c_ulong,
                                    );
                                    n_files = n_files.wrapping_add(1);
                                    n_files;
                                }
                                1 | 4 | 22 => {}
                                _ => {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"UNKNOWN (%u): length %ld\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        ext_op_code as libc::c_int,
                                        op_code_data.offset_from(data) as libc::c_long,
                                    );
                                }
                            }
                            data = op_code_end;
                        }
                    }
                    2 => {
                        let mut _val_13: dwarf_vma = 0;
                        let mut _len_20: libc::c_uint = 0;
                        let mut _status_13: libc::c_int = 0;
                        _val_13 = read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_20,
                            &mut _status_13,
                        );
                        data = data.offset(_len_20 as isize);
                        uladv = _val_13;
                        if uladv != _val_13 {
                            _status_13 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_13,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            5268 as libc::c_int as libc::c_ulong,
                        );
                        if linfo.li_max_ops_per_insn as libc::c_int == 1 as libc::c_int {
                            uladv = uladv
                                .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong);
                            state_machine_regs
                                .address = (state_machine_regs.address as libc::c_ulong)
                                .wrapping_add(uladv) as dwarf_vma as dwarf_vma;
                            if uladv != 0 {
                                state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                            }
                        } else {
                            let mut addrdelta_0: libc::c_uint = (state_machine_regs
                                .op_index as libc::c_ulong)
                                .wrapping_add(uladv)
                                .wrapping_div(linfo.li_max_ops_per_insn as libc::c_ulong)
                                .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                                as libc::c_uint;
                            state_machine_regs
                                .address = (state_machine_regs.address as libc::c_ulong)
                                .wrapping_add(addrdelta_0 as libc::c_ulong) as dwarf_vma
                                as dwarf_vma;
                            state_machine_regs
                                .op_index = (state_machine_regs.op_index as libc::c_ulong)
                                .wrapping_add(uladv)
                                .wrapping_rem(linfo.li_max_ops_per_insn as libc::c_ulong)
                                as libc::c_uchar;
                            if addrdelta_0 != 0 {
                                state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                            }
                        }
                    }
                    3 => {
                        let mut _val_14: dwarf_signed_vma = 0;
                        let mut _len_21: libc::c_uint = 0;
                        let mut _status_14: libc::c_int = 0;
                        _val_14 = read_leb128(
                            data,
                            end,
                            1 as libc::c_int != 0,
                            &mut _len_21,
                            &mut _status_14,
                        ) as dwarf_signed_vma;
                        data = data.offset(_len_21 as isize);
                        adv = _val_14 as libc::c_int;
                        if adv as libc::c_long != _val_14 {
                            _status_14 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_14,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            5293 as libc::c_int as libc::c_ulong,
                        );
                        state_machine_regs
                            .line = (state_machine_regs.line)
                            .wrapping_add(adv as libc::c_uint);
                    }
                    4 => {
                        let mut _val_15: dwarf_vma = 0;
                        let mut _len_22: libc::c_uint = 0;
                        let mut _status_15: libc::c_int = 0;
                        _val_15 = read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_22,
                            &mut _status_15,
                        );
                        data = data.offset(_len_22 as isize);
                        uladv = _val_15;
                        if uladv != _val_15 {
                            _status_15 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_15,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            5298 as libc::c_int as libc::c_ulong,
                        );
                        state_machine_regs.file = uladv as libc::c_uint;
                        let mut file_0: libc::c_uint = (state_machine_regs.file)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint);
                        let mut dir: libc::c_uint = 0;
                        if file_table.is_null()
                            || n_files == 0 as libc::c_int as libc::c_uint
                        {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"\n [Use file table entry %d]\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                file_0,
                            );
                        } else if file_0 >= n_files {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"file index %u > number of files %u\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                file_0.wrapping_add(1 as libc::c_int as libc::c_uint),
                                n_files,
                            );
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"\n <over large file table index %u>\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                file_0,
                            );
                        } else {
                            dir = (*file_table.offset(file_0 as isize)).directory_index;
                            if dir == 0 as libc::c_int as libc::c_uint {
                                printf(
                                    b"\n./%s:[++]\n\0" as *const u8 as *const libc::c_char,
                                    (*file_table.offset(file_0 as isize)).name,
                                );
                            } else if directory_table.is_null()
                                || n_directories == 0 as libc::c_int as libc::c_ulong
                            {
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"\n [Use file %s in directory table entry %d]\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    (*file_table.offset(file_0 as isize)).name,
                                    dir,
                                );
                            } else if dir as libc::c_ulong > n_directories {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"directory index %u > number of directories %s\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    dir,
                                    dwarf_vmatoa(
                                        b"u\0" as *const u8 as *const libc::c_char,
                                        n_directories,
                                    ),
                                );
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"\n <over large directory table entry %u>\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    dir,
                                );
                            } else {
                                printf(
                                    b"\n%s/%s:\n\0" as *const u8 as *const libc::c_char,
                                    *directory_table
                                        .offset(
                                            dir.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                                        ),
                                    (*file_table.offset(file_0 as isize)).name,
                                );
                            }
                        }
                    }
                    5 => {
                        let mut _val_16: dwarf_vma = 0;
                        let mut _len_23: libc::c_uint = 0;
                        let mut _status_16: libc::c_int = 0;
                        _val_16 = read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_23,
                            &mut _status_16,
                        );
                        data = data.offset(_len_23 as isize);
                        uladv = _val_16;
                        if uladv != _val_16 {
                            _status_16 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_16,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            5334 as libc::c_int as libc::c_ulong,
                        );
                        state_machine_regs.column = uladv as libc::c_uint;
                    }
                    6 => {
                        adv = state_machine_regs.is_stmt;
                        adv = (adv == 0) as libc::c_int;
                        state_machine_regs.is_stmt = adv;
                    }
                    7 => {
                        state_machine_regs.basic_block = 1 as libc::c_int;
                    }
                    8 => {
                        uladv = ((255 as libc::c_int
                            - linfo.li_opcode_base as libc::c_int)
                            / linfo.li_line_range as libc::c_int) as libc::c_ulong;
                        if linfo.li_max_ops_per_insn as libc::c_int == 1 as libc::c_int {
                            uladv = uladv
                                .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong);
                            state_machine_regs
                                .address = (state_machine_regs.address as libc::c_ulong)
                                .wrapping_add(uladv) as dwarf_vma as dwarf_vma;
                            if uladv != 0 {
                                state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                            }
                        } else {
                            let mut addrdelta_1: libc::c_uint = (state_machine_regs
                                .op_index as libc::c_ulong)
                                .wrapping_add(uladv)
                                .wrapping_div(linfo.li_max_ops_per_insn as libc::c_ulong)
                                .wrapping_mul(linfo.li_min_insn_length as libc::c_ulong)
                                as libc::c_uint;
                            state_machine_regs
                                .address = (state_machine_regs.address as libc::c_ulong)
                                .wrapping_add(addrdelta_1 as libc::c_ulong) as dwarf_vma
                                as dwarf_vma;
                            state_machine_regs
                                .op_index = (state_machine_regs.op_index as libc::c_ulong)
                                .wrapping_add(uladv)
                                .wrapping_rem(linfo.li_max_ops_per_insn as libc::c_ulong)
                                as libc::c_uchar;
                            if addrdelta_1 != 0 {
                                state_machine_regs.view = 0 as libc::c_int as libc::c_uint;
                            }
                        }
                    }
                    9 => {
                        let mut amount_6: size_t = 2 as libc::c_int as size_t;
                        if (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)
                            < amount_6
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_6,
                                    5 as libc::c_int,
                                ),
                                amount_6 as libc::c_int,
                                ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_6 = ::core::mem::size_of::<libc::c_ulong>()
                                as libc::c_ulong;
                        }
                        let mut avail_6: size_t = end.offset_from(data) as libc::c_long
                            as size_t;
                        if data > end {
                            avail_6 = 0 as libc::c_int as size_t;
                        }
                        if amount_6 > avail_6 {
                            amount_6 = avail_6;
                        }
                        if amount_6 == 0 as libc::c_int as libc::c_ulong {
                            uladv = 0 as libc::c_int as libc::c_ulong;
                        } else {
                            uladv = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(data, amount_6 as libc::c_uint);
                        }
                        data = data.offset(amount_6 as isize);
                        state_machine_regs
                            .address = (state_machine_regs.address as libc::c_ulong)
                            .wrapping_add(uladv) as dwarf_vma as dwarf_vma;
                        state_machine_regs.op_index = 0 as libc::c_int as libc::c_uchar;
                    }
                    1 | 10 | 11 => {}
                    12 => {
                        let mut _val_17: dwarf_vma = 0;
                        let mut _len_24: libc::c_uint = 0;
                        let mut _status_17: libc::c_int = 0;
                        _val_17 = read_leb128(
                            data,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_24,
                            &mut _status_17,
                        );
                        data = data.offset(_len_24 as isize);
                        uladv = _val_17;
                        if uladv != _val_17 {
                            _status_17 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_17,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            5387 as libc::c_int as libc::c_ulong,
                        );
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Set ISA to %lu\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            uladv,
                        );
                    }
                    _ => {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"  Unknown opcode %d with operands: \0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            op_code as libc::c_int,
                        );
                        if !standard_opcodes.is_null() {
                            i = *standard_opcodes
                                .offset(
                                    (op_code as libc::c_int - 1 as libc::c_int) as isize,
                                ) as libc::c_int;
                            while i > 0 as libc::c_int {
                                let mut val: dwarf_vma = 0;
                                let mut _val_18: dwarf_vma = 0;
                                let mut _len_25: libc::c_uint = 0;
                                let mut _status_18: libc::c_int = 0;
                                _val_18 = read_leb128(
                                    data,
                                    end,
                                    0 as libc::c_int != 0,
                                    &mut _len_25,
                                    &mut _status_18,
                                );
                                data = data.offset(_len_25 as isize);
                                val = _val_18;
                                if val != _val_18 {
                                    _status_18 |= 2 as libc::c_int;
                                }
                                report_leb_status(
                                    _status_18,
                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                    5399 as libc::c_int as libc::c_ulong,
                                );
                                printf(
                                    b"0x%s%s\0" as *const u8 as *const libc::c_char,
                                    dwarf_vmatoa(
                                        b"x\0" as *const u8 as *const libc::c_char,
                                        val,
                                    ),
                                    if i == 1 as libc::c_int {
                                        b"\0" as *const u8 as *const libc::c_char
                                    } else {
                                        b", \0" as *const u8 as *const libc::c_char
                                    },
                                );
                                i -= 1;
                                i;
                            }
                        }
                        putchar('\n' as i32);
                    }
                }
            }
            if is_special_opcode != 0 || xop == -(DW_LNE_end_sequence as libc::c_int)
                || xop == DW_LNS_copy as libc::c_int
            {
                let MAX_FILENAME_LENGTH: libc::c_uint = 35 as libc::c_int
                    as libc::c_uint;
                let mut fileName: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut newFileName: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut fileNameLength: size_t = 0;
                if !file_table.is_null() {
                    let mut indx: libc::c_uint = (state_machine_regs.file)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint);
                    if indx >= n_files {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"corrupt file index %u encountered\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            indx,
                        );
                        fileName = dcgettext(
                            0 as *const libc::c_char,
                            b"<corrupt>\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        );
                    } else {
                        fileName = (*file_table.offset(indx as isize)).name
                            as *mut libc::c_char;
                    }
                } else {
                    fileName = dcgettext(
                        0 as *const libc::c_char,
                        b"<unknown>\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    );
                }
                fileNameLength = strlen(fileName);
                newFileName = fileName;
                if fileNameLength > MAX_FILENAME_LENGTH as libc::c_ulong && do_wide == 0
                {
                    newFileName = xmalloc(
                        MAX_FILENAME_LENGTH
                            .wrapping_add(1 as libc::c_int as libc::c_uint) as size_t,
                    ) as *mut libc::c_char;
                    memcpy(
                        newFileName as *mut libc::c_void,
                        fileName
                            .offset(fileNameLength as isize)
                            .offset(-(MAX_FILENAME_LENGTH as isize))
                            as *const libc::c_void,
                        MAX_FILENAME_LENGTH as libc::c_ulong,
                    );
                    *newFileName
                        .offset(
                            MAX_FILENAME_LENGTH as isize,
                        ) = 0 as libc::c_int as libc::c_char;
                }
                if do_wide == 0 || fileNameLength <= MAX_FILENAME_LENGTH as libc::c_ulong
                {
                    if linfo.li_max_ops_per_insn as libc::c_int == 1 as libc::c_int {
                        if xop == -(DW_LNE_end_sequence as libc::c_int) {
                            printf(
                                b"%-35s  %11s  %#18lx\0" as *const u8
                                    as *const libc::c_char,
                                newFileName,
                                b"-\0" as *const u8 as *const libc::c_char,
                                state_machine_regs.address,
                            );
                        } else {
                            printf(
                                b"%-35s  %11d  %#18lx\0" as *const u8
                                    as *const libc::c_char,
                                newFileName,
                                state_machine_regs.line,
                                state_machine_regs.address,
                            );
                        }
                    } else if xop == -(DW_LNE_end_sequence as libc::c_int) {
                        printf(
                            b"%-35s  %11s  %#18lx[%d]\0" as *const u8
                                as *const libc::c_char,
                            newFileName,
                            b"-\0" as *const u8 as *const libc::c_char,
                            state_machine_regs.address,
                            state_machine_regs.op_index as libc::c_int,
                        );
                    } else {
                        printf(
                            b"%-35s  %11d  %#18lx[%d]\0" as *const u8
                                as *const libc::c_char,
                            newFileName,
                            state_machine_regs.line,
                            state_machine_regs.address,
                            state_machine_regs.op_index as libc::c_int,
                        );
                    }
                } else if linfo.li_max_ops_per_insn as libc::c_int == 1 as libc::c_int {
                    if xop == -(DW_LNE_end_sequence as libc::c_int) {
                        printf(
                            b"%s  %11s  %#18lx\0" as *const u8 as *const libc::c_char,
                            newFileName,
                            b"-\0" as *const u8 as *const libc::c_char,
                            state_machine_regs.address,
                        );
                    } else {
                        printf(
                            b"%s  %11d  %#18lx\0" as *const u8 as *const libc::c_char,
                            newFileName,
                            state_machine_regs.line,
                            state_machine_regs.address,
                        );
                    }
                } else if xop == -(DW_LNE_end_sequence as libc::c_int) {
                    printf(
                        b"%s  %11s  %#18lx[%d]\0" as *const u8 as *const libc::c_char,
                        newFileName,
                        b"-\0" as *const u8 as *const libc::c_char,
                        state_machine_regs.address,
                        state_machine_regs.op_index as libc::c_int,
                    );
                } else {
                    printf(
                        b"%s  %11d  %#18lx[%d]\0" as *const u8 as *const libc::c_char,
                        newFileName,
                        state_machine_regs.line,
                        state_machine_regs.address,
                        state_machine_regs.op_index as libc::c_int,
                    );
                }
                if xop != -(DW_LNE_end_sequence as libc::c_int) {
                    if state_machine_regs.view != 0 {
                        printf(
                            b"  %6u\0" as *const u8 as *const libc::c_char,
                            state_machine_regs.view,
                        );
                    } else {
                        printf(b"        \0" as *const u8 as *const libc::c_char);
                    }
                    if state_machine_regs.is_stmt != 0 {
                        printf(b"       x\0" as *const u8 as *const libc::c_char);
                    }
                }
                putchar('\n' as i32);
                state_machine_regs.view = (state_machine_regs.view).wrapping_add(1);
                state_machine_regs.view;
                if xop == -(DW_LNE_end_sequence as libc::c_int) {
                    reset_state_machine(linfo.li_default_is_stmt as libc::c_int);
                    putchar('\n' as i32);
                }
                if newFileName != fileName {
                    free(newFileName as *mut libc::c_void);
                }
            }
        }
        if !file_table.is_null() {
            free(file_table as *mut libc::c_void);
            file_table = 0 as *mut File_Entry;
            n_files = 0 as libc::c_int as libc::c_uint;
        }
        if !directory_table.is_null() {
            free(directory_table as *mut libc::c_void);
            directory_table = 0 as *mut *mut libc::c_uchar;
            n_directories = 0 as libc::c_int as dwarf_vma;
        }
        putchar('\n' as i32);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_lines(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut data: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = data.offset((*section).size as isize);
    let mut retValRaw: libc::c_int = 1 as libc::c_int;
    let mut retValDecoded: libc::c_int = 1 as libc::c_int;
    if do_debug_lines == 0 as libc::c_int {
        do_debug_lines |= 1 as libc::c_int;
    }
    if do_debug_lines & 1 as libc::c_int != 0 {
        retValRaw = display_debug_lines_raw(section, data, end, file);
    }
    if do_debug_lines & 2 as libc::c_int != 0 {
        retValDecoded = display_debug_lines_decoded(section, data, data, end, file);
    }
    if retValRaw == 0 || retValDecoded == 0 {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn find_debug_info_for_offset(
    mut offset: libc::c_ulong,
) -> *mut debug_info {
    let mut i: libc::c_uint = 0;
    if num_debug_info_entries == -(1 as libc::c_int) as libc::c_uint {
        return 0 as *mut debug_info;
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < num_debug_info_entries {
        if (*debug_information.offset(i as isize)).cu_offset == offset {
            return debug_information.offset(i as isize);
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as *mut debug_info;
}
unsafe extern "C" fn get_gdb_index_symbol_kind_name(
    mut kind: gdb_index_symbol_kind,
) -> *const libc::c_char {
    static mut kinds: [*const libc::c_char; 8] = [
        b"no info\0" as *const u8 as *const libc::c_char,
        b"type\0" as *const u8 as *const libc::c_char,
        b"variable\0" as *const u8 as *const libc::c_char,
        b"function\0" as *const u8 as *const libc::c_char,
        b"other\0" as *const u8 as *const libc::c_char,
        b"unused5\0" as *const u8 as *const libc::c_char,
        b"unused6\0" as *const u8 as *const libc::c_char,
        b"unused7\0" as *const u8 as *const libc::c_char,
    ];
    return dcgettext(0 as *const libc::c_char, kinds[kind as usize], 5 as libc::c_int);
}
unsafe extern "C" fn display_debug_pubnames_worker(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
    mut is_gnu: libc::c_int,
) -> libc::c_int {
    let mut names: DWARF2_Internal_PubNames = DWARF2_Internal_PubNames {
        pn_length: 0,
        pn_version: 0,
        pn_offset: 0,
        pn_size: 0,
    };
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = start.offset((*section).size as isize);
    load_debug_info(file);
    introduce(section, 0 as libc::c_int != 0);
    while start < end {
        let mut data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut sec_off: libc::c_ulong = start.offset_from((*section).start)
            as libc::c_long as libc::c_ulong;
        let mut offset_size: libc::c_uint = 0;
        let mut amount: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = end.offset_from(start) as libc::c_long as size_t;
        if start > end {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            names.pn_length = 0 as libc::c_int as dwarf_vma;
        } else {
            names
                .pn_length = byte_get
                .expect("non-null function pointer")(start, amount as libc::c_uint);
        }
        start = start.offset(amount as isize);
        if names.pn_length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_0: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_0,
                        5 as libc::c_int,
                    ),
                    amount_0 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_0: size_t = end.offset_from(start) as libc::c_long as size_t;
            if start > end {
                avail_0 = 0 as libc::c_int as size_t;
            }
            if amount_0 > avail_0 {
                amount_0 = avail_0;
            }
            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                names.pn_length = 0 as libc::c_int as dwarf_vma;
            } else {
                names
                    .pn_length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(start, amount_0 as libc::c_uint);
            }
            start = start.offset(amount_0 as isize);
            offset_size = 8 as libc::c_int as libc::c_uint;
        } else {
            offset_size = 4 as libc::c_int as libc::c_uint;
        }
        if names.pn_length > end.offset_from(start) as libc::c_long as size_t {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Debug info is corrupted, %s header at %#lx has length %s\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                sec_off,
                dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, names.pn_length),
            );
            break;
        } else {
            data = start;
            start = start.offset(names.pn_length as isize);
            let mut amount_1: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong;
            }
            let mut avail_1: size_t = start.offset_from(data) as libc::c_long as size_t;
            if data > start {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                names.pn_version = 0 as libc::c_int as libc::c_ushort;
            } else {
                names
                    .pn_version = byte_get
                    .expect("non-null function pointer")(data, amount_1 as libc::c_uint)
                    as libc::c_ushort;
            }
            data = data.offset(amount_1 as isize);
            let mut amount_2: size_t = offset_size as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_2: size_t = start.offset_from(data) as libc::c_long as size_t;
            if data > start {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                names.pn_offset = 0 as libc::c_int as dwarf_vma;
            } else {
                names
                    .pn_offset = byte_get
                    .expect("non-null function pointer")(data, amount_2 as libc::c_uint);
            }
            data = data.offset(amount_2 as isize);
            if num_debug_info_entries != -(1 as libc::c_int) as libc::c_uint
                && num_debug_info_entries > 0 as libc::c_int as libc::c_uint
                && (find_debug_info_for_offset(names.pn_offset)).is_null()
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b".debug_info offset of 0x%lx in %s section does not point to a CU header.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    names.pn_offset,
                    (*section).name,
                );
            }
            let mut amount_3: size_t = offset_size as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_3 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_3,
                        5 as libc::c_int,
                    ),
                    amount_3 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_3 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_3: size_t = start.offset_from(data) as libc::c_long as size_t;
            if data > start {
                avail_3 = 0 as libc::c_int as size_t;
            }
            if amount_3 > avail_3 {
                amount_3 = avail_3;
            }
            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                names.pn_size = 0 as libc::c_int as dwarf_vma;
            } else {
                names
                    .pn_size = byte_get
                    .expect("non-null function pointer")(data, amount_3 as libc::c_uint);
            }
            data = data.offset(amount_3 as isize);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Length:                              %ld\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                names.pn_length as libc::c_long,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Version:                             %d\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                names.pn_version as libc::c_int,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Offset into .debug_info section:     0x%lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                names.pn_offset,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Size of area in .debug_info section: %ld\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                names.pn_size as libc::c_long,
            );
            if names.pn_version as libc::c_int != 2 as libc::c_int
                && names.pn_version as libc::c_int != 3 as libc::c_int
            {
                static mut warned: libc::c_int = 0 as libc::c_int;
                if warned == 0 {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Only DWARF 2 and 3 pubnames are currently supported\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    warned = 1 as libc::c_int;
                }
            } else {
                if is_gnu != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\n    Offset  Kind          Name\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                } else {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"\n    Offset\tName\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                loop {
                    let mut maxprint: bfd_size_type = 0;
                    let mut offset: dwarf_vma = 0;
                    let mut amount_4: size_t = offset_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_4
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_4,
                                5 as libc::c_int,
                            ),
                            amount_4 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_4 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_4: size_t = start.offset_from(data) as libc::c_long
                        as size_t;
                    if data > start {
                        avail_4 = 0 as libc::c_int as size_t;
                    }
                    if amount_4 > avail_4 {
                        amount_4 = avail_4;
                    }
                    if amount_4 == 0 as libc::c_int as libc::c_ulong {
                        offset = 0 as libc::c_int as dwarf_vma;
                    } else {
                        offset = byte_get
                            .expect(
                                "non-null function pointer",
                            )(data, amount_4 as libc::c_uint);
                    }
                    data = data.offset(amount_4 as isize);
                    if offset == 0 as libc::c_int as libc::c_ulong {
                        break;
                    }
                    if data >= start {
                        break;
                    }
                    maxprint = (start.offset_from(data) as libc::c_long
                        - 1 as libc::c_int as libc::c_long) as bfd_size_type;
                    if is_gnu != 0 {
                        let mut kind_data: libc::c_uint = 0;
                        let mut kind: gdb_index_symbol_kind = GDB_INDEX_SYMBOL_KIND_NONE;
                        let mut kind_name: *const libc::c_char = 0
                            as *const libc::c_char;
                        let mut is_static: libc::c_int = 0;
                        let mut amount_5: size_t = 1 as libc::c_int as size_t;
                        if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                            < amount_5
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_5,
                                    5 as libc::c_int,
                                ),
                                amount_5 as libc::c_int,
                                ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_5 = ::core::mem::size_of::<libc::c_uint>()
                                as libc::c_ulong;
                        }
                        let mut avail_5: size_t = start.offset_from(data) as libc::c_long
                            as size_t;
                        if data > start {
                            avail_5 = 0 as libc::c_int as size_t;
                        }
                        if amount_5 > avail_5 {
                            amount_5 = avail_5;
                        }
                        if amount_5 == 0 as libc::c_int as libc::c_ulong {
                            kind_data = 0 as libc::c_int as libc::c_uint;
                        } else {
                            kind_data = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(data, amount_5 as libc::c_uint) as libc::c_uint;
                        }
                        data = data.offset(amount_5 as isize);
                        maxprint = maxprint.wrapping_sub(1);
                        maxprint;
                        kind_data <<= 24 as libc::c_int;
                        kind = (kind_data >> 28 as libc::c_int
                            & 7 as libc::c_int as libc::c_uint) as gdb_index_symbol_kind;
                        kind_name = get_gdb_index_symbol_kind_name(kind);
                        is_static = (kind_data >> 31 as libc::c_int
                            & 1 as libc::c_int as libc::c_uint) as libc::c_int;
                        printf(
                            b"    %-6lx  %s,%-10s  %.*s\n\0" as *const u8
                                as *const libc::c_char,
                            offset,
                            if is_static != 0 {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"s\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            } else {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"g\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            },
                            kind_name,
                            maxprint as libc::c_int,
                            data,
                        );
                    } else {
                        printf(
                            b"    %-6lx\t%.*s\n\0" as *const u8 as *const libc::c_char,
                            offset,
                            maxprint as libc::c_int,
                            data,
                        );
                    }
                    data = data
                        .offset(strnlen(data as *mut libc::c_char, maxprint) as isize);
                    if data < start {
                        data = data.offset(1);
                        data;
                    }
                    if data >= start {
                        break;
                    }
                }
            }
        }
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_pubnames(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    return display_debug_pubnames_worker(section, file, 0 as libc::c_int);
}
unsafe extern "C" fn display_debug_gnu_pubnames(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    return display_debug_pubnames_worker(section, file, 1 as libc::c_int);
}
unsafe extern "C" fn display_debug_macinfo(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = start.offset((*section).size as isize);
    let mut curr: *mut libc::c_uchar = start;
    let mut op: dwarf_macinfo_record_type = 0 as dwarf_macinfo_record_type;
    introduce(section, 0 as libc::c_int != 0);
    while curr < end {
        let mut lineno: libc::c_uint = 0;
        let mut string: *const libc::c_uchar = 0 as *const libc::c_uchar;
        op = *curr as dwarf_macinfo_record_type;
        curr = curr.offset(1);
        curr;
        match op as libc::c_uint {
            3 => {
                let mut filenum: libc::c_uint = 0;
                let mut _val: dwarf_vma = 0;
                let mut _len: libc::c_uint = 0;
                let mut _status: libc::c_int = 0;
                _val = read_leb128(
                    curr,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len,
                    &mut _status,
                );
                curr = curr.offset(_len as isize);
                lineno = _val as libc::c_uint;
                if lineno as libc::c_ulong != _val {
                    _status |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    5773 as libc::c_int as libc::c_ulong,
                );
                let mut _val_0: dwarf_vma = 0;
                let mut _len_0: libc::c_uint = 0;
                let mut _status_0: libc::c_int = 0;
                _val_0 = read_leb128(
                    curr,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_0,
                    &mut _status_0,
                );
                curr = curr.offset(_len_0 as isize);
                filenum = _val_0 as libc::c_uint;
                if filenum as libc::c_ulong != _val_0 {
                    _status_0 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_0,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    5774 as libc::c_int as libc::c_ulong,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" DW_MACINFO_start_file - lineno: %d filenum: %d\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    lineno,
                    filenum,
                );
            }
            4 => {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" DW_MACINFO_end_file\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            1 => {
                let mut _val_1: dwarf_vma = 0;
                let mut _len_1: libc::c_uint = 0;
                let mut _status_1: libc::c_int = 0;
                _val_1 = read_leb128(
                    curr,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_1,
                    &mut _status_1,
                );
                curr = curr.offset(_len_1 as isize);
                lineno = _val_1 as libc::c_uint;
                if lineno as libc::c_ulong != _val_1 {
                    _status_1 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_1,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    5785 as libc::c_int as libc::c_ulong,
                );
                string = curr;
                curr = curr
                    .offset(
                        strnlen(
                            string as *mut libc::c_char,
                            end.offset_from(string) as libc::c_long as size_t,
                        ) as isize,
                    );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" DW_MACINFO_define - lineno : %d macro : %*s\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    lineno,
                    curr.offset_from(string) as libc::c_long as libc::c_int,
                    string,
                );
                if curr < end {
                    curr = curr.offset(1);
                    curr;
                }
            }
            2 => {
                let mut _val_2: dwarf_vma = 0;
                let mut _len_2: libc::c_uint = 0;
                let mut _status_2: libc::c_int = 0;
                _val_2 = read_leb128(
                    curr,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_2,
                    &mut _status_2,
                );
                curr = curr.offset(_len_2 as isize);
                lineno = _val_2 as libc::c_uint;
                if lineno as libc::c_ulong != _val_2 {
                    _status_2 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_2,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    5795 as libc::c_int as libc::c_ulong,
                );
                string = curr;
                curr = curr
                    .offset(
                        strnlen(
                            string as *mut libc::c_char,
                            end.offset_from(string) as libc::c_long as size_t,
                        ) as isize,
                    );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" DW_MACINFO_undef - lineno : %d macro : %*s\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    lineno,
                    curr.offset_from(string) as libc::c_long as libc::c_int,
                    string,
                );
                if curr < end {
                    curr = curr.offset(1);
                    curr;
                }
            }
            255 => {
                let mut constant: libc::c_uint = 0;
                let mut _val_3: dwarf_vma = 0;
                let mut _len_3: libc::c_uint = 0;
                let mut _status_3: libc::c_int = 0;
                _val_3 = read_leb128(
                    curr,
                    end,
                    0 as libc::c_int != 0,
                    &mut _len_3,
                    &mut _status_3,
                );
                curr = curr.offset(_len_3 as isize);
                constant = _val_3 as libc::c_uint;
                if constant as libc::c_ulong != _val_3 {
                    _status_3 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_3,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    5808 as libc::c_int as libc::c_ulong,
                );
                string = curr;
                curr = curr
                    .offset(
                        strnlen(
                            string as *mut libc::c_char,
                            end.offset_from(string) as libc::c_long as size_t,
                        ) as isize,
                    );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b" DW_MACINFO_vendor_ext - constant : %d string : %*s\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    constant,
                    curr.offset_from(string) as libc::c_long as libc::c_int,
                    string,
                );
                if curr < end {
                    curr = curr.offset(1);
                    curr;
                }
            }
            _ => {}
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn get_line_filename_and_dirname(
    mut line_offset: dwarf_vma,
    mut fileidx: dwarf_vma,
    mut dir_name: *mut *mut libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut section: *mut dwarf_section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(line as libc::c_int as isize))
        .section;
    let mut hdrptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut dirtable: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut file_name: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut offset_size: libc::c_uint = 0;
    let mut version: libc::c_uint = 0;
    let mut opcode_base: libc::c_uint = 0;
    let mut length: dwarf_vma = 0;
    let mut diridx: dwarf_vma = 0;
    let mut end: *const libc::c_uchar = 0 as *const libc::c_uchar;
    *dir_name = 0 as *mut libc::c_uchar;
    if ((*section).start).is_null() || line_offset >= (*section).size
        || fileidx == 0 as libc::c_int as libc::c_ulong
    {
        return 0 as *mut libc::c_uchar;
    }
    hdrptr = ((*section).start).offset(line_offset as isize);
    end = ((*section).start).offset((*section).size as isize);
    let mut amount: size_t = 4 as libc::c_int as size_t;
    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount,
                5 as libc::c_int,
            ),
            amount as libc::c_int,
            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
        );
        amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
    }
    let mut avail: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end as *mut libc::c_uchar {
        avail = 0 as libc::c_int as size_t;
    }
    if amount > avail {
        amount = avail;
    }
    if amount == 0 as libc::c_int as libc::c_ulong {
        length = 0 as libc::c_int as dwarf_vma;
    } else {
        length = byte_get
            .expect("non-null function pointer")(hdrptr, amount as libc::c_uint);
    }
    hdrptr = hdrptr.offset(amount as isize);
    if length == 0xffffffff as libc::c_uint as libc::c_ulong {
        let mut amount_0: size_t = 8 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_0,
                    5 as libc::c_int,
                ),
                amount_0 as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail_0: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end as *mut libc::c_uchar {
            avail_0 = 0 as libc::c_int as size_t;
        }
        if amount_0 > avail_0 {
            amount_0 = avail_0;
        }
        if amount_0 == 0 as libc::c_int as libc::c_ulong {
            length = 0 as libc::c_int as dwarf_vma;
        } else {
            length = byte_get
                .expect("non-null function pointer")(hdrptr, amount_0 as libc::c_uint);
        }
        hdrptr = hdrptr.offset(amount_0 as isize);
        offset_size = 8 as libc::c_int as libc::c_uint;
    } else {
        offset_size = 4 as libc::c_int as libc::c_uint;
    }
    if length > end.offset_from(hdrptr) as libc::c_long as size_t
        || length
            < (2 as libc::c_int as libc::c_uint)
                .wrapping_add(offset_size)
                .wrapping_add(1 as libc::c_int as libc::c_uint)
                .wrapping_add(3 as libc::c_int as libc::c_uint)
                .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong
    {
        return 0 as *mut libc::c_uchar;
    }
    end = hdrptr.offset(length as isize);
    let mut amount_1: size_t = 2 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_1 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_1,
                5 as libc::c_int,
            ),
            amount_1 as libc::c_int,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
        );
        amount_1 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
    }
    let mut avail_1: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end as *mut libc::c_uchar {
        avail_1 = 0 as libc::c_int as size_t;
    }
    if amount_1 > avail_1 {
        amount_1 = avail_1;
    }
    if amount_1 == 0 as libc::c_int as libc::c_ulong {
        version = 0 as libc::c_int as libc::c_uint;
    } else {
        version = byte_get
            .expect("non-null function pointer")(hdrptr, amount_1 as libc::c_uint)
            as libc::c_uint;
    }
    hdrptr = hdrptr.offset(amount_1 as isize);
    if version != 2 as libc::c_int as libc::c_uint
        && version != 3 as libc::c_int as libc::c_uint
        && version != 4 as libc::c_int as libc::c_uint
    {
        return 0 as *mut libc::c_uchar;
    }
    hdrptr = hdrptr
        .offset(offset_size.wrapping_add(1 as libc::c_int as libc::c_uint) as isize);
    if version >= 4 as libc::c_int as libc::c_uint {
        hdrptr = hdrptr.offset(1);
        hdrptr;
    }
    hdrptr = hdrptr.offset(3 as libc::c_int as isize);
    let mut amount_2: size_t = 1 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_2 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_2,
                5 as libc::c_int,
            ),
            amount_2 as libc::c_int,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
        );
        amount_2 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
    }
    let mut avail_2: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
    if hdrptr > end as *mut libc::c_uchar {
        avail_2 = 0 as libc::c_int as size_t;
    }
    if amount_2 > avail_2 {
        amount_2 = avail_2;
    }
    if amount_2 == 0 as libc::c_int as libc::c_ulong {
        opcode_base = 0 as libc::c_int as libc::c_uint;
    } else {
        opcode_base = byte_get
            .expect("non-null function pointer")(hdrptr, amount_2 as libc::c_uint)
            as libc::c_uint;
    }
    hdrptr = hdrptr.offset(amount_2 as isize);
    if opcode_base == 0 as libc::c_int as libc::c_uint
        || opcode_base.wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_ulong
            >= end.offset_from(hdrptr) as libc::c_long as size_t
    {
        return 0 as *mut libc::c_uchar;
    }
    hdrptr = hdrptr
        .offset(opcode_base.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize);
    dirtable = hdrptr;
    while *hdrptr as libc::c_int != '\0' as i32 {
        hdrptr = hdrptr
            .offset(
                strnlen(
                    hdrptr as *mut libc::c_char,
                    end.offset_from(hdrptr) as libc::c_long as size_t,
                ) as isize,
            );
        if hdrptr < end as *mut libc::c_uchar {
            hdrptr = hdrptr.offset(1);
            hdrptr;
        }
        if hdrptr >= end as *mut libc::c_uchar {
            return 0 as *mut libc::c_uchar;
        }
    }
    hdrptr = hdrptr.offset(1);
    hdrptr;
    while hdrptr < end as *mut libc::c_uchar && *hdrptr as libc::c_int != '\0' as i32
        && fileidx > 1 as libc::c_int as libc::c_ulong
    {
        hdrptr = hdrptr
            .offset(
                strnlen(
                    hdrptr as *mut libc::c_char,
                    end.offset_from(hdrptr) as libc::c_long as size_t,
                ) as isize,
            );
        if hdrptr < end as *mut libc::c_uchar {
            hdrptr = hdrptr.offset(1);
            hdrptr;
        }
        let mut _len: libc::c_uint = 0;
        read_leb128(
            hdrptr,
            end,
            0 as libc::c_int != 0,
            &mut _len,
            0 as *mut libc::c_int,
        );
        hdrptr = hdrptr.offset(_len as isize);
        let mut _len_0: libc::c_uint = 0;
        read_leb128(
            hdrptr,
            end,
            0 as libc::c_int != 0,
            &mut _len_0,
            0 as *mut libc::c_int,
        );
        hdrptr = hdrptr.offset(_len_0 as isize);
        let mut _len_1: libc::c_uint = 0;
        read_leb128(
            hdrptr,
            end,
            0 as libc::c_int != 0,
            &mut _len_1,
            0 as *mut libc::c_int,
        );
        hdrptr = hdrptr.offset(_len_1 as isize);
        fileidx = fileidx.wrapping_sub(1);
        fileidx;
    }
    if hdrptr >= end as *mut libc::c_uchar || *hdrptr as libc::c_int == '\0' as i32 {
        return 0 as *mut libc::c_uchar;
    }
    file_name = hdrptr;
    hdrptr = hdrptr
        .offset(
            strnlen(
                hdrptr as *mut libc::c_char,
                end.offset_from(hdrptr) as libc::c_long as size_t,
            ) as isize,
        );
    if hdrptr < end as *mut libc::c_uchar {
        hdrptr = hdrptr.offset(1);
        hdrptr;
    }
    if hdrptr >= end as *mut libc::c_uchar {
        return 0 as *mut libc::c_uchar;
    }
    let mut _val: dwarf_vma = 0;
    let mut _len_2: libc::c_uint = 0;
    let mut _status: libc::c_int = 0;
    _val = read_leb128(hdrptr, end, 0 as libc::c_int != 0, &mut _len_2, &mut _status);
    hdrptr = hdrptr.offset(_len_2 as isize);
    diridx = _val;
    if diridx != _val {
        _status |= 2 as libc::c_int;
    }
    report_leb_status(
        _status,
        b"dwarf.c\0" as *const u8 as *const libc::c_char,
        5909 as libc::c_int as libc::c_ulong,
    );
    if diridx == 0 as libc::c_int as libc::c_ulong {
        return file_name;
    }
    while dirtable < end as *mut libc::c_uchar && *dirtable as libc::c_int != '\0' as i32
        && diridx > 1 as libc::c_int as libc::c_ulong
    {
        dirtable = dirtable
            .offset(
                strnlen(
                    dirtable as *mut libc::c_char,
                    end.offset_from(dirtable) as libc::c_long as size_t,
                ) as isize,
            );
        if dirtable < end as *mut libc::c_uchar {
            dirtable = dirtable.offset(1);
            dirtable;
        }
        diridx = diridx.wrapping_sub(1);
        diridx;
    }
    if dirtable >= end as *mut libc::c_uchar || *dirtable as libc::c_int == '\0' as i32 {
        return 0 as *mut libc::c_uchar;
    }
    *dir_name = dirtable;
    return file_name;
}
unsafe extern "C" fn display_debug_macro(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = start.offset((*section).size as isize);
    let mut curr: *mut libc::c_uchar = start;
    let mut extended_op_buf: [*mut libc::c_uchar; 256] = [0 as *mut libc::c_uchar; 256];
    let mut is_dwo: bool = 0 as libc::c_int != 0;
    let mut suffix: *const libc::c_char = strrchr((*section).name, '.' as i32);
    if !suffix.is_null()
        && strcmp(suffix, b".dwo\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        is_dwo = 1 as libc::c_int != 0;
    }
    load_debug_section_with_follow(str, file);
    load_debug_section_with_follow(line, file);
    load_debug_section_with_follow(str_index, file);
    introduce(section, 0 as libc::c_int != 0);
    while curr < end {
        let mut lineno: libc::c_uint = 0;
        let mut version: libc::c_uint = 0;
        let mut flags: libc::c_uint = 0;
        let mut offset_size: libc::c_uint = 0;
        let mut string: *const libc::c_uchar = 0 as *const libc::c_uchar;
        let mut line_offset: dwarf_vma = 0 as libc::c_int as dwarf_vma;
        let mut sec_offset: dwarf_vma = curr.offset_from(start) as libc::c_long
            as dwarf_vma;
        let mut offset: dwarf_vma = 0;
        let mut extended_ops: *mut *mut libc::c_uchar = 0 as *mut *mut libc::c_uchar;
        let mut amount: size_t = 2 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
        }
        let mut avail: size_t = end.offset_from(curr) as libc::c_long as size_t;
        if curr > end {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            version = 0 as libc::c_int as libc::c_uint;
        } else {
            version = byte_get
                .expect("non-null function pointer")(curr, amount as libc::c_uint)
                as libc::c_uint;
        }
        curr = curr.offset(amount as isize);
        if version != 4 as libc::c_int as libc::c_uint
            && version != 5 as libc::c_int as libc::c_uint
        {
            error(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Expected to find a version number of 4 or 5 in section %s but found %d instead\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                version,
            );
            return 0 as libc::c_int;
        }
        let mut amount_0: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_0 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_0,
                    5 as libc::c_int,
                ),
                amount_0 as libc::c_int,
                ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
            );
            amount_0 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
        }
        let mut avail_0: size_t = end.offset_from(curr) as libc::c_long as size_t;
        if curr > end {
            avail_0 = 0 as libc::c_int as size_t;
        }
        if amount_0 > avail_0 {
            amount_0 = avail_0;
        }
        if amount_0 == 0 as libc::c_int as libc::c_ulong {
            flags = 0 as libc::c_int as libc::c_uint;
        } else {
            flags = byte_get
                .expect("non-null function pointer")(curr, amount_0 as libc::c_uint)
                as libc::c_uint;
        }
        curr = curr.offset(amount_0 as isize);
        offset_size = (if flags & 1 as libc::c_int as libc::c_uint != 0 {
            8 as libc::c_int
        } else {
            4 as libc::c_int
        }) as libc::c_uint;
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Offset:                      0x%lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            sec_offset,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Version:                     %d\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            version,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Offset size:                 %d\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            offset_size,
        );
        if flags & 2 as libc::c_int as libc::c_uint != 0 {
            let mut amount_1: size_t = offset_size as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_1: size_t = end.offset_from(curr) as libc::c_long as size_t;
            if curr > end {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                line_offset = 0 as libc::c_int as dwarf_vma;
            } else {
                line_offset = byte_get
                    .expect("non-null function pointer")(curr, amount_1 as libc::c_uint);
            }
            curr = curr.offset(amount_1 as isize);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Offset into .debug_line:     0x%lx\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                line_offset,
            );
        }
        if flags & 4 as libc::c_int as libc::c_uint != 0 {
            let mut i: libc::c_uint = 0;
            let mut count: libc::c_uint = 0;
            let mut op: libc::c_uint = 0;
            let mut nargs: dwarf_vma = 0;
            let mut n: dwarf_vma = 0;
            let mut amount_2: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
            }
            let mut avail_2: size_t = end.offset_from(curr) as libc::c_long as size_t;
            if curr > end {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                count = 0 as libc::c_int as libc::c_uint;
            } else {
                count = byte_get
                    .expect("non-null function pointer")(curr, amount_2 as libc::c_uint)
                    as libc::c_uint;
            }
            curr = curr.offset(amount_2 as isize);
            memset(
                extended_op_buf.as_mut_ptr() as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<[*mut libc::c_uchar; 256]>() as libc::c_ulong,
            );
            extended_ops = extended_op_buf.as_mut_ptr();
            if count != 0 {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Extension opcode arguments:\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                i = 0 as libc::c_int as libc::c_uint;
                while i < count {
                    let mut amount_3: size_t = 1 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        < amount_3
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_3,
                                5 as libc::c_int,
                            ),
                            amount_3 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_3 = ::core::mem::size_of::<libc::c_uint>()
                            as libc::c_ulong;
                    }
                    let mut avail_3: size_t = end.offset_from(curr) as libc::c_long
                        as size_t;
                    if curr > end {
                        avail_3 = 0 as libc::c_int as size_t;
                    }
                    if amount_3 > avail_3 {
                        amount_3 = avail_3;
                    }
                    if amount_3 == 0 as libc::c_int as libc::c_ulong {
                        op = 0 as libc::c_int as libc::c_uint;
                    } else {
                        op = byte_get
                            .expect(
                                "non-null function pointer",
                            )(curr, amount_3 as libc::c_uint) as libc::c_uint;
                    }
                    curr = curr.offset(amount_3 as isize);
                    let ref mut fresh25 = *extended_ops.offset(op as isize);
                    *fresh25 = curr;
                    let mut _val: dwarf_vma = 0;
                    let mut _len: libc::c_uint = 0;
                    let mut _status: libc::c_int = 0;
                    _val = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len,
                        &mut _status,
                    );
                    curr = curr.offset(_len as isize);
                    nargs = _val;
                    if nargs != _val {
                        _status |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        5988 as libc::c_int as libc::c_ulong,
                    );
                    if nargs == 0 as libc::c_int as libc::c_ulong {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"    DW_MACRO_%02x has no arguments\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            op,
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"    DW_MACRO_%02x arguments: \0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            op,
                        );
                        n = 0 as libc::c_int as dwarf_vma;
                        while n < nargs {
                            let mut form: libc::c_uint = 0;
                            let mut amount_4: size_t = 1 as libc::c_int as size_t;
                            if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                                < amount_4
                            {
                                error(
                                    dcngettext(
                                        0 as *const libc::c_char,
                                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        amount_4,
                                        5 as libc::c_int,
                                    ),
                                    amount_4 as libc::c_int,
                                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                        as libc::c_int,
                                );
                                amount_4 = ::core::mem::size_of::<libc::c_uint>()
                                    as libc::c_ulong;
                            }
                            let mut avail_4: size_t = end.offset_from(curr)
                                as libc::c_long as size_t;
                            if curr > end {
                                avail_4 = 0 as libc::c_int as size_t;
                            }
                            if amount_4 > avail_4 {
                                amount_4 = avail_4;
                            }
                            if amount_4 == 0 as libc::c_int as libc::c_ulong {
                                form = 0 as libc::c_int as libc::c_uint;
                            } else {
                                form = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(curr, amount_4 as libc::c_uint) as libc::c_uint;
                            }
                            curr = curr.offset(amount_4 as isize);
                            printf(
                                b"%s%s\0" as *const u8 as *const libc::c_char,
                                get_FORM_name(form as libc::c_ulong),
                                if n
                                    == nargs.wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                {
                                    b"\n\0" as *const u8 as *const libc::c_char
                                } else {
                                    b", \0" as *const u8 as *const libc::c_char
                                },
                            );
                            match form {
                                11 | 5 | 6 | 7 | 13 | 15 | 9 | 10 | 3 | 4 | 12 | 8 | 14
                                | 23 => {}
                                _ => {
                                    error(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Invalid extension opcode form %s\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        get_FORM_name(form as libc::c_ulong),
                                    );
                                    return 0 as libc::c_int;
                                }
                            }
                            n = n.wrapping_add(1);
                            n;
                        }
                    }
                    i = i.wrapping_add(1);
                    i;
                }
            }
        }
        printf(b"\n\0" as *const u8 as *const libc::c_char);
        loop {
            let mut op_0: libc::c_uint = 0;
            if curr >= end {
                error(
                    dcgettext(
                        0 as *const libc::c_char,
                        b".debug_macro section not zero terminated\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int;
            }
            let mut amount_5: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_5 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_5,
                        5 as libc::c_int,
                    ),
                    amount_5 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_5 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
            }
            let mut avail_5: size_t = end.offset_from(curr) as libc::c_long as size_t;
            if curr > end {
                avail_5 = 0 as libc::c_int as size_t;
            }
            if amount_5 > avail_5 {
                amount_5 = avail_5;
            }
            if amount_5 == 0 as libc::c_int as libc::c_ulong {
                op_0 = 0 as libc::c_int as libc::c_uint;
            } else {
                op_0 = byte_get
                    .expect("non-null function pointer")(curr, amount_5 as libc::c_uint)
                    as libc::c_uint;
            }
            curr = curr.offset(amount_5 as isize);
            if op_0 == 0 as libc::c_int as libc::c_uint {
                break;
            }
            match op_0 {
                1 => {
                    let mut _val_0: dwarf_vma = 0;
                    let mut _len_0: libc::c_uint = 0;
                    let mut _status_0: libc::c_int = 0;
                    _val_0 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_0,
                        &mut _status_0,
                    );
                    curr = curr.offset(_len_0 as isize);
                    lineno = _val_0 as libc::c_uint;
                    if lineno as libc::c_ulong != _val_0 {
                        _status_0 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_0,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6047 as libc::c_int as libc::c_ulong,
                    );
                    string = curr;
                    curr = curr
                        .offset(
                            strnlen(
                                string as *mut libc::c_char,
                                end.offset_from(string) as libc::c_long as size_t,
                            ) as isize,
                        );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_define - lineno : %d macro : %*s\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        lineno,
                        curr.offset_from(string) as libc::c_long as libc::c_int,
                        string,
                    );
                    if curr < end {
                        curr = curr.offset(1);
                        curr;
                    }
                }
                2 => {
                    let mut _val_1: dwarf_vma = 0;
                    let mut _len_1: libc::c_uint = 0;
                    let mut _status_1: libc::c_int = 0;
                    _val_1 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_1,
                        &mut _status_1,
                    );
                    curr = curr.offset(_len_1 as isize);
                    lineno = _val_1 as libc::c_uint;
                    if lineno as libc::c_ulong != _val_1 {
                        _status_1 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_1,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6057 as libc::c_int as libc::c_ulong,
                    );
                    string = curr;
                    curr = curr
                        .offset(
                            strnlen(
                                string as *mut libc::c_char,
                                end.offset_from(string) as libc::c_long as size_t,
                            ) as isize,
                        );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_undef - lineno : %d macro : %*s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        lineno,
                        curr.offset_from(string) as libc::c_long as libc::c_int,
                        string,
                    );
                    if curr < end {
                        curr = curr.offset(1);
                        curr;
                    }
                }
                3 => {
                    let mut filenum: libc::c_uint = 0;
                    let mut file_name: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                    let mut dir_name: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                    let mut _val_2: dwarf_vma = 0;
                    let mut _len_2: libc::c_uint = 0;
                    let mut _status_2: libc::c_int = 0;
                    _val_2 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_2,
                        &mut _status_2,
                    );
                    curr = curr.offset(_len_2 as isize);
                    lineno = _val_2 as libc::c_uint;
                    if lineno as libc::c_ulong != _val_2 {
                        _status_2 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_2,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6071 as libc::c_int as libc::c_ulong,
                    );
                    let mut _val_3: dwarf_vma = 0;
                    let mut _len_3: libc::c_uint = 0;
                    let mut _status_3: libc::c_int = 0;
                    _val_3 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_3,
                        &mut _status_3,
                    );
                    curr = curr.offset(_len_3 as isize);
                    filenum = _val_3 as libc::c_uint;
                    if filenum as libc::c_ulong != _val_3 {
                        _status_3 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_3,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6072 as libc::c_int as libc::c_ulong,
                    );
                    if flags & 2 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"DW_MACRO_start_file used, but no .debug_line offset provided.\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        file_name = get_line_filename_and_dirname(
                            line_offset,
                            filenum as dwarf_vma,
                            &mut dir_name,
                        );
                    }
                    if file_name.is_null() {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" DW_MACRO_start_file - lineno: %d filenum: %d\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            lineno,
                            filenum,
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" DW_MACRO_start_file - lineno: %d filenum: %d filename: %s%s%s\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            lineno,
                            filenum,
                            if !dir_name.is_null() {
                                dir_name as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                            if !dir_name.is_null() {
                                b"/\0" as *const u8 as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                            file_name,
                        );
                    }
                }
                4 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_end_file\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                5 => {
                    let mut _val_4: dwarf_vma = 0;
                    let mut _len_4: libc::c_uint = 0;
                    let mut _status_4: libc::c_int = 0;
                    _val_4 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_4,
                        &mut _status_4,
                    );
                    curr = curr.offset(_len_4 as isize);
                    lineno = _val_4 as libc::c_uint;
                    if lineno as libc::c_ulong != _val_4 {
                        _status_4 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_4,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6096 as libc::c_int as libc::c_ulong,
                    );
                    if version == 4 as libc::c_int as libc::c_uint
                        && is_dwo as libc::c_int != 0
                    {
                        let mut _val_5: dwarf_vma = 0;
                        let mut _len_5: libc::c_uint = 0;
                        let mut _status_5: libc::c_int = 0;
                        _val_5 = read_leb128(
                            curr,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_5,
                            &mut _status_5,
                        );
                        curr = curr.offset(_len_5 as isize);
                        offset = _val_5;
                        if offset != _val_5 {
                            _status_5 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_5,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            6098 as libc::c_int as libc::c_ulong,
                        );
                    } else {
                        let mut amount_6: size_t = offset_size as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_6
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_6,
                                    5 as libc::c_int,
                                ),
                                amount_6 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_6 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_6: size_t = end.offset_from(curr) as libc::c_long
                            as size_t;
                        if curr > end {
                            avail_6 = 0 as libc::c_int as size_t;
                        }
                        if amount_6 > avail_6 {
                            amount_6 = avail_6;
                        }
                        if amount_6 == 0 as libc::c_int as libc::c_ulong {
                            offset = 0 as libc::c_int as dwarf_vma;
                        } else {
                            offset = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(curr, amount_6 as libc::c_uint);
                        }
                        curr = curr.offset(amount_6 as isize);
                    }
                    string = fetch_indirect_string(offset);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_define_strp - lineno : %d macro : %s\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        lineno,
                        string,
                    );
                }
                6 => {
                    let mut _val_6: dwarf_vma = 0;
                    let mut _len_6: libc::c_uint = 0;
                    let mut _status_6: libc::c_int = 0;
                    _val_6 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_6,
                        &mut _status_6,
                    );
                    curr = curr.offset(_len_6 as isize);
                    lineno = _val_6 as libc::c_uint;
                    if lineno as libc::c_ulong != _val_6 {
                        _status_6 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_6,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6107 as libc::c_int as libc::c_ulong,
                    );
                    if version == 4 as libc::c_int as libc::c_uint
                        && is_dwo as libc::c_int != 0
                    {
                        let mut _val_7: dwarf_vma = 0;
                        let mut _len_7: libc::c_uint = 0;
                        let mut _status_7: libc::c_int = 0;
                        _val_7 = read_leb128(
                            curr,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_7,
                            &mut _status_7,
                        );
                        curr = curr.offset(_len_7 as isize);
                        offset = _val_7;
                        if offset != _val_7 {
                            _status_7 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_7,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            6109 as libc::c_int as libc::c_ulong,
                        );
                    } else {
                        let mut amount_7: size_t = offset_size as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_7
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_7,
                                    5 as libc::c_int,
                                ),
                                amount_7 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_7 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_7: size_t = end.offset_from(curr) as libc::c_long
                            as size_t;
                        if curr > end {
                            avail_7 = 0 as libc::c_int as size_t;
                        }
                        if amount_7 > avail_7 {
                            amount_7 = avail_7;
                        }
                        if amount_7 == 0 as libc::c_int as libc::c_ulong {
                            offset = 0 as libc::c_int as dwarf_vma;
                        } else {
                            offset = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(curr, amount_7 as libc::c_uint);
                        }
                        curr = curr.offset(amount_7 as isize);
                    }
                    string = fetch_indirect_string(offset);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_undef_strp - lineno : %d macro : %s\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        lineno,
                        string,
                    );
                }
                7 => {
                    let mut amount_8: size_t = offset_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_8
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_8,
                                5 as libc::c_int,
                            ),
                            amount_8 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_8 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_8: size_t = end.offset_from(curr) as libc::c_long
                        as size_t;
                    if curr > end {
                        avail_8 = 0 as libc::c_int as size_t;
                    }
                    if amount_8 > avail_8 {
                        amount_8 = avail_8;
                    }
                    if amount_8 == 0 as libc::c_int as libc::c_ulong {
                        offset = 0 as libc::c_int as dwarf_vma;
                    } else {
                        offset = byte_get
                            .expect(
                                "non-null function pointer",
                            )(curr, amount_8 as libc::c_uint);
                    }
                    curr = curr.offset(amount_8 as isize);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_import - offset : 0x%lx\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        offset,
                    );
                }
                8 => {
                    let mut _val_8: dwarf_vma = 0;
                    let mut _len_8: libc::c_uint = 0;
                    let mut _status_8: libc::c_int = 0;
                    _val_8 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_8,
                        &mut _status_8,
                    );
                    curr = curr.offset(_len_8 as isize);
                    lineno = _val_8 as libc::c_uint;
                    if lineno as libc::c_ulong != _val_8 {
                        _status_8 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_8,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6124 as libc::c_int as libc::c_ulong,
                    );
                    let mut amount_9: size_t = offset_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_9
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_9,
                                5 as libc::c_int,
                            ),
                            amount_9 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_9 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_9: size_t = end.offset_from(curr) as libc::c_long
                        as size_t;
                    if curr > end {
                        avail_9 = 0 as libc::c_int as size_t;
                    }
                    if amount_9 > avail_9 {
                        amount_9 = avail_9;
                    }
                    if amount_9 == 0 as libc::c_int as libc::c_ulong {
                        offset = 0 as libc::c_int as dwarf_vma;
                    } else {
                        offset = byte_get
                            .expect(
                                "non-null function pointer",
                            )(curr, amount_9 as libc::c_uint);
                    }
                    curr = curr.offset(amount_9 as isize);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_define_sup - lineno : %d macro offset : 0x%lx\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        lineno,
                        offset,
                    );
                }
                9 => {
                    let mut _val_9: dwarf_vma = 0;
                    let mut _len_9: libc::c_uint = 0;
                    let mut _status_9: libc::c_int = 0;
                    _val_9 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_9,
                        &mut _status_9,
                    );
                    curr = curr.offset(_len_9 as isize);
                    lineno = _val_9 as libc::c_uint;
                    if lineno as libc::c_ulong != _val_9 {
                        _status_9 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_9,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6131 as libc::c_int as libc::c_ulong,
                    );
                    let mut amount_10: size_t = offset_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_10
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_10,
                                5 as libc::c_int,
                            ),
                            amount_10 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_10 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_10: size_t = end.offset_from(curr) as libc::c_long
                        as size_t;
                    if curr > end {
                        avail_10 = 0 as libc::c_int as size_t;
                    }
                    if amount_10 > avail_10 {
                        amount_10 = avail_10;
                    }
                    if amount_10 == 0 as libc::c_int as libc::c_ulong {
                        offset = 0 as libc::c_int as dwarf_vma;
                    } else {
                        offset = byte_get
                            .expect(
                                "non-null function pointer",
                            )(curr, amount_10 as libc::c_uint);
                    }
                    curr = curr.offset(amount_10 as isize);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_undef_sup - lineno : %d macro offset : 0x%lx\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        lineno,
                        offset,
                    );
                }
                10 => {
                    let mut amount_11: size_t = offset_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_11
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_11,
                                5 as libc::c_int,
                            ),
                            amount_11 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_11 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_11: size_t = end.offset_from(curr) as libc::c_long
                        as size_t;
                    if curr > end {
                        avail_11 = 0 as libc::c_int as size_t;
                    }
                    if amount_11 > avail_11 {
                        amount_11 = avail_11;
                    }
                    if amount_11 == 0 as libc::c_int as libc::c_ulong {
                        offset = 0 as libc::c_int as dwarf_vma;
                    } else {
                        offset = byte_get
                            .expect(
                                "non-null function pointer",
                            )(curr, amount_11 as libc::c_uint);
                    }
                    curr = curr.offset(amount_11 as isize);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b" DW_MACRO_import_sup - offset : 0x%lx\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        offset,
                    );
                }
                11 | 12 => {
                    let mut _val_10: dwarf_vma = 0;
                    let mut _len_10: libc::c_uint = 0;
                    let mut _status_10: libc::c_int = 0;
                    _val_10 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_10,
                        &mut _status_10,
                    );
                    curr = curr.offset(_len_10 as isize);
                    lineno = _val_10 as libc::c_uint;
                    if lineno as libc::c_ulong != _val_10 {
                        _status_10 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_10,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6145 as libc::c_int as libc::c_ulong,
                    );
                    let mut _val_11: dwarf_vma = 0;
                    let mut _len_11: libc::c_uint = 0;
                    let mut _status_11: libc::c_int = 0;
                    _val_11 = read_leb128(
                        curr,
                        end,
                        0 as libc::c_int != 0,
                        &mut _len_11,
                        &mut _status_11,
                    );
                    curr = curr.offset(_len_11 as isize);
                    offset = _val_11;
                    if offset != _val_11 {
                        _status_11 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_11,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6146 as libc::c_int as libc::c_ulong,
                    );
                    string = fetch_indexed_string(
                        offset,
                        0 as *mut cu_tu_set,
                        offset_size as dwarf_vma,
                        0 as libc::c_int != 0,
                    ) as *const libc::c_uchar;
                    if op_0 == DW_MACRO_define_strx as libc::c_int as libc::c_uint {
                        printf(
                            b" DW_MACRO_define_strx \0" as *const u8
                                as *const libc::c_char,
                        );
                    } else {
                        printf(
                            b" DW_MACRO_undef_strx \0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    if do_wide != 0 {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"(with offset %s) \0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            dwarf_vmatoa(
                                b"x\0" as *const u8 as *const libc::c_char,
                                offset,
                            ),
                        );
                    }
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"lineno : %d macro : %s\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        lineno,
                        string,
                    );
                }
                _ => {
                    if op_0 >= DW_MACRO_lo_user as libc::c_int as libc::c_uint
                        && op_0 <= DW_MACRO_hi_user as libc::c_int as libc::c_uint
                    {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" <Target Specific macro op: %#x - UNHANDLED\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            op_0,
                        );
                    } else if extended_ops.is_null()
                        || (*extended_ops.offset(op_0 as isize)).is_null()
                    {
                        error(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" Unknown macro opcode %02x seen\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            op_0,
                        );
                        return 0 as libc::c_int;
                    } else {
                        let mut nargs_0: dwarf_vma = 0;
                        let mut n_0: dwarf_vma = 0;
                        let mut desc: *mut libc::c_uchar = *extended_ops
                            .offset(op_0 as isize);
                        let mut _val_12: dwarf_vma = 0;
                        let mut _len_12: libc::c_uint = 0;
                        let mut _status_12: libc::c_int = 0;
                        _val_12 = read_leb128(
                            desc,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len_12,
                            &mut _status_12,
                        );
                        desc = desc.offset(_len_12 as isize);
                        nargs_0 = _val_12;
                        if nargs_0 != _val_12 {
                            _status_12 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_12,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            6176 as libc::c_int as libc::c_ulong,
                        );
                        if nargs_0 == 0 as libc::c_int as libc::c_ulong {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" DW_MACRO_%02x\n\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                op_0,
                            );
                        } else {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" DW_MACRO_%02x -\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                op_0,
                            );
                            n_0 = 0 as libc::c_int as dwarf_vma;
                            while n_0 < nargs_0 {
                                let mut val: libc::c_int = 0;
                                let mut amount_12: size_t = 1 as libc::c_int as size_t;
                                if (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                    < amount_12
                                {
                                    error(
                                        dcngettext(
                                            0 as *const libc::c_char,
                                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            amount_12,
                                            5 as libc::c_int,
                                        ),
                                        amount_12 as libc::c_int,
                                        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
                                            as libc::c_int,
                                    );
                                    amount_12 = ::core::mem::size_of::<libc::c_int>()
                                        as libc::c_ulong;
                                }
                                let mut avail_12: size_t = end.offset_from(desc)
                                    as libc::c_long as size_t;
                                if desc > end {
                                    avail_12 = 0 as libc::c_int as size_t;
                                }
                                if amount_12 > avail_12 {
                                    amount_12 = avail_12;
                                }
                                if amount_12 == 0 as libc::c_int as libc::c_ulong {
                                    val = 0 as libc::c_int;
                                } else {
                                    val = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(desc, amount_12 as libc::c_uint) as libc::c_int;
                                }
                                desc = desc.offset(amount_12 as isize);
                                curr = read_and_display_attr_value(
                                    0 as libc::c_int as libc::c_ulong,
                                    val as libc::c_ulong,
                                    0 as libc::c_int as dwarf_signed_vma,
                                    start,
                                    curr,
                                    end,
                                    0 as libc::c_int as dwarf_vma,
                                    0 as libc::c_int as dwarf_vma,
                                    offset_size as dwarf_vma,
                                    version as libc::c_int,
                                    0 as *mut debug_info,
                                    0 as libc::c_int,
                                    0 as *mut dwarf_section,
                                    0 as *mut cu_tu_set,
                                    ' ' as i32 as libc::c_char,
                                    -(1 as libc::c_int),
                                );
                                if n_0
                                    != nargs_0.wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                {
                                    printf(b",\0" as *const u8 as *const libc::c_char);
                                }
                                n_0 = n_0.wrapping_add(1);
                                n_0;
                            }
                            printf(b"\n\0" as *const u8 as *const libc::c_char);
                        }
                    }
                }
            }
        }
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_abbrev(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    let mut entry: *mut abbrev_entry = 0 as *mut abbrev_entry;
    let mut start: *mut libc::c_uchar = (*section).start;
    introduce(section, 0 as libc::c_int != 0);
    loop {
        let mut list: *mut abbrev_list = 0 as *mut abbrev_list;
        let mut offset: dwarf_vma = 0;
        offset = start.offset_from((*section).start) as libc::c_long as dwarf_vma;
        list = find_abbrev_list_by_abbrev_offset(0 as libc::c_int as dwarf_vma, offset);
        if list.is_null() {
            list = new_abbrev_list(0 as libc::c_int as dwarf_vma, offset);
            start = process_abbrev_set(
                section,
                0 as libc::c_int as dwarf_vma,
                (*section).size,
                offset,
                list,
            );
            (*list).start_of_next_abbrevs = start;
        } else {
            start = (*list).start_of_next_abbrevs;
        }
        if !((*list).first_abbrev).is_null() {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Number TAG (0x%lx)\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                offset as libc::c_long,
            );
            entry = (*list).first_abbrev;
            while !entry.is_null() {
                let mut attr: *mut abbrev_attr = 0 as *mut abbrev_attr;
                printf(
                    b"   %ld      %s    [%s]\n\0" as *const u8 as *const libc::c_char,
                    (*entry).number,
                    get_TAG_name((*entry).tag),
                    if (*entry).children != 0 {
                        dcgettext(
                            0 as *const libc::c_char,
                            b"has children\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        )
                    } else {
                        dcgettext(
                            0 as *const libc::c_char,
                            b"no children\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        )
                    },
                );
                attr = (*entry).first_attr;
                while !attr.is_null() {
                    printf(
                        b"    %-18s %s\0" as *const u8 as *const libc::c_char,
                        get_AT_name((*attr).attribute),
                        get_FORM_name((*attr).form),
                    );
                    if (*attr).form
                        == DW_FORM_implicit_const as libc::c_int as libc::c_ulong
                    {
                        printf(
                            b": %s\0" as *const u8 as *const libc::c_char,
                            dwarf_vmatoa(
                                b"d\0" as *const u8 as *const libc::c_char,
                                (*attr).implicit_const as dwarf_vma,
                            ),
                        );
                    }
                    putchar('\n' as i32);
                    attr = (*attr).next;
                }
                entry = (*entry).next;
            }
        }
        if start.is_null() {
            break;
        }
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
unsafe extern "C" fn is_max_address(
    mut addr: dwarf_vma,
    mut pointer_size: libc::c_uint,
) -> bool {
    let mut mask: dwarf_vma = !(!(1 as libc::c_int as dwarf_vma)
        << pointer_size
            .wrapping_mul(8 as libc::c_int as libc::c_uint)
            .wrapping_sub(1 as libc::c_int as libc::c_uint));
    return addr & mask == mask;
}
unsafe extern "C" fn display_view_pair_list(
    mut section: *mut dwarf_section,
    mut vstart_ptr: *mut *mut libc::c_uchar,
    mut debug_info_entry: libc::c_uint,
    mut vlistend: *mut libc::c_uchar,
) {
    let mut vstart: *mut libc::c_uchar = *vstart_ptr;
    let mut section_end: *mut libc::c_uchar = ((*section).start)
        .offset((*section).size as isize);
    let mut pointer_size: libc::c_uint = (*debug_information
        .offset(debug_info_entry as isize))
        .pointer_size;
    if vlistend < section_end {
        section_end = vlistend;
    }
    putchar('\n' as i32);
    while vstart < section_end {
        let mut off: dwarf_vma = vstart.offset_from((*section).start) as libc::c_long
            as dwarf_vma;
        let mut vbegin: dwarf_vma = 0;
        let mut vend: dwarf_vma = 0;
        let mut _val: dwarf_vma = 0;
        let mut _len: libc::c_uint = 0;
        let mut _status: libc::c_int = 0;
        _val = read_leb128(
            vstart,
            section_end,
            0 as libc::c_int != 0,
            &mut _len,
            &mut _status,
        );
        vstart = vstart.offset(_len as isize);
        vbegin = _val;
        if vbegin != _val {
            _status |= 2 as libc::c_int;
        }
        report_leb_status(
            _status,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            6299 as libc::c_int as libc::c_ulong,
        );
        if vstart == section_end {
            break;
        }
        let mut _val_0: dwarf_vma = 0;
        let mut _len_0: libc::c_uint = 0;
        let mut _status_0: libc::c_int = 0;
        _val_0 = read_leb128(
            vstart,
            section_end,
            0 as libc::c_int != 0,
            &mut _len_0,
            &mut _status_0,
        );
        vstart = vstart.offset(_len_0 as isize);
        vend = _val_0;
        if vend != _val_0 {
            _status_0 |= 2 as libc::c_int;
        }
        report_leb_status(
            _status_0,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            6303 as libc::c_int as libc::c_ulong,
        );
        printf(b"    %8.8lx \0" as *const u8 as *const libc::c_char, off);
        print_dwarf_view(vbegin, pointer_size, 1 as libc::c_int);
        print_dwarf_view(vend, pointer_size, 1 as libc::c_int);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"location view pair\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    putchar('\n' as i32);
    *vstart_ptr = vstart;
}
unsafe extern "C" fn display_loc_list(
    mut section: *mut dwarf_section,
    mut start_ptr: *mut *mut libc::c_uchar,
    mut debug_info_entry: libc::c_uint,
    mut offset: dwarf_vma,
    mut base_address: dwarf_vma,
    mut vstart_ptr: *mut *mut libc::c_uchar,
    mut has_frame_base: libc::c_int,
) {
    let mut start: *mut libc::c_uchar = *start_ptr;
    let mut vstart: *mut libc::c_uchar = *vstart_ptr;
    let mut section_end: *mut libc::c_uchar = ((*section).start)
        .offset((*section).size as isize);
    let mut cu_offset: libc::c_ulong = 0;
    let mut pointer_size: libc::c_uint = 0;
    let mut offset_size: libc::c_uint = 0;
    let mut dwarf_version: libc::c_int = 0;
    let mut begin: dwarf_vma = 0;
    let mut end: dwarf_vma = 0;
    let mut length: libc::c_ushort = 0;
    let mut need_frame_base: libc::c_int = 0;
    if debug_info_entry >= num_debug_info_entries {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"No debug information available for loc lists of entry: %u\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            debug_info_entry,
        );
        return;
    }
    cu_offset = (*debug_information.offset(debug_info_entry as isize)).cu_offset;
    pointer_size = (*debug_information.offset(debug_info_entry as isize)).pointer_size;
    offset_size = (*debug_information.offset(debug_info_entry as isize)).offset_size;
    dwarf_version = (*debug_information.offset(debug_info_entry as isize)).dwarf_version;
    if pointer_size < 2 as libc::c_int as libc::c_uint
        || pointer_size > 8 as libc::c_int as libc::c_uint
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Invalid pointer size (%d) in debug info for entry %d\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            pointer_size,
            debug_info_entry,
        );
        return;
    }
    loop {
        let mut off: dwarf_vma = offset
            .wrapping_add(
                start.offset_from(*start_ptr) as libc::c_long as libc::c_ulong,
            );
        let mut vbegin: dwarf_vma = vm1;
        let mut vend: dwarf_vma = vm1;
        if (2 as libc::c_int as libc::c_uint).wrapping_mul(pointer_size) as libc::c_ulong
            > section_end.offset_from(start) as libc::c_long as size_t
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Location list starting at offset 0x%lx is not terminated.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                offset,
            );
            break;
        } else {
            printf(b"    %8.8lx \0" as *const u8 as *const libc::c_char, off);
            let mut amount: size_t = pointer_size as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount,
                        5 as libc::c_int,
                    ),
                    amount as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail: size_t = section_end.offset_from(start) as libc::c_long
                as size_t;
            if start > section_end {
                avail = 0 as libc::c_int as size_t;
            }
            if amount > avail {
                amount = avail;
            }
            if amount == 0 as libc::c_int as libc::c_ulong {
                begin = 0 as libc::c_int as dwarf_vma;
            } else {
                begin = byte_get
                    .expect("non-null function pointer")(start, amount as libc::c_uint);
            }
            start = start.offset(amount as isize);
            let mut amount_0: size_t = pointer_size as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_0,
                        5 as libc::c_int,
                    ),
                    amount_0 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_0: size_t = section_end.offset_from(start) as libc::c_long
                as size_t;
            if start > section_end {
                avail_0 = 0 as libc::c_int as size_t;
            }
            if amount_0 > avail_0 {
                amount_0 = avail_0;
            }
            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                end = 0 as libc::c_int as dwarf_vma;
            } else {
                end = byte_get
                    .expect(
                        "non-null function pointer",
                    )(start, amount_0 as libc::c_uint);
            }
            start = start.offset(amount_0 as isize);
            if begin == 0 as libc::c_int as libc::c_ulong
                && end == 0 as libc::c_int as libc::c_ulong
            {
                if !reloc_at(section, off)
                    && !reloc_at(
                        section,
                        off.wrapping_add(pointer_size as libc::c_ulong),
                    )
                {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<End of list>\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    break;
                }
            }
            if is_max_address(begin, pointer_size) as libc::c_int != 0
                && !is_max_address(end, pointer_size)
            {
                base_address = end;
                print_dwarf_vma(begin, pointer_size);
                print_dwarf_vma(end, pointer_size);
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"(base address)\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            } else {
                if !vstart.is_null() {
                    off = offset
                        .wrapping_add(
                            vstart.offset_from(*start_ptr) as libc::c_long
                                as libc::c_ulong,
                        );
                    let mut _val: dwarf_vma = 0;
                    let mut _len: libc::c_uint = 0;
                    let mut _status: libc::c_int = 0;
                    _val = read_leb128(
                        vstart,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len,
                        &mut _status,
                    );
                    vstart = vstart.offset(_len as isize);
                    vbegin = _val;
                    if vbegin != _val {
                        _status |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6405 as libc::c_int as libc::c_ulong,
                    );
                    print_dwarf_view(vbegin, pointer_size, 1 as libc::c_int);
                    let mut _val_0: dwarf_vma = 0;
                    let mut _len_0: libc::c_uint = 0;
                    let mut _status_0: libc::c_int = 0;
                    _val_0 = read_leb128(
                        vstart,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_0,
                        &mut _status_0,
                    );
                    vstart = vstart.offset(_len_0 as isize);
                    vend = _val_0;
                    if vend != _val_0 {
                        _status_0 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_0,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6408 as libc::c_int as libc::c_ulong,
                    );
                    print_dwarf_view(vend, pointer_size, 1 as libc::c_int);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"views at %8.8lx for:\n    %*s \0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        off,
                        8 as libc::c_int,
                        b"\0" as *const u8 as *const libc::c_char,
                    );
                }
                if 2 as libc::c_int as libc::c_ulong
                    > section_end.offset_from(start) as libc::c_long as size_t
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Location list starting at offset 0x%lx is not terminated.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        offset,
                    );
                    break;
                } else {
                    let mut amount_1: size_t = 2 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong)
                        < amount_1
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_1,
                                5 as libc::c_int,
                            ),
                            amount_1 as libc::c_int,
                            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_1 = ::core::mem::size_of::<libc::c_ushort>()
                            as libc::c_ulong;
                    }
                    let mut avail_1: size_t = section_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > section_end {
                        avail_1 = 0 as libc::c_int as size_t;
                    }
                    if amount_1 > avail_1 {
                        amount_1 = avail_1;
                    }
                    if amount_1 == 0 as libc::c_int as libc::c_ulong {
                        length = 0 as libc::c_int as libc::c_ushort;
                    } else {
                        length = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_1 as libc::c_uint) as libc::c_ushort;
                    }
                    start = start.offset(amount_1 as isize);
                    if length as libc::c_ulong
                        > section_end.offset_from(start) as libc::c_long as size_t
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Location list starting at offset 0x%lx is not terminated.\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            offset,
                        );
                        break;
                    } else {
                        print_dwarf_vma(begin.wrapping_add(base_address), pointer_size);
                        print_dwarf_vma(end.wrapping_add(base_address), pointer_size);
                        putchar('(' as i32);
                        need_frame_base = decode_location_expression(
                            start,
                            pointer_size,
                            offset_size,
                            dwarf_version,
                            length as dwarf_vma,
                            cu_offset,
                            section,
                        );
                        putchar(')' as i32);
                        if need_frame_base != 0 && has_frame_base == 0 {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" [without DW_AT_frame_base]\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                        }
                        if begin == end && vbegin == vend {
                            fputs(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" (start == end)\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                stdout,
                            );
                        } else if begin > end || begin == end && vbegin > vend {
                            fputs(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b" (start > end)\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                stdout,
                            );
                        }
                        putchar('\n' as i32);
                        start = start.offset(length as libc::c_int as isize);
                    }
                }
            }
        }
    }
    *start_ptr = start;
    *vstart_ptr = vstart;
}
unsafe extern "C" fn display_loclists_list(
    mut section: *mut dwarf_section,
    mut start_ptr: *mut *mut libc::c_uchar,
    mut debug_info_entry: libc::c_uint,
    mut offset: dwarf_vma,
    mut base_address: dwarf_vma,
    mut vstart_ptr: *mut *mut libc::c_uchar,
    mut has_frame_base: libc::c_int,
) {
    let mut start: *mut libc::c_uchar = *start_ptr;
    let mut vstart: *mut libc::c_uchar = *vstart_ptr;
    let mut section_end: *mut libc::c_uchar = ((*section).start)
        .offset((*section).size as isize);
    let mut cu_offset: libc::c_ulong = 0;
    let mut pointer_size: libc::c_uint = 0;
    let mut offset_size: libc::c_uint = 0;
    let mut dwarf_version: libc::c_int = 0;
    let mut begin: dwarf_vma = -(1 as libc::c_int) as dwarf_vma;
    let mut vbegin: dwarf_vma = -(1 as libc::c_int) as dwarf_vma;
    let mut end: dwarf_vma = -(1 as libc::c_int) as dwarf_vma;
    let mut vend: dwarf_vma = -(1 as libc::c_int) as dwarf_vma;
    let mut length: dwarf_vma = 0;
    let mut need_frame_base: libc::c_int = 0;
    if debug_info_entry >= num_debug_info_entries {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"No debug information available for loclists lists of entry: %u\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            debug_info_entry,
        );
        return;
    }
    cu_offset = (*debug_information.offset(debug_info_entry as isize)).cu_offset;
    pointer_size = (*debug_information.offset(debug_info_entry as isize)).pointer_size;
    offset_size = (*debug_information.offset(debug_info_entry as isize)).offset_size;
    dwarf_version = (*debug_information.offset(debug_info_entry as isize)).dwarf_version;
    if pointer_size < 2 as libc::c_int as libc::c_uint
        || pointer_size > 8 as libc::c_int as libc::c_uint
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Invalid pointer size (%d) in debug info for entry %d\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            pointer_size,
            debug_info_entry,
        );
        return;
    }
    loop {
        let mut off: dwarf_vma = offset
            .wrapping_add(
                start.offset_from(*start_ptr) as libc::c_long as libc::c_ulong,
            );
        let mut llet: dwarf_location_list_entry_type = DW_LLE_end_of_list;
        if start.offset(1 as libc::c_int as isize) > section_end {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Location list starting at offset 0x%lx is not terminated.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                offset,
            );
            break;
        } else {
            printf(b"    %8.8lx \0" as *const u8 as *const libc::c_char, off);
            let mut amount: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_location_list_entry_type>()
                as libc::c_ulong) < amount
            {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount,
                        5 as libc::c_int,
                    ),
                    amount as libc::c_int,
                    ::core::mem::size_of::<dwarf_location_list_entry_type>()
                        as libc::c_ulong as libc::c_int,
                );
                amount = ::core::mem::size_of::<dwarf_location_list_entry_type>()
                    as libc::c_ulong;
            }
            let mut avail: size_t = section_end.offset_from(start) as libc::c_long
                as size_t;
            if start > section_end {
                avail = 0 as libc::c_int as size_t;
            }
            if amount > avail {
                amount = avail;
            }
            if amount == 0 as libc::c_int as libc::c_ulong {
                llet = DW_LLE_end_of_list;
            } else {
                llet = byte_get
                    .expect("non-null function pointer")(start, amount as libc::c_uint)
                    as dwarf_location_list_entry_type;
            }
            start = start.offset(amount as isize);
            if !vstart.is_null()
                && (llet as libc::c_uint
                    == DW_LLE_offset_pair as libc::c_int as libc::c_uint
                    || llet as libc::c_uint
                        == DW_LLE_start_end as libc::c_int as libc::c_uint
                    || llet as libc::c_uint
                        == DW_LLE_start_length as libc::c_int as libc::c_uint)
            {
                off = offset
                    .wrapping_add(
                        vstart.offset_from(*start_ptr) as libc::c_long as libc::c_ulong,
                    );
                let mut _val: dwarf_vma = 0;
                let mut _len: libc::c_uint = 0;
                let mut _status: libc::c_int = 0;
                _val = read_leb128(
                    vstart,
                    section_end,
                    0 as libc::c_int != 0,
                    &mut _len,
                    &mut _status,
                );
                vstart = vstart.offset(_len as isize);
                vbegin = _val;
                if vbegin != _val {
                    _status |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    6526 as libc::c_int as libc::c_ulong,
                );
                print_dwarf_view(vbegin, pointer_size, 1 as libc::c_int);
                let mut _val_0: dwarf_vma = 0;
                let mut _len_0: libc::c_uint = 0;
                let mut _status_0: libc::c_int = 0;
                _val_0 = read_leb128(
                    vstart,
                    section_end,
                    0 as libc::c_int != 0,
                    &mut _len_0,
                    &mut _status_0,
                );
                vstart = vstart.offset(_len_0 as isize);
                vend = _val_0;
                if vend != _val_0 {
                    _status_0 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_0,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    6529 as libc::c_int as libc::c_ulong,
                );
                print_dwarf_view(vend, pointer_size, 1 as libc::c_int);
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"views at %8.8lx for:\n    %*s \0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    off,
                    8 as libc::c_int,
                    b"\0" as *const u8 as *const libc::c_char,
                );
            }
            match llet as libc::c_uint {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<End of list>\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                4 => {
                    let mut _val_1: dwarf_vma = 0;
                    let mut _len_1: libc::c_uint = 0;
                    let mut _status_1: libc::c_int = 0;
                    _val_1 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_1,
                        &mut _status_1,
                    );
                    start = start.offset(_len_1 as isize);
                    begin = _val_1;
                    if begin != _val_1 {
                        _status_1 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_1,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6542 as libc::c_int as libc::c_ulong,
                    );
                    begin = (begin as libc::c_ulong).wrapping_add(base_address)
                        as dwarf_vma as dwarf_vma;
                    let mut _val_2: dwarf_vma = 0;
                    let mut _len_2: libc::c_uint = 0;
                    let mut _status_2: libc::c_int = 0;
                    _val_2 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_2,
                        &mut _status_2,
                    );
                    start = start.offset(_len_2 as isize);
                    end = _val_2;
                    if end != _val_2 {
                        _status_2 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_2,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6544 as libc::c_int as libc::c_ulong,
                    );
                    end = (end as libc::c_ulong).wrapping_add(base_address) as dwarf_vma
                        as dwarf_vma;
                }
                7 => {
                    let mut amount_0: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_0,
                                5 as libc::c_int,
                            ),
                            amount_0 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_0: size_t = section_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > section_end {
                        avail_0 = 0 as libc::c_int as size_t;
                    }
                    if amount_0 > avail_0 {
                        amount_0 = avail_0;
                    }
                    if amount_0 == 0 as libc::c_int as libc::c_ulong {
                        begin = 0 as libc::c_int as dwarf_vma;
                    } else {
                        begin = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_0 as libc::c_uint);
                    }
                    start = start.offset(amount_0 as isize);
                    let mut amount_1: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_1
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_1,
                                5 as libc::c_int,
                            ),
                            amount_1 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_1 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_1: size_t = section_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > section_end {
                        avail_1 = 0 as libc::c_int as size_t;
                    }
                    if amount_1 > avail_1 {
                        amount_1 = avail_1;
                    }
                    if amount_1 == 0 as libc::c_int as libc::c_ulong {
                        end = 0 as libc::c_int as dwarf_vma;
                    } else {
                        end = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_1 as libc::c_uint);
                    }
                    start = start.offset(amount_1 as isize);
                }
                8 => {
                    let mut amount_2: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_2
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_2,
                                5 as libc::c_int,
                            ),
                            amount_2 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_2 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_2: size_t = section_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > section_end {
                        avail_2 = 0 as libc::c_int as size_t;
                    }
                    if amount_2 > avail_2 {
                        amount_2 = avail_2;
                    }
                    if amount_2 == 0 as libc::c_int as libc::c_ulong {
                        begin = 0 as libc::c_int as dwarf_vma;
                    } else {
                        begin = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_2 as libc::c_uint);
                    }
                    start = start.offset(amount_2 as isize);
                    let mut _val_3: dwarf_vma = 0;
                    let mut _len_3: libc::c_uint = 0;
                    let mut _status_3: libc::c_int = 0;
                    _val_3 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_3,
                        &mut _status_3,
                    );
                    start = start.offset(_len_3 as isize);
                    end = _val_3;
                    if end != _val_3 {
                        _status_3 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_3,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6553 as libc::c_int as libc::c_ulong,
                    );
                    end = (end as libc::c_ulong).wrapping_add(begin) as dwarf_vma
                        as dwarf_vma;
                }
                6 => {
                    let mut amount_3: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_3
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_3,
                                5 as libc::c_int,
                            ),
                            amount_3 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_3 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_3: size_t = section_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > section_end {
                        avail_3 = 0 as libc::c_int as size_t;
                    }
                    if amount_3 > avail_3 {
                        amount_3 = avail_3;
                    }
                    if amount_3 == 0 as libc::c_int as libc::c_ulong {
                        base_address = 0 as libc::c_int as dwarf_vma;
                    } else {
                        base_address = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_3 as libc::c_uint);
                    }
                    start = start.offset(amount_3 as isize);
                    print_dwarf_vma(base_address, pointer_size);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(base address)\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                9 => {
                    if !vstart.is_null() {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"View pair entry in loclist with locviews attribute\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    let mut _val_4: dwarf_vma = 0;
                    let mut _len_4: libc::c_uint = 0;
                    let mut _status_4: libc::c_int = 0;
                    _val_4 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_4,
                        &mut _status_4,
                    );
                    start = start.offset(_len_4 as isize);
                    vbegin = _val_4;
                    if vbegin != _val_4 {
                        _status_4 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_4,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6566 as libc::c_int as libc::c_ulong,
                    );
                    print_dwarf_view(vbegin, pointer_size, 1 as libc::c_int);
                    let mut _val_5: dwarf_vma = 0;
                    let mut _len_5: libc::c_uint = 0;
                    let mut _status_5: libc::c_int = 0;
                    _val_5 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_5,
                        &mut _status_5,
                    );
                    start = start.offset(_len_5 as isize);
                    vend = _val_5;
                    if vend != _val_5 {
                        _status_5 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_5,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6569 as libc::c_int as libc::c_ulong,
                    );
                    print_dwarf_view(vend, pointer_size, 1 as libc::c_int);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"views for:\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    continue;
                }
                _ => {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Invalid location list entry type %d\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        llet as libc::c_uint,
                    );
                    return;
                }
            }
            if llet as libc::c_uint == DW_LLE_end_of_list as libc::c_int as libc::c_uint
            {
                break;
            }
            if llet as libc::c_uint != DW_LLE_offset_pair as libc::c_int as libc::c_uint
                && llet as libc::c_uint
                    != DW_LLE_start_end as libc::c_int as libc::c_uint
                && llet as libc::c_uint
                    != DW_LLE_start_length as libc::c_int as libc::c_uint
            {
                continue;
            }
            if start == section_end {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Location list starting at offset 0x%lx is not terminated.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    offset,
                );
                break;
            } else {
                let mut _val_6: dwarf_vma = 0;
                let mut _len_6: libc::c_uint = 0;
                let mut _status_6: libc::c_int = 0;
                _val_6 = read_leb128(
                    start,
                    section_end,
                    0 as libc::c_int != 0,
                    &mut _len_6,
                    &mut _status_6,
                );
                start = start.offset(_len_6 as isize);
                length = _val_6;
                if length != _val_6 {
                    _status_6 |= 2 as libc::c_int;
                }
                report_leb_status(
                    _status_6,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    6592 as libc::c_int as libc::c_ulong,
                );
                if length > section_end.offset_from(start) as libc::c_long as size_t {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Location list starting at offset 0x%lx is not terminated.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        offset,
                    );
                    break;
                } else {
                    print_dwarf_vma(begin, pointer_size);
                    print_dwarf_vma(end, pointer_size);
                    putchar('(' as i32);
                    need_frame_base = decode_location_expression(
                        start,
                        pointer_size,
                        offset_size,
                        dwarf_version,
                        length,
                        cu_offset,
                        section,
                    );
                    putchar(')' as i32);
                    if need_frame_base != 0 && has_frame_base == 0 {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" [without DW_AT_frame_base]\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    if begin == end && vbegin == vend {
                        fputs(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" (start == end)\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            stdout,
                        );
                    } else if begin > end || begin == end && vbegin > vend {
                        fputs(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" (start > end)\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            stdout,
                        );
                    }
                    putchar('\n' as i32);
                    start = start.offset(length as isize);
                    vend = -(1 as libc::c_int) as dwarf_vma;
                    vbegin = vend;
                }
            }
        }
    }
    if vbegin != vm1 || vend != vm1 {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"Trailing view pair not used in a range\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    *start_ptr = start;
    *vstart_ptr = vstart;
}
unsafe extern "C" fn print_addr_index(mut idx: libc::c_uint, mut len: libc::c_uint) {
    static mut buf: [libc::c_char; 15] = [0; 15];
    snprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong,
        b"[%d]\0" as *const u8 as *const libc::c_char,
        idx,
    );
    printf(b"%*s \0" as *const u8 as *const libc::c_char, len, buf.as_mut_ptr());
}
unsafe extern "C" fn display_loc_list_dwo(
    mut section: *mut dwarf_section,
    mut start_ptr: *mut *mut libc::c_uchar,
    mut debug_info_entry: libc::c_uint,
    mut offset: dwarf_vma,
    mut vstart_ptr: *mut *mut libc::c_uchar,
    mut has_frame_base: libc::c_int,
) {
    let mut start: *mut libc::c_uchar = *start_ptr;
    let mut vstart: *mut libc::c_uchar = *vstart_ptr;
    let mut section_end: *mut libc::c_uchar = ((*section).start)
        .offset((*section).size as isize);
    let mut cu_offset: libc::c_ulong = 0;
    let mut pointer_size: libc::c_uint = 0;
    let mut offset_size: libc::c_uint = 0;
    let mut dwarf_version: libc::c_int = 0;
    let mut entry_type: libc::c_int = 0;
    let mut length: libc::c_ushort = 0;
    let mut need_frame_base: libc::c_int = 0;
    let mut idx: libc::c_uint = 0;
    if debug_info_entry >= num_debug_info_entries {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"No debug information for loc lists of entry: %u\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            debug_info_entry,
        );
        return;
    }
    cu_offset = (*debug_information.offset(debug_info_entry as isize)).cu_offset;
    pointer_size = (*debug_information.offset(debug_info_entry as isize)).pointer_size;
    offset_size = (*debug_information.offset(debug_info_entry as isize)).offset_size;
    dwarf_version = (*debug_information.offset(debug_info_entry as isize)).dwarf_version;
    if pointer_size < 2 as libc::c_int as libc::c_uint
        || pointer_size > 8 as libc::c_int as libc::c_uint
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Invalid pointer size (%d) in debug info for entry %d\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            pointer_size,
            debug_info_entry,
        );
        return;
    }
    loop {
        printf(
            b"    %8.8lx \0" as *const u8 as *const libc::c_char,
            offset
                .wrapping_add(
                    start.offset_from(*start_ptr) as libc::c_long as libc::c_ulong,
                ),
        );
        if start >= section_end {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Location list starting at offset 0x%lx is not terminated.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                offset,
            );
            break;
        } else {
            let mut amount: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_int>() as libc::c_ulong) < amount {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount,
                        5 as libc::c_int,
                    ),
                    amount as libc::c_int,
                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int,
                );
                amount = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong;
            }
            let mut avail: size_t = section_end.offset_from(start) as libc::c_long
                as size_t;
            if start > section_end {
                avail = 0 as libc::c_int as size_t;
            }
            if amount > avail {
                amount = avail;
            }
            if amount == 0 as libc::c_int as libc::c_ulong {
                entry_type = 0 as libc::c_int;
            } else {
                entry_type = byte_get
                    .expect("non-null function pointer")(start, amount as libc::c_uint)
                    as libc::c_int;
            }
            start = start.offset(amount as isize);
            if !vstart.is_null() {
                match entry_type {
                    2 | 3 | 4 => {
                        let mut view: dwarf_vma = 0;
                        let mut off: dwarf_vma = offset
                            .wrapping_add(
                                vstart.offset_from(*start_ptr) as libc::c_long
                                    as libc::c_ulong,
                            );
                        let mut _val: dwarf_vma = 0;
                        let mut _len: libc::c_uint = 0;
                        let mut _status: libc::c_int = 0;
                        _val = read_leb128(
                            vstart,
                            section_end,
                            0 as libc::c_int != 0,
                            &mut _len,
                            &mut _status,
                        );
                        vstart = vstart.offset(_len as isize);
                        view = _val;
                        if view != _val {
                            _status |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            6713 as libc::c_int as libc::c_ulong,
                        );
                        print_dwarf_view(
                            view,
                            8 as libc::c_int as libc::c_uint,
                            1 as libc::c_int,
                        );
                        let mut _val_0: dwarf_vma = 0;
                        let mut _len_0: libc::c_uint = 0;
                        let mut _status_0: libc::c_int = 0;
                        _val_0 = read_leb128(
                            vstart,
                            section_end,
                            0 as libc::c_int != 0,
                            &mut _len_0,
                            &mut _status_0,
                        );
                        vstart = vstart.offset(_len_0 as isize);
                        view = _val_0;
                        if view != _val_0 {
                            _status_0 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_0,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            6716 as libc::c_int as libc::c_ulong,
                        );
                        print_dwarf_view(
                            view,
                            8 as libc::c_int as libc::c_uint,
                            1 as libc::c_int,
                        );
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"views at %8.8lx for:\n    %*s \0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            off,
                            8 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {}
                }
            }
            match entry_type {
                0 => {
                    *start_ptr = start;
                    *vstart_ptr = vstart;
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<End of list>\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return;
                }
                1 => {
                    let mut _val_1: dwarf_vma = 0;
                    let mut _len_1: libc::c_uint = 0;
                    let mut _status_1: libc::c_int = 0;
                    _val_1 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_1,
                        &mut _status_1,
                    );
                    start = start.offset(_len_1 as isize);
                    idx = _val_1 as libc::c_uint;
                    if idx as libc::c_ulong != _val_1 {
                        _status_1 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_1,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6734 as libc::c_int as libc::c_ulong,
                    );
                    print_addr_index(idx, 8 as libc::c_int as libc::c_uint);
                    printf(
                        b"%*s\0" as *const u8 as *const libc::c_char,
                        9 as libc::c_int
                            + (if !vstart.is_null() {
                                2 as libc::c_int * 6 as libc::c_int
                            } else {
                                0 as libc::c_int
                            }),
                        b"\0" as *const u8 as *const libc::c_char,
                    );
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(base address selection entry)\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    continue;
                }
                2 => {
                    let mut _val_2: dwarf_vma = 0;
                    let mut _len_2: libc::c_uint = 0;
                    let mut _status_2: libc::c_int = 0;
                    _val_2 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_2,
                        &mut _status_2,
                    );
                    start = start.offset(_len_2 as isize);
                    idx = _val_2 as libc::c_uint;
                    if idx as libc::c_ulong != _val_2 {
                        _status_2 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_2,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6740 as libc::c_int as libc::c_ulong,
                    );
                    print_addr_index(idx, 8 as libc::c_int as libc::c_uint);
                    let mut _val_3: dwarf_vma = 0;
                    let mut _len_3: libc::c_uint = 0;
                    let mut _status_3: libc::c_int = 0;
                    _val_3 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_3,
                        &mut _status_3,
                    );
                    start = start.offset(_len_3 as isize);
                    idx = _val_3 as libc::c_uint;
                    if idx as libc::c_ulong != _val_3 {
                        _status_3 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_3,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6742 as libc::c_int as libc::c_ulong,
                    );
                    print_addr_index(idx, 8 as libc::c_int as libc::c_uint);
                }
                3 => {
                    let mut _val_4: dwarf_vma = 0;
                    let mut _len_4: libc::c_uint = 0;
                    let mut _status_4: libc::c_int = 0;
                    _val_4 = read_leb128(
                        start,
                        section_end,
                        0 as libc::c_int != 0,
                        &mut _len_4,
                        &mut _status_4,
                    );
                    start = start.offset(_len_4 as isize);
                    idx = _val_4 as libc::c_uint;
                    if idx as libc::c_ulong != _val_4 {
                        _status_4 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_4,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        6746 as libc::c_int as libc::c_ulong,
                    );
                    print_addr_index(idx, 8 as libc::c_int as libc::c_uint);
                    let mut amount_0: size_t = 4 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        < amount_0
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_0,
                                5 as libc::c_int,
                            ),
                            amount_0 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_0 = ::core::mem::size_of::<libc::c_uint>()
                            as libc::c_ulong;
                    }
                    let mut avail_0: size_t = section_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > section_end {
                        avail_0 = 0 as libc::c_int as size_t;
                    }
                    if amount_0 > avail_0 {
                        amount_0 = avail_0;
                    }
                    if amount_0 == 0 as libc::c_int as libc::c_ulong {
                        idx = 0 as libc::c_int as libc::c_uint;
                    } else {
                        idx = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_0 as libc::c_uint) as libc::c_uint;
                    }
                    start = start.offset(amount_0 as isize);
                    printf(b"%08x \0" as *const u8 as *const libc::c_char, idx);
                }
                4 => {
                    let mut amount_1: size_t = 4 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        < amount_1
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_1,
                                5 as libc::c_int,
                            ),
                            amount_1 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_1 = ::core::mem::size_of::<libc::c_uint>()
                            as libc::c_ulong;
                    }
                    let mut avail_1: size_t = section_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > section_end {
                        avail_1 = 0 as libc::c_int as size_t;
                    }
                    if amount_1 > avail_1 {
                        amount_1 = avail_1;
                    }
                    if amount_1 == 0 as libc::c_int as libc::c_ulong {
                        idx = 0 as libc::c_int as libc::c_uint;
                    } else {
                        idx = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_1 as libc::c_uint) as libc::c_uint;
                    }
                    start = start.offset(amount_1 as isize);
                    printf(b"%08x \0" as *const u8 as *const libc::c_char, idx);
                    let mut amount_2: size_t = 4 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        < amount_2
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_2,
                                5 as libc::c_int,
                            ),
                            amount_2 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_2 = ::core::mem::size_of::<libc::c_uint>()
                            as libc::c_ulong;
                    }
                    let mut avail_2: size_t = section_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > section_end {
                        avail_2 = 0 as libc::c_int as size_t;
                    }
                    if amount_2 > avail_2 {
                        amount_2 = avail_2;
                    }
                    if amount_2 == 0 as libc::c_int as libc::c_ulong {
                        idx = 0 as libc::c_int as libc::c_uint;
                    } else {
                        idx = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_2 as libc::c_uint) as libc::c_uint;
                    }
                    start = start.offset(amount_2 as isize);
                    printf(b"%08x \0" as *const u8 as *const libc::c_char, idx);
                }
                _ => {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Unknown location list entry type 0x%x.\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        entry_type,
                    );
                    *start_ptr = start;
                    *vstart_ptr = vstart;
                    return;
                }
            }
            if 2 as libc::c_int as libc::c_ulong
                > section_end.offset_from(start) as libc::c_long as size_t
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Location list starting at offset 0x%lx is not terminated.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    offset,
                );
                break;
            } else {
                let mut amount_3: size_t = 2 as libc::c_int as size_t;
                if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong) < amount_3
                {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_3,
                            5 as libc::c_int,
                        ),
                        amount_3 as libc::c_int,
                        ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_3 = ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong;
                }
                let mut avail_3: size_t = section_end.offset_from(start) as libc::c_long
                    as size_t;
                if start > section_end {
                    avail_3 = 0 as libc::c_int as size_t;
                }
                if amount_3 > avail_3 {
                    amount_3 = avail_3;
                }
                if amount_3 == 0 as libc::c_int as libc::c_ulong {
                    length = 0 as libc::c_int as libc::c_ushort;
                } else {
                    length = byte_get
                        .expect(
                            "non-null function pointer",
                        )(start, amount_3 as libc::c_uint) as libc::c_ushort;
                }
                start = start.offset(amount_3 as isize);
                if length as libc::c_ulong
                    > section_end.offset_from(start) as libc::c_long as size_t
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Location list starting at offset 0x%lx is not terminated.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        offset,
                    );
                    break;
                } else {
                    putchar('(' as i32);
                    need_frame_base = decode_location_expression(
                        start,
                        pointer_size,
                        offset_size,
                        dwarf_version,
                        length as dwarf_vma,
                        cu_offset,
                        section,
                    );
                    putchar(')' as i32);
                    if need_frame_base != 0 && has_frame_base == 0 {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b" [without DW_AT_frame_base]\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    putchar('\n' as i32);
                    start = start.offset(length as libc::c_int as isize);
                }
            }
        }
    }
    *start_ptr = start;
    *vstart_ptr = vstart;
}
static mut loc_offsets: *mut dwarf_vma = 0 as *const dwarf_vma as *mut dwarf_vma;
static mut loc_views: *mut dwarf_vma = 0 as *const dwarf_vma as *mut dwarf_vma;
unsafe extern "C" fn loc_offsets_compar(
    mut ap: *const libc::c_void,
    mut bp: *const libc::c_void,
) -> libc::c_int {
    let mut a: dwarf_vma = *loc_offsets.offset(*(ap as *const libc::c_uint) as isize);
    let mut b: dwarf_vma = *loc_offsets.offset(*(bp as *const libc::c_uint) as isize);
    let mut ret: libc::c_int = (a > b) as libc::c_int - (b > a) as libc::c_int;
    if ret != 0 {
        return ret;
    }
    a = *loc_views.offset(*(ap as *const libc::c_uint) as isize);
    b = *loc_views.offset(*(bp as *const libc::c_uint) as isize);
    ret = (a > b) as libc::c_int - (b > a) as libc::c_int;
    return ret;
}
unsafe extern "C" fn display_debug_loc(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut vstart: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut bytes: libc::c_ulong = 0;
    let mut section_begin: *mut libc::c_uchar = start;
    let mut num_loc_list: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut last_offset: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut last_view: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut first: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    let mut seen_first_offset: libc::c_int = 0 as libc::c_int;
    let mut locs_sorted: libc::c_int = 1 as libc::c_int;
    let mut next: *mut libc::c_uchar = start;
    let mut vnext: *mut libc::c_uchar = vstart;
    let mut array: *mut libc::c_uint = 0 as *mut libc::c_uint;
    let mut suffix: *const libc::c_char = strrchr((*section).name, '.' as i32);
    let mut is_dwo: bool = 0 as libc::c_int != 0;
    let mut is_loclists: libc::c_int = (strstr(
        (*section).name,
        b"debug_loclists\0" as *const u8 as *const libc::c_char,
    ) != 0 as *mut libc::c_void as *mut libc::c_char) as libc::c_int;
    let mut expected_start: dwarf_vma = 0 as libc::c_int as dwarf_vma;
    if !suffix.is_null()
        && strcmp(suffix, b".dwo\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        is_dwo = 1 as libc::c_int != 0;
    }
    bytes = (*section).size;
    if bytes == 0 as libc::c_int as libc::c_ulong {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nThe %s section is empty.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    if is_loclists != 0 {
        let mut hdrptr: *mut libc::c_uchar = section_begin;
        let mut ll_length: dwarf_vma = 0;
        let mut ll_version: libc::c_ushort = 0;
        let mut end: *mut libc::c_uchar = section_begin.offset((*section).size as isize);
        let mut address_size: libc::c_uchar = 0;
        let mut segment_selector_size: libc::c_uchar = 0;
        let mut offset_entry_count: uint32_t = 0;
        let mut amount: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            ll_length = 0 as libc::c_int as dwarf_vma;
        } else {
            ll_length = byte_get
                .expect("non-null function pointer")(hdrptr, amount as libc::c_uint);
        }
        hdrptr = hdrptr.offset(amount as isize);
        if ll_length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_0: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_0,
                        5 as libc::c_int,
                    ),
                    amount_0 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_0: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
            if hdrptr > end {
                avail_0 = 0 as libc::c_int as size_t;
            }
            if amount_0 > avail_0 {
                amount_0 = avail_0;
            }
            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                ll_length = 0 as libc::c_int as dwarf_vma;
            } else {
                ll_length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_0 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_0 as isize);
        }
        let mut amount_1: size_t = 2 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong) < amount_1 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_1,
                    5 as libc::c_int,
                ),
                amount_1 as libc::c_int,
                ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong as libc::c_int,
            );
            amount_1 = ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong;
        }
        let mut avail_1: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_1 = 0 as libc::c_int as size_t;
        }
        if amount_1 > avail_1 {
            amount_1 = avail_1;
        }
        if amount_1 == 0 as libc::c_int as libc::c_ulong {
            ll_version = 0 as libc::c_int as libc::c_ushort;
        } else {
            ll_version = byte_get
                .expect("non-null function pointer")(hdrptr, amount_1 as libc::c_uint)
                as libc::c_ushort;
        }
        hdrptr = hdrptr.offset(amount_1 as isize);
        if ll_version as libc::c_int != 5 as libc::c_int {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The %s section contains corrupt or unsupported version number: %d.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                ll_version as libc::c_int,
            );
            return 0 as libc::c_int;
        }
        let mut amount_2: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_2 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_2,
                    5 as libc::c_int,
                ),
                amount_2 as libc::c_int,
                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
            );
            amount_2 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
        }
        let mut avail_2: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_2 = 0 as libc::c_int as size_t;
        }
        if amount_2 > avail_2 {
            amount_2 = avail_2;
        }
        if amount_2 == 0 as libc::c_int as libc::c_ulong {
            address_size = 0 as libc::c_int as libc::c_uchar;
        } else {
            address_size = byte_get
                .expect("non-null function pointer")(hdrptr, amount_2 as libc::c_uint)
                as libc::c_uchar;
        }
        hdrptr = hdrptr.offset(amount_2 as isize);
        let mut amount_3: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_3 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_3,
                    5 as libc::c_int,
                ),
                amount_3 as libc::c_int,
                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
            );
            amount_3 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
        }
        let mut avail_3: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_3 = 0 as libc::c_int as size_t;
        }
        if amount_3 > avail_3 {
            amount_3 = avail_3;
        }
        if amount_3 == 0 as libc::c_int as libc::c_ulong {
            segment_selector_size = 0 as libc::c_int as libc::c_uchar;
        } else {
            segment_selector_size = byte_get
                .expect("non-null function pointer")(hdrptr, amount_3 as libc::c_uint)
                as libc::c_uchar;
        }
        hdrptr = hdrptr.offset(amount_3 as isize);
        if segment_selector_size as libc::c_int != 0 as libc::c_int {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The %s section contains unsupported segment selector size: %d.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                segment_selector_size as libc::c_int,
            );
            return 0 as libc::c_int;
        }
        let mut amount_4: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<uint32_t>() as libc::c_ulong) < amount_4 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_4,
                    5 as libc::c_int,
                ),
                amount_4 as libc::c_int,
                ::core::mem::size_of::<uint32_t>() as libc::c_ulong as libc::c_int,
            );
            amount_4 = ::core::mem::size_of::<uint32_t>() as libc::c_ulong;
        }
        let mut avail_4: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail_4 = 0 as libc::c_int as size_t;
        }
        if amount_4 > avail_4 {
            amount_4 = avail_4;
        }
        if amount_4 == 0 as libc::c_int as libc::c_ulong {
            offset_entry_count = 0 as libc::c_int as uint32_t;
        } else {
            offset_entry_count = byte_get
                .expect("non-null function pointer")(hdrptr, amount_4 as libc::c_uint)
                as uint32_t;
        }
        hdrptr = hdrptr.offset(amount_4 as isize);
        if offset_entry_count != 0 as libc::c_int as libc::c_uint {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The %s section contains unsupported offset entry count: %d.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                offset_entry_count,
            );
            return 0 as libc::c_int;
        }
        expected_start = hdrptr.offset_from(section_begin) as libc::c_long as dwarf_vma;
    }
    if load_debug_info(file) == 0 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < num_debug_info_entries {
        let mut num: libc::c_uint = 0;
        num = (*debug_information.offset(i as isize)).num_loc_offsets;
        if num > num_loc_list {
            num_loc_list = num;
        }
        if locs_sorted != 0 && num != 0 as libc::c_int as libc::c_uint {
            if seen_first_offset == 0 {
                last_offset = *((*debug_information.offset(i as isize)).loc_offsets)
                    .offset(0 as libc::c_int as isize);
                last_view = *((*debug_information.offset(i as isize)).loc_views)
                    .offset(0 as libc::c_int as isize);
                first = i;
                seen_first_offset = 1 as libc::c_int;
                j = 1 as libc::c_int as libc::c_uint;
            } else {
                j = 0 as libc::c_int as libc::c_uint;
            }
            while j < num {
                if last_offset
                    > *((*debug_information.offset(i as isize)).loc_offsets)
                        .offset(j as isize)
                    || last_offset
                        == *((*debug_information.offset(i as isize)).loc_offsets)
                            .offset(j as isize)
                        && last_view
                            > *((*debug_information.offset(i as isize)).loc_views)
                                .offset(j as isize)
                {
                    locs_sorted = 0 as libc::c_int;
                    break;
                } else {
                    last_offset = *((*debug_information.offset(i as isize)).loc_offsets)
                        .offset(j as isize);
                    last_view = *((*debug_information.offset(i as isize)).loc_views)
                        .offset(j as isize);
                    j = j.wrapping_add(1);
                    j;
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    if seen_first_offset == 0 {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"No location lists in .debug_info section!\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    if (*debug_information.offset(first as isize)).num_loc_offsets
        > 0 as libc::c_int as libc::c_uint
        && *((*debug_information.offset(first as isize)).loc_offsets)
            .offset(0 as libc::c_int as isize) != expected_start
        && *((*debug_information.offset(first as isize)).loc_views)
            .offset(0 as libc::c_int as isize) != expected_start
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Location lists in %s section start at 0x%s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
            dwarf_vmatoa(
                b"x\0" as *const u8 as *const libc::c_char,
                *((*debug_information.offset(first as isize)).loc_offsets)
                    .offset(0 as libc::c_int as isize),
            ),
        );
    }
    if locs_sorted == 0 {
        array = xcmalloc(
            num_loc_list as size_t,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong,
        ) as *mut libc::c_uint;
    }
    introduce(section, 0 as libc::c_int != 0);
    if reloc_at(section, 0 as libc::c_int as dwarf_vma) {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b" Warning: This section has relocations - addresses seen here may not be accurate.\n\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"    Offset   Begin            End              Expression\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    seen_first_offset = 0 as libc::c_int;
    i = first;
    while i < num_debug_info_entries {
        let mut offset: dwarf_vma = 0;
        let mut voffset: dwarf_vma = 0;
        let mut base_address: dwarf_vma = 0;
        let mut k: libc::c_uint = 0;
        let mut has_frame_base: libc::c_int = 0;
        if locs_sorted == 0 {
            k = 0 as libc::c_int as libc::c_uint;
            while k < (*debug_information.offset(i as isize)).num_loc_offsets {
                *array.offset(k as isize) = k;
                k = k.wrapping_add(1);
                k;
            }
            loc_offsets = (*debug_information.offset(i as isize)).loc_offsets;
            loc_views = (*debug_information.offset(i as isize)).loc_views;
            qsort(
                array as *mut libc::c_void,
                (*debug_information.offset(i as isize)).num_loc_offsets as size_t,
                ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong,
                Some(
                    loc_offsets_compar
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
        }
        let mut adjacent_view_loclists: libc::c_int = 1 as libc::c_int;
        k = 0 as libc::c_int as libc::c_uint;
        while k < (*debug_information.offset(i as isize)).num_loc_offsets {
            j = if locs_sorted != 0 { k } else { *array.offset(k as isize) };
            if !(k != 0
                && *((*debug_information.offset(i as isize)).loc_offsets)
                    .offset(
                        (if locs_sorted != 0 {
                            k.wrapping_sub(1 as libc::c_int as libc::c_uint)
                        } else {
                            *array
                                .offset(
                                    k.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                                )
                        }) as isize,
                    )
                    == *((*debug_information.offset(i as isize)).loc_offsets)
                        .offset(j as isize)
                && *((*debug_information.offset(i as isize)).loc_views)
                    .offset(
                        (if locs_sorted != 0 {
                            k.wrapping_sub(1 as libc::c_int as libc::c_uint)
                        } else {
                            *array
                                .offset(
                                    k.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                                )
                        }) as isize,
                    )
                    == *((*debug_information.offset(i as isize)).loc_views)
                        .offset(j as isize))
            {
                has_frame_base = *((*debug_information.offset(i as isize))
                    .have_frame_base)
                    .offset(j as isize);
                offset = *((*debug_information.offset(i as isize)).loc_offsets)
                    .offset(j as isize);
                next = section_begin.offset(offset as isize);
                voffset = *((*debug_information.offset(i as isize)).loc_views)
                    .offset(j as isize);
                if voffset != vm1 {
                    vnext = section_begin.offset(voffset as isize);
                } else {
                    vnext = 0 as *mut libc::c_uchar;
                }
                base_address = (*debug_information.offset(i as isize)).base_address;
                if !vnext.is_null() && vnext < next {
                    vstart = vnext;
                    display_view_pair_list(section, &mut vstart, i, next);
                    if start == vnext {
                        start = vstart;
                    }
                }
                if seen_first_offset == 0 || adjacent_view_loclists == 0 {
                    seen_first_offset = 1 as libc::c_int;
                } else if start < next {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"There is a hole [0x%lx - 0x%lx] in .debug_loc section.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        start.offset_from(section_begin) as libc::c_long
                            as libc::c_ulong,
                        offset,
                    );
                } else if start > next {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"There is an overlap [0x%lx - 0x%lx] in .debug_loc section.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        start.offset_from(section_begin) as libc::c_long
                            as libc::c_ulong,
                        offset,
                    );
                }
                start = next;
                vstart = vnext;
                if offset >= bytes {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Offset 0x%lx is bigger than .debug_loc section size.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        offset,
                    );
                } else if !vnext.is_null() && voffset >= bytes {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"View Offset 0x%lx is bigger than .debug_loc section size.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        voffset,
                    );
                } else {
                    if is_loclists == 0 {
                        if is_dwo {
                            display_loc_list_dwo(
                                section,
                                &mut start,
                                i,
                                offset,
                                &mut vstart,
                                has_frame_base,
                            );
                        } else {
                            display_loc_list(
                                section,
                                &mut start,
                                i,
                                offset,
                                base_address,
                                &mut vstart,
                                has_frame_base,
                            );
                        }
                    } else if is_dwo {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"DWO is not yet supported.\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        display_loclists_list(
                            section,
                            &mut start,
                            i,
                            offset,
                            base_address,
                            &mut vstart,
                            has_frame_base,
                        );
                    }
                    if adjacent_view_loclists != 0 && !vnext.is_null() && vnext != start
                        && vstart != next
                    {
                        adjacent_view_loclists = 0 as libc::c_int;
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Hole and overlap detection requires adjacent view lists and loclists.\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    if !vnext.is_null() && vnext == start {
                        display_view_pair_list(section, &mut start, i, vstart);
                    }
                }
            }
            k = k.wrapping_add(1);
            k;
        }
        i = i.wrapping_add(1);
        i;
    }
    if start < ((*section).start).offset((*section).size as isize) {
        warn(
            dcngettext(
                0 as *const libc::c_char,
                b"There is %ld unused byte at the end of section %s\n\0" as *const u8
                    as *const libc::c_char,
                b"There are %ld unused bytes at the end of section %s\n\0" as *const u8
                    as *const libc::c_char,
                ((*section).start).offset((*section).size as isize).offset_from(start)
                    as libc::c_long as libc::c_ulong,
                5 as libc::c_int,
            ),
            ((*section).start).offset((*section).size as isize).offset_from(start)
                as libc::c_long,
            (*section).name,
        );
    }
    putchar('\n' as i32);
    free(array as *mut libc::c_void);
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_str(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut bytes: libc::c_ulong = (*section).size;
    let mut addr: dwarf_vma = (*section).address;
    if bytes == 0 as libc::c_int as libc::c_ulong {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nThe %s section is empty.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    introduce(section, 0 as libc::c_int != 0);
    while bytes != 0 {
        let mut j: libc::c_int = 0;
        let mut k: libc::c_int = 0;
        let mut lbytes: libc::c_int = 0;
        lbytes = (if bytes > 16 as libc::c_int as libc::c_ulong {
            16 as libc::c_int as libc::c_ulong
        } else {
            bytes
        }) as libc::c_int;
        printf(b"  0x%8.8lx \0" as *const u8 as *const libc::c_char, addr);
        j = 0 as libc::c_int;
        while j < 16 as libc::c_int {
            if j < lbytes {
                printf(
                    b"%2.2x\0" as *const u8 as *const libc::c_char,
                    *start.offset(j as isize) as libc::c_int,
                );
            } else {
                printf(b"  \0" as *const u8 as *const libc::c_char);
            }
            if j & 3 as libc::c_int == 3 as libc::c_int {
                printf(b" \0" as *const u8 as *const libc::c_char);
            }
            j += 1;
            j;
        }
        j = 0 as libc::c_int;
        while j < lbytes {
            k = *start.offset(j as isize) as libc::c_int;
            if k >= ' ' as i32 && k < 0x80 as libc::c_int {
                printf(b"%c\0" as *const u8 as *const libc::c_char, k);
            } else {
                printf(b".\0" as *const u8 as *const libc::c_char);
            }
            j += 1;
            j;
        }
        putchar('\n' as i32);
        start = start.offset(lbytes as isize);
        addr = (addr as libc::c_ulong).wrapping_add(lbytes as libc::c_ulong) as dwarf_vma
            as dwarf_vma;
        bytes = bytes.wrapping_sub(lbytes as libc::c_ulong);
    }
    putchar('\n' as i32);
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_info(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    return process_debug_info(
        section,
        file,
        (*section).abbrev_sec,
        0 as libc::c_int != 0,
        0 as libc::c_int != 0,
    ) as libc::c_int;
}
unsafe extern "C" fn display_debug_types(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    return process_debug_info(
        section,
        file,
        (*section).abbrev_sec,
        0 as libc::c_int != 0,
        1 as libc::c_int != 0,
    ) as libc::c_int;
}
unsafe extern "C" fn display_trace_info(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    return process_debug_info(
        section,
        file,
        (*section).abbrev_sec,
        0 as libc::c_int != 0,
        1 as libc::c_int != 0,
    ) as libc::c_int;
}
unsafe extern "C" fn display_debug_aranges(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = start.offset((*section).size as isize);
    introduce(section, 0 as libc::c_int != 0);
    load_debug_info(file);
    while start < end {
        let mut hdrptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut arange: DWARF2_Internal_ARange = DWARF2_Internal_ARange {
            ar_length: 0,
            ar_version: 0,
            ar_info_offset: 0,
            ar_pointer_size: 0,
            ar_segment_size: 0,
        };
        let mut addr_ranges: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut length: dwarf_vma = 0;
        let mut address: dwarf_vma = 0;
        let mut sec_off: libc::c_ulong = 0;
        let mut address_size: libc::c_uchar = 0;
        let mut excess: libc::c_int = 0;
        let mut offset_size: libc::c_uint = 0;
        let mut end_ranges: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        hdrptr = start;
        sec_off = hdrptr.offset_from((*section).start) as libc::c_long as libc::c_ulong;
        let mut amount: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
        if hdrptr > end {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            arange.ar_length = 0 as libc::c_int as dwarf_vma;
        } else {
            arange
                .ar_length = byte_get
                .expect("non-null function pointer")(hdrptr, amount as libc::c_uint);
        }
        hdrptr = hdrptr.offset(amount as isize);
        if arange.ar_length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_0: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_0,
                        5 as libc::c_int,
                    ),
                    amount_0 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_0: size_t = end.offset_from(hdrptr) as libc::c_long as size_t;
            if hdrptr > end {
                avail_0 = 0 as libc::c_int as size_t;
            }
            if amount_0 > avail_0 {
                amount_0 = avail_0;
            }
            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                arange.ar_length = 0 as libc::c_int as dwarf_vma;
            } else {
                arange
                    .ar_length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_0 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_0 as isize);
            offset_size = 8 as libc::c_int as libc::c_uint;
        } else {
            offset_size = 4 as libc::c_int as libc::c_uint;
        }
        if arange.ar_length > end.offset_from(hdrptr) as libc::c_long as size_t {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Debug info is corrupted, %s header at %#lx has length %s\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                sec_off,
                dwarf_vmatoa(
                    b"x\0" as *const u8 as *const libc::c_char,
                    arange.ar_length,
                ),
            );
            break;
        } else {
            end_ranges = hdrptr.offset(arange.ar_length as isize);
            let mut amount_1: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong;
            }
            let mut avail_1: size_t = end_ranges.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > end_ranges {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                arange.ar_version = 0 as libc::c_int as libc::c_ushort;
            } else {
                arange
                    .ar_version = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_1 as libc::c_uint) as libc::c_ushort;
            }
            hdrptr = hdrptr.offset(amount_1 as isize);
            let mut amount_2: size_t = offset_size as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_2: size_t = end_ranges.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > end_ranges {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                arange.ar_info_offset = 0 as libc::c_int as dwarf_vma;
            } else {
                arange
                    .ar_info_offset = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_2 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_2 as isize);
            if num_debug_info_entries != -(1 as libc::c_int) as libc::c_uint
                && num_debug_info_entries > 0 as libc::c_int as libc::c_uint
                && (find_debug_info_for_offset(arange.ar_info_offset)).is_null()
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b".debug_info offset of 0x%lx in %s section does not point to a CU header.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    arange.ar_info_offset,
                    (*section).name,
                );
            }
            let mut amount_3: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_3 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_3,
                        5 as libc::c_int,
                    ),
                    amount_3 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_3 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
            }
            let mut avail_3: size_t = end_ranges.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > end_ranges {
                avail_3 = 0 as libc::c_int as size_t;
            }
            if amount_3 > avail_3 {
                amount_3 = avail_3;
            }
            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                arange.ar_pointer_size = 0 as libc::c_int as libc::c_uchar;
            } else {
                arange
                    .ar_pointer_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_3 as libc::c_uint) as libc::c_uchar;
            }
            hdrptr = hdrptr.offset(amount_3 as isize);
            let mut amount_4: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_4 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_4,
                        5 as libc::c_int,
                    ),
                    amount_4 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_4 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
            }
            let mut avail_4: size_t = end_ranges.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > end_ranges {
                avail_4 = 0 as libc::c_int as size_t;
            }
            if amount_4 > avail_4 {
                amount_4 = avail_4;
            }
            if amount_4 == 0 as libc::c_int as libc::c_ulong {
                arange.ar_segment_size = 0 as libc::c_int as libc::c_uchar;
            } else {
                arange
                    .ar_segment_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_4 as libc::c_uint) as libc::c_uchar;
            }
            hdrptr = hdrptr.offset(amount_4 as isize);
            if arange.ar_version as libc::c_int != 2 as libc::c_int
                && arange.ar_version as libc::c_int != 3 as libc::c_int
            {
                if arange.ar_version != 0 {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Only DWARF 2 and 3 aranges are currently supported.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                break;
            } else {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Length:                   %ld\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    arange.ar_length as libc::c_long,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Version:                  %d\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    arange.ar_version as libc::c_int,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Offset into .debug_info:  0x%lx\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    arange.ar_info_offset,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Pointer Size:             %d\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    arange.ar_pointer_size as libc::c_int,
                );
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"  Segment Size:             %d\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    arange.ar_segment_size as libc::c_int,
                );
                address_size = (arange.ar_pointer_size as libc::c_int
                    + arange.ar_segment_size as libc::c_int) as libc::c_uchar;
                if address_size as libc::c_int == 0 as libc::c_int
                    || address_size as libc::c_int > 8 as libc::c_int
                {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Invalid address size in %s section!\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*section).name,
                    );
                    break;
                } else if address_size as libc::c_int
                    & address_size as libc::c_int - 1 as libc::c_int != 0 as libc::c_int
                {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Pointer size + Segment size is not a power of two.\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    break;
                } else {
                    if address_size as libc::c_int > 4 as libc::c_int {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\n    Address            Length\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    } else {
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"\n    Address    Length\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                    }
                    addr_ranges = hdrptr;
                    excess = (hdrptr.offset_from(start) as libc::c_long
                        % (2 as libc::c_int * address_size as libc::c_int)
                            as libc::c_long) as libc::c_int;
                    if excess != 0 {
                        addr_ranges = addr_ranges
                            .offset(
                                (2 as libc::c_int * address_size as libc::c_int - excess)
                                    as isize,
                            );
                    }
                    start = end_ranges;
                    while (2 as libc::c_uint).wrapping_mul(address_size as libc::c_uint)
                        as libc::c_ulong
                        <= start.offset_from(addr_ranges) as libc::c_long as size_t
                    {
                        let mut amount_5: size_t = address_size as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_5
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_5,
                                    5 as libc::c_int,
                                ),
                                amount_5 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_5 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_5: size_t = start.offset_from(addr_ranges)
                            as libc::c_long as size_t;
                        if addr_ranges > start {
                            avail_5 = 0 as libc::c_int as size_t;
                        }
                        if amount_5 > avail_5 {
                            amount_5 = avail_5;
                        }
                        if amount_5 == 0 as libc::c_int as libc::c_ulong {
                            address = 0 as libc::c_int as dwarf_vma;
                        } else {
                            address = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(addr_ranges, amount_5 as libc::c_uint);
                        }
                        addr_ranges = addr_ranges.offset(amount_5 as isize);
                        let mut amount_6: size_t = address_size as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_6
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_6,
                                    5 as libc::c_int,
                                ),
                                amount_6 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_6 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_6: size_t = start.offset_from(addr_ranges)
                            as libc::c_long as size_t;
                        if addr_ranges > start {
                            avail_6 = 0 as libc::c_int as size_t;
                        }
                        if amount_6 > avail_6 {
                            amount_6 = avail_6;
                        }
                        if amount_6 == 0 as libc::c_int as libc::c_ulong {
                            length = 0 as libc::c_int as dwarf_vma;
                        } else {
                            length = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(addr_ranges, amount_6 as libc::c_uint);
                        }
                        addr_ranges = addr_ranges.offset(amount_6 as isize);
                        printf(b"    \0" as *const u8 as *const libc::c_char);
                        print_dwarf_vma(address, address_size as libc::c_uint);
                        print_dwarf_vma(length, address_size as libc::c_uint);
                        putchar('\n' as i32);
                    }
                }
            }
        }
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
unsafe extern "C" fn comp_addr_base(
    mut v0: *const libc::c_void,
    mut v1: *const libc::c_void,
) -> libc::c_int {
    let mut info0: *mut debug_info = *(v0 as *mut *mut debug_info);
    let mut info1: *mut debug_info = *(v1 as *mut *mut debug_info);
    return ((*info0).addr_base).wrapping_sub((*info1).addr_base) as libc::c_int;
}
unsafe extern "C" fn display_debug_addr(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut debug_addr_info: *mut *mut debug_info = 0 as *mut *mut debug_info;
    let mut entry: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut i: libc::c_uint = 0;
    let mut count: libc::c_uint = 0;
    let mut header: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if (*section).size == 0 as libc::c_int as libc::c_ulong {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nThe %s section is empty.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    if load_debug_info(file) == 0 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    introduce(section, 0 as libc::c_int != 0);
    debug_addr_info = xcalloc(
        num_debug_info_entries.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t,
        ::core::mem::size_of::<*mut debug_info>() as libc::c_ulong,
    ) as *mut *mut debug_info;
    count = 0 as libc::c_int as libc::c_uint;
    i = 0 as libc::c_int as libc::c_uint;
    while i < num_debug_info_entries {
        if (*debug_information.offset(i as isize)).addr_base
            != -(1 as libc::c_int) as libc::c_uint as libc::c_ulong
        {
            if (*debug_information.offset(i as isize)).addr_base >= (*section).size {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Corrupt address base (%lx) found in debug section %u\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*debug_information.offset(i as isize)).addr_base,
                    i,
                );
            } else {
                let fresh26 = count;
                count = count.wrapping_add(1);
                let ref mut fresh27 = *debug_addr_info.offset(fresh26 as isize);
                *fresh27 = debug_information.offset(i as isize);
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    let ref mut fresh28 = *debug_addr_info.offset(count as isize);
    *fresh28 = xmalloc(::core::mem::size_of::<debug_info>() as libc::c_ulong)
        as *mut debug_info;
    (**debug_addr_info.offset(count as isize)).addr_base = (*section).size;
    qsort(
        debug_addr_info as *mut libc::c_void,
        count as size_t,
        ::core::mem::size_of::<*mut debug_info>() as libc::c_ulong,
        Some(
            comp_addr_base
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    header = (*section).start;
    i = 0 as libc::c_int as libc::c_uint;
    while i < count {
        let mut idx: libc::c_uint = 0;
        let mut address_size: libc::c_uint = (**debug_addr_info.offset(i as isize))
            .pointer_size;
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  For compilation unit at offset 0x%s:\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            dwarf_vmatoa(
                b"x\0" as *const u8 as *const libc::c_char,
                (**debug_addr_info.offset(i as isize)).cu_offset,
            ),
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\tIndex\tAddress\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        entry = ((*section).start)
            .offset((**debug_addr_info.offset(i as isize)).addr_base as isize);
        if (**debug_addr_info.offset(i as isize)).dwarf_version >= 5 as libc::c_int {
            let mut header_size: size_t = entry.offset_from(header) as libc::c_long
                as size_t;
            let mut curr_header: *mut libc::c_uchar = header;
            let mut length: dwarf_vma = 0;
            let mut version: libc::c_int = 0;
            let mut segment_selector_size: libc::c_int = 0;
            if header_size != 8 as libc::c_int as libc::c_ulong
                && header_size != 16 as libc::c_int as libc::c_ulong
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Corrupt %s section: expecting header size of 8 or 16, but found %ld instead\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*section).name,
                    header_size as libc::c_long,
                );
                return 0 as libc::c_int;
            }
            let mut amount: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount,
                        5 as libc::c_int,
                    ),
                    amount as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail: size_t = entry.offset_from(curr_header) as libc::c_long
                as size_t;
            if curr_header > entry {
                avail = 0 as libc::c_int as size_t;
            }
            if amount > avail {
                amount = avail;
            }
            if amount == 0 as libc::c_int as libc::c_ulong {
                length = 0 as libc::c_int as dwarf_vma;
            } else {
                length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(curr_header, amount as libc::c_uint);
            }
            curr_header = curr_header.offset(amount as isize);
            if length == 0xffffffff as libc::c_uint as libc::c_ulong {
                let mut amount_0: size_t = 8 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_0,
                            5 as libc::c_int,
                        ),
                        amount_0 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_0: size_t = entry.offset_from(curr_header) as libc::c_long
                    as size_t;
                if curr_header > entry {
                    avail_0 = 0 as libc::c_int as size_t;
                }
                if amount_0 > avail_0 {
                    amount_0 = avail_0;
                }
                if amount_0 == 0 as libc::c_int as libc::c_ulong {
                    length = 0 as libc::c_int as dwarf_vma;
                } else {
                    length = byte_get
                        .expect(
                            "non-null function pointer",
                        )(curr_header, amount_0 as libc::c_uint);
                }
                curr_header = curr_header.offset(amount_0 as isize);
            }
            end = curr_header.offset(length as isize);
            let mut amount_1: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_int>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong;
            }
            let mut avail_1: size_t = entry.offset_from(curr_header) as libc::c_long
                as size_t;
            if curr_header > entry {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                version = 0 as libc::c_int;
            } else {
                version = byte_get
                    .expect(
                        "non-null function pointer",
                    )(curr_header, amount_1 as libc::c_uint) as libc::c_int;
            }
            curr_header = curr_header.offset(amount_1 as isize);
            if version != 5 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Corrupt %s section: expecting version number 5 in header but found %d instead\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*section).name,
                    version,
                );
            }
            let mut amount_2: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
            }
            let mut avail_2: size_t = entry.offset_from(curr_header) as libc::c_long
                as size_t;
            if curr_header > entry {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                address_size = 0 as libc::c_int as libc::c_uint;
            } else {
                address_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(curr_header, amount_2 as libc::c_uint) as libc::c_uint;
            }
            curr_header = curr_header.offset(amount_2 as isize);
            let mut amount_3: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_int>() as libc::c_ulong) < amount_3 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_3,
                        5 as libc::c_int,
                    ),
                    amount_3 as libc::c_int,
                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int,
                );
                amount_3 = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong;
            }
            let mut avail_3: size_t = entry.offset_from(curr_header) as libc::c_long
                as size_t;
            if curr_header > entry {
                avail_3 = 0 as libc::c_int as size_t;
            }
            if amount_3 > avail_3 {
                amount_3 = avail_3;
            }
            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                segment_selector_size = 0 as libc::c_int;
            } else {
                segment_selector_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(curr_header, amount_3 as libc::c_uint) as libc::c_int;
            }
            curr_header = curr_header.offset(amount_3 as isize);
            address_size = address_size
                .wrapping_add(segment_selector_size as libc::c_uint);
        } else {
            end = ((*section).start)
                .offset(
                    (**debug_addr_info
                        .offset(
                            i.wrapping_add(1 as libc::c_int as libc::c_uint) as isize,
                        ))
                        .addr_base as isize,
                );
        }
        header = end;
        idx = 0 as libc::c_int as libc::c_uint;
        while entry < end {
            let mut base: dwarf_vma = byte_get
                .expect("non-null function pointer")(entry, address_size);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"\t%d:\t\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                idx,
            );
            print_dwarf_vma(base, address_size);
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            entry = entry.offset(address_size as isize);
            idx = idx.wrapping_add(1);
            idx;
        }
        i = i.wrapping_add(1);
        i;
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    free(debug_addr_info as *mut libc::c_void);
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_str_offsets(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut idx: libc::c_ulong = 0;
    if (*section).size == 0 as libc::c_int as libc::c_ulong {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nThe %s section is empty.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = start.offset((*section).size as isize);
    let mut curr: *mut libc::c_uchar = start;
    let mut suffix: *const libc::c_char = strrchr((*section).name, '.' as i32);
    let mut dwo: bool = !suffix.is_null()
        && strcmp(suffix, b".dwo\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int;
    if dwo {
        load_debug_section_with_follow(str_dwo, file);
    } else {
        load_debug_section_with_follow(str, file);
    }
    introduce(section, 0 as libc::c_int != 0);
    while curr < end {
        let mut length: dwarf_vma = 0;
        let mut entry_length: dwarf_vma = 0;
        let mut amount: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = end.offset_from(curr) as libc::c_long as size_t;
        if curr > end {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            length = 0 as libc::c_int as dwarf_vma;
        } else {
            length = byte_get
                .expect("non-null function pointer")(curr, amount as libc::c_uint);
        }
        curr = curr.offset(amount as isize);
        if length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_0: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_0,
                        5 as libc::c_int,
                    ),
                    amount_0 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_0: size_t = end.offset_from(curr) as libc::c_long as size_t;
            if curr > end {
                avail_0 = 0 as libc::c_int as size_t;
            }
            if amount_0 > avail_0 {
                amount_0 = avail_0;
            }
            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                length = 0 as libc::c_int as dwarf_vma;
            } else {
                length = byte_get
                    .expect("non-null function pointer")(curr, amount_0 as libc::c_uint);
            }
            curr = curr.offset(amount_0 as isize);
            entry_length = 8 as libc::c_int as dwarf_vma;
        } else {
            entry_length = 4 as libc::c_int as dwarf_vma;
        }
        let mut entries_end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        if length == 0 as libc::c_int as libc::c_ulong {
            length = (*section).size;
            curr = (*section).start;
            entries_end = end;
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    Length: %#lx\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                length,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"       Index   Offset [String]\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        } else {
            if length <= end.offset_from(curr) as libc::c_long as dwarf_vma {
                entries_end = curr.offset(length as isize);
            } else {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Section %s is too small %#lx\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*section).name,
                    (*section).size,
                );
                entries_end = end;
            }
            let mut version: libc::c_int = 0;
            let mut amount_1: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_int>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong;
            }
            let mut avail_1: size_t = entries_end.offset_from(curr) as libc::c_long
                as size_t;
            if curr > entries_end {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                version = 0 as libc::c_int;
            } else {
                version = byte_get
                    .expect("non-null function pointer")(curr, amount_1 as libc::c_uint)
                    as libc::c_int;
            }
            curr = curr.offset(amount_1 as isize);
            if version != 5 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unexpected version number in str_offset header: %#x\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    version,
                );
            }
            let mut padding: libc::c_int = 0;
            let mut amount_2: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_int>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong;
            }
            let mut avail_2: size_t = entries_end.offset_from(curr) as libc::c_long
                as size_t;
            if curr > entries_end {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                padding = 0 as libc::c_int;
            } else {
                padding = byte_get
                    .expect("non-null function pointer")(curr, amount_2 as libc::c_uint)
                    as libc::c_int;
            }
            curr = curr.offset(amount_2 as isize);
            if padding != 0 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Unexpected value in str_offset header's padding field: %#x\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    padding,
                );
            }
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    Length: %#lx\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                length,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"    Version: %#lx\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                version as libc::c_ulong,
            );
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"       Index   Offset [String]\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
        }
        idx = 0 as libc::c_int as libc::c_ulong;
        while curr < entries_end {
            let mut offset: dwarf_vma = 0;
            let mut string: *const libc::c_uchar = 0 as *const libc::c_uchar;
            if (entries_end.offset_from(curr) as libc::c_long as dwarf_vma)
                < entry_length
            {
                return 0 as libc::c_int;
            }
            let mut amount_3: size_t = entry_length;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_3 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_3,
                        5 as libc::c_int,
                    ),
                    amount_3 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_3 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_3: size_t = entries_end.offset_from(curr) as libc::c_long
                as size_t;
            if curr > entries_end {
                avail_3 = 0 as libc::c_int as size_t;
            }
            if amount_3 > avail_3 {
                amount_3 = avail_3;
            }
            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                offset = 0 as libc::c_int as dwarf_vma;
            } else {
                offset = byte_get
                    .expect("non-null function pointer")(curr, amount_3 as libc::c_uint);
            }
            curr = curr.offset(amount_3 as isize);
            if dwo {
                string = fetch_indexed_string(
                    idx,
                    0 as *mut cu_tu_set,
                    entry_length,
                    dwo,
                ) as *const libc::c_uchar;
            } else {
                string = fetch_indirect_string(offset);
            }
            printf(
                b"    %8lu %8s %s\n\0" as *const u8 as *const libc::c_char,
                idx,
                dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, offset),
                string,
            );
            idx = idx.wrapping_add(1);
            idx;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn range_entry_compar(
    mut ap: *const libc::c_void,
    mut bp: *const libc::c_void,
) -> libc::c_int {
    let mut a_re: *const range_entry = ap as *const range_entry;
    let mut b_re: *const range_entry = bp as *const range_entry;
    let a: dwarf_vma = (*a_re).ranges_offset;
    let b: dwarf_vma = (*b_re).ranges_offset;
    return (a > b) as libc::c_int - (b > a) as libc::c_int;
}
unsafe extern "C" fn display_debug_ranges_list(
    mut start: *mut libc::c_uchar,
    mut finish: *mut libc::c_uchar,
    mut pointer_size: libc::c_uint,
    mut offset: libc::c_ulong,
    mut base_address: libc::c_ulong,
) {
    while start < finish {
        let mut begin: dwarf_vma = 0;
        let mut end: dwarf_vma = 0;
        let mut amount: size_t = pointer_size as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = finish.offset_from(start) as libc::c_long as size_t;
        if start > finish {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            begin = 0 as libc::c_int as dwarf_vma;
        } else {
            begin = byte_get
                .expect("non-null function pointer")(start, amount as libc::c_uint);
        }
        start = start.offset(amount as isize);
        if start >= finish {
            break;
        }
        let mut amount_0: size_t = pointer_size as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_0,
                    5 as libc::c_int,
                ),
                amount_0 as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail_0: size_t = finish.offset_from(start) as libc::c_long as size_t;
        if start > finish {
            avail_0 = 0 as libc::c_int as size_t;
        }
        if amount_0 > avail_0 {
            amount_0 = avail_0;
        }
        if amount_0 == 0 as libc::c_int as libc::c_ulong {
            end = 0 as libc::c_int as dwarf_vma;
        } else {
            end = byte_get_signed(start, amount_0 as libc::c_uint);
        }
        start = start.offset(amount_0 as isize);
        printf(b"    %8.8lx \0" as *const u8 as *const libc::c_char, offset);
        if begin == 0 as libc::c_int as libc::c_ulong
            && end == 0 as libc::c_int as libc::c_ulong
        {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"<End of list>\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            break;
        } else if is_max_address(begin, pointer_size) as libc::c_int != 0
            && !is_max_address(end, pointer_size)
        {
            base_address = end;
            print_dwarf_vma(begin, pointer_size);
            print_dwarf_vma(end, pointer_size);
            printf(b"(base address)\n\0" as *const u8 as *const libc::c_char);
        } else {
            print_dwarf_vma(begin.wrapping_add(base_address), pointer_size);
            print_dwarf_vma(end.wrapping_add(base_address), pointer_size);
            if begin == end {
                fputs(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"(start == end)\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    stdout,
                );
            } else if begin > end {
                fputs(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"(start > end)\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    stdout,
                );
            }
            putchar('\n' as i32);
        }
    }
}
unsafe extern "C" fn display_debug_rnglists_list(
    mut start: *mut libc::c_uchar,
    mut finish: *mut libc::c_uchar,
    mut pointer_size: libc::c_uint,
    mut offset: libc::c_ulong,
    mut base_address: libc::c_ulong,
) {
    let mut next: *mut libc::c_uchar = start;
    loop {
        let mut off: libc::c_ulong = offset
            .wrapping_add(start.offset_from(next) as libc::c_long as libc::c_ulong);
        let mut rlet: dwarf_range_list_entry = DW_RLE_end_of_list;
        let mut begin: dwarf_vma = -(1 as libc::c_int) as dwarf_vma;
        let mut length: dwarf_vma = 0;
        let mut end: dwarf_vma = -(1 as libc::c_int) as dwarf_vma;
        if start >= finish {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Range list starting at offset 0x%lx is not terminated.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                offset,
            );
            break;
        } else {
            printf(b"    %8.8lx \0" as *const u8 as *const libc::c_char, off);
            let mut amount: size_t = 1 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_range_list_entry>() as libc::c_ulong)
                < amount
            {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount,
                        5 as libc::c_int,
                    ),
                    amount as libc::c_int,
                    ::core::mem::size_of::<dwarf_range_list_entry>() as libc::c_ulong
                        as libc::c_int,
                );
                amount = ::core::mem::size_of::<dwarf_range_list_entry>()
                    as libc::c_ulong;
            }
            let mut avail: size_t = finish.offset_from(start) as libc::c_long as size_t;
            if start > finish {
                avail = 0 as libc::c_int as size_t;
            }
            if amount > avail {
                amount = avail;
            }
            if amount == 0 as libc::c_int as libc::c_ulong {
                rlet = DW_RLE_end_of_list;
            } else {
                rlet = byte_get
                    .expect("non-null function pointer")(start, amount as libc::c_uint)
                    as dwarf_range_list_entry;
            }
            start = start.offset(amount as isize);
            match rlet as libc::c_uint {
                0 => {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"<End of list>\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                5 => {
                    let mut amount_0: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)
                        < amount_0
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_0,
                                5 as libc::c_int,
                            ),
                            amount_0 as libc::c_int,
                            ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_0 = ::core::mem::size_of::<libc::c_ulong>()
                            as libc::c_ulong;
                    }
                    let mut avail_0: size_t = finish.offset_from(start) as libc::c_long
                        as size_t;
                    if start > finish {
                        avail_0 = 0 as libc::c_int as size_t;
                    }
                    if amount_0 > avail_0 {
                        amount_0 = avail_0;
                    }
                    if amount_0 == 0 as libc::c_int as libc::c_ulong {
                        base_address = 0 as libc::c_int as libc::c_ulong;
                    } else {
                        base_address = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_0 as libc::c_uint);
                    }
                    start = start.offset(amount_0 as isize);
                    print_dwarf_vma(base_address, pointer_size);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"(base address)\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                }
                7 => {
                    let mut amount_1: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_1
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_1,
                                5 as libc::c_int,
                            ),
                            amount_1 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_1 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_1: size_t = finish.offset_from(start) as libc::c_long
                        as size_t;
                    if start > finish {
                        avail_1 = 0 as libc::c_int as size_t;
                    }
                    if amount_1 > avail_1 {
                        amount_1 = avail_1;
                    }
                    if amount_1 == 0 as libc::c_int as libc::c_ulong {
                        begin = 0 as libc::c_int as dwarf_vma;
                    } else {
                        begin = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_1 as libc::c_uint);
                    }
                    start = start.offset(amount_1 as isize);
                    let mut _val: dwarf_vma = 0;
                    let mut _len: libc::c_uint = 0;
                    let mut _status: libc::c_int = 0;
                    _val = read_leb128(
                        start,
                        finish,
                        0 as libc::c_int != 0,
                        &mut _len,
                        &mut _status,
                    );
                    start = start.offset(_len as isize);
                    length = _val;
                    if length != _val {
                        _status |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        7633 as libc::c_int as libc::c_ulong,
                    );
                    end = begin.wrapping_add(length);
                }
                4 => {
                    let mut _val_0: dwarf_vma = 0;
                    let mut _len_0: libc::c_uint = 0;
                    let mut _status_0: libc::c_int = 0;
                    _val_0 = read_leb128(
                        start,
                        finish,
                        0 as libc::c_int != 0,
                        &mut _len_0,
                        &mut _status_0,
                    );
                    start = start.offset(_len_0 as isize);
                    begin = _val_0;
                    if begin != _val_0 {
                        _status_0 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_0,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        7637 as libc::c_int as libc::c_ulong,
                    );
                    let mut _val_1: dwarf_vma = 0;
                    let mut _len_1: libc::c_uint = 0;
                    let mut _status_1: libc::c_int = 0;
                    _val_1 = read_leb128(
                        start,
                        finish,
                        0 as libc::c_int != 0,
                        &mut _len_1,
                        &mut _status_1,
                    );
                    start = start.offset(_len_1 as isize);
                    end = _val_1;
                    if end != _val_1 {
                        _status_1 |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status_1,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        7638 as libc::c_int as libc::c_ulong,
                    );
                }
                6 => {
                    let mut amount_2: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_2
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_2,
                                5 as libc::c_int,
                            ),
                            amount_2 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_2 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_2: size_t = finish.offset_from(start) as libc::c_long
                        as size_t;
                    if start > finish {
                        avail_2 = 0 as libc::c_int as size_t;
                    }
                    if amount_2 > avail_2 {
                        amount_2 = avail_2;
                    }
                    if amount_2 == 0 as libc::c_int as libc::c_ulong {
                        begin = 0 as libc::c_int as dwarf_vma;
                    } else {
                        begin = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_2 as libc::c_uint);
                    }
                    start = start.offset(amount_2 as isize);
                    let mut amount_3: size_t = pointer_size as size_t;
                    if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_3
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_3,
                                5 as libc::c_int,
                            ),
                            amount_3 as libc::c_int,
                            ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_3 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                    }
                    let mut avail_3: size_t = finish.offset_from(start) as libc::c_long
                        as size_t;
                    if start > finish {
                        avail_3 = 0 as libc::c_int as size_t;
                    }
                    if amount_3 > avail_3 {
                        amount_3 = avail_3;
                    }
                    if amount_3 == 0 as libc::c_int as libc::c_ulong {
                        end = 0 as libc::c_int as dwarf_vma;
                    } else {
                        end = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_3 as libc::c_uint);
                    }
                    start = start.offset(amount_3 as isize);
                }
                _ => {
                    error(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Invalid range list entry type %d\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        rlet as libc::c_uint,
                    );
                    rlet = DW_RLE_end_of_list;
                }
            }
            if rlet as libc::c_uint == DW_RLE_end_of_list as libc::c_int as libc::c_uint
            {
                break;
            }
            if rlet as libc::c_uint == DW_RLE_base_address as libc::c_int as libc::c_uint
            {
                continue;
            }
            if rlet as libc::c_uint == DW_RLE_offset_pair as libc::c_int as libc::c_uint
            {
                begin = (begin as libc::c_ulong).wrapping_add(base_address) as dwarf_vma
                    as dwarf_vma;
                end = (end as libc::c_ulong).wrapping_add(base_address) as dwarf_vma
                    as dwarf_vma;
            }
            print_dwarf_vma(begin, pointer_size);
            print_dwarf_vma(end, pointer_size);
            if begin == end {
                fputs(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"(start == end)\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    stdout,
                );
            } else if begin > end {
                fputs(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"(start > end)\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    stdout,
                );
            }
            putchar('\n' as i32);
        }
    };
}
unsafe extern "C" fn display_debug_ranges(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut last_start: *mut libc::c_uchar = start;
    let mut bytes: libc::c_ulong = (*section).size;
    let mut section_begin: *mut libc::c_uchar = start;
    let mut finish: *mut libc::c_uchar = start.offset(bytes as isize);
    let mut num_range_list: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut range_entries: *mut range_entry = 0 as *mut range_entry;
    let mut range_entry_fill: *mut range_entry = 0 as *mut range_entry;
    let mut is_rnglists: libc::c_int = (strstr(
        (*section).name,
        b"debug_rnglists\0" as *const u8 as *const libc::c_char,
    ) != 0 as *mut libc::c_void as *mut libc::c_char) as libc::c_int;
    let mut address_size: libc::c_uchar = 0 as libc::c_int as libc::c_uchar;
    let mut last_offset: dwarf_vma = 0 as libc::c_int as dwarf_vma;
    if bytes == 0 as libc::c_int as libc::c_ulong {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\nThe %s section is empty.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    if is_rnglists != 0 {
        let mut initial_length: dwarf_vma = 0;
        let mut segment_selector_size: libc::c_uchar = 0;
        let mut offset_size: libc::c_uint = 0;
        let mut offset_entry_count: libc::c_uint = 0;
        let mut version: libc::c_ushort = 0;
        let mut amount: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = finish.offset_from(start) as libc::c_long as size_t;
        if start > finish {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            initial_length = 0 as libc::c_int as dwarf_vma;
        } else {
            initial_length = byte_get
                .expect("non-null function pointer")(start, amount as libc::c_uint);
        }
        start = start.offset(amount as isize);
        if initial_length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_0: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_0,
                        5 as libc::c_int,
                    ),
                    amount_0 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_0: size_t = finish.offset_from(start) as libc::c_long
                as size_t;
            if start > finish {
                avail_0 = 0 as libc::c_int as size_t;
            }
            if amount_0 > avail_0 {
                amount_0 = avail_0;
            }
            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                initial_length = 0 as libc::c_int as dwarf_vma;
            } else {
                initial_length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(start, amount_0 as libc::c_uint);
            }
            start = start.offset(amount_0 as isize);
            offset_size = 8 as libc::c_int as libc::c_uint;
        } else {
            offset_size = 4 as libc::c_int as libc::c_uint;
        }
        if initial_length > finish.offset_from(start) as libc::c_long as size_t {
            if reloc_at(
                section,
                (start.offset_from((*section).start) as libc::c_long
                    - offset_size as libc::c_long) as dwarf_vma,
            ) {
                initial_length = finish.offset_from(start) as libc::c_long as dwarf_vma;
            } else {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"The length field (0x%lx) in the debug_rnglists header is wrong - the section is too small\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    initial_length as libc::c_long,
                );
                return 0 as libc::c_int;
            }
        }
        finish = start.offset(initial_length as isize);
        let mut amount_1: size_t = 2 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong) < amount_1 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_1,
                    5 as libc::c_int,
                ),
                amount_1 as libc::c_int,
                ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong as libc::c_int,
            );
            amount_1 = ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong;
        }
        let mut avail_1: size_t = finish.offset_from(start) as libc::c_long as size_t;
        if start > finish {
            avail_1 = 0 as libc::c_int as size_t;
        }
        if amount_1 > avail_1 {
            amount_1 = avail_1;
        }
        if amount_1 == 0 as libc::c_int as libc::c_ulong {
            version = 0 as libc::c_int as libc::c_ushort;
        } else {
            version = byte_get
                .expect("non-null function pointer")(start, amount_1 as libc::c_uint)
                as libc::c_ushort;
        }
        start = start.offset(amount_1 as isize);
        if version as libc::c_int != 5 as libc::c_int {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Only DWARF version 5 debug_rnglists info is currently supported.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int;
        }
        let mut amount_2: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_2 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_2,
                    5 as libc::c_int,
                ),
                amount_2 as libc::c_int,
                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
            );
            amount_2 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
        }
        let mut avail_2: size_t = finish.offset_from(start) as libc::c_long as size_t;
        if start > finish {
            avail_2 = 0 as libc::c_int as size_t;
        }
        if amount_2 > avail_2 {
            amount_2 = avail_2;
        }
        if amount_2 == 0 as libc::c_int as libc::c_ulong {
            address_size = 0 as libc::c_int as libc::c_uchar;
        } else {
            address_size = byte_get
                .expect("non-null function pointer")(start, amount_2 as libc::c_uint)
                as libc::c_uchar;
        }
        start = start.offset(amount_2 as isize);
        let mut amount_3: size_t = 1 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong) < amount_3 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_3,
                    5 as libc::c_int,
                ),
                amount_3 as libc::c_int,
                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong as libc::c_int,
            );
            amount_3 = ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong;
        }
        let mut avail_3: size_t = finish.offset_from(start) as libc::c_long as size_t;
        if start > finish {
            avail_3 = 0 as libc::c_int as size_t;
        }
        if amount_3 > avail_3 {
            amount_3 = avail_3;
        }
        if amount_3 == 0 as libc::c_int as libc::c_ulong {
            segment_selector_size = 0 as libc::c_int as libc::c_uchar;
        } else {
            segment_selector_size = byte_get
                .expect("non-null function pointer")(start, amount_3 as libc::c_uint)
                as libc::c_uchar;
        }
        start = start.offset(amount_3 as isize);
        if segment_selector_size as libc::c_int != 0 as libc::c_int {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The %s section contains unsupported segment selector size: %d.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                segment_selector_size as libc::c_int,
            );
            return 0 as libc::c_int;
        }
        let mut amount_4: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_4 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_4,
                    5 as libc::c_int,
                ),
                amount_4 as libc::c_int,
                ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
            );
            amount_4 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
        }
        let mut avail_4: size_t = finish.offset_from(start) as libc::c_long as size_t;
        if start > finish {
            avail_4 = 0 as libc::c_int as size_t;
        }
        if amount_4 > avail_4 {
            amount_4 = avail_4;
        }
        if amount_4 == 0 as libc::c_int as libc::c_ulong {
            offset_entry_count = 0 as libc::c_int as libc::c_uint;
        } else {
            offset_entry_count = byte_get
                .expect("non-null function pointer")(start, amount_4 as libc::c_uint)
                as libc::c_uint;
        }
        start = start.offset(amount_4 as isize);
        if offset_entry_count != 0 as libc::c_int as libc::c_uint {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"The %s section contains unsupported offset entry count: %u.\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
                offset_entry_count,
            );
            return 0 as libc::c_int;
        }
    }
    if load_debug_info(file) == 0 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    num_range_list = 0 as libc::c_int as libc::c_uint;
    i = 0 as libc::c_int as libc::c_uint;
    while i < num_debug_info_entries {
        if !((*debug_information.offset(i as isize)).dwarf_version < 5 as libc::c_int
            && is_rnglists != 0)
        {
            if !((*debug_information.offset(i as isize)).dwarf_version
                >= 5 as libc::c_int && is_rnglists == 0)
            {
                num_range_list = num_range_list
                    .wrapping_add(
                        (*debug_information.offset(i as isize)).num_range_lists,
                    );
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    if num_range_list == 0 as libc::c_int as libc::c_uint {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"No range lists in .debug_info section.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 1 as libc::c_int;
    }
    range_entries = xmalloc(
        (::core::mem::size_of::<range_entry>() as libc::c_ulong)
            .wrapping_mul(num_range_list as libc::c_ulong),
    ) as *mut range_entry;
    range_entry_fill = range_entries;
    i = 0 as libc::c_int as libc::c_uint;
    while i < num_debug_info_entries {
        let mut debug_info_p: *mut debug_info = &mut *debug_information
            .offset(i as isize) as *mut debug_info;
        let mut j: libc::c_uint = 0;
        if !((*debug_information.offset(i as isize)).dwarf_version < 5 as libc::c_int
            && is_rnglists != 0)
        {
            if !((*debug_information.offset(i as isize)).dwarf_version
                >= 5 as libc::c_int && is_rnglists == 0)
            {
                j = 0 as libc::c_int as libc::c_uint;
                while j < (*debug_info_p).num_range_lists {
                    (*range_entry_fill)
                        .ranges_offset = *((*debug_info_p).range_lists)
                        .offset(j as isize);
                    (*range_entry_fill).debug_info_p = debug_info_p;
                    range_entry_fill = range_entry_fill.offset(1);
                    range_entry_fill;
                    j = j.wrapping_add(1);
                    j;
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    qsort(
        range_entries as *mut libc::c_void,
        num_range_list as size_t,
        ::core::mem::size_of::<range_entry>() as libc::c_ulong,
        Some(
            range_entry_compar
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    if dwarf_check != 0 as libc::c_int
        && (*range_entries.offset(0 as libc::c_int as isize)).ranges_offset
            != 0 as libc::c_int as libc::c_ulong
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Range lists in %s section start at 0x%lx\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
            (*range_entries.offset(0 as libc::c_int as isize)).ranges_offset,
        );
    }
    introduce(section, 0 as libc::c_int != 0);
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"    Offset   Begin    End\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    let mut current_block_172: u64;
    i = 0 as libc::c_int as libc::c_uint;
    while i < num_range_list {
        let mut range_entry: *mut range_entry = &mut *range_entries.offset(i as isize)
            as *mut range_entry;
        let mut debug_info_p_0: *mut debug_info = (*range_entry).debug_info_p;
        let mut pointer_size: libc::c_uint = 0;
        let mut offset: dwarf_vma = 0;
        let mut next: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut base_address: dwarf_vma = 0;
        pointer_size = if is_rnglists != 0 {
            address_size as libc::c_uint
        } else {
            (*debug_info_p_0).pointer_size
        };
        offset = (*range_entry).ranges_offset;
        base_address = (*debug_info_p_0).base_address;
        if pointer_size < 2 as libc::c_int as libc::c_uint
            || pointer_size > 8 as libc::c_int as libc::c_uint
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Corrupt pointer size (%d) in debug entry at offset %8.8lx\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                pointer_size,
                offset,
            );
        } else if offset > finish.offset_from(section_begin) as libc::c_long as size_t {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Corrupt offset (%#8.8lx) in range entry %u\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                offset,
                i,
            );
        } else {
            next = section_begin.offset(offset as isize);
            if !(i > 0 as libc::c_int as libc::c_uint && last_offset == offset) {
                last_offset = offset;
                if dwarf_check != 0 as libc::c_int
                    && i > 0 as libc::c_int as libc::c_uint
                {
                    if start < next {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"There is a hole [0x%lx - 0x%lx] in %s section.\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            start.offset_from(section_begin) as libc::c_long
                                as libc::c_ulong,
                            next.offset_from(section_begin) as libc::c_long
                                as libc::c_ulong,
                            (*section).name,
                        );
                        current_block_172 = 17294538204572434997;
                    } else if start > next {
                        if next == last_start {
                            current_block_172 = 16974974966130203269;
                        } else {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"There is an overlap [0x%lx - 0x%lx] in %s section.\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                start.offset_from(section_begin) as libc::c_long
                                    as libc::c_ulong,
                                next.offset_from(section_begin) as libc::c_long
                                    as libc::c_ulong,
                                (*section).name,
                            );
                            current_block_172 = 17294538204572434997;
                        }
                    } else {
                        current_block_172 = 17294538204572434997;
                    }
                } else {
                    current_block_172 = 17294538204572434997;
                }
                match current_block_172 {
                    16974974966130203269 => {}
                    _ => {
                        start = next;
                        last_start = next;
                        if is_rnglists != 0 {
                            Some(
                                display_debug_rnglists_list
                                    as unsafe extern "C" fn(
                                        *mut libc::c_uchar,
                                        *mut libc::c_uchar,
                                        libc::c_uint,
                                        libc::c_ulong,
                                        libc::c_ulong,
                                    ) -> (),
                            )
                        } else {
                            Some(
                                display_debug_ranges_list
                                    as unsafe extern "C" fn(
                                        *mut libc::c_uchar,
                                        *mut libc::c_uchar,
                                        libc::c_uint,
                                        libc::c_ulong,
                                        libc::c_ulong,
                                    ) -> (),
                            )
                        }
                            .expect(
                                "non-null function pointer",
                            )(start, finish, pointer_size, offset, base_address);
                    }
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    putchar('\n' as i32);
    free(range_entries as *mut libc::c_void);
    return 1 as libc::c_int;
}
static mut dwarf_regnames_lookup_func: dwarf_regname_lookup_ftype = None;
static mut dwarf_regnames: *const *const libc::c_char = 0 as *const *const libc::c_char;
static mut dwarf_regnames_count: libc::c_uint = 0;
unsafe extern "C" fn frame_need_space(
    mut fc: *mut Frame_Chunk,
    mut reg: libc::c_uint,
) -> libc::c_int {
    let mut prev: libc::c_uint = (*fc).ncols;
    if reg < (*fc).ncols {
        return 0 as libc::c_int;
    }
    if dwarf_regnames_count > 0 as libc::c_int as libc::c_uint
        && reg > dwarf_regnames_count
    {
        return -(1 as libc::c_int);
    }
    (*fc).ncols = reg.wrapping_add(1 as libc::c_int as libc::c_uint);
    if (*fc).ncols == 0 as libc::c_int as libc::c_uint {
        return -(1 as libc::c_int);
    }
    if (*fc).ncols > 1024 as libc::c_int as libc::c_uint
        && dwarf_regnames_count == 0 as libc::c_int as libc::c_uint
    {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Unfeasibly large register number: %u\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            reg,
        );
        (*fc).ncols = 0 as libc::c_int as libc::c_uint;
        return -(1 as libc::c_int);
    }
    (*fc)
        .col_type = xcrealloc(
        (*fc).col_type as *mut libc::c_void,
        (*fc).ncols as size_t,
        ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
    ) as *mut libc::c_short;
    (*fc)
        .col_offset = xcrealloc(
        (*fc).col_offset as *mut libc::c_void,
        (*fc).ncols as size_t,
        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
    ) as *mut libc::c_int;
    if ((*fc).col_type).is_null() || ((*fc).col_offset).is_null() {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory allocating %u columns in dwarf frame arrays\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*fc).ncols,
        );
        (*fc).ncols = 0 as libc::c_int as libc::c_uint;
        return -(1 as libc::c_int);
    }
    while prev < (*fc).ncols {
        *((*fc).col_type).offset(prev as isize) = -(1 as libc::c_int) as libc::c_short;
        *((*fc).col_offset).offset(prev as isize) = 0 as libc::c_int;
        prev = prev.wrapping_add(1);
        prev;
    }
    return 1 as libc::c_int;
}
static mut dwarf_regnames_i386: [*const libc::c_char; 101] = [
    b"eax\0" as *const u8 as *const libc::c_char,
    b"ecx\0" as *const u8 as *const libc::c_char,
    b"edx\0" as *const u8 as *const libc::c_char,
    b"ebx\0" as *const u8 as *const libc::c_char,
    b"esp\0" as *const u8 as *const libc::c_char,
    b"ebp\0" as *const u8 as *const libc::c_char,
    b"esi\0" as *const u8 as *const libc::c_char,
    b"edi\0" as *const u8 as *const libc::c_char,
    b"eip\0" as *const u8 as *const libc::c_char,
    b"eflags\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    b"st0\0" as *const u8 as *const libc::c_char,
    b"st1\0" as *const u8 as *const libc::c_char,
    b"st2\0" as *const u8 as *const libc::c_char,
    b"st3\0" as *const u8 as *const libc::c_char,
    b"st4\0" as *const u8 as *const libc::c_char,
    b"st5\0" as *const u8 as *const libc::c_char,
    b"st6\0" as *const u8 as *const libc::c_char,
    b"st7\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"xmm0\0" as *const u8 as *const libc::c_char,
    b"xmm1\0" as *const u8 as *const libc::c_char,
    b"xmm2\0" as *const u8 as *const libc::c_char,
    b"xmm3\0" as *const u8 as *const libc::c_char,
    b"xmm4\0" as *const u8 as *const libc::c_char,
    b"xmm5\0" as *const u8 as *const libc::c_char,
    b"xmm6\0" as *const u8 as *const libc::c_char,
    b"xmm7\0" as *const u8 as *const libc::c_char,
    b"mm0\0" as *const u8 as *const libc::c_char,
    b"mm1\0" as *const u8 as *const libc::c_char,
    b"mm2\0" as *const u8 as *const libc::c_char,
    b"mm3\0" as *const u8 as *const libc::c_char,
    b"mm4\0" as *const u8 as *const libc::c_char,
    b"mm5\0" as *const u8 as *const libc::c_char,
    b"mm6\0" as *const u8 as *const libc::c_char,
    b"mm7\0" as *const u8 as *const libc::c_char,
    b"fcw\0" as *const u8 as *const libc::c_char,
    b"fsw\0" as *const u8 as *const libc::c_char,
    b"mxcsr\0" as *const u8 as *const libc::c_char,
    b"es\0" as *const u8 as *const libc::c_char,
    b"cs\0" as *const u8 as *const libc::c_char,
    b"ss\0" as *const u8 as *const libc::c_char,
    b"ds\0" as *const u8 as *const libc::c_char,
    b"fs\0" as *const u8 as *const libc::c_char,
    b"gs\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"tr\0" as *const u8 as *const libc::c_char,
    b"ldtr\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"k0\0" as *const u8 as *const libc::c_char,
    b"k1\0" as *const u8 as *const libc::c_char,
    b"k2\0" as *const u8 as *const libc::c_char,
    b"k3\0" as *const u8 as *const libc::c_char,
    b"k4\0" as *const u8 as *const libc::c_char,
    b"k5\0" as *const u8 as *const libc::c_char,
    b"k6\0" as *const u8 as *const libc::c_char,
    b"k7\0" as *const u8 as *const libc::c_char,
];
static mut dwarf_regnames_iamcu: [*const libc::c_char; 101] = [
    b"eax\0" as *const u8 as *const libc::c_char,
    b"ecx\0" as *const u8 as *const libc::c_char,
    b"edx\0" as *const u8 as *const libc::c_char,
    b"ebx\0" as *const u8 as *const libc::c_char,
    b"esp\0" as *const u8 as *const libc::c_char,
    b"ebp\0" as *const u8 as *const libc::c_char,
    b"esi\0" as *const u8 as *const libc::c_char,
    b"edi\0" as *const u8 as *const libc::c_char,
    b"eip\0" as *const u8 as *const libc::c_char,
    b"eflags\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"es\0" as *const u8 as *const libc::c_char,
    b"cs\0" as *const u8 as *const libc::c_char,
    b"ss\0" as *const u8 as *const libc::c_char,
    b"ds\0" as *const u8 as *const libc::c_char,
    b"fs\0" as *const u8 as *const libc::c_char,
    b"gs\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"tr\0" as *const u8 as *const libc::c_char,
    b"ldtr\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
];
unsafe extern "C" fn init_dwarf_regnames_i386() {
    dwarf_regnames = dwarf_regnames_i386.as_ptr();
    dwarf_regnames_count = (::core::mem::size_of::<[*const libc::c_char; 101]>()
        as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
        as libc::c_uint;
    dwarf_regnames_lookup_func = Some(
        regname_internal_by_table_only
            as unsafe extern "C" fn(libc::c_uint) -> *const libc::c_char,
    );
}
unsafe extern "C" fn init_dwarf_regnames_iamcu() {
    dwarf_regnames = dwarf_regnames_iamcu.as_ptr();
    dwarf_regnames_count = (::core::mem::size_of::<[*const libc::c_char; 101]>()
        as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
        as libc::c_uint;
    dwarf_regnames_lookup_func = Some(
        regname_internal_by_table_only
            as unsafe extern "C" fn(libc::c_uint) -> *const libc::c_char,
    );
}
static mut dwarf_regnames_x86_64: [*const libc::c_char; 126] = [
    b"rax\0" as *const u8 as *const libc::c_char,
    b"rdx\0" as *const u8 as *const libc::c_char,
    b"rcx\0" as *const u8 as *const libc::c_char,
    b"rbx\0" as *const u8 as *const libc::c_char,
    b"rsi\0" as *const u8 as *const libc::c_char,
    b"rdi\0" as *const u8 as *const libc::c_char,
    b"rbp\0" as *const u8 as *const libc::c_char,
    b"rsp\0" as *const u8 as *const libc::c_char,
    b"r8\0" as *const u8 as *const libc::c_char,
    b"r9\0" as *const u8 as *const libc::c_char,
    b"r10\0" as *const u8 as *const libc::c_char,
    b"r11\0" as *const u8 as *const libc::c_char,
    b"r12\0" as *const u8 as *const libc::c_char,
    b"r13\0" as *const u8 as *const libc::c_char,
    b"r14\0" as *const u8 as *const libc::c_char,
    b"r15\0" as *const u8 as *const libc::c_char,
    b"rip\0" as *const u8 as *const libc::c_char,
    b"xmm0\0" as *const u8 as *const libc::c_char,
    b"xmm1\0" as *const u8 as *const libc::c_char,
    b"xmm2\0" as *const u8 as *const libc::c_char,
    b"xmm3\0" as *const u8 as *const libc::c_char,
    b"xmm4\0" as *const u8 as *const libc::c_char,
    b"xmm5\0" as *const u8 as *const libc::c_char,
    b"xmm6\0" as *const u8 as *const libc::c_char,
    b"xmm7\0" as *const u8 as *const libc::c_char,
    b"xmm8\0" as *const u8 as *const libc::c_char,
    b"xmm9\0" as *const u8 as *const libc::c_char,
    b"xmm10\0" as *const u8 as *const libc::c_char,
    b"xmm11\0" as *const u8 as *const libc::c_char,
    b"xmm12\0" as *const u8 as *const libc::c_char,
    b"xmm13\0" as *const u8 as *const libc::c_char,
    b"xmm14\0" as *const u8 as *const libc::c_char,
    b"xmm15\0" as *const u8 as *const libc::c_char,
    b"st0\0" as *const u8 as *const libc::c_char,
    b"st1\0" as *const u8 as *const libc::c_char,
    b"st2\0" as *const u8 as *const libc::c_char,
    b"st3\0" as *const u8 as *const libc::c_char,
    b"st4\0" as *const u8 as *const libc::c_char,
    b"st5\0" as *const u8 as *const libc::c_char,
    b"st6\0" as *const u8 as *const libc::c_char,
    b"st7\0" as *const u8 as *const libc::c_char,
    b"mm0\0" as *const u8 as *const libc::c_char,
    b"mm1\0" as *const u8 as *const libc::c_char,
    b"mm2\0" as *const u8 as *const libc::c_char,
    b"mm3\0" as *const u8 as *const libc::c_char,
    b"mm4\0" as *const u8 as *const libc::c_char,
    b"mm5\0" as *const u8 as *const libc::c_char,
    b"mm6\0" as *const u8 as *const libc::c_char,
    b"mm7\0" as *const u8 as *const libc::c_char,
    b"rflags\0" as *const u8 as *const libc::c_char,
    b"es\0" as *const u8 as *const libc::c_char,
    b"cs\0" as *const u8 as *const libc::c_char,
    b"ss\0" as *const u8 as *const libc::c_char,
    b"ds\0" as *const u8 as *const libc::c_char,
    b"fs\0" as *const u8 as *const libc::c_char,
    b"gs\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"fs.base\0" as *const u8 as *const libc::c_char,
    b"gs.base\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"tr\0" as *const u8 as *const libc::c_char,
    b"ldtr\0" as *const u8 as *const libc::c_char,
    b"mxcsr\0" as *const u8 as *const libc::c_char,
    b"fcw\0" as *const u8 as *const libc::c_char,
    b"fsw\0" as *const u8 as *const libc::c_char,
    b"xmm16\0" as *const u8 as *const libc::c_char,
    b"xmm17\0" as *const u8 as *const libc::c_char,
    b"xmm18\0" as *const u8 as *const libc::c_char,
    b"xmm19\0" as *const u8 as *const libc::c_char,
    b"xmm20\0" as *const u8 as *const libc::c_char,
    b"xmm21\0" as *const u8 as *const libc::c_char,
    b"xmm22\0" as *const u8 as *const libc::c_char,
    b"xmm23\0" as *const u8 as *const libc::c_char,
    b"xmm24\0" as *const u8 as *const libc::c_char,
    b"xmm25\0" as *const u8 as *const libc::c_char,
    b"xmm26\0" as *const u8 as *const libc::c_char,
    b"xmm27\0" as *const u8 as *const libc::c_char,
    b"xmm28\0" as *const u8 as *const libc::c_char,
    b"xmm29\0" as *const u8 as *const libc::c_char,
    b"xmm30\0" as *const u8 as *const libc::c_char,
    b"xmm31\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"k0\0" as *const u8 as *const libc::c_char,
    b"k1\0" as *const u8 as *const libc::c_char,
    b"k2\0" as *const u8 as *const libc::c_char,
    b"k3\0" as *const u8 as *const libc::c_char,
    b"k4\0" as *const u8 as *const libc::c_char,
    b"k5\0" as *const u8 as *const libc::c_char,
    b"k6\0" as *const u8 as *const libc::c_char,
    b"k7\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn init_dwarf_regnames_x86_64() {
    dwarf_regnames = dwarf_regnames_x86_64.as_ptr();
    dwarf_regnames_count = (::core::mem::size_of::<[*const libc::c_char; 126]>()
        as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
        as libc::c_uint;
    dwarf_regnames_lookup_func = Some(
        regname_internal_by_table_only
            as unsafe extern "C" fn(libc::c_uint) -> *const libc::c_char,
    );
}
static mut dwarf_regnames_aarch64: [*const libc::c_char; 128] = [
    b"x0\0" as *const u8 as *const libc::c_char,
    b"x1\0" as *const u8 as *const libc::c_char,
    b"x2\0" as *const u8 as *const libc::c_char,
    b"x3\0" as *const u8 as *const libc::c_char,
    b"x4\0" as *const u8 as *const libc::c_char,
    b"x5\0" as *const u8 as *const libc::c_char,
    b"x6\0" as *const u8 as *const libc::c_char,
    b"x7\0" as *const u8 as *const libc::c_char,
    b"x8\0" as *const u8 as *const libc::c_char,
    b"x9\0" as *const u8 as *const libc::c_char,
    b"x10\0" as *const u8 as *const libc::c_char,
    b"x11\0" as *const u8 as *const libc::c_char,
    b"x12\0" as *const u8 as *const libc::c_char,
    b"x13\0" as *const u8 as *const libc::c_char,
    b"x14\0" as *const u8 as *const libc::c_char,
    b"x15\0" as *const u8 as *const libc::c_char,
    b"x16\0" as *const u8 as *const libc::c_char,
    b"x17\0" as *const u8 as *const libc::c_char,
    b"x18\0" as *const u8 as *const libc::c_char,
    b"x19\0" as *const u8 as *const libc::c_char,
    b"x20\0" as *const u8 as *const libc::c_char,
    b"x21\0" as *const u8 as *const libc::c_char,
    b"x22\0" as *const u8 as *const libc::c_char,
    b"x23\0" as *const u8 as *const libc::c_char,
    b"x24\0" as *const u8 as *const libc::c_char,
    b"x25\0" as *const u8 as *const libc::c_char,
    b"x26\0" as *const u8 as *const libc::c_char,
    b"x27\0" as *const u8 as *const libc::c_char,
    b"x28\0" as *const u8 as *const libc::c_char,
    b"x29\0" as *const u8 as *const libc::c_char,
    b"x30\0" as *const u8 as *const libc::c_char,
    b"sp\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    b"elr\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"vg\0" as *const u8 as *const libc::c_char,
    b"ffr\0" as *const u8 as *const libc::c_char,
    b"p0\0" as *const u8 as *const libc::c_char,
    b"p1\0" as *const u8 as *const libc::c_char,
    b"p2\0" as *const u8 as *const libc::c_char,
    b"p3\0" as *const u8 as *const libc::c_char,
    b"p4\0" as *const u8 as *const libc::c_char,
    b"p5\0" as *const u8 as *const libc::c_char,
    b"p6\0" as *const u8 as *const libc::c_char,
    b"p7\0" as *const u8 as *const libc::c_char,
    b"p8\0" as *const u8 as *const libc::c_char,
    b"p9\0" as *const u8 as *const libc::c_char,
    b"p10\0" as *const u8 as *const libc::c_char,
    b"p11\0" as *const u8 as *const libc::c_char,
    b"p12\0" as *const u8 as *const libc::c_char,
    b"p13\0" as *const u8 as *const libc::c_char,
    b"p14\0" as *const u8 as *const libc::c_char,
    b"p15\0" as *const u8 as *const libc::c_char,
    b"v0\0" as *const u8 as *const libc::c_char,
    b"v1\0" as *const u8 as *const libc::c_char,
    b"v2\0" as *const u8 as *const libc::c_char,
    b"v3\0" as *const u8 as *const libc::c_char,
    b"v4\0" as *const u8 as *const libc::c_char,
    b"v5\0" as *const u8 as *const libc::c_char,
    b"v6\0" as *const u8 as *const libc::c_char,
    b"v7\0" as *const u8 as *const libc::c_char,
    b"v8\0" as *const u8 as *const libc::c_char,
    b"v9\0" as *const u8 as *const libc::c_char,
    b"v10\0" as *const u8 as *const libc::c_char,
    b"v11\0" as *const u8 as *const libc::c_char,
    b"v12\0" as *const u8 as *const libc::c_char,
    b"v13\0" as *const u8 as *const libc::c_char,
    b"v14\0" as *const u8 as *const libc::c_char,
    b"v15\0" as *const u8 as *const libc::c_char,
    b"v16\0" as *const u8 as *const libc::c_char,
    b"v17\0" as *const u8 as *const libc::c_char,
    b"v18\0" as *const u8 as *const libc::c_char,
    b"v19\0" as *const u8 as *const libc::c_char,
    b"v20\0" as *const u8 as *const libc::c_char,
    b"v21\0" as *const u8 as *const libc::c_char,
    b"v22\0" as *const u8 as *const libc::c_char,
    b"v23\0" as *const u8 as *const libc::c_char,
    b"v24\0" as *const u8 as *const libc::c_char,
    b"v25\0" as *const u8 as *const libc::c_char,
    b"v26\0" as *const u8 as *const libc::c_char,
    b"v27\0" as *const u8 as *const libc::c_char,
    b"v28\0" as *const u8 as *const libc::c_char,
    b"v29\0" as *const u8 as *const libc::c_char,
    b"v30\0" as *const u8 as *const libc::c_char,
    b"v31\0" as *const u8 as *const libc::c_char,
    b"z0\0" as *const u8 as *const libc::c_char,
    b"z1\0" as *const u8 as *const libc::c_char,
    b"z2\0" as *const u8 as *const libc::c_char,
    b"z3\0" as *const u8 as *const libc::c_char,
    b"z4\0" as *const u8 as *const libc::c_char,
    b"z5\0" as *const u8 as *const libc::c_char,
    b"z6\0" as *const u8 as *const libc::c_char,
    b"z7\0" as *const u8 as *const libc::c_char,
    b"z8\0" as *const u8 as *const libc::c_char,
    b"z9\0" as *const u8 as *const libc::c_char,
    b"z10\0" as *const u8 as *const libc::c_char,
    b"z11\0" as *const u8 as *const libc::c_char,
    b"z12\0" as *const u8 as *const libc::c_char,
    b"z13\0" as *const u8 as *const libc::c_char,
    b"z14\0" as *const u8 as *const libc::c_char,
    b"z15\0" as *const u8 as *const libc::c_char,
    b"z16\0" as *const u8 as *const libc::c_char,
    b"z17\0" as *const u8 as *const libc::c_char,
    b"z18\0" as *const u8 as *const libc::c_char,
    b"z19\0" as *const u8 as *const libc::c_char,
    b"z20\0" as *const u8 as *const libc::c_char,
    b"z21\0" as *const u8 as *const libc::c_char,
    b"z22\0" as *const u8 as *const libc::c_char,
    b"z23\0" as *const u8 as *const libc::c_char,
    b"z24\0" as *const u8 as *const libc::c_char,
    b"z25\0" as *const u8 as *const libc::c_char,
    b"z26\0" as *const u8 as *const libc::c_char,
    b"z27\0" as *const u8 as *const libc::c_char,
    b"z28\0" as *const u8 as *const libc::c_char,
    b"z29\0" as *const u8 as *const libc::c_char,
    b"z30\0" as *const u8 as *const libc::c_char,
    b"z31\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn init_dwarf_regnames_aarch64() {
    dwarf_regnames = dwarf_regnames_aarch64.as_ptr();
    dwarf_regnames_count = (::core::mem::size_of::<[*const libc::c_char; 128]>()
        as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
        as libc::c_uint;
    dwarf_regnames_lookup_func = Some(
        regname_internal_by_table_only
            as unsafe extern "C" fn(libc::c_uint) -> *const libc::c_char,
    );
}
static mut dwarf_regnames_s390: [*const libc::c_char; 84] = [
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"f0\0" as *const u8 as *const libc::c_char,
    b"f2\0" as *const u8 as *const libc::c_char,
    b"f4\0" as *const u8 as *const libc::c_char,
    b"f6\0" as *const u8 as *const libc::c_char,
    b"f1\0" as *const u8 as *const libc::c_char,
    b"f3\0" as *const u8 as *const libc::c_char,
    b"f5\0" as *const u8 as *const libc::c_char,
    b"f7\0" as *const u8 as *const libc::c_char,
    b"f8\0" as *const u8 as *const libc::c_char,
    b"f10\0" as *const u8 as *const libc::c_char,
    b"f12\0" as *const u8 as *const libc::c_char,
    b"f14\0" as *const u8 as *const libc::c_char,
    b"f9\0" as *const u8 as *const libc::c_char,
    b"f11\0" as *const u8 as *const libc::c_char,
    b"f13\0" as *const u8 as *const libc::c_char,
    b"f15\0" as *const u8 as *const libc::c_char,
    b"cr0\0" as *const u8 as *const libc::c_char,
    b"cr1\0" as *const u8 as *const libc::c_char,
    b"cr2\0" as *const u8 as *const libc::c_char,
    b"cr3\0" as *const u8 as *const libc::c_char,
    b"cr4\0" as *const u8 as *const libc::c_char,
    b"cr5\0" as *const u8 as *const libc::c_char,
    b"cr6\0" as *const u8 as *const libc::c_char,
    b"cr7\0" as *const u8 as *const libc::c_char,
    b"cr8\0" as *const u8 as *const libc::c_char,
    b"cr9\0" as *const u8 as *const libc::c_char,
    b"cr10\0" as *const u8 as *const libc::c_char,
    b"cr11\0" as *const u8 as *const libc::c_char,
    b"cr12\0" as *const u8 as *const libc::c_char,
    b"cr13\0" as *const u8 as *const libc::c_char,
    b"cr14\0" as *const u8 as *const libc::c_char,
    b"cr15\0" as *const u8 as *const libc::c_char,
    b"a0\0" as *const u8 as *const libc::c_char,
    b"a1\0" as *const u8 as *const libc::c_char,
    b"a2\0" as *const u8 as *const libc::c_char,
    b"a3\0" as *const u8 as *const libc::c_char,
    b"a4\0" as *const u8 as *const libc::c_char,
    b"a5\0" as *const u8 as *const libc::c_char,
    b"a6\0" as *const u8 as *const libc::c_char,
    b"a7\0" as *const u8 as *const libc::c_char,
    b"a8\0" as *const u8 as *const libc::c_char,
    b"a9\0" as *const u8 as *const libc::c_char,
    b"a10\0" as *const u8 as *const libc::c_char,
    b"a11\0" as *const u8 as *const libc::c_char,
    b"a12\0" as *const u8 as *const libc::c_char,
    b"a13\0" as *const u8 as *const libc::c_char,
    b"a14\0" as *const u8 as *const libc::c_char,
    b"a15\0" as *const u8 as *const libc::c_char,
    b"pswm\0" as *const u8 as *const libc::c_char,
    b"pswa\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_char,
    0 as *const libc::c_char,
    b"v16\0" as *const u8 as *const libc::c_char,
    b"v18\0" as *const u8 as *const libc::c_char,
    b"v20\0" as *const u8 as *const libc::c_char,
    b"v22\0" as *const u8 as *const libc::c_char,
    b"v17\0" as *const u8 as *const libc::c_char,
    b"v19\0" as *const u8 as *const libc::c_char,
    b"v21\0" as *const u8 as *const libc::c_char,
    b"v23\0" as *const u8 as *const libc::c_char,
    b"v24\0" as *const u8 as *const libc::c_char,
    b"v26\0" as *const u8 as *const libc::c_char,
    b"v28\0" as *const u8 as *const libc::c_char,
    b"v30\0" as *const u8 as *const libc::c_char,
    b"v25\0" as *const u8 as *const libc::c_char,
    b"v27\0" as *const u8 as *const libc::c_char,
    b"v29\0" as *const u8 as *const libc::c_char,
    b"v31\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn init_dwarf_regnames_s390() {
    dwarf_regnames = dwarf_regnames_s390.as_ptr();
    dwarf_regnames_count = (::core::mem::size_of::<[*const libc::c_char; 84]>()
        as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
        as libc::c_uint;
    dwarf_regnames_lookup_func = Some(
        regname_internal_by_table_only
            as unsafe extern "C" fn(libc::c_uint) -> *const libc::c_char,
    );
}
static mut dwarf_regnames_riscv: [*const libc::c_char; 64] = [
    b"zero\0" as *const u8 as *const libc::c_char,
    b"ra\0" as *const u8 as *const libc::c_char,
    b"sp\0" as *const u8 as *const libc::c_char,
    b"gp\0" as *const u8 as *const libc::c_char,
    b"tp\0" as *const u8 as *const libc::c_char,
    b"t0\0" as *const u8 as *const libc::c_char,
    b"t1\0" as *const u8 as *const libc::c_char,
    b"t2\0" as *const u8 as *const libc::c_char,
    b"s0\0" as *const u8 as *const libc::c_char,
    b"s1\0" as *const u8 as *const libc::c_char,
    b"a0\0" as *const u8 as *const libc::c_char,
    b"a1\0" as *const u8 as *const libc::c_char,
    b"a2\0" as *const u8 as *const libc::c_char,
    b"a3\0" as *const u8 as *const libc::c_char,
    b"a4\0" as *const u8 as *const libc::c_char,
    b"a5\0" as *const u8 as *const libc::c_char,
    b"a6\0" as *const u8 as *const libc::c_char,
    b"a7\0" as *const u8 as *const libc::c_char,
    b"s2\0" as *const u8 as *const libc::c_char,
    b"s3\0" as *const u8 as *const libc::c_char,
    b"s4\0" as *const u8 as *const libc::c_char,
    b"s5\0" as *const u8 as *const libc::c_char,
    b"s6\0" as *const u8 as *const libc::c_char,
    b"s7\0" as *const u8 as *const libc::c_char,
    b"s8\0" as *const u8 as *const libc::c_char,
    b"s9\0" as *const u8 as *const libc::c_char,
    b"s10\0" as *const u8 as *const libc::c_char,
    b"s11\0" as *const u8 as *const libc::c_char,
    b"t3\0" as *const u8 as *const libc::c_char,
    b"t4\0" as *const u8 as *const libc::c_char,
    b"t5\0" as *const u8 as *const libc::c_char,
    b"t6\0" as *const u8 as *const libc::c_char,
    b"ft0\0" as *const u8 as *const libc::c_char,
    b"ft1\0" as *const u8 as *const libc::c_char,
    b"ft2\0" as *const u8 as *const libc::c_char,
    b"ft3\0" as *const u8 as *const libc::c_char,
    b"ft4\0" as *const u8 as *const libc::c_char,
    b"ft5\0" as *const u8 as *const libc::c_char,
    b"ft6\0" as *const u8 as *const libc::c_char,
    b"ft7\0" as *const u8 as *const libc::c_char,
    b"fs0\0" as *const u8 as *const libc::c_char,
    b"fs1\0" as *const u8 as *const libc::c_char,
    b"fa0\0" as *const u8 as *const libc::c_char,
    b"fa1\0" as *const u8 as *const libc::c_char,
    b"fa2\0" as *const u8 as *const libc::c_char,
    b"fa3\0" as *const u8 as *const libc::c_char,
    b"fa4\0" as *const u8 as *const libc::c_char,
    b"fa5\0" as *const u8 as *const libc::c_char,
    b"fa6\0" as *const u8 as *const libc::c_char,
    b"fa7\0" as *const u8 as *const libc::c_char,
    b"fs2\0" as *const u8 as *const libc::c_char,
    b"fs3\0" as *const u8 as *const libc::c_char,
    b"fs4\0" as *const u8 as *const libc::c_char,
    b"fs5\0" as *const u8 as *const libc::c_char,
    b"fs6\0" as *const u8 as *const libc::c_char,
    b"fs7\0" as *const u8 as *const libc::c_char,
    b"fs8\0" as *const u8 as *const libc::c_char,
    b"fs9\0" as *const u8 as *const libc::c_char,
    b"fs10\0" as *const u8 as *const libc::c_char,
    b"fs11\0" as *const u8 as *const libc::c_char,
    b"ft8\0" as *const u8 as *const libc::c_char,
    b"ft9\0" as *const u8 as *const libc::c_char,
    b"ft10\0" as *const u8 as *const libc::c_char,
    b"ft11\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn regname_internal_riscv(
    mut regno: libc::c_uint,
) -> *const libc::c_char {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    if (regno as libc::c_ulong)
        < (::core::mem::size_of::<[*const libc::c_char; 64]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
    {
        name = dwarf_regnames_riscv[regno as usize];
    } else if regno >= 4096 as libc::c_int as libc::c_uint
        && regno <= 8191 as libc::c_int as libc::c_uint
    {
        match regno {
            4096 => {
                name = b"ustatus\0" as *const u8 as *const libc::c_char;
            }
            4100 => {
                name = b"uie\0" as *const u8 as *const libc::c_char;
            }
            4101 => {
                name = b"utvec\0" as *const u8 as *const libc::c_char;
            }
            4160 => {
                name = b"uscratch\0" as *const u8 as *const libc::c_char;
            }
            4161 => {
                name = b"uepc\0" as *const u8 as *const libc::c_char;
            }
            4162 => {
                name = b"ucause\0" as *const u8 as *const libc::c_char;
            }
            4163 => {
                name = b"utval\0" as *const u8 as *const libc::c_char;
            }
            4164 => {
                name = b"uip\0" as *const u8 as *const libc::c_char;
            }
            7168 => {
                name = b"cycle\0" as *const u8 as *const libc::c_char;
            }
            7169 => {
                name = b"time\0" as *const u8 as *const libc::c_char;
            }
            7170 => {
                name = b"instret\0" as *const u8 as *const libc::c_char;
            }
            7171 => {
                name = b"hpmcounter3\0" as *const u8 as *const libc::c_char;
            }
            7172 => {
                name = b"hpmcounter4\0" as *const u8 as *const libc::c_char;
            }
            7173 => {
                name = b"hpmcounter5\0" as *const u8 as *const libc::c_char;
            }
            7174 => {
                name = b"hpmcounter6\0" as *const u8 as *const libc::c_char;
            }
            7175 => {
                name = b"hpmcounter7\0" as *const u8 as *const libc::c_char;
            }
            7176 => {
                name = b"hpmcounter8\0" as *const u8 as *const libc::c_char;
            }
            7177 => {
                name = b"hpmcounter9\0" as *const u8 as *const libc::c_char;
            }
            7178 => {
                name = b"hpmcounter10\0" as *const u8 as *const libc::c_char;
            }
            7179 => {
                name = b"hpmcounter11\0" as *const u8 as *const libc::c_char;
            }
            7180 => {
                name = b"hpmcounter12\0" as *const u8 as *const libc::c_char;
            }
            7181 => {
                name = b"hpmcounter13\0" as *const u8 as *const libc::c_char;
            }
            7182 => {
                name = b"hpmcounter14\0" as *const u8 as *const libc::c_char;
            }
            7183 => {
                name = b"hpmcounter15\0" as *const u8 as *const libc::c_char;
            }
            7184 => {
                name = b"hpmcounter16\0" as *const u8 as *const libc::c_char;
            }
            7185 => {
                name = b"hpmcounter17\0" as *const u8 as *const libc::c_char;
            }
            7186 => {
                name = b"hpmcounter18\0" as *const u8 as *const libc::c_char;
            }
            7187 => {
                name = b"hpmcounter19\0" as *const u8 as *const libc::c_char;
            }
            7188 => {
                name = b"hpmcounter20\0" as *const u8 as *const libc::c_char;
            }
            7189 => {
                name = b"hpmcounter21\0" as *const u8 as *const libc::c_char;
            }
            7190 => {
                name = b"hpmcounter22\0" as *const u8 as *const libc::c_char;
            }
            7191 => {
                name = b"hpmcounter23\0" as *const u8 as *const libc::c_char;
            }
            7192 => {
                name = b"hpmcounter24\0" as *const u8 as *const libc::c_char;
            }
            7193 => {
                name = b"hpmcounter25\0" as *const u8 as *const libc::c_char;
            }
            7194 => {
                name = b"hpmcounter26\0" as *const u8 as *const libc::c_char;
            }
            7195 => {
                name = b"hpmcounter27\0" as *const u8 as *const libc::c_char;
            }
            7196 => {
                name = b"hpmcounter28\0" as *const u8 as *const libc::c_char;
            }
            7197 => {
                name = b"hpmcounter29\0" as *const u8 as *const libc::c_char;
            }
            7198 => {
                name = b"hpmcounter30\0" as *const u8 as *const libc::c_char;
            }
            7199 => {
                name = b"hpmcounter31\0" as *const u8 as *const libc::c_char;
            }
            7296 => {
                name = b"cycleh\0" as *const u8 as *const libc::c_char;
            }
            7297 => {
                name = b"timeh\0" as *const u8 as *const libc::c_char;
            }
            7298 => {
                name = b"instreth\0" as *const u8 as *const libc::c_char;
            }
            7299 => {
                name = b"hpmcounter3h\0" as *const u8 as *const libc::c_char;
            }
            7300 => {
                name = b"hpmcounter4h\0" as *const u8 as *const libc::c_char;
            }
            7301 => {
                name = b"hpmcounter5h\0" as *const u8 as *const libc::c_char;
            }
            7302 => {
                name = b"hpmcounter6h\0" as *const u8 as *const libc::c_char;
            }
            7303 => {
                name = b"hpmcounter7h\0" as *const u8 as *const libc::c_char;
            }
            7304 => {
                name = b"hpmcounter8h\0" as *const u8 as *const libc::c_char;
            }
            7305 => {
                name = b"hpmcounter9h\0" as *const u8 as *const libc::c_char;
            }
            7306 => {
                name = b"hpmcounter10h\0" as *const u8 as *const libc::c_char;
            }
            7307 => {
                name = b"hpmcounter11h\0" as *const u8 as *const libc::c_char;
            }
            7308 => {
                name = b"hpmcounter12h\0" as *const u8 as *const libc::c_char;
            }
            7309 => {
                name = b"hpmcounter13h\0" as *const u8 as *const libc::c_char;
            }
            7310 => {
                name = b"hpmcounter14h\0" as *const u8 as *const libc::c_char;
            }
            7311 => {
                name = b"hpmcounter15h\0" as *const u8 as *const libc::c_char;
            }
            7312 => {
                name = b"hpmcounter16h\0" as *const u8 as *const libc::c_char;
            }
            7313 => {
                name = b"hpmcounter17h\0" as *const u8 as *const libc::c_char;
            }
            7314 => {
                name = b"hpmcounter18h\0" as *const u8 as *const libc::c_char;
            }
            7315 => {
                name = b"hpmcounter19h\0" as *const u8 as *const libc::c_char;
            }
            7316 => {
                name = b"hpmcounter20h\0" as *const u8 as *const libc::c_char;
            }
            7317 => {
                name = b"hpmcounter21h\0" as *const u8 as *const libc::c_char;
            }
            7318 => {
                name = b"hpmcounter22h\0" as *const u8 as *const libc::c_char;
            }
            7319 => {
                name = b"hpmcounter23h\0" as *const u8 as *const libc::c_char;
            }
            7320 => {
                name = b"hpmcounter24h\0" as *const u8 as *const libc::c_char;
            }
            7321 => {
                name = b"hpmcounter25h\0" as *const u8 as *const libc::c_char;
            }
            7322 => {
                name = b"hpmcounter26h\0" as *const u8 as *const libc::c_char;
            }
            7323 => {
                name = b"hpmcounter27h\0" as *const u8 as *const libc::c_char;
            }
            7324 => {
                name = b"hpmcounter28h\0" as *const u8 as *const libc::c_char;
            }
            7325 => {
                name = b"hpmcounter29h\0" as *const u8 as *const libc::c_char;
            }
            7326 => {
                name = b"hpmcounter30h\0" as *const u8 as *const libc::c_char;
            }
            7327 => {
                name = b"hpmcounter31h\0" as *const u8 as *const libc::c_char;
            }
            4352 => {
                name = b"sstatus\0" as *const u8 as *const libc::c_char;
            }
            4354 => {
                name = b"sedeleg\0" as *const u8 as *const libc::c_char;
            }
            4355 => {
                name = b"sideleg\0" as *const u8 as *const libc::c_char;
            }
            4356 => {
                name = b"sie\0" as *const u8 as *const libc::c_char;
            }
            4357 => {
                name = b"stvec\0" as *const u8 as *const libc::c_char;
            }
            4358 => {
                name = b"scounteren\0" as *const u8 as *const libc::c_char;
            }
            4416 => {
                name = b"sscratch\0" as *const u8 as *const libc::c_char;
            }
            4417 => {
                name = b"sepc\0" as *const u8 as *const libc::c_char;
            }
            4418 => {
                name = b"scause\0" as *const u8 as *const libc::c_char;
            }
            4419 => {
                name = b"stval\0" as *const u8 as *const libc::c_char;
            }
            4420 => {
                name = b"sip\0" as *const u8 as *const libc::c_char;
            }
            4480 => {
                name = b"satp\0" as *const u8 as *const libc::c_char;
            }
            7953 => {
                name = b"mvendorid\0" as *const u8 as *const libc::c_char;
            }
            7954 => {
                name = b"marchid\0" as *const u8 as *const libc::c_char;
            }
            7955 => {
                name = b"mimpid\0" as *const u8 as *const libc::c_char;
            }
            7956 => {
                name = b"mhartid\0" as *const u8 as *const libc::c_char;
            }
            4864 => {
                name = b"mstatus\0" as *const u8 as *const libc::c_char;
            }
            4865 => {
                name = b"misa\0" as *const u8 as *const libc::c_char;
            }
            4866 => {
                name = b"medeleg\0" as *const u8 as *const libc::c_char;
            }
            4867 => {
                name = b"mideleg\0" as *const u8 as *const libc::c_char;
            }
            4868 => {
                name = b"mie\0" as *const u8 as *const libc::c_char;
            }
            4869 => {
                name = b"mtvec\0" as *const u8 as *const libc::c_char;
            }
            4870 => {
                name = b"mcounteren\0" as *const u8 as *const libc::c_char;
            }
            4928 => {
                name = b"mscratch\0" as *const u8 as *const libc::c_char;
            }
            4929 => {
                name = b"mepc\0" as *const u8 as *const libc::c_char;
            }
            4930 => {
                name = b"mcause\0" as *const u8 as *const libc::c_char;
            }
            4931 => {
                name = b"mtval\0" as *const u8 as *const libc::c_char;
            }
            4932 => {
                name = b"mip\0" as *const u8 as *const libc::c_char;
            }
            5024 => {
                name = b"pmpcfg0\0" as *const u8 as *const libc::c_char;
            }
            5025 => {
                name = b"pmpcfg1\0" as *const u8 as *const libc::c_char;
            }
            5026 => {
                name = b"pmpcfg2\0" as *const u8 as *const libc::c_char;
            }
            5027 => {
                name = b"pmpcfg3\0" as *const u8 as *const libc::c_char;
            }
            5040 => {
                name = b"pmpaddr0\0" as *const u8 as *const libc::c_char;
            }
            5041 => {
                name = b"pmpaddr1\0" as *const u8 as *const libc::c_char;
            }
            5042 => {
                name = b"pmpaddr2\0" as *const u8 as *const libc::c_char;
            }
            5043 => {
                name = b"pmpaddr3\0" as *const u8 as *const libc::c_char;
            }
            5044 => {
                name = b"pmpaddr4\0" as *const u8 as *const libc::c_char;
            }
            5045 => {
                name = b"pmpaddr5\0" as *const u8 as *const libc::c_char;
            }
            5046 => {
                name = b"pmpaddr6\0" as *const u8 as *const libc::c_char;
            }
            5047 => {
                name = b"pmpaddr7\0" as *const u8 as *const libc::c_char;
            }
            5048 => {
                name = b"pmpaddr8\0" as *const u8 as *const libc::c_char;
            }
            5049 => {
                name = b"pmpaddr9\0" as *const u8 as *const libc::c_char;
            }
            5050 => {
                name = b"pmpaddr10\0" as *const u8 as *const libc::c_char;
            }
            5051 => {
                name = b"pmpaddr11\0" as *const u8 as *const libc::c_char;
            }
            5052 => {
                name = b"pmpaddr12\0" as *const u8 as *const libc::c_char;
            }
            5053 => {
                name = b"pmpaddr13\0" as *const u8 as *const libc::c_char;
            }
            5054 => {
                name = b"pmpaddr14\0" as *const u8 as *const libc::c_char;
            }
            5055 => {
                name = b"pmpaddr15\0" as *const u8 as *const libc::c_char;
            }
            6912 => {
                name = b"mcycle\0" as *const u8 as *const libc::c_char;
            }
            6914 => {
                name = b"minstret\0" as *const u8 as *const libc::c_char;
            }
            6915 => {
                name = b"mhpmcounter3\0" as *const u8 as *const libc::c_char;
            }
            6916 => {
                name = b"mhpmcounter4\0" as *const u8 as *const libc::c_char;
            }
            6917 => {
                name = b"mhpmcounter5\0" as *const u8 as *const libc::c_char;
            }
            6918 => {
                name = b"mhpmcounter6\0" as *const u8 as *const libc::c_char;
            }
            6919 => {
                name = b"mhpmcounter7\0" as *const u8 as *const libc::c_char;
            }
            6920 => {
                name = b"mhpmcounter8\0" as *const u8 as *const libc::c_char;
            }
            6921 => {
                name = b"mhpmcounter9\0" as *const u8 as *const libc::c_char;
            }
            6922 => {
                name = b"mhpmcounter10\0" as *const u8 as *const libc::c_char;
            }
            6923 => {
                name = b"mhpmcounter11\0" as *const u8 as *const libc::c_char;
            }
            6924 => {
                name = b"mhpmcounter12\0" as *const u8 as *const libc::c_char;
            }
            6925 => {
                name = b"mhpmcounter13\0" as *const u8 as *const libc::c_char;
            }
            6926 => {
                name = b"mhpmcounter14\0" as *const u8 as *const libc::c_char;
            }
            6927 => {
                name = b"mhpmcounter15\0" as *const u8 as *const libc::c_char;
            }
            6928 => {
                name = b"mhpmcounter16\0" as *const u8 as *const libc::c_char;
            }
            6929 => {
                name = b"mhpmcounter17\0" as *const u8 as *const libc::c_char;
            }
            6930 => {
                name = b"mhpmcounter18\0" as *const u8 as *const libc::c_char;
            }
            6931 => {
                name = b"mhpmcounter19\0" as *const u8 as *const libc::c_char;
            }
            6932 => {
                name = b"mhpmcounter20\0" as *const u8 as *const libc::c_char;
            }
            6933 => {
                name = b"mhpmcounter21\0" as *const u8 as *const libc::c_char;
            }
            6934 => {
                name = b"mhpmcounter22\0" as *const u8 as *const libc::c_char;
            }
            6935 => {
                name = b"mhpmcounter23\0" as *const u8 as *const libc::c_char;
            }
            6936 => {
                name = b"mhpmcounter24\0" as *const u8 as *const libc::c_char;
            }
            6937 => {
                name = b"mhpmcounter25\0" as *const u8 as *const libc::c_char;
            }
            6938 => {
                name = b"mhpmcounter26\0" as *const u8 as *const libc::c_char;
            }
            6939 => {
                name = b"mhpmcounter27\0" as *const u8 as *const libc::c_char;
            }
            6940 => {
                name = b"mhpmcounter28\0" as *const u8 as *const libc::c_char;
            }
            6941 => {
                name = b"mhpmcounter29\0" as *const u8 as *const libc::c_char;
            }
            6942 => {
                name = b"mhpmcounter30\0" as *const u8 as *const libc::c_char;
            }
            6943 => {
                name = b"mhpmcounter31\0" as *const u8 as *const libc::c_char;
            }
            7040 => {
                name = b"mcycleh\0" as *const u8 as *const libc::c_char;
            }
            7042 => {
                name = b"minstreth\0" as *const u8 as *const libc::c_char;
            }
            7043 => {
                name = b"mhpmcounter3h\0" as *const u8 as *const libc::c_char;
            }
            7044 => {
                name = b"mhpmcounter4h\0" as *const u8 as *const libc::c_char;
            }
            7045 => {
                name = b"mhpmcounter5h\0" as *const u8 as *const libc::c_char;
            }
            7046 => {
                name = b"mhpmcounter6h\0" as *const u8 as *const libc::c_char;
            }
            7047 => {
                name = b"mhpmcounter7h\0" as *const u8 as *const libc::c_char;
            }
            7048 => {
                name = b"mhpmcounter8h\0" as *const u8 as *const libc::c_char;
            }
            7049 => {
                name = b"mhpmcounter9h\0" as *const u8 as *const libc::c_char;
            }
            7050 => {
                name = b"mhpmcounter10h\0" as *const u8 as *const libc::c_char;
            }
            7051 => {
                name = b"mhpmcounter11h\0" as *const u8 as *const libc::c_char;
            }
            7052 => {
                name = b"mhpmcounter12h\0" as *const u8 as *const libc::c_char;
            }
            7053 => {
                name = b"mhpmcounter13h\0" as *const u8 as *const libc::c_char;
            }
            7054 => {
                name = b"mhpmcounter14h\0" as *const u8 as *const libc::c_char;
            }
            7055 => {
                name = b"mhpmcounter15h\0" as *const u8 as *const libc::c_char;
            }
            7056 => {
                name = b"mhpmcounter16h\0" as *const u8 as *const libc::c_char;
            }
            7057 => {
                name = b"mhpmcounter17h\0" as *const u8 as *const libc::c_char;
            }
            7058 => {
                name = b"mhpmcounter18h\0" as *const u8 as *const libc::c_char;
            }
            7059 => {
                name = b"mhpmcounter19h\0" as *const u8 as *const libc::c_char;
            }
            7060 => {
                name = b"mhpmcounter20h\0" as *const u8 as *const libc::c_char;
            }
            7061 => {
                name = b"mhpmcounter21h\0" as *const u8 as *const libc::c_char;
            }
            7062 => {
                name = b"mhpmcounter22h\0" as *const u8 as *const libc::c_char;
            }
            7063 => {
                name = b"mhpmcounter23h\0" as *const u8 as *const libc::c_char;
            }
            7064 => {
                name = b"mhpmcounter24h\0" as *const u8 as *const libc::c_char;
            }
            7065 => {
                name = b"mhpmcounter25h\0" as *const u8 as *const libc::c_char;
            }
            7066 => {
                name = b"mhpmcounter26h\0" as *const u8 as *const libc::c_char;
            }
            7067 => {
                name = b"mhpmcounter27h\0" as *const u8 as *const libc::c_char;
            }
            7068 => {
                name = b"mhpmcounter28h\0" as *const u8 as *const libc::c_char;
            }
            7069 => {
                name = b"mhpmcounter29h\0" as *const u8 as *const libc::c_char;
            }
            7070 => {
                name = b"mhpmcounter30h\0" as *const u8 as *const libc::c_char;
            }
            7071 => {
                name = b"mhpmcounter31h\0" as *const u8 as *const libc::c_char;
            }
            4896 => {
                name = b"mcountinhibit\0" as *const u8 as *const libc::c_char;
            }
            4899 => {
                name = b"mhpmevent3\0" as *const u8 as *const libc::c_char;
            }
            4900 => {
                name = b"mhpmevent4\0" as *const u8 as *const libc::c_char;
            }
            4901 => {
                name = b"mhpmevent5\0" as *const u8 as *const libc::c_char;
            }
            4902 => {
                name = b"mhpmevent6\0" as *const u8 as *const libc::c_char;
            }
            4903 => {
                name = b"mhpmevent7\0" as *const u8 as *const libc::c_char;
            }
            4904 => {
                name = b"mhpmevent8\0" as *const u8 as *const libc::c_char;
            }
            4905 => {
                name = b"mhpmevent9\0" as *const u8 as *const libc::c_char;
            }
            4906 => {
                name = b"mhpmevent10\0" as *const u8 as *const libc::c_char;
            }
            4907 => {
                name = b"mhpmevent11\0" as *const u8 as *const libc::c_char;
            }
            4908 => {
                name = b"mhpmevent12\0" as *const u8 as *const libc::c_char;
            }
            4909 => {
                name = b"mhpmevent13\0" as *const u8 as *const libc::c_char;
            }
            4910 => {
                name = b"mhpmevent14\0" as *const u8 as *const libc::c_char;
            }
            4911 => {
                name = b"mhpmevent15\0" as *const u8 as *const libc::c_char;
            }
            4912 => {
                name = b"mhpmevent16\0" as *const u8 as *const libc::c_char;
            }
            4913 => {
                name = b"mhpmevent17\0" as *const u8 as *const libc::c_char;
            }
            4914 => {
                name = b"mhpmevent18\0" as *const u8 as *const libc::c_char;
            }
            4915 => {
                name = b"mhpmevent19\0" as *const u8 as *const libc::c_char;
            }
            4916 => {
                name = b"mhpmevent20\0" as *const u8 as *const libc::c_char;
            }
            4917 => {
                name = b"mhpmevent21\0" as *const u8 as *const libc::c_char;
            }
            4918 => {
                name = b"mhpmevent22\0" as *const u8 as *const libc::c_char;
            }
            4919 => {
                name = b"mhpmevent23\0" as *const u8 as *const libc::c_char;
            }
            4920 => {
                name = b"mhpmevent24\0" as *const u8 as *const libc::c_char;
            }
            4921 => {
                name = b"mhpmevent25\0" as *const u8 as *const libc::c_char;
            }
            4922 => {
                name = b"mhpmevent26\0" as *const u8 as *const libc::c_char;
            }
            4923 => {
                name = b"mhpmevent27\0" as *const u8 as *const libc::c_char;
            }
            4924 => {
                name = b"mhpmevent28\0" as *const u8 as *const libc::c_char;
            }
            4925 => {
                name = b"mhpmevent29\0" as *const u8 as *const libc::c_char;
            }
            4926 => {
                name = b"mhpmevent30\0" as *const u8 as *const libc::c_char;
            }
            4927 => {
                name = b"mhpmevent31\0" as *const u8 as *const libc::c_char;
            }
            4608 => {
                name = b"hstatus\0" as *const u8 as *const libc::c_char;
            }
            4610 => {
                name = b"hedeleg\0" as *const u8 as *const libc::c_char;
            }
            4611 => {
                name = b"hideleg\0" as *const u8 as *const libc::c_char;
            }
            4612 => {
                name = b"hie\0" as *const u8 as *const libc::c_char;
            }
            4613 => {
                name = b"htvec\0" as *const u8 as *const libc::c_char;
            }
            4672 => {
                name = b"hscratch\0" as *const u8 as *const libc::c_char;
            }
            4673 => {
                name = b"hepc\0" as *const u8 as *const libc::c_char;
            }
            4674 => {
                name = b"hcause\0" as *const u8 as *const libc::c_char;
            }
            4675 => {
                name = b"hbadaddr\0" as *const u8 as *const libc::c_char;
            }
            4676 => {
                name = b"hip\0" as *const u8 as *const libc::c_char;
            }
            4992 => {
                name = b"mbase\0" as *const u8 as *const libc::c_char;
            }
            4993 => {
                name = b"mbound\0" as *const u8 as *const libc::c_char;
            }
            4994 => {
                name = b"mibase\0" as *const u8 as *const libc::c_char;
            }
            4995 => {
                name = b"mibound\0" as *const u8 as *const libc::c_char;
            }
            4996 => {
                name = b"mdbase\0" as *const u8 as *const libc::c_char;
            }
            4997 => {
                name = b"mdbound\0" as *const u8 as *const libc::c_char;
            }
            4897 => {
                name = b"mscounteren\0" as *const u8 as *const libc::c_char;
            }
            4898 => {
                name = b"mhcounteren\0" as *const u8 as *const libc::c_char;
            }
            4097 => {
                name = b"fflags\0" as *const u8 as *const libc::c_char;
            }
            4098 => {
                name = b"frm\0" as *const u8 as *const libc::c_char;
            }
            4099 => {
                name = b"fcsr\0" as *const u8 as *const libc::c_char;
            }
            6064 => {
                name = b"dcsr\0" as *const u8 as *const libc::c_char;
            }
            6065 => {
                name = b"dpc\0" as *const u8 as *const libc::c_char;
            }
            6066 => {
                name = b"dscratch0\0" as *const u8 as *const libc::c_char;
            }
            6067 => {
                name = b"dscratch1\0" as *const u8 as *const libc::c_char;
            }
            6048 => {
                name = b"tselect\0" as *const u8 as *const libc::c_char;
            }
            6049 => {
                name = b"tdata1\0" as *const u8 as *const libc::c_char;
            }
            6050 => {
                name = b"tdata2\0" as *const u8 as *const libc::c_char;
            }
            6051 => {
                name = b"tdata3\0" as *const u8 as *const libc::c_char;
            }
            6052 => {
                name = b"tinfo\0" as *const u8 as *const libc::c_char;
            }
            6053 => {
                name = b"tcontrol\0" as *const u8 as *const libc::c_char;
            }
            6056 => {
                name = b"mcontext\0" as *const u8 as *const libc::c_char;
            }
            6058 => {
                name = b"scontext\0" as *const u8 as *const libc::c_char;
            }
            _ => {
                static mut csr_name: [libc::c_char; 10] = [0; 10];
                snprintf(
                    csr_name.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong,
                    b"csr%d\0" as *const u8 as *const libc::c_char,
                    regno.wrapping_sub(4096 as libc::c_int as libc::c_uint),
                );
                name = csr_name.as_mut_ptr();
            }
        }
    }
    return name;
}
unsafe extern "C" fn init_dwarf_regnames_riscv() {
    dwarf_regnames = 0 as *const *const libc::c_char;
    dwarf_regnames_count = 8192 as libc::c_int as libc::c_uint;
    dwarf_regnames_lookup_func = Some(
        regname_internal_riscv
            as unsafe extern "C" fn(libc::c_uint) -> *const libc::c_char,
    );
}
unsafe extern "C" fn frame_display_row(
    mut fc: *mut Frame_Chunk,
    mut need_col_headers: *mut libc::c_int,
    mut max_regs: *mut libc::c_uint,
) {
    let mut r: libc::c_uint = 0;
    let mut tmp: [libc::c_char; 100] = [0; 100];
    if *max_regs != (*fc).ncols {
        *max_regs = (*fc).ncols;
    }
    if *need_col_headers != 0 {
        *need_col_headers = 0 as libc::c_int;
        printf(
            b"%-*s CFA      \0" as *const u8 as *const libc::c_char,
            eh_addr_size.wrapping_mul(2 as libc::c_int as libc::c_uint),
            b"   LOC\0" as *const u8 as *const libc::c_char,
        );
        r = 0 as libc::c_int as libc::c_uint;
        while r < *max_regs {
            if *((*fc).col_type).offset(r as isize) as libc::c_int != -(1 as libc::c_int)
            {
                if r == (*fc).ra {
                    printf(b"ra    \0" as *const u8 as *const libc::c_char);
                } else {
                    printf(
                        b"%-5s \0" as *const u8 as *const libc::c_char,
                        regname(r, 1 as libc::c_int),
                    );
                }
            }
            r = r.wrapping_add(1);
            r;
        }
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    print_dwarf_vma((*fc).pc_begin, eh_addr_size);
    if (*fc).cfa_exp != 0 {
        strcpy(tmp.as_mut_ptr(), b"exp\0" as *const u8 as *const libc::c_char);
    } else {
        sprintf(
            tmp.as_mut_ptr(),
            b"%s%+d\0" as *const u8 as *const libc::c_char,
            regname((*fc).cfa_reg, 1 as libc::c_int),
            (*fc).cfa_offset as libc::c_int,
        );
    }
    printf(b"%-8s \0" as *const u8 as *const libc::c_char, tmp.as_mut_ptr());
    r = 0 as libc::c_int as libc::c_uint;
    while r < (*fc).ncols {
        if *((*fc).col_type).offset(r as isize) as libc::c_int != -(1 as libc::c_int) {
            match *((*fc).col_type).offset(r as isize) as libc::c_int {
                7 => {
                    strcpy(tmp.as_mut_ptr(), b"u\0" as *const u8 as *const libc::c_char);
                }
                8 => {
                    strcpy(tmp.as_mut_ptr(), b"s\0" as *const u8 as *const libc::c_char);
                }
                128 => {
                    sprintf(
                        tmp.as_mut_ptr(),
                        b"c%+d\0" as *const u8 as *const libc::c_char,
                        *((*fc).col_offset).offset(r as isize),
                    );
                }
                20 => {
                    sprintf(
                        tmp.as_mut_ptr(),
                        b"v%+d\0" as *const u8 as *const libc::c_char,
                        *((*fc).col_offset).offset(r as isize),
                    );
                }
                9 => {
                    sprintf(
                        tmp.as_mut_ptr(),
                        b"%s\0" as *const u8 as *const libc::c_char,
                        regname(
                            *((*fc).col_offset).offset(r as isize) as libc::c_uint,
                            0 as libc::c_int,
                        ),
                    );
                }
                16 => {
                    strcpy(
                        tmp.as_mut_ptr(),
                        b"exp\0" as *const u8 as *const libc::c_char,
                    );
                }
                22 => {
                    strcpy(
                        tmp.as_mut_ptr(),
                        b"vexp\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {
                    strcpy(
                        tmp.as_mut_ptr(),
                        b"n/a\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            printf(b"%-5s \0" as *const u8 as *const libc::c_char, tmp.as_mut_ptr());
        }
        r = r.wrapping_add(1);
        r;
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn read_cie(
    mut start: *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
    mut p_cie: *mut *mut Frame_Chunk,
    mut p_version: *mut libc::c_int,
    mut p_aug_len: *mut bfd_size_type,
    mut p_aug: *mut *mut libc::c_uchar,
) -> *mut libc::c_uchar {
    let mut current_block: u64;
    let mut version: libc::c_int = 0;
    let mut fc: *mut Frame_Chunk = 0 as *mut Frame_Chunk;
    let mut augmentation_data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut augmentation_data_len: bfd_size_type = 0 as libc::c_int as bfd_size_type;
    *p_cie = 0 as *mut Frame_Chunk;
    if start >= end {
        return end;
    }
    fc = xmalloc(::core::mem::size_of::<Frame_Chunk>() as libc::c_ulong)
        as *mut Frame_Chunk;
    memset(
        fc as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Frame_Chunk>() as libc::c_ulong,
    );
    (*fc)
        .col_type = xmalloc(::core::mem::size_of::<libc::c_short>() as libc::c_ulong)
        as *mut libc::c_short;
    (*fc)
        .col_offset = xmalloc(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
        as *mut libc::c_int;
    let fresh29 = start;
    start = start.offset(1);
    version = *fresh29 as libc::c_int;
    (*fc).augmentation = start as *mut libc::c_char;
    while start < end {
        let fresh30 = start;
        start = start.offset(1);
        if *fresh30 as libc::c_int == '\0' as i32 {
            break;
        }
    }
    if start == end {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"No terminator for augmentation name\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    } else {
        if strcmp((*fc).augmentation, b"eh\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            if eh_addr_size as libc::c_ulong
                > end.offset_from(start) as libc::c_long as size_t
            {
                current_block = 853552618433832358;
            } else {
                start = start.offset(eh_addr_size as isize);
                current_block = 12599329904712511516;
            }
        } else {
            current_block = 12599329904712511516;
        }
        match current_block {
            853552618433832358 => {}
            _ => {
                if version >= 4 as libc::c_int {
                    if 2 as libc::c_int as libc::c_ulong
                        > end.offset_from(start) as libc::c_long as size_t
                    {
                        current_block = 853552618433832358;
                    } else {
                        let mut amount: size_t = 1 as libc::c_int as size_t;
                        if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
                            < amount
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount,
                                    5 as libc::c_int,
                                ),
                                amount as libc::c_int,
                                ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount = ::core::mem::size_of::<libc::c_uchar>()
                                as libc::c_ulong;
                        }
                        let mut avail: size_t = end.offset_from(start) as libc::c_long
                            as size_t;
                        if start > end {
                            avail = 0 as libc::c_int as size_t;
                        }
                        if amount > avail {
                            amount = avail;
                        }
                        if amount == 0 as libc::c_int as libc::c_ulong {
                            (*fc).ptr_size = 0 as libc::c_int as libc::c_uchar;
                        } else {
                            (*fc)
                                .ptr_size = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(start, amount as libc::c_uint) as libc::c_uchar;
                        }
                        start = start.offset(amount as isize);
                        if ((*fc).ptr_size as libc::c_int) < 1 as libc::c_int
                            || (*fc).ptr_size as libc::c_int > 8 as libc::c_int
                        {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Invalid pointer size (%d) in CIE data\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                (*fc).ptr_size as libc::c_int,
                            );
                            current_block = 853552618433832358;
                        } else {
                            let mut amount_0: size_t = 1 as libc::c_int as size_t;
                            if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
                                < amount_0
                            {
                                error(
                                    dcngettext(
                                        0 as *const libc::c_char,
                                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        amount_0,
                                        5 as libc::c_int,
                                    ),
                                    amount_0 as libc::c_int,
                                    ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                                        as libc::c_int,
                                );
                                amount_0 = ::core::mem::size_of::<libc::c_uchar>()
                                    as libc::c_ulong;
                            }
                            let mut avail_0: size_t = end.offset_from(start)
                                as libc::c_long as size_t;
                            if start > end {
                                avail_0 = 0 as libc::c_int as size_t;
                            }
                            if amount_0 > avail_0 {
                                amount_0 = avail_0;
                            }
                            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                                (*fc).segment_size = 0 as libc::c_int as libc::c_uchar;
                            } else {
                                (*fc)
                                    .segment_size = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(start, amount_0 as libc::c_uint) as libc::c_uchar;
                            }
                            start = start.offset(amount_0 as isize);
                            if (*fc).segment_size as libc::c_int > 8 as libc::c_int
                                || (*fc).segment_size as libc::c_int
                                    + (*fc).ptr_size as libc::c_int > 8 as libc::c_int
                            {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Invalid segment size (%d) in CIE data\n\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    (*fc).segment_size as libc::c_int,
                                );
                                current_block = 853552618433832358;
                            } else {
                                eh_addr_size = (*fc).ptr_size as libc::c_uint;
                                current_block = 5892776923941496671;
                            }
                        }
                    }
                } else {
                    (*fc).ptr_size = eh_addr_size as libc::c_uchar;
                    (*fc).segment_size = 0 as libc::c_int as libc::c_uchar;
                    current_block = 5892776923941496671;
                }
                match current_block {
                    853552618433832358 => {}
                    _ => {
                        let mut _val: dwarf_vma = 0;
                        let mut _len: libc::c_uint = 0;
                        let mut _status: libc::c_int = 0;
                        _val = read_leb128(
                            start,
                            end,
                            0 as libc::c_int != 0,
                            &mut _len,
                            &mut _status,
                        );
                        start = start.offset(_len as isize);
                        (*fc).code_factor = _val as libc::c_uint;
                        if (*fc).code_factor as libc::c_ulong != _val {
                            _status |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            8449 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_0: dwarf_signed_vma = 0;
                        let mut _len_0: libc::c_uint = 0;
                        let mut _status_0: libc::c_int = 0;
                        _val_0 = read_leb128(
                            start,
                            end,
                            1 as libc::c_int != 0,
                            &mut _len_0,
                            &mut _status_0,
                        ) as dwarf_signed_vma;
                        start = start.offset(_len_0 as isize);
                        (*fc).data_factor = _val_0 as libc::c_int;
                        if (*fc).data_factor as libc::c_long != _val_0 {
                            _status_0 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_0,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            8450 as libc::c_int as libc::c_ulong,
                        );
                        if !(start >= end) {
                            if version == 1 as libc::c_int {
                                let mut amount_1: size_t = 1 as libc::c_int as size_t;
                                if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                                    < amount_1
                                {
                                    error(
                                        dcngettext(
                                            0 as *const libc::c_char,
                                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            amount_1,
                                            5 as libc::c_int,
                                        ),
                                        amount_1 as libc::c_int,
                                        ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                            as libc::c_int,
                                    );
                                    amount_1 = ::core::mem::size_of::<libc::c_uint>()
                                        as libc::c_ulong;
                                }
                                let mut avail_1: size_t = end.offset_from(start)
                                    as libc::c_long as size_t;
                                if start > end {
                                    avail_1 = 0 as libc::c_int as size_t;
                                }
                                if amount_1 > avail_1 {
                                    amount_1 = avail_1;
                                }
                                if amount_1 == 0 as libc::c_int as libc::c_ulong {
                                    (*fc).ra = 0 as libc::c_int as libc::c_uint;
                                } else {
                                    (*fc)
                                        .ra = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(start, amount_1 as libc::c_uint) as libc::c_uint;
                                }
                                start = start.offset(amount_1 as isize);
                            } else {
                                let mut _val_1: dwarf_vma = 0;
                                let mut _len_1: libc::c_uint = 0;
                                let mut _status_1: libc::c_int = 0;
                                _val_1 = read_leb128(
                                    start,
                                    end,
                                    0 as libc::c_int != 0,
                                    &mut _len_1,
                                    &mut _status_1,
                                );
                                start = start.offset(_len_1 as isize);
                                (*fc).ra = _val_1 as libc::c_uint;
                                if (*fc).ra as libc::c_ulong != _val_1 {
                                    _status_1 |= 2 as libc::c_int;
                                }
                                report_leb_status(
                                    _status_1,
                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                    8461 as libc::c_int as libc::c_ulong,
                                );
                            }
                            if *((*fc).augmentation).offset(0 as libc::c_int as isize)
                                as libc::c_int == 'z' as i32
                            {
                                if start >= end {
                                    current_block = 853552618433832358;
                                } else {
                                    let mut _val_2: dwarf_vma = 0;
                                    let mut _len_2: libc::c_uint = 0;
                                    let mut _status_2: libc::c_int = 0;
                                    _val_2 = read_leb128(
                                        start,
                                        end,
                                        0 as libc::c_int != 0,
                                        &mut _len_2,
                                        &mut _status_2,
                                    );
                                    start = start.offset(_len_2 as isize);
                                    augmentation_data_len = _val_2;
                                    if augmentation_data_len != _val_2 {
                                        _status_2 |= 2 as libc::c_int;
                                    }
                                    report_leb_status(
                                        _status_2,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        8468 as libc::c_int as libc::c_ulong,
                                    );
                                    augmentation_data = start;
                                    if augmentation_data_len
                                        > end.offset_from(start) as libc::c_long as bfd_size_type
                                    {
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"Augmentation data too long: 0x%s, expected at most %#lx\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            dwarf_vmatoa(
                                                b"x\0" as *const u8 as *const libc::c_char,
                                                augmentation_data_len,
                                            ),
                                            end.offset_from(start) as libc::c_long as libc::c_ulong,
                                        );
                                        current_block = 853552618433832358;
                                    } else {
                                        start = start.offset(augmentation_data_len as isize);
                                        current_block = 2904036176499606090;
                                    }
                                }
                            } else {
                                current_block = 2904036176499606090;
                            }
                            match current_block {
                                853552618433832358 => {}
                                _ => {
                                    if augmentation_data_len != 0 {
                                        let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                                        let mut q: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                                        let mut qend: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                                        p = ((*fc).augmentation as *mut libc::c_uchar)
                                            .offset(1 as libc::c_int as isize);
                                        q = augmentation_data;
                                        qend = q.offset(augmentation_data_len as isize);
                                        while p < end && q < qend {
                                            if *p as libc::c_int == 'L' as i32 {
                                                q = q.offset(1);
                                                q;
                                            } else if *p as libc::c_int == 'P' as i32 {
                                                q = q
                                                    .offset(
                                                        (1 as libc::c_int as libc::c_uint)
                                                            .wrapping_add(size_of_encoded_value(*q as libc::c_int))
                                                            as isize,
                                                    );
                                            } else if *p as libc::c_int == 'R' as i32 {
                                                let fresh31 = q;
                                                q = q.offset(1);
                                                (*fc).fde_encoding = *fresh31;
                                            } else if !(*p as libc::c_int == 'S' as i32) {
                                                if !(*p as libc::c_int == 'B' as i32) {
                                                    break;
                                                }
                                            }
                                            p = p.offset(1);
                                            p;
                                        }
                                    }
                                    *p_cie = fc;
                                    if !p_version.is_null() {
                                        *p_version = version;
                                    }
                                    if !p_aug_len.is_null() {
                                        *p_aug_len = augmentation_data_len;
                                        *p_aug = augmentation_data;
                                    }
                                    return start;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    free((*fc).col_offset as *mut libc::c_void);
    free((*fc).col_type as *mut libc::c_void);
    free(fc as *mut libc::c_void);
    return end;
}
unsafe extern "C" fn display_data(
    mut printed: bfd_size_type,
    mut data: *const libc::c_uchar,
    len: bfd_size_type,
) {
    if do_wide != 0
        || len
            < (80 as libc::c_int as libc::c_ulong)
                .wrapping_sub(printed)
                .wrapping_div(3 as libc::c_int as libc::c_ulong)
    {
        printed = 0 as libc::c_int as bfd_size_type;
        while printed < len {
            printf(
                b" %02x\0" as *const u8 as *const libc::c_char,
                *data.offset(printed as isize) as libc::c_int,
            );
            printed = printed.wrapping_add(1);
            printed;
        }
    } else {
        printed = 0 as libc::c_int as bfd_size_type;
        while printed < len {
            if printed
                .wrapping_rem((80 as libc::c_int / 3 as libc::c_int) as libc::c_ulong)
                == 0 as libc::c_int as libc::c_ulong
            {
                putchar('\n' as i32);
            }
            printf(
                b" %02x\0" as *const u8 as *const libc::c_char,
                *data.offset(printed as isize) as libc::c_int,
            );
            printed = printed.wrapping_add(1);
            printed;
        }
    };
}
unsafe extern "C" fn display_augmentation_data(
    mut data: *const libc::c_uchar,
    len: bfd_size_type,
) {
    let mut i: bfd_size_type = 0;
    i = printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Augmentation data:    \0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    ) as bfd_size_type;
    display_data(i, data, len);
}
unsafe extern "C" fn display_debug_frames(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut end: *mut libc::c_uchar = start.offset((*section).size as isize);
    let mut section_start: *mut libc::c_uchar = start;
    let mut chunks: *mut Frame_Chunk = 0 as *mut Frame_Chunk;
    let mut forward_refs: *mut Frame_Chunk = 0 as *mut Frame_Chunk;
    let mut remembered_state: *mut Frame_Chunk = 0 as *mut Frame_Chunk;
    let mut rs: *mut Frame_Chunk = 0 as *mut Frame_Chunk;
    let mut is_eh: bool = strcmp(
        (*section).name,
        b".eh_frame\0" as *const u8 as *const libc::c_char,
    ) == 0 as libc::c_int;
    let mut max_regs: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut bad_reg: *const libc::c_char = dcgettext(
        0 as *const libc::c_char,
        b"bad register: \0" as *const u8 as *const libc::c_char,
        5 as libc::c_int,
    );
    let mut saved_eh_addr_size: libc::c_uint = eh_addr_size;
    introduce(section, 0 as libc::c_int != 0);
    while start < end {
        let mut saved_start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut block_end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut length: dwarf_vma = 0;
        let mut cie_id: dwarf_vma = 0;
        let mut fc: *mut Frame_Chunk = 0 as *mut Frame_Chunk;
        let mut cie: *mut Frame_Chunk = 0 as *mut Frame_Chunk;
        let mut need_col_headers: libc::c_int = 1 as libc::c_int;
        let mut augmentation_data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut augmentation_data_len: bfd_size_type = 0 as libc::c_int as bfd_size_type;
        let mut encoded_ptr_size: libc::c_uint = saved_eh_addr_size;
        let mut offset_size: libc::c_uint = 0;
        let mut all_nops: bool = false;
        static mut fde_fc: Frame_Chunk = Frame_Chunk {
            next: 0 as *const Frame_Chunk as *mut Frame_Chunk,
            chunk_start: 0 as *const libc::c_uchar as *mut libc::c_uchar,
            ncols: 0,
            col_type: 0 as *const libc::c_short as *mut libc::c_short,
            col_offset: 0 as *const libc::c_int as *mut libc::c_int,
            augmentation: 0 as *const libc::c_char as *mut libc::c_char,
            code_factor: 0,
            data_factor: 0,
            pc_begin: 0,
            pc_range: 0,
            cfa_reg: 0,
            cfa_offset: 0,
            ra: 0,
            fde_encoding: 0,
            cfa_exp: 0,
            ptr_size: 0,
            segment_size: 0,
        };
        saved_start = start;
        let mut amount: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = end.offset_from(start) as libc::c_long as size_t;
        if start > end {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            length = 0 as libc::c_int as dwarf_vma;
        } else {
            length = byte_get
                .expect("non-null function pointer")(start, amount as libc::c_uint);
        }
        start = start.offset(amount as isize);
        if length == 0 as libc::c_int as libc::c_ulong {
            printf(
                b"\n%08lx ZERO terminator\n\n\0" as *const u8 as *const libc::c_char,
                saved_start.offset_from(section_start) as libc::c_long as libc::c_ulong,
            );
            while start < end && *start as libc::c_int == 0 as libc::c_int {
                start = start.offset(1);
                start;
            }
        } else {
            if length == 0xffffffff as libc::c_uint as libc::c_ulong {
                let mut amount_0: size_t = 8 as libc::c_int as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_0,
                            5 as libc::c_int,
                        ),
                        amount_0 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_0: size_t = end.offset_from(start) as libc::c_long
                    as size_t;
                if start > end {
                    avail_0 = 0 as libc::c_int as size_t;
                }
                if amount_0 > avail_0 {
                    amount_0 = avail_0;
                }
                if amount_0 == 0 as libc::c_int as libc::c_ulong {
                    length = 0 as libc::c_int as dwarf_vma;
                } else {
                    length = byte_get
                        .expect(
                            "non-null function pointer",
                        )(start, amount_0 as libc::c_uint);
                }
                start = start.offset(amount_0 as isize);
                offset_size = 8 as libc::c_int as libc::c_uint;
            } else {
                offset_size = 4 as libc::c_int as libc::c_uint;
            }
            if length > end.offset_from(start) as libc::c_long as size_t {
                warn(
                    b"Invalid length 0x%s in FDE at %#08lx\n\0" as *const u8
                        as *const libc::c_char,
                    dwarf_vmatoa_1(0 as *const libc::c_char, length, offset_size),
                    saved_start.offset_from(section_start) as libc::c_long
                        as libc::c_ulong,
                );
                block_end = end;
            } else {
                block_end = start.offset(length as isize);
            }
            let mut amount_1: size_t = offset_size as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_1: size_t = block_end.offset_from(start) as libc::c_long
                as size_t;
            if start > block_end {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                cie_id = 0 as libc::c_int as dwarf_vma;
            } else {
                cie_id = byte_get
                    .expect(
                        "non-null function pointer",
                    )(start, amount_1 as libc::c_uint);
            }
            start = start.offset(amount_1 as isize);
            if if is_eh as libc::c_int != 0 {
                (cie_id == 0 as libc::c_int as libc::c_ulong) as libc::c_int
            } else {
                (offset_size == 4 as libc::c_int as libc::c_uint
                    && cie_id == 0xffffffff as libc::c_uint as libc::c_ulong
                    || offset_size == 8 as libc::c_int as libc::c_uint
                        && cie_id as libc::c_ulonglong
                            == 0xffffffffffffffff as libc::c_ulonglong) as libc::c_int
            } != 0
            {
                let mut version: libc::c_int = 0;
                let mut mreg: libc::c_uint = 0;
                start = read_cie(
                    start,
                    block_end,
                    &mut cie,
                    &mut version,
                    &mut augmentation_data_len,
                    &mut augmentation_data,
                );
                if cie.is_null() {
                    break;
                }
                fc = cie;
                (*fc).next = chunks;
                chunks = fc;
                (*fc).chunk_start = saved_start;
                mreg = if max_regs > 0 as libc::c_int as libc::c_uint {
                    max_regs.wrapping_sub(1 as libc::c_int as libc::c_uint)
                } else {
                    0 as libc::c_int as libc::c_uint
                };
                if mreg < (*fc).ra {
                    mreg = (*fc).ra;
                }
                if frame_need_space(fc, mreg) < 0 as libc::c_int {
                    break;
                }
                if (*fc).fde_encoding != 0 {
                    encoded_ptr_size = size_of_encoded_value(
                        (*fc).fde_encoding as libc::c_int,
                    );
                }
                printf(
                    b"\n%08lx \0" as *const u8 as *const libc::c_char,
                    saved_start.offset_from(section_start) as libc::c_long
                        as libc::c_ulong,
                );
                print_dwarf_vma(length, (*fc).ptr_size as libc::c_uint);
                print_dwarf_vma(cie_id, offset_size);
                if do_debug_frames_interp != 0 {
                    printf(
                        b"CIE \"%s\" cf=%d df=%d ra=%d\n\0" as *const u8
                            as *const libc::c_char,
                        (*fc).augmentation,
                        (*fc).code_factor,
                        (*fc).data_factor,
                        (*fc).ra,
                    );
                } else {
                    printf(b"CIE\n\0" as *const u8 as *const libc::c_char);
                    printf(
                        b"  Version:               %d\n\0" as *const u8
                            as *const libc::c_char,
                        version,
                    );
                    printf(
                        b"  Augmentation:          \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        (*fc).augmentation,
                    );
                    if version >= 4 as libc::c_int {
                        printf(
                            b"  Pointer Size:          %u\n\0" as *const u8
                                as *const libc::c_char,
                            (*fc).ptr_size as libc::c_int,
                        );
                        printf(
                            b"  Segment Size:          %u\n\0" as *const u8
                                as *const libc::c_char,
                            (*fc).segment_size as libc::c_int,
                        );
                    }
                    printf(
                        b"  Code alignment factor: %u\n\0" as *const u8
                            as *const libc::c_char,
                        (*fc).code_factor,
                    );
                    printf(
                        b"  Data alignment factor: %d\n\0" as *const u8
                            as *const libc::c_char,
                        (*fc).data_factor,
                    );
                    printf(
                        b"  Return address column: %d\n\0" as *const u8
                            as *const libc::c_char,
                        (*fc).ra,
                    );
                    if augmentation_data_len != 0 {
                        display_augmentation_data(
                            augmentation_data,
                            augmentation_data_len,
                        );
                    }
                    putchar('\n' as i32);
                }
            } else {
                let mut look_for: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                let mut segment_selector: libc::c_ulong = 0;
                let mut cie_off: dwarf_vma = 0;
                cie_off = cie_id;
                if is_eh {
                    let mut sign: dwarf_vma = (1 as libc::c_int as dwarf_vma)
                        << offset_size
                            .wrapping_mul(8 as libc::c_int as libc::c_uint)
                            .wrapping_sub(1 as libc::c_int as libc::c_uint);
                    cie_off = (cie_off ^ sign).wrapping_sub(sign);
                    cie_off = (start
                        .offset(-(4 as libc::c_int as isize))
                        .offset_from(section_start) as libc::c_long as libc::c_ulong)
                        .wrapping_sub(cie_off);
                }
                look_for = section_start.offset(cie_off as isize);
                if cie_off
                    <= saved_start.offset_from(section_start) as libc::c_long
                        as dwarf_vma
                {
                    cie = chunks;
                    while !cie.is_null() {
                        if (*cie).chunk_start == look_for {
                            break;
                        }
                        cie = (*cie).next;
                    }
                } else if cie_off >= (*section).size {
                    cie = 0 as *mut Frame_Chunk;
                } else {
                    cie = forward_refs;
                    while !cie.is_null() {
                        if (*cie).chunk_start == look_for {
                            break;
                        }
                        cie = (*cie).next;
                    }
                    if cie.is_null() {
                        let mut off_size: libc::c_uint = 0;
                        let mut cie_scan: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                        cie_scan = look_for;
                        off_size = 4 as libc::c_int as libc::c_uint;
                        let mut amount_2: size_t = 4 as libc::c_int as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_2
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_2,
                                    5 as libc::c_int,
                                ),
                                amount_2 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_2 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_2: size_t = end.offset_from(cie_scan)
                            as libc::c_long as size_t;
                        if cie_scan > end {
                            avail_2 = 0 as libc::c_int as size_t;
                        }
                        if amount_2 > avail_2 {
                            amount_2 = avail_2;
                        }
                        if amount_2 == 0 as libc::c_int as libc::c_ulong {
                            length = 0 as libc::c_int as dwarf_vma;
                        } else {
                            length = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(cie_scan, amount_2 as libc::c_uint);
                        }
                        cie_scan = cie_scan.offset(amount_2 as isize);
                        if length == 0xffffffff as libc::c_uint as libc::c_ulong {
                            let mut amount_3: size_t = 8 as libc::c_int as size_t;
                            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                                < amount_3
                            {
                                error(
                                    dcngettext(
                                        0 as *const libc::c_char,
                                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        amount_3,
                                        5 as libc::c_int,
                                    ),
                                    amount_3 as libc::c_int,
                                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                        as libc::c_int,
                                );
                                amount_3 = ::core::mem::size_of::<dwarf_vma>()
                                    as libc::c_ulong;
                            }
                            let mut avail_3: size_t = end.offset_from(cie_scan)
                                as libc::c_long as size_t;
                            if cie_scan > end {
                                avail_3 = 0 as libc::c_int as size_t;
                            }
                            if amount_3 > avail_3 {
                                amount_3 = avail_3;
                            }
                            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                                length = 0 as libc::c_int as dwarf_vma;
                            } else {
                                length = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(cie_scan, amount_3 as libc::c_uint);
                            }
                            cie_scan = cie_scan.offset(amount_3 as isize);
                            off_size = 8 as libc::c_int as libc::c_uint;
                        }
                        if length != 0 as libc::c_int as libc::c_ulong
                            && length
                                <= end.offset_from(cie_scan) as libc::c_long as size_t
                        {
                            let mut c_id: dwarf_vma = 0;
                            let mut cie_end: *mut libc::c_uchar = cie_scan
                                .offset(length as isize);
                            let mut amount_4: size_t = off_size as size_t;
                            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                                < amount_4
                            {
                                error(
                                    dcngettext(
                                        0 as *const libc::c_char,
                                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        amount_4,
                                        5 as libc::c_int,
                                    ),
                                    amount_4 as libc::c_int,
                                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                        as libc::c_int,
                                );
                                amount_4 = ::core::mem::size_of::<dwarf_vma>()
                                    as libc::c_ulong;
                            }
                            let mut avail_4: size_t = cie_end.offset_from(cie_scan)
                                as libc::c_long as size_t;
                            if cie_scan > cie_end {
                                avail_4 = 0 as libc::c_int as size_t;
                            }
                            if amount_4 > avail_4 {
                                amount_4 = avail_4;
                            }
                            if amount_4 == 0 as libc::c_int as libc::c_ulong {
                                c_id = 0 as libc::c_int as dwarf_vma;
                            } else {
                                c_id = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(cie_scan, amount_4 as libc::c_uint);
                            }
                            cie_scan = cie_scan.offset(amount_4 as isize);
                            if if is_eh as libc::c_int != 0 {
                                (c_id == 0 as libc::c_int as libc::c_ulong) as libc::c_int
                            } else {
                                (off_size == 4 as libc::c_int as libc::c_uint
                                    && c_id == 0xffffffff as libc::c_uint as libc::c_ulong
                                    || off_size == 8 as libc::c_int as libc::c_uint
                                        && c_id as libc::c_ulonglong
                                            == 0xffffffffffffffff as libc::c_ulonglong) as libc::c_int
                            } != 0
                            {
                                let mut version_0: libc::c_int = 0;
                                let mut mreg_0: libc::c_uint = 0;
                                read_cie(
                                    cie_scan,
                                    cie_end,
                                    &mut cie,
                                    &mut version_0,
                                    &mut augmentation_data_len,
                                    &mut augmentation_data,
                                );
                                if cie.is_null() {
                                    warn(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b"Failed to read CIE information\n\0" as *const u8
                                                as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                    break;
                                } else {
                                    (*cie).next = forward_refs;
                                    forward_refs = cie;
                                    (*cie).chunk_start = look_for;
                                    mreg_0 = if max_regs > 0 as libc::c_int as libc::c_uint {
                                        max_regs.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                    } else {
                                        0 as libc::c_int as libc::c_uint
                                    };
                                    if mreg_0 < (*cie).ra {
                                        mreg_0 = (*cie).ra;
                                    }
                                    if frame_need_space(cie, mreg_0) < 0 as libc::c_int {
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"Invalid max register\n\0" as *const u8
                                                    as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                        );
                                        break;
                                    } else if (*cie).fde_encoding != 0 {
                                        encoded_ptr_size = size_of_encoded_value(
                                            (*cie).fde_encoding as libc::c_int,
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
                fc = &mut fde_fc;
                memset(
                    fc as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<Frame_Chunk>() as libc::c_ulong,
                );
                if cie.is_null() {
                    warn(
                        b"Invalid CIE pointer 0x%s in FDE at %#08lx\n\0" as *const u8
                            as *const libc::c_char,
                        dwarf_vmatoa_1(0 as *const libc::c_char, cie_id, offset_size),
                        saved_start.offset_from(section_start) as libc::c_long
                            as libc::c_ulong,
                    );
                    (*fc).ncols = 0 as libc::c_int as libc::c_uint;
                    (*fc)
                        .col_type = xmalloc(
                        ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                    ) as *mut libc::c_short;
                    (*fc)
                        .col_offset = xmalloc(
                        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                    ) as *mut libc::c_int;
                    if frame_need_space(
                        fc,
                        if max_regs > 0 as libc::c_int as libc::c_uint {
                            max_regs.wrapping_sub(1 as libc::c_int as libc::c_uint)
                        } else {
                            0 as libc::c_int as libc::c_uint
                        },
                    ) < 0 as libc::c_int
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Invalid max register\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        break;
                    } else {
                        cie = fc;
                        (*fc)
                            .augmentation = b"\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                        (*fc).fde_encoding = 0 as libc::c_int as libc::c_uchar;
                        (*fc).ptr_size = eh_addr_size as libc::c_uchar;
                        (*fc).segment_size = 0 as libc::c_int as libc::c_uchar;
                    }
                } else {
                    (*fc).ncols = (*cie).ncols;
                    (*fc)
                        .col_type = xcmalloc(
                        (*fc).ncols as size_t,
                        ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                    ) as *mut libc::c_short;
                    (*fc)
                        .col_offset = xcmalloc(
                        (*fc).ncols as size_t,
                        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                    ) as *mut libc::c_int;
                    memcpy(
                        (*fc).col_type as *mut libc::c_void,
                        (*cie).col_type as *const libc::c_void,
                        ((*fc).ncols as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                            ),
                    );
                    memcpy(
                        (*fc).col_offset as *mut libc::c_void,
                        (*cie).col_offset as *const libc::c_void,
                        ((*fc).ncols as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                            ),
                    );
                    (*fc).augmentation = (*cie).augmentation;
                    (*fc).ptr_size = (*cie).ptr_size;
                    eh_addr_size = (*cie).ptr_size as libc::c_uint;
                    (*fc).segment_size = (*cie).segment_size;
                    (*fc).code_factor = (*cie).code_factor;
                    (*fc).data_factor = (*cie).data_factor;
                    (*fc).cfa_reg = (*cie).cfa_reg;
                    (*fc).cfa_offset = (*cie).cfa_offset;
                    (*fc).ra = (*cie).ra;
                    if frame_need_space(
                        fc,
                        if max_regs > 0 as libc::c_int as libc::c_uint {
                            max_regs.wrapping_sub(1 as libc::c_int as libc::c_uint)
                        } else {
                            0 as libc::c_int as libc::c_uint
                        },
                    ) < 0 as libc::c_int
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Invalid max register\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        break;
                    } else {
                        (*fc).fde_encoding = (*cie).fde_encoding;
                    }
                }
                if (*fc).fde_encoding != 0 {
                    encoded_ptr_size = size_of_encoded_value(
                        (*fc).fde_encoding as libc::c_int,
                    );
                }
                segment_selector = 0 as libc::c_int as libc::c_ulong;
                if (*fc).segment_size != 0 {
                    if (*fc).segment_size as libc::c_ulong
                        > ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Probably corrupt segment size: %d - using 4 instead\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*fc).segment_size as libc::c_int,
                        );
                        (*fc).segment_size = 4 as libc::c_int as libc::c_uchar;
                    }
                    let mut amount_5: size_t = (*fc).segment_size as size_t;
                    if (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)
                        < amount_5
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_5,
                                5 as libc::c_int,
                            ),
                            amount_5 as libc::c_int,
                            ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_5 = ::core::mem::size_of::<libc::c_ulong>()
                            as libc::c_ulong;
                    }
                    let mut avail_5: size_t = block_end.offset_from(start)
                        as libc::c_long as size_t;
                    if start > block_end {
                        avail_5 = 0 as libc::c_int as size_t;
                    }
                    if amount_5 > avail_5 {
                        amount_5 = avail_5;
                    }
                    if amount_5 == 0 as libc::c_int as libc::c_ulong {
                        segment_selector = 0 as libc::c_int as libc::c_ulong;
                    } else {
                        segment_selector = byte_get
                            .expect(
                                "non-null function pointer",
                            )(start, amount_5 as libc::c_uint);
                    }
                    start = start.offset(amount_5 as isize);
                }
                (*fc)
                    .pc_begin = get_encoded_value(
                    &mut start,
                    (*fc).fde_encoding as libc::c_int,
                    section,
                    block_end,
                );
                let mut amount_6: size_t = encoded_ptr_size as size_t;
                if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_6 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_6,
                            5 as libc::c_int,
                        ),
                        amount_6 as libc::c_int,
                        ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_6 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
                }
                let mut avail_6: size_t = block_end.offset_from(start) as libc::c_long
                    as size_t;
                if start > block_end {
                    avail_6 = 0 as libc::c_int as size_t;
                }
                if amount_6 > avail_6 {
                    amount_6 = avail_6;
                }
                if amount_6 == 0 as libc::c_int as libc::c_ulong {
                    (*fc).pc_range = 0 as libc::c_int as dwarf_vma;
                } else {
                    (*fc)
                        .pc_range = byte_get
                        .expect(
                            "non-null function pointer",
                        )(start, amount_6 as libc::c_uint);
                }
                start = start.offset(amount_6 as isize);
                if *((*cie).augmentation).offset(0 as libc::c_int as isize)
                    as libc::c_int == 'z' as i32
                {
                    let mut _val: dwarf_vma = 0;
                    let mut _len: libc::c_uint = 0;
                    let mut _status: libc::c_int = 0;
                    _val = read_leb128(
                        start,
                        block_end,
                        0 as libc::c_int != 0,
                        &mut _len,
                        &mut _status,
                    );
                    start = start.offset(_len as isize);
                    augmentation_data_len = _val;
                    if augmentation_data_len != _val {
                        _status |= 2 as libc::c_int;
                    }
                    report_leb_status(
                        _status,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        8844 as libc::c_int as libc::c_ulong,
                    );
                    augmentation_data = start;
                    if augmentation_data_len
                        > block_end.offset_from(start) as libc::c_long as bfd_size_type
                    {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Augmentation data too long: 0x%s, expected at most %#lx\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            dwarf_vmatoa(
                                b"x\0" as *const u8 as *const libc::c_char,
                                augmentation_data_len,
                            ),
                            block_end.offset_from(start) as libc::c_long as libc::c_ulong,
                        );
                        start = block_end;
                        augmentation_data = 0 as *mut libc::c_uchar;
                        augmentation_data_len = 0 as libc::c_int as bfd_size_type;
                    }
                    start = start.offset(augmentation_data_len as isize);
                }
                printf(
                    b"\n%08lx %s %s FDE cie=%08lx pc=\0" as *const u8
                        as *const libc::c_char,
                    saved_start.offset_from(section_start) as libc::c_long
                        as libc::c_ulong,
                    dwarf_vmatoa_1(
                        0 as *const libc::c_char,
                        length,
                        (*fc).ptr_size as libc::c_uint,
                    ),
                    dwarf_vmatoa_1(0 as *const libc::c_char, cie_id, offset_size),
                    ((*cie).chunk_start).offset_from(section_start) as libc::c_long
                        as libc::c_ulong,
                );
                if (*fc).segment_size != 0 {
                    printf(
                        b"%04lx:\0" as *const u8 as *const libc::c_char,
                        segment_selector,
                    );
                }
                printf(
                    b"%s..%s\n\0" as *const u8 as *const libc::c_char,
                    dwarf_vmatoa_1(
                        0 as *const libc::c_char,
                        (*fc).pc_begin,
                        (*fc).ptr_size as libc::c_uint,
                    ),
                    dwarf_vmatoa_1(
                        0 as *const libc::c_char,
                        ((*fc).pc_begin).wrapping_add((*fc).pc_range),
                        (*fc).ptr_size as libc::c_uint,
                    ),
                );
                if do_debug_frames_interp == 0 && augmentation_data_len != 0 {
                    display_augmentation_data(augmentation_data, augmentation_data_len);
                    putchar('\n' as i32);
                }
            }
            if 1 as libc::c_int != 0 || do_debug_frames_interp != 0 {
                let mut tmp: *mut libc::c_uchar = start;
                while start < block_end {
                    let mut reg: libc::c_uint = 0;
                    let mut op: libc::c_uint = 0;
                    let mut opa: libc::c_uint = 0;
                    let mut temp: libc::c_ulong = 0;
                    let fresh32 = start;
                    start = start.offset(1);
                    op = *fresh32 as libc::c_uint;
                    opa = op & 0x3f as libc::c_int as libc::c_uint;
                    if op & 0xc0 as libc::c_int as libc::c_uint != 0 {
                        op &= 0xc0 as libc::c_int as libc::c_uint;
                    }
                    match op {
                        128 => {
                            let mut _len_0: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_0,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_0 as isize);
                            if frame_need_space(fc, opa) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        opa as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        192 => {
                            if frame_need_space(fc, opa) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        opa as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        1 => {
                            if (block_end.offset_from(start) as libc::c_long as size_t)
                                < encoded_ptr_size as libc::c_ulong
                            {
                                start = block_end;
                            } else {
                                start = start.offset(encoded_ptr_size as isize);
                            }
                        }
                        2 => {
                            if (block_end.offset_from(start) as libc::c_long as size_t)
                                < 1 as libc::c_int as libc::c_ulong
                            {
                                start = block_end;
                            } else {
                                start = start.offset(1 as libc::c_int as isize);
                            }
                        }
                        3 => {
                            if (block_end.offset_from(start) as libc::c_long as size_t)
                                < 2 as libc::c_int as libc::c_ulong
                            {
                                start = block_end;
                            } else {
                                start = start.offset(2 as libc::c_int as isize);
                            }
                        }
                        4 => {
                            if (block_end.offset_from(start) as libc::c_long as size_t)
                                < 4 as libc::c_int as libc::c_ulong
                            {
                                start = block_end;
                            } else {
                                start = start.offset(4 as libc::c_int as isize);
                            }
                        }
                        5 | 20 => {
                            let mut _val_0: dwarf_vma = 0;
                            let mut _len_1: libc::c_uint = 0;
                            let mut _status_0: libc::c_int = 0;
                            _val_0 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_1,
                                &mut _status_0,
                            );
                            start = start.offset(_len_1 as isize);
                            reg = _val_0 as libc::c_uint;
                            if reg as libc::c_ulong != _val_0 {
                                _status_0 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_0,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                8944 as libc::c_int as libc::c_ulong,
                            );
                            let mut _len_2: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_2,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_2 as isize);
                            if frame_need_space(fc, reg) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        reg as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        6 => {
                            let mut _val_1: dwarf_vma = 0;
                            let mut _len_3: libc::c_uint = 0;
                            let mut _status_1: libc::c_int = 0;
                            _val_1 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_3,
                                &mut _status_1,
                            );
                            start = start.offset(_len_3 as isize);
                            reg = _val_1 as libc::c_uint;
                            if reg as libc::c_ulong != _val_1 {
                                _status_1 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_1,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                8950 as libc::c_int as libc::c_ulong,
                            );
                            if frame_need_space(fc, reg) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        reg as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        7 => {
                            let mut _val_2: dwarf_vma = 0;
                            let mut _len_4: libc::c_uint = 0;
                            let mut _status_2: libc::c_int = 0;
                            _val_2 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_4,
                                &mut _status_2,
                            );
                            start = start.offset(_len_4 as isize);
                            reg = _val_2 as libc::c_uint;
                            if reg as libc::c_ulong != _val_2 {
                                _status_2 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_2,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                8955 as libc::c_int as libc::c_ulong,
                            );
                            if frame_need_space(fc, reg) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        reg as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        8 => {
                            let mut _val_3: dwarf_vma = 0;
                            let mut _len_5: libc::c_uint = 0;
                            let mut _status_3: libc::c_int = 0;
                            _val_3 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_5,
                                &mut _status_3,
                            );
                            start = start.offset(_len_5 as isize);
                            reg = _val_3 as libc::c_uint;
                            if reg as libc::c_ulong != _val_3 {
                                _status_3 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_3,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                8960 as libc::c_int as libc::c_ulong,
                            );
                            if frame_need_space(fc, reg) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        reg as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        9 => {
                            let mut _val_4: dwarf_vma = 0;
                            let mut _len_6: libc::c_uint = 0;
                            let mut _status_4: libc::c_int = 0;
                            _val_4 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_6,
                                &mut _status_4,
                            );
                            start = start.offset(_len_6 as isize);
                            reg = _val_4 as libc::c_uint;
                            if reg as libc::c_ulong != _val_4 {
                                _status_4 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_4,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                8965 as libc::c_int as libc::c_ulong,
                            );
                            let mut _len_7: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_7,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_7 as isize);
                            if frame_need_space(fc, reg) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        reg as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        12 => {
                            let mut _len_8: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_8,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_8 as isize);
                            let mut _len_9: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_9,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_9 as isize);
                        }
                        13 => {
                            let mut _len_10: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_10,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_10 as isize);
                        }
                        14 => {
                            let mut _len_11: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_11,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_11 as isize);
                        }
                        15 => {
                            let mut _val_5: dwarf_vma = 0;
                            let mut _len_12: libc::c_uint = 0;
                            let mut _status_5: libc::c_int = 0;
                            _val_5 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_12,
                                &mut _status_5,
                            );
                            start = start.offset(_len_12 as isize);
                            temp = _val_5;
                            if temp != _val_5 {
                                _status_5 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_5,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                8981 as libc::c_int as libc::c_ulong,
                            );
                            if (block_end.offset_from(start) as libc::c_long as size_t)
                                < temp
                            {
                                start = block_end;
                            } else {
                                start = start.offset(temp as isize);
                            }
                        }
                        16 | 22 => {
                            let mut _val_6: dwarf_vma = 0;
                            let mut _len_13: libc::c_uint = 0;
                            let mut _status_6: libc::c_int = 0;
                            _val_6 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_13,
                                &mut _status_6,
                            );
                            start = start.offset(_len_13 as isize);
                            reg = _val_6 as libc::c_uint;
                            if reg as libc::c_ulong != _val_6 {
                                _status_6 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_6,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                8989 as libc::c_int as libc::c_ulong,
                            );
                            let mut _val_7: dwarf_vma = 0;
                            let mut _len_14: libc::c_uint = 0;
                            let mut _status_7: libc::c_int = 0;
                            _val_7 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_14,
                                &mut _status_7,
                            );
                            start = start.offset(_len_14 as isize);
                            temp = _val_7;
                            if temp != _val_7 {
                                _status_7 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_7,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                8990 as libc::c_int as libc::c_ulong,
                            );
                            if (block_end.offset_from(start) as libc::c_long as size_t)
                                < temp
                            {
                                start = block_end;
                            } else {
                                start = start.offset(temp as isize);
                            }
                            if frame_need_space(fc, reg) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        reg as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        17 | 21 => {
                            let mut _val_8: dwarf_vma = 0;
                            let mut _len_15: libc::c_uint = 0;
                            let mut _status_8: libc::c_int = 0;
                            _val_8 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_15,
                                &mut _status_8,
                            );
                            start = start.offset(_len_15 as isize);
                            reg = _val_8 as libc::c_uint;
                            if reg as libc::c_ulong != _val_8 {
                                _status_8 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_8,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                9000 as libc::c_int as libc::c_ulong,
                            );
                            let mut _len_16: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                1 as libc::c_int != 0,
                                &mut _len_16,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_16 as isize);
                            if frame_need_space(fc, reg) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        reg as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        18 => {
                            let mut _len_17: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_17,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_17 as isize);
                            let mut _len_18: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                1 as libc::c_int != 0,
                                &mut _len_18,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_18 as isize);
                        }
                        19 => {
                            let mut _len_19: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                1 as libc::c_int != 0,
                                &mut _len_19,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_19 as isize);
                        }
                        29 => {
                            if (block_end.offset_from(start) as libc::c_long as size_t)
                                < 8 as libc::c_int as libc::c_ulong
                            {
                                start = block_end;
                            } else {
                                start = start.offset(8 as libc::c_int as isize);
                            }
                        }
                        46 => {
                            let mut _len_20: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_20,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_20 as isize);
                        }
                        47 => {
                            let mut _val_9: dwarf_vma = 0;
                            let mut _len_21: libc::c_uint = 0;
                            let mut _status_9: libc::c_int = 0;
                            _val_9 = read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_21,
                                &mut _status_9,
                            );
                            start = start.offset(_len_21 as isize);
                            reg = _val_9 as libc::c_uint;
                            if reg as libc::c_ulong != _val_9 {
                                _status_9 |= 2 as libc::c_int;
                            }
                            report_leb_status(
                                _status_9,
                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                9022 as libc::c_int as libc::c_ulong,
                            );
                            let mut _len_22: libc::c_uint = 0;
                            read_leb128(
                                start,
                                block_end,
                                0 as libc::c_int != 0,
                                &mut _len_22,
                                0 as *mut libc::c_int,
                            );
                            start = start.offset(_len_22 as isize);
                            if frame_need_space(fc, reg) >= 0 as libc::c_int {
                                *((*fc).col_type)
                                    .offset(
                                        reg as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            }
                        }
                        64 | _ => {}
                    }
                }
                start = tmp;
            }
            all_nops = 1 as libc::c_int != 0;
            while start < block_end {
                let mut op_0: libc::c_uint = 0;
                let mut opa_0: libc::c_uint = 0;
                let mut ul: libc::c_ulong = 0;
                let mut roffs: libc::c_ulong = 0;
                let mut reg_0: libc::c_uint = 0;
                let mut l: dwarf_signed_vma = 0;
                let mut ofs: dwarf_vma = 0;
                let mut vma: dwarf_vma = 0;
                let mut reg_prefix: *const libc::c_char = b"\0" as *const u8
                    as *const libc::c_char;
                let fresh33 = start;
                start = start.offset(1);
                op_0 = *fresh33 as libc::c_uint;
                opa_0 = op_0 & 0x3f as libc::c_int as libc::c_uint;
                if op_0 & 0xc0 as libc::c_int as libc::c_uint != 0 {
                    op_0 &= 0xc0 as libc::c_int as libc::c_uint;
                }
                if op_0 != DW_CFA_nop as libc::c_int as libc::c_uint {
                    all_nops = 0 as libc::c_int != 0;
                }
                match op_0 {
                    64 => {
                        if do_debug_frames_interp != 0 {
                            frame_display_row(fc, &mut need_col_headers, &mut max_regs);
                        } else {
                            printf(
                                b"  DW_CFA_advance_loc: %d to %s\n\0" as *const u8
                                    as *const libc::c_char,
                                opa_0.wrapping_mul((*fc).code_factor),
                                dwarf_vmatoa_1(
                                    0 as *const libc::c_char,
                                    ((*fc).pc_begin)
                                        .wrapping_add(
                                            opa_0.wrapping_mul((*fc).code_factor) as libc::c_ulong,
                                        ),
                                    (*fc).ptr_size as libc::c_uint,
                                ),
                            );
                        }
                        (*fc)
                            .pc_begin = ((*fc).pc_begin as libc::c_ulong)
                            .wrapping_add(
                                opa_0.wrapping_mul((*fc).code_factor) as libc::c_ulong,
                            ) as dwarf_vma as dwarf_vma;
                    }
                    128 => {
                        let mut _val_10: dwarf_vma = 0;
                        let mut _len_23: libc::c_uint = 0;
                        let mut _status_10: libc::c_int = 0;
                        _val_10 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_23,
                            &mut _status_10,
                        );
                        start = start.offset(_len_23 as isize);
                        roffs = _val_10;
                        if roffs != _val_10 {
                            _status_10 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_10,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9078 as libc::c_int as libc::c_ulong,
                        );
                        if opa_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_offset: %s%s at cfa%+ld\n\0" as *const u8
                                    as *const libc::c_char,
                                reg_prefix,
                                regname(opa_0, 0 as libc::c_int),
                                roffs.wrapping_mul((*fc).data_factor as libc::c_ulong),
                            );
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    opa_0 as isize,
                                ) = DW_CFA_offset as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(
                                    opa_0 as isize,
                                ) = roffs.wrapping_mul((*fc).data_factor as libc::c_ulong)
                                as libc::c_int;
                        }
                    }
                    192 => {
                        if opa_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_restore: %s%s\n\0" as *const u8
                                    as *const libc::c_char,
                                reg_prefix,
                                regname(opa_0, 0 as libc::c_int),
                            );
                        }
                        if !(*reg_prefix as libc::c_int != '\0' as i32) {
                            if opa_0 >= (*cie).ncols
                                || do_debug_frames_interp != 0
                                    && *((*cie).col_type).offset(opa_0 as isize) as libc::c_int
                                        == -(1 as libc::c_int)
                            {
                                *((*fc).col_type)
                                    .offset(
                                        opa_0 as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                                *((*fc).col_offset)
                                    .offset(opa_0 as isize) = 0 as libc::c_int;
                            } else {
                                *((*fc).col_type)
                                    .offset(
                                        opa_0 as isize,
                                    ) = *((*cie).col_type).offset(opa_0 as isize);
                                *((*fc).col_offset)
                                    .offset(
                                        opa_0 as isize,
                                    ) = *((*cie).col_offset).offset(opa_0 as isize);
                            }
                        }
                    }
                    1 => {
                        vma = get_encoded_value(
                            &mut start,
                            (*fc).fde_encoding as libc::c_int,
                            section,
                            block_end,
                        );
                        if do_debug_frames_interp != 0 {
                            frame_display_row(fc, &mut need_col_headers, &mut max_regs);
                        } else {
                            printf(
                                b"  DW_CFA_set_loc: %s\n\0" as *const u8
                                    as *const libc::c_char,
                                dwarf_vmatoa_1(
                                    0 as *const libc::c_char,
                                    vma,
                                    (*fc).ptr_size as libc::c_uint,
                                ),
                            );
                        }
                        (*fc).pc_begin = vma;
                    }
                    2 => {
                        let mut amount_7: size_t = 1 as libc::c_int as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_7
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_7,
                                    5 as libc::c_int,
                                ),
                                amount_7 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_7 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_7: size_t = block_end.offset_from(start)
                            as libc::c_long as size_t;
                        if start > block_end {
                            avail_7 = 0 as libc::c_int as size_t;
                        }
                        if amount_7 > avail_7 {
                            amount_7 = avail_7;
                        }
                        if amount_7 == 0 as libc::c_int as libc::c_ulong {
                            ofs = 0 as libc::c_int as dwarf_vma;
                        } else {
                            ofs = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(start, amount_7 as libc::c_uint);
                        }
                        start = start.offset(amount_7 as isize);
                        if do_debug_frames_interp != 0 {
                            frame_display_row(fc, &mut need_col_headers, &mut max_regs);
                        } else {
                            printf(
                                b"  DW_CFA_advance_loc1: %ld to %s\n\0" as *const u8
                                    as *const libc::c_char,
                                ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                                dwarf_vmatoa_1(
                                    0 as *const libc::c_char,
                                    ((*fc).pc_begin)
                                        .wrapping_add(
                                            ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                                        ),
                                    (*fc).ptr_size as libc::c_uint,
                                ),
                            );
                        }
                        (*fc)
                            .pc_begin = ((*fc).pc_begin as libc::c_ulong)
                            .wrapping_add(
                                ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                            ) as dwarf_vma as dwarf_vma;
                    }
                    3 => {
                        let mut amount_8: size_t = 2 as libc::c_int as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_8
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_8,
                                    5 as libc::c_int,
                                ),
                                amount_8 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_8 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_8: size_t = block_end.offset_from(start)
                            as libc::c_long as size_t;
                        if start > block_end {
                            avail_8 = 0 as libc::c_int as size_t;
                        }
                        if amount_8 > avail_8 {
                            amount_8 = avail_8;
                        }
                        if amount_8 == 0 as libc::c_int as libc::c_ulong {
                            ofs = 0 as libc::c_int as dwarf_vma;
                        } else {
                            ofs = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(start, amount_8 as libc::c_uint);
                        }
                        start = start.offset(amount_8 as isize);
                        if do_debug_frames_interp != 0 {
                            frame_display_row(fc, &mut need_col_headers, &mut max_regs);
                        } else {
                            printf(
                                b"  DW_CFA_advance_loc2: %ld to %s\n\0" as *const u8
                                    as *const libc::c_char,
                                ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                                dwarf_vmatoa_1(
                                    0 as *const libc::c_char,
                                    ((*fc).pc_begin)
                                        .wrapping_add(
                                            ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                                        ),
                                    (*fc).ptr_size as libc::c_uint,
                                ),
                            );
                        }
                        (*fc)
                            .pc_begin = ((*fc).pc_begin as libc::c_ulong)
                            .wrapping_add(
                                ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                            ) as dwarf_vma as dwarf_vma;
                    }
                    4 => {
                        let mut amount_9: size_t = 4 as libc::c_int as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_9
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_9,
                                    5 as libc::c_int,
                                ),
                                amount_9 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_9 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_9: size_t = block_end.offset_from(start)
                            as libc::c_long as size_t;
                        if start > block_end {
                            avail_9 = 0 as libc::c_int as size_t;
                        }
                        if amount_9 > avail_9 {
                            amount_9 = avail_9;
                        }
                        if amount_9 == 0 as libc::c_int as libc::c_ulong {
                            ofs = 0 as libc::c_int as dwarf_vma;
                        } else {
                            ofs = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(start, amount_9 as libc::c_uint);
                        }
                        start = start.offset(amount_9 as isize);
                        if do_debug_frames_interp != 0 {
                            frame_display_row(fc, &mut need_col_headers, &mut max_regs);
                        } else {
                            printf(
                                b"  DW_CFA_advance_loc4: %ld to %s\n\0" as *const u8
                                    as *const libc::c_char,
                                ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                                dwarf_vmatoa_1(
                                    0 as *const libc::c_char,
                                    ((*fc).pc_begin)
                                        .wrapping_add(
                                            ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                                        ),
                                    (*fc).ptr_size as libc::c_uint,
                                ),
                            );
                        }
                        (*fc)
                            .pc_begin = ((*fc).pc_begin as libc::c_ulong)
                            .wrapping_add(
                                ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                            ) as dwarf_vma as dwarf_vma;
                    }
                    5 => {
                        let mut _val_11: dwarf_vma = 0;
                        let mut _len_24: libc::c_uint = 0;
                        let mut _status_11: libc::c_int = 0;
                        _val_11 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_24,
                            &mut _status_11,
                        );
                        start = start.offset(_len_24 as isize);
                        reg_0 = _val_11 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_11 {
                            _status_11 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_11,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9166 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_12: dwarf_vma = 0;
                        let mut _len_25: libc::c_uint = 0;
                        let mut _status_12: libc::c_int = 0;
                        _val_12 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_25,
                            &mut _status_12,
                        );
                        start = start.offset(_len_25 as isize);
                        roffs = _val_12;
                        if roffs != _val_12 {
                            _status_12 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_12,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9167 as libc::c_int as libc::c_ulong,
                        );
                        if reg_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_offset_extended: %s%s at cfa%+ld\n\0"
                                    as *const u8 as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                                roffs.wrapping_mul((*fc).data_factor as libc::c_ulong),
                            );
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    reg_0 as isize,
                                ) = DW_CFA_offset as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(
                                    reg_0 as isize,
                                ) = roffs.wrapping_mul((*fc).data_factor as libc::c_ulong)
                                as libc::c_int;
                        }
                    }
                    20 => {
                        let mut _val_13: dwarf_vma = 0;
                        let mut _len_26: libc::c_uint = 0;
                        let mut _status_13: libc::c_int = 0;
                        _val_13 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_26,
                            &mut _status_13,
                        );
                        start = start.offset(_len_26 as isize);
                        reg_0 = _val_13 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_13 {
                            _status_13 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_13,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9182 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_14: dwarf_vma = 0;
                        let mut _len_27: libc::c_uint = 0;
                        let mut _status_14: libc::c_int = 0;
                        _val_14 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_27,
                            &mut _status_14,
                        );
                        start = start.offset(_len_27 as isize);
                        roffs = _val_14;
                        if roffs != _val_14 {
                            _status_14 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_14,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9183 as libc::c_int as libc::c_ulong,
                        );
                        if reg_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_val_offset: %s%s is cfa%+ld\n\0" as *const u8
                                    as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                                roffs.wrapping_mul((*fc).data_factor as libc::c_ulong),
                            );
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    reg_0 as isize,
                                ) = DW_CFA_val_offset as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(
                                    reg_0 as isize,
                                ) = roffs.wrapping_mul((*fc).data_factor as libc::c_ulong)
                                as libc::c_int;
                        }
                    }
                    6 => {
                        let mut _val_15: dwarf_vma = 0;
                        let mut _len_28: libc::c_uint = 0;
                        let mut _status_15: libc::c_int = 0;
                        _val_15 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_28,
                            &mut _status_15,
                        );
                        start = start.offset(_len_28 as isize);
                        reg_0 = _val_15 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_15 {
                            _status_15 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_15,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9198 as libc::c_int as libc::c_ulong,
                        );
                        if reg_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_restore_extended: %s%s\n\0" as *const u8
                                    as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                            );
                        }
                        if !(*reg_prefix as libc::c_int != '\0' as i32) {
                            if reg_0 >= (*cie).ncols {
                                *((*fc).col_type)
                                    .offset(
                                        reg_0 as isize,
                                    ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                                *((*fc).col_offset)
                                    .offset(reg_0 as isize) = 0 as libc::c_int;
                            } else {
                                *((*fc).col_type)
                                    .offset(
                                        reg_0 as isize,
                                    ) = *((*cie).col_type).offset(reg_0 as isize);
                                *((*fc).col_offset)
                                    .offset(
                                        reg_0 as isize,
                                    ) = *((*cie).col_offset).offset(reg_0 as isize);
                            }
                        }
                    }
                    7 => {
                        let mut _val_16: dwarf_vma = 0;
                        let mut _len_29: libc::c_uint = 0;
                        let mut _status_16: libc::c_int = 0;
                        _val_16 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_29,
                            &mut _status_16,
                        );
                        start = start.offset(_len_29 as isize);
                        reg_0 = _val_16 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_16 {
                            _status_16 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_16,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9220 as libc::c_int as libc::c_ulong,
                        );
                        if reg_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_undefined: %s%s\n\0" as *const u8
                                    as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                            );
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    reg_0 as isize,
                                ) = DW_CFA_undefined as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(reg_0 as isize) = 0 as libc::c_int;
                        }
                    }
                    8 => {
                        let mut _val_17: dwarf_vma = 0;
                        let mut _len_30: libc::c_uint = 0;
                        let mut _status_17: libc::c_int = 0;
                        _val_17 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_30,
                            &mut _status_17,
                        );
                        start = start.offset(_len_30 as isize);
                        reg_0 = _val_17 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_17 {
                            _status_17 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_17,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9234 as libc::c_int as libc::c_ulong,
                        );
                        if reg_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_same_value: %s%s\n\0" as *const u8
                                    as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                            );
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    reg_0 as isize,
                                ) = DW_CFA_same_value as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(reg_0 as isize) = 0 as libc::c_int;
                        }
                    }
                    9 => {
                        let mut _val_18: dwarf_vma = 0;
                        let mut _len_31: libc::c_uint = 0;
                        let mut _status_18: libc::c_int = 0;
                        _val_18 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_31,
                            &mut _status_18,
                        );
                        start = start.offset(_len_31 as isize);
                        reg_0 = _val_18 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_18 {
                            _status_18 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_18,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9248 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_19: dwarf_vma = 0;
                        let mut _len_32: libc::c_uint = 0;
                        let mut _status_19: libc::c_int = 0;
                        _val_19 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_32,
                            &mut _status_19,
                        );
                        start = start.offset(_len_32 as isize);
                        roffs = _val_19;
                        if roffs != _val_19 {
                            _status_19 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_19,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9249 as libc::c_int as libc::c_ulong,
                        );
                        if reg_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_register: %s%s in \0" as *const u8
                                    as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                            );
                            puts(regname(roffs as libc::c_uint, 0 as libc::c_int));
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    reg_0 as isize,
                                ) = DW_CFA_register as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(reg_0 as isize) = roffs as libc::c_int;
                        }
                    }
                    10 => {
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_remember_state\n\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        rs = xmalloc(
                            ::core::mem::size_of::<Frame_Chunk>() as libc::c_ulong,
                        ) as *mut Frame_Chunk;
                        (*rs).cfa_offset = (*fc).cfa_offset;
                        (*rs).cfa_reg = (*fc).cfa_reg;
                        (*rs).ra = (*fc).ra;
                        (*rs).cfa_exp = (*fc).cfa_exp;
                        (*rs).ncols = (*fc).ncols;
                        (*rs)
                            .col_type = xcmalloc(
                            (*rs).ncols as size_t,
                            ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                        ) as *mut libc::c_short;
                        (*rs)
                            .col_offset = xcmalloc(
                            (*rs).ncols as size_t,
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ) as *mut libc::c_int;
                        memcpy(
                            (*rs).col_type as *mut libc::c_void,
                            (*fc).col_type as *const libc::c_void,
                            ((*rs).ncols as libc::c_ulong)
                                .wrapping_mul(
                                    ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                                ),
                        );
                        memcpy(
                            (*rs).col_offset as *mut libc::c_void,
                            (*fc).col_offset as *const libc::c_void,
                            ((*rs).ncols as libc::c_ulong)
                                .wrapping_mul(
                                    ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                                ),
                        );
                        (*rs).next = remembered_state;
                        remembered_state = rs;
                    }
                    11 => {
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_restore_state\n\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        rs = remembered_state;
                        if !rs.is_null() {
                            remembered_state = (*rs).next;
                            (*fc).cfa_offset = (*rs).cfa_offset;
                            (*fc).cfa_reg = (*rs).cfa_reg;
                            (*fc).ra = (*rs).ra;
                            (*fc).cfa_exp = (*rs).cfa_exp;
                            if frame_need_space(
                                fc,
                                ((*rs).ncols).wrapping_sub(1 as libc::c_int as libc::c_uint),
                            ) < 0 as libc::c_int
                            {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Invalid column number in saved frame state\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                );
                                (*fc).ncols = 0 as libc::c_int as libc::c_uint;
                            } else {
                                memcpy(
                                    (*fc).col_type as *mut libc::c_void,
                                    (*rs).col_type as *const libc::c_void,
                                    ((*rs).ncols as libc::c_ulong)
                                        .wrapping_mul(
                                            ::core::mem::size_of::<libc::c_short>() as libc::c_ulong,
                                        ),
                                );
                                memcpy(
                                    (*fc).col_offset as *mut libc::c_void,
                                    (*rs).col_offset as *const libc::c_void,
                                    ((*rs).ncols as libc::c_ulong)
                                        .wrapping_mul(
                                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                                        ),
                                );
                                free((*rs).col_type as *mut libc::c_void);
                                free((*rs).col_offset as *mut libc::c_void);
                                free(rs as *mut libc::c_void);
                            }
                        } else if do_debug_frames_interp != 0 {
                            printf(
                                b"Mismatched DW_CFA_restore_state\n\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                    }
                    12 => {
                        let mut _val_20: dwarf_vma = 0;
                        let mut _len_33: libc::c_uint = 0;
                        let mut _status_20: libc::c_int = 0;
                        _val_20 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_33,
                            &mut _status_20,
                        );
                        start = start.offset(_len_33 as isize);
                        (*fc).cfa_reg = _val_20 as libc::c_uint;
                        if (*fc).cfa_reg as libc::c_ulong != _val_20 {
                            _status_20 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_20,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9312 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_21: dwarf_vma = 0;
                        let mut _len_34: libc::c_uint = 0;
                        let mut _status_21: libc::c_int = 0;
                        _val_21 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_34,
                            &mut _status_21,
                        );
                        start = start.offset(_len_34 as isize);
                        (*fc).cfa_offset = _val_21;
                        if (*fc).cfa_offset != _val_21 {
                            _status_21 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_21,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9313 as libc::c_int as libc::c_ulong,
                        );
                        (*fc).cfa_exp = 0 as libc::c_int as libc::c_uchar;
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_def_cfa: %s ofs %d\n\0" as *const u8
                                    as *const libc::c_char,
                                regname((*fc).cfa_reg, 0 as libc::c_int),
                                (*fc).cfa_offset as libc::c_int,
                            );
                        }
                    }
                    13 => {
                        let mut _val_22: dwarf_vma = 0;
                        let mut _len_35: libc::c_uint = 0;
                        let mut _status_22: libc::c_int = 0;
                        _val_22 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_35,
                            &mut _status_22,
                        );
                        start = start.offset(_len_35 as isize);
                        (*fc).cfa_reg = _val_22 as libc::c_uint;
                        if (*fc).cfa_reg as libc::c_ulong != _val_22 {
                            _status_22 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_22,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9321 as libc::c_int as libc::c_ulong,
                        );
                        (*fc).cfa_exp = 0 as libc::c_int as libc::c_uchar;
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_def_cfa_register: %s\n\0" as *const u8
                                    as *const libc::c_char,
                                regname((*fc).cfa_reg, 0 as libc::c_int),
                            );
                        }
                    }
                    14 => {
                        let mut _val_23: dwarf_vma = 0;
                        let mut _len_36: libc::c_uint = 0;
                        let mut _status_23: libc::c_int = 0;
                        _val_23 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_36,
                            &mut _status_23,
                        );
                        start = start.offset(_len_36 as isize);
                        (*fc).cfa_offset = _val_23;
                        if (*fc).cfa_offset != _val_23 {
                            _status_23 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_23,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9329 as libc::c_int as libc::c_ulong,
                        );
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_def_cfa_offset: %d\n\0" as *const u8
                                    as *const libc::c_char,
                                (*fc).cfa_offset as libc::c_int,
                            );
                        }
                    }
                    0 => {
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_nop\n\0" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                    15 => {
                        let mut _val_24: dwarf_vma = 0;
                        let mut _len_37: libc::c_uint = 0;
                        let mut _status_24: libc::c_int = 0;
                        _val_24 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_37,
                            &mut _status_24,
                        );
                        start = start.offset(_len_37 as isize);
                        ul = _val_24;
                        if ul != _val_24 {
                            _status_24 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_24,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9340 as libc::c_int as libc::c_ulong,
                        );
                        if ul > block_end.offset_from(start) as libc::c_long as size_t {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  DW_CFA_def_cfa_expression: <corrupt len %lu>\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ul,
                            );
                        } else {
                            if do_debug_frames_interp == 0 {
                                printf(
                                    b"  DW_CFA_def_cfa_expression (\0" as *const u8
                                        as *const libc::c_char,
                                );
                                decode_location_expression(
                                    start,
                                    eh_addr_size,
                                    0 as libc::c_int as libc::c_uint,
                                    -(1 as libc::c_int),
                                    ul,
                                    0 as libc::c_int as dwarf_vma,
                                    section,
                                );
                                printf(b")\n\0" as *const u8 as *const libc::c_char);
                            }
                            (*fc).cfa_exp = 1 as libc::c_int as libc::c_uchar;
                            start = start.offset(ul as isize);
                        }
                    }
                    16 => {
                        let mut _val_25: dwarf_vma = 0;
                        let mut _len_38: libc::c_uint = 0;
                        let mut _status_25: libc::c_int = 0;
                        _val_25 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_38,
                            &mut _status_25,
                        );
                        start = start.offset(_len_38 as isize);
                        reg_0 = _val_25 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_25 {
                            _status_25 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_25,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9358 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_26: dwarf_vma = 0;
                        let mut _len_39: libc::c_uint = 0;
                        let mut _status_26: libc::c_int = 0;
                        _val_26 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_39,
                            &mut _status_26,
                        );
                        start = start.offset(_len_39 as isize);
                        ul = _val_26;
                        if ul != _val_26 {
                            _status_26 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_26,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9359 as libc::c_int as libc::c_ulong,
                        );
                        if reg_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if ul > block_end.offset_from(start) as libc::c_long as size_t {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  DW_CFA_expression: <corrupt len %lu>\n\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                ul,
                            );
                        } else {
                            if do_debug_frames_interp == 0
                                || *reg_prefix as libc::c_int != '\0' as i32
                            {
                                printf(
                                    b"  DW_CFA_expression: %s%s (\0" as *const u8
                                        as *const libc::c_char,
                                    reg_prefix,
                                    regname(reg_0, 0 as libc::c_int),
                                );
                                decode_location_expression(
                                    start,
                                    eh_addr_size,
                                    0 as libc::c_int as libc::c_uint,
                                    -(1 as libc::c_int),
                                    ul,
                                    0 as libc::c_int as dwarf_vma,
                                    section,
                                );
                                printf(b")\n\0" as *const u8 as *const libc::c_char);
                            }
                            if *reg_prefix as libc::c_int == '\0' as i32 {
                                *((*fc).col_type)
                                    .offset(
                                        reg_0 as isize,
                                    ) = DW_CFA_expression as libc::c_int as libc::c_short;
                            }
                            start = start.offset(ul as isize);
                        }
                    }
                    22 => {
                        let mut _val_27: dwarf_vma = 0;
                        let mut _len_40: libc::c_uint = 0;
                        let mut _status_27: libc::c_int = 0;
                        _val_27 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_40,
                            &mut _status_27,
                        );
                        start = start.offset(_len_40 as isize);
                        reg_0 = _val_27 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_27 {
                            _status_27 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_27,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9383 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_28: dwarf_vma = 0;
                        let mut _len_41: libc::c_uint = 0;
                        let mut _status_28: libc::c_int = 0;
                        _val_28 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_41,
                            &mut _status_28,
                        );
                        start = start.offset(_len_41 as isize);
                        ul = _val_28;
                        if ul != _val_28 {
                            _status_28 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_28,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9384 as libc::c_int as libc::c_ulong,
                        );
                        if reg_0 >= (*fc).ncols {
                            reg_prefix = bad_reg;
                        }
                        if ul > block_end.offset_from(start) as libc::c_long as size_t {
                            printf(
                                b"  DW_CFA_val_expression: <corrupt len %lu>\n\0"
                                    as *const u8 as *const libc::c_char,
                                ul,
                            );
                        } else {
                            if do_debug_frames_interp == 0
                                || *reg_prefix as libc::c_int != '\0' as i32
                            {
                                printf(
                                    b"  DW_CFA_val_expression: %s%s (\0" as *const u8
                                        as *const libc::c_char,
                                    reg_prefix,
                                    regname(reg_0, 0 as libc::c_int),
                                );
                                decode_location_expression(
                                    start,
                                    eh_addr_size,
                                    0 as libc::c_int as libc::c_uint,
                                    -(1 as libc::c_int),
                                    ul,
                                    0 as libc::c_int as dwarf_vma,
                                    section,
                                );
                                printf(b")\n\0" as *const u8 as *const libc::c_char);
                            }
                            if *reg_prefix as libc::c_int == '\0' as i32 {
                                *((*fc).col_type)
                                    .offset(
                                        reg_0 as isize,
                                    ) = DW_CFA_val_expression as libc::c_int as libc::c_short;
                            }
                            start = start.offset(ul as isize);
                        }
                    }
                    17 => {
                        let mut _val_29: dwarf_vma = 0;
                        let mut _len_42: libc::c_uint = 0;
                        let mut _status_29: libc::c_int = 0;
                        _val_29 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_42,
                            &mut _status_29,
                        );
                        start = start.offset(_len_42 as isize);
                        reg_0 = _val_29 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_29 {
                            _status_29 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_29,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9406 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_30: dwarf_signed_vma = 0;
                        let mut _len_43: libc::c_uint = 0;
                        let mut _status_30: libc::c_int = 0;
                        _val_30 = read_leb128(
                            start,
                            block_end,
                            1 as libc::c_int != 0,
                            &mut _len_43,
                            &mut _status_30,
                        ) as dwarf_signed_vma;
                        start = start.offset(_len_43 as isize);
                        l = _val_30;
                        if l != _val_30 {
                            _status_30 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_30,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9407 as libc::c_int as libc::c_ulong,
                        );
                        if frame_need_space(fc, reg_0) < 0 as libc::c_int {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_offset_extended_sf: %s%s at cfa%+ld\n\0"
                                    as *const u8 as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                                l * (*fc).data_factor as libc::c_long,
                            );
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    reg_0 as isize,
                                ) = DW_CFA_offset as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(
                                    reg_0 as isize,
                                ) = (l * (*fc).data_factor as libc::c_long) as libc::c_int;
                        }
                    }
                    21 => {
                        let mut _val_31: dwarf_vma = 0;
                        let mut _len_44: libc::c_uint = 0;
                        let mut _status_31: libc::c_int = 0;
                        _val_31 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_44,
                            &mut _status_31,
                        );
                        start = start.offset(_len_44 as isize);
                        reg_0 = _val_31 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_31 {
                            _status_31 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_31,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9422 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_32: dwarf_signed_vma = 0;
                        let mut _len_45: libc::c_uint = 0;
                        let mut _status_32: libc::c_int = 0;
                        _val_32 = read_leb128(
                            start,
                            block_end,
                            1 as libc::c_int != 0,
                            &mut _len_45,
                            &mut _status_32,
                        ) as dwarf_signed_vma;
                        start = start.offset(_len_45 as isize);
                        l = _val_32;
                        if l != _val_32 {
                            _status_32 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_32,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9423 as libc::c_int as libc::c_ulong,
                        );
                        if frame_need_space(fc, reg_0) < 0 as libc::c_int {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_val_offset_sf: %s%s is cfa%+ld\n\0" as *const u8
                                    as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                                l * (*fc).data_factor as libc::c_long,
                            );
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    reg_0 as isize,
                                ) = DW_CFA_val_offset as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(
                                    reg_0 as isize,
                                ) = (l * (*fc).data_factor as libc::c_long) as libc::c_int;
                        }
                    }
                    18 => {
                        let mut _val_33: dwarf_vma = 0;
                        let mut _len_46: libc::c_uint = 0;
                        let mut _status_33: libc::c_int = 0;
                        _val_33 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_46,
                            &mut _status_33,
                        );
                        start = start.offset(_len_46 as isize);
                        (*fc).cfa_reg = _val_33 as libc::c_uint;
                        if (*fc).cfa_reg as libc::c_ulong != _val_33 {
                            _status_33 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_33,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9438 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_34: dwarf_signed_vma = 0;
                        let mut _len_47: libc::c_uint = 0;
                        let mut _status_34: libc::c_int = 0;
                        _val_34 = read_leb128(
                            start,
                            block_end,
                            1 as libc::c_int != 0,
                            &mut _len_47,
                            &mut _status_34,
                        ) as dwarf_signed_vma;
                        start = start.offset(_len_47 as isize);
                        l = _val_34;
                        if l != _val_34 {
                            _status_34 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_34,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9439 as libc::c_int as libc::c_ulong,
                        );
                        l *= (*fc).data_factor as libc::c_long;
                        (*fc).cfa_offset = l as dwarf_vma;
                        (*fc).cfa_exp = 0 as libc::c_int as libc::c_uchar;
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_def_cfa_sf: %s ofs %ld\n\0" as *const u8
                                    as *const libc::c_char,
                                regname((*fc).cfa_reg, 0 as libc::c_int),
                                l,
                            );
                        }
                    }
                    19 => {
                        let mut _val_35: dwarf_signed_vma = 0;
                        let mut _len_48: libc::c_uint = 0;
                        let mut _status_35: libc::c_int = 0;
                        _val_35 = read_leb128(
                            start,
                            block_end,
                            1 as libc::c_int != 0,
                            &mut _len_48,
                            &mut _status_35,
                        ) as dwarf_signed_vma;
                        start = start.offset(_len_48 as isize);
                        l = _val_35;
                        if l != _val_35 {
                            _status_35 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_35,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9449 as libc::c_int as libc::c_ulong,
                        );
                        l *= (*fc).data_factor as libc::c_long;
                        (*fc).cfa_offset = l as dwarf_vma;
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_def_cfa_offset_sf: %ld\n\0" as *const u8
                                    as *const libc::c_char,
                                l,
                            );
                        }
                    }
                    29 => {
                        let mut amount_10: size_t = 8 as libc::c_int as size_t;
                        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong)
                            < amount_10
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_10,
                                    5 as libc::c_int,
                                ),
                                amount_10 as libc::c_int,
                                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_10 = ::core::mem::size_of::<dwarf_vma>()
                                as libc::c_ulong;
                        }
                        let mut avail_10: size_t = block_end.offset_from(start)
                            as libc::c_long as size_t;
                        if start > block_end {
                            avail_10 = 0 as libc::c_int as size_t;
                        }
                        if amount_10 > avail_10 {
                            amount_10 = avail_10;
                        }
                        if amount_10 == 0 as libc::c_int as libc::c_ulong {
                            ofs = 0 as libc::c_int as dwarf_vma;
                        } else {
                            ofs = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(start, amount_10 as libc::c_uint);
                        }
                        start = start.offset(amount_10 as isize);
                        if do_debug_frames_interp != 0 {
                            frame_display_row(fc, &mut need_col_headers, &mut max_regs);
                        } else {
                            printf(
                                b"  DW_CFA_MIPS_advance_loc8: %ld to %s\n\0" as *const u8
                                    as *const libc::c_char,
                                ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                                dwarf_vmatoa_1(
                                    0 as *const libc::c_char,
                                    ((*fc).pc_begin)
                                        .wrapping_add(
                                            ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                                        ),
                                    (*fc).ptr_size as libc::c_uint,
                                ),
                            );
                        }
                        (*fc)
                            .pc_begin = ((*fc).pc_begin as libc::c_ulong)
                            .wrapping_add(
                                ofs.wrapping_mul((*fc).code_factor as libc::c_ulong),
                            ) as dwarf_vma as dwarf_vma;
                    }
                    45 => {
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_GNU_window_save\n\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                    }
                    46 => {
                        let mut _val_36: dwarf_vma = 0;
                        let mut _len_49: libc::c_uint = 0;
                        let mut _status_36: libc::c_int = 0;
                        _val_36 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_49,
                            &mut _status_36,
                        );
                        start = start.offset(_len_49 as isize);
                        ul = _val_36;
                        if ul != _val_36 {
                            _status_36 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_36,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9475 as libc::c_int as libc::c_ulong,
                        );
                        if do_debug_frames_interp == 0 {
                            printf(
                                b"  DW_CFA_GNU_args_size: %ld\n\0" as *const u8
                                    as *const libc::c_char,
                                ul,
                            );
                        }
                    }
                    47 => {
                        let mut _val_37: dwarf_vma = 0;
                        let mut _len_50: libc::c_uint = 0;
                        let mut _status_37: libc::c_int = 0;
                        _val_37 = read_leb128(
                            start,
                            block_end,
                            0 as libc::c_int != 0,
                            &mut _len_50,
                            &mut _status_37,
                        );
                        start = start.offset(_len_50 as isize);
                        reg_0 = _val_37 as libc::c_uint;
                        if reg_0 as libc::c_ulong != _val_37 {
                            _status_37 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_37,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9481 as libc::c_int as libc::c_ulong,
                        );
                        let mut _val_38: dwarf_signed_vma = 0;
                        let mut _len_51: libc::c_uint = 0;
                        let mut _status_38: libc::c_int = 0;
                        _val_38 = read_leb128(
                            start,
                            block_end,
                            1 as libc::c_int != 0,
                            &mut _len_51,
                            &mut _status_38,
                        ) as dwarf_signed_vma;
                        start = start.offset(_len_51 as isize);
                        l = _val_38;
                        if l != _val_38 {
                            _status_38 |= 2 as libc::c_int;
                        }
                        report_leb_status(
                            _status_38,
                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                            9482 as libc::c_int as libc::c_ulong,
                        );
                        l = -l;
                        if frame_need_space(fc, reg_0) < 0 as libc::c_int {
                            reg_prefix = bad_reg;
                        }
                        if do_debug_frames_interp == 0
                            || *reg_prefix as libc::c_int != '\0' as i32
                        {
                            printf(
                                b"  DW_CFA_GNU_negative_offset_extended: %s%s at cfa%+ld\n\0"
                                    as *const u8 as *const libc::c_char,
                                reg_prefix,
                                regname(reg_0, 0 as libc::c_int),
                                l * (*fc).data_factor as libc::c_long,
                            );
                        }
                        if *reg_prefix as libc::c_int == '\0' as i32 {
                            *((*fc).col_type)
                                .offset(
                                    reg_0 as isize,
                                ) = DW_CFA_offset as libc::c_int as libc::c_short;
                            *((*fc).col_offset)
                                .offset(
                                    reg_0 as isize,
                                ) = (l * (*fc).data_factor as libc::c_long) as libc::c_int;
                        }
                    }
                    _ => {
                        if op_0 >= DW_CFA_lo_user as libc::c_int as libc::c_uint
                            && op_0 <= DW_CFA_hi_user as libc::c_int as libc::c_uint
                        {
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"  DW_CFA_??? (User defined call frame op: %#x)\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                op_0,
                            );
                        } else {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Unsupported or unknown Dwarf Call Frame Instruction number: %#x\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                op_0,
                            );
                        }
                        start = block_end;
                    }
                }
            }
            if do_debug_frames_interp != 0 && !all_nops {
                frame_display_row(fc, &mut need_col_headers, &mut max_regs);
            }
            if !(fde_fc.col_type).is_null() {
                free(fde_fc.col_type as *mut libc::c_void);
                fde_fc.col_type = 0 as *mut libc::c_short;
            }
            if !(fde_fc.col_offset).is_null() {
                free(fde_fc.col_offset as *mut libc::c_void);
                fde_fc.col_offset = 0 as *mut libc::c_int;
            }
            start = block_end;
            eh_addr_size = saved_eh_addr_size;
        }
    }
    printf(b"\n\0" as *const u8 as *const libc::c_char);
    while !remembered_state.is_null() {
        rs = remembered_state;
        remembered_state = (*rs).next;
        free((*rs).col_type as *mut libc::c_void);
        free((*rs).col_offset as *mut libc::c_void);
        (*rs).next = 0 as *mut Frame_Chunk;
        free(rs as *mut libc::c_void);
    }
    while !chunks.is_null() {
        rs = chunks;
        chunks = (*rs).next;
        free((*rs).col_type as *mut libc::c_void);
        free((*rs).col_offset as *mut libc::c_void);
        (*rs).next = 0 as *mut Frame_Chunk;
        free(rs as *mut libc::c_void);
    }
    while !forward_refs.is_null() {
        rs = forward_refs;
        forward_refs = (*rs).next;
        free((*rs).col_type as *mut libc::c_void);
        free((*rs).col_offset as *mut libc::c_void);
        (*rs).next = 0 as *mut Frame_Chunk;
        free(rs as *mut libc::c_void);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_names(
    mut section: *mut dwarf_section,
    mut file: *mut libc::c_void,
) -> libc::c_int {
    let mut hdrptr: *mut libc::c_uchar = (*section).start;
    let mut unit_length: dwarf_vma = 0;
    let mut unit_start: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let section_end: *const libc::c_uchar = ((*section).start)
        .offset((*section).size as isize);
    let mut unit_end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    introduce(section, 0 as libc::c_int != 0);
    load_debug_section_with_follow(str, file);
    while hdrptr < section_end as *mut libc::c_uchar {
        let mut offset_size: libc::c_uint = 0;
        let mut dwarf_version: uint16_t = 0;
        let mut padding: uint16_t = 0;
        let mut comp_unit_count: uint32_t = 0;
        let mut local_type_unit_count: uint32_t = 0;
        let mut foreign_type_unit_count: uint32_t = 0;
        let mut bucket_count: uint64_t = 0;
        let mut name_count: uint64_t = 0;
        let mut abbrev_table_size: uint64_t = 0;
        let mut augmentation_string_size: uint32_t = 0;
        let mut i: libc::c_uint = 0;
        let mut augmentation_printable: bool = false;
        let mut augmentation_string: *const libc::c_char = 0 as *const libc::c_char;
        let mut total: size_t = 0;
        unit_start = hdrptr;
        let mut amount: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount,
                    5 as libc::c_int,
                ),
                amount as libc::c_int,
                ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
            );
            amount = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
        }
        let mut avail: size_t = section_end.offset_from(hdrptr) as libc::c_long
            as size_t;
        if hdrptr > section_end as *mut libc::c_uchar {
            avail = 0 as libc::c_int as size_t;
        }
        if amount > avail {
            amount = avail;
        }
        if amount == 0 as libc::c_int as libc::c_ulong {
            unit_length = 0 as libc::c_int as dwarf_vma;
        } else {
            unit_length = byte_get
                .expect("non-null function pointer")(hdrptr, amount as libc::c_uint);
        }
        hdrptr = hdrptr.offset(amount as isize);
        if unit_length == 0xffffffff as libc::c_uint as libc::c_ulong {
            let mut amount_0: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_0 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_0,
                        5 as libc::c_int,
                    ),
                    amount_0 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_0 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_0: size_t = section_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > section_end as *mut libc::c_uchar {
                avail_0 = 0 as libc::c_int as size_t;
            }
            if amount_0 > avail_0 {
                amount_0 = avail_0;
            }
            if amount_0 == 0 as libc::c_int as libc::c_ulong {
                unit_length = 0 as libc::c_int as dwarf_vma;
            } else {
                unit_length = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_0 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_0 as isize);
            offset_size = 8 as libc::c_int as libc::c_uint;
        } else {
            offset_size = 4 as libc::c_int as libc::c_uint;
        }
        if !(unit_length > section_end.offset_from(hdrptr) as libc::c_long as size_t
            || unit_length
                < (2 as libc::c_int + 2 as libc::c_int
                    + 4 as libc::c_int * 7 as libc::c_int) as libc::c_ulong)
        {
            unit_end = hdrptr.offset(unit_length as isize);
            let mut amount_1: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint16_t>() as libc::c_ulong) < amount_1 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_1,
                        5 as libc::c_int,
                    ),
                    amount_1 as libc::c_int,
                    ::core::mem::size_of::<uint16_t>() as libc::c_ulong as libc::c_int,
                );
                amount_1 = ::core::mem::size_of::<uint16_t>() as libc::c_ulong;
            }
            let mut avail_1: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_1 = 0 as libc::c_int as size_t;
            }
            if amount_1 > avail_1 {
                amount_1 = avail_1;
            }
            if amount_1 == 0 as libc::c_int as libc::c_ulong {
                dwarf_version = 0 as libc::c_int as uint16_t;
            } else {
                dwarf_version = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_1 as libc::c_uint) as uint16_t;
            }
            hdrptr = hdrptr.offset(amount_1 as isize);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Version %ld\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                dwarf_version as libc::c_long,
            );
            if dwarf_version as libc::c_int != 5 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Only DWARF version 5 .debug_names is currently supported.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                return 0 as libc::c_int;
            }
            let mut amount_2: size_t = 2 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint16_t>() as libc::c_ulong) < amount_2 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_2,
                        5 as libc::c_int,
                    ),
                    amount_2 as libc::c_int,
                    ::core::mem::size_of::<uint16_t>() as libc::c_ulong as libc::c_int,
                );
                amount_2 = ::core::mem::size_of::<uint16_t>() as libc::c_ulong;
            }
            let mut avail_2: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_2 = 0 as libc::c_int as size_t;
            }
            if amount_2 > avail_2 {
                amount_2 = avail_2;
            }
            if amount_2 == 0 as libc::c_int as libc::c_ulong {
                padding = 0 as libc::c_int as uint16_t;
            } else {
                padding = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_2 as libc::c_uint) as uint16_t;
            }
            hdrptr = hdrptr.offset(amount_2 as isize);
            if padding as libc::c_int != 0 as libc::c_int {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Padding field of .debug_names must be 0 (found 0x%x)\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    padding as libc::c_int,
                );
            }
            let mut amount_3: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint32_t>() as libc::c_ulong) < amount_3 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_3,
                        5 as libc::c_int,
                    ),
                    amount_3 as libc::c_int,
                    ::core::mem::size_of::<uint32_t>() as libc::c_ulong as libc::c_int,
                );
                amount_3 = ::core::mem::size_of::<uint32_t>() as libc::c_ulong;
            }
            let mut avail_3: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_3 = 0 as libc::c_int as size_t;
            }
            if amount_3 > avail_3 {
                amount_3 = avail_3;
            }
            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                comp_unit_count = 0 as libc::c_int as uint32_t;
            } else {
                comp_unit_count = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_3 as libc::c_uint) as uint32_t;
            }
            hdrptr = hdrptr.offset(amount_3 as isize);
            if comp_unit_count == 0 as libc::c_int as libc::c_uint {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Compilation unit count must be >= 1 in .debug_names\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            let mut amount_4: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint32_t>() as libc::c_ulong) < amount_4 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_4,
                        5 as libc::c_int,
                    ),
                    amount_4 as libc::c_int,
                    ::core::mem::size_of::<uint32_t>() as libc::c_ulong as libc::c_int,
                );
                amount_4 = ::core::mem::size_of::<uint32_t>() as libc::c_ulong;
            }
            let mut avail_4: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_4 = 0 as libc::c_int as size_t;
            }
            if amount_4 > avail_4 {
                amount_4 = avail_4;
            }
            if amount_4 == 0 as libc::c_int as libc::c_ulong {
                local_type_unit_count = 0 as libc::c_int as uint32_t;
            } else {
                local_type_unit_count = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_4 as libc::c_uint) as uint32_t;
            }
            hdrptr = hdrptr.offset(amount_4 as isize);
            let mut amount_5: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint32_t>() as libc::c_ulong) < amount_5 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_5,
                        5 as libc::c_int,
                    ),
                    amount_5 as libc::c_int,
                    ::core::mem::size_of::<uint32_t>() as libc::c_ulong as libc::c_int,
                );
                amount_5 = ::core::mem::size_of::<uint32_t>() as libc::c_ulong;
            }
            let mut avail_5: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_5 = 0 as libc::c_int as size_t;
            }
            if amount_5 > avail_5 {
                amount_5 = avail_5;
            }
            if amount_5 == 0 as libc::c_int as libc::c_ulong {
                foreign_type_unit_count = 0 as libc::c_int as uint32_t;
            } else {
                foreign_type_unit_count = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_5 as libc::c_uint) as uint32_t;
            }
            hdrptr = hdrptr.offset(amount_5 as isize);
            let mut amount_6: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint64_t>() as libc::c_ulong) < amount_6 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_6,
                        5 as libc::c_int,
                    ),
                    amount_6 as libc::c_int,
                    ::core::mem::size_of::<uint64_t>() as libc::c_ulong as libc::c_int,
                );
                amount_6 = ::core::mem::size_of::<uint64_t>() as libc::c_ulong;
            }
            let mut avail_6: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_6 = 0 as libc::c_int as size_t;
            }
            if amount_6 > avail_6 {
                amount_6 = avail_6;
            }
            if amount_6 == 0 as libc::c_int as libc::c_ulong {
                bucket_count = 0 as libc::c_int as uint64_t;
            } else {
                bucket_count = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_6 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_6 as isize);
            let mut amount_7: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint64_t>() as libc::c_ulong) < amount_7 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_7,
                        5 as libc::c_int,
                    ),
                    amount_7 as libc::c_int,
                    ::core::mem::size_of::<uint64_t>() as libc::c_ulong as libc::c_int,
                );
                amount_7 = ::core::mem::size_of::<uint64_t>() as libc::c_ulong;
            }
            let mut avail_7: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_7 = 0 as libc::c_int as size_t;
            }
            if amount_7 > avail_7 {
                amount_7 = avail_7;
            }
            if amount_7 == 0 as libc::c_int as libc::c_ulong {
                name_count = 0 as libc::c_int as uint64_t;
            } else {
                name_count = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_7 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_7 as isize);
            let mut amount_8: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint64_t>() as libc::c_ulong) < amount_8 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_8,
                        5 as libc::c_int,
                    ),
                    amount_8 as libc::c_int,
                    ::core::mem::size_of::<uint64_t>() as libc::c_ulong as libc::c_int,
                );
                amount_8 = ::core::mem::size_of::<uint64_t>() as libc::c_ulong;
            }
            let mut avail_8: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_8 = 0 as libc::c_int as size_t;
            }
            if amount_8 > avail_8 {
                amount_8 = avail_8;
            }
            if amount_8 == 0 as libc::c_int as libc::c_ulong {
                abbrev_table_size = 0 as libc::c_int as uint64_t;
            } else {
                abbrev_table_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_8 as libc::c_uint);
            }
            hdrptr = hdrptr.offset(amount_8 as isize);
            let mut amount_9: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<uint32_t>() as libc::c_ulong) < amount_9 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_9,
                        5 as libc::c_int,
                    ),
                    amount_9 as libc::c_int,
                    ::core::mem::size_of::<uint32_t>() as libc::c_ulong as libc::c_int,
                );
                amount_9 = ::core::mem::size_of::<uint32_t>() as libc::c_ulong;
            }
            let mut avail_9: size_t = unit_end.offset_from(hdrptr) as libc::c_long
                as size_t;
            if hdrptr > unit_end {
                avail_9 = 0 as libc::c_int as size_t;
            }
            if amount_9 > avail_9 {
                amount_9 = avail_9;
            }
            if amount_9 == 0 as libc::c_int as libc::c_ulong {
                augmentation_string_size = 0 as libc::c_int as uint32_t;
            } else {
                augmentation_string_size = byte_get
                    .expect(
                        "non-null function pointer",
                    )(hdrptr, amount_9 as libc::c_uint) as uint32_t;
            }
            hdrptr = hdrptr.offset(amount_9 as isize);
            if augmentation_string_size.wrapping_rem(4 as libc::c_int as libc::c_uint)
                != 0 as libc::c_int as libc::c_uint
            {
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Augmentation string length %u must be rounded up to a multiple of 4 in .debug_names.\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    augmentation_string_size,
                );
                augmentation_string_size = (augmentation_string_size as libc::c_uint)
                    .wrapping_add(
                        augmentation_string_size.wrapping_neg()
                            & 3 as libc::c_int as libc::c_uint,
                    ) as uint32_t as uint32_t;
            }
            if !(augmentation_string_size as libc::c_ulong
                > unit_end.offset_from(hdrptr) as libc::c_long as size_t)
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Augmentation string:\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                augmentation_printable = 1 as libc::c_int != 0;
                augmentation_string = hdrptr as *const libc::c_char;
                i = 0 as libc::c_int as libc::c_uint;
                while i < augmentation_string_size {
                    let mut uc: libc::c_uchar = 0;
                    let mut amount_10: size_t = 1 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
                        < amount_10
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_10,
                                5 as libc::c_int,
                            ),
                            amount_10 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_10 = ::core::mem::size_of::<libc::c_uchar>()
                            as libc::c_ulong;
                    }
                    let mut avail_10: size_t = unit_end.offset_from(hdrptr)
                        as libc::c_long as size_t;
                    if hdrptr > unit_end {
                        avail_10 = 0 as libc::c_int as size_t;
                    }
                    if amount_10 > avail_10 {
                        amount_10 = avail_10;
                    }
                    if amount_10 == 0 as libc::c_int as libc::c_ulong {
                        uc = 0 as libc::c_int as libc::c_uchar;
                    } else {
                        uc = byte_get
                            .expect(
                                "non-null function pointer",
                            )(hdrptr, amount_10 as libc::c_uint) as libc::c_uchar;
                    }
                    hdrptr = hdrptr.offset(amount_10 as isize);
                    printf(
                        b" %02x\0" as *const u8 as *const libc::c_char,
                        uc as libc::c_int,
                    );
                    if uc as libc::c_int != 0 as libc::c_int
                        && _sch_istable[(uc as libc::c_int & 0xff as libc::c_int)
                            as usize] as libc::c_int
                            & _sch_isprint as libc::c_int as libc::c_ushort
                                as libc::c_int == 0
                    {
                        augmentation_printable = 0 as libc::c_int != 0;
                    }
                    i = i.wrapping_add(1);
                    i;
                }
                if augmentation_printable {
                    printf(b"  (\"\0" as *const u8 as *const libc::c_char);
                    i = 0 as libc::c_int as libc::c_uint;
                    while i < augmentation_string_size
                        && *augmentation_string.offset(i as isize) as libc::c_int != 0
                    {
                        putchar(*augmentation_string.offset(i as isize) as libc::c_int);
                        i = i.wrapping_add(1);
                        i;
                    }
                    printf(b"\")\0" as *const u8 as *const libc::c_char);
                }
                putchar('\n' as i32);
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"CU table:\n\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
                total = comp_unit_count as size_t;
                total = (total as libc::c_ulong)
                    .wrapping_mul(offset_size as libc::c_ulong) as size_t as size_t;
                if !(offset_size != 0 as libc::c_int as libc::c_uint
                    && total.wrapping_div(offset_size as libc::c_ulong)
                        != comp_unit_count as libc::c_ulong
                    || total > unit_end.offset_from(hdrptr) as libc::c_long as size_t)
                {
                    i = 0 as libc::c_int as libc::c_uint;
                    while i < comp_unit_count {
                        let mut cu_offset: uint64_t = 0;
                        let mut amount_11: size_t = offset_size as size_t;
                        if (::core::mem::size_of::<uint64_t>() as libc::c_ulong)
                            < amount_11
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_11,
                                    5 as libc::c_int,
                                ),
                                amount_11 as libc::c_int,
                                ::core::mem::size_of::<uint64_t>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_11 = ::core::mem::size_of::<uint64_t>()
                                as libc::c_ulong;
                        }
                        let mut avail_11: size_t = unit_end.offset_from(hdrptr)
                            as libc::c_long as size_t;
                        if hdrptr > unit_end {
                            avail_11 = 0 as libc::c_int as size_t;
                        }
                        if amount_11 > avail_11 {
                            amount_11 = avail_11;
                        }
                        if amount_11 == 0 as libc::c_int as libc::c_ulong {
                            cu_offset = 0 as libc::c_int as uint64_t;
                        } else {
                            cu_offset = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(hdrptr, amount_11 as libc::c_uint);
                        }
                        hdrptr = hdrptr.offset(amount_11 as isize);
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"[%3u] 0x%lx\n\0" as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            i,
                            cu_offset,
                        );
                        i = i.wrapping_add(1);
                        i;
                    }
                    putchar('\n' as i32);
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"TU table:\n\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    total = local_type_unit_count as size_t;
                    total = (total as libc::c_ulong)
                        .wrapping_mul(offset_size as libc::c_ulong) as size_t as size_t;
                    if !(offset_size != 0 as libc::c_int as libc::c_uint
                        && total.wrapping_div(offset_size as libc::c_ulong)
                            != local_type_unit_count as libc::c_ulong
                        || total
                            > unit_end.offset_from(hdrptr) as libc::c_long as size_t)
                    {
                        i = 0 as libc::c_int as libc::c_uint;
                        while i < local_type_unit_count {
                            let mut tu_offset: uint64_t = 0;
                            let mut amount_12: size_t = offset_size as size_t;
                            if (::core::mem::size_of::<uint64_t>() as libc::c_ulong)
                                < amount_12
                            {
                                error(
                                    dcngettext(
                                        0 as *const libc::c_char,
                                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                            as *const u8 as *const libc::c_char,
                                        amount_12,
                                        5 as libc::c_int,
                                    ),
                                    amount_12 as libc::c_int,
                                    ::core::mem::size_of::<uint64_t>() as libc::c_ulong
                                        as libc::c_int,
                                );
                                amount_12 = ::core::mem::size_of::<uint64_t>()
                                    as libc::c_ulong;
                            }
                            let mut avail_12: size_t = unit_end.offset_from(hdrptr)
                                as libc::c_long as size_t;
                            if hdrptr > unit_end {
                                avail_12 = 0 as libc::c_int as size_t;
                            }
                            if amount_12 > avail_12 {
                                amount_12 = avail_12;
                            }
                            if amount_12 == 0 as libc::c_int as libc::c_ulong {
                                tu_offset = 0 as libc::c_int as uint64_t;
                            } else {
                                tu_offset = byte_get
                                    .expect(
                                        "non-null function pointer",
                                    )(hdrptr, amount_12 as libc::c_uint);
                            }
                            hdrptr = hdrptr.offset(amount_12 as isize);
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"[%3u] 0x%lx\n\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                i,
                                tu_offset,
                            );
                            i = i.wrapping_add(1);
                            i;
                        }
                        putchar('\n' as i32);
                        printf(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Foreign TU table:\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                        );
                        total = foreign_type_unit_count as size_t;
                        total = (total as libc::c_ulong)
                            .wrapping_mul(8 as libc::c_int as libc::c_ulong) as size_t
                            as size_t;
                        if !(8 as libc::c_int != 0 as libc::c_int
                            && total.wrapping_div(8 as libc::c_int as libc::c_ulong)
                                != foreign_type_unit_count as libc::c_ulong
                            || total
                                > unit_end.offset_from(hdrptr) as libc::c_long as size_t)
                        {
                            i = 0 as libc::c_int as libc::c_uint;
                            while i < foreign_type_unit_count {
                                let mut signature: uint64_t = 0;
                                let mut amount_13: size_t = 8 as libc::c_int as size_t;
                                if (::core::mem::size_of::<uint64_t>() as libc::c_ulong)
                                    < amount_13
                                {
                                    error(
                                        dcngettext(
                                            0 as *const libc::c_char,
                                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            amount_13,
                                            5 as libc::c_int,
                                        ),
                                        amount_13 as libc::c_int,
                                        ::core::mem::size_of::<uint64_t>() as libc::c_ulong
                                            as libc::c_int,
                                    );
                                    amount_13 = ::core::mem::size_of::<uint64_t>()
                                        as libc::c_ulong;
                                }
                                let mut avail_13: size_t = unit_end.offset_from(hdrptr)
                                    as libc::c_long as size_t;
                                if hdrptr > unit_end {
                                    avail_13 = 0 as libc::c_int as size_t;
                                }
                                if amount_13 > avail_13 {
                                    amount_13 = avail_13;
                                }
                                if amount_13 == 0 as libc::c_int as libc::c_ulong {
                                    signature = 0 as libc::c_int as uint64_t;
                                } else {
                                    signature = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(hdrptr, amount_13 as libc::c_uint);
                                }
                                hdrptr = hdrptr.offset(amount_13 as isize);
                                printf(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"[%3u] \0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    i,
                                );
                                print_dwarf_vma(
                                    signature,
                                    8 as libc::c_int as libc::c_uint,
                                );
                                putchar('\n' as i32);
                                i = i.wrapping_add(1);
                                i;
                            }
                            putchar('\n' as i32);
                            let mut xtra: uint64_t = bucket_count
                                .wrapping_mul(
                                    ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                                )
                                .wrapping_add(
                                    name_count
                                        .wrapping_mul(
                                            (::core::mem::size_of::<uint32_t>() as libc::c_ulong)
                                                .wrapping_add(
                                                    (2 as libc::c_int as libc::c_uint).wrapping_mul(offset_size)
                                                        as libc::c_ulong,
                                                ),
                                        ),
                                )
                                .wrapping_add(abbrev_table_size);
                            if xtra
                                > unit_end.offset_from(hdrptr) as libc::c_long as size_t
                            {
                                warn(
                                    dcgettext(
                                        0 as *const libc::c_char,
                                        b"Entry pool offset (0x%lx) exceeds unit size 0x%lx for unit 0x%lx in the debug_names\n\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    xtra as libc::c_long,
                                    unit_end.offset_from(unit_start) as libc::c_long,
                                    unit_start.offset_from((*section).start) as libc::c_long,
                                );
                                return 0 as libc::c_int;
                            }
                            let hash_table_buckets: *const uint32_t = hdrptr
                                as *mut uint32_t;
                            hdrptr = hdrptr
                                .offset(
                                    bucket_count
                                        .wrapping_mul(
                                            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                                        ) as isize,
                                );
                            let hash_table_hashes: *const uint32_t = hdrptr
                                as *mut uint32_t;
                            hdrptr = hdrptr
                                .offset(
                                    name_count
                                        .wrapping_mul(
                                            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                                        ) as isize,
                                );
                            let name_table_string_offsets: *mut libc::c_uchar = hdrptr;
                            hdrptr = hdrptr
                                .offset(
                                    name_count.wrapping_mul(offset_size as libc::c_ulong)
                                        as isize,
                                );
                            let name_table_entry_offsets: *mut libc::c_uchar = hdrptr;
                            hdrptr = hdrptr
                                .offset(
                                    name_count.wrapping_mul(offset_size as libc::c_ulong)
                                        as isize,
                                );
                            let abbrev_table: *mut libc::c_uchar = hdrptr;
                            hdrptr = hdrptr.offset(abbrev_table_size as isize);
                            let abbrev_table_end: *const libc::c_uchar = hdrptr;
                            let entry_pool: *mut libc::c_uchar = hdrptr;
                            let mut buckets_filled: size_t = 0 as libc::c_int as size_t;
                            let mut bucketi: size_t = 0;
                            bucketi = 0 as libc::c_int as size_t;
                            while bucketi < bucket_count {
                                let bucket: uint32_t = *hash_table_buckets
                                    .offset(bucketi as isize);
                                if bucket != 0 as libc::c_int as libc::c_uint {
                                    buckets_filled = buckets_filled.wrapping_add(1);
                                    buckets_filled;
                                }
                                bucketi = bucketi.wrapping_add(1);
                                bucketi;
                            }
                            printf(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"Used %zu of %lu bucket.\n\0" as *const u8
                                        as *const libc::c_char,
                                    b"Used %zu of %lu buckets.\n\0" as *const u8
                                        as *const libc::c_char,
                                    bucket_count,
                                    5 as libc::c_int,
                                ),
                                buckets_filled,
                                bucket_count,
                            );
                            let mut hash_prev: uint32_t = 0 as libc::c_int as uint32_t;
                            let mut hash_clash_count: size_t = 0 as libc::c_int
                                as size_t;
                            let mut longest_clash: size_t = 0 as libc::c_int as size_t;
                            let mut this_length: size_t = 0 as libc::c_int as size_t;
                            let mut hashi: size_t = 0;
                            hashi = 0 as libc::c_int as size_t;
                            while hashi < name_count {
                                let hash_this: uint32_t = *hash_table_hashes
                                    .offset(hashi as isize);
                                if hashi > 0 as libc::c_int as libc::c_ulong {
                                    if (hash_prev as libc::c_ulong).wrapping_rem(bucket_count)
                                        == (hash_this as libc::c_ulong).wrapping_rem(bucket_count)
                                    {
                                        hash_clash_count = hash_clash_count.wrapping_add(1);
                                        hash_clash_count;
                                        this_length = this_length.wrapping_add(1);
                                        this_length;
                                        longest_clash = if longest_clash > this_length {
                                            longest_clash
                                        } else {
                                            this_length
                                        };
                                    } else {
                                        this_length = 0 as libc::c_int as size_t;
                                    }
                                }
                                hash_prev = hash_this;
                                hashi = hashi.wrapping_add(1);
                                hashi;
                            }
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Out of %lu items there are %zu bucket clashes (longest of %zu entries).\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                name_count,
                                hash_clash_count,
                                longest_clash,
                            );
                            if name_count
                                == buckets_filled.wrapping_add(hash_clash_count)
                            {} else {
                                __assert_fail(
                                    b"name_count == buckets_filled + hash_clash_count\0"
                                        as *const u8 as *const libc::c_char,
                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                    9784 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 56],
                                        &[libc::c_char; 56],
                                    >(
                                        b"int display_debug_names(struct dwarf_section *, void *)\0",
                                    ))
                                        .as_ptr(),
                                );
                            }
                            'c_81133: {
                                if name_count
                                    == buckets_filled.wrapping_add(hash_clash_count)
                                {} else {
                                    __assert_fail(
                                        b"name_count == buckets_filled + hash_clash_count\0"
                                            as *const u8 as *const libc::c_char,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        9784 as libc::c_int as libc::c_uint,
                                        (*::core::mem::transmute::<
                                            &[u8; 56],
                                            &[libc::c_char; 56],
                                        >(
                                            b"int display_debug_names(struct dwarf_section *, void *)\0",
                                        ))
                                            .as_ptr(),
                                    );
                                }
                            };
                            let mut abbrev_lookup: *mut abbrev_lookup_entry = 0
                                as *mut abbrev_lookup_entry;
                            let mut abbrev_lookup_used: size_t = 0 as libc::c_int
                                as size_t;
                            let mut abbrev_lookup_allocated: size_t = 0 as libc::c_int
                                as size_t;
                            let mut abbrevptr: *mut libc::c_uchar = abbrev_table;
                            loop {
                                let mut abbrev_tag: dwarf_vma = 0;
                                let mut _val: dwarf_vma = 0;
                                let mut _len: libc::c_uint = 0;
                                let mut _status: libc::c_int = 0;
                                _val = read_leb128(
                                    abbrevptr,
                                    abbrev_table_end,
                                    0 as libc::c_int != 0,
                                    &mut _len,
                                    &mut _status,
                                );
                                abbrevptr = abbrevptr.offset(_len as isize);
                                abbrev_tag = _val;
                                if abbrev_tag != _val {
                                    _status |= 2 as libc::c_int;
                                }
                                report_leb_status(
                                    _status,
                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                    9800 as libc::c_int as libc::c_ulong,
                                );
                                if abbrev_tag == 0 as libc::c_int as libc::c_ulong {
                                    break;
                                }
                                if abbrev_lookup_used == abbrev_lookup_allocated {
                                    abbrev_lookup_allocated = if 0x100 as libc::c_int
                                        as libc::c_ulong
                                        > abbrev_lookup_allocated
                                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)
                                    {
                                        0x100 as libc::c_int as libc::c_ulong
                                    } else {
                                        abbrev_lookup_allocated
                                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)
                                    };
                                    abbrev_lookup = xrealloc(
                                        abbrev_lookup as *mut libc::c_void,
                                        abbrev_lookup_allocated
                                            .wrapping_mul(
                                                ::core::mem::size_of::<abbrev_lookup_entry>()
                                                    as libc::c_ulong,
                                            ),
                                    ) as *mut abbrev_lookup_entry;
                                }
                                if abbrev_lookup_used < abbrev_lookup_allocated {} else {
                                    __assert_fail(
                                        b"abbrev_lookup_used < abbrev_lookup_allocated\0"
                                            as *const u8 as *const libc::c_char,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        9811 as libc::c_int as libc::c_uint,
                                        (*::core::mem::transmute::<
                                            &[u8; 56],
                                            &[libc::c_char; 56],
                                        >(
                                            b"int display_debug_names(struct dwarf_section *, void *)\0",
                                        ))
                                            .as_ptr(),
                                    );
                                }
                                'c_80980: {
                                    if abbrev_lookup_used < abbrev_lookup_allocated {} else {
                                        __assert_fail(
                                            b"abbrev_lookup_used < abbrev_lookup_allocated\0"
                                                as *const u8 as *const libc::c_char,
                                            b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                            9811 as libc::c_int as libc::c_uint,
                                            (*::core::mem::transmute::<
                                                &[u8; 56],
                                                &[libc::c_char; 56],
                                            >(
                                                b"int display_debug_names(struct dwarf_section *, void *)\0",
                                            ))
                                                .as_ptr(),
                                        );
                                    }
                                };
                                let mut entry: *mut abbrev_lookup_entry = 0
                                    as *mut abbrev_lookup_entry;
                                entry = abbrev_lookup;
                                while entry
                                    < abbrev_lookup.offset(abbrev_lookup_used as isize)
                                {
                                    if (*entry).abbrev_tag == abbrev_tag {
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"Duplicate abbreviation tag %lu in unit 0x%lx in the debug_names\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            abbrev_tag as libc::c_long,
                                            unit_start.offset_from((*section).start) as libc::c_long,
                                        );
                                        break;
                                    } else {
                                        entry = entry.offset(1);
                                        entry;
                                    }
                                }
                                let fresh34 = abbrev_lookup_used;
                                abbrev_lookup_used = abbrev_lookup_used.wrapping_add(1);
                                entry = &mut *abbrev_lookup.offset(fresh34 as isize)
                                    as *mut abbrev_lookup_entry;
                                (*entry).abbrev_tag = abbrev_tag;
                                (*entry).abbrev_lookup_ptr = abbrevptr;
                                let mut _len_0: libc::c_uint = 0;
                                read_leb128(
                                    abbrevptr,
                                    abbrev_table_end,
                                    0 as libc::c_int != 0,
                                    &mut _len_0,
                                    0 as *mut libc::c_int,
                                );
                                abbrevptr = abbrevptr.offset(_len_0 as isize);
                                loop {
                                    let mut xindex: dwarf_vma = 0;
                                    let mut form: dwarf_vma = 0;
                                    let mut _val_0: dwarf_vma = 0;
                                    let mut _len_1: libc::c_uint = 0;
                                    let mut _status_0: libc::c_int = 0;
                                    _val_0 = read_leb128(
                                        abbrevptr,
                                        abbrev_table_end,
                                        0 as libc::c_int != 0,
                                        &mut _len_1,
                                        &mut _status_0,
                                    );
                                    abbrevptr = abbrevptr.offset(_len_1 as isize);
                                    xindex = _val_0;
                                    if xindex != _val_0 {
                                        _status_0 |= 2 as libc::c_int;
                                    }
                                    report_leb_status(
                                        _status_0,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        9833 as libc::c_int as libc::c_ulong,
                                    );
                                    let mut _val_1: dwarf_vma = 0;
                                    let mut _len_2: libc::c_uint = 0;
                                    let mut _status_1: libc::c_int = 0;
                                    _val_1 = read_leb128(
                                        abbrevptr,
                                        abbrev_table_end,
                                        0 as libc::c_int != 0,
                                        &mut _len_2,
                                        &mut _status_1,
                                    );
                                    abbrevptr = abbrevptr.offset(_len_2 as isize);
                                    form = _val_1;
                                    if form != _val_1 {
                                        _status_1 |= 2 as libc::c_int;
                                    }
                                    report_leb_status(
                                        _status_1,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        9834 as libc::c_int as libc::c_ulong,
                                    );
                                    if xindex == 0 as libc::c_int as libc::c_ulong
                                        && form == 0 as libc::c_int as libc::c_ulong
                                    {
                                        break;
                                    }
                                }
                            }
                            printf(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"\nSymbol table:\n\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                            );
                            let mut namei: uint32_t = 0;
                            namei = 0 as libc::c_int as uint32_t;
                            while (namei as libc::c_ulong) < name_count {
                                let mut string_offset: uint64_t = 0;
                                let mut entry_offset: uint64_t = 0;
                                let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                                p = name_table_string_offsets
                                    .offset(namei.wrapping_mul(offset_size) as isize);
                                let mut amount_14: size_t = offset_size as size_t;
                                if (::core::mem::size_of::<uint64_t>() as libc::c_ulong)
                                    < amount_14
                                {
                                    error(
                                        dcngettext(
                                            0 as *const libc::c_char,
                                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            amount_14,
                                            5 as libc::c_int,
                                        ),
                                        amount_14 as libc::c_int,
                                        ::core::mem::size_of::<uint64_t>() as libc::c_ulong
                                            as libc::c_int,
                                    );
                                    amount_14 = ::core::mem::size_of::<uint64_t>()
                                        as libc::c_ulong;
                                }
                                let mut avail_14: size_t = unit_end.offset_from(p)
                                    as libc::c_long as size_t;
                                if p > unit_end {
                                    avail_14 = 0 as libc::c_int as size_t;
                                }
                                if amount_14 > avail_14 {
                                    amount_14 = avail_14;
                                }
                                if amount_14 == 0 as libc::c_int as libc::c_ulong {
                                    string_offset = 0 as libc::c_int as uint64_t;
                                } else {
                                    string_offset = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(p, amount_14 as libc::c_uint);
                                }
                                p = name_table_entry_offsets
                                    .offset(namei.wrapping_mul(offset_size) as isize);
                                let mut amount_15: size_t = offset_size as size_t;
                                if (::core::mem::size_of::<uint64_t>() as libc::c_ulong)
                                    < amount_15
                                {
                                    error(
                                        dcngettext(
                                            0 as *const libc::c_char,
                                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                                as *const u8 as *const libc::c_char,
                                            amount_15,
                                            5 as libc::c_int,
                                        ),
                                        amount_15 as libc::c_int,
                                        ::core::mem::size_of::<uint64_t>() as libc::c_ulong
                                            as libc::c_int,
                                    );
                                    amount_15 = ::core::mem::size_of::<uint64_t>()
                                        as libc::c_ulong;
                                }
                                let mut avail_15: size_t = unit_end.offset_from(p)
                                    as libc::c_long as size_t;
                                if p > unit_end {
                                    avail_15 = 0 as libc::c_int as size_t;
                                }
                                if amount_15 > avail_15 {
                                    amount_15 = avail_15;
                                }
                                if amount_15 == 0 as libc::c_int as libc::c_ulong {
                                    entry_offset = 0 as libc::c_int as uint64_t;
                                } else {
                                    entry_offset = byte_get
                                        .expect(
                                            "non-null function pointer",
                                        )(p, amount_15 as libc::c_uint);
                                }
                                printf(
                                    b"[%3u] #%08x %s:\0" as *const u8 as *const libc::c_char,
                                    namei,
                                    *hash_table_hashes.offset(namei as isize),
                                    fetch_indirect_string(string_offset),
                                );
                                let mut entryptr: *mut libc::c_uchar = entry_pool
                                    .offset(entry_offset as isize);
                                let mut tagno: libc::c_int = -(2 as libc::c_int);
                                let mut second_abbrev_tag: dwarf_vma = -(1 as libc::c_int)
                                    as dwarf_vma;
                                loop {
                                    let mut abbrev_tag_0: dwarf_vma = 0;
                                    let mut dwarf_tag: dwarf_vma = 0;
                                    let mut entry_0: *const abbrev_lookup_entry = 0
                                        as *const abbrev_lookup_entry;
                                    let mut _val_2: dwarf_vma = 0;
                                    let mut _len_3: libc::c_uint = 0;
                                    let mut _status_2: libc::c_int = 0;
                                    _val_2 = read_leb128(
                                        entryptr,
                                        unit_end,
                                        0 as libc::c_int != 0,
                                        &mut _len_3,
                                        &mut _status_2,
                                    );
                                    entryptr = entryptr.offset(_len_3 as isize);
                                    abbrev_tag_0 = _val_2;
                                    if abbrev_tag_0 != _val_2 {
                                        _status_2 |= 2 as libc::c_int;
                                    }
                                    report_leb_status(
                                        _status_2,
                                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                        9870 as libc::c_int as libc::c_ulong,
                                    );
                                    if tagno == -(1 as libc::c_int) {
                                        second_abbrev_tag = abbrev_tag_0;
                                        tagno = 0 as libc::c_int;
                                        entryptr = entry_pool.offset(entry_offset as isize);
                                    } else {
                                        if abbrev_tag_0 == 0 as libc::c_int as libc::c_ulong {
                                            break;
                                        }
                                        if tagno >= 0 as libc::c_int {
                                            printf(
                                                b"%s<%lu>\0" as *const u8 as *const libc::c_char,
                                                if tagno == 0 as libc::c_int
                                                    && second_abbrev_tag == 0 as libc::c_int as libc::c_ulong
                                                {
                                                    b" \0" as *const u8 as *const libc::c_char
                                                } else {
                                                    b"\n\t\0" as *const u8 as *const libc::c_char
                                                },
                                                abbrev_tag_0,
                                            );
                                        }
                                        entry_0 = abbrev_lookup;
                                        while entry_0
                                            < abbrev_lookup.offset(abbrev_lookup_used as isize)
                                                as *const abbrev_lookup_entry
                                        {
                                            if (*entry_0).abbrev_tag == abbrev_tag_0 {
                                                break;
                                            }
                                            entry_0 = entry_0.offset(1);
                                            entry_0;
                                        }
                                        if entry_0
                                            >= abbrev_lookup.offset(abbrev_lookup_used as isize)
                                                as *const abbrev_lookup_entry
                                        {
                                            warn(
                                                dcgettext(
                                                    0 as *const libc::c_char,
                                                    b"Undefined abbreviation tag %lu in unit 0x%lx in the debug_names\n\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abbrev_tag_0 as libc::c_long,
                                                unit_start.offset_from((*section).start) as libc::c_long,
                                            );
                                            break;
                                        } else {
                                            abbrevptr = (*entry_0).abbrev_lookup_ptr;
                                            let mut _val_3: dwarf_vma = 0;
                                            let mut _len_4: libc::c_uint = 0;
                                            let mut _status_3: libc::c_int = 0;
                                            _val_3 = read_leb128(
                                                abbrevptr,
                                                abbrev_table_end,
                                                0 as libc::c_int != 0,
                                                &mut _len_4,
                                                &mut _status_3,
                                            );
                                            abbrevptr = abbrevptr.offset(_len_4 as isize);
                                            dwarf_tag = _val_3;
                                            if dwarf_tag != _val_3 {
                                                _status_3 |= 2 as libc::c_int;
                                            }
                                            report_leb_status(
                                                _status_3,
                                                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                                9899 as libc::c_int as libc::c_ulong,
                                            );
                                            if tagno >= 0 as libc::c_int {
                                                printf(
                                                    b" %s\0" as *const u8 as *const libc::c_char,
                                                    get_TAG_name(dwarf_tag),
                                                );
                                            }
                                            loop {
                                                let mut xindex_0: dwarf_vma = 0;
                                                let mut form_0: dwarf_vma = 0;
                                                let mut _val_4: dwarf_vma = 0;
                                                let mut _len_5: libc::c_uint = 0;
                                                let mut _status_4: libc::c_int = 0;
                                                _val_4 = read_leb128(
                                                    abbrevptr,
                                                    abbrev_table_end,
                                                    0 as libc::c_int != 0,
                                                    &mut _len_5,
                                                    &mut _status_4,
                                                );
                                                abbrevptr = abbrevptr.offset(_len_5 as isize);
                                                xindex_0 = _val_4;
                                                if xindex_0 != _val_4 {
                                                    _status_4 |= 2 as libc::c_int;
                                                }
                                                report_leb_status(
                                                    _status_4,
                                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                                    9906 as libc::c_int as libc::c_ulong,
                                                );
                                                let mut _val_5: dwarf_vma = 0;
                                                let mut _len_6: libc::c_uint = 0;
                                                let mut _status_5: libc::c_int = 0;
                                                _val_5 = read_leb128(
                                                    abbrevptr,
                                                    abbrev_table_end,
                                                    0 as libc::c_int != 0,
                                                    &mut _len_6,
                                                    &mut _status_5,
                                                );
                                                abbrevptr = abbrevptr.offset(_len_6 as isize);
                                                form_0 = _val_5;
                                                if form_0 != _val_5 {
                                                    _status_5 |= 2 as libc::c_int;
                                                }
                                                report_leb_status(
                                                    _status_5,
                                                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                                                    9907 as libc::c_int as libc::c_ulong,
                                                );
                                                if xindex_0 == 0 as libc::c_int as libc::c_ulong
                                                    && form_0 == 0 as libc::c_int as libc::c_ulong
                                                {
                                                    break;
                                                }
                                                if tagno >= 0 as libc::c_int {
                                                    printf(
                                                        b" %s\0" as *const u8 as *const libc::c_char,
                                                        get_IDX_name(xindex_0),
                                                    );
                                                }
                                                entryptr = read_and_display_attr_value(
                                                    0 as libc::c_int as libc::c_ulong,
                                                    form_0,
                                                    0 as libc::c_int as dwarf_signed_vma,
                                                    unit_start,
                                                    entryptr,
                                                    unit_end,
                                                    0 as libc::c_int as dwarf_vma,
                                                    0 as libc::c_int as dwarf_vma,
                                                    offset_size as dwarf_vma,
                                                    dwarf_version as libc::c_int,
                                                    0 as *mut debug_info,
                                                    (tagno < 0 as libc::c_int) as libc::c_int,
                                                    0 as *mut dwarf_section,
                                                    0 as *mut cu_tu_set,
                                                    '=' as i32 as libc::c_char,
                                                    -(1 as libc::c_int),
                                                );
                                            }
                                            tagno += 1;
                                            tagno;
                                        }
                                    }
                                }
                                if tagno <= 0 as libc::c_int {
                                    printf(
                                        dcgettext(
                                            0 as *const libc::c_char,
                                            b" <no entries>\0" as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                    );
                                }
                                putchar('\n' as i32);
                                namei = namei.wrapping_add(1);
                                namei;
                            }
                            free(abbrev_lookup as *mut libc::c_void);
                            hdrptr = unit_end;
                            continue;
                        }
                    }
                }
            }
        }
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Debug info is corrupted, %s header at %#lx has length %s\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
            unit_start.offset_from((*section).start) as libc::c_long as libc::c_ulong,
            dwarf_vmatoa(b"x\0" as *const u8 as *const libc::c_char, unit_length),
        );
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_debug_links(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    let mut filename: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut filelen: libc::c_uint = 0;
    introduce(section, 0 as libc::c_int != 0);
    filename = (*section).start;
    filelen = strnlen(filename as *const libc::c_char, (*section).size) as libc::c_uint;
    if filelen as libc::c_ulong == (*section).size {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"The debuglink filename is corrupt/missing\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"  Separate debug info file: %s\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        filename,
    );
    if startswith(
        (*section).name,
        b".gnu_debuglink\0" as *const u8 as *const libc::c_char,
    ) {
        let mut crc32: libc::c_uint = 0;
        let mut crc_offset: libc::c_uint = 0;
        crc_offset = filelen.wrapping_add(1 as libc::c_int as libc::c_uint);
        crc_offset = crc_offset.wrapping_add(3 as libc::c_int as libc::c_uint)
            & !(3 as libc::c_int) as libc::c_uint;
        if crc_offset.wrapping_add(4 as libc::c_int as libc::c_uint) as libc::c_ulong
            > (*section).size
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"CRC offset missing/truncated\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int;
        }
        crc32 = byte_get
            .expect(
                "non-null function pointer",
            )(filename.offset(crc_offset as isize), 4 as libc::c_int as libc::c_uint)
            as libc::c_uint;
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  CRC value: %#x\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            crc32,
        );
        if (crc_offset.wrapping_add(4 as libc::c_int as libc::c_uint) as libc::c_ulong)
            < (*section).size
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"There are %#lx extraneous bytes at the end of the section\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                ((*section).size)
                    .wrapping_sub(
                        crc_offset.wrapping_add(4 as libc::c_int as libc::c_uint)
                            as libc::c_ulong,
                    ) as libc::c_long,
            );
            return 0 as libc::c_int;
        }
    } else {
        let mut build_id: *const libc::c_uchar = ((*section).start)
            .offset(filelen as isize)
            .offset(1 as libc::c_int as isize);
        let mut build_id_len: bfd_size_type = ((*section).size)
            .wrapping_sub(
                filelen.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
            );
        let mut printed: bfd_size_type = 0;
        if build_id_len < 0x14 as libc::c_int as libc::c_ulong {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Build-ID is too short (%#lx bytes)\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                build_id_len as libc::c_long,
            );
            return 0 as libc::c_int;
        }
        printed = printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Build-ID (%#lx bytes):\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            build_id_len as libc::c_long,
        ) as bfd_size_type;
        display_data(printed, build_id, build_id_len);
        putchar('\n' as i32);
    }
    putchar('\n' as i32);
    return 1 as libc::c_int;
}
unsafe extern "C" fn display_gdb_index(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    let mut start: *mut libc::c_uchar = (*section).start;
    let mut version: uint32_t = 0;
    let mut cu_list_offset: uint32_t = 0;
    let mut tu_list_offset: uint32_t = 0;
    let mut address_table_offset: uint32_t = 0;
    let mut symbol_table_offset: uint32_t = 0;
    let mut constant_pool_offset: uint32_t = 0;
    let mut cu_list_elements: libc::c_uint = 0;
    let mut tu_list_elements: libc::c_uint = 0;
    let mut address_table_size: libc::c_uint = 0;
    let mut symbol_table_slots: libc::c_uint = 0;
    let mut cu_list: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tu_list: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut address_table: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut symbol_table: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut constant_pool: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut i: libc::c_uint = 0;
    introduce(section, 0 as libc::c_int != 0);
    if (*section).size
        < (6 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong)
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Truncated header in the %s section.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    version = byte_get_little_endian(start, 4 as libc::c_int as libc::c_uint)
        as uint32_t;
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"Version %ld\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        version as libc::c_long,
    );
    if version < 3 as libc::c_int as libc::c_uint
        || version > 8 as libc::c_int as libc::c_uint
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unsupported version %lu.\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            version as libc::c_ulong,
        );
        return 0 as libc::c_int;
    }
    if version < 4 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"The address table data in version 3 may be wrong.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    if version < 5 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Version 4 does not support case insensitive lookups.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    if version < 6 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Version 5 does not include inlined functions.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    if version < 7 as libc::c_int as libc::c_uint {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Version 6 does not include symbol attributes.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    cu_list_offset = byte_get_little_endian(
        start.offset(4 as libc::c_int as isize),
        4 as libc::c_int as libc::c_uint,
    ) as uint32_t;
    tu_list_offset = byte_get_little_endian(
        start.offset(8 as libc::c_int as isize),
        4 as libc::c_int as libc::c_uint,
    ) as uint32_t;
    address_table_offset = byte_get_little_endian(
        start.offset(12 as libc::c_int as isize),
        4 as libc::c_int as libc::c_uint,
    ) as uint32_t;
    symbol_table_offset = byte_get_little_endian(
        start.offset(16 as libc::c_int as isize),
        4 as libc::c_int as libc::c_uint,
    ) as uint32_t;
    constant_pool_offset = byte_get_little_endian(
        start.offset(20 as libc::c_int as isize),
        4 as libc::c_int as libc::c_uint,
    ) as uint32_t;
    if cu_list_offset as libc::c_ulong > (*section).size
        || tu_list_offset as libc::c_ulong > (*section).size
        || address_table_offset as libc::c_ulong > (*section).size
        || symbol_table_offset as libc::c_ulong > (*section).size
        || constant_pool_offset as libc::c_ulong > (*section).size
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Corrupt header in the %s section.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    if tu_list_offset < cu_list_offset {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"TU offset (%x) is less than CU offset (%x)\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            tu_list_offset,
            cu_list_offset,
        );
        return 0 as libc::c_int;
    }
    cu_list_elements = tu_list_offset
        .wrapping_sub(cu_list_offset)
        .wrapping_div(8 as libc::c_int as libc::c_uint);
    if address_table_offset < tu_list_offset {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Address table offset (%x) is less than TU offset (%x)\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            address_table_offset,
            tu_list_offset,
        );
        return 0 as libc::c_int;
    }
    tu_list_elements = address_table_offset
        .wrapping_sub(tu_list_offset)
        .wrapping_div(8 as libc::c_int as libc::c_uint);
    if symbol_table_offset < address_table_offset {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Symbol table offset (%x) is less then Address table offset (%x)\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            symbol_table_offset,
            address_table_offset,
        );
        return 0 as libc::c_int;
    }
    address_table_size = symbol_table_offset.wrapping_sub(address_table_offset);
    if constant_pool_offset < symbol_table_offset {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Constant pool offset (%x) is less than symbol table offset (%x)\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            constant_pool_offset,
            symbol_table_offset,
        );
        return 0 as libc::c_int;
    }
    symbol_table_slots = constant_pool_offset
        .wrapping_sub(symbol_table_offset)
        .wrapping_div(8 as libc::c_int as libc::c_uint);
    cu_list = start.offset(cu_list_offset as isize);
    tu_list = start.offset(tu_list_offset as isize);
    address_table = start.offset(address_table_offset as isize);
    symbol_table = start.offset(symbol_table_offset as isize);
    constant_pool = start.offset(constant_pool_offset as isize);
    if address_table_offset.wrapping_add(address_table_size) as libc::c_ulong
        > (*section).size
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Address table extends beyond end of section.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as libc::c_int;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\nCU table:\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    i = 0 as libc::c_int as libc::c_uint;
    while i < cu_list_elements {
        let mut cu_offset: uint64_t = byte_get_little_endian(
            cu_list.offset(i.wrapping_mul(8 as libc::c_int as libc::c_uint) as isize),
            8 as libc::c_int as libc::c_uint,
        );
        let mut cu_length: uint64_t = byte_get_little_endian(
            cu_list
                .offset(i.wrapping_mul(8 as libc::c_int as libc::c_uint) as isize)
                .offset(8 as libc::c_int as isize),
            8 as libc::c_int as libc::c_uint,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"[%3u] 0x%lx - 0x%lx\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            i.wrapping_div(2 as libc::c_int as libc::c_uint),
            cu_offset,
            cu_offset
                .wrapping_add(cu_length)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        );
        i = i.wrapping_add(2 as libc::c_int as libc::c_uint);
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\nTU table:\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    i = 0 as libc::c_int as libc::c_uint;
    while i < tu_list_elements {
        let mut tu_offset: uint64_t = byte_get_little_endian(
            tu_list.offset(i.wrapping_mul(8 as libc::c_int as libc::c_uint) as isize),
            8 as libc::c_int as libc::c_uint,
        );
        let mut type_offset: uint64_t = byte_get_little_endian(
            tu_list
                .offset(i.wrapping_mul(8 as libc::c_int as libc::c_uint) as isize)
                .offset(8 as libc::c_int as isize),
            8 as libc::c_int as libc::c_uint,
        );
        let mut signature: uint64_t = byte_get_little_endian(
            tu_list
                .offset(i.wrapping_mul(8 as libc::c_int as libc::c_uint) as isize)
                .offset(16 as libc::c_int as isize),
            8 as libc::c_int as libc::c_uint,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"[%3u] 0x%lx 0x%lx \0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            i.wrapping_div(3 as libc::c_int as libc::c_uint),
            tu_offset,
            type_offset,
        );
        print_dwarf_vma(signature, 8 as libc::c_int as libc::c_uint);
        printf(b"\n\0" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(3 as libc::c_int as libc::c_uint);
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\nAddress table:\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    i = 0 as libc::c_int as libc::c_uint;
    while i < address_table_size
        && i
            <= address_table_size
                .wrapping_sub(
                    (2 as libc::c_int * 8 as libc::c_int + 4 as libc::c_int)
                        as libc::c_uint,
                )
    {
        let mut low: uint64_t = byte_get_little_endian(
            address_table.offset(i as isize),
            8 as libc::c_int as libc::c_uint,
        );
        let mut high: uint64_t = byte_get_little_endian(
            address_table.offset(i as isize).offset(8 as libc::c_int as isize),
            8 as libc::c_int as libc::c_uint,
        );
        let mut cu_index: uint32_t = byte_get_little_endian(
            address_table.offset(i as isize).offset(16 as libc::c_int as isize),
            4 as libc::c_int as libc::c_uint,
        ) as uint32_t;
        print_dwarf_vma(low, 8 as libc::c_int as libc::c_uint);
        print_dwarf_vma(high, 8 as libc::c_int as libc::c_uint);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"%lu\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            cu_index as libc::c_ulong,
        );
        i = i
            .wrapping_add(
                (2 as libc::c_int * 8 as libc::c_int + 4 as libc::c_int) as libc::c_uint,
            );
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"\nSymbol table:\n\0" as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
    );
    i = 0 as libc::c_int as libc::c_uint;
    while i < symbol_table_slots {
        let mut name_offset: uint32_t = byte_get_little_endian(
            symbol_table
                .offset(i.wrapping_mul(8 as libc::c_int as libc::c_uint) as isize),
            4 as libc::c_int as libc::c_uint,
        ) as uint32_t;
        let mut cu_vector_offset: uint32_t = byte_get_little_endian(
            symbol_table
                .offset(i.wrapping_mul(8 as libc::c_int as libc::c_uint) as isize)
                .offset(4 as libc::c_int as isize),
            4 as libc::c_int as libc::c_uint,
        ) as uint32_t;
        let mut num_cus: uint32_t = 0;
        let mut cu: uint32_t = 0;
        if name_offset != 0 as libc::c_int as libc::c_uint
            || cu_vector_offset != 0 as libc::c_int as libc::c_uint
        {
            let mut j: libc::c_uint = 0;
            if name_offset as libc::c_ulong
                >= ((*section).size).wrapping_sub(constant_pool_offset as libc::c_ulong)
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"[%3u] <corrupt offset: %x>\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    i,
                    name_offset,
                );
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Corrupt name offset of 0x%x found for symbol table slot %d\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    name_offset,
                    i,
                );
            } else {
                printf(
                    b"[%3u] %.*s:\0" as *const u8 as *const libc::c_char,
                    i,
                    ((*section).size)
                        .wrapping_sub(
                            constant_pool_offset.wrapping_add(name_offset)
                                as libc::c_ulong,
                        ) as libc::c_int,
                    constant_pool.offset(name_offset as isize),
                );
            }
            if ((*section).size).wrapping_sub(constant_pool_offset as libc::c_ulong)
                < 4 as libc::c_int as libc::c_ulong
                || cu_vector_offset as libc::c_ulong
                    > ((*section).size)
                        .wrapping_sub(constant_pool_offset as libc::c_ulong)
                        .wrapping_sub(4 as libc::c_int as libc::c_ulong)
            {
                printf(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"<invalid CU vector offset: %x>\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    cu_vector_offset,
                );
                warn(
                    dcgettext(
                        0 as *const libc::c_char,
                        b"Corrupt CU vector offset of 0x%x found for symbol table slot %d\n\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    cu_vector_offset,
                    i,
                );
            } else {
                num_cus = byte_get_little_endian(
                    constant_pool.offset(cu_vector_offset as isize),
                    4 as libc::c_int as libc::c_uint,
                ) as uint32_t;
                if (num_cus as uint64_t).wrapping_mul(4 as libc::c_int as libc::c_ulong)
                    > ((*section).size)
                        .wrapping_sub(
                            constant_pool_offset
                                .wrapping_add(cu_vector_offset)
                                .wrapping_add(4 as libc::c_int as libc::c_uint)
                                as libc::c_ulong,
                        )
                {
                    printf(
                        b"<invalid number of CUs: %d>\n\0" as *const u8
                            as *const libc::c_char,
                        num_cus,
                    );
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Invalid number of CUs (0x%x) for symbol table slot %d\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        num_cus,
                        i,
                    );
                } else {
                    if num_cus > 1 as libc::c_int as libc::c_uint {
                        printf(b"\n\0" as *const u8 as *const libc::c_char);
                    }
                    j = 0 as libc::c_int as libc::c_uint;
                    while j < num_cus {
                        let mut is_static: libc::c_int = 0;
                        let mut kind: gdb_index_symbol_kind = GDB_INDEX_SYMBOL_KIND_NONE;
                        cu = byte_get_little_endian(
                            constant_pool
                                .offset(cu_vector_offset as isize)
                                .offset(4 as libc::c_int as isize)
                                .offset(
                                    j.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,
                                ),
                            4 as libc::c_int as libc::c_uint,
                        ) as uint32_t;
                        is_static = (cu >> 31 as libc::c_int
                            & 1 as libc::c_int as libc::c_uint) as libc::c_int;
                        kind = (cu >> 28 as libc::c_int
                            & 7 as libc::c_int as libc::c_uint) as gdb_index_symbol_kind;
                        cu = cu
                            & (((1 as libc::c_int) << 24 as libc::c_int)
                                - 1 as libc::c_int) as libc::c_uint;
                        if cu
                            >= cu_list_elements
                                .wrapping_div(2 as libc::c_int as libc::c_uint)
                        {
                            printf(
                                b"%cT%lu\0" as *const u8 as *const libc::c_char,
                                if num_cus > 1 as libc::c_int as libc::c_uint {
                                    '\t' as i32
                                } else {
                                    ' ' as i32
                                },
                                cu
                                    .wrapping_sub(
                                        cu_list_elements
                                            .wrapping_div(2 as libc::c_int as libc::c_uint),
                                    ) as libc::c_ulong,
                            );
                        } else {
                            printf(
                                b"%c%lu\0" as *const u8 as *const libc::c_char,
                                if num_cus > 1 as libc::c_int as libc::c_uint {
                                    '\t' as i32
                                } else {
                                    ' ' as i32
                                },
                                cu as libc::c_ulong,
                            );
                        }
                        printf(
                            b" [%s, %s]\0" as *const u8 as *const libc::c_char,
                            if is_static != 0 {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"static\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            } else {
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"global\0" as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                )
                            },
                            get_gdb_index_symbol_kind_name(kind),
                        );
                        if num_cus > 1 as libc::c_int as libc::c_uint {
                            printf(b"\n\0" as *const u8 as *const libc::c_char);
                        }
                        j = j.wrapping_add(1);
                        j;
                    }
                    if num_cus <= 1 as libc::c_int as libc::c_uint {
                        printf(b"\n\0" as *const u8 as *const libc::c_char);
                    }
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn prealloc_cu_tu_list(mut nshndx: libc::c_uint) {
    if shndx_pool.is_null() {
        shndx_pool_size = nshndx;
        shndx_pool_used = 0 as libc::c_int as libc::c_uint;
        shndx_pool = xcmalloc(
            shndx_pool_size as size_t,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong,
        ) as *mut libc::c_uint;
    } else {
        shndx_pool_size = shndx_pool_used.wrapping_add(nshndx);
        shndx_pool = xcrealloc(
            shndx_pool as *mut libc::c_void,
            shndx_pool_size as size_t,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong,
        ) as *mut libc::c_uint;
    };
}
unsafe extern "C" fn add_shndx_to_cu_tu_entry(mut shndx: libc::c_uint) {
    if shndx_pool_used >= shndx_pool_size {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Internal error: out of space in the shndx pool.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return;
    }
    let fresh35 = shndx_pool_used;
    shndx_pool_used = shndx_pool_used.wrapping_add(1);
    *shndx_pool.offset(fresh35 as isize) = shndx;
}
unsafe extern "C" fn end_cu_tu_entry() {
    if shndx_pool_used >= shndx_pool_size {
        error(
            dcgettext(
                0 as *const libc::c_char,
                b"Internal error: out of space in the shndx pool.\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return;
    }
    let fresh36 = shndx_pool_used;
    shndx_pool_used = shndx_pool_used.wrapping_add(1);
    *shndx_pool.offset(fresh36 as isize) = 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn get_DW_SECT_short_name(
    mut dw_sect: libc::c_uint,
) -> *const libc::c_char {
    static mut buf: [libc::c_char; 16] = [0; 16];
    match dw_sect {
        1 => return b"info\0" as *const u8 as *const libc::c_char,
        2 => return b"types\0" as *const u8 as *const libc::c_char,
        3 => return b"abbrev\0" as *const u8 as *const libc::c_char,
        4 => return b"line\0" as *const u8 as *const libc::c_char,
        5 => return b"loc\0" as *const u8 as *const libc::c_char,
        6 => return b"str_off\0" as *const u8 as *const libc::c_char,
        7 => return b"macinfo\0" as *const u8 as *const libc::c_char,
        8 => return b"macro\0" as *const u8 as *const libc::c_char,
        _ => {}
    }
    snprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        b"%d\0" as *const u8 as *const libc::c_char,
        dw_sect,
    );
    return buf.as_mut_ptr();
}
unsafe extern "C" fn process_cu_tu_index(
    mut section: *mut dwarf_section,
    mut do_display: libc::c_int,
) -> libc::c_int {
    let mut phdr: *mut libc::c_uchar = (*section).start;
    let mut limit: *mut libc::c_uchar = phdr.offset((*section).size as isize);
    let mut phash: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut pindex: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut ppool: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut version: libc::c_uint = 0;
    let mut ncols: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut nused: libc::c_uint = 0;
    let mut nslots: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    let mut signature: dwarf_vma = 0;
    let mut total: size_t = 0;
    if phdr.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Section %s is empty\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    if (*section).size < 24 as libc::c_int as libc::c_ulong {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Section %s is too small to contain a CU/TU header\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*section).name,
        );
        return 0 as libc::c_int;
    }
    phash = phdr;
    let mut amount: size_t = 4 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount,
                5 as libc::c_int,
            ),
            amount as libc::c_int,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
        );
        amount = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
    }
    let mut avail: size_t = limit.offset_from(phash) as libc::c_long as size_t;
    if phash > limit {
        avail = 0 as libc::c_int as size_t;
    }
    if amount > avail {
        amount = avail;
    }
    if amount == 0 as libc::c_int as libc::c_ulong {
        version = 0 as libc::c_int as libc::c_uint;
    } else {
        version = byte_get
            .expect("non-null function pointer")(phash, amount as libc::c_uint)
            as libc::c_uint;
    }
    phash = phash.offset(amount as isize);
    if version >= 2 as libc::c_int as libc::c_uint {
        let mut amount_0: size_t = 4 as libc::c_int as size_t;
        if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_0 {
            error(
                dcngettext(
                    0 as *const libc::c_char,
                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                        as *const u8 as *const libc::c_char,
                    amount_0,
                    5 as libc::c_int,
                ),
                amount_0 as libc::c_int,
                ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
            );
            amount_0 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
        }
        let mut avail_0: size_t = limit.offset_from(phash) as libc::c_long as size_t;
        if phash > limit {
            avail_0 = 0 as libc::c_int as size_t;
        }
        if amount_0 > avail_0 {
            amount_0 = avail_0;
        }
        if amount_0 == 0 as libc::c_int as libc::c_ulong {
            ncols = 0 as libc::c_int as libc::c_uint;
        } else {
            ncols = byte_get
                .expect("non-null function pointer")(phash, amount_0 as libc::c_uint)
                as libc::c_uint;
        }
        phash = phash.offset(amount_0 as isize);
    }
    let mut amount_1: size_t = 4 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_1 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_1,
                5 as libc::c_int,
            ),
            amount_1 as libc::c_int,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
        );
        amount_1 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
    }
    let mut avail_1: size_t = limit.offset_from(phash) as libc::c_long as size_t;
    if phash > limit {
        avail_1 = 0 as libc::c_int as size_t;
    }
    if amount_1 > avail_1 {
        amount_1 = avail_1;
    }
    if amount_1 == 0 as libc::c_int as libc::c_ulong {
        nused = 0 as libc::c_int as libc::c_uint;
    } else {
        nused = byte_get
            .expect("non-null function pointer")(phash, amount_1 as libc::c_uint)
            as libc::c_uint;
    }
    phash = phash.offset(amount_1 as isize);
    let mut amount_2: size_t = 4 as libc::c_int as size_t;
    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_2 {
        error(
            dcngettext(
                0 as *const libc::c_char,
                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                    as *const u8 as *const libc::c_char,
                amount_2,
                5 as libc::c_int,
            ),
            amount_2 as libc::c_int,
            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_int,
        );
        amount_2 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
    }
    let mut avail_2: size_t = limit.offset_from(phash) as libc::c_long as size_t;
    if phash > limit {
        avail_2 = 0 as libc::c_int as size_t;
    }
    if amount_2 > avail_2 {
        amount_2 = avail_2;
    }
    if amount_2 == 0 as libc::c_int as libc::c_ulong {
        nslots = 0 as libc::c_int as libc::c_uint;
    } else {
        nslots = byte_get
            .expect("non-null function pointer")(phash, amount_2 as libc::c_uint)
            as libc::c_uint;
    }
    phash = phash.offset(amount_2 as isize);
    pindex = phash
        .offset(
            (nslots as size_t).wrapping_mul(8 as libc::c_int as libc::c_ulong) as isize,
        );
    ppool = pindex
        .offset(
            (nslots as size_t).wrapping_mul(4 as libc::c_int as libc::c_ulong) as isize,
        );
    if do_display != 0 {
        introduce(section, 0 as libc::c_int != 0);
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Version:                 %u\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            version,
        );
        if version >= 2 as libc::c_int as libc::c_uint {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Number of columns:       %u\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                ncols,
            );
        }
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Number of used entries:  %u\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            nused,
        );
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Number of slots:         %u\n\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            nslots,
        );
    }
    total = nslots as size_t;
    total = (total as libc::c_ulong).wrapping_mul(12 as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    if 12 as libc::c_int != 0 as libc::c_int
        && total.wrapping_div(12 as libc::c_int as libc::c_ulong) != nslots as size_t
        || total > limit.offset_from(phash) as libc::c_long as size_t
    {
        warn(
            dcngettext(
                0 as *const libc::c_char,
                b"Section %s is too small for %u slot\n\0" as *const u8
                    as *const libc::c_char,
                b"Section %s is too small for %u slots\n\0" as *const u8
                    as *const libc::c_char,
                nslots as libc::c_ulong,
                5 as libc::c_int,
            ),
            (*section).name,
            nslots,
        );
        return 0 as libc::c_int;
    }
    if version == 1 as libc::c_int as libc::c_uint {
        if do_display == 0 {
            prealloc_cu_tu_list(
                (limit.offset_from(ppool) as libc::c_long
                    / 4 as libc::c_int as libc::c_long) as libc::c_uint,
            );
        }
        i = 0 as libc::c_int as libc::c_uint;
        while i < nslots {
            let mut shndx_list: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut shndx: libc::c_uint = 0;
            let mut amount_3: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_3 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_3,
                        5 as libc::c_int,
                    ),
                    amount_3 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_3 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_3: size_t = limit.offset_from(phash) as libc::c_long as size_t;
            if phash > limit {
                avail_3 = 0 as libc::c_int as size_t;
            }
            if amount_3 > avail_3 {
                amount_3 = avail_3;
            }
            if amount_3 == 0 as libc::c_int as libc::c_ulong {
                signature = 0 as libc::c_int as dwarf_vma;
            } else {
                signature = byte_get
                    .expect(
                        "non-null function pointer",
                    )(phash, amount_3 as libc::c_uint);
            }
            if signature != 0 as libc::c_int as libc::c_ulong {
                let mut amount_4: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_4 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_4,
                            5 as libc::c_int,
                        ),
                        amount_4 as libc::c_int,
                        ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_4 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
                }
                let mut avail_4: size_t = limit.offset_from(pindex) as libc::c_long
                    as size_t;
                if pindex > limit {
                    avail_4 = 0 as libc::c_int as size_t;
                }
                if amount_4 > avail_4 {
                    amount_4 = avail_4;
                }
                if amount_4 == 0 as libc::c_int as libc::c_ulong {
                    j = 0 as libc::c_int as libc::c_uint;
                } else {
                    j = byte_get
                        .expect(
                            "non-null function pointer",
                        )(pindex, amount_4 as libc::c_uint) as libc::c_uint;
                }
                shndx_list = ppool
                    .offset(j.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize);
                if shndx_list < ppool {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Section index pool located before start of section\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    return 0 as libc::c_int;
                }
                if do_display != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  [%3d] Signature:  0x%s  Sections: \0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            signature,
                        ),
                    );
                }
                loop {
                    if shndx_list >= limit {
                        warn(
                            dcgettext(
                                0 as *const libc::c_char,
                                b"Section %s too small for shndx pool\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*section).name,
                        );
                        return 0 as libc::c_int;
                    }
                    let mut amount_5: size_t = 4 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        < amount_5
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_5,
                                5 as libc::c_int,
                            ),
                            amount_5 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_5 = ::core::mem::size_of::<libc::c_uint>()
                            as libc::c_ulong;
                    }
                    let mut avail_5: size_t = limit.offset_from(shndx_list)
                        as libc::c_long as size_t;
                    if shndx_list > limit {
                        avail_5 = 0 as libc::c_int as size_t;
                    }
                    if amount_5 > avail_5 {
                        amount_5 = avail_5;
                    }
                    if amount_5 == 0 as libc::c_int as libc::c_ulong {
                        shndx = 0 as libc::c_int as libc::c_uint;
                    } else {
                        shndx = byte_get
                            .expect(
                                "non-null function pointer",
                            )(shndx_list, amount_5 as libc::c_uint) as libc::c_uint;
                    }
                    if shndx == 0 as libc::c_int as libc::c_uint {
                        break;
                    }
                    if do_display != 0 {
                        printf(b" %d\0" as *const u8 as *const libc::c_char, shndx);
                    } else {
                        add_shndx_to_cu_tu_entry(shndx);
                    }
                    shndx_list = shndx_list.offset(4 as libc::c_int as isize);
                }
                if do_display != 0 {
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                } else {
                    end_cu_tu_entry();
                }
            }
            phash = phash.offset(8 as libc::c_int as isize);
            pindex = pindex.offset(4 as libc::c_int as isize);
            i = i.wrapping_add(1);
            i;
        }
    } else if version == 2 as libc::c_int as libc::c_uint {
        let mut val: libc::c_uint = 0;
        let mut dw_sect: libc::c_uint = 0;
        let mut ph: *mut libc::c_uchar = phash;
        let mut pi: *mut libc::c_uchar = pindex;
        let mut poffsets: *mut libc::c_uchar = ppool
            .offset(
                (ncols as size_t).wrapping_mul(4 as libc::c_int as libc::c_ulong)
                    as isize,
            );
        let mut psizes: *mut libc::c_uchar = poffsets
            .offset(
                (nused as size_t)
                    .wrapping_mul(ncols as libc::c_ulong)
                    .wrapping_mul(4 as libc::c_int as libc::c_ulong) as isize,
            );
        let mut is_tu_index: bool = false;
        let mut this_set: *mut cu_tu_set = 0 as *mut cu_tu_set;
        let mut row: libc::c_uint = 0;
        let mut prow: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut temp: size_t = 0;
        is_tu_index = strcmp(
            (*section).name,
            b".debug_tu_index\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int;
        if nused == (1 as libc::c_uint).wrapping_neg()
            || {
                temp = ncols as size_t;
                temp = (temp as libc::c_ulong)
                    .wrapping_mul(4 as libc::c_int as libc::c_ulong) as size_t as size_t;
                4 as libc::c_int != 0 as libc::c_int
                    && temp.wrapping_div(4 as libc::c_int as libc::c_ulong)
                        != ncols as size_t
            }
            || {
                total = (nused as size_t)
                    .wrapping_add(1 as libc::c_int as libc::c_ulong);
                total = (total as libc::c_ulong).wrapping_mul(temp) as size_t as size_t;
                temp != 0 as libc::c_int as libc::c_ulong
                    && total.wrapping_div(temp)
                        != (nused as size_t)
                            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            } || total > limit.offset_from(ppool) as libc::c_long as size_t
        {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"Section %s too small for offset and size tables\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*section).name,
            );
            return 0 as libc::c_int;
        }
        if do_display != 0 {
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Offset table\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                b"  slot  %-16s  \0" as *const u8 as *const libc::c_char,
                if is_tu_index as libc::c_int != 0 {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"signature\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                } else {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"dwo_id\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                },
            );
        } else if is_tu_index {
            tu_count = nused as libc::c_int;
            tu_sets = xcalloc2(
                nused as size_t,
                ::core::mem::size_of::<cu_tu_set>() as libc::c_ulong,
            ) as *mut cu_tu_set;
            this_set = tu_sets;
        } else {
            cu_count = nused as libc::c_int;
            cu_sets = xcalloc2(
                nused as size_t,
                ::core::mem::size_of::<cu_tu_set>() as libc::c_ulong,
            ) as *mut cu_tu_set;
            this_set = cu_sets;
        }
        if do_display != 0 {
            j = 0 as libc::c_int as libc::c_uint;
            while j < ncols {
                let mut p: *mut libc::c_uchar = ppool
                    .offset(j.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize);
                let mut amount_6: size_t = 4 as libc::c_int as size_t;
                if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_6 {
                    error(
                        dcngettext(
                            0 as *const libc::c_char,
                            b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                as *const u8 as *const libc::c_char,
                            amount_6,
                            5 as libc::c_int,
                        ),
                        amount_6 as libc::c_int,
                        ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                            as libc::c_int,
                    );
                    amount_6 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
                }
                let mut avail_6: size_t = limit.offset_from(p) as libc::c_long as size_t;
                if p > limit {
                    avail_6 = 0 as libc::c_int as size_t;
                }
                if amount_6 > avail_6 {
                    amount_6 = avail_6;
                }
                if amount_6 == 0 as libc::c_int as libc::c_ulong {
                    dw_sect = 0 as libc::c_int as libc::c_uint;
                } else {
                    dw_sect = byte_get
                        .expect("non-null function pointer")(p, amount_6 as libc::c_uint)
                        as libc::c_uint;
                }
                printf(
                    b" %8s\0" as *const u8 as *const libc::c_char,
                    get_DW_SECT_short_name(dw_sect),
                );
                j = j.wrapping_add(1);
                j;
            }
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
        i = 0 as libc::c_int as libc::c_uint;
        while i < nslots {
            let mut amount_7: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_7 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_7,
                        5 as libc::c_int,
                    ),
                    amount_7 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_7 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_7: size_t = limit.offset_from(ph) as libc::c_long as size_t;
            if ph > limit {
                avail_7 = 0 as libc::c_int as size_t;
            }
            if amount_7 > avail_7 {
                amount_7 = avail_7;
            }
            if amount_7 == 0 as libc::c_int as libc::c_ulong {
                signature = 0 as libc::c_int as dwarf_vma;
            } else {
                signature = byte_get
                    .expect("non-null function pointer")(ph, amount_7 as libc::c_uint);
            }
            let mut amount_8: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_8 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_8,
                        5 as libc::c_int,
                    ),
                    amount_8 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_8 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
            }
            let mut avail_8: size_t = limit.offset_from(pi) as libc::c_long as size_t;
            if pi > limit {
                avail_8 = 0 as libc::c_int as size_t;
            }
            if amount_8 > avail_8 {
                amount_8 = avail_8;
            }
            if amount_8 == 0 as libc::c_int as libc::c_ulong {
                row = 0 as libc::c_int as libc::c_uint;
            } else {
                row = byte_get
                    .expect("non-null function pointer")(pi, amount_8 as libc::c_uint)
                    as libc::c_uint;
            }
            if row != 0 as libc::c_int as libc::c_uint {
                if row > nused {
                    warn(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"Row index (%u) is larger than number of used entries (%u)\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        row,
                        nused,
                    );
                    return 0 as libc::c_int;
                }
                if do_display == 0 {
                    let mut num_copy: size_t = ::core::mem::size_of::<uint64_t>()
                        as libc::c_ulong;
                    memcpy(
                        &mut (*this_set
                            .offset(
                                row.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                            ))
                            .signature as *mut uint64_t as *mut libc::c_void,
                        ph as *const libc::c_void,
                        num_copy,
                    );
                }
                prow = poffsets
                    .offset(
                        row
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            .wrapping_mul(ncols)
                            .wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,
                    );
                if do_display != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  [%3d] 0x%s\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            signature,
                        ),
                    );
                }
                j = 0 as libc::c_int as libc::c_uint;
                while j < ncols {
                    let mut p_0: *mut libc::c_uchar = prow
                        .offset(
                            j.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,
                        );
                    let mut amount_9: size_t = 4 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        < amount_9
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_9,
                                5 as libc::c_int,
                            ),
                            amount_9 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_9 = ::core::mem::size_of::<libc::c_uint>()
                            as libc::c_ulong;
                    }
                    let mut avail_9: size_t = limit.offset_from(p_0) as libc::c_long
                        as size_t;
                    if p_0 > limit {
                        avail_9 = 0 as libc::c_int as size_t;
                    }
                    if amount_9 > avail_9 {
                        amount_9 = avail_9;
                    }
                    if amount_9 == 0 as libc::c_int as libc::c_ulong {
                        val = 0 as libc::c_int as libc::c_uint;
                    } else {
                        val = byte_get
                            .expect(
                                "non-null function pointer",
                            )(p_0, amount_9 as libc::c_uint) as libc::c_uint;
                    }
                    if do_display != 0 {
                        printf(b" %8d\0" as *const u8 as *const libc::c_char, val);
                    } else {
                        p_0 = ppool
                            .offset(
                                j.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,
                            );
                        let mut amount_10: size_t = 4 as libc::c_int as size_t;
                        if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                            < amount_10
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_10,
                                    5 as libc::c_int,
                                ),
                                amount_10 as libc::c_int,
                                ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_10 = ::core::mem::size_of::<libc::c_uint>()
                                as libc::c_ulong;
                        }
                        let mut avail_10: size_t = limit.offset_from(p_0) as libc::c_long
                            as size_t;
                        if p_0 > limit {
                            avail_10 = 0 as libc::c_int as size_t;
                        }
                        if amount_10 > avail_10 {
                            amount_10 = avail_10;
                        }
                        if amount_10 == 0 as libc::c_int as libc::c_ulong {
                            dw_sect = 0 as libc::c_int as libc::c_uint;
                        } else {
                            dw_sect = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(p_0, amount_10 as libc::c_uint) as libc::c_uint;
                        }
                        if dw_sect >= DW_SECT_MAX as libc::c_int as libc::c_uint {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Overlarge Dwarf section index detected: %u\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dw_sect,
                            );
                        } else {
                            (*this_set
                                .offset(
                                    row.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                                ))
                                .section_offsets[dw_sect as usize] = val as dwarf_vma;
                        }
                    }
                    j = j.wrapping_add(1);
                    j;
                }
                if do_display != 0 {
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                }
            }
            ph = ph.offset(8 as libc::c_int as isize);
            pi = pi.offset(4 as libc::c_int as isize);
            i = i.wrapping_add(1);
            i;
        }
        ph = phash;
        pi = pindex;
        if do_display != 0 {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
            printf(
                dcgettext(
                    0 as *const libc::c_char,
                    b"  Size table\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            printf(
                b"  slot  %-16s  \0" as *const u8 as *const libc::c_char,
                if is_tu_index as libc::c_int != 0 {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"signature\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                } else {
                    dcgettext(
                        0 as *const libc::c_char,
                        b"dwo_id\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    )
                },
            );
        }
        j = 0 as libc::c_int as libc::c_uint;
        while j < ncols {
            let mut p_1: *mut libc::c_uchar = ppool
                .offset(j.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize);
            let mut amount_11: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_11 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_11,
                        5 as libc::c_int,
                    ),
                    amount_11 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_11 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
            }
            let mut avail_11: size_t = limit.offset_from(p_1) as libc::c_long as size_t;
            if p_1 > limit {
                avail_11 = 0 as libc::c_int as size_t;
            }
            if amount_11 > avail_11 {
                amount_11 = avail_11;
            }
            if amount_11 == 0 as libc::c_int as libc::c_ulong {
                val = 0 as libc::c_int as libc::c_uint;
            } else {
                val = byte_get
                    .expect("non-null function pointer")(p_1, amount_11 as libc::c_uint)
                    as libc::c_uint;
            }
            if do_display != 0 {
                printf(
                    b" %8s\0" as *const u8 as *const libc::c_char,
                    get_DW_SECT_short_name(val),
                );
            }
            j = j.wrapping_add(1);
            j;
        }
        if do_display != 0 {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
        i = 0 as libc::c_int as libc::c_uint;
        while i < nslots {
            let mut amount_12: size_t = 8 as libc::c_int as size_t;
            if (::core::mem::size_of::<dwarf_vma>() as libc::c_ulong) < amount_12 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_12,
                        5 as libc::c_int,
                    ),
                    amount_12 as libc::c_int,
                    ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong as libc::c_int,
                );
                amount_12 = ::core::mem::size_of::<dwarf_vma>() as libc::c_ulong;
            }
            let mut avail_12: size_t = limit.offset_from(ph) as libc::c_long as size_t;
            if ph > limit {
                avail_12 = 0 as libc::c_int as size_t;
            }
            if amount_12 > avail_12 {
                amount_12 = avail_12;
            }
            if amount_12 == 0 as libc::c_int as libc::c_ulong {
                signature = 0 as libc::c_int as dwarf_vma;
            } else {
                signature = byte_get
                    .expect("non-null function pointer")(ph, amount_12 as libc::c_uint);
            }
            let mut amount_13: size_t = 4 as libc::c_int as size_t;
            if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong) < amount_13 {
                error(
                    dcngettext(
                        0 as *const libc::c_char,
                        b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                            as *const u8 as *const libc::c_char,
                        amount_13,
                        5 as libc::c_int,
                    ),
                    amount_13 as libc::c_int,
                    ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                        as libc::c_int,
                );
                amount_13 = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong;
            }
            let mut avail_13: size_t = limit.offset_from(pi) as libc::c_long as size_t;
            if pi > limit {
                avail_13 = 0 as libc::c_int as size_t;
            }
            if amount_13 > avail_13 {
                amount_13 = avail_13;
            }
            if amount_13 == 0 as libc::c_int as libc::c_ulong {
                row = 0 as libc::c_int as libc::c_uint;
            } else {
                row = byte_get
                    .expect("non-null function pointer")(pi, amount_13 as libc::c_uint)
                    as libc::c_uint;
            }
            if row != 0 as libc::c_int as libc::c_uint {
                prow = psizes
                    .offset(
                        row
                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                            .wrapping_mul(ncols)
                            .wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,
                    );
                if do_display != 0 {
                    printf(
                        dcgettext(
                            0 as *const libc::c_char,
                            b"  [%3d] 0x%s\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        i,
                        dwarf_vmatoa(
                            b"x\0" as *const u8 as *const libc::c_char,
                            signature,
                        ),
                    );
                }
                j = 0 as libc::c_int as libc::c_uint;
                while j < ncols {
                    let mut p_2: *mut libc::c_uchar = prow
                        .offset(
                            j.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,
                        );
                    let mut amount_14: size_t = 4 as libc::c_int as size_t;
                    if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        < amount_14
                    {
                        error(
                            dcngettext(
                                0 as *const libc::c_char,
                                b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                    as *const u8 as *const libc::c_char,
                                amount_14,
                                5 as libc::c_int,
                            ),
                            amount_14 as libc::c_int,
                            ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                as libc::c_int,
                        );
                        amount_14 = ::core::mem::size_of::<libc::c_uint>()
                            as libc::c_ulong;
                    }
                    let mut avail_14: size_t = limit.offset_from(p_2) as libc::c_long
                        as size_t;
                    if p_2 > limit {
                        avail_14 = 0 as libc::c_int as size_t;
                    }
                    if amount_14 > avail_14 {
                        amount_14 = avail_14;
                    }
                    if amount_14 == 0 as libc::c_int as libc::c_ulong {
                        val = 0 as libc::c_int as libc::c_uint;
                    } else {
                        val = byte_get
                            .expect(
                                "non-null function pointer",
                            )(p_2, amount_14 as libc::c_uint) as libc::c_uint;
                    }
                    if do_display != 0 {
                        printf(b" %8d\0" as *const u8 as *const libc::c_char, val);
                    } else {
                        p_2 = ppool
                            .offset(
                                j.wrapping_mul(4 as libc::c_int as libc::c_uint) as isize,
                            );
                        let mut amount_15: size_t = 4 as libc::c_int as size_t;
                        if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                            < amount_15
                        {
                            error(
                                dcngettext(
                                    0 as *const libc::c_char,
                                    b"internal error: attempt to read %d byte of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    b"internal error: attempt to read %d bytes of data in to %d sized variable\0"
                                        as *const u8 as *const libc::c_char,
                                    amount_15,
                                    5 as libc::c_int,
                                ),
                                amount_15 as libc::c_int,
                                ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
                                    as libc::c_int,
                            );
                            amount_15 = ::core::mem::size_of::<libc::c_uint>()
                                as libc::c_ulong;
                        }
                        let mut avail_15: size_t = limit.offset_from(p_2) as libc::c_long
                            as size_t;
                        if p_2 > limit {
                            avail_15 = 0 as libc::c_int as size_t;
                        }
                        if amount_15 > avail_15 {
                            amount_15 = avail_15;
                        }
                        if amount_15 == 0 as libc::c_int as libc::c_ulong {
                            dw_sect = 0 as libc::c_int as libc::c_uint;
                        } else {
                            dw_sect = byte_get
                                .expect(
                                    "non-null function pointer",
                                )(p_2, amount_15 as libc::c_uint) as libc::c_uint;
                        }
                        if dw_sect >= DW_SECT_MAX as libc::c_int as libc::c_uint {
                            warn(
                                dcgettext(
                                    0 as *const libc::c_char,
                                    b"Overlarge Dwarf section index detected: %u\n\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                dw_sect,
                            );
                        } else {
                            (*this_set
                                .offset(
                                    row.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                                ))
                                .section_sizes[dw_sect as usize] = val as size_t;
                        }
                    }
                    j = j.wrapping_add(1);
                    j;
                }
                if do_display != 0 {
                    printf(b"\n\0" as *const u8 as *const libc::c_char);
                }
            }
            ph = ph.offset(8 as libc::c_int as isize);
            pi = pi.offset(4 as libc::c_int as isize);
            i = i.wrapping_add(1);
            i;
        }
    } else if do_display != 0 {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"  Unsupported version (%d)\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            version,
        );
    }
    if do_display != 0 {
        printf(b"\n\0" as *const u8 as *const libc::c_char);
    }
    return 1 as libc::c_int;
}
static mut cu_tu_indexes_read: libc::c_int = -(1 as libc::c_int);
unsafe extern "C" fn display_cu_index(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    return process_cu_tu_index(section, 1 as libc::c_int);
}
unsafe extern "C" fn display_debug_not_supported(
    mut section: *mut dwarf_section,
    mut _file: *mut libc::c_void,
) -> libc::c_int {
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"Displaying the debug contents of section %s is not yet supported.\n\0"
                as *const u8 as *const libc::c_char,
            5 as libc::c_int,
        ),
        (*section).name,
    );
    return 1 as libc::c_int;
}
unsafe extern "C" fn calc_gnu_debuglink_crc32(
    mut crc: libc::c_ulong,
    mut buf: *const libc::c_uchar,
    mut len: bfd_size_type,
) -> libc::c_ulong {
    static mut crc32_table: [libc::c_ulong; 256] = [
        0 as libc::c_int as libc::c_ulong,
        0x77073096 as libc::c_int as libc::c_ulong,
        0xee0e612c as libc::c_uint as libc::c_ulong,
        0x990951ba as libc::c_uint as libc::c_ulong,
        0x76dc419 as libc::c_int as libc::c_ulong,
        0x706af48f as libc::c_int as libc::c_ulong,
        0xe963a535 as libc::c_uint as libc::c_ulong,
        0x9e6495a3 as libc::c_uint as libc::c_ulong,
        0xedb8832 as libc::c_int as libc::c_ulong,
        0x79dcb8a4 as libc::c_int as libc::c_ulong,
        0xe0d5e91e as libc::c_uint as libc::c_ulong,
        0x97d2d988 as libc::c_uint as libc::c_ulong,
        0x9b64c2b as libc::c_int as libc::c_ulong,
        0x7eb17cbd as libc::c_int as libc::c_ulong,
        0xe7b82d07 as libc::c_uint as libc::c_ulong,
        0x90bf1d91 as libc::c_uint as libc::c_ulong,
        0x1db71064 as libc::c_int as libc::c_ulong,
        0x6ab020f2 as libc::c_int as libc::c_ulong,
        0xf3b97148 as libc::c_uint as libc::c_ulong,
        0x84be41de as libc::c_uint as libc::c_ulong,
        0x1adad47d as libc::c_int as libc::c_ulong,
        0x6ddde4eb as libc::c_int as libc::c_ulong,
        0xf4d4b551 as libc::c_uint as libc::c_ulong,
        0x83d385c7 as libc::c_uint as libc::c_ulong,
        0x136c9856 as libc::c_int as libc::c_ulong,
        0x646ba8c0 as libc::c_int as libc::c_ulong,
        0xfd62f97a as libc::c_uint as libc::c_ulong,
        0x8a65c9ec as libc::c_uint as libc::c_ulong,
        0x14015c4f as libc::c_int as libc::c_ulong,
        0x63066cd9 as libc::c_int as libc::c_ulong,
        0xfa0f3d63 as libc::c_uint as libc::c_ulong,
        0x8d080df5 as libc::c_uint as libc::c_ulong,
        0x3b6e20c8 as libc::c_int as libc::c_ulong,
        0x4c69105e as libc::c_int as libc::c_ulong,
        0xd56041e4 as libc::c_uint as libc::c_ulong,
        0xa2677172 as libc::c_uint as libc::c_ulong,
        0x3c03e4d1 as libc::c_int as libc::c_ulong,
        0x4b04d447 as libc::c_int as libc::c_ulong,
        0xd20d85fd as libc::c_uint as libc::c_ulong,
        0xa50ab56b as libc::c_uint as libc::c_ulong,
        0x35b5a8fa as libc::c_int as libc::c_ulong,
        0x42b2986c as libc::c_int as libc::c_ulong,
        0xdbbbc9d6 as libc::c_uint as libc::c_ulong,
        0xacbcf940 as libc::c_uint as libc::c_ulong,
        0x32d86ce3 as libc::c_int as libc::c_ulong,
        0x45df5c75 as libc::c_int as libc::c_ulong,
        0xdcd60dcf as libc::c_uint as libc::c_ulong,
        0xabd13d59 as libc::c_uint as libc::c_ulong,
        0x26d930ac as libc::c_int as libc::c_ulong,
        0x51de003a as libc::c_int as libc::c_ulong,
        0xc8d75180 as libc::c_uint as libc::c_ulong,
        0xbfd06116 as libc::c_uint as libc::c_ulong,
        0x21b4f4b5 as libc::c_int as libc::c_ulong,
        0x56b3c423 as libc::c_int as libc::c_ulong,
        0xcfba9599 as libc::c_uint as libc::c_ulong,
        0xb8bda50f as libc::c_uint as libc::c_ulong,
        0x2802b89e as libc::c_int as libc::c_ulong,
        0x5f058808 as libc::c_int as libc::c_ulong,
        0xc60cd9b2 as libc::c_uint as libc::c_ulong,
        0xb10be924 as libc::c_uint as libc::c_ulong,
        0x2f6f7c87 as libc::c_int as libc::c_ulong,
        0x58684c11 as libc::c_int as libc::c_ulong,
        0xc1611dab as libc::c_uint as libc::c_ulong,
        0xb6662d3d as libc::c_uint as libc::c_ulong,
        0x76dc4190 as libc::c_int as libc::c_ulong,
        0x1db7106 as libc::c_int as libc::c_ulong,
        0x98d220bc as libc::c_uint as libc::c_ulong,
        0xefd5102a as libc::c_uint as libc::c_ulong,
        0x71b18589 as libc::c_int as libc::c_ulong,
        0x6b6b51f as libc::c_int as libc::c_ulong,
        0x9fbfe4a5 as libc::c_uint as libc::c_ulong,
        0xe8b8d433 as libc::c_uint as libc::c_ulong,
        0x7807c9a2 as libc::c_int as libc::c_ulong,
        0xf00f934 as libc::c_int as libc::c_ulong,
        0x9609a88e as libc::c_uint as libc::c_ulong,
        0xe10e9818 as libc::c_uint as libc::c_ulong,
        0x7f6a0dbb as libc::c_int as libc::c_ulong,
        0x86d3d2d as libc::c_int as libc::c_ulong,
        0x91646c97 as libc::c_uint as libc::c_ulong,
        0xe6635c01 as libc::c_uint as libc::c_ulong,
        0x6b6b51f4 as libc::c_int as libc::c_ulong,
        0x1c6c6162 as libc::c_int as libc::c_ulong,
        0x856530d8 as libc::c_uint as libc::c_ulong,
        0xf262004e as libc::c_uint as libc::c_ulong,
        0x6c0695ed as libc::c_int as libc::c_ulong,
        0x1b01a57b as libc::c_int as libc::c_ulong,
        0x8208f4c1 as libc::c_uint as libc::c_ulong,
        0xf50fc457 as libc::c_uint as libc::c_ulong,
        0x65b0d9c6 as libc::c_int as libc::c_ulong,
        0x12b7e950 as libc::c_int as libc::c_ulong,
        0x8bbeb8ea as libc::c_uint as libc::c_ulong,
        0xfcb9887c as libc::c_uint as libc::c_ulong,
        0x62dd1ddf as libc::c_int as libc::c_ulong,
        0x15da2d49 as libc::c_int as libc::c_ulong,
        0x8cd37cf3 as libc::c_uint as libc::c_ulong,
        0xfbd44c65 as libc::c_uint as libc::c_ulong,
        0x4db26158 as libc::c_int as libc::c_ulong,
        0x3ab551ce as libc::c_int as libc::c_ulong,
        0xa3bc0074 as libc::c_uint as libc::c_ulong,
        0xd4bb30e2 as libc::c_uint as libc::c_ulong,
        0x4adfa541 as libc::c_int as libc::c_ulong,
        0x3dd895d7 as libc::c_int as libc::c_ulong,
        0xa4d1c46d as libc::c_uint as libc::c_ulong,
        0xd3d6f4fb as libc::c_uint as libc::c_ulong,
        0x4369e96a as libc::c_int as libc::c_ulong,
        0x346ed9fc as libc::c_int as libc::c_ulong,
        0xad678846 as libc::c_uint as libc::c_ulong,
        0xda60b8d0 as libc::c_uint as libc::c_ulong,
        0x44042d73 as libc::c_int as libc::c_ulong,
        0x33031de5 as libc::c_int as libc::c_ulong,
        0xaa0a4c5f as libc::c_uint as libc::c_ulong,
        0xdd0d7cc9 as libc::c_uint as libc::c_ulong,
        0x5005713c as libc::c_int as libc::c_ulong,
        0x270241aa as libc::c_int as libc::c_ulong,
        0xbe0b1010 as libc::c_uint as libc::c_ulong,
        0xc90c2086 as libc::c_uint as libc::c_ulong,
        0x5768b525 as libc::c_int as libc::c_ulong,
        0x206f85b3 as libc::c_int as libc::c_ulong,
        0xb966d409 as libc::c_uint as libc::c_ulong,
        0xce61e49f as libc::c_uint as libc::c_ulong,
        0x5edef90e as libc::c_int as libc::c_ulong,
        0x29d9c998 as libc::c_int as libc::c_ulong,
        0xb0d09822 as libc::c_uint as libc::c_ulong,
        0xc7d7a8b4 as libc::c_uint as libc::c_ulong,
        0x59b33d17 as libc::c_int as libc::c_ulong,
        0x2eb40d81 as libc::c_int as libc::c_ulong,
        0xb7bd5c3b as libc::c_uint as libc::c_ulong,
        0xc0ba6cad as libc::c_uint as libc::c_ulong,
        0xedb88320 as libc::c_uint as libc::c_ulong,
        0x9abfb3b6 as libc::c_uint as libc::c_ulong,
        0x3b6e20c as libc::c_int as libc::c_ulong,
        0x74b1d29a as libc::c_int as libc::c_ulong,
        0xead54739 as libc::c_uint as libc::c_ulong,
        0x9dd277af as libc::c_uint as libc::c_ulong,
        0x4db2615 as libc::c_int as libc::c_ulong,
        0x73dc1683 as libc::c_int as libc::c_ulong,
        0xe3630b12 as libc::c_uint as libc::c_ulong,
        0x94643b84 as libc::c_uint as libc::c_ulong,
        0xd6d6a3e as libc::c_int as libc::c_ulong,
        0x7a6a5aa8 as libc::c_int as libc::c_ulong,
        0xe40ecf0b as libc::c_uint as libc::c_ulong,
        0x9309ff9d as libc::c_uint as libc::c_ulong,
        0xa00ae27 as libc::c_int as libc::c_ulong,
        0x7d079eb1 as libc::c_int as libc::c_ulong,
        0xf00f9344 as libc::c_uint as libc::c_ulong,
        0x8708a3d2 as libc::c_uint as libc::c_ulong,
        0x1e01f268 as libc::c_int as libc::c_ulong,
        0x6906c2fe as libc::c_int as libc::c_ulong,
        0xf762575d as libc::c_uint as libc::c_ulong,
        0x806567cb as libc::c_uint as libc::c_ulong,
        0x196c3671 as libc::c_int as libc::c_ulong,
        0x6e6b06e7 as libc::c_int as libc::c_ulong,
        0xfed41b76 as libc::c_uint as libc::c_ulong,
        0x89d32be0 as libc::c_uint as libc::c_ulong,
        0x10da7a5a as libc::c_int as libc::c_ulong,
        0x67dd4acc as libc::c_int as libc::c_ulong,
        0xf9b9df6f as libc::c_uint as libc::c_ulong,
        0x8ebeeff9 as libc::c_uint as libc::c_ulong,
        0x17b7be43 as libc::c_int as libc::c_ulong,
        0x60b08ed5 as libc::c_int as libc::c_ulong,
        0xd6d6a3e8 as libc::c_uint as libc::c_ulong,
        0xa1d1937e as libc::c_uint as libc::c_ulong,
        0x38d8c2c4 as libc::c_int as libc::c_ulong,
        0x4fdff252 as libc::c_int as libc::c_ulong,
        0xd1bb67f1 as libc::c_uint as libc::c_ulong,
        0xa6bc5767 as libc::c_uint as libc::c_ulong,
        0x3fb506dd as libc::c_int as libc::c_ulong,
        0x48b2364b as libc::c_int as libc::c_ulong,
        0xd80d2bda as libc::c_uint as libc::c_ulong,
        0xaf0a1b4c as libc::c_uint as libc::c_ulong,
        0x36034af6 as libc::c_int as libc::c_ulong,
        0x41047a60 as libc::c_int as libc::c_ulong,
        0xdf60efc3 as libc::c_uint as libc::c_ulong,
        0xa867df55 as libc::c_uint as libc::c_ulong,
        0x316e8eef as libc::c_int as libc::c_ulong,
        0x4669be79 as libc::c_int as libc::c_ulong,
        0xcb61b38c as libc::c_uint as libc::c_ulong,
        0xbc66831a as libc::c_uint as libc::c_ulong,
        0x256fd2a0 as libc::c_int as libc::c_ulong,
        0x5268e236 as libc::c_int as libc::c_ulong,
        0xcc0c7795 as libc::c_uint as libc::c_ulong,
        0xbb0b4703 as libc::c_uint as libc::c_ulong,
        0x220216b9 as libc::c_int as libc::c_ulong,
        0x5505262f as libc::c_int as libc::c_ulong,
        0xc5ba3bbe as libc::c_uint as libc::c_ulong,
        0xb2bd0b28 as libc::c_uint as libc::c_ulong,
        0x2bb45a92 as libc::c_int as libc::c_ulong,
        0x5cb36a04 as libc::c_int as libc::c_ulong,
        0xc2d7ffa7 as libc::c_uint as libc::c_ulong,
        0xb5d0cf31 as libc::c_uint as libc::c_ulong,
        0x2cd99e8b as libc::c_int as libc::c_ulong,
        0x5bdeae1d as libc::c_int as libc::c_ulong,
        0x9b64c2b0 as libc::c_uint as libc::c_ulong,
        0xec63f226 as libc::c_uint as libc::c_ulong,
        0x756aa39c as libc::c_int as libc::c_ulong,
        0x26d930a as libc::c_int as libc::c_ulong,
        0x9c0906a9 as libc::c_uint as libc::c_ulong,
        0xeb0e363f as libc::c_uint as libc::c_ulong,
        0x72076785 as libc::c_int as libc::c_ulong,
        0x5005713 as libc::c_int as libc::c_ulong,
        0x95bf4a82 as libc::c_uint as libc::c_ulong,
        0xe2b87a14 as libc::c_uint as libc::c_ulong,
        0x7bb12bae as libc::c_int as libc::c_ulong,
        0xcb61b38 as libc::c_int as libc::c_ulong,
        0x92d28e9b as libc::c_uint as libc::c_ulong,
        0xe5d5be0d as libc::c_uint as libc::c_ulong,
        0x7cdcefb7 as libc::c_int as libc::c_ulong,
        0xbdbdf21 as libc::c_int as libc::c_ulong,
        0x86d3d2d4 as libc::c_uint as libc::c_ulong,
        0xf1d4e242 as libc::c_uint as libc::c_ulong,
        0x68ddb3f8 as libc::c_int as libc::c_ulong,
        0x1fda836e as libc::c_int as libc::c_ulong,
        0x81be16cd as libc::c_uint as libc::c_ulong,
        0xf6b9265b as libc::c_uint as libc::c_ulong,
        0x6fb077e1 as libc::c_int as libc::c_ulong,
        0x18b74777 as libc::c_int as libc::c_ulong,
        0x88085ae6 as libc::c_uint as libc::c_ulong,
        0xff0f6a70 as libc::c_uint as libc::c_ulong,
        0x66063bca as libc::c_int as libc::c_ulong,
        0x11010b5c as libc::c_int as libc::c_ulong,
        0x8f659eff as libc::c_uint as libc::c_ulong,
        0xf862ae69 as libc::c_uint as libc::c_ulong,
        0x616bffd3 as libc::c_int as libc::c_ulong,
        0x166ccf45 as libc::c_int as libc::c_ulong,
        0xa00ae278 as libc::c_uint as libc::c_ulong,
        0xd70dd2ee as libc::c_uint as libc::c_ulong,
        0x4e048354 as libc::c_int as libc::c_ulong,
        0x3903b3c2 as libc::c_int as libc::c_ulong,
        0xa7672661 as libc::c_uint as libc::c_ulong,
        0xd06016f7 as libc::c_uint as libc::c_ulong,
        0x4969474d as libc::c_int as libc::c_ulong,
        0x3e6e77db as libc::c_int as libc::c_ulong,
        0xaed16a4a as libc::c_uint as libc::c_ulong,
        0xd9d65adc as libc::c_uint as libc::c_ulong,
        0x40df0b66 as libc::c_int as libc::c_ulong,
        0x37d83bf0 as libc::c_int as libc::c_ulong,
        0xa9bcae53 as libc::c_uint as libc::c_ulong,
        0xdebb9ec5 as libc::c_uint as libc::c_ulong,
        0x47b2cf7f as libc::c_int as libc::c_ulong,
        0x30b5ffe9 as libc::c_int as libc::c_ulong,
        0xbdbdf21c as libc::c_uint as libc::c_ulong,
        0xcabac28a as libc::c_uint as libc::c_ulong,
        0x53b39330 as libc::c_int as libc::c_ulong,
        0x24b4a3a6 as libc::c_int as libc::c_ulong,
        0xbad03605 as libc::c_uint as libc::c_ulong,
        0xcdd70693 as libc::c_uint as libc::c_ulong,
        0x54de5729 as libc::c_int as libc::c_ulong,
        0x23d967bf as libc::c_int as libc::c_ulong,
        0xb3667a2e as libc::c_uint as libc::c_ulong,
        0xc4614ab8 as libc::c_uint as libc::c_ulong,
        0x5d681b02 as libc::c_int as libc::c_ulong,
        0x2a6f2b94 as libc::c_int as libc::c_ulong,
        0xb40bbe37 as libc::c_uint as libc::c_ulong,
        0xc30c8ea1 as libc::c_uint as libc::c_ulong,
        0x5a05df1b as libc::c_int as libc::c_ulong,
        0x2d02ef8d as libc::c_int as libc::c_ulong,
    ];
    let mut end: *const libc::c_uchar = 0 as *const libc::c_uchar;
    crc = !crc & 0xffffffff as libc::c_uint as libc::c_ulong;
    end = buf.offset(len as isize);
    while buf < end {
        crc = crc32_table[((crc ^ *buf as libc::c_ulong)
            & 0xff as libc::c_int as libc::c_ulong) as usize] ^ crc >> 8 as libc::c_int;
        buf = buf.offset(1);
        buf;
    }
    return !crc & 0xffffffff as libc::c_uint as libc::c_ulong;
}
unsafe extern "C" fn check_gnu_debuglink(
    mut pathname: *const libc::c_char,
    mut crc_pointer: *mut libc::c_void,
) -> bool {
    static mut buffer: [libc::c_uchar; 8192] = [0; 8192];
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut count: bfd_size_type = 0;
    let mut crc: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut sep_data: *mut libc::c_void = 0 as *mut libc::c_void;
    sep_data = open_debug_file(pathname);
    if sep_data.is_null() {
        return 0 as libc::c_int != 0;
    }
    f = fopen(pathname, b"rb\0" as *const u8 as *const libc::c_char);
    if f.is_null() {
        close_debug_file(sep_data);
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to reopen separate debug info file: %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            pathname,
        );
        return 0 as libc::c_int != 0;
    }
    loop {
        count = fread(
            buffer.as_mut_ptr() as *mut libc::c_void,
            1 as libc::c_int as libc::c_ulong,
            ::core::mem::size_of::<[libc::c_uchar; 8192]>() as libc::c_ulong,
            f,
        );
        if !(count > 0 as libc::c_int as libc::c_ulong) {
            break;
        }
        crc = calc_gnu_debuglink_crc32(crc, buffer.as_mut_ptr(), count);
    }
    fclose(f);
    if crc != *(crc_pointer as *mut libc::c_ulong) {
        close_debug_file(sep_data);
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Separate debug info file %s found, but CRC does not match - ignoring\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            pathname,
        );
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn parse_gnu_debuglink(
    mut section: *mut dwarf_section,
    mut data: *mut libc::c_void,
) -> *const libc::c_char {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut crc_offset: libc::c_uint = 0;
    let mut crc32: *mut libc::c_ulong = data as *mut libc::c_ulong;
    name = (*section).start as *const libc::c_char;
    crc_offset = (strnlen(name, (*section).size))
        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_uint;
    if crc_offset == 1 as libc::c_int as libc::c_uint {
        return 0 as *const libc::c_char;
    }
    crc_offset = crc_offset.wrapping_add(3 as libc::c_int as libc::c_uint)
        & !(3 as libc::c_int) as libc::c_uint;
    if crc_offset.wrapping_add(4 as libc::c_int as libc::c_uint) as libc::c_ulong
        > (*section).size
    {
        return 0 as *const libc::c_char;
    }
    *crc32 = byte_get
        .expect(
            "non-null function pointer",
        )(
        ((*section).start).offset(crc_offset as isize),
        4 as libc::c_int as libc::c_uint,
    );
    return name;
}
unsafe extern "C" fn check_gnu_debugaltlink(
    mut filename: *const libc::c_char,
    mut _data: *mut libc::c_void,
) -> bool {
    let mut sep_data: *mut libc::c_void = open_debug_file(filename);
    if sep_data.is_null() {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn parse_gnu_debugaltlink(
    mut section: *mut dwarf_section,
    mut data: *mut libc::c_void,
) -> *const libc::c_char {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut namelen: bfd_size_type = 0;
    let mut id_len: bfd_size_type = 0;
    let mut build_id_data: *mut Build_id_data = 0 as *mut Build_id_data;
    name = (*section).start as *const libc::c_char;
    namelen = (strnlen(name, (*section).size))
        .wrapping_add(1 as libc::c_int as libc::c_ulong);
    if namelen == 1 as libc::c_int as libc::c_ulong {
        return 0 as *const libc::c_char;
    }
    if namelen >= (*section).size {
        return 0 as *const libc::c_char;
    }
    id_len = ((*section).size).wrapping_sub(namelen);
    if id_len < 0x14 as libc::c_int as libc::c_ulong {
        return 0 as *const libc::c_char;
    }
    build_id_data = data as *mut Build_id_data;
    (*build_id_data).len = id_len;
    (*build_id_data).data = ((*section).start).offset(namelen as isize);
    return name;
}
unsafe extern "C" fn add_separate_debug_file(
    mut filename: *const libc::c_char,
    mut handle: *mut libc::c_void,
) {
    let mut i: *mut separate_info = xmalloc(
        ::core::mem::size_of::<separate_info>() as libc::c_ulong,
    ) as *mut separate_info;
    (*i).filename = filename;
    (*i).handle = handle;
    (*i).next = first_separate_info;
    first_separate_info = i;
}
unsafe extern "C" fn load_separate_debug_info(
    mut main_filename: *const libc::c_char,
    mut xlink: *mut dwarf_section,
    mut parse_func: parse_func_type,
    mut check_func: check_func_type,
    mut func_data: *mut libc::c_void,
    mut _file: *mut libc::c_void,
) -> *mut libc::c_void {
    let mut separate_filename: *const libc::c_char = 0 as *const libc::c_char;
    let mut debug_filename: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut canon_dir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut canon_dirlen: size_t = 0;
    let mut dirlen: size_t = 0;
    separate_filename = parse_func.expect("non-null function pointer")(xlink, func_data);
    if separate_filename.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Corrupt debuglink section: %s\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            if !((*xlink).name).is_null() {
                (*xlink).name
            } else {
                (*xlink).uncompressed_name
            },
        );
        return 0 as *mut libc::c_void;
    }
    canon_dir = lrealpath(main_filename);
    canon_dirlen = strlen(canon_dir);
    while canon_dirlen > 0 as libc::c_int as libc::c_ulong {
        if *canon_dir
            .offset(
                canon_dirlen.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
            ) as libc::c_int == '/' as i32
            || *canon_dir
                .offset(
                    canon_dirlen.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                ) as libc::c_int == '\\' as i32 && 0 as libc::c_int != 0
        {
            break;
        }
        canon_dirlen = canon_dirlen.wrapping_sub(1);
        canon_dirlen;
    }
    *canon_dir.offset(canon_dirlen as isize) = '\0' as i32 as libc::c_char;
    debug_filename = malloc(
        (strlen(b"/lib/debug\0" as *const u8 as *const libc::c_char))
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_add(canon_dirlen)
            .wrapping_add(strlen(b".debug/\0" as *const u8 as *const libc::c_char))
            .wrapping_add(
                strlen(b"/usr/lib/debug\0" as *const u8 as *const libc::c_char),
            )
            .wrapping_add(
                strlen(b"/usr/lib/debug/usr\0" as *const u8 as *const libc::c_char),
            )
            .wrapping_add(strlen(separate_filename))
            .wrapping_add(1 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
    if debug_filename.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        free(canon_dir as *mut libc::c_void);
        return 0 as *mut libc::c_void;
    }
    sprintf(
        debug_filename,
        b"%s\0" as *const u8 as *const libc::c_char,
        separate_filename,
    );
    if !check_func.expect("non-null function pointer")(debug_filename, func_data) {
        sprintf(
            debug_filename,
            b".debug/%s\0" as *const u8 as *const libc::c_char,
            separate_filename,
        );
        if !check_func.expect("non-null function pointer")(debug_filename, func_data) {
            sprintf(
                debug_filename,
                b"%s%s\0" as *const u8 as *const libc::c_char,
                canon_dir,
                separate_filename,
            );
            if !check_func.expect("non-null function pointer")(debug_filename, func_data)
            {
                sprintf(
                    debug_filename,
                    b"%s.debug/%s\0" as *const u8 as *const libc::c_char,
                    canon_dir,
                    separate_filename,
                );
                if !check_func
                    .expect("non-null function pointer")(debug_filename, func_data)
                {
                    sprintf(
                        debug_filename,
                        b"%s/%s\0" as *const u8 as *const libc::c_char,
                        b"/usr/lib/debug\0" as *const u8 as *const libc::c_char,
                        separate_filename,
                    );
                    if !check_func
                        .expect("non-null function pointer")(debug_filename, func_data)
                    {
                        sprintf(
                            debug_filename,
                            b"%s/%s/%s\0" as *const u8 as *const libc::c_char,
                            b"/usr/lib/debug\0" as *const u8 as *const libc::c_char,
                            canon_dir,
                            separate_filename,
                        );
                        if !check_func
                            .expect(
                                "non-null function pointer",
                            )(debug_filename, func_data)
                        {
                            sprintf(
                                debug_filename,
                                b"%s/%s\0" as *const u8 as *const libc::c_char,
                                b"/usr/lib/debug/usr\0" as *const u8 as *const libc::c_char,
                                separate_filename,
                            );
                            if !check_func
                                .expect(
                                    "non-null function pointer",
                                )(debug_filename, func_data)
                            {
                                strcpy(
                                    debug_filename,
                                    b"/lib/debug\0" as *const u8 as *const libc::c_char,
                                );
                                dirlen = (strlen(
                                    b"/lib/debug\0" as *const u8 as *const libc::c_char,
                                ))
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong);
                                if dirlen > 0 as libc::c_int as libc::c_ulong
                                    && (*::core::mem::transmute::<
                                        &[u8; 11],
                                        &[libc::c_char; 11],
                                    >(b"/lib/debug\0"))[dirlen as usize] as libc::c_int
                                        != '/' as i32
                                {
                                    strcat(
                                        debug_filename,
                                        b"/\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                strcat(debug_filename, separate_filename);
                                if !check_func
                                    .expect(
                                        "non-null function pointer",
                                    )(debug_filename, func_data)
                                {
                                    if do_debug_links != 0 {
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"could not find separate debug file '%s'\n\0" as *const u8
                                                    as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            separate_filename,
                                        );
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"tried: %s\n\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            debug_filename,
                                        );
                                        sprintf(
                                            debug_filename,
                                            b"%s/%s\0" as *const u8 as *const libc::c_char,
                                            b"/usr/lib/debug/usr\0" as *const u8 as *const libc::c_char,
                                            separate_filename,
                                        );
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"tried: %s\n\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            debug_filename,
                                        );
                                        sprintf(
                                            debug_filename,
                                            b"%s/%s/%s\0" as *const u8 as *const libc::c_char,
                                            b"/usr/lib/debug\0" as *const u8 as *const libc::c_char,
                                            canon_dir,
                                            separate_filename,
                                        );
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"tried: %s\n\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            debug_filename,
                                        );
                                        sprintf(
                                            debug_filename,
                                            b"%s/%s\0" as *const u8 as *const libc::c_char,
                                            b"/usr/lib/debug\0" as *const u8 as *const libc::c_char,
                                            separate_filename,
                                        );
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"tried: %s\n\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            debug_filename,
                                        );
                                        sprintf(
                                            debug_filename,
                                            b"%s.debug/%s\0" as *const u8 as *const libc::c_char,
                                            canon_dir,
                                            separate_filename,
                                        );
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"tried: %s\n\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            debug_filename,
                                        );
                                        sprintf(
                                            debug_filename,
                                            b"%s%s\0" as *const u8 as *const libc::c_char,
                                            canon_dir,
                                            separate_filename,
                                        );
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"tried: %s\n\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            debug_filename,
                                        );
                                        sprintf(
                                            debug_filename,
                                            b".debug/%s\0" as *const u8 as *const libc::c_char,
                                            separate_filename,
                                        );
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"tried: %s\n\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            debug_filename,
                                        );
                                        sprintf(
                                            debug_filename,
                                            b"%s\0" as *const u8 as *const libc::c_char,
                                            separate_filename,
                                        );
                                        warn(
                                            dcgettext(
                                                0 as *const libc::c_char,
                                                b"tried: %s\n\0" as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            debug_filename,
                                        );
                                    }
                                    free(canon_dir as *mut libc::c_void);
                                    free(debug_filename as *mut libc::c_void);
                                    return 0 as *mut libc::c_void;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    free(canon_dir as *mut libc::c_void);
    let mut debug_handle: *mut libc::c_void = 0 as *mut libc::c_void;
    debug_handle = open_debug_file(debug_filename);
    if debug_handle.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"failed to open separate debug file: %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            debug_filename,
        );
        free(debug_filename as *mut libc::c_void);
        return 0 as *mut libc::c_void;
    }
    if do_debug_links != 0 {
        printf(
            dcgettext(
                0 as *const libc::c_char,
                b"\n%s: Found separate debug info file: %s\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            main_filename,
            debug_filename,
        );
    }
    add_separate_debug_file(debug_filename, debug_handle);
    return debug_handle;
}
unsafe extern "C" fn load_dwo_file(
    mut main_filename: *const libc::c_char,
    mut name: *const libc::c_char,
    mut dir: *const libc::c_char,
    mut _id: *const libc::c_char,
) -> *mut libc::c_void {
    let mut separate_filename: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut separate_handle: *mut libc::c_void = 0 as *mut libc::c_void;
    if *name.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32
        || *name.offset(0 as libc::c_int as isize) as libc::c_int == '\\' as i32
            && 0 as libc::c_int != 0
        || *name.offset(0 as libc::c_int as isize) as libc::c_int != 0
            && *name.offset(1 as libc::c_int as isize) as libc::c_int == ':' as i32
            && 0 as libc::c_int != 0
    {
        separate_filename = strdup(name);
    } else {
        separate_filename = concat(
            dir,
            b"/\0" as *const u8 as *const libc::c_char,
            name,
            0 as *mut libc::c_void,
        );
    }
    if separate_filename.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Out of memory allocating dwo filename\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 0 as *mut libc::c_void;
    }
    separate_handle = open_debug_file(separate_filename);
    if separate_handle.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"Unable to load dwo file: %s\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            separate_filename,
        );
        free(separate_filename as *mut libc::c_void);
        return 0 as *mut libc::c_void;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"%s: Found separate debug object file: %s\n\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        main_filename,
        separate_filename,
    );
    add_separate_debug_file(separate_filename, separate_handle);
    return separate_handle;
}
unsafe extern "C" fn load_debug_sup_file(
    mut main_filename: *const libc::c_char,
    mut file: *mut libc::c_void,
) {
    if !load_debug_section(debug_sup, file) {
        return;
    }
    let mut section: *mut dwarf_section = 0 as *mut dwarf_section;
    section = &mut (*debug_displays
        .as_mut_ptr()
        .offset(debug_sup as libc::c_int as isize))
        .section;
    if !section.is_null() {} else {
        __assert_fail(
            b"section != NULL\0" as *const u8 as *const libc::c_char,
            b"dwarf.c\0" as *const u8 as *const libc::c_char,
            11252 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 47],
                &[libc::c_char; 47],
            >(b"void load_debug_sup_file(const char *, void *)\0"))
                .as_ptr(),
        );
    }
    'c_109381: {
        if !section.is_null() {} else {
            __assert_fail(
                b"section != NULL\0" as *const u8 as *const libc::c_char,
                b"dwarf.c\0" as *const u8 as *const libc::c_char,
                11252 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 47],
                    &[libc::c_char; 47],
                >(b"void load_debug_sup_file(const char *, void *)\0"))
                    .as_ptr(),
            );
        }
    };
    if ((*section).start).is_null()
        || (*section).size < 5 as libc::c_int as libc::c_ulong
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b".debug_sup section is corrupt/empty\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return;
    }
    if *((*section).start).offset(2 as libc::c_int as isize) as libc::c_int
        != 0 as libc::c_int
    {
        return;
    }
    let mut filename: *const libc::c_char = ((*section).start as *const libc::c_char)
        .offset(3 as libc::c_int as isize);
    if strnlen(
        filename,
        ((*section).size).wrapping_sub(3 as libc::c_int as libc::c_ulong),
    ) == ((*section).size).wrapping_sub(3 as libc::c_int as libc::c_ulong)
    {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"filename in .debug_sup section is corrupt\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return;
    }
    if *filename.offset(0 as libc::c_int as isize) as libc::c_int != '/' as i32
        && !(strchr(main_filename, '/' as i32)).is_null()
    {
        let mut new_name: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut new_len: libc::c_int = 0;
        new_len = asprintf(
            &mut new_name as *mut *mut libc::c_char,
            b"%.*s/%s\0" as *const u8 as *const libc::c_char,
            (strrchr(main_filename, '/' as i32)).offset_from(main_filename)
                as libc::c_long as libc::c_int,
            main_filename,
            filename,
        );
        if new_len < 3 as libc::c_int {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"unable to construct path for supplementary debug file\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            if new_len > -(1 as libc::c_int) {
                free(new_name as *mut libc::c_void);
            }
            return;
        }
        filename = new_name;
    } else {
        filename = strdup(filename);
        if filename.is_null() {
            warn(
                dcgettext(
                    0 as *const libc::c_char,
                    b"out of memory constructing filename for .debug_sup link\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return;
        }
    }
    let mut handle: *mut libc::c_void = open_debug_file(filename);
    if handle.is_null() {
        warn(
            dcgettext(
                0 as *const libc::c_char,
                b"unable to open file '%s' referenced from .debug_sup section\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            filename,
        );
        free(filename as *mut libc::c_void);
        return;
    }
    printf(
        dcgettext(
            0 as *const libc::c_char,
            b"%s: Found supplementary debug file: %s\n\n\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        main_filename,
        filename,
    );
    add_separate_debug_file(filename, handle);
}
unsafe extern "C" fn check_for_and_load_links(
    mut file: *mut libc::c_void,
    mut filename: *const libc::c_char,
) {
    let mut handle: *mut libc::c_void = 0 as *mut libc::c_void;
    if load_debug_section(gnu_debugaltlink, file) {
        let mut build_id_data: Build_id_data = Build_id_data {
            len: 0,
            data: 0 as *const libc::c_uchar,
        };
        handle = load_separate_debug_info(
            filename,
            &mut (*debug_displays
                .as_mut_ptr()
                .offset(gnu_debugaltlink as libc::c_int as isize))
                .section,
            Some(
                parse_gnu_debugaltlink
                    as unsafe extern "C" fn(
                        *mut dwarf_section,
                        *mut libc::c_void,
                    ) -> *const libc::c_char,
            ),
            Some(
                check_gnu_debugaltlink
                    as unsafe extern "C" fn(
                        *const libc::c_char,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            &mut build_id_data as *mut Build_id_data as *mut libc::c_void,
            file,
        );
        if !handle.is_null() {
            if handle == (*first_separate_info).handle {} else {
                __assert_fail(
                    b"handle == first_separate_info->handle\0" as *const u8
                        as *const libc::c_char,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    11336 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 52],
                        &[libc::c_char; 52],
                    >(b"void check_for_and_load_links(void *, const char *)\0"))
                        .as_ptr(),
                );
            }
            'c_111196: {
                if handle == (*first_separate_info).handle {} else {
                    __assert_fail(
                        b"handle == first_separate_info->handle\0" as *const u8
                            as *const libc::c_char,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        11336 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 52],
                            &[libc::c_char; 52],
                        >(b"void check_for_and_load_links(void *, const char *)\0"))
                            .as_ptr(),
                    );
                }
            };
            check_for_and_load_links(
                (*first_separate_info).handle,
                (*first_separate_info).filename,
            );
        }
    }
    if load_debug_section(gnu_debuglink, file) {
        let mut crc32: libc::c_ulong = 0;
        handle = load_separate_debug_info(
            filename,
            &mut (*debug_displays
                .as_mut_ptr()
                .offset(gnu_debuglink as libc::c_int as isize))
                .section,
            Some(
                parse_gnu_debuglink
                    as unsafe extern "C" fn(
                        *mut dwarf_section,
                        *mut libc::c_void,
                    ) -> *const libc::c_char,
            ),
            Some(
                check_gnu_debuglink
                    as unsafe extern "C" fn(
                        *const libc::c_char,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            &mut crc32 as *mut libc::c_ulong as *mut libc::c_void,
            file,
        );
        if !handle.is_null() {
            if handle == (*first_separate_info).handle {} else {
                __assert_fail(
                    b"handle == first_separate_info->handle\0" as *const u8
                        as *const libc::c_char,
                    b"dwarf.c\0" as *const u8 as *const libc::c_char,
                    11354 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 52],
                        &[libc::c_char; 52],
                    >(b"void check_for_and_load_links(void *, const char *)\0"))
                        .as_ptr(),
                );
            }
            'c_109460: {
                if handle == (*first_separate_info).handle {} else {
                    __assert_fail(
                        b"handle == first_separate_info->handle\0" as *const u8
                            as *const libc::c_char,
                        b"dwarf.c\0" as *const u8 as *const libc::c_char,
                        11354 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 52],
                            &[libc::c_char; 52],
                        >(b"void check_for_and_load_links(void *, const char *)\0"))
                            .as_ptr(),
                    );
                }
            };
            check_for_and_load_links(
                (*first_separate_info).handle,
                (*first_separate_info).filename,
            );
        }
    }
    load_debug_sup_file(filename, file);
}
