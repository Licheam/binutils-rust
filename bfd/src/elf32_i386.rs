use ::libc;
use ::c2rust_bitfields;
extern "C" {
    pub type bfd_sym_data_struct;
    pub type bfd_pef_xlib_data_struct;
    pub type bfd_pef_data_struct;
    pub type plugin_data_struct;
    pub type mach_o_fat_data_struct;
    pub type mach_o_data_struct;
    pub type netbsd_core_struct;
    pub type versados_data_struct;
    pub type cisco_core_struct;
    pub type osf_core_struct;
    pub type lynx_core_struct;
    pub type sgi_core_struct;
    pub type hppabsd_core_struct;
    pub type hpux_core_struct;
    pub type som_data_struct;
    pub type trad_core_struct;
    pub type sco5_core_struct;
    pub type sun_core_struct;
    pub type mmo_data_struct;
    pub type elf_strtab_hash;
    pub type dwarf1_debug;
    pub type got_entry;
    pub type plt_entry;
    pub type tekhex_data_struct;
    pub type ihex_data_struct;
    pub type verilog_data_struct;
    pub type srec_data_struct;
    pub type ecoff_tdata;
    pub type xcoff_tdata;
    pub type pe_tdata;
    pub type coff_tdata;
    pub type aout_data_struct;
    pub type bfd_strtab_hash;
    pub type ecoff_debug_swap;
    pub type cie;
    fn bfd_hash_traverse(
        _: *mut bfd_hash_table,
        _: Option::<
            unsafe extern "C" fn(*mut bfd_hash_entry, *mut libc::c_void) -> bool,
        >,
        info: *mut libc::c_void,
    );
    fn bfd_getl64(_: *const libc::c_void) -> bfd_uint64_t;
    fn bfd_getl_signed_64(_: *const libc::c_void) -> bfd_int64_t;
    fn bfd_getl32(_: *const libc::c_void) -> bfd_vma;
    fn bfd_getl_signed_32(_: *const libc::c_void) -> bfd_signed_vma;
    fn bfd_getl16(_: *const libc::c_void) -> bfd_vma;
    fn bfd_getl_signed_16(_: *const libc::c_void) -> bfd_signed_vma;
    fn bfd_putl64(_: bfd_uint64_t, _: *mut libc::c_void);
    fn bfd_putl32(_: bfd_vma, _: *mut libc::c_void);
    fn bfd_putl16(_: bfd_vma, _: *mut libc::c_void);
    fn bfd_alloc(abfd: *mut bfd, wanted: bfd_size_type) -> *mut libc::c_void;
    fn bfd_zalloc(abfd: *mut bfd, wanted: bfd_size_type) -> *mut libc::c_void;
    static mut _bfd_std_section: [asection; 4];
    fn bfd_get_section_by_name(
        abfd: *mut bfd,
        name: *const libc::c_char,
    ) -> *mut asection;
    fn bfd_get_section_contents(
        abfd: *mut bfd,
        section: *mut asection,
        location: *mut libc::c_void,
        offset: file_ptr,
        count: bfd_size_type,
    ) -> bool;
    fn bfd_malloc_and_get_section(
        abfd: *mut bfd,
        section: *mut asection,
        buf: *mut *mut bfd_byte,
    ) -> bool;
    fn bfd_generic_discard_group(abfd: *mut bfd, group: *mut asection) -> bool;
    fn bfd_default_set_arch_mach(
        abfd: *mut bfd,
        arch: bfd_architecture,
        mach: libc::c_ulong,
    ) -> bool;
    fn bfd_set_error(error_tag: bfd_error_type);
    fn _bfd_error_handler(fmt: *const libc::c_char, _: ...);
    fn free(_: *mut libc::c_void);
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strcasecmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn htab_traverse(_: htab_t, _: htab_trav, _: *mut libc::c_void);
    fn dcgettext(
        __domainname: *const libc::c_char,
        __msgid: *const libc::c_char,
        __category: libc::c_int,
    ) -> *mut libc::c_char;
    fn bfd_generic_define_common_symbol(
        output_bfd: *mut bfd,
        info: *mut bfd_link_info,
        h: *mut bfd_link_hash_entry,
    ) -> bool;
    fn unwrap_hash_lookup(
        _: *mut bfd_link_info,
        _: *mut bfd,
        _: *mut bfd_link_hash_entry,
    ) -> *mut bfd_link_hash_entry;
    fn bfd_malloc(_: bfd_size_type) -> *mut libc::c_void;
    fn _bfd_generic_mkarchive(_: *mut bfd) -> bool;
    fn bfd_generic_archive_p(_: *mut bfd) -> bfd_cleanup;
    fn bfd_slurp_armap(_: *mut bfd) -> bool;
    fn _bfd_slurp_extended_name_table(_: *mut bfd) -> bool;
    fn _bfd_write_archive_contents(_: *mut bfd) -> bool;
    fn _bfd_generic_get_elt_at_index(_: *mut bfd, _: symindex) -> *mut bfd;
    fn _bfd_free_cached_info(_: *mut bfd) -> bool;
    fn _bfd_bool_bfd_asymbol_false(_: *mut bfd, _: *mut asymbol) -> bool;
    fn _bfd_bool_bfd_false_error(_: *mut bfd) -> bool;
    fn _bfd_bool_bfd_true(_: *mut bfd) -> bool;
    fn _bfd_bool_bfd_link_true(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_bool_bfd_uint_true(_: *mut bfd, _: libc::c_uint) -> bool;
    fn _bfd_void_bfd_link(_: *mut bfd, _: *mut bfd_link_info);
    fn _bfd_dummy_target(_: *mut bfd) -> bfd_cleanup;
    fn bfd_dont_truncate_arname(
        _: *mut bfd,
        _: *const libc::c_char,
        _: *mut libc::c_char,
    );
    fn _bfd_coff_write_armap(
        _: *mut bfd,
        _: libc::c_uint,
        _: *mut orl,
        _: libc::c_uint,
        _: libc::c_int,
    ) -> bool;
    fn _bfd_generic_read_ar_hdr(_: *mut bfd) -> *mut libc::c_void;
    fn _bfd_generic_write_ar_hdr(_: *mut bfd, _: *mut bfd) -> bool;
    fn bfd_generic_openr_next_archived_file(_: *mut bfd, _: *mut bfd) -> *mut bfd;
    fn bfd_generic_stat_arch_elt(_: *mut bfd, _: *mut stat) -> libc::c_int;
    fn _bfd_generic_get_section_contents(
        _: *mut bfd,
        _: *mut asection,
        _: *mut libc::c_void,
        _: file_ptr,
        _: bfd_size_type,
    ) -> bool;
    fn _bfd_generic_get_section_contents_in_window(
        _: *mut bfd,
        _: *mut asection,
        _: *mut bfd_window,
        _: file_ptr,
        _: bfd_size_type,
    ) -> bool;
    fn _bfd_archive_coff_construct_extended_name_table(
        _: *mut bfd,
        _: *mut *mut libc::c_char,
        _: *mut bfd_size_type,
        _: *mut *const libc::c_char,
    ) -> bool;
    fn _bfd_nosymbols_bfd_make_debug_symbol(
        _: *mut bfd,
        _: *mut libc::c_void,
        _: libc::c_ulong,
    ) -> *mut asymbol;
    fn _bfd_generic_read_minisymbols(
        _: *mut bfd,
        _: bool,
        _: *mut *mut libc::c_void,
        _: *mut libc::c_uint,
    ) -> libc::c_long;
    fn _bfd_generic_minisymbol_to_symbol(
        _: *mut bfd,
        _: bool,
        _: *const libc::c_void,
        _: *mut asymbol,
    ) -> *mut asymbol;
    fn _bfd_generic_link_just_syms(_: *mut asection, _: *mut bfd_link_info);
    fn _bfd_generic_link_split_section(_: *mut bfd, _: *mut bfd_section) -> bool;
    fn _bfd_final_link_relocate(
        _: *const reloc_howto_type,
        _: *mut bfd,
        _: *mut asection,
        _: *mut bfd_byte,
        _: bfd_vma,
        _: bfd_vma,
        _: bfd_vma,
    ) -> bfd_reloc_status_type;
    fn _bfd_clear_contents(
        _: *const reloc_howto_type,
        _: *mut bfd,
        _: *mut asection,
        _: *mut bfd_byte,
        _: bfd_vma,
    ) -> bfd_reloc_status_type;
    fn bfd_assert(_: *const libc::c_char, _: libc::c_int);
    fn _bfd_abort(_: *const libc::c_char, _: libc::c_int, _: *const libc::c_char) -> !;
    fn bfd_generic_relax_section(
        abfd: *mut bfd,
        section: *mut asection,
        _: *mut bfd_link_info,
        _: *mut bool,
    ) -> bool;
    fn bfd_generic_get_relocated_section_contents(
        abfd: *mut bfd,
        link_info: *mut bfd_link_info,
        link_order: *mut bfd_link_order,
        data: *mut bfd_byte,
        relocatable: bool,
        symbols: *mut *mut asymbol,
    ) -> *mut bfd_byte;
    fn _bfd_generic_set_reloc(
        abfd: *mut bfd,
        section: sec_ptr,
        relptr: *mut *mut arelent,
        count: libc::c_uint,
    );
    fn _bfd_unrecognized_reloc(
        abfd: *mut bfd,
        section: sec_ptr,
        r_type: libc::c_uint,
    ) -> bool;
    fn bfd_elf_string_from_elf_section(
        _: *mut bfd,
        _: libc::c_uint,
        _: libc::c_uint,
    ) -> *mut libc::c_char;
    fn bfd_elf_sym_name(
        _: *mut bfd,
        _: *mut Elf_Internal_Shdr,
        _: *mut Elf_Internal_Sym,
        _: *mut asection,
    ) -> *const libc::c_char;
    fn _bfd_elf_copy_private_bfd_data(_: *mut bfd, _: *mut bfd) -> bool;
    fn _bfd_elf_print_private_bfd_data(_: *mut bfd, _: *mut libc::c_void) -> bool;
    fn _bfd_elf_get_symbol_version_string(
        _: *mut bfd,
        _: *mut asymbol,
        _: bool,
        _: *mut bool,
    ) -> *const libc::c_char;
    fn bfd_elf_print_symbol(
        _: *mut bfd,
        _: *mut libc::c_void,
        _: *mut asymbol,
        _: bfd_print_symbol_type,
    );
    fn _bfd_elf_eh_frame_address_size(_: *mut bfd, _: *const asection) -> libc::c_uint;
    fn _bfd_elf_encode_eh_address(
        abfd: *mut bfd,
        info: *mut bfd_link_info,
        osec: *mut asection,
        offset: bfd_vma,
        loc_sec: *mut asection,
        loc_offset: bfd_vma,
        encoded: *mut bfd_vma,
    ) -> bfd_byte;
    fn _bfd_elf_can_make_relative(
        input_bfd: *mut bfd,
        info: *mut bfd_link_info,
        eh_frame_section: *mut asection,
    ) -> bool;
    fn _bfd_elf_rel_local_sym(
        _: *mut bfd,
        _: *mut Elf_Internal_Sym,
        _: *mut *mut asection,
        _: bfd_vma,
    ) -> bfd_vma;
    fn _bfd_elf_section_offset(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
        _: bfd_vma,
    ) -> bfd_vma;
    fn bfd_elf_generic_reloc(
        _: *mut bfd,
        _: *mut arelent,
        _: *mut asymbol,
        _: *mut libc::c_void,
        _: *mut asection,
        _: *mut bfd,
        _: *mut *mut libc::c_char,
    ) -> bfd_reloc_status_type;
    fn bfd_elf_mkcorefile(_: *mut bfd) -> bool;
    fn _bfd_elf_make_section_from_shdr(
        _: *mut bfd,
        _: *mut Elf_Internal_Shdr,
        _: *const libc::c_char,
        _: libc::c_int,
    ) -> bool;
    fn _bfd_elf_make_section_from_phdr(
        _: *mut bfd,
        _: *mut Elf_Internal_Phdr,
        _: libc::c_int,
        _: *const libc::c_char,
    ) -> bool;
    fn _bfd_elf_link_hide_symbol(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut bfd_link_hash_entry,
    );
    fn _bfd_elf_merge_sections(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn bfd_elf_is_group_section(_: *mut bfd, _: *const bfd_section) -> bool;
    fn bfd_elf_group_name(_: *mut bfd, _: *const bfd_section) -> *const libc::c_char;
    fn _bfd_elf_section_already_linked(
        _: *mut bfd,
        _: *mut asection,
        _: *mut bfd_link_info,
    ) -> bool;
    fn _bfd_elf_copy_link_hash_symbol_type(
        _: *mut bfd,
        _: *mut bfd_link_hash_entry,
        _: *mut bfd_link_hash_entry,
    );
    fn _bfd_elf_copy_private_header_data(_: *mut bfd, _: *mut bfd) -> bool;
    fn _bfd_elf_copy_private_symbol_data(
        _: *mut bfd,
        _: *mut asymbol,
        _: *mut bfd,
        _: *mut asymbol,
    ) -> bool;
    fn _bfd_elf_init_private_section_data(
        _: *mut bfd,
        _: *mut asection,
        _: *mut bfd,
        _: *mut asection,
        _: *mut bfd_link_info,
    ) -> bool;
    fn _bfd_elf_copy_private_section_data(
        _: *mut bfd,
        _: *mut asection,
        _: *mut bfd,
        _: *mut asection,
    ) -> bool;
    fn _bfd_elf_write_object_contents(_: *mut bfd) -> bool;
    fn _bfd_elf_write_corefile_contents(_: *mut bfd) -> bool;
    fn _bfd_elf_set_section_contents(
        _: *mut bfd,
        _: sec_ptr,
        _: *const libc::c_void,
        _: file_ptr,
        _: bfd_size_type,
    ) -> bool;
    fn _bfd_elf_get_symtab_upper_bound(_: *mut bfd) -> libc::c_long;
    fn _bfd_elf_canonicalize_symtab(_: *mut bfd, _: *mut *mut asymbol) -> libc::c_long;
    fn _bfd_elf_get_dynamic_symtab_upper_bound(_: *mut bfd) -> libc::c_long;
    fn _bfd_elf_canonicalize_dynamic_symtab(
        _: *mut bfd,
        _: *mut *mut asymbol,
    ) -> libc::c_long;
    fn _bfd_elf_get_reloc_upper_bound(_: *mut bfd, _: sec_ptr) -> libc::c_long;
    fn _bfd_elf_canonicalize_reloc(
        _: *mut bfd,
        _: sec_ptr,
        _: *mut *mut arelent,
        _: *mut *mut asymbol,
    ) -> libc::c_long;
    fn _bfd_elf_make_dynamic_reloc_section(
        _: *mut asection,
        _: *mut bfd,
        _: libc::c_uint,
        _: *mut bfd,
        _: bool,
    ) -> *mut asection;
    fn _bfd_elf_get_dynamic_reloc_upper_bound(_: *mut bfd) -> libc::c_long;
    fn _bfd_elf_canonicalize_dynamic_reloc(
        _: *mut bfd,
        _: *mut *mut arelent,
        _: *mut *mut asymbol,
    ) -> libc::c_long;
    fn _bfd_elf_make_empty_symbol(_: *mut bfd) -> *mut asymbol;
    fn _bfd_elf_get_symbol_info(_: *mut bfd, _: *mut asymbol, _: *mut symbol_info);
    fn _bfd_elf_is_local_label_name(_: *mut bfd, _: *const libc::c_char) -> bool;
    fn _bfd_elf_get_lineno(_: *mut bfd, _: *mut asymbol) -> *mut alent;
    fn _bfd_elf_set_arch_mach(
        _: *mut bfd,
        _: bfd_architecture,
        _: libc::c_ulong,
    ) -> bool;
    fn _bfd_elf_find_nearest_line(
        _: *mut bfd,
        _: *mut *mut asymbol,
        _: *mut asection,
        _: bfd_vma,
        _: *mut *const libc::c_char,
        _: *mut *const libc::c_char,
        _: *mut libc::c_uint,
        _: *mut libc::c_uint,
    ) -> bool;
    fn _bfd_elf_find_line(
        _: *mut bfd,
        _: *mut *mut asymbol,
        _: *mut asymbol,
        _: *mut *const libc::c_char,
        _: *mut libc::c_uint,
    ) -> bool;
    fn _bfd_elf_find_inliner_info(
        _: *mut bfd,
        _: *mut *const libc::c_char,
        _: *mut *const libc::c_char,
        _: *mut libc::c_uint,
    ) -> bool;
    fn _bfd_elf_sizeof_headers(_: *mut bfd, _: *mut bfd_link_info) -> libc::c_int;
    fn _bfd_elf_new_section_hook(_: *mut bfd, _: *mut asection) -> bool;
    fn _bfd_elf_get_sec_type_attr(
        _: *mut bfd,
        _: *mut asection,
    ) -> *const bfd_elf_special_section;
    fn bfd_sym_from_r_symndx(
        _: *mut sym_cache,
        _: *mut bfd,
        _: libc::c_ulong,
    ) -> *mut Elf_Internal_Sym;
    fn bfd_section_from_elf_index(_: *mut bfd, _: libc::c_uint) -> *mut asection;
    fn _bfd_elf_modify_headers(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_elf_default_action_discarded(_: *mut bfd_section) -> libc::c_uint;
    fn _bfd_elf_omit_section_dynsym_all(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
    ) -> bool;
    fn _bfd_elf_create_dynamic_sections(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_elfcore_make_pseudosection(
        _: *mut bfd,
        _: *mut libc::c_char,
        _: size_t,
        _: ufile_ptr,
    ) -> bool;
    fn _bfd_elfcore_strndup(
        _: *mut bfd,
        _: *mut libc::c_char,
        _: size_t,
    ) -> *mut libc::c_char;
    fn _bfd_elf_link_output_relocs(
        _: *mut bfd,
        _: *mut asection,
        _: *mut Elf_Internal_Shdr,
        _: *mut Elf_Internal_Rela,
        _: *mut *mut elf_link_hash_entry,
    ) -> bool;
    fn _bfd_elf_symbol_refs_local_p(
        _: *mut elf_link_hash_entry,
        _: *mut bfd_link_info,
        _: bool,
    ) -> bool;
    fn bfd_elf_define_start_stop(
        _: *mut bfd_link_info,
        _: *const libc::c_char,
        _: *mut asection,
    ) -> *mut bfd_link_hash_entry;
    fn _bfd_elf_init_file_header(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_elf_final_write_processing(_: *mut bfd) -> bool;
    fn bfd_elf32_object_p(_: *mut bfd) -> bfd_cleanup;
    fn bfd_elf32_core_file_p(_: *mut bfd) -> bfd_cleanup;
    fn bfd_elf32_core_file_failing_command(_: *mut bfd) -> *mut libc::c_char;
    fn bfd_elf32_core_file_failing_signal(_: *mut bfd) -> libc::c_int;
    fn bfd_elf32_core_file_matches_executable_p(_: *mut bfd, _: *mut bfd) -> bool;
    fn bfd_elf32_core_file_pid(_: *mut bfd) -> libc::c_int;
    fn _bfd_elf32_core_find_build_id(_: *mut bfd, _: bfd_vma) -> bool;
    fn bfd_elf32_swap_reloc_in(
        _: *mut bfd,
        _: *const bfd_byte,
        _: *mut Elf_Internal_Rela,
    );
    fn bfd_elf32_swap_reloc_out(
        _: *mut bfd,
        _: *const Elf_Internal_Rela,
        _: *mut bfd_byte,
    );
    fn _bfd_elf_default_relocs_compatible(
        _: *const bfd_target,
        _: *const bfd_target,
    ) -> bool;
    fn _bfd_elf_relocs_compatible(_: *const bfd_target, _: *const bfd_target) -> bool;
    fn _bfd_elf_notice_as_needed(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: notice_asneeded_action,
    ) -> bool;
    fn _bfd_elf_archive_symbol_lookup(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *const libc::c_char,
    ) -> *mut bfd_link_hash_entry;
    fn bfd_elf_link_add_symbols(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_elf_close_and_cleanup(_: *mut bfd) -> bool;
    fn _bfd_elf_common_definition(_: *mut Elf_Internal_Sym) -> bool;
    fn _bfd_elf_common_section_index(_: *mut asection) -> libc::c_uint;
    fn _bfd_elf_common_section(_: *mut asection) -> *mut asection;
    fn _bfd_elf_default_got_elt_size(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut elf_link_hash_entry,
        _: *mut bfd,
        _: libc::c_ulong,
    ) -> bfd_vma;
    fn _bfd_elf_rel_vtable_reloc_fn(
        _: *mut bfd,
        _: *mut arelent,
        _: *mut bfd_symbol,
        _: *mut libc::c_void,
        _: *mut asection,
        _: *mut bfd,
        _: *mut *mut libc::c_char,
    ) -> bfd_reloc_status_type;
    fn bfd_elf_final_link(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_elf_gc_keep(info: *mut bfd_link_info);
    fn bfd_elf_gc_mark_dynamic_ref_symbol(
        h: *mut elf_link_hash_entry,
        inf: *mut libc::c_void,
    ) -> bool;
    fn bfd_elf_gc_sections(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn bfd_elf_gc_record_vtinherit(
        _: *mut bfd,
        _: *mut asection,
        _: *mut elf_link_hash_entry,
        _: bfd_vma,
    ) -> bool;
    fn bfd_elf_gc_record_vtentry(
        _: *mut bfd,
        _: *mut asection,
        _: *mut elf_link_hash_entry,
        _: bfd_vma,
    ) -> bool;
    fn _bfd_elf_gc_mark_extra_sections(
        _: *mut bfd_link_info,
        _: elf_gc_mark_hook_fn,
    ) -> bool;
    fn _bfd_elf_is_function_type(_: libc::c_uint) -> bool;
    fn _bfd_elf_maybe_function_sym(
        _: *const asymbol,
        _: *mut asection,
        _: *mut bfd_vma,
    ) -> bfd_size_type;
    fn _bfd_elf_plt_get_reloc_section(
        _: *mut bfd,
        _: *const libc::c_char,
    ) -> *mut asection;
    fn bfd_elf_lookup_section_flags(
        _: *mut bfd_link_info,
        _: *mut flag_info,
        _: *mut asection,
    ) -> bool;
    fn _bfd_elf32_bfd_from_remote_memory(
        templ: *mut bfd,
        ehdr_vma: bfd_vma,
        size: bfd_size_type,
        loadbasep: *mut bfd_vma,
        target_read_memory: Option::<
            unsafe extern "C" fn(bfd_vma, *mut bfd_byte, bfd_size_type) -> libc::c_int,
        >,
    ) -> *mut bfd;
    fn _bfd_elf_single_rel_hdr(sec: *mut asection) -> *mut Elf_Internal_Shdr;
    fn elf_append_rel(_: *mut bfd, _: *mut asection, _: *mut Elf_Internal_Rela);
    fn elf32_r_info(_: bfd_vma, _: bfd_vma) -> bfd_vma;
    fn elf32_r_sym(_: bfd_vma) -> bfd_vma;
    fn _bfd_elf_init_secondary_reloc_section(
        _: *mut bfd,
        _: *mut Elf_Internal_Shdr,
        _: *const libc::c_char,
        _: libc::c_uint,
    ) -> bool;
    fn _bfd_elf_slurp_secondary_reloc_section(
        _: *mut bfd,
        _: *mut asection,
        _: *mut *mut asymbol,
        _: bool,
    ) -> bool;
    fn _bfd_elf_copy_special_section_fields(
        _: *const bfd,
        _: *mut bfd,
        _: *const Elf_Internal_Shdr,
        _: *mut Elf_Internal_Shdr,
    ) -> bool;
    fn _bfd_elf_write_secondary_reloc_section(_: *mut bfd, _: *mut asection) -> bool;
    fn _bfd_x86_elf_mkobject(_: *mut bfd) -> bool;
    fn _bfd_x86_elf_set_tls_module_base(_: *mut bfd_link_info);
    fn _bfd_x86_elf_dtpoff_base(_: *mut bfd_link_info) -> bfd_vma;
    fn _bfd_elf_x86_get_local_sym_hash(
        _: *mut elf_x86_link_hash_table,
        _: *mut bfd,
        _: *const Elf_Internal_Rela,
        _: bool,
    ) -> *mut elf_link_hash_entry;
    fn _bfd_x86_elf_link_hash_table_create(_: *mut bfd) -> *mut bfd_link_hash_table;
    fn _bfd_x86_elf_link_check_relocs(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_elf_x86_valid_reloc_p(
        _: *mut asection,
        _: *mut bfd_link_info,
        _: *mut elf_x86_link_hash_table,
        _: *const Elf_Internal_Rela,
        _: *mut elf_link_hash_entry,
        _: *mut Elf_Internal_Sym,
        _: *mut Elf_Internal_Shdr,
        _: *mut bool,
    ) -> bool;
    fn _bfd_x86_elf_size_dynamic_sections(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_x86_elf_finish_dynamic_sections(
        _: *mut bfd,
        _: *mut bfd_link_info,
    ) -> *mut elf_x86_link_hash_table;
    fn _bfd_x86_elf_always_size_sections(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_x86_elf_merge_symbol_attribute(
        _: *mut elf_link_hash_entry,
        _: libc::c_uint,
        _: bool,
        _: bool,
    );
    fn _bfd_x86_elf_copy_indirect_symbol(
        _: *mut bfd_link_info,
        _: *mut elf_link_hash_entry,
        _: *mut elf_link_hash_entry,
    );
    fn _bfd_x86_elf_fixup_symbol(
        _: *mut bfd_link_info,
        _: *mut elf_link_hash_entry,
    ) -> bool;
    fn _bfd_x86_elf_hash_symbol(_: *mut elf_link_hash_entry) -> bool;
    fn _bfd_x86_elf_adjust_dynamic_symbol(
        _: *mut bfd_link_info,
        _: *mut elf_link_hash_entry,
    ) -> bool;
    fn _bfd_x86_elf_hide_symbol(
        _: *mut bfd_link_info,
        _: *mut elf_link_hash_entry,
        _: bool,
    );
    fn _bfd_x86_elf_link_symbol_references_local(
        _: *mut bfd_link_info,
        _: *mut elf_link_hash_entry,
    ) -> bool;
    fn _bfd_x86_elf_gc_mark_hook(
        _: *mut asection,
        _: *mut bfd_link_info,
        _: *mut Elf_Internal_Rela,
        _: *mut elf_link_hash_entry,
        _: *mut Elf_Internal_Sym,
    ) -> *mut asection;
    fn _bfd_x86_elf_get_synthetic_symtab(
        _: *mut bfd,
        _: libc::c_long,
        _: libc::c_long,
        _: bfd_vma,
        _: *mut elf_x86_plt,
        _: *mut *mut asymbol,
        _: *mut *mut asymbol,
    ) -> libc::c_long;
    fn _bfd_x86_elf_parse_gnu_properties(
        _: *mut bfd,
        _: libc::c_uint,
        _: *mut bfd_byte,
        _: libc::c_uint,
    ) -> elf_property_kind;
    fn _bfd_x86_elf_merge_gnu_properties(
        _: *mut bfd_link_info,
        _: *mut bfd,
        _: *mut bfd,
        _: *mut elf_property,
        _: *mut elf_property,
    ) -> bool;
    fn _bfd_x86_elf_link_fixup_gnu_properties(
        _: *mut bfd_link_info,
        _: *mut *mut elf_property_list,
    );
    fn _bfd_x86_elf_link_setup_gnu_properties(
        _: *mut bfd_link_info,
        _: *mut elf_x86_init_table,
    ) -> *mut bfd;
    fn _bfd_x86_elf_link_fixup_ifunc_symbol(
        _: *mut bfd_link_info,
        _: *mut elf_x86_link_hash_table,
        _: *mut elf_link_hash_entry,
        sym: *mut Elf_Internal_Sym,
    );
    fn _bfd_x86_elf_link_report_relative_reloc(
        _: *mut bfd_link_info,
        _: *mut asection,
        _: *mut elf_link_hash_entry,
        _: *mut Elf_Internal_Sym,
        _: *const libc::c_char,
        _: *const libc::c_void,
    );
    fn elf_vxworks_add_symbol_hook(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut Elf_Internal_Sym,
        _: *mut *const libc::c_char,
        _: *mut flagword,
        _: *mut *mut asection,
        _: *mut bfd_vma,
    ) -> bool;
    fn elf_vxworks_link_output_symbol_hook(
        _: *mut bfd_link_info,
        name: *const libc::c_char,
        _: *mut Elf_Internal_Sym,
        _: *mut asection,
        _: *mut elf_link_hash_entry,
    ) -> libc::c_int;
    fn elf_vxworks_emit_relocs(
        _: *mut bfd,
        _: *mut asection,
        _: *mut Elf_Internal_Shdr,
        _: *mut Elf_Internal_Rela,
        _: *mut *mut elf_link_hash_entry,
    ) -> bool;
    fn elf_vxworks_final_write_processing(_: *mut bfd) -> bool;
    static _bfd_elf32_size_info: elf_size_info;
}
pub type size_t = libc::c_ulong;
pub type __uint64_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type hashval_t = libc::c_uint;
pub type htab_hash = Option::<unsafe extern "C" fn(*const libc::c_void) -> hashval_t>;
pub type htab_eq = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
pub type htab_del = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type htab_trav = Option::<
    unsafe extern "C" fn(*mut *mut libc::c_void, *mut libc::c_void) -> libc::c_int,
>;
pub type htab_alloc = Option::<
    unsafe extern "C" fn(size_t, size_t) -> *mut libc::c_void,
>;
pub type htab_free = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type htab_alloc_with_arg = Option::<
    unsafe extern "C" fn(*mut libc::c_void, size_t, size_t) -> *mut libc::c_void,
>;
pub type htab_free_with_arg = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct htab {
    pub hash_f: htab_hash,
    pub eq_f: htab_eq,
    pub del_f: htab_del,
    pub entries: *mut *mut libc::c_void,
    pub size: size_t,
    pub n_elements: size_t,
    pub n_deleted: size_t,
    pub searches: libc::c_uint,
    pub collisions: libc::c_uint,
    pub alloc_f: htab_alloc,
    pub free_f: htab_free,
    pub alloc_arg: *mut libc::c_void,
    pub alloc_with_arg_f: htab_alloc_with_arg,
    pub free_with_arg_f: htab_free_with_arg,
    pub size_prime_index: libc::c_uint,
}
pub type htab_t = *mut htab;
pub type uint64_t = __uint64_t;
pub type bfd_int64_t = libc::c_long;
pub type bfd_uint64_t = libc::c_ulong;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd {
    pub filename: *const libc::c_char,
    pub xvec: *const bfd_target,
    pub iostream: *mut libc::c_void,
    pub iovec: *const bfd_iovec,
    pub lru_prev: *mut bfd,
    pub lru_next: *mut bfd,
    pub where_0: ufile_ptr,
    pub mtime: libc::c_long,
    pub id: libc::c_uint,
    pub flags: flagword,
    #[bitfield(name = "format", ty = "bfd_format", bits = "0..=2")]
    #[bitfield(name = "direction", ty = "bfd_direction", bits = "3..=4")]
    #[bitfield(name = "cacheable", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "target_defaulted", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "opened_once", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "mtime_set", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "no_export", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "output_has_begun", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "has_armap", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "is_thin_archive", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "no_element_cache", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "selective_search", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "is_linker_output", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "is_linker_input", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "plugin_format", ty = "bfd_plugin_format", bits = "17..=18")]
    #[bitfield(name = "lto_output", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "lto_slim_object", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "read_only", ty = "libc::c_uint", bits = "21..=21")]
    pub format_direction_cacheable_target_defaulted_opened_once_mtime_set_no_export_output_has_begun_has_armap_is_thin_archive_no_element_cache_selective_search_is_linker_output_is_linker_input_plugin_format_lto_output_lto_slim_object_read_only: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 5],
    pub plugin_dummy_bfd: *mut bfd,
    pub origin: ufile_ptr,
    pub proxy_origin: ufile_ptr,
    pub section_htab: bfd_hash_table,
    pub sections: *mut bfd_section,
    pub section_last: *mut bfd_section,
    pub section_count: libc::c_uint,
    pub archive_plugin_fd: libc::c_int,
    pub archive_plugin_fd_open_count: libc::c_uint,
    pub archive_pass: libc::c_int,
    pub start_address: bfd_vma,
    pub outsymbols: *mut *mut bfd_symbol,
    pub symcount: libc::c_uint,
    pub dynsymcount: libc::c_uint,
    pub arch_info: *const bfd_arch_info,
    pub size: ufile_ptr,
    pub arelt_data: *mut libc::c_void,
    pub my_archive: *mut bfd,
    pub archive_next: *mut bfd,
    pub archive_head: *mut bfd,
    pub nested_archives: *mut bfd,
    pub link: C2RustUnnamed_19,
    pub tdata: C2RustUnnamed,
    pub usrdata: *mut libc::c_void,
    pub memory: *mut libc::c_void,
    pub build_id: *const bfd_build_id,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_build_id {
    pub size: bfd_size_type,
    pub data: [bfd_byte; 1],
}
pub type bfd_byte = libc::c_uchar;
pub type bfd_size_type = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
    pub aout_data: *mut aout_data_struct,
    pub aout_ar_data: *mut artdata,
    pub coff_obj_data: *mut coff_tdata,
    pub pe_obj_data: *mut pe_tdata,
    pub xcoff_obj_data: *mut xcoff_tdata,
    pub ecoff_obj_data: *mut ecoff_tdata,
    pub srec_data: *mut srec_data_struct,
    pub verilog_data: *mut verilog_data_struct,
    pub ihex_data: *mut ihex_data_struct,
    pub tekhex_data: *mut tekhex_data_struct,
    pub elf_obj_data: *mut elf_obj_tdata,
    pub mmo_data: *mut mmo_data_struct,
    pub sun_core_data: *mut sun_core_struct,
    pub sco5_core_data: *mut sco5_core_struct,
    pub trad_core_data: *mut trad_core_struct,
    pub som_data: *mut som_data_struct,
    pub hpux_core_data: *mut hpux_core_struct,
    pub hppabsd_core_data: *mut hppabsd_core_struct,
    pub sgi_core_data: *mut sgi_core_struct,
    pub lynx_core_data: *mut lynx_core_struct,
    pub osf_core_data: *mut osf_core_struct,
    pub cisco_core_data: *mut cisco_core_struct,
    pub versados_data: *mut versados_data_struct,
    pub netbsd_core_data: *mut netbsd_core_struct,
    pub mach_o_data: *mut mach_o_data_struct,
    pub mach_o_fat_data: *mut mach_o_fat_data_struct,
    pub plugin_data: *mut plugin_data_struct,
    pub pef_data: *mut bfd_pef_data_struct,
    pub pef_xlib_data: *mut bfd_pef_xlib_data_struct,
    pub sym_data: *mut bfd_sym_data_struct,
    pub any: *mut libc::c_void,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_obj_tdata {
    pub elf_header: [Elf_Internal_Ehdr; 1],
    pub elf_sect_ptr: *mut *mut Elf_Internal_Shdr,
    pub phdr: *mut Elf_Internal_Phdr,
    pub symtab_hdr: Elf_Internal_Shdr,
    pub shstrtab_hdr: Elf_Internal_Shdr,
    pub strtab_hdr: Elf_Internal_Shdr,
    pub dynsymtab_hdr: Elf_Internal_Shdr,
    pub dynstrtab_hdr: Elf_Internal_Shdr,
    pub dynversym_hdr: Elf_Internal_Shdr,
    pub dynverref_hdr: Elf_Internal_Shdr,
    pub dynverdef_hdr: Elf_Internal_Shdr,
    pub symtab_shndx_list: *mut elf_section_list,
    pub gp: bfd_vma,
    pub gp_size: libc::c_uint,
    pub num_elf_sections: libc::c_uint,
    pub being_created: *mut libc::c_uchar,
    pub sym_hashes: *mut *mut elf_link_hash_entry,
    pub local_got: C2RustUnnamed_15,
    pub dt_name: *const libc::c_char,
    pub dt_audit: *const libc::c_char,
    pub line_info: *mut libc::c_void,
    pub dwarf1_find_line_info: *mut dwarf1_debug,
    pub dwarf2_find_line_info: *mut libc::c_void,
    pub elf_find_function_cache: *mut libc::c_void,
    pub cverdefs: libc::c_uint,
    pub cverrefs: libc::c_uint,
    pub verdef: *mut Elf_Internal_Verdef,
    pub verref: *mut Elf_Internal_Verneed,
    pub eh_frame_section: *mut asection,
    pub symbuf: *mut libc::c_void,
    pub properties: *mut elf_property_list,
    pub known_obj_attributes: [[obj_attribute; 71]; 2],
    pub other_obj_attributes: [*mut obj_attribute_list; 2],
    pub sdt_note_head: *mut sdt_note,
    pub group_sect_ptr: *mut *mut Elf_Internal_Shdr,
    pub num_group: libc::c_uint,
    pub group_search_offset: libc::c_uint,
    pub symtab_section: libc::c_uint,
    pub dynsymtab_section: libc::c_uint,
    pub dynversym_section: libc::c_uint,
    pub dynverdef_section: libc::c_uint,
    pub dynverref_section: libc::c_uint,
    #[bitfield(name = "object_id", ty = "elf_target_id", bits = "0..=5")]
    #[bitfield(name = "dyn_lib_class", ty = "dynamic_lib_link_class", bits = "6..=9")]
    #[bitfield(name = "has_gnu_osabi", ty = "elf_gnu_osabi", bits = "10..=13")]
    #[bitfield(name = "has_no_copy_on_protected", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "bad_symtab", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "is_pie", ty = "libc::c_uint", bits = "16..=16")]
    pub object_id_dyn_lib_class_has_gnu_osabi_has_no_copy_on_protected_bad_symtab_is_pie: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub core: *mut core_elf_obj_tdata,
    pub o: *mut output_elf_obj_tdata,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct output_elf_obj_tdata {
    pub seg_map: *mut elf_segment_map,
    pub strtab_ptr: *mut elf_strtab_hash,
    pub section_syms: *mut *mut asymbol,
    pub eh_frame_hdr: *mut asection,
    pub build_id: C2RustUnnamed_13,
    pub program_header_size: bfd_size_type,
    pub next_file_pos: file_ptr,
    pub link_info: *mut bfd_link_info,
    pub num_section_syms: libc::c_int,
    pub shstrtab_section: libc::c_uint,
    pub strtab_section: libc::c_uint,
    pub stack_flags: libc::c_uint,
    pub flags_init: bool,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_link_info {
    #[bitfield(name = "type_0", ty = "output_type", bits = "0..=1")]
    #[bitfield(name = "symbolic", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "nocopyreloc", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "export_dynamic", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "create_default_symver", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "gc_sections", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "gc_keep_exported", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "notice_all", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "lto_plugin_active", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "lto_all_symbols_read", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "strip_discarded", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "dynamic_data", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "resolve_section_groups", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "big_endian", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "strip", ty = "bfd_link_strip", bits = "15..=16")]
    #[bitfield(name = "discard", ty = "bfd_link_discard", bits = "17..=18")]
    #[bitfield(name = "elf_stt_common", ty = "bfd_link_elf_stt_common", bits = "19..=20")]
    #[bitfield(name = "common_skip_ar_symbols", ty = "bfd_link_common_skip_ar_symbols", bits = "21..=22")]
    #[bitfield(name = "unresolved_syms_in_objects", ty = "report_method", bits = "23..=24")]
    #[bitfield(name = "unresolved_syms_in_shared_libs", ty = "report_method", bits = "25..=26")]
    #[bitfield(name = "warn_unresolved_syms", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "static_link", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "keep_memory", ty = "libc::c_uint", bits = "29..=29")]
    #[bitfield(name = "emitrelocations", ty = "libc::c_uint", bits = "30..=30")]
    #[bitfield(name = "relro", ty = "libc::c_uint", bits = "31..=31")]
    #[bitfield(name = "separate_code", ty = "libc::c_uint", bits = "32..=32")]
    #[bitfield(name = "eh_frame_hdr_type", ty = "libc::c_uint", bits = "33..=34")]
    #[bitfield(name = "textrel_check", ty = "textrel_check_method", bits = "35..=36")]
    #[bitfield(name = "emit_hash", ty = "libc::c_uint", bits = "37..=37")]
    #[bitfield(name = "emit_gnu_hash", ty = "libc::c_uint", bits = "38..=38")]
    #[bitfield(name = "reduce_memory_overheads", ty = "libc::c_uint", bits = "39..=39")]
    #[bitfield(name = "traditional_format", ty = "libc::c_uint", bits = "40..=40")]
    #[bitfield(name = "combreloc", ty = "libc::c_uint", bits = "41..=41")]
    #[bitfield(name = "default_imported_symver", ty = "libc::c_uint", bits = "42..=42")]
    #[bitfield(name = "new_dtags", ty = "libc::c_uint", bits = "43..=43")]
    #[bitfield(name = "no_ld_generated_unwind_info", ty = "libc::c_uint", bits = "44..=44")]
    #[bitfield(name = "task_link", ty = "libc::c_uint", bits = "45..=45")]
    #[bitfield(name = "allow_multiple_definition", ty = "libc::c_uint", bits = "46..=46")]
    #[bitfield(name = "prohibit_multiple_definition_absolute", ty = "libc::c_uint", bits = "47..=47")]
    #[bitfield(name = "warn_multiple_definition", ty = "libc::c_uint", bits = "48..=48")]
    #[bitfield(name = "allow_undefined_version", ty = "libc::c_uint", bits = "49..=49")]
    #[bitfield(name = "dynamic", ty = "libc::c_uint", bits = "50..=50")]
    #[bitfield(name = "execstack", ty = "libc::c_uint", bits = "51..=51")]
    #[bitfield(name = "noexecstack", ty = "libc::c_uint", bits = "52..=52")]
    #[bitfield(name = "optimize", ty = "libc::c_uint", bits = "53..=53")]
    #[bitfield(name = "print_gc_sections", ty = "libc::c_uint", bits = "54..=54")]
    #[bitfield(name = "warn_alternate_em", ty = "libc::c_uint", bits = "55..=55")]
    #[bitfield(name = "user_phdrs", ty = "libc::c_uint", bits = "56..=56")]
    #[bitfield(name = "load_phdrs", ty = "libc::c_uint", bits = "57..=57")]
    #[bitfield(name = "check_relocs_after_open_input", ty = "libc::c_uint", bits = "58..=58")]
    #[bitfield(name = "nointerp", ty = "libc::c_uint", bits = "59..=59")]
    #[bitfield(name = "inhibit_common_definition", ty = "libc::c_uint", bits = "60..=60")]
    #[bitfield(name = "has_map_file", ty = "libc::c_uint", bits = "61..=61")]
    #[bitfield(name = "non_contiguous_regions", ty = "libc::c_uint", bits = "62..=62")]
    #[bitfield(name = "non_contiguous_regions_warnings", ty = "libc::c_uint", bits = "63..=63")]
    #[bitfield(name = "unique_symbol", ty = "libc::c_uint", bits = "64..=64")]
    pub type_0_symbolic_nocopyreloc_export_dynamic_create_default_symver_gc_sections_gc_keep_exported_notice_all_lto_plugin_active_lto_all_symbols_read_strip_discarded_dynamic_data_resolve_section_groups_big_endian_strip_discard_elf_stt_common_common_skip_ar_symbols_unresolved_syms_in_objects_unresolved_syms_in_shared_libs_warn_unresolved_syms_static_link_keep_memory_emitrelocations_relro_separate_code_eh_frame_hdr_type_textrel_check_emit_hash_emit_gnu_hash_reduce_memory_overheads_traditional_format_combreloc_default_imported_symver_new_dtags_no_ld_generated_unwind_info_task_link_allow_multiple_definition_prohibit_multiple_definition_absolute_warn_multiple_definition_allow_undefined_version_dynamic_execstack_noexecstack_optimize_print_gc_sections_warn_alternate_em_user_phdrs_load_phdrs_check_relocs_after_open_input_nointerp_inhibit_common_definition_has_map_file_non_contiguous_regions_non_contiguous_regions_warnings_unique_symbol: [u8; 9],
    pub wrap_char: libc::c_char,
    pub path_separator: libc::c_char,
    pub compress_debug: compressed_debug_section_type,
    pub stacksize: bfd_signed_vma,
    pub disable_target_specific_optimizations: libc::c_int,
    pub callbacks: *const bfd_link_callbacks,
    pub hash: *mut bfd_link_hash_table,
    pub keep_hash: *mut bfd_hash_table,
    pub notice_hash: *mut bfd_hash_table,
    pub wrap_hash: *mut bfd_hash_table,
    pub ignore_hash: *mut bfd_hash_table,
    pub output_bfd: *mut bfd,
    pub out_implib_bfd: *mut bfd,
    pub input_bfds: *mut bfd,
    pub input_bfds_tail: *mut *mut bfd,
    pub create_object_symbols_section: *mut asection,
    pub gc_sym_list: *mut bfd_sym_chain,
    pub base_file: *mut libc::c_void,
    pub init_function: *const libc::c_char,
    pub fini_function: *const libc::c_char,
    pub relax_pass: libc::c_int,
    pub relax_trip: libc::c_int,
    pub extern_protected_data: libc::c_int,
    pub dynamic_undefined_weak: libc::c_int,
    pub pei386_auto_import: libc::c_int,
    pub pei386_runtime_pseudo_reloc: libc::c_int,
    pub spare_dynamic_tags: libc::c_uint,
    pub flags: bfd_vma,
    pub flags_1: bfd_vma,
    pub gnu_flags_1: bfd_vma,
    pub start_stop_gc: libc::c_int,
    pub start_stop_visibility: libc::c_uint,
    pub maxpagesize: bfd_vma,
    pub commonpagesize: bfd_vma,
    pub relro_start: bfd_vma,
    pub relro_end: bfd_vma,
    pub dynamic_list: *mut bfd_elf_dynamic_list,
    pub version_info: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_tree {
    pub next: *mut bfd_elf_version_tree,
    pub name: *const libc::c_char,
    pub vernum: libc::c_uint,
    pub globals: bfd_elf_version_expr_head,
    pub locals: bfd_elf_version_expr_head,
    pub deps: *mut bfd_elf_version_deps,
    pub name_indx: libc::c_uint,
    pub used: libc::c_int,
    pub match_0: Option::<
        unsafe extern "C" fn(
            *mut bfd_elf_version_expr_head,
            *mut bfd_elf_version_expr,
            *const libc::c_char,
        ) -> *mut bfd_elf_version_expr,
    >,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_elf_version_expr {
    pub next: *mut bfd_elf_version_expr,
    pub pattern: *const libc::c_char,
    #[bitfield(name = "literal", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "symver", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "script", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "mask", ty = "libc::c_uint", bits = "3..=5")]
    pub literal_symver_script_mask: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 7],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_expr_head {
    pub list: *mut bfd_elf_version_expr,
    pub htab: *mut libc::c_void,
    pub remaining: *mut bfd_elf_version_expr,
    pub mask: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_deps {
    pub next: *mut bfd_elf_version_deps,
    pub version_needed: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_dynamic_list {
    pub head: bfd_elf_version_expr_head,
    pub match_0: Option::<
        unsafe extern "C" fn(
            *mut bfd_elf_version_expr_head,
            *mut bfd_elf_version_expr,
            *const libc::c_char,
        ) -> *mut bfd_elf_version_expr,
    >,
}
pub type bfd_vma = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_sym_chain {
    pub next: *mut bfd_sym_chain,
    pub name: *const libc::c_char,
}
pub type asection = bfd_section;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_section {
    pub name: *const libc::c_char,
    pub id: libc::c_uint,
    pub section_id: libc::c_uint,
    pub index: libc::c_uint,
    pub next: *mut bfd_section,
    pub prev: *mut bfd_section,
    pub flags: flagword,
    #[bitfield(name = "user_set_vma", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "linker_mark", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "linker_has_input", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "gc_mark", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "compress_status", ty = "libc::c_uint", bits = "4..=5")]
    #[bitfield(name = "segment_mark", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "sec_info_type", ty = "libc::c_uint", bits = "7..=9")]
    #[bitfield(name = "use_rela_p", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "sec_flg0", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "sec_flg1", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "sec_flg2", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "sec_flg3", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "sec_flg4", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "sec_flg5", ty = "libc::c_uint", bits = "16..=16")]
    pub user_set_vma_linker_mark_linker_has_input_gc_mark_compress_status_segment_mark_sec_info_type_use_rela_p_sec_flg0_sec_flg1_sec_flg2_sec_flg3_sec_flg4_sec_flg5: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub vma: bfd_vma,
    pub lma: bfd_vma,
    pub size: bfd_size_type,
    pub rawsize: bfd_size_type,
    pub compressed_size: bfd_size_type,
    pub relax: *mut relax_table,
    pub relax_count: libc::c_int,
    pub output_offset: bfd_vma,
    pub output_section: *mut bfd_section,
    pub alignment_power: libc::c_uint,
    pub relocation: *mut reloc_cache_entry,
    pub orelocation: *mut *mut reloc_cache_entry,
    pub reloc_count: libc::c_uint,
    pub filepos: file_ptr,
    pub rel_filepos: file_ptr,
    pub line_filepos: file_ptr,
    pub userdata: *mut libc::c_void,
    pub contents: *mut libc::c_uchar,
    pub lineno: *mut alent,
    pub lineno_count: libc::c_uint,
    pub entsize: libc::c_uint,
    pub kept_section: *mut bfd_section,
    pub moving_line_filepos: file_ptr,
    pub target_index: libc::c_int,
    pub used_by_bfd: *mut libc::c_void,
    pub constructor_chain: *mut relent_chain,
    pub owner: *mut bfd,
    pub symbol: *mut bfd_symbol,
    pub symbol_ptr_ptr: *mut *mut bfd_symbol,
    pub map_head: C2RustUnnamed_0,
    pub map_tail: C2RustUnnamed_0,
    pub already_assigned: *mut bfd_section,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub link_order: *mut bfd_link_order,
    pub s: *mut bfd_section,
    pub linked_to_symbol_name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_order {
    pub next: *mut bfd_link_order,
    pub type_0: bfd_link_order_type,
    pub offset: bfd_vma,
    pub size: bfd_size_type,
    pub u: C2RustUnnamed_1,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub indirect: C2RustUnnamed_5,
    pub data: C2RustUnnamed_4,
    pub reloc: C2RustUnnamed_2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub p: *mut bfd_link_order_reloc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_order_reloc {
    pub reloc: bfd_reloc_code_real_type,
    pub u: C2RustUnnamed_3,
    pub addend: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub section: *mut asection,
    pub name: *const libc::c_char,
}
pub type bfd_reloc_code_real_type = bfd_reloc_code_real;
pub type bfd_reloc_code_real = libc::c_uint;
pub const BFD_RELOC_UNUSED: bfd_reloc_code_real = 2383;
pub const BFD_RELOC_S12Z_OPR: bfd_reloc_code_real = 2382;
pub const BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4: bfd_reloc_code_real = 2381;
pub const BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4: bfd_reloc_code_real = 2380;
pub const BFD_RELOC_CKCORE_IRELATIVE: bfd_reloc_code_real = 2379;
pub const BFD_RELOC_CKCORE_CALLGRAPH: bfd_reloc_code_real = 2378;
pub const BFD_RELOC_CKCORE_NOJSRI: bfd_reloc_code_real = 2377;
pub const BFD_RELOC_CKCORE_PCREL_FLRW_IMM8BY4: bfd_reloc_code_real = 2376;
pub const BFD_RELOC_CKCORE_TLS_TPOFF32: bfd_reloc_code_real = 2375;
pub const BFD_RELOC_CKCORE_TLS_DTPOFF32: bfd_reloc_code_real = 2374;
pub const BFD_RELOC_CKCORE_TLS_DTPMOD32: bfd_reloc_code_real = 2373;
pub const BFD_RELOC_CKCORE_TLS_LDO32: bfd_reloc_code_real = 2372;
pub const BFD_RELOC_CKCORE_TLS_LDM32: bfd_reloc_code_real = 2371;
pub const BFD_RELOC_CKCORE_TLS_GD32: bfd_reloc_code_real = 2370;
pub const BFD_RELOC_CKCORE_TLS_IE32: bfd_reloc_code_real = 2369;
pub const BFD_RELOC_CKCORE_TLS_LE32: bfd_reloc_code_real = 2368;
pub const BFD_RELOC_CKCORE_PCREL_IMM7BY4: bfd_reloc_code_real = 2367;
pub const BFD_RELOC_CKCORE_PLT_IMM18BY4: bfd_reloc_code_real = 2366;
pub const BFD_RELOC_CKCORE_GOT_IMM18BY4: bfd_reloc_code_real = 2365;
pub const BFD_RELOC_CKCORE_GOTOFF_IMM18: bfd_reloc_code_real = 2364;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18BY4: bfd_reloc_code_real = 2363;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18BY2: bfd_reloc_code_real = 2362;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18: bfd_reloc_code_real = 2361;
pub const BFD_RELOC_CKCORE_PCREL_IMM18BY2: bfd_reloc_code_real = 2360;
pub const BFD_RELOC_CKCORE_DOFFSET_LO16: bfd_reloc_code_real = 2359;
pub const BFD_RELOC_CKCORE_TOFFSET_LO16: bfd_reloc_code_real = 2358;
pub const BFD_RELOC_CKCORE_PCREL_JSR_IMM26BY2: bfd_reloc_code_real = 2357;
pub const BFD_RELOC_CKCORE_ADDRPLT_LO16: bfd_reloc_code_real = 2356;
pub const BFD_RELOC_CKCORE_ADDRPLT_HI16: bfd_reloc_code_real = 2355;
pub const BFD_RELOC_CKCORE_ADDRGOT_LO16: bfd_reloc_code_real = 2354;
pub const BFD_RELOC_CKCORE_ADDRGOT_HI16: bfd_reloc_code_real = 2353;
pub const BFD_RELOC_CKCORE_PLT_LO16: bfd_reloc_code_real = 2352;
pub const BFD_RELOC_CKCORE_PLT_HI16: bfd_reloc_code_real = 2351;
pub const BFD_RELOC_CKCORE_PLT12: bfd_reloc_code_real = 2350;
pub const BFD_RELOC_CKCORE_GOT_LO16: bfd_reloc_code_real = 2349;
pub const BFD_RELOC_CKCORE_GOT_HI16: bfd_reloc_code_real = 2348;
pub const BFD_RELOC_CKCORE_GOT12: bfd_reloc_code_real = 2347;
pub const BFD_RELOC_CKCORE_GOTOFF_LO16: bfd_reloc_code_real = 2346;
pub const BFD_RELOC_CKCORE_GOTOFF_HI16: bfd_reloc_code_real = 2345;
pub const BFD_RELOC_CKCORE_GOTPC_LO16: bfd_reloc_code_real = 2344;
pub const BFD_RELOC_CKCORE_GOTPC_HI16: bfd_reloc_code_real = 2343;
pub const BFD_RELOC_CKCORE_ADDR_LO16: bfd_reloc_code_real = 2342;
pub const BFD_RELOC_CKCORE_ADDR_HI16: bfd_reloc_code_real = 2341;
pub const BFD_RELOC_CKCORE_PCREL_IMM10BY4: bfd_reloc_code_real = 2340;
pub const BFD_RELOC_CKCORE_PCREL_IMM10BY2: bfd_reloc_code_real = 2339;
pub const BFD_RELOC_CKCORE_PCREL_IMM16BY4: bfd_reloc_code_real = 2338;
pub const BFD_RELOC_CKCORE_PCREL_IMM16BY2: bfd_reloc_code_real = 2337;
pub const BFD_RELOC_CKCORE_PCREL_IMM26BY2: bfd_reloc_code_real = 2336;
pub const BFD_RELOC_CKCORE_ADDRPLT: bfd_reloc_code_real = 2335;
pub const BFD_RELOC_CKCORE_ADDRGOT: bfd_reloc_code_real = 2334;
pub const BFD_RELOC_CKCORE_PLT32: bfd_reloc_code_real = 2333;
pub const BFD_RELOC_CKCORE_GOT32: bfd_reloc_code_real = 2332;
pub const BFD_RELOC_CKCORE_GOTPC: bfd_reloc_code_real = 2331;
pub const BFD_RELOC_CKCORE_GOTOFF: bfd_reloc_code_real = 2330;
pub const BFD_RELOC_CKCORE_JUMP_SLOT: bfd_reloc_code_real = 2329;
pub const BFD_RELOC_CKCORE_GLOB_DAT: bfd_reloc_code_real = 2328;
pub const BFD_RELOC_CKCORE_COPY: bfd_reloc_code_real = 2327;
pub const BFD_RELOC_CKCORE_RELATIVE: bfd_reloc_code_real = 2326;
pub const BFD_RELOC_CKCORE_GNU_VTENTRY: bfd_reloc_code_real = 2325;
pub const BFD_RELOC_CKCORE_GNU_VTINHERIT: bfd_reloc_code_real = 2324;
pub const BFD_RELOC_CKCORE_PCREL_JSR_IMM11BY2: bfd_reloc_code_real = 2323;
pub const BFD_RELOC_CKCORE_PCREL32: bfd_reloc_code_real = 2322;
pub const BFD_RELOC_CKCORE_PCREL_IMM4BY2: bfd_reloc_code_real = 2321;
pub const BFD_RELOC_CKCORE_PCREL_IMM11BY2: bfd_reloc_code_real = 2320;
pub const BFD_RELOC_CKCORE_PCREL_IMM8BY4: bfd_reloc_code_real = 2319;
pub const BFD_RELOC_CKCORE_ADDR32: bfd_reloc_code_real = 2318;
pub const BFD_RELOC_CKCORE_NONE: bfd_reloc_code_real = 2317;
pub const BFD_RELOC_WASM32_PLT_SIG: bfd_reloc_code_real = 2316;
pub const BFD_RELOC_WASM32_INDEX: bfd_reloc_code_real = 2315;
pub const BFD_RELOC_WASM32_CODE_POINTER: bfd_reloc_code_real = 2314;
pub const BFD_RELOC_WASM32_COPY: bfd_reloc_code_real = 2313;
pub const BFD_RELOC_WASM32_ABS32_CODE: bfd_reloc_code_real = 2312;
pub const BFD_RELOC_WASM32_PLT_INDEX: bfd_reloc_code_real = 2311;
pub const BFD_RELOC_WASM32_LEB128_PLT: bfd_reloc_code_real = 2310;
pub const BFD_RELOC_WASM32_LEB128_GOT_CODE: bfd_reloc_code_real = 2309;
pub const BFD_RELOC_WASM32_LEB128_GOT: bfd_reloc_code_real = 2308;
pub const BFD_RELOC_WASM32_LEB128: bfd_reloc_code_real = 2307;
pub const BFD_RELOC_VISIUM_IM16_PCREL: bfd_reloc_code_real = 2306;
pub const BFD_RELOC_VISIUM_LO16_PCREL: bfd_reloc_code_real = 2305;
pub const BFD_RELOC_VISIUM_HI16_PCREL: bfd_reloc_code_real = 2304;
pub const BFD_RELOC_VISIUM_REL16: bfd_reloc_code_real = 2303;
pub const BFD_RELOC_VISIUM_IM16: bfd_reloc_code_real = 2302;
pub const BFD_RELOC_VISIUM_LO16: bfd_reloc_code_real = 2301;
pub const BFD_RELOC_VISIUM_HI16: bfd_reloc_code_real = 2300;
pub const BFD_RELOC_EPIPHANY_IMM8: bfd_reloc_code_real = 2299;
pub const BFD_RELOC_EPIPHANY_IMM11: bfd_reloc_code_real = 2298;
pub const BFD_RELOC_EPIPHANY_SIMM11: bfd_reloc_code_real = 2297;
pub const BFD_RELOC_EPIPHANY_LOW: bfd_reloc_code_real = 2296;
pub const BFD_RELOC_EPIPHANY_HIGH: bfd_reloc_code_real = 2295;
pub const BFD_RELOC_EPIPHANY_SIMM24: bfd_reloc_code_real = 2294;
pub const BFD_RELOC_EPIPHANY_SIMM8: bfd_reloc_code_real = 2293;
pub const BFD_RELOC_BPF_DISP32: bfd_reloc_code_real = 2292;
pub const BFD_RELOC_BPF_DISP16: bfd_reloc_code_real = 2291;
pub const BFD_RELOC_BPF_16: bfd_reloc_code_real = 2290;
pub const BFD_RELOC_BPF_32: bfd_reloc_code_real = 2289;
pub const BFD_RELOC_BPF_64: bfd_reloc_code_real = 2288;
pub const BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD: bfd_reloc_code_real = 2287;
pub const BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD: bfd_reloc_code_real = 2286;
pub const BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD: bfd_reloc_code_real = 2285;
pub const BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD: bfd_reloc_code_real = 2284;
pub const BFD_RELOC_TILEGX_TLS_IE_LOAD: bfd_reloc_code_real = 2283;
pub const BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD: bfd_reloc_code_real = 2282;
pub const BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD: bfd_reloc_code_real = 2281;
pub const BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD: bfd_reloc_code_real = 2280;
pub const BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD: bfd_reloc_code_real = 2279;
pub const BFD_RELOC_TILEGX_TLS_GD_CALL: bfd_reloc_code_real = 2278;
pub const BFD_RELOC_TILEGX_TLS_TPOFF32: bfd_reloc_code_real = 2277;
pub const BFD_RELOC_TILEGX_TLS_DTPOFF32: bfd_reloc_code_real = 2276;
pub const BFD_RELOC_TILEGX_TLS_DTPMOD32: bfd_reloc_code_real = 2275;
pub const BFD_RELOC_TILEGX_TLS_TPOFF64: bfd_reloc_code_real = 2274;
pub const BFD_RELOC_TILEGX_TLS_DTPOFF64: bfd_reloc_code_real = 2273;
pub const BFD_RELOC_TILEGX_TLS_DTPMOD64: bfd_reloc_code_real = 2272;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE: bfd_reloc_code_real = 2271;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE: bfd_reloc_code_real = 2270;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE: bfd_reloc_code_real = 2269;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE: bfd_reloc_code_real = 2268;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL: bfd_reloc_code_real = 2267;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL: bfd_reloc_code_real = 2266;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL: bfd_reloc_code_real = 2265;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL: bfd_reloc_code_real = 2264;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL: bfd_reloc_code_real = 2263;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL: bfd_reloc_code_real = 2262;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE: bfd_reloc_code_real = 2261;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE: bfd_reloc_code_real = 2260;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD: bfd_reloc_code_real = 2259;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD: bfd_reloc_code_real = 2258;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD: bfd_reloc_code_real = 2257;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD: bfd_reloc_code_real = 2256;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE: bfd_reloc_code_real = 2255;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE: bfd_reloc_code_real = 2254;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE: bfd_reloc_code_real = 2253;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE: bfd_reloc_code_real = 2252;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE: bfd_reloc_code_real = 2251;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE: bfd_reloc_code_real = 2250;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD: bfd_reloc_code_real = 2249;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD: bfd_reloc_code_real = 2248;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL: bfd_reloc_code_real = 2247;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL: bfd_reloc_code_real = 2246;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT: bfd_reloc_code_real = 2245;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT: bfd_reloc_code_real = 2244;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT: bfd_reloc_code_real = 2243;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT: bfd_reloc_code_real = 2242;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL: bfd_reloc_code_real = 2241;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL: bfd_reloc_code_real = 2240;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL: bfd_reloc_code_real = 2239;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL: bfd_reloc_code_real = 2238;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL: bfd_reloc_code_real = 2237;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL: bfd_reloc_code_real = 2236;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT: bfd_reloc_code_real = 2235;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT: bfd_reloc_code_real = 2234;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL: bfd_reloc_code_real = 2233;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL: bfd_reloc_code_real = 2232;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL: bfd_reloc_code_real = 2231;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL: bfd_reloc_code_real = 2230;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL: bfd_reloc_code_real = 2229;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL: bfd_reloc_code_real = 2228;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL: bfd_reloc_code_real = 2227;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL: bfd_reloc_code_real = 2226;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL: bfd_reloc_code_real = 2225;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL: bfd_reloc_code_real = 2224;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL: bfd_reloc_code_real = 2223;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL: bfd_reloc_code_real = 2222;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL: bfd_reloc_code_real = 2221;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL: bfd_reloc_code_real = 2220;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST: bfd_reloc_code_real = 2219;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST: bfd_reloc_code_real = 2218;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST: bfd_reloc_code_real = 2217;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST: bfd_reloc_code_real = 2216;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST: bfd_reloc_code_real = 2215;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST: bfd_reloc_code_real = 2214;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3: bfd_reloc_code_real = 2213;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3: bfd_reloc_code_real = 2212;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2: bfd_reloc_code_real = 2211;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2: bfd_reloc_code_real = 2210;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1: bfd_reloc_code_real = 2209;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1: bfd_reloc_code_real = 2208;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0: bfd_reloc_code_real = 2207;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0: bfd_reloc_code_real = 2206;
pub const BFD_RELOC_TILEGX_SHAMT_Y1: bfd_reloc_code_real = 2205;
pub const BFD_RELOC_TILEGX_SHAMT_Y0: bfd_reloc_code_real = 2204;
pub const BFD_RELOC_TILEGX_SHAMT_X1: bfd_reloc_code_real = 2203;
pub const BFD_RELOC_TILEGX_SHAMT_X0: bfd_reloc_code_real = 2202;
pub const BFD_RELOC_TILEGX_MMEND_X0: bfd_reloc_code_real = 2201;
pub const BFD_RELOC_TILEGX_MMSTART_X0: bfd_reloc_code_real = 2200;
pub const BFD_RELOC_TILEGX_MF_IMM14_X1: bfd_reloc_code_real = 2199;
pub const BFD_RELOC_TILEGX_MT_IMM14_X1: bfd_reloc_code_real = 2198;
pub const BFD_RELOC_TILEGX_DEST_IMM8_X1: bfd_reloc_code_real = 2197;
pub const BFD_RELOC_TILEGX_IMM8_Y1: bfd_reloc_code_real = 2196;
pub const BFD_RELOC_TILEGX_IMM8_X1: bfd_reloc_code_real = 2195;
pub const BFD_RELOC_TILEGX_IMM8_Y0: bfd_reloc_code_real = 2194;
pub const BFD_RELOC_TILEGX_IMM8_X0: bfd_reloc_code_real = 2193;
pub const BFD_RELOC_TILEGX_JUMPOFF_X1_PLT: bfd_reloc_code_real = 2192;
pub const BFD_RELOC_TILEGX_JUMPOFF_X1: bfd_reloc_code_real = 2191;
pub const BFD_RELOC_TILEGX_BROFF_X1: bfd_reloc_code_real = 2190;
pub const BFD_RELOC_TILEGX_RELATIVE: bfd_reloc_code_real = 2189;
pub const BFD_RELOC_TILEGX_JMP_SLOT: bfd_reloc_code_real = 2188;
pub const BFD_RELOC_TILEGX_GLOB_DAT: bfd_reloc_code_real = 2187;
pub const BFD_RELOC_TILEGX_COPY: bfd_reloc_code_real = 2186;
pub const BFD_RELOC_TILEGX_HW2_LAST: bfd_reloc_code_real = 2185;
pub const BFD_RELOC_TILEGX_HW1_LAST: bfd_reloc_code_real = 2184;
pub const BFD_RELOC_TILEGX_HW0_LAST: bfd_reloc_code_real = 2183;
pub const BFD_RELOC_TILEGX_HW3: bfd_reloc_code_real = 2182;
pub const BFD_RELOC_TILEGX_HW2: bfd_reloc_code_real = 2181;
pub const BFD_RELOC_TILEGX_HW1: bfd_reloc_code_real = 2180;
pub const BFD_RELOC_TILEGX_HW0: bfd_reloc_code_real = 2179;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA: bfd_reloc_code_real = 2178;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA: bfd_reloc_code_real = 2177;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI: bfd_reloc_code_real = 2176;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI: bfd_reloc_code_real = 2175;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO: bfd_reloc_code_real = 2174;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO: bfd_reloc_code_real = 2173;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE: bfd_reloc_code_real = 2172;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE: bfd_reloc_code_real = 2171;
pub const BFD_RELOC_TILEPRO_TLS_TPOFF32: bfd_reloc_code_real = 2170;
pub const BFD_RELOC_TILEPRO_TLS_DTPOFF32: bfd_reloc_code_real = 2169;
pub const BFD_RELOC_TILEPRO_TLS_DTPMOD32: bfd_reloc_code_real = 2168;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA: bfd_reloc_code_real = 2167;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA: bfd_reloc_code_real = 2166;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI: bfd_reloc_code_real = 2165;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI: bfd_reloc_code_real = 2164;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO: bfd_reloc_code_real = 2163;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO: bfd_reloc_code_real = 2162;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE: bfd_reloc_code_real = 2161;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE: bfd_reloc_code_real = 2160;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA: bfd_reloc_code_real = 2159;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA: bfd_reloc_code_real = 2158;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI: bfd_reloc_code_real = 2157;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI: bfd_reloc_code_real = 2156;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO: bfd_reloc_code_real = 2155;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO: bfd_reloc_code_real = 2154;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD: bfd_reloc_code_real = 2153;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD: bfd_reloc_code_real = 2152;
pub const BFD_RELOC_TILEPRO_TLS_IE_LOAD: bfd_reloc_code_real = 2151;
pub const BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD: bfd_reloc_code_real = 2150;
pub const BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD: bfd_reloc_code_real = 2149;
pub const BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD: bfd_reloc_code_real = 2148;
pub const BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD: bfd_reloc_code_real = 2147;
pub const BFD_RELOC_TILEPRO_TLS_GD_CALL: bfd_reloc_code_real = 2146;
pub const BFD_RELOC_TILEPRO_SHAMT_Y1: bfd_reloc_code_real = 2145;
pub const BFD_RELOC_TILEPRO_SHAMT_Y0: bfd_reloc_code_real = 2144;
pub const BFD_RELOC_TILEPRO_SHAMT_X1: bfd_reloc_code_real = 2143;
pub const BFD_RELOC_TILEPRO_SHAMT_X0: bfd_reloc_code_real = 2142;
pub const BFD_RELOC_TILEPRO_MMEND_X1: bfd_reloc_code_real = 2141;
pub const BFD_RELOC_TILEPRO_MMSTART_X1: bfd_reloc_code_real = 2140;
pub const BFD_RELOC_TILEPRO_MMEND_X0: bfd_reloc_code_real = 2139;
pub const BFD_RELOC_TILEPRO_MMSTART_X0: bfd_reloc_code_real = 2138;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA: bfd_reloc_code_real = 2137;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA: bfd_reloc_code_real = 2136;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI: bfd_reloc_code_real = 2135;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI: bfd_reloc_code_real = 2134;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO: bfd_reloc_code_real = 2133;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO: bfd_reloc_code_real = 2132;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT: bfd_reloc_code_real = 2131;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT: bfd_reloc_code_real = 2130;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL: bfd_reloc_code_real = 2129;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL: bfd_reloc_code_real = 2128;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL: bfd_reloc_code_real = 2127;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL: bfd_reloc_code_real = 2126;
pub const BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL: bfd_reloc_code_real = 2125;
pub const BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL: bfd_reloc_code_real = 2124;
pub const BFD_RELOC_TILEPRO_IMM16_X1_PCREL: bfd_reloc_code_real = 2123;
pub const BFD_RELOC_TILEPRO_IMM16_X0_PCREL: bfd_reloc_code_real = 2122;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HA: bfd_reloc_code_real = 2121;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HA: bfd_reloc_code_real = 2120;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HI: bfd_reloc_code_real = 2119;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HI: bfd_reloc_code_real = 2118;
pub const BFD_RELOC_TILEPRO_IMM16_X1_LO: bfd_reloc_code_real = 2117;
pub const BFD_RELOC_TILEPRO_IMM16_X0_LO: bfd_reloc_code_real = 2116;
pub const BFD_RELOC_TILEPRO_IMM16_X1: bfd_reloc_code_real = 2115;
pub const BFD_RELOC_TILEPRO_IMM16_X0: bfd_reloc_code_real = 2114;
pub const BFD_RELOC_TILEPRO_MF_IMM15_X1: bfd_reloc_code_real = 2113;
pub const BFD_RELOC_TILEPRO_MT_IMM15_X1: bfd_reloc_code_real = 2112;
pub const BFD_RELOC_TILEPRO_DEST_IMM8_X1: bfd_reloc_code_real = 2111;
pub const BFD_RELOC_TILEPRO_IMM8_Y1: bfd_reloc_code_real = 2110;
pub const BFD_RELOC_TILEPRO_IMM8_X1: bfd_reloc_code_real = 2109;
pub const BFD_RELOC_TILEPRO_IMM8_Y0: bfd_reloc_code_real = 2108;
pub const BFD_RELOC_TILEPRO_IMM8_X0: bfd_reloc_code_real = 2107;
pub const BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT: bfd_reloc_code_real = 2106;
pub const BFD_RELOC_TILEPRO_JOFFLONG_X1: bfd_reloc_code_real = 2105;
pub const BFD_RELOC_TILEPRO_BROFF_X1: bfd_reloc_code_real = 2104;
pub const BFD_RELOC_TILEPRO_RELATIVE: bfd_reloc_code_real = 2103;
pub const BFD_RELOC_TILEPRO_JMP_SLOT: bfd_reloc_code_real = 2102;
pub const BFD_RELOC_TILEPRO_GLOB_DAT: bfd_reloc_code_real = 2101;
pub const BFD_RELOC_TILEPRO_COPY: bfd_reloc_code_real = 2100;
pub const BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC: bfd_reloc_code_real = 2099;
pub const BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2098;
pub const BFD_RELOC_AARCH64_LD_GOT_LO12_NC: bfd_reloc_code_real = 2097;
pub const BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12_NC: bfd_reloc_code_real = 2096;
pub const BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12: bfd_reloc_code_real = 2095;
pub const BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC: bfd_reloc_code_real = 2094;
pub const BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12: bfd_reloc_code_real = 2093;
pub const BFD_RELOC_AARCH64_LDST_LO12: bfd_reloc_code_real = 2092;
pub const BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP: bfd_reloc_code_real = 2091;
pub const BFD_RELOC_AARCH64_RELOC_END: bfd_reloc_code_real = 2090;
pub const BFD_RELOC_AARCH64_IRELATIVE: bfd_reloc_code_real = 2089;
pub const BFD_RELOC_AARCH64_TLSDESC: bfd_reloc_code_real = 2088;
pub const BFD_RELOC_AARCH64_TLS_TPREL: bfd_reloc_code_real = 2087;
pub const BFD_RELOC_AARCH64_TLS_DTPREL: bfd_reloc_code_real = 2086;
pub const BFD_RELOC_AARCH64_TLS_DTPMOD: bfd_reloc_code_real = 2085;
pub const BFD_RELOC_AARCH64_RELATIVE: bfd_reloc_code_real = 2084;
pub const BFD_RELOC_AARCH64_JUMP_SLOT: bfd_reloc_code_real = 2083;
pub const BFD_RELOC_AARCH64_GLOB_DAT: bfd_reloc_code_real = 2082;
pub const BFD_RELOC_AARCH64_COPY: bfd_reloc_code_real = 2081;
pub const BFD_RELOC_AARCH64_TLSDESC_CALL: bfd_reloc_code_real = 2080;
pub const BFD_RELOC_AARCH64_TLSDESC_ADD: bfd_reloc_code_real = 2079;
pub const BFD_RELOC_AARCH64_TLSDESC_LDR: bfd_reloc_code_real = 2078;
pub const BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC: bfd_reloc_code_real = 2077;
pub const BFD_RELOC_AARCH64_TLSDESC_OFF_G1: bfd_reloc_code_real = 2076;
pub const BFD_RELOC_AARCH64_TLSDESC_ADD_LO12: bfd_reloc_code_real = 2075;
pub const BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC: bfd_reloc_code_real = 2074;
pub const BFD_RELOC_AARCH64_TLSDESC_LD64_LO12: bfd_reloc_code_real = 2073;
pub const BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21: bfd_reloc_code_real = 2072;
pub const BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21: bfd_reloc_code_real = 2071;
pub const BFD_RELOC_AARCH64_TLSDESC_LD_PREL19: bfd_reloc_code_real = 2070;
pub const BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12_NC: bfd_reloc_code_real = 2069;
pub const BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12: bfd_reloc_code_real = 2068;
pub const BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12_NC: bfd_reloc_code_real = 2067;
pub const BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12: bfd_reloc_code_real = 2066;
pub const BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12_NC: bfd_reloc_code_real = 2065;
pub const BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12: bfd_reloc_code_real = 2064;
pub const BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12_NC: bfd_reloc_code_real = 2063;
pub const BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12: bfd_reloc_code_real = 2062;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC: bfd_reloc_code_real = 2061;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12: bfd_reloc_code_real = 2060;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12: bfd_reloc_code_real = 2059;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC: bfd_reloc_code_real = 2058;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0: bfd_reloc_code_real = 2057;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC: bfd_reloc_code_real = 2056;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1: bfd_reloc_code_real = 2055;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2: bfd_reloc_code_real = 2054;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2: bfd_reloc_code_real = 2053;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC: bfd_reloc_code_real = 2052;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1: bfd_reloc_code_real = 2051;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC: bfd_reloc_code_real = 2050;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0: bfd_reloc_code_real = 2049;
pub const BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC: bfd_reloc_code_real = 2048;
pub const BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12: bfd_reloc_code_real = 2047;
pub const BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC: bfd_reloc_code_real = 2046;
pub const BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12: bfd_reloc_code_real = 2045;
pub const BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC: bfd_reloc_code_real = 2044;
pub const BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12: bfd_reloc_code_real = 2043;
pub const BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC: bfd_reloc_code_real = 2042;
pub const BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12: bfd_reloc_code_real = 2041;
pub const BFD_RELOC_AARCH64_TLSLD_ADR_PREL21: bfd_reloc_code_real = 2040;
pub const BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21: bfd_reloc_code_real = 2039;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC: bfd_reloc_code_real = 2038;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC: bfd_reloc_code_real = 2037;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12: bfd_reloc_code_real = 2036;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12: bfd_reloc_code_real = 2035;
pub const BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1: bfd_reloc_code_real = 2034;
pub const BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC: bfd_reloc_code_real = 2033;
pub const BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19: bfd_reloc_code_real = 2032;
pub const BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2031;
pub const BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2030;
pub const BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21: bfd_reloc_code_real = 2029;
pub const BFD_RELOC_AARCH64_TLSGD_MOVW_G1: bfd_reloc_code_real = 2028;
pub const BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC: bfd_reloc_code_real = 2027;
pub const BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC: bfd_reloc_code_real = 2026;
pub const BFD_RELOC_AARCH64_TLSGD_ADR_PREL21: bfd_reloc_code_real = 2025;
pub const BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21: bfd_reloc_code_real = 2024;
pub const BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15: bfd_reloc_code_real = 2023;
pub const BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14: bfd_reloc_code_real = 2022;
pub const BFD_RELOC_AARCH64_LD64_GOTOFF_LO15: bfd_reloc_code_real = 2021;
pub const BFD_RELOC_AARCH64_MOVW_GOTOFF_G1: bfd_reloc_code_real = 2020;
pub const BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC: bfd_reloc_code_real = 2019;
pub const BFD_RELOC_AARCH64_LD32_GOT_LO12_NC: bfd_reloc_code_real = 2018;
pub const BFD_RELOC_AARCH64_LD64_GOT_LO12_NC: bfd_reloc_code_real = 2017;
pub const BFD_RELOC_AARCH64_ADR_GOT_PAGE: bfd_reloc_code_real = 2016;
pub const BFD_RELOC_AARCH64_GOT_LD_PREL19: bfd_reloc_code_real = 2015;
pub const BFD_RELOC_AARCH64_LDST128_LO12: bfd_reloc_code_real = 2014;
pub const BFD_RELOC_AARCH64_LDST64_LO12: bfd_reloc_code_real = 2013;
pub const BFD_RELOC_AARCH64_LDST32_LO12: bfd_reloc_code_real = 2012;
pub const BFD_RELOC_AARCH64_LDST16_LO12: bfd_reloc_code_real = 2011;
pub const BFD_RELOC_AARCH64_CALL26: bfd_reloc_code_real = 2010;
pub const BFD_RELOC_AARCH64_JUMP26: bfd_reloc_code_real = 2009;
pub const BFD_RELOC_AARCH64_BRANCH19: bfd_reloc_code_real = 2008;
pub const BFD_RELOC_AARCH64_TSTBR14: bfd_reloc_code_real = 2007;
pub const BFD_RELOC_AARCH64_LDST8_LO12: bfd_reloc_code_real = 2006;
pub const BFD_RELOC_AARCH64_ADD_LO12: bfd_reloc_code_real = 2005;
pub const BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL: bfd_reloc_code_real = 2004;
pub const BFD_RELOC_AARCH64_ADR_HI21_PCREL: bfd_reloc_code_real = 2003;
pub const BFD_RELOC_AARCH64_ADR_LO21_PCREL: bfd_reloc_code_real = 2002;
pub const BFD_RELOC_AARCH64_LD_LO19_PCREL: bfd_reloc_code_real = 2001;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G3: bfd_reloc_code_real = 2000;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G2_NC: bfd_reloc_code_real = 1999;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G2: bfd_reloc_code_real = 1998;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G1_NC: bfd_reloc_code_real = 1997;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G1: bfd_reloc_code_real = 1996;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G0_NC: bfd_reloc_code_real = 1995;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G0: bfd_reloc_code_real = 1994;
pub const BFD_RELOC_AARCH64_MOVW_G2_S: bfd_reloc_code_real = 1993;
pub const BFD_RELOC_AARCH64_MOVW_G1_S: bfd_reloc_code_real = 1992;
pub const BFD_RELOC_AARCH64_MOVW_G0_S: bfd_reloc_code_real = 1991;
pub const BFD_RELOC_AARCH64_MOVW_G3: bfd_reloc_code_real = 1990;
pub const BFD_RELOC_AARCH64_MOVW_G2_NC: bfd_reloc_code_real = 1989;
pub const BFD_RELOC_AARCH64_MOVW_G2: bfd_reloc_code_real = 1988;
pub const BFD_RELOC_AARCH64_MOVW_G1_NC: bfd_reloc_code_real = 1987;
pub const BFD_RELOC_AARCH64_MOVW_G1: bfd_reloc_code_real = 1986;
pub const BFD_RELOC_AARCH64_MOVW_G0_NC: bfd_reloc_code_real = 1985;
pub const BFD_RELOC_AARCH64_MOVW_G0: bfd_reloc_code_real = 1984;
pub const BFD_RELOC_AARCH64_16_PCREL: bfd_reloc_code_real = 1983;
pub const BFD_RELOC_AARCH64_32_PCREL: bfd_reloc_code_real = 1982;
pub const BFD_RELOC_AARCH64_64_PCREL: bfd_reloc_code_real = 1981;
pub const BFD_RELOC_AARCH64_16: bfd_reloc_code_real = 1980;
pub const BFD_RELOC_AARCH64_32: bfd_reloc_code_real = 1979;
pub const BFD_RELOC_AARCH64_64: bfd_reloc_code_real = 1978;
pub const BFD_RELOC_AARCH64_NONE: bfd_reloc_code_real = 1977;
pub const BFD_RELOC_AARCH64_NULL: bfd_reloc_code_real = 1976;
pub const BFD_RELOC_AARCH64_RELOC_START: bfd_reloc_code_real = 1975;
pub const BFD_RELOC_MICROBLAZE_64_TEXTREL: bfd_reloc_code_real = 1974;
pub const BFD_RELOC_MICROBLAZE_64_TEXTPCREL: bfd_reloc_code_real = 1973;
pub const BFD_RELOC_MICROBLAZE_64_TLSTPREL: bfd_reloc_code_real = 1972;
pub const BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL: bfd_reloc_code_real = 1971;
pub const BFD_RELOC_MICROBLAZE_64_TLSDTPREL: bfd_reloc_code_real = 1970;
pub const BFD_RELOC_MICROBLAZE_32_TLSDTPREL: bfd_reloc_code_real = 1969;
pub const BFD_RELOC_MICROBLAZE_32_TLSDTPMOD: bfd_reloc_code_real = 1968;
pub const BFD_RELOC_MICROBLAZE_64_TLSLD: bfd_reloc_code_real = 1967;
pub const BFD_RELOC_MICROBLAZE_64_TLSGD: bfd_reloc_code_real = 1966;
pub const BFD_RELOC_MICROBLAZE_64_TLS: bfd_reloc_code_real = 1965;
pub const BFD_RELOC_MICROBLAZE_COPY: bfd_reloc_code_real = 1964;
pub const BFD_RELOC_MICROBLAZE_32_GOTOFF: bfd_reloc_code_real = 1963;
pub const BFD_RELOC_MICROBLAZE_64_GOTOFF: bfd_reloc_code_real = 1962;
pub const BFD_RELOC_MICROBLAZE_64_PLT: bfd_reloc_code_real = 1961;
pub const BFD_RELOC_MICROBLAZE_64_GOT: bfd_reloc_code_real = 1960;
pub const BFD_RELOC_MICROBLAZE_64_GOTPC: bfd_reloc_code_real = 1959;
pub const BFD_RELOC_MICROBLAZE_64_NONE: bfd_reloc_code_real = 1958;
pub const BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM: bfd_reloc_code_real = 1957;
pub const BFD_RELOC_MICROBLAZE_32_RWSDA: bfd_reloc_code_real = 1956;
pub const BFD_RELOC_MICROBLAZE_32_ROSDA: bfd_reloc_code_real = 1955;
pub const BFD_RELOC_MICROBLAZE_32_LO_PCREL: bfd_reloc_code_real = 1954;
pub const BFD_RELOC_MICROBLAZE_32_LO: bfd_reloc_code_real = 1953;
pub const BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT: bfd_reloc_code_real = 1952;
pub const BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12: bfd_reloc_code_real = 1951;
pub const BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21: bfd_reloc_code_real = 1950;
pub const BFD_RELOC_MACH_O_ARM64_ADDEND: bfd_reloc_code_real = 1949;
pub const BFD_RELOC_MACH_O_X86_64_TLV: bfd_reloc_code_real = 1948;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_4: bfd_reloc_code_real = 1947;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_2: bfd_reloc_code_real = 1946;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_1: bfd_reloc_code_real = 1945;
pub const BFD_RELOC_MACH_O_X86_64_GOT_LOAD: bfd_reloc_code_real = 1944;
pub const BFD_RELOC_MACH_O_X86_64_GOT: bfd_reloc_code_real = 1943;
pub const BFD_RELOC_MACH_O_X86_64_BRANCH8: bfd_reloc_code_real = 1942;
pub const BFD_RELOC_MACH_O_X86_64_BRANCH32: bfd_reloc_code_real = 1941;
pub const BFD_RELOC_MACH_O_SUBTRACTOR64: bfd_reloc_code_real = 1940;
pub const BFD_RELOC_MACH_O_SUBTRACTOR32: bfd_reloc_code_real = 1939;
pub const BFD_RELOC_MACH_O_PAIR: bfd_reloc_code_real = 1938;
pub const BFD_RELOC_MACH_O_LOCAL_SECTDIFF: bfd_reloc_code_real = 1937;
pub const BFD_RELOC_MACH_O_SECTDIFF: bfd_reloc_code_real = 1936;
pub const BFD_RELOC_LM32_RELATIVE: bfd_reloc_code_real = 1935;
pub const BFD_RELOC_LM32_JMP_SLOT: bfd_reloc_code_real = 1934;
pub const BFD_RELOC_LM32_GLOB_DAT: bfd_reloc_code_real = 1933;
pub const BFD_RELOC_LM32_COPY: bfd_reloc_code_real = 1932;
pub const BFD_RELOC_LM32_GOTOFF_LO16: bfd_reloc_code_real = 1931;
pub const BFD_RELOC_LM32_GOTOFF_HI16: bfd_reloc_code_real = 1930;
pub const BFD_RELOC_LM32_16_GOT: bfd_reloc_code_real = 1929;
pub const BFD_RELOC_LM32_BRANCH: bfd_reloc_code_real = 1928;
pub const BFD_RELOC_LM32_CALL: bfd_reloc_code_real = 1927;
pub const BFD_RELOC_Z8K_IMM4L: bfd_reloc_code_real = 1926;
pub const BFD_RELOC_Z8K_CALLR: bfd_reloc_code_real = 1925;
pub const BFD_RELOC_Z8K_DISP7: bfd_reloc_code_real = 1924;
pub const BFD_RELOC_Z80_16_BE: bfd_reloc_code_real = 1923;
pub const BFD_RELOC_Z80_WORD1: bfd_reloc_code_real = 1922;
pub const BFD_RELOC_Z80_WORD0: bfd_reloc_code_real = 1921;
pub const BFD_RELOC_Z80_BYTE3: bfd_reloc_code_real = 1920;
pub const BFD_RELOC_Z80_BYTE2: bfd_reloc_code_real = 1919;
pub const BFD_RELOC_Z80_BYTE1: bfd_reloc_code_real = 1918;
pub const BFD_RELOC_Z80_BYTE0: bfd_reloc_code_real = 1917;
pub const BFD_RELOC_Z80_DISP8: bfd_reloc_code_real = 1916;
pub const BFD_RELOC_XTENSA_NDIFF32: bfd_reloc_code_real = 1915;
pub const BFD_RELOC_XTENSA_NDIFF16: bfd_reloc_code_real = 1914;
pub const BFD_RELOC_XTENSA_NDIFF8: bfd_reloc_code_real = 1913;
pub const BFD_RELOC_XTENSA_PDIFF32: bfd_reloc_code_real = 1912;
pub const BFD_RELOC_XTENSA_PDIFF16: bfd_reloc_code_real = 1911;
pub const BFD_RELOC_XTENSA_PDIFF8: bfd_reloc_code_real = 1910;
pub const BFD_RELOC_XTENSA_TLS_CALL: bfd_reloc_code_real = 1909;
pub const BFD_RELOC_XTENSA_TLS_ARG: bfd_reloc_code_real = 1908;
pub const BFD_RELOC_XTENSA_TLS_FUNC: bfd_reloc_code_real = 1907;
pub const BFD_RELOC_XTENSA_TLS_TPOFF: bfd_reloc_code_real = 1906;
pub const BFD_RELOC_XTENSA_TLS_DTPOFF: bfd_reloc_code_real = 1905;
pub const BFD_RELOC_XTENSA_TLSDESC_ARG: bfd_reloc_code_real = 1904;
pub const BFD_RELOC_XTENSA_TLSDESC_FN: bfd_reloc_code_real = 1903;
pub const BFD_RELOC_XTENSA_ASM_SIMPLIFY: bfd_reloc_code_real = 1902;
pub const BFD_RELOC_XTENSA_ASM_EXPAND: bfd_reloc_code_real = 1901;
pub const BFD_RELOC_XTENSA_OP2: bfd_reloc_code_real = 1900;
pub const BFD_RELOC_XTENSA_OP1: bfd_reloc_code_real = 1899;
pub const BFD_RELOC_XTENSA_OP0: bfd_reloc_code_real = 1898;
pub const BFD_RELOC_XTENSA_SLOT14_ALT: bfd_reloc_code_real = 1897;
pub const BFD_RELOC_XTENSA_SLOT13_ALT: bfd_reloc_code_real = 1896;
pub const BFD_RELOC_XTENSA_SLOT12_ALT: bfd_reloc_code_real = 1895;
pub const BFD_RELOC_XTENSA_SLOT11_ALT: bfd_reloc_code_real = 1894;
pub const BFD_RELOC_XTENSA_SLOT10_ALT: bfd_reloc_code_real = 1893;
pub const BFD_RELOC_XTENSA_SLOT9_ALT: bfd_reloc_code_real = 1892;
pub const BFD_RELOC_XTENSA_SLOT8_ALT: bfd_reloc_code_real = 1891;
pub const BFD_RELOC_XTENSA_SLOT7_ALT: bfd_reloc_code_real = 1890;
pub const BFD_RELOC_XTENSA_SLOT6_ALT: bfd_reloc_code_real = 1889;
pub const BFD_RELOC_XTENSA_SLOT5_ALT: bfd_reloc_code_real = 1888;
pub const BFD_RELOC_XTENSA_SLOT4_ALT: bfd_reloc_code_real = 1887;
pub const BFD_RELOC_XTENSA_SLOT3_ALT: bfd_reloc_code_real = 1886;
pub const BFD_RELOC_XTENSA_SLOT2_ALT: bfd_reloc_code_real = 1885;
pub const BFD_RELOC_XTENSA_SLOT1_ALT: bfd_reloc_code_real = 1884;
pub const BFD_RELOC_XTENSA_SLOT0_ALT: bfd_reloc_code_real = 1883;
pub const BFD_RELOC_XTENSA_SLOT14_OP: bfd_reloc_code_real = 1882;
pub const BFD_RELOC_XTENSA_SLOT13_OP: bfd_reloc_code_real = 1881;
pub const BFD_RELOC_XTENSA_SLOT12_OP: bfd_reloc_code_real = 1880;
pub const BFD_RELOC_XTENSA_SLOT11_OP: bfd_reloc_code_real = 1879;
pub const BFD_RELOC_XTENSA_SLOT10_OP: bfd_reloc_code_real = 1878;
pub const BFD_RELOC_XTENSA_SLOT9_OP: bfd_reloc_code_real = 1877;
pub const BFD_RELOC_XTENSA_SLOT8_OP: bfd_reloc_code_real = 1876;
pub const BFD_RELOC_XTENSA_SLOT7_OP: bfd_reloc_code_real = 1875;
pub const BFD_RELOC_XTENSA_SLOT6_OP: bfd_reloc_code_real = 1874;
pub const BFD_RELOC_XTENSA_SLOT5_OP: bfd_reloc_code_real = 1873;
pub const BFD_RELOC_XTENSA_SLOT4_OP: bfd_reloc_code_real = 1872;
pub const BFD_RELOC_XTENSA_SLOT3_OP: bfd_reloc_code_real = 1871;
pub const BFD_RELOC_XTENSA_SLOT2_OP: bfd_reloc_code_real = 1870;
pub const BFD_RELOC_XTENSA_SLOT1_OP: bfd_reloc_code_real = 1869;
pub const BFD_RELOC_XTENSA_SLOT0_OP: bfd_reloc_code_real = 1868;
pub const BFD_RELOC_XTENSA_DIFF32: bfd_reloc_code_real = 1867;
pub const BFD_RELOC_XTENSA_DIFF16: bfd_reloc_code_real = 1866;
pub const BFD_RELOC_XTENSA_DIFF8: bfd_reloc_code_real = 1865;
pub const BFD_RELOC_XTENSA_PLT: bfd_reloc_code_real = 1864;
pub const BFD_RELOC_XTENSA_RELATIVE: bfd_reloc_code_real = 1863;
pub const BFD_RELOC_XTENSA_JMP_SLOT: bfd_reloc_code_real = 1862;
pub const BFD_RELOC_XTENSA_GLOB_DAT: bfd_reloc_code_real = 1861;
pub const BFD_RELOC_XTENSA_RTLD: bfd_reloc_code_real = 1860;
pub const BFD_RELOC_IQ2000_UHI16: bfd_reloc_code_real = 1859;
pub const BFD_RELOC_IQ2000_OFFSET_21: bfd_reloc_code_real = 1858;
pub const BFD_RELOC_IQ2000_OFFSET_16: bfd_reloc_code_real = 1857;
pub const BFD_RELOC_PRU_GNU_DIFF32_PMEM: bfd_reloc_code_real = 1856;
pub const BFD_RELOC_PRU_GNU_DIFF16_PMEM: bfd_reloc_code_real = 1855;
pub const BFD_RELOC_PRU_GNU_DIFF32: bfd_reloc_code_real = 1854;
pub const BFD_RELOC_PRU_GNU_DIFF16: bfd_reloc_code_real = 1853;
pub const BFD_RELOC_PRU_GNU_DIFF8: bfd_reloc_code_real = 1852;
pub const BFD_RELOC_PRU_16_PMEM: bfd_reloc_code_real = 1851;
pub const BFD_RELOC_PRU_32_PMEM: bfd_reloc_code_real = 1850;
pub const BFD_RELOC_PRU_U8_PCREL: bfd_reloc_code_real = 1849;
pub const BFD_RELOC_PRU_S10_PCREL: bfd_reloc_code_real = 1848;
pub const BFD_RELOC_PRU_LDI32: bfd_reloc_code_real = 1847;
pub const BFD_RELOC_PRU_U16_PMEMIMM: bfd_reloc_code_real = 1846;
pub const BFD_RELOC_PRU_U16: bfd_reloc_code_real = 1845;
pub const BFD_RELOC_NIOS2_R2_T1X1I6_2: bfd_reloc_code_real = 1844;
pub const BFD_RELOC_NIOS2_R2_T1X1I6: bfd_reloc_code_real = 1843;
pub const BFD_RELOC_NIOS2_R2_L5I4X1: bfd_reloc_code_real = 1842;
pub const BFD_RELOC_NIOS2_R2_F1I5_2: bfd_reloc_code_real = 1841;
pub const BFD_RELOC_NIOS2_R2_X2L5: bfd_reloc_code_real = 1840;
pub const BFD_RELOC_NIOS2_R2_X1I7_2: bfd_reloc_code_real = 1839;
pub const BFD_RELOC_NIOS2_R2_T2I4_2: bfd_reloc_code_real = 1838;
pub const BFD_RELOC_NIOS2_R2_T2I4_1: bfd_reloc_code_real = 1837;
pub const BFD_RELOC_NIOS2_R2_T2I4: bfd_reloc_code_real = 1836;
pub const BFD_RELOC_NIOS2_R2_T1I7_2: bfd_reloc_code_real = 1835;
pub const BFD_RELOC_NIOS2_R2_T1I7_1_PCREL: bfd_reloc_code_real = 1834;
pub const BFD_RELOC_NIOS2_R2_I10_1_PCREL: bfd_reloc_code_real = 1833;
pub const BFD_RELOC_NIOS2_R2_S12: bfd_reloc_code_real = 1832;
pub const BFD_RELOC_NIOS2_CALL_HA: bfd_reloc_code_real = 1831;
pub const BFD_RELOC_NIOS2_CALL_LO: bfd_reloc_code_real = 1830;
pub const BFD_RELOC_NIOS2_GOT_HA: bfd_reloc_code_real = 1829;
pub const BFD_RELOC_NIOS2_GOT_LO: bfd_reloc_code_real = 1828;
pub const BFD_RELOC_NIOS2_CALL26_NOAT: bfd_reloc_code_real = 1827;
pub const BFD_RELOC_NIOS2_GOTOFF: bfd_reloc_code_real = 1826;
pub const BFD_RELOC_NIOS2_RELATIVE: bfd_reloc_code_real = 1825;
pub const BFD_RELOC_NIOS2_JUMP_SLOT: bfd_reloc_code_real = 1824;
pub const BFD_RELOC_NIOS2_GLOB_DAT: bfd_reloc_code_real = 1823;
pub const BFD_RELOC_NIOS2_COPY: bfd_reloc_code_real = 1822;
pub const BFD_RELOC_NIOS2_TLS_TPREL: bfd_reloc_code_real = 1821;
pub const BFD_RELOC_NIOS2_TLS_DTPREL: bfd_reloc_code_real = 1820;
pub const BFD_RELOC_NIOS2_TLS_DTPMOD: bfd_reloc_code_real = 1819;
pub const BFD_RELOC_NIOS2_TLS_LE16: bfd_reloc_code_real = 1818;
pub const BFD_RELOC_NIOS2_TLS_IE16: bfd_reloc_code_real = 1817;
pub const BFD_RELOC_NIOS2_TLS_LDO16: bfd_reloc_code_real = 1816;
pub const BFD_RELOC_NIOS2_TLS_LDM16: bfd_reloc_code_real = 1815;
pub const BFD_RELOC_NIOS2_TLS_GD16: bfd_reloc_code_real = 1814;
pub const BFD_RELOC_NIOS2_PCREL_HA: bfd_reloc_code_real = 1813;
pub const BFD_RELOC_NIOS2_PCREL_LO: bfd_reloc_code_real = 1812;
pub const BFD_RELOC_NIOS2_GOTOFF_HA: bfd_reloc_code_real = 1811;
pub const BFD_RELOC_NIOS2_GOTOFF_LO: bfd_reloc_code_real = 1810;
pub const BFD_RELOC_NIOS2_CALL16: bfd_reloc_code_real = 1809;
pub const BFD_RELOC_NIOS2_GOT16: bfd_reloc_code_real = 1808;
pub const BFD_RELOC_NIOS2_ALIGN: bfd_reloc_code_real = 1807;
pub const BFD_RELOC_NIOS2_CALLR: bfd_reloc_code_real = 1806;
pub const BFD_RELOC_NIOS2_CJMP: bfd_reloc_code_real = 1805;
pub const BFD_RELOC_NIOS2_UJMP: bfd_reloc_code_real = 1804;
pub const BFD_RELOC_NIOS2_GPREL: bfd_reloc_code_real = 1803;
pub const BFD_RELOC_NIOS2_HIADJ16: bfd_reloc_code_real = 1802;
pub const BFD_RELOC_NIOS2_LO16: bfd_reloc_code_real = 1801;
pub const BFD_RELOC_NIOS2_HI16: bfd_reloc_code_real = 1800;
pub const BFD_RELOC_NIOS2_IMM8: bfd_reloc_code_real = 1799;
pub const BFD_RELOC_NIOS2_IMM6: bfd_reloc_code_real = 1798;
pub const BFD_RELOC_NIOS2_CACHE_OPX: bfd_reloc_code_real = 1797;
pub const BFD_RELOC_NIOS2_IMM5: bfd_reloc_code_real = 1796;
pub const BFD_RELOC_NIOS2_CALL26: bfd_reloc_code_real = 1795;
pub const BFD_RELOC_NIOS2_U16: bfd_reloc_code_real = 1794;
pub const BFD_RELOC_NIOS2_S16: bfd_reloc_code_real = 1793;
pub const BFD_RELOC_MSP430_SUB_ULEB128: bfd_reloc_code_real = 1792;
pub const BFD_RELOC_MSP430_SET_ULEB128: bfd_reloc_code_real = 1791;
pub const BFD_RELOC_MSP430_SYM_DIFF: bfd_reloc_code_real = 1790;
pub const BFD_RELOC_MSP430_PREL31: bfd_reloc_code_real = 1789;
pub const BFD_RELOC_MSP430_ABS_HI16: bfd_reloc_code_real = 1788;
pub const BFD_RELOC_MSP430X_ABS16: bfd_reloc_code_real = 1787;
pub const BFD_RELOC_MSP430X_PCR20_CALL: bfd_reloc_code_real = 1786;
pub const BFD_RELOC_MSP430X_PCR16: bfd_reloc_code_real = 1785;
pub const BFD_RELOC_MSP430X_ABS20_ADR_DST: bfd_reloc_code_real = 1784;
pub const BFD_RELOC_MSP430X_ABS20_ADR_SRC: bfd_reloc_code_real = 1783;
pub const BFD_RELOC_MSP430X_ABS20_EXT_ODST: bfd_reloc_code_real = 1782;
pub const BFD_RELOC_MSP430X_ABS20_EXT_DST: bfd_reloc_code_real = 1781;
pub const BFD_RELOC_MSP430X_ABS20_EXT_SRC: bfd_reloc_code_real = 1780;
pub const BFD_RELOC_MSP430X_PCR20_EXT_ODST: bfd_reloc_code_real = 1779;
pub const BFD_RELOC_MSP430X_PCR20_EXT_DST: bfd_reloc_code_real = 1778;
pub const BFD_RELOC_MSP430X_PCR20_EXT_SRC: bfd_reloc_code_real = 1777;
pub const BFD_RELOC_MSP430_ABS8: bfd_reloc_code_real = 1776;
pub const BFD_RELOC_MSP430_RL_PCREL: bfd_reloc_code_real = 1775;
pub const BFD_RELOC_MSP430_2X_PCREL: bfd_reloc_code_real = 1774;
pub const BFD_RELOC_MSP430_16_BYTE: bfd_reloc_code_real = 1773;
pub const BFD_RELOC_MSP430_16_PCREL_BYTE: bfd_reloc_code_real = 1772;
pub const BFD_RELOC_MSP430_16: bfd_reloc_code_real = 1771;
pub const BFD_RELOC_MSP430_16_PCREL: bfd_reloc_code_real = 1770;
pub const BFD_RELOC_MSP430_10_PCREL: bfd_reloc_code_real = 1769;
pub const BFD_RELOC_MT_PCINSN8: bfd_reloc_code_real = 1768;
pub const BFD_RELOC_MT_GNU_VTENTRY: bfd_reloc_code_real = 1767;
pub const BFD_RELOC_MT_GNU_VTINHERIT: bfd_reloc_code_real = 1766;
pub const BFD_RELOC_MT_LO16: bfd_reloc_code_real = 1765;
pub const BFD_RELOC_MT_HI16: bfd_reloc_code_real = 1764;
pub const BFD_RELOC_MT_PC16: bfd_reloc_code_real = 1763;
pub const BFD_RELOC_VAX_RELATIVE: bfd_reloc_code_real = 1762;
pub const BFD_RELOC_VAX_JMP_SLOT: bfd_reloc_code_real = 1761;
pub const BFD_RELOC_VAX_GLOB_DAT: bfd_reloc_code_real = 1760;
pub const BFD_RELOC_XC16X_SOF: bfd_reloc_code_real = 1759;
pub const BFD_RELOC_XC16X_SEG: bfd_reloc_code_real = 1758;
pub const BFD_RELOC_XC16X_POF: bfd_reloc_code_real = 1757;
pub const BFD_RELOC_XC16X_PAG: bfd_reloc_code_real = 1756;
pub const BFD_RELOC_RELC: bfd_reloc_code_real = 1755;
pub const BFD_RELOC_XSTORMY16_FPTR16: bfd_reloc_code_real = 1754;
pub const BFD_RELOC_XSTORMY16_24: bfd_reloc_code_real = 1753;
pub const BFD_RELOC_XSTORMY16_12: bfd_reloc_code_real = 1752;
pub const BFD_RELOC_XSTORMY16_REL_12: bfd_reloc_code_real = 1751;
pub const BFD_RELOC_H8_DISP32A16: bfd_reloc_code_real = 1750;
pub const BFD_RELOC_H8_DIR32A16: bfd_reloc_code_real = 1749;
pub const BFD_RELOC_H8_DIR24R8: bfd_reloc_code_real = 1748;
pub const BFD_RELOC_H8_DIR24A8: bfd_reloc_code_real = 1747;
pub const BFD_RELOC_H8_DIR16R8: bfd_reloc_code_real = 1746;
pub const BFD_RELOC_H8_DIR16A8: bfd_reloc_code_real = 1745;
pub const BFD_RELOC_OR1K_TLS_DTPMOD: bfd_reloc_code_real = 1744;
pub const BFD_RELOC_OR1K_TLS_DTPOFF: bfd_reloc_code_real = 1743;
pub const BFD_RELOC_OR1K_TLS_TPOFF: bfd_reloc_code_real = 1742;
pub const BFD_RELOC_OR1K_TLS_LE_SLO16: bfd_reloc_code_real = 1741;
pub const BFD_RELOC_OR1K_TLS_LE_LO16: bfd_reloc_code_real = 1740;
pub const BFD_RELOC_OR1K_TLS_LE_AHI16: bfd_reloc_code_real = 1739;
pub const BFD_RELOC_OR1K_TLS_LE_HI16: bfd_reloc_code_real = 1738;
pub const BFD_RELOC_OR1K_TLS_IE_LO13: bfd_reloc_code_real = 1737;
pub const BFD_RELOC_OR1K_TLS_IE_PG21: bfd_reloc_code_real = 1736;
pub const BFD_RELOC_OR1K_TLS_IE_LO16: bfd_reloc_code_real = 1735;
pub const BFD_RELOC_OR1K_TLS_IE_AHI16: bfd_reloc_code_real = 1734;
pub const BFD_RELOC_OR1K_TLS_IE_HI16: bfd_reloc_code_real = 1733;
pub const BFD_RELOC_OR1K_TLS_LDO_LO16: bfd_reloc_code_real = 1732;
pub const BFD_RELOC_OR1K_TLS_LDO_HI16: bfd_reloc_code_real = 1731;
pub const BFD_RELOC_OR1K_TLS_LDM_LO13: bfd_reloc_code_real = 1730;
pub const BFD_RELOC_OR1K_TLS_LDM_PG21: bfd_reloc_code_real = 1729;
pub const BFD_RELOC_OR1K_TLS_LDM_LO16: bfd_reloc_code_real = 1728;
pub const BFD_RELOC_OR1K_TLS_LDM_HI16: bfd_reloc_code_real = 1727;
pub const BFD_RELOC_OR1K_TLS_GD_LO13: bfd_reloc_code_real = 1726;
pub const BFD_RELOC_OR1K_TLS_GD_PG21: bfd_reloc_code_real = 1725;
pub const BFD_RELOC_OR1K_TLS_GD_LO16: bfd_reloc_code_real = 1724;
pub const BFD_RELOC_OR1K_TLS_GD_HI16: bfd_reloc_code_real = 1723;
pub const BFD_RELOC_OR1K_RELATIVE: bfd_reloc_code_real = 1722;
pub const BFD_RELOC_OR1K_JMP_SLOT: bfd_reloc_code_real = 1721;
pub const BFD_RELOC_OR1K_GLOB_DAT: bfd_reloc_code_real = 1720;
pub const BFD_RELOC_OR1K_COPY: bfd_reloc_code_real = 1719;
pub const BFD_RELOC_OR1K_GOTOFF_SLO16: bfd_reloc_code_real = 1718;
pub const BFD_RELOC_OR1K_PLTA26: bfd_reloc_code_real = 1717;
pub const BFD_RELOC_OR1K_PLT26: bfd_reloc_code_real = 1716;
pub const BFD_RELOC_OR1K_GOT_LO13: bfd_reloc_code_real = 1715;
pub const BFD_RELOC_OR1K_GOT_PG21: bfd_reloc_code_real = 1714;
pub const BFD_RELOC_OR1K_GOT16: bfd_reloc_code_real = 1713;
pub const BFD_RELOC_OR1K_GOT_AHI16: bfd_reloc_code_real = 1712;
pub const BFD_RELOC_OR1K_GOTPC_LO16: bfd_reloc_code_real = 1711;
pub const BFD_RELOC_OR1K_GOTPC_HI16: bfd_reloc_code_real = 1710;
pub const BFD_RELOC_OR1K_SLO13: bfd_reloc_code_real = 1709;
pub const BFD_RELOC_OR1K_LO13: bfd_reloc_code_real = 1708;
pub const BFD_RELOC_OR1K_PCREL_PG21: bfd_reloc_code_real = 1707;
pub const BFD_RELOC_OR1K_SLO16: bfd_reloc_code_real = 1706;
pub const BFD_RELOC_OR1K_REL_26: bfd_reloc_code_real = 1705;
pub const BFD_RELOC_CRIS_32_IE: bfd_reloc_code_real = 1704;
pub const BFD_RELOC_CRIS_DTPMOD: bfd_reloc_code_real = 1703;
pub const BFD_RELOC_CRIS_16_TPREL: bfd_reloc_code_real = 1702;
pub const BFD_RELOC_CRIS_32_TPREL: bfd_reloc_code_real = 1701;
pub const BFD_RELOC_CRIS_16_GOT_TPREL: bfd_reloc_code_real = 1700;
pub const BFD_RELOC_CRIS_32_GOT_TPREL: bfd_reloc_code_real = 1699;
pub const BFD_RELOC_CRIS_16_DTPREL: bfd_reloc_code_real = 1698;
pub const BFD_RELOC_CRIS_32_DTPREL: bfd_reloc_code_real = 1697;
pub const BFD_RELOC_CRIS_DTP: bfd_reloc_code_real = 1696;
pub const BFD_RELOC_CRIS_32_GD: bfd_reloc_code_real = 1695;
pub const BFD_RELOC_CRIS_16_GOT_GD: bfd_reloc_code_real = 1694;
pub const BFD_RELOC_CRIS_32_GOT_GD: bfd_reloc_code_real = 1693;
pub const BFD_RELOC_CRIS_32_PLT_PCREL: bfd_reloc_code_real = 1692;
pub const BFD_RELOC_CRIS_32_PLT_GOTREL: bfd_reloc_code_real = 1691;
pub const BFD_RELOC_CRIS_32_GOTREL: bfd_reloc_code_real = 1690;
pub const BFD_RELOC_CRIS_16_GOTPLT: bfd_reloc_code_real = 1689;
pub const BFD_RELOC_CRIS_32_GOTPLT: bfd_reloc_code_real = 1688;
pub const BFD_RELOC_CRIS_16_GOT: bfd_reloc_code_real = 1687;
pub const BFD_RELOC_CRIS_32_GOT: bfd_reloc_code_real = 1686;
pub const BFD_RELOC_CRIS_RELATIVE: bfd_reloc_code_real = 1685;
pub const BFD_RELOC_CRIS_JUMP_SLOT: bfd_reloc_code_real = 1684;
pub const BFD_RELOC_CRIS_GLOB_DAT: bfd_reloc_code_real = 1683;
pub const BFD_RELOC_CRIS_COPY: bfd_reloc_code_real = 1682;
pub const BFD_RELOC_CRIS_UNSIGNED_4: bfd_reloc_code_real = 1681;
pub const BFD_RELOC_CRIS_LAPCQ_OFFSET: bfd_reloc_code_real = 1680;
pub const BFD_RELOC_CRIS_UNSIGNED_16: bfd_reloc_code_real = 1679;
pub const BFD_RELOC_CRIS_SIGNED_16: bfd_reloc_code_real = 1678;
pub const BFD_RELOC_CRIS_UNSIGNED_8: bfd_reloc_code_real = 1677;
pub const BFD_RELOC_CRIS_SIGNED_8: bfd_reloc_code_real = 1676;
pub const BFD_RELOC_CRIS_UNSIGNED_6: bfd_reloc_code_real = 1675;
pub const BFD_RELOC_CRIS_SIGNED_6: bfd_reloc_code_real = 1674;
pub const BFD_RELOC_CRIS_UNSIGNED_5: bfd_reloc_code_real = 1673;
pub const BFD_RELOC_CRIS_BDISP8: bfd_reloc_code_real = 1672;
pub const BFD_RELOC_CRX_SWITCH32: bfd_reloc_code_real = 1671;
pub const BFD_RELOC_CRX_SWITCH16: bfd_reloc_code_real = 1670;
pub const BFD_RELOC_CRX_SWITCH8: bfd_reloc_code_real = 1669;
pub const BFD_RELOC_CRX_IMM32: bfd_reloc_code_real = 1668;
pub const BFD_RELOC_CRX_IMM16: bfd_reloc_code_real = 1667;
pub const BFD_RELOC_CRX_NUM32: bfd_reloc_code_real = 1666;
pub const BFD_RELOC_CRX_NUM16: bfd_reloc_code_real = 1665;
pub const BFD_RELOC_CRX_NUM8: bfd_reloc_code_real = 1664;
pub const BFD_RELOC_CRX_ABS32: bfd_reloc_code_real = 1663;
pub const BFD_RELOC_CRX_ABS16: bfd_reloc_code_real = 1662;
pub const BFD_RELOC_CRX_REGREL32: bfd_reloc_code_real = 1661;
pub const BFD_RELOC_CRX_REGREL28: bfd_reloc_code_real = 1660;
pub const BFD_RELOC_CRX_REGREL22: bfd_reloc_code_real = 1659;
pub const BFD_RELOC_CRX_REGREL12: bfd_reloc_code_real = 1658;
pub const BFD_RELOC_CRX_REL32: bfd_reloc_code_real = 1657;
pub const BFD_RELOC_CRX_REL24: bfd_reloc_code_real = 1656;
pub const BFD_RELOC_CRX_REL16: bfd_reloc_code_real = 1655;
pub const BFD_RELOC_CRX_REL8_CMP: bfd_reloc_code_real = 1654;
pub const BFD_RELOC_CRX_REL8: bfd_reloc_code_real = 1653;
pub const BFD_RELOC_CRX_REL4: bfd_reloc_code_real = 1652;
pub const BFD_RELOC_CR16_GLOB_DAT: bfd_reloc_code_real = 1651;
pub const BFD_RELOC_CR16_GOTC_REGREL20: bfd_reloc_code_real = 1650;
pub const BFD_RELOC_CR16_GOT_REGREL20: bfd_reloc_code_real = 1649;
pub const BFD_RELOC_CR16_SWITCH32: bfd_reloc_code_real = 1648;
pub const BFD_RELOC_CR16_SWITCH16: bfd_reloc_code_real = 1647;
pub const BFD_RELOC_CR16_SWITCH8: bfd_reloc_code_real = 1646;
pub const BFD_RELOC_CR16_DISP24a: bfd_reloc_code_real = 1645;
pub const BFD_RELOC_CR16_DISP24: bfd_reloc_code_real = 1644;
pub const BFD_RELOC_CR16_DISP20: bfd_reloc_code_real = 1643;
pub const BFD_RELOC_CR16_DISP16: bfd_reloc_code_real = 1642;
pub const BFD_RELOC_CR16_DISP8: bfd_reloc_code_real = 1641;
pub const BFD_RELOC_CR16_DISP4: bfd_reloc_code_real = 1640;
pub const BFD_RELOC_CR16_IMM32a: bfd_reloc_code_real = 1639;
pub const BFD_RELOC_CR16_IMM32: bfd_reloc_code_real = 1638;
pub const BFD_RELOC_CR16_IMM24: bfd_reloc_code_real = 1637;
pub const BFD_RELOC_CR16_IMM20: bfd_reloc_code_real = 1636;
pub const BFD_RELOC_CR16_IMM16: bfd_reloc_code_real = 1635;
pub const BFD_RELOC_CR16_IMM8: bfd_reloc_code_real = 1634;
pub const BFD_RELOC_CR16_IMM4: bfd_reloc_code_real = 1633;
pub const BFD_RELOC_CR16_ABS24: bfd_reloc_code_real = 1632;
pub const BFD_RELOC_CR16_ABS20: bfd_reloc_code_real = 1631;
pub const BFD_RELOC_CR16_REGREL20a: bfd_reloc_code_real = 1630;
pub const BFD_RELOC_CR16_REGREL20: bfd_reloc_code_real = 1629;
pub const BFD_RELOC_CR16_REGREL16: bfd_reloc_code_real = 1628;
pub const BFD_RELOC_CR16_REGREL14a: bfd_reloc_code_real = 1627;
pub const BFD_RELOC_CR16_REGREL14: bfd_reloc_code_real = 1626;
pub const BFD_RELOC_CR16_REGREL4a: bfd_reloc_code_real = 1625;
pub const BFD_RELOC_CR16_REGREL4: bfd_reloc_code_real = 1624;
pub const BFD_RELOC_CR16_REGREL0: bfd_reloc_code_real = 1623;
pub const BFD_RELOC_CR16_NUM32a: bfd_reloc_code_real = 1622;
pub const BFD_RELOC_CR16_NUM32: bfd_reloc_code_real = 1621;
pub const BFD_RELOC_CR16_NUM16: bfd_reloc_code_real = 1620;
pub const BFD_RELOC_CR16_NUM8: bfd_reloc_code_real = 1619;
pub const BFD_RELOC_S12Z_15_PCREL: bfd_reloc_code_real = 1618;
pub const BFD_RELOC_M68HC12_HI8XG: bfd_reloc_code_real = 1617;
pub const BFD_RELOC_M68HC12_LO8XG: bfd_reloc_code_real = 1616;
pub const BFD_RELOC_M68HC12_10_PCREL: bfd_reloc_code_real = 1615;
pub const BFD_RELOC_M68HC12_9_PCREL: bfd_reloc_code_real = 1614;
pub const BFD_RELOC_M68HC12_16B: bfd_reloc_code_real = 1613;
pub const BFD_RELOC_M68HC12_9B: bfd_reloc_code_real = 1612;
pub const BFD_RELOC_XGATE_IMM5: bfd_reloc_code_real = 1611;
pub const BFD_RELOC_XGATE_IMM4: bfd_reloc_code_real = 1610;
pub const BFD_RELOC_XGATE_IMM3: bfd_reloc_code_real = 1609;
pub const BFD_RELOC_XGATE_IMM8_HI: bfd_reloc_code_real = 1608;
pub const BFD_RELOC_XGATE_IMM8_LO: bfd_reloc_code_real = 1607;
pub const BFD_RELOC_XGATE_PCREL_10: bfd_reloc_code_real = 1606;
pub const BFD_RELOC_XGATE_PCREL_9: bfd_reloc_code_real = 1605;
pub const BFD_RELOC_XGATE_24: bfd_reloc_code_real = 1604;
pub const BFD_RELOC_XGATE_GPAGE: bfd_reloc_code_real = 1603;
pub const BFD_RELOC_XGATE_LO16: bfd_reloc_code_real = 1602;
pub const BFD_RELOC_XGATE_RL_GROUP: bfd_reloc_code_real = 1601;
pub const BFD_RELOC_XGATE_RL_JUMP: bfd_reloc_code_real = 1600;
pub const BFD_RELOC_M68HC12_5B: bfd_reloc_code_real = 1599;
pub const BFD_RELOC_M68HC11_24: bfd_reloc_code_real = 1598;
pub const BFD_RELOC_M68HC11_PAGE: bfd_reloc_code_real = 1597;
pub const BFD_RELOC_M68HC11_LO16: bfd_reloc_code_real = 1596;
pub const BFD_RELOC_M68HC11_RL_GROUP: bfd_reloc_code_real = 1595;
pub const BFD_RELOC_M68HC11_RL_JUMP: bfd_reloc_code_real = 1594;
pub const BFD_RELOC_M68HC11_3B: bfd_reloc_code_real = 1593;
pub const BFD_RELOC_M68HC11_LO8: bfd_reloc_code_real = 1592;
pub const BFD_RELOC_M68HC11_HI8: bfd_reloc_code_real = 1591;
pub const BFD_RELOC_IA64_LTOFF_DTPREL22: bfd_reloc_code_real = 1590;
pub const BFD_RELOC_IA64_DTPREL64LSB: bfd_reloc_code_real = 1589;
pub const BFD_RELOC_IA64_DTPREL64MSB: bfd_reloc_code_real = 1588;
pub const BFD_RELOC_IA64_DTPREL32LSB: bfd_reloc_code_real = 1587;
pub const BFD_RELOC_IA64_DTPREL32MSB: bfd_reloc_code_real = 1586;
pub const BFD_RELOC_IA64_DTPREL64I: bfd_reloc_code_real = 1585;
pub const BFD_RELOC_IA64_DTPREL22: bfd_reloc_code_real = 1584;
pub const BFD_RELOC_IA64_DTPREL14: bfd_reloc_code_real = 1583;
pub const BFD_RELOC_IA64_LTOFF_DTPMOD22: bfd_reloc_code_real = 1582;
pub const BFD_RELOC_IA64_DTPMOD64LSB: bfd_reloc_code_real = 1581;
pub const BFD_RELOC_IA64_DTPMOD64MSB: bfd_reloc_code_real = 1580;
pub const BFD_RELOC_IA64_LTOFF_TPREL22: bfd_reloc_code_real = 1579;
pub const BFD_RELOC_IA64_TPREL64LSB: bfd_reloc_code_real = 1578;
pub const BFD_RELOC_IA64_TPREL64MSB: bfd_reloc_code_real = 1577;
pub const BFD_RELOC_IA64_TPREL64I: bfd_reloc_code_real = 1576;
pub const BFD_RELOC_IA64_TPREL22: bfd_reloc_code_real = 1575;
pub const BFD_RELOC_IA64_TPREL14: bfd_reloc_code_real = 1574;
pub const BFD_RELOC_IA64_LDXMOV: bfd_reloc_code_real = 1573;
pub const BFD_RELOC_IA64_LTOFF22X: bfd_reloc_code_real = 1572;
pub const BFD_RELOC_IA64_COPY: bfd_reloc_code_real = 1571;
pub const BFD_RELOC_IA64_IPLTLSB: bfd_reloc_code_real = 1570;
pub const BFD_RELOC_IA64_IPLTMSB: bfd_reloc_code_real = 1569;
pub const BFD_RELOC_IA64_LTV64LSB: bfd_reloc_code_real = 1568;
pub const BFD_RELOC_IA64_LTV64MSB: bfd_reloc_code_real = 1567;
pub const BFD_RELOC_IA64_LTV32LSB: bfd_reloc_code_real = 1566;
pub const BFD_RELOC_IA64_LTV32MSB: bfd_reloc_code_real = 1565;
pub const BFD_RELOC_IA64_REL64LSB: bfd_reloc_code_real = 1564;
pub const BFD_RELOC_IA64_REL64MSB: bfd_reloc_code_real = 1563;
pub const BFD_RELOC_IA64_REL32LSB: bfd_reloc_code_real = 1562;
pub const BFD_RELOC_IA64_REL32MSB: bfd_reloc_code_real = 1561;
pub const BFD_RELOC_IA64_SECREL64LSB: bfd_reloc_code_real = 1560;
pub const BFD_RELOC_IA64_SECREL64MSB: bfd_reloc_code_real = 1559;
pub const BFD_RELOC_IA64_SECREL32LSB: bfd_reloc_code_real = 1558;
pub const BFD_RELOC_IA64_SECREL32MSB: bfd_reloc_code_real = 1557;
pub const BFD_RELOC_IA64_SEGREL64LSB: bfd_reloc_code_real = 1556;
pub const BFD_RELOC_IA64_SEGREL64MSB: bfd_reloc_code_real = 1555;
pub const BFD_RELOC_IA64_SEGREL32LSB: bfd_reloc_code_real = 1554;
pub const BFD_RELOC_IA64_SEGREL32MSB: bfd_reloc_code_real = 1553;
pub const BFD_RELOC_IA64_LTOFF_FPTR64LSB: bfd_reloc_code_real = 1552;
pub const BFD_RELOC_IA64_LTOFF_FPTR64MSB: bfd_reloc_code_real = 1551;
pub const BFD_RELOC_IA64_LTOFF_FPTR32LSB: bfd_reloc_code_real = 1550;
pub const BFD_RELOC_IA64_LTOFF_FPTR32MSB: bfd_reloc_code_real = 1549;
pub const BFD_RELOC_IA64_LTOFF_FPTR64I: bfd_reloc_code_real = 1548;
pub const BFD_RELOC_IA64_LTOFF_FPTR22: bfd_reloc_code_real = 1547;
pub const BFD_RELOC_IA64_PCREL64LSB: bfd_reloc_code_real = 1546;
pub const BFD_RELOC_IA64_PCREL64MSB: bfd_reloc_code_real = 1545;
pub const BFD_RELOC_IA64_PCREL32LSB: bfd_reloc_code_real = 1544;
pub const BFD_RELOC_IA64_PCREL32MSB: bfd_reloc_code_real = 1543;
pub const BFD_RELOC_IA64_PCREL64I: bfd_reloc_code_real = 1542;
pub const BFD_RELOC_IA64_PCREL60B: bfd_reloc_code_real = 1541;
pub const BFD_RELOC_IA64_PCREL22: bfd_reloc_code_real = 1540;
pub const BFD_RELOC_IA64_PCREL21F: bfd_reloc_code_real = 1539;
pub const BFD_RELOC_IA64_PCREL21M: bfd_reloc_code_real = 1538;
pub const BFD_RELOC_IA64_PCREL21BI: bfd_reloc_code_real = 1537;
pub const BFD_RELOC_IA64_PCREL21B: bfd_reloc_code_real = 1536;
pub const BFD_RELOC_IA64_FPTR64LSB: bfd_reloc_code_real = 1535;
pub const BFD_RELOC_IA64_FPTR64MSB: bfd_reloc_code_real = 1534;
pub const BFD_RELOC_IA64_FPTR32LSB: bfd_reloc_code_real = 1533;
pub const BFD_RELOC_IA64_FPTR32MSB: bfd_reloc_code_real = 1532;
pub const BFD_RELOC_IA64_FPTR64I: bfd_reloc_code_real = 1531;
pub const BFD_RELOC_IA64_PLTOFF64LSB: bfd_reloc_code_real = 1530;
pub const BFD_RELOC_IA64_PLTOFF64MSB: bfd_reloc_code_real = 1529;
pub const BFD_RELOC_IA64_PLTOFF64I: bfd_reloc_code_real = 1528;
pub const BFD_RELOC_IA64_PLTOFF22: bfd_reloc_code_real = 1527;
pub const BFD_RELOC_IA64_LTOFF64I: bfd_reloc_code_real = 1526;
pub const BFD_RELOC_IA64_LTOFF22: bfd_reloc_code_real = 1525;
pub const BFD_RELOC_IA64_GPREL64LSB: bfd_reloc_code_real = 1524;
pub const BFD_RELOC_IA64_GPREL64MSB: bfd_reloc_code_real = 1523;
pub const BFD_RELOC_IA64_GPREL32LSB: bfd_reloc_code_real = 1522;
pub const BFD_RELOC_IA64_GPREL32MSB: bfd_reloc_code_real = 1521;
pub const BFD_RELOC_IA64_GPREL64I: bfd_reloc_code_real = 1520;
pub const BFD_RELOC_IA64_GPREL22: bfd_reloc_code_real = 1519;
pub const BFD_RELOC_IA64_DIR64LSB: bfd_reloc_code_real = 1518;
pub const BFD_RELOC_IA64_DIR64MSB: bfd_reloc_code_real = 1517;
pub const BFD_RELOC_IA64_DIR32LSB: bfd_reloc_code_real = 1516;
pub const BFD_RELOC_IA64_DIR32MSB: bfd_reloc_code_real = 1515;
pub const BFD_RELOC_IA64_IMM64: bfd_reloc_code_real = 1514;
pub const BFD_RELOC_IA64_IMM22: bfd_reloc_code_real = 1513;
pub const BFD_RELOC_IA64_IMM14: bfd_reloc_code_real = 1512;
pub const BFD_RELOC_VTABLE_ENTRY: bfd_reloc_code_real = 1511;
pub const BFD_RELOC_VTABLE_INHERIT: bfd_reloc_code_real = 1510;
pub const BFD_RELOC_VPE4KMATH_INSN: bfd_reloc_code_real = 1509;
pub const BFD_RELOC_VPE4KMATH_DATA: bfd_reloc_code_real = 1508;
pub const BFD_RELOC_IP2K_FR_OFFSET: bfd_reloc_code_real = 1507;
pub const BFD_RELOC_IP2K_TEXT: bfd_reloc_code_real = 1506;
pub const BFD_RELOC_IP2K_PC_SKIP: bfd_reloc_code_real = 1505;
pub const BFD_RELOC_IP2K_HI8INSN: bfd_reloc_code_real = 1504;
pub const BFD_RELOC_IP2K_LO8INSN: bfd_reloc_code_real = 1503;
pub const BFD_RELOC_IP2K_EX8DATA: bfd_reloc_code_real = 1502;
pub const BFD_RELOC_IP2K_HI8DATA: bfd_reloc_code_real = 1501;
pub const BFD_RELOC_IP2K_LO8DATA: bfd_reloc_code_real = 1500;
pub const BFD_RELOC_IP2K_PAGE3: bfd_reloc_code_real = 1499;
pub const BFD_RELOC_IP2K_ADDR16CJP: bfd_reloc_code_real = 1498;
pub const BFD_RELOC_IP2K_BANK: bfd_reloc_code_real = 1497;
pub const BFD_RELOC_IP2K_FR9: bfd_reloc_code_real = 1496;
pub const BFD_RELOC_SCORE_DUMMY_HI16: bfd_reloc_code_real = 1495;
pub const BFD_RELOC_SCORE_CALL15: bfd_reloc_code_real = 1494;
pub const BFD_RELOC_SCORE_GOT_LO16: bfd_reloc_code_real = 1493;
pub const BFD_RELOC_SCORE_GOT15: bfd_reloc_code_real = 1492;
pub const BFD_RELOC_SCORE_BCMP: bfd_reloc_code_real = 1491;
pub const BFD_RELOC_SCORE16_BRANCH: bfd_reloc_code_real = 1490;
pub const BFD_RELOC_SCORE16_JMP: bfd_reloc_code_real = 1489;
pub const BFD_RELOC_SCORE_IMM32: bfd_reloc_code_real = 1488;
pub const BFD_RELOC_SCORE_IMM30: bfd_reloc_code_real = 1487;
pub const BFD_RELOC_SCORE_BRANCH: bfd_reloc_code_real = 1486;
pub const BFD_RELOC_SCORE_JMP: bfd_reloc_code_real = 1485;
pub const BFD_RELOC_SCORE_DUMMY2: bfd_reloc_code_real = 1484;
pub const BFD_RELOC_SCORE_GPREL15: bfd_reloc_code_real = 1483;
pub const BFD_RELOC_390_IRELATIVE: bfd_reloc_code_real = 1482;
pub const BFD_RELOC_390_TLS_GOTIE20: bfd_reloc_code_real = 1481;
pub const BFD_RELOC_390_GOTPLT20: bfd_reloc_code_real = 1480;
pub const BFD_RELOC_390_GOT20: bfd_reloc_code_real = 1479;
pub const BFD_RELOC_390_20: bfd_reloc_code_real = 1478;
pub const BFD_RELOC_390_TLS_TPOFF: bfd_reloc_code_real = 1477;
pub const BFD_RELOC_390_TLS_DTPOFF: bfd_reloc_code_real = 1476;
pub const BFD_RELOC_390_TLS_DTPMOD: bfd_reloc_code_real = 1475;
pub const BFD_RELOC_390_TLS_LDO64: bfd_reloc_code_real = 1474;
pub const BFD_RELOC_390_TLS_LDO32: bfd_reloc_code_real = 1473;
pub const BFD_RELOC_390_TLS_LE64: bfd_reloc_code_real = 1472;
pub const BFD_RELOC_390_TLS_LE32: bfd_reloc_code_real = 1471;
pub const BFD_RELOC_390_TLS_IEENT: bfd_reloc_code_real = 1470;
pub const BFD_RELOC_390_TLS_IE64: bfd_reloc_code_real = 1469;
pub const BFD_RELOC_390_TLS_IE32: bfd_reloc_code_real = 1468;
pub const BFD_RELOC_390_TLS_LDM64: bfd_reloc_code_real = 1467;
pub const BFD_RELOC_390_TLS_LDM32: bfd_reloc_code_real = 1466;
pub const BFD_RELOC_390_TLS_GOTIE64: bfd_reloc_code_real = 1465;
pub const BFD_RELOC_390_TLS_GOTIE32: bfd_reloc_code_real = 1464;
pub const BFD_RELOC_390_TLS_GOTIE12: bfd_reloc_code_real = 1463;
pub const BFD_RELOC_390_TLS_GD64: bfd_reloc_code_real = 1462;
pub const BFD_RELOC_390_TLS_GD32: bfd_reloc_code_real = 1461;
pub const BFD_RELOC_390_TLS_LDCALL: bfd_reloc_code_real = 1460;
pub const BFD_RELOC_390_TLS_GDCALL: bfd_reloc_code_real = 1459;
pub const BFD_RELOC_390_TLS_LOAD: bfd_reloc_code_real = 1458;
pub const BFD_RELOC_390_PLTOFF64: bfd_reloc_code_real = 1457;
pub const BFD_RELOC_390_PLTOFF32: bfd_reloc_code_real = 1456;
pub const BFD_RELOC_390_PLTOFF16: bfd_reloc_code_real = 1455;
pub const BFD_RELOC_390_GOTPLTENT: bfd_reloc_code_real = 1454;
pub const BFD_RELOC_390_GOTPLT64: bfd_reloc_code_real = 1453;
pub const BFD_RELOC_390_GOTPLT32: bfd_reloc_code_real = 1452;
pub const BFD_RELOC_390_GOTPLT16: bfd_reloc_code_real = 1451;
pub const BFD_RELOC_390_GOTPLT12: bfd_reloc_code_real = 1450;
pub const BFD_RELOC_390_GOTOFF64: bfd_reloc_code_real = 1449;
pub const BFD_RELOC_390_GOTENT: bfd_reloc_code_real = 1448;
pub const BFD_RELOC_390_PLT64: bfd_reloc_code_real = 1447;
pub const BFD_RELOC_390_GOT64: bfd_reloc_code_real = 1446;
pub const BFD_RELOC_390_GOTPCDBL: bfd_reloc_code_real = 1445;
pub const BFD_RELOC_390_PLT32DBL: bfd_reloc_code_real = 1444;
pub const BFD_RELOC_390_PC32DBL: bfd_reloc_code_real = 1443;
pub const BFD_RELOC_390_PLT24DBL: bfd_reloc_code_real = 1442;
pub const BFD_RELOC_390_PC24DBL: bfd_reloc_code_real = 1441;
pub const BFD_RELOC_390_PLT16DBL: bfd_reloc_code_real = 1440;
pub const BFD_RELOC_390_PC16DBL: bfd_reloc_code_real = 1439;
pub const BFD_RELOC_390_PLT12DBL: bfd_reloc_code_real = 1438;
pub const BFD_RELOC_390_PC12DBL: bfd_reloc_code_real = 1437;
pub const BFD_RELOC_390_GOT16: bfd_reloc_code_real = 1436;
pub const BFD_RELOC_390_GOTPC: bfd_reloc_code_real = 1435;
pub const BFD_RELOC_390_RELATIVE: bfd_reloc_code_real = 1434;
pub const BFD_RELOC_390_JMP_SLOT: bfd_reloc_code_real = 1433;
pub const BFD_RELOC_390_GLOB_DAT: bfd_reloc_code_real = 1432;
pub const BFD_RELOC_390_COPY: bfd_reloc_code_real = 1431;
pub const BFD_RELOC_390_PLT32: bfd_reloc_code_real = 1430;
pub const BFD_RELOC_390_GOT12: bfd_reloc_code_real = 1429;
pub const BFD_RELOC_390_12: bfd_reloc_code_real = 1428;
pub const BFD_RELOC_RX_RELAX: bfd_reloc_code_real = 1427;
pub const BFD_RELOC_RX_ABS16UL: bfd_reloc_code_real = 1426;
pub const BFD_RELOC_RX_ABS16UW: bfd_reloc_code_real = 1425;
pub const BFD_RELOC_RX_ABS16U: bfd_reloc_code_real = 1424;
pub const BFD_RELOC_RX_ABS32_REV: bfd_reloc_code_real = 1423;
pub const BFD_RELOC_RX_ABS32: bfd_reloc_code_real = 1422;
pub const BFD_RELOC_RX_ABS16_REV: bfd_reloc_code_real = 1421;
pub const BFD_RELOC_RX_ABS16: bfd_reloc_code_real = 1420;
pub const BFD_RELOC_RX_ABS8: bfd_reloc_code_real = 1419;
pub const BFD_RELOC_RX_OP_NEG: bfd_reloc_code_real = 1418;
pub const BFD_RELOC_RX_OP_SUBTRACT: bfd_reloc_code_real = 1417;
pub const BFD_RELOC_RX_SYM: bfd_reloc_code_real = 1416;
pub const BFD_RELOC_RX_GPRELL: bfd_reloc_code_real = 1415;
pub const BFD_RELOC_RX_GPRELW: bfd_reloc_code_real = 1414;
pub const BFD_RELOC_RX_GPRELB: bfd_reloc_code_real = 1413;
pub const BFD_RELOC_RX_DIFF: bfd_reloc_code_real = 1412;
pub const BFD_RELOC_RX_DIR3U_PCREL: bfd_reloc_code_real = 1411;
pub const BFD_RELOC_RX_24U: bfd_reloc_code_real = 1410;
pub const BFD_RELOC_RX_16U: bfd_reloc_code_real = 1409;
pub const BFD_RELOC_RX_8U: bfd_reloc_code_real = 1408;
pub const BFD_RELOC_RX_32_OP: bfd_reloc_code_real = 1407;
pub const BFD_RELOC_RX_24_OP: bfd_reloc_code_real = 1406;
pub const BFD_RELOC_RX_16_OP: bfd_reloc_code_real = 1405;
pub const BFD_RELOC_RX_NEG32: bfd_reloc_code_real = 1404;
pub const BFD_RELOC_RX_NEG24: bfd_reloc_code_real = 1403;
pub const BFD_RELOC_RX_NEG16: bfd_reloc_code_real = 1402;
pub const BFD_RELOC_RX_NEG8: bfd_reloc_code_real = 1401;
pub const BFD_RELOC_RL78_SADDR: bfd_reloc_code_real = 1400;
pub const BFD_RELOC_RL78_CODE: bfd_reloc_code_real = 1399;
pub const BFD_RELOC_RL78_LO16: bfd_reloc_code_real = 1398;
pub const BFD_RELOC_RL78_HI8: bfd_reloc_code_real = 1397;
pub const BFD_RELOC_RL78_HI16: bfd_reloc_code_real = 1396;
pub const BFD_RELOC_RL78_RELAX: bfd_reloc_code_real = 1395;
pub const BFD_RELOC_RL78_ABS16UL: bfd_reloc_code_real = 1394;
pub const BFD_RELOC_RL78_ABS16UW: bfd_reloc_code_real = 1393;
pub const BFD_RELOC_RL78_ABS16U: bfd_reloc_code_real = 1392;
pub const BFD_RELOC_RL78_ABS32_REV: bfd_reloc_code_real = 1391;
pub const BFD_RELOC_RL78_ABS32: bfd_reloc_code_real = 1390;
pub const BFD_RELOC_RL78_ABS16_REV: bfd_reloc_code_real = 1389;
pub const BFD_RELOC_RL78_ABS16: bfd_reloc_code_real = 1388;
pub const BFD_RELOC_RL78_ABS8: bfd_reloc_code_real = 1387;
pub const BFD_RELOC_RL78_OP_SHRA: bfd_reloc_code_real = 1386;
pub const BFD_RELOC_RL78_OP_AND: bfd_reloc_code_real = 1385;
pub const BFD_RELOC_RL78_OP_NEG: bfd_reloc_code_real = 1384;
pub const BFD_RELOC_RL78_OP_SUBTRACT: bfd_reloc_code_real = 1383;
pub const BFD_RELOC_RL78_SYM: bfd_reloc_code_real = 1382;
pub const BFD_RELOC_RL78_GPRELL: bfd_reloc_code_real = 1381;
pub const BFD_RELOC_RL78_GPRELW: bfd_reloc_code_real = 1380;
pub const BFD_RELOC_RL78_GPRELB: bfd_reloc_code_real = 1379;
pub const BFD_RELOC_RL78_DIFF: bfd_reloc_code_real = 1378;
pub const BFD_RELOC_RL78_DIR3U_PCREL: bfd_reloc_code_real = 1377;
pub const BFD_RELOC_RL78_24U: bfd_reloc_code_real = 1376;
pub const BFD_RELOC_RL78_16U: bfd_reloc_code_real = 1375;
pub const BFD_RELOC_RL78_8U: bfd_reloc_code_real = 1374;
pub const BFD_RELOC_RL78_32_OP: bfd_reloc_code_real = 1373;
pub const BFD_RELOC_RL78_24_OP: bfd_reloc_code_real = 1372;
pub const BFD_RELOC_RL78_16_OP: bfd_reloc_code_real = 1371;
pub const BFD_RELOC_RL78_NEG32: bfd_reloc_code_real = 1370;
pub const BFD_RELOC_RL78_NEG24: bfd_reloc_code_real = 1369;
pub const BFD_RELOC_RL78_NEG16: bfd_reloc_code_real = 1368;
pub const BFD_RELOC_RL78_NEG8: bfd_reloc_code_real = 1367;
pub const BFD_RELOC_RISCV_32_PCREL: bfd_reloc_code_real = 1366;
pub const BFD_RELOC_RISCV_SET32: bfd_reloc_code_real = 1365;
pub const BFD_RELOC_RISCV_SET16: bfd_reloc_code_real = 1364;
pub const BFD_RELOC_RISCV_SET8: bfd_reloc_code_real = 1363;
pub const BFD_RELOC_RISCV_SET6: bfd_reloc_code_real = 1362;
pub const BFD_RELOC_RISCV_SUB6: bfd_reloc_code_real = 1361;
pub const BFD_RELOC_RISCV_CFA: bfd_reloc_code_real = 1360;
pub const BFD_RELOC_RISCV_RELAX: bfd_reloc_code_real = 1359;
pub const BFD_RELOC_RISCV_TPREL_S: bfd_reloc_code_real = 1358;
pub const BFD_RELOC_RISCV_TPREL_I: bfd_reloc_code_real = 1357;
pub const BFD_RELOC_RISCV_GPREL_S: bfd_reloc_code_real = 1356;
pub const BFD_RELOC_RISCV_GPREL_I: bfd_reloc_code_real = 1355;
pub const BFD_RELOC_RISCV_RVC_LUI: bfd_reloc_code_real = 1354;
pub const BFD_RELOC_RISCV_RVC_JUMP: bfd_reloc_code_real = 1353;
pub const BFD_RELOC_RISCV_RVC_BRANCH: bfd_reloc_code_real = 1352;
pub const BFD_RELOC_RISCV_ALIGN: bfd_reloc_code_real = 1351;
pub const BFD_RELOC_RISCV_TLS_TPREL64: bfd_reloc_code_real = 1350;
pub const BFD_RELOC_RISCV_TLS_TPREL32: bfd_reloc_code_real = 1349;
pub const BFD_RELOC_RISCV_TLS_DTPREL64: bfd_reloc_code_real = 1348;
pub const BFD_RELOC_RISCV_TLS_DTPMOD64: bfd_reloc_code_real = 1347;
pub const BFD_RELOC_RISCV_TLS_DTPREL32: bfd_reloc_code_real = 1346;
pub const BFD_RELOC_RISCV_TLS_DTPMOD32: bfd_reloc_code_real = 1345;
pub const BFD_RELOC_RISCV_JMP: bfd_reloc_code_real = 1344;
pub const BFD_RELOC_RISCV_TLS_GD_HI20: bfd_reloc_code_real = 1343;
pub const BFD_RELOC_RISCV_TLS_GOT_HI20: bfd_reloc_code_real = 1342;
pub const BFD_RELOC_RISCV_GOT_HI20: bfd_reloc_code_real = 1341;
pub const BFD_RELOC_RISCV_SUB64: bfd_reloc_code_real = 1340;
pub const BFD_RELOC_RISCV_SUB32: bfd_reloc_code_real = 1339;
pub const BFD_RELOC_RISCV_SUB16: bfd_reloc_code_real = 1338;
pub const BFD_RELOC_RISCV_SUB8: bfd_reloc_code_real = 1337;
pub const BFD_RELOC_RISCV_ADD64: bfd_reloc_code_real = 1336;
pub const BFD_RELOC_RISCV_ADD32: bfd_reloc_code_real = 1335;
pub const BFD_RELOC_RISCV_ADD16: bfd_reloc_code_real = 1334;
pub const BFD_RELOC_RISCV_ADD8: bfd_reloc_code_real = 1333;
pub const BFD_RELOC_RISCV_CALL_PLT: bfd_reloc_code_real = 1332;
pub const BFD_RELOC_RISCV_CALL: bfd_reloc_code_real = 1331;
pub const BFD_RELOC_RISCV_TPREL_ADD: bfd_reloc_code_real = 1330;
pub const BFD_RELOC_RISCV_TPREL_LO12_S: bfd_reloc_code_real = 1329;
pub const BFD_RELOC_RISCV_TPREL_LO12_I: bfd_reloc_code_real = 1328;
pub const BFD_RELOC_RISCV_TPREL_HI20: bfd_reloc_code_real = 1327;
pub const BFD_RELOC_RISCV_GPREL12_S: bfd_reloc_code_real = 1326;
pub const BFD_RELOC_RISCV_GPREL12_I: bfd_reloc_code_real = 1325;
pub const BFD_RELOC_RISCV_LO12_S: bfd_reloc_code_real = 1324;
pub const BFD_RELOC_RISCV_LO12_I: bfd_reloc_code_real = 1323;
pub const BFD_RELOC_RISCV_PCREL_LO12_S: bfd_reloc_code_real = 1322;
pub const BFD_RELOC_RISCV_PCREL_LO12_I: bfd_reloc_code_real = 1321;
pub const BFD_RELOC_RISCV_PCREL_HI20: bfd_reloc_code_real = 1320;
pub const BFD_RELOC_RISCV_HI20: bfd_reloc_code_real = 1319;
pub const BFD_RELOC_AVR_PORT5: bfd_reloc_code_real = 1318;
pub const BFD_RELOC_AVR_PORT6: bfd_reloc_code_real = 1317;
pub const BFD_RELOC_AVR_LDS_STS_16: bfd_reloc_code_real = 1316;
pub const BFD_RELOC_AVR_DIFF32: bfd_reloc_code_real = 1315;
pub const BFD_RELOC_AVR_DIFF16: bfd_reloc_code_real = 1314;
pub const BFD_RELOC_AVR_DIFF8: bfd_reloc_code_real = 1313;
pub const BFD_RELOC_AVR_8_HLO: bfd_reloc_code_real = 1312;
pub const BFD_RELOC_AVR_8_HI: bfd_reloc_code_real = 1311;
pub const BFD_RELOC_AVR_8_LO: bfd_reloc_code_real = 1310;
pub const BFD_RELOC_AVR_6_ADIW: bfd_reloc_code_real = 1309;
pub const BFD_RELOC_AVR_6: bfd_reloc_code_real = 1308;
pub const BFD_RELOC_AVR_LDI: bfd_reloc_code_real = 1307;
pub const BFD_RELOC_AVR_CALL: bfd_reloc_code_real = 1306;
pub const BFD_RELOC_AVR_HH8_LDI_PM_NEG: bfd_reloc_code_real = 1305;
pub const BFD_RELOC_AVR_HI8_LDI_PM_NEG: bfd_reloc_code_real = 1304;
pub const BFD_RELOC_AVR_LO8_LDI_PM_NEG: bfd_reloc_code_real = 1303;
pub const BFD_RELOC_AVR_HH8_LDI_PM: bfd_reloc_code_real = 1302;
pub const BFD_RELOC_AVR_HI8_LDI_GS: bfd_reloc_code_real = 1301;
pub const BFD_RELOC_AVR_HI8_LDI_PM: bfd_reloc_code_real = 1300;
pub const BFD_RELOC_AVR_LO8_LDI_GS: bfd_reloc_code_real = 1299;
pub const BFD_RELOC_AVR_LO8_LDI_PM: bfd_reloc_code_real = 1298;
pub const BFD_RELOC_AVR_MS8_LDI_NEG: bfd_reloc_code_real = 1297;
pub const BFD_RELOC_AVR_HH8_LDI_NEG: bfd_reloc_code_real = 1296;
pub const BFD_RELOC_AVR_HI8_LDI_NEG: bfd_reloc_code_real = 1295;
pub const BFD_RELOC_AVR_LO8_LDI_NEG: bfd_reloc_code_real = 1294;
pub const BFD_RELOC_AVR_MS8_LDI: bfd_reloc_code_real = 1293;
pub const BFD_RELOC_AVR_HH8_LDI: bfd_reloc_code_real = 1292;
pub const BFD_RELOC_AVR_HI8_LDI: bfd_reloc_code_real = 1291;
pub const BFD_RELOC_AVR_LO8_LDI: bfd_reloc_code_real = 1290;
pub const BFD_RELOC_AVR_16_PM: bfd_reloc_code_real = 1289;
pub const BFD_RELOC_AVR_13_PCREL: bfd_reloc_code_real = 1288;
pub const BFD_RELOC_AVR_7_PCREL: bfd_reloc_code_real = 1287;
pub const BFD_RELOC_MMIX_LOCAL: bfd_reloc_code_real = 1286;
pub const BFD_RELOC_MMIX_BASE_PLUS_OFFSET: bfd_reloc_code_real = 1285;
pub const BFD_RELOC_MMIX_REG: bfd_reloc_code_real = 1284;
pub const BFD_RELOC_MMIX_REG_OR_BYTE: bfd_reloc_code_real = 1283;
pub const BFD_RELOC_MMIX_ADDR27: bfd_reloc_code_real = 1282;
pub const BFD_RELOC_MMIX_ADDR19: bfd_reloc_code_real = 1281;
pub const BFD_RELOC_MMIX_JMP_3: bfd_reloc_code_real = 1280;
pub const BFD_RELOC_MMIX_JMP_2: bfd_reloc_code_real = 1279;
pub const BFD_RELOC_MMIX_JMP_1: bfd_reloc_code_real = 1278;
pub const BFD_RELOC_MMIX_JMP: bfd_reloc_code_real = 1277;
pub const BFD_RELOC_MMIX_PUSHJ_STUBBABLE: bfd_reloc_code_real = 1276;
pub const BFD_RELOC_MMIX_PUSHJ_3: bfd_reloc_code_real = 1275;
pub const BFD_RELOC_MMIX_PUSHJ_2: bfd_reloc_code_real = 1274;
pub const BFD_RELOC_MMIX_PUSHJ_1: bfd_reloc_code_real = 1273;
pub const BFD_RELOC_MMIX_PUSHJ: bfd_reloc_code_real = 1272;
pub const BFD_RELOC_MMIX_CBRANCH_3: bfd_reloc_code_real = 1271;
pub const BFD_RELOC_MMIX_CBRANCH_2: bfd_reloc_code_real = 1270;
pub const BFD_RELOC_MMIX_CBRANCH_1: bfd_reloc_code_real = 1269;
pub const BFD_RELOC_MMIX_CBRANCH_J: bfd_reloc_code_real = 1268;
pub const BFD_RELOC_MMIX_CBRANCH: bfd_reloc_code_real = 1267;
pub const BFD_RELOC_MMIX_GETA_3: bfd_reloc_code_real = 1266;
pub const BFD_RELOC_MMIX_GETA_2: bfd_reloc_code_real = 1265;
pub const BFD_RELOC_MMIX_GETA_1: bfd_reloc_code_real = 1264;
pub const BFD_RELOC_MMIX_GETA: bfd_reloc_code_real = 1263;
pub const BFD_RELOC_METAG_TLS_LE_LO16: bfd_reloc_code_real = 1262;
pub const BFD_RELOC_METAG_TLS_LE_HI16: bfd_reloc_code_real = 1261;
pub const BFD_RELOC_METAG_TLS_LE: bfd_reloc_code_real = 1260;
pub const BFD_RELOC_METAG_TLS_DTPOFF: bfd_reloc_code_real = 1259;
pub const BFD_RELOC_METAG_TLS_DTPMOD: bfd_reloc_code_real = 1258;
pub const BFD_RELOC_METAG_TLS_TPOFF: bfd_reloc_code_real = 1257;
pub const BFD_RELOC_METAG_TLS_IENONPIC_LO16: bfd_reloc_code_real = 1256;
pub const BFD_RELOC_METAG_TLS_IENONPIC_HI16: bfd_reloc_code_real = 1255;
pub const BFD_RELOC_METAG_TLS_IENONPIC: bfd_reloc_code_real = 1254;
pub const BFD_RELOC_METAG_TLS_IE: bfd_reloc_code_real = 1253;
pub const BFD_RELOC_METAG_TLS_LDO: bfd_reloc_code_real = 1252;
pub const BFD_RELOC_METAG_TLS_LDO_LO16: bfd_reloc_code_real = 1251;
pub const BFD_RELOC_METAG_TLS_LDO_HI16: bfd_reloc_code_real = 1250;
pub const BFD_RELOC_METAG_TLS_LDM: bfd_reloc_code_real = 1249;
pub const BFD_RELOC_METAG_TLS_GD: bfd_reloc_code_real = 1248;
pub const BFD_RELOC_METAG_GLOB_DAT: bfd_reloc_code_real = 1247;
pub const BFD_RELOC_METAG_RELATIVE: bfd_reloc_code_real = 1246;
pub const BFD_RELOC_METAG_JMP_SLOT: bfd_reloc_code_real = 1245;
pub const BFD_RELOC_METAG_COPY: bfd_reloc_code_real = 1244;
pub const BFD_RELOC_METAG_PLT: bfd_reloc_code_real = 1243;
pub const BFD_RELOC_METAG_GOTOFF: bfd_reloc_code_real = 1242;
pub const BFD_RELOC_METAG_RELBRANCH_PLT: bfd_reloc_code_real = 1241;
pub const BFD_RELOC_METAG_LO16_PLT: bfd_reloc_code_real = 1240;
pub const BFD_RELOC_METAG_HI16_PLT: bfd_reloc_code_real = 1239;
pub const BFD_RELOC_METAG_LO16_GOTPC: bfd_reloc_code_real = 1238;
pub const BFD_RELOC_METAG_HI16_GOTPC: bfd_reloc_code_real = 1237;
pub const BFD_RELOC_METAG_GETSET_GOT: bfd_reloc_code_real = 1236;
pub const BFD_RELOC_METAG_GETSET_GOTOFF: bfd_reloc_code_real = 1235;
pub const BFD_RELOC_METAG_LO16_GOTOFF: bfd_reloc_code_real = 1234;
pub const BFD_RELOC_METAG_HI16_GOTOFF: bfd_reloc_code_real = 1233;
pub const BFD_RELOC_METAG_REL16: bfd_reloc_code_real = 1232;
pub const BFD_RELOC_METAG_REL8: bfd_reloc_code_real = 1231;
pub const BFD_RELOC_METAG_LOOG: bfd_reloc_code_real = 1230;
pub const BFD_RELOC_METAG_HIOG: bfd_reloc_code_real = 1229;
pub const BFD_RELOC_METAG_GETSETOFF: bfd_reloc_code_real = 1228;
pub const BFD_RELOC_METAG_RELBRANCH: bfd_reloc_code_real = 1227;
pub const BFD_RELOC_METAG_LOADDR16: bfd_reloc_code_real = 1226;
pub const BFD_RELOC_METAG_HIADDR16: bfd_reloc_code_real = 1225;
pub const BFD_RELOC_MEP_GNU_VTENTRY: bfd_reloc_code_real = 1224;
pub const BFD_RELOC_MEP_GNU_VTINHERIT: bfd_reloc_code_real = 1223;
pub const BFD_RELOC_MEP_ADDR24A4: bfd_reloc_code_real = 1222;
pub const BFD_RELOC_MEP_UIMM24: bfd_reloc_code_real = 1221;
pub const BFD_RELOC_MEP_TPREL7A4: bfd_reloc_code_real = 1220;
pub const BFD_RELOC_MEP_TPREL7A2: bfd_reloc_code_real = 1219;
pub const BFD_RELOC_MEP_TPREL7: bfd_reloc_code_real = 1218;
pub const BFD_RELOC_MEP_TPREL: bfd_reloc_code_real = 1217;
pub const BFD_RELOC_MEP_GPREL: bfd_reloc_code_real = 1216;
pub const BFD_RELOC_MEP_HI16S: bfd_reloc_code_real = 1215;
pub const BFD_RELOC_MEP_HI16U: bfd_reloc_code_real = 1214;
pub const BFD_RELOC_MEP_LOW16: bfd_reloc_code_real = 1213;
pub const BFD_RELOC_MEP_PCABS24A2: bfd_reloc_code_real = 1212;
pub const BFD_RELOC_MEP_PCREL24A2: bfd_reloc_code_real = 1211;
pub const BFD_RELOC_MEP_PCREL17A2: bfd_reloc_code_real = 1210;
pub const BFD_RELOC_MEP_PCREL12A2: bfd_reloc_code_real = 1209;
pub const BFD_RELOC_MEP_PCREL8A2: bfd_reloc_code_real = 1208;
pub const BFD_RELOC_MEP_32: bfd_reloc_code_real = 1207;
pub const BFD_RELOC_MEP_16: bfd_reloc_code_real = 1206;
pub const BFD_RELOC_MEP_8: bfd_reloc_code_real = 1205;
pub const BFD_RELOC_MCORE_RVA: bfd_reloc_code_real = 1204;
pub const BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2: bfd_reloc_code_real = 1203;
pub const BFD_RELOC_MCORE_PCREL_32: bfd_reloc_code_real = 1202;
pub const BFD_RELOC_MCORE_PCREL_IMM4BY2: bfd_reloc_code_real = 1201;
pub const BFD_RELOC_MCORE_PCREL_IMM11BY2: bfd_reloc_code_real = 1200;
pub const BFD_RELOC_MCORE_PCREL_IMM8BY4: bfd_reloc_code_real = 1199;
pub const BFD_RELOC_FR30_12_PCREL: bfd_reloc_code_real = 1198;
pub const BFD_RELOC_FR30_9_PCREL: bfd_reloc_code_real = 1197;
pub const BFD_RELOC_FR30_10_IN_8: bfd_reloc_code_real = 1196;
pub const BFD_RELOC_FR30_9_IN_8: bfd_reloc_code_real = 1195;
pub const BFD_RELOC_FR30_8_IN_8: bfd_reloc_code_real = 1194;
pub const BFD_RELOC_FR30_6_IN_4: bfd_reloc_code_real = 1193;
pub const BFD_RELOC_FR30_20: bfd_reloc_code_real = 1192;
pub const BFD_RELOC_FR30_48: bfd_reloc_code_real = 1191;
pub const BFD_RELOC_C6000_NOCMP: bfd_reloc_code_real = 1190;
pub const BFD_RELOC_C6000_FPHEAD: bfd_reloc_code_real = 1189;
pub const BFD_RELOC_C6000_ALIGN: bfd_reloc_code_real = 1188;
pub const BFD_RELOC_C6000_PCR_L16: bfd_reloc_code_real = 1187;
pub const BFD_RELOC_C6000_PCR_H16: bfd_reloc_code_real = 1186;
pub const BFD_RELOC_C6000_EHTYPE: bfd_reloc_code_real = 1185;
pub const BFD_RELOC_C6000_JUMP_SLOT: bfd_reloc_code_real = 1184;
pub const BFD_RELOC_C6000_COPY: bfd_reloc_code_real = 1183;
pub const BFD_RELOC_C6000_PREL31: bfd_reloc_code_real = 1182;
pub const BFD_RELOC_C6000_DSBT_INDEX: bfd_reloc_code_real = 1181;
pub const BFD_RELOC_C6000_SBR_GOT_H16_W: bfd_reloc_code_real = 1180;
pub const BFD_RELOC_C6000_SBR_GOT_L16_W: bfd_reloc_code_real = 1179;
pub const BFD_RELOC_C6000_SBR_GOT_U15_W: bfd_reloc_code_real = 1178;
pub const BFD_RELOC_C6000_SBR_H16_W: bfd_reloc_code_real = 1177;
pub const BFD_RELOC_C6000_SBR_H16_H: bfd_reloc_code_real = 1176;
pub const BFD_RELOC_C6000_SBR_H16_B: bfd_reloc_code_real = 1175;
pub const BFD_RELOC_C6000_SBR_L16_W: bfd_reloc_code_real = 1174;
pub const BFD_RELOC_C6000_SBR_L16_H: bfd_reloc_code_real = 1173;
pub const BFD_RELOC_C6000_SBR_L16_B: bfd_reloc_code_real = 1172;
pub const BFD_RELOC_C6000_SBR_S16: bfd_reloc_code_real = 1171;
pub const BFD_RELOC_C6000_SBR_U15_W: bfd_reloc_code_real = 1170;
pub const BFD_RELOC_C6000_SBR_U15_H: bfd_reloc_code_real = 1169;
pub const BFD_RELOC_C6000_SBR_U15_B: bfd_reloc_code_real = 1168;
pub const BFD_RELOC_C6000_ABS_H16: bfd_reloc_code_real = 1167;
pub const BFD_RELOC_C6000_ABS_L16: bfd_reloc_code_real = 1166;
pub const BFD_RELOC_C6000_ABS_S16: bfd_reloc_code_real = 1165;
pub const BFD_RELOC_C6000_PCR_S7: bfd_reloc_code_real = 1164;
pub const BFD_RELOC_C6000_PCR_S10: bfd_reloc_code_real = 1163;
pub const BFD_RELOC_C6000_PCR_S12: bfd_reloc_code_real = 1162;
pub const BFD_RELOC_C6000_PCR_S21: bfd_reloc_code_real = 1161;
pub const BFD_RELOC_TIC54X_MS7_OF_23: bfd_reloc_code_real = 1160;
pub const BFD_RELOC_TIC54X_16_OF_23: bfd_reloc_code_real = 1159;
pub const BFD_RELOC_TIC54X_23: bfd_reloc_code_real = 1158;
pub const BFD_RELOC_TIC54X_PARTMS9: bfd_reloc_code_real = 1157;
pub const BFD_RELOC_TIC54X_PARTLS7: bfd_reloc_code_real = 1156;
pub const BFD_RELOC_TIC30_LDP: bfd_reloc_code_real = 1155;
pub const BFD_RELOC_V850_DATA: bfd_reloc_code_real = 1154;
pub const BFD_RELOC_V850_CODE: bfd_reloc_code_real = 1153;
pub const BFD_RELOC_V850_32_GOTOFF: bfd_reloc_code_real = 1152;
pub const BFD_RELOC_V850_16_GOTOFF: bfd_reloc_code_real = 1151;
pub const BFD_RELOC_V850_RELATIVE: bfd_reloc_code_real = 1150;
pub const BFD_RELOC_V850_JMP_SLOT: bfd_reloc_code_real = 1149;
pub const BFD_RELOC_V850_GLOB_DAT: bfd_reloc_code_real = 1148;
pub const BFD_RELOC_V850_COPY: bfd_reloc_code_real = 1147;
pub const BFD_RELOC_V850_32_PLT_PCREL: bfd_reloc_code_real = 1146;
pub const BFD_RELOC_V850_22_PLT_PCREL: bfd_reloc_code_real = 1145;
pub const BFD_RELOC_V850_32_GOT: bfd_reloc_code_real = 1144;
pub const BFD_RELOC_V850_16_GOT: bfd_reloc_code_real = 1143;
pub const BFD_RELOC_V850_32_GOTPCREL: bfd_reloc_code_real = 1142;
pub const BFD_RELOC_V850_CALLT_15_16_OFFSET: bfd_reloc_code_real = 1141;
pub const BFD_RELOC_V850_LO16_S1: bfd_reloc_code_real = 1140;
pub const BFD_RELOC_V850_16_S1: bfd_reloc_code_real = 1139;
pub const BFD_RELOC_V850_16_SPLIT_OFFSET: bfd_reloc_code_real = 1138;
pub const BFD_RELOC_V850_32_ABS: bfd_reloc_code_real = 1137;
pub const BFD_RELOC_V850_32_PCREL: bfd_reloc_code_real = 1136;
pub const BFD_RELOC_V850_23: bfd_reloc_code_real = 1135;
pub const BFD_RELOC_V850_17_PCREL: bfd_reloc_code_real = 1134;
pub const BFD_RELOC_V850_16_PCREL: bfd_reloc_code_real = 1133;
pub const BFD_RELOC_V850_LO16_SPLIT_OFFSET: bfd_reloc_code_real = 1132;
pub const BFD_RELOC_V850_ALIGN: bfd_reloc_code_real = 1131;
pub const BFD_RELOC_V850_LONGJUMP: bfd_reloc_code_real = 1130;
pub const BFD_RELOC_V850_LONGCALL: bfd_reloc_code_real = 1129;
pub const BFD_RELOC_V850_CALLT_16_16_OFFSET: bfd_reloc_code_real = 1128;
pub const BFD_RELOC_V850_CALLT_6_7_OFFSET: bfd_reloc_code_real = 1127;
pub const BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET: bfd_reloc_code_real = 1126;
pub const BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET: bfd_reloc_code_real = 1125;
pub const BFD_RELOC_V850_TDA_4_4_OFFSET: bfd_reloc_code_real = 1124;
pub const BFD_RELOC_V850_TDA_4_5_OFFSET: bfd_reloc_code_real = 1123;
pub const BFD_RELOC_V850_TDA_16_16_OFFSET: bfd_reloc_code_real = 1122;
pub const BFD_RELOC_V850_TDA_7_7_OFFSET: bfd_reloc_code_real = 1121;
pub const BFD_RELOC_V850_TDA_7_8_OFFSET: bfd_reloc_code_real = 1120;
pub const BFD_RELOC_V850_TDA_6_8_OFFSET: bfd_reloc_code_real = 1119;
pub const BFD_RELOC_V850_ZDA_15_16_OFFSET: bfd_reloc_code_real = 1118;
pub const BFD_RELOC_V850_ZDA_16_16_OFFSET: bfd_reloc_code_real = 1117;
pub const BFD_RELOC_V850_SDA_15_16_OFFSET: bfd_reloc_code_real = 1116;
pub const BFD_RELOC_V850_SDA_16_16_OFFSET: bfd_reloc_code_real = 1115;
pub const BFD_RELOC_V850_22_PCREL: bfd_reloc_code_real = 1114;
pub const BFD_RELOC_V850_9_PCREL: bfd_reloc_code_real = 1113;
pub const BFD_RELOC_NDS32_LSI: bfd_reloc_code_real = 1112;
pub const BFD_RELOC_NDS32_GROUP: bfd_reloc_code_real = 1111;
pub const BFD_RELOC_NDS32_REMOVE: bfd_reloc_code_real = 1110;
pub const BFD_RELOC_NDS32_TLS_DESC_MEM: bfd_reloc_code_real = 1109;
pub const BFD_RELOC_NDS32_TLS_DESC_CALL: bfd_reloc_code_real = 1108;
pub const BFD_RELOC_NDS32_TLS_DESC_FUNC: bfd_reloc_code_real = 1107;
pub const BFD_RELOC_NDS32_TLS_DESC_ADD: bfd_reloc_code_real = 1106;
pub const BFD_RELOC_NDS32_TLS_DESC_SDA17S2: bfd_reloc_code_real = 1105;
pub const BFD_RELOC_NDS32_TLS_DESC_20: bfd_reloc_code_real = 1104;
pub const BFD_RELOC_NDS32_TLS_DESC_LO12: bfd_reloc_code_real = 1103;
pub const BFD_RELOC_NDS32_TLS_DESC_HI20: bfd_reloc_code_real = 1102;
pub const BFD_RELOC_NDS32_TLS_DESC: bfd_reloc_code_real = 1101;
pub const BFD_RELOC_NDS32_TLS_IEGP_LW: bfd_reloc_code_real = 1100;
pub const BFD_RELOC_NDS32_TLS_IEGP_LO12S2: bfd_reloc_code_real = 1099;
pub const BFD_RELOC_NDS32_TLS_IEGP_LO12: bfd_reloc_code_real = 1098;
pub const BFD_RELOC_NDS32_TLS_IEGP_HI20: bfd_reloc_code_real = 1097;
pub const BFD_RELOC_NDS32_TLS_IE_LO12S2: bfd_reloc_code_real = 1096;
pub const BFD_RELOC_NDS32_TLS_IE_LO12: bfd_reloc_code_real = 1095;
pub const BFD_RELOC_NDS32_TLS_IE_HI20: bfd_reloc_code_real = 1094;
pub const BFD_RELOC_NDS32_TLS_LE_LS: bfd_reloc_code_real = 1093;
pub const BFD_RELOC_NDS32_TLS_LE_ADD: bfd_reloc_code_real = 1092;
pub const BFD_RELOC_NDS32_TLS_LE_15S2: bfd_reloc_code_real = 1091;
pub const BFD_RELOC_NDS32_TLS_LE_15S1: bfd_reloc_code_real = 1090;
pub const BFD_RELOC_NDS32_TLS_LE_15S0: bfd_reloc_code_real = 1089;
pub const BFD_RELOC_NDS32_TLS_LE_20: bfd_reloc_code_real = 1088;
pub const BFD_RELOC_NDS32_TLS_LE_LO12: bfd_reloc_code_real = 1087;
pub const BFD_RELOC_NDS32_TLS_LE_HI20: bfd_reloc_code_real = 1086;
pub const BFD_RELOC_NDS32_GOTTPOFF: bfd_reloc_code_real = 1085;
pub const BFD_RELOC_NDS32_TPOFF: bfd_reloc_code_real = 1084;
pub const BFD_RELOC_NDS32_10IFCU_PCREL: bfd_reloc_code_real = 1083;
pub const BFD_RELOC_NDS32_17IFC_PCREL: bfd_reloc_code_real = 1082;
pub const BFD_RELOC_NDS32_TRAN: bfd_reloc_code_real = 1081;
pub const BFD_RELOC_NDS32_DATA: bfd_reloc_code_real = 1080;
pub const BFD_RELOC_NDS32_25_ABS: bfd_reloc_code_real = 1079;
pub const BFD_RELOC_NDS32_EMPTY: bfd_reloc_code_real = 1078;
pub const BFD_RELOC_NDS32_DIFF_ULEB128: bfd_reloc_code_real = 1077;
pub const BFD_RELOC_NDS32_DIFF32: bfd_reloc_code_real = 1076;
pub const BFD_RELOC_NDS32_DIFF16: bfd_reloc_code_real = 1075;
pub const BFD_RELOC_NDS32_DIFF8: bfd_reloc_code_real = 1074;
pub const BFD_RELOC_NDS32_SUBTRAHEND: bfd_reloc_code_real = 1073;
pub const BFD_RELOC_NDS32_MINUEND: bfd_reloc_code_real = 1072;
pub const BFD_RELOC_NDS32_RELAX_REGION_END: bfd_reloc_code_real = 1071;
pub const BFD_RELOC_NDS32_RELAX_REGION_BEGIN: bfd_reloc_code_real = 1070;
pub const BFD_RELOC_NDS32_PLTBLOCK: bfd_reloc_code_real = 1069;
pub const BFD_RELOC_NDS32_PTR_RESOLVED: bfd_reloc_code_real = 1068;
pub const BFD_RELOC_NDS32_PTR_COUNT: bfd_reloc_code_real = 1067;
pub const BFD_RELOC_NDS32_PTR: bfd_reloc_code_real = 1066;
pub const BFD_RELOC_NDS32_MULCALL_SUFF: bfd_reloc_code_real = 1065;
pub const BFD_RELOC_NDS32_PLT_GOT_SUFF: bfd_reloc_code_real = 1064;
pub const BFD_RELOC_NDS32_GOTOFF_SUFF: bfd_reloc_code_real = 1063;
pub const BFD_RELOC_NDS32_GOT_SUFF: bfd_reloc_code_real = 1062;
pub const BFD_RELOC_NDS32_RELAX_ENTRY: bfd_reloc_code_real = 1061;
pub const BFD_RELOC_NDS32_SDA_FP7U2_RELA: bfd_reloc_code_real = 1060;
pub const BFD_RELOC_NDS32_10_UPCREL: bfd_reloc_code_real = 1059;
pub const BFD_RELOC_NDS32_5: bfd_reloc_code_real = 1058;
pub const BFD_RELOC_NDS32_GOT17S2: bfd_reloc_code_real = 1057;
pub const BFD_RELOC_NDS32_GOT15S2: bfd_reloc_code_real = 1056;
pub const BFD_RELOC_NDS32_GOTOFF_LO19: bfd_reloc_code_real = 1055;
pub const BFD_RELOC_NDS32_GOTOFF_LO15: bfd_reloc_code_real = 1054;
pub const BFD_RELOC_NDS32_GOT_LO19: bfd_reloc_code_real = 1053;
pub const BFD_RELOC_NDS32_GOT_LO15: bfd_reloc_code_real = 1052;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO19: bfd_reloc_code_real = 1051;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO15: bfd_reloc_code_real = 1050;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO20: bfd_reloc_code_real = 1049;
pub const BFD_RELOC_NDS32_UPDATE_TA: bfd_reloc_code_real = 1048;
pub const BFD_RELOC_NDS32_DWARF2_LEB: bfd_reloc_code_real = 1047;
pub const BFD_RELOC_NDS32_DWARF2_OP2: bfd_reloc_code_real = 1046;
pub const BFD_RELOC_NDS32_DWARF2_OP1: bfd_reloc_code_real = 1045;
pub const BFD_RELOC_NDS32_LO12S2_SP: bfd_reloc_code_real = 1044;
pub const BFD_RELOC_NDS32_LO12S2_DP: bfd_reloc_code_real = 1043;
pub const BFD_RELOC_NDS32_SDA12S2_SP: bfd_reloc_code_real = 1042;
pub const BFD_RELOC_NDS32_SDA12S2_DP: bfd_reloc_code_real = 1041;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO12: bfd_reloc_code_real = 1040;
pub const BFD_RELOC_NDS32_PLT_GOTREL_HI20: bfd_reloc_code_real = 1039;
pub const BFD_RELOC_NDS32_PLTREL_LO12: bfd_reloc_code_real = 1038;
pub const BFD_RELOC_NDS32_PLTREL_HI20: bfd_reloc_code_real = 1037;
pub const BFD_RELOC_NDS32_LONGJUMP7: bfd_reloc_code_real = 1036;
pub const BFD_RELOC_NDS32_LONGJUMP6: bfd_reloc_code_real = 1035;
pub const BFD_RELOC_NDS32_LONGJUMP5: bfd_reloc_code_real = 1034;
pub const BFD_RELOC_NDS32_LONGJUMP4: bfd_reloc_code_real = 1033;
pub const BFD_RELOC_NDS32_LONGCALL6: bfd_reloc_code_real = 1032;
pub const BFD_RELOC_NDS32_LONGCALL5: bfd_reloc_code_real = 1031;
pub const BFD_RELOC_NDS32_LONGCALL4: bfd_reloc_code_real = 1030;
pub const BFD_RELOC_NDS32_25_FIXED: bfd_reloc_code_real = 1029;
pub const BFD_RELOC_NDS32_17_FIXED: bfd_reloc_code_real = 1028;
pub const BFD_RELOC_NDS32_15_FIXED: bfd_reloc_code_real = 1027;
pub const BFD_RELOC_NDS32_9_FIXED: bfd_reloc_code_real = 1026;
pub const BFD_RELOC_NDS32_LOADSTORE: bfd_reloc_code_real = 1025;
pub const BFD_RELOC_NDS32_LONGJUMP3: bfd_reloc_code_real = 1024;
pub const BFD_RELOC_NDS32_LONGJUMP2: bfd_reloc_code_real = 1023;
pub const BFD_RELOC_NDS32_LONGJUMP1: bfd_reloc_code_real = 1022;
pub const BFD_RELOC_NDS32_LONGCALL3: bfd_reloc_code_real = 1021;
pub const BFD_RELOC_NDS32_LONGCALL2: bfd_reloc_code_real = 1020;
pub const BFD_RELOC_NDS32_LONGCALL1: bfd_reloc_code_real = 1019;
pub const BFD_RELOC_NDS32_LABEL: bfd_reloc_code_real = 1018;
pub const BFD_RELOC_NDS32_INSN16: bfd_reloc_code_real = 1017;
pub const BFD_RELOC_NDS32_GOTPC_LO12: bfd_reloc_code_real = 1016;
pub const BFD_RELOC_NDS32_GOTPC_HI20: bfd_reloc_code_real = 1015;
pub const BFD_RELOC_NDS32_GOT_LO12: bfd_reloc_code_real = 1014;
pub const BFD_RELOC_NDS32_GOT_HI20: bfd_reloc_code_real = 1013;
pub const BFD_RELOC_NDS32_GOTPC20: bfd_reloc_code_real = 1012;
pub const BFD_RELOC_NDS32_GOTOFF_LO12: bfd_reloc_code_real = 1011;
pub const BFD_RELOC_NDS32_GOTOFF_HI20: bfd_reloc_code_real = 1010;
pub const BFD_RELOC_NDS32_GOTOFF: bfd_reloc_code_real = 1009;
pub const BFD_RELOC_NDS32_RELATIVE: bfd_reloc_code_real = 1008;
pub const BFD_RELOC_NDS32_JMP_SLOT: bfd_reloc_code_real = 1007;
pub const BFD_RELOC_NDS32_GLOB_DAT: bfd_reloc_code_real = 1006;
pub const BFD_RELOC_NDS32_COPY: bfd_reloc_code_real = 1005;
pub const BFD_RELOC_NDS32_25_PLTREL: bfd_reloc_code_real = 1004;
pub const BFD_RELOC_NDS32_9_PLTREL: bfd_reloc_code_real = 1003;
pub const BFD_RELOC_NDS32_GOT20: bfd_reloc_code_real = 1002;
pub const BFD_RELOC_NDS32_SDA19S0: bfd_reloc_code_real = 1001;
pub const BFD_RELOC_NDS32_SDA18S1: bfd_reloc_code_real = 1000;
pub const BFD_RELOC_NDS32_SDA17S2: bfd_reloc_code_real = 999;
pub const BFD_RELOC_NDS32_SDA16S3: bfd_reloc_code_real = 998;
pub const BFD_RELOC_NDS32_SDA15S0: bfd_reloc_code_real = 997;
pub const BFD_RELOC_NDS32_SDA15S1: bfd_reloc_code_real = 996;
pub const BFD_RELOC_NDS32_SDA15S2: bfd_reloc_code_real = 995;
pub const BFD_RELOC_NDS32_SDA15S3: bfd_reloc_code_real = 994;
pub const BFD_RELOC_NDS32_LO12S0_ORI: bfd_reloc_code_real = 993;
pub const BFD_RELOC_NDS32_LO12S0: bfd_reloc_code_real = 992;
pub const BFD_RELOC_NDS32_LO12S1: bfd_reloc_code_real = 991;
pub const BFD_RELOC_NDS32_LO12S2: bfd_reloc_code_real = 990;
pub const BFD_RELOC_NDS32_LO12S3: bfd_reloc_code_real = 989;
pub const BFD_RELOC_NDS32_HI20: bfd_reloc_code_real = 988;
pub const BFD_RELOC_NDS32_25_PCREL: bfd_reloc_code_real = 987;
pub const BFD_RELOC_NDS32_17_PCREL: bfd_reloc_code_real = 986;
pub const BFD_RELOC_NDS32_15_PCREL: bfd_reloc_code_real = 985;
pub const BFD_RELOC_NDS32_WORD_9_PCREL: bfd_reloc_code_real = 984;
pub const BFD_RELOC_NDS32_9_PCREL: bfd_reloc_code_real = 983;
pub const BFD_RELOC_NDS32_20: bfd_reloc_code_real = 982;
pub const BFD_RELOC_M32R_GOTPC_LO: bfd_reloc_code_real = 981;
pub const BFD_RELOC_M32R_GOTPC_HI_SLO: bfd_reloc_code_real = 980;
pub const BFD_RELOC_M32R_GOTPC_HI_ULO: bfd_reloc_code_real = 979;
pub const BFD_RELOC_M32R_GOT16_LO: bfd_reloc_code_real = 978;
pub const BFD_RELOC_M32R_GOT16_HI_SLO: bfd_reloc_code_real = 977;
pub const BFD_RELOC_M32R_GOT16_HI_ULO: bfd_reloc_code_real = 976;
pub const BFD_RELOC_M32R_GOTPC24: bfd_reloc_code_real = 975;
pub const BFD_RELOC_M32R_GOTOFF_LO: bfd_reloc_code_real = 974;
pub const BFD_RELOC_M32R_GOTOFF_HI_SLO: bfd_reloc_code_real = 973;
pub const BFD_RELOC_M32R_GOTOFF_HI_ULO: bfd_reloc_code_real = 972;
pub const BFD_RELOC_M32R_GOTOFF: bfd_reloc_code_real = 971;
pub const BFD_RELOC_M32R_RELATIVE: bfd_reloc_code_real = 970;
pub const BFD_RELOC_M32R_JMP_SLOT: bfd_reloc_code_real = 969;
pub const BFD_RELOC_M32R_GLOB_DAT: bfd_reloc_code_real = 968;
pub const BFD_RELOC_M32R_COPY: bfd_reloc_code_real = 967;
pub const BFD_RELOC_M32R_26_PLTREL: bfd_reloc_code_real = 966;
pub const BFD_RELOC_M32R_GOT24: bfd_reloc_code_real = 965;
pub const BFD_RELOC_M32R_SDA16: bfd_reloc_code_real = 964;
pub const BFD_RELOC_M32R_LO16: bfd_reloc_code_real = 963;
pub const BFD_RELOC_M32R_HI16_SLO: bfd_reloc_code_real = 962;
pub const BFD_RELOC_M32R_HI16_ULO: bfd_reloc_code_real = 961;
pub const BFD_RELOC_M32R_26_PCREL: bfd_reloc_code_real = 960;
pub const BFD_RELOC_M32R_18_PCREL: bfd_reloc_code_real = 959;
pub const BFD_RELOC_M32R_10_PCREL: bfd_reloc_code_real = 958;
pub const BFD_RELOC_M32R_24: bfd_reloc_code_real = 957;
pub const BFD_RELOC_M32C_RL_2ADDR: bfd_reloc_code_real = 956;
pub const BFD_RELOC_M32C_RL_1ADDR: bfd_reloc_code_real = 955;
pub const BFD_RELOC_M32C_RL_JUMP: bfd_reloc_code_real = 954;
pub const BFD_RELOC_M32C_HI8: bfd_reloc_code_real = 953;
pub const BFD_RELOC_DLX_JMP26: bfd_reloc_code_real = 952;
pub const BFD_RELOC_DLX_LO16: bfd_reloc_code_real = 951;
pub const BFD_RELOC_DLX_HI16_S: bfd_reloc_code_real = 950;
pub const BFD_RELOC_D30V_32_PCREL: bfd_reloc_code_real = 949;
pub const BFD_RELOC_D30V_32: bfd_reloc_code_real = 948;
pub const BFD_RELOC_D30V_21_PCREL_R: bfd_reloc_code_real = 947;
pub const BFD_RELOC_D30V_21_PCREL: bfd_reloc_code_real = 946;
pub const BFD_RELOC_D30V_21: bfd_reloc_code_real = 945;
pub const BFD_RELOC_D30V_15_PCREL_R: bfd_reloc_code_real = 944;
pub const BFD_RELOC_D30V_15_PCREL: bfd_reloc_code_real = 943;
pub const BFD_RELOC_D30V_15: bfd_reloc_code_real = 942;
pub const BFD_RELOC_D30V_9_PCREL_R: bfd_reloc_code_real = 941;
pub const BFD_RELOC_D30V_9_PCREL: bfd_reloc_code_real = 940;
pub const BFD_RELOC_D30V_6: bfd_reloc_code_real = 939;
pub const BFD_RELOC_D10V_18_PCREL: bfd_reloc_code_real = 938;
pub const BFD_RELOC_D10V_18: bfd_reloc_code_real = 937;
pub const BFD_RELOC_D10V_10_PCREL_L: bfd_reloc_code_real = 936;
pub const BFD_RELOC_D10V_10_PCREL_R: bfd_reloc_code_real = 935;
pub const BFD_ARELOC_BFIN_ADDR: bfd_reloc_code_real = 934;
pub const BFD_ARELOC_BFIN_HWPAGE: bfd_reloc_code_real = 933;
pub const BFD_ARELOC_BFIN_PAGE: bfd_reloc_code_real = 932;
pub const BFD_ARELOC_BFIN_COMP: bfd_reloc_code_real = 931;
pub const BFD_ARELOC_BFIN_NEG: bfd_reloc_code_real = 930;
pub const BFD_ARELOC_BFIN_LEN: bfd_reloc_code_real = 929;
pub const BFD_ARELOC_BFIN_LOR: bfd_reloc_code_real = 928;
pub const BFD_ARELOC_BFIN_LAND: bfd_reloc_code_real = 927;
pub const BFD_ARELOC_BFIN_XOR: bfd_reloc_code_real = 926;
pub const BFD_ARELOC_BFIN_OR: bfd_reloc_code_real = 925;
pub const BFD_ARELOC_BFIN_AND: bfd_reloc_code_real = 924;
pub const BFD_ARELOC_BFIN_RSHIFT: bfd_reloc_code_real = 923;
pub const BFD_ARELOC_BFIN_LSHIFT: bfd_reloc_code_real = 922;
pub const BFD_ARELOC_BFIN_MOD: bfd_reloc_code_real = 921;
pub const BFD_ARELOC_BFIN_DIV: bfd_reloc_code_real = 920;
pub const BFD_ARELOC_BFIN_MULT: bfd_reloc_code_real = 919;
pub const BFD_ARELOC_BFIN_SUB: bfd_reloc_code_real = 918;
pub const BFD_ARELOC_BFIN_ADD: bfd_reloc_code_real = 917;
pub const BFD_ARELOC_BFIN_CONST: bfd_reloc_code_real = 916;
pub const BFD_ARELOC_BFIN_PUSH: bfd_reloc_code_real = 915;
pub const BFD_RELOC_BFIN_PLTPC: bfd_reloc_code_real = 914;
pub const BFD_RELOC_BFIN_GOT: bfd_reloc_code_real = 913;
pub const BFD_RELOC_BFIN_GOTOFFLO: bfd_reloc_code_real = 912;
pub const BFD_RELOC_BFIN_GOTOFFHI: bfd_reloc_code_real = 911;
pub const BFD_RELOC_BFIN_GOTOFF17M4: bfd_reloc_code_real = 910;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO: bfd_reloc_code_real = 909;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI: bfd_reloc_code_real = 908;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4: bfd_reloc_code_real = 907;
pub const BFD_RELOC_BFIN_FUNCDESC_VALUE: bfd_reloc_code_real = 906;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTLO: bfd_reloc_code_real = 905;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTHI: bfd_reloc_code_real = 904;
pub const BFD_RELOC_BFIN_FUNCDESC_GOT17M4: bfd_reloc_code_real = 903;
pub const BFD_RELOC_BFIN_FUNCDESC: bfd_reloc_code_real = 902;
pub const BFD_RELOC_BFIN_GOTLO: bfd_reloc_code_real = 901;
pub const BFD_RELOC_BFIN_GOTHI: bfd_reloc_code_real = 900;
pub const BFD_RELOC_BFIN_GOT17M4: bfd_reloc_code_real = 899;
pub const BFD_RELOC_BFIN_24_PCREL_JUMP_L: bfd_reloc_code_real = 898;
pub const BFD_RELOC_BFIN_24_PCREL_CALL_X: bfd_reloc_code_real = 897;
pub const BFD_RELOC_BFIN_12_PCREL_JUMP_S: bfd_reloc_code_real = 896;
pub const BFD_RELOC_BFIN_12_PCREL_JUMP: bfd_reloc_code_real = 895;
pub const BFD_RELOC_BFIN_11_PCREL: bfd_reloc_code_real = 894;
pub const BFD_RELOC_BFIN_10_PCREL: bfd_reloc_code_real = 893;
pub const BFD_RELOC_BFIN_16_LOW: bfd_reloc_code_real = 892;
pub const BFD_RELOC_BFIN_5_PCREL: bfd_reloc_code_real = 891;
pub const BFD_RELOC_BFIN_4_PCREL: bfd_reloc_code_real = 890;
pub const BFD_RELOC_BFIN_16_HIGH: bfd_reloc_code_real = 889;
pub const BFD_RELOC_BFIN_16_IMM: bfd_reloc_code_real = 888;
pub const BFD_RELOC_ARC_JLI_SECTOFF: bfd_reloc_code_real = 887;
pub const BFD_RELOC_ARC_NPS_CMEM16: bfd_reloc_code_real = 886;
pub const BFD_RELOC_ARC_S21H_PCREL_PLT: bfd_reloc_code_real = 885;
pub const BFD_RELOC_ARC_S25W_PCREL_PLT: bfd_reloc_code_real = 884;
pub const BFD_RELOC_ARC_TLS_LE_32: bfd_reloc_code_real = 883;
pub const BFD_RELOC_ARC_TLS_LE_S9: bfd_reloc_code_real = 882;
pub const BFD_RELOC_ARC_TLS_DTPOFF_S9: bfd_reloc_code_real = 881;
pub const BFD_RELOC_ARC_TLS_DTPOFF: bfd_reloc_code_real = 880;
pub const BFD_RELOC_ARC_TLS_IE_GOT: bfd_reloc_code_real = 879;
pub const BFD_RELOC_ARC_TLS_GD_CALL: bfd_reloc_code_real = 878;
pub const BFD_RELOC_ARC_TLS_GD_LD: bfd_reloc_code_real = 877;
pub const BFD_RELOC_ARC_TLS_GD_GOT: bfd_reloc_code_real = 876;
pub const BFD_RELOC_ARC_TLS_TPOFF: bfd_reloc_code_real = 875;
pub const BFD_RELOC_ARC_TLS_DTPMOD: bfd_reloc_code_real = 874;
pub const BFD_RELOC_ARC_S25H_PCREL_PLT: bfd_reloc_code_real = 873;
pub const BFD_RELOC_ARC_S21W_PCREL_PLT: bfd_reloc_code_real = 872;
pub const BFD_RELOC_ARC_GOTPC: bfd_reloc_code_real = 871;
pub const BFD_RELOC_ARC_GOTOFF: bfd_reloc_code_real = 870;
pub const BFD_RELOC_ARC_RELATIVE: bfd_reloc_code_real = 869;
pub const BFD_RELOC_ARC_JMP_SLOT: bfd_reloc_code_real = 868;
pub const BFD_RELOC_ARC_GLOB_DAT: bfd_reloc_code_real = 867;
pub const BFD_RELOC_ARC_COPY: bfd_reloc_code_real = 866;
pub const BFD_RELOC_ARC_PLT32: bfd_reloc_code_real = 865;
pub const BFD_RELOC_ARC_GOTPC32: bfd_reloc_code_real = 864;
pub const BFD_RELOC_ARC_GOT32: bfd_reloc_code_real = 863;
pub const BFD_RELOC_ARC_PC32: bfd_reloc_code_real = 862;
pub const BFD_RELOC_ARC_32_PCREL: bfd_reloc_code_real = 861;
pub const BFD_RELOC_ARC_SDA16_ST2: bfd_reloc_code_real = 860;
pub const BFD_RELOC_ARC_SDA_12: bfd_reloc_code_real = 859;
pub const BFD_RELOC_ARC_SECTOFF_2: bfd_reloc_code_real = 858;
pub const BFD_RELOC_ARC_SECTOFF_1: bfd_reloc_code_real = 857;
pub const BFD_RELOC_ARC_SECTOFF_ME_2: bfd_reloc_code_real = 856;
pub const BFD_RELOC_ARC_SECTOFF_ME_1: bfd_reloc_code_real = 855;
pub const BFD_RELOC_AC_SECTOFF_S9_2: bfd_reloc_code_real = 854;
pub const BFD_RELOC_AC_SECTOFF_S9_1: bfd_reloc_code_real = 853;
pub const BFD_RELOC_AC_SECTOFF_S9: bfd_reloc_code_real = 852;
pub const BFD_RELOC_AC_SECTOFF_U8_2: bfd_reloc_code_real = 851;
pub const BFD_RELOC_AC_SECTOFF_U8_1: bfd_reloc_code_real = 850;
pub const BFD_RELOC_AC_SECTOFF_U8: bfd_reloc_code_real = 849;
pub const BFD_RELOC_ARC_W_ME: bfd_reloc_code_real = 848;
pub const BFD_RELOC_ARC_SDA32_ME: bfd_reloc_code_real = 847;
pub const BFD_RELOC_ARC_SECTOFF_ME: bfd_reloc_code_real = 846;
pub const BFD_RELOC_ARC_N32_ME: bfd_reloc_code_real = 845;
pub const BFD_RELOC_ARC_32_ME_S: bfd_reloc_code_real = 844;
pub const BFD_RELOC_ARC_32_ME: bfd_reloc_code_real = 843;
pub const BFD_RELOC_ARC_W: bfd_reloc_code_real = 842;
pub const BFD_RELOC_ARC_S13_PCREL: bfd_reloc_code_real = 841;
pub const BFD_RELOC_ARC_SDA16_LD2: bfd_reloc_code_real = 840;
pub const BFD_RELOC_ARC_SDA16_LD1: bfd_reloc_code_real = 839;
pub const BFD_RELOC_ARC_SDA16_LD: bfd_reloc_code_real = 838;
pub const BFD_RELOC_ARC_SDA_LDST2: bfd_reloc_code_real = 837;
pub const BFD_RELOC_ARC_SDA_LDST1: bfd_reloc_code_real = 836;
pub const BFD_RELOC_ARC_SDA_LDST: bfd_reloc_code_real = 835;
pub const BFD_RELOC_ARC_SDA32: bfd_reloc_code_real = 834;
pub const BFD_RELOC_ARC_S25W_PCREL: bfd_reloc_code_real = 833;
pub const BFD_RELOC_ARC_S25H_PCREL: bfd_reloc_code_real = 832;
pub const BFD_RELOC_ARC_S21W_PCREL: bfd_reloc_code_real = 831;
pub const BFD_RELOC_ARC_S21H_PCREL: bfd_reloc_code_real = 830;
pub const BFD_RELOC_ARC_SECTOFF: bfd_reloc_code_real = 829;
pub const BFD_RELOC_ARC_SDA: bfd_reloc_code_real = 828;
pub const BFD_RELOC_ARC_N32: bfd_reloc_code_real = 827;
pub const BFD_RELOC_ARC_N24: bfd_reloc_code_real = 826;
pub const BFD_RELOC_ARC_N16: bfd_reloc_code_real = 825;
pub const BFD_RELOC_ARC_N8: bfd_reloc_code_real = 824;
pub const BFD_RELOC_ARC_32: bfd_reloc_code_real = 823;
pub const BFD_RELOC_ARC_24: bfd_reloc_code_real = 822;
pub const BFD_RELOC_ARC_16: bfd_reloc_code_real = 821;
pub const BFD_RELOC_ARC_8: bfd_reloc_code_real = 820;
pub const BFD_RELOC_ARC_NONE: bfd_reloc_code_real = 819;
pub const BFD_RELOC_SH_FUNCDESC: bfd_reloc_code_real = 818;
pub const BFD_RELOC_SH_GOTOFFFUNCDESC20: bfd_reloc_code_real = 817;
pub const BFD_RELOC_SH_GOTOFFFUNCDESC: bfd_reloc_code_real = 816;
pub const BFD_RELOC_SH_GOTFUNCDESC20: bfd_reloc_code_real = 815;
pub const BFD_RELOC_SH_GOTFUNCDESC: bfd_reloc_code_real = 814;
pub const BFD_RELOC_SH_GOTOFF20: bfd_reloc_code_real = 813;
pub const BFD_RELOC_SH_GOT20: bfd_reloc_code_real = 812;
pub const BFD_RELOC_SH_TLS_TPOFF32: bfd_reloc_code_real = 811;
pub const BFD_RELOC_SH_TLS_DTPOFF32: bfd_reloc_code_real = 810;
pub const BFD_RELOC_SH_TLS_DTPMOD32: bfd_reloc_code_real = 809;
pub const BFD_RELOC_SH_TLS_LE_32: bfd_reloc_code_real = 808;
pub const BFD_RELOC_SH_TLS_IE_32: bfd_reloc_code_real = 807;
pub const BFD_RELOC_SH_TLS_LDO_32: bfd_reloc_code_real = 806;
pub const BFD_RELOC_SH_TLS_LD_32: bfd_reloc_code_real = 805;
pub const BFD_RELOC_SH_TLS_GD_32: bfd_reloc_code_real = 804;
pub const BFD_RELOC_SH_PT_16: bfd_reloc_code_real = 803;
pub const BFD_RELOC_SH_IMM_HI16_PCREL: bfd_reloc_code_real = 802;
pub const BFD_RELOC_SH_IMM_HI16: bfd_reloc_code_real = 801;
pub const BFD_RELOC_SH_IMM_MEDHI16_PCREL: bfd_reloc_code_real = 800;
pub const BFD_RELOC_SH_IMM_MEDHI16: bfd_reloc_code_real = 799;
pub const BFD_RELOC_SH_IMM_MEDLOW16_PCREL: bfd_reloc_code_real = 798;
pub const BFD_RELOC_SH_IMM_MEDLOW16: bfd_reloc_code_real = 797;
pub const BFD_RELOC_SH_IMM_LOW16_PCREL: bfd_reloc_code_real = 796;
pub const BFD_RELOC_SH_IMM_LOW16: bfd_reloc_code_real = 795;
pub const BFD_RELOC_SH_IMMU16: bfd_reloc_code_real = 794;
pub const BFD_RELOC_SH_IMMS16: bfd_reloc_code_real = 793;
pub const BFD_RELOC_SH_IMMS10BY8: bfd_reloc_code_real = 792;
pub const BFD_RELOC_SH_IMMS10BY4: bfd_reloc_code_real = 791;
pub const BFD_RELOC_SH_IMMS10BY2: bfd_reloc_code_real = 790;
pub const BFD_RELOC_SH_IMMS10: bfd_reloc_code_real = 789;
pub const BFD_RELOC_SH_IMMU6: bfd_reloc_code_real = 788;
pub const BFD_RELOC_SH_IMMS6BY32: bfd_reloc_code_real = 787;
pub const BFD_RELOC_SH_IMMS6: bfd_reloc_code_real = 786;
pub const BFD_RELOC_SH_IMMU5: bfd_reloc_code_real = 785;
pub const BFD_RELOC_SH_SHMEDIA_CODE: bfd_reloc_code_real = 784;
pub const BFD_RELOC_SH_GOTPLT32: bfd_reloc_code_real = 783;
pub const BFD_RELOC_SH_GOTPLT10BY8: bfd_reloc_code_real = 782;
pub const BFD_RELOC_SH_GOTPLT10BY4: bfd_reloc_code_real = 781;
pub const BFD_RELOC_SH_GOT10BY8: bfd_reloc_code_real = 780;
pub const BFD_RELOC_SH_GOT10BY4: bfd_reloc_code_real = 779;
pub const BFD_RELOC_SH_RELATIVE64: bfd_reloc_code_real = 778;
pub const BFD_RELOC_SH_JMP_SLOT64: bfd_reloc_code_real = 777;
pub const BFD_RELOC_SH_GLOB_DAT64: bfd_reloc_code_real = 776;
pub const BFD_RELOC_SH_COPY64: bfd_reloc_code_real = 775;
pub const BFD_RELOC_SH_GOTPC_HI16: bfd_reloc_code_real = 774;
pub const BFD_RELOC_SH_GOTPC_MEDHI16: bfd_reloc_code_real = 773;
pub const BFD_RELOC_SH_GOTPC_MEDLOW16: bfd_reloc_code_real = 772;
pub const BFD_RELOC_SH_GOTPC_LOW16: bfd_reloc_code_real = 771;
pub const BFD_RELOC_SH_GOTOFF_HI16: bfd_reloc_code_real = 770;
pub const BFD_RELOC_SH_GOTOFF_MEDHI16: bfd_reloc_code_real = 769;
pub const BFD_RELOC_SH_GOTOFF_MEDLOW16: bfd_reloc_code_real = 768;
pub const BFD_RELOC_SH_GOTOFF_LOW16: bfd_reloc_code_real = 767;
pub const BFD_RELOC_SH_PLT_HI16: bfd_reloc_code_real = 766;
pub const BFD_RELOC_SH_PLT_MEDHI16: bfd_reloc_code_real = 765;
pub const BFD_RELOC_SH_PLT_MEDLOW16: bfd_reloc_code_real = 764;
pub const BFD_RELOC_SH_PLT_LOW16: bfd_reloc_code_real = 763;
pub const BFD_RELOC_SH_GOTPLT_HI16: bfd_reloc_code_real = 762;
pub const BFD_RELOC_SH_GOTPLT_MEDHI16: bfd_reloc_code_real = 761;
pub const BFD_RELOC_SH_GOTPLT_MEDLOW16: bfd_reloc_code_real = 760;
pub const BFD_RELOC_SH_GOTPLT_LOW16: bfd_reloc_code_real = 759;
pub const BFD_RELOC_SH_GOT_HI16: bfd_reloc_code_real = 758;
pub const BFD_RELOC_SH_GOT_MEDHI16: bfd_reloc_code_real = 757;
pub const BFD_RELOC_SH_GOT_MEDLOW16: bfd_reloc_code_real = 756;
pub const BFD_RELOC_SH_GOT_LOW16: bfd_reloc_code_real = 755;
pub const BFD_RELOC_SH_GOTPC: bfd_reloc_code_real = 754;
pub const BFD_RELOC_SH_RELATIVE: bfd_reloc_code_real = 753;
pub const BFD_RELOC_SH_JMP_SLOT: bfd_reloc_code_real = 752;
pub const BFD_RELOC_SH_GLOB_DAT: bfd_reloc_code_real = 751;
pub const BFD_RELOC_SH_COPY: bfd_reloc_code_real = 750;
pub const BFD_RELOC_SH_LOOP_END: bfd_reloc_code_real = 749;
pub const BFD_RELOC_SH_LOOP_START: bfd_reloc_code_real = 748;
pub const BFD_RELOC_SH_LABEL: bfd_reloc_code_real = 747;
pub const BFD_RELOC_SH_DATA: bfd_reloc_code_real = 746;
pub const BFD_RELOC_SH_CODE: bfd_reloc_code_real = 745;
pub const BFD_RELOC_SH_ALIGN: bfd_reloc_code_real = 744;
pub const BFD_RELOC_SH_COUNT: bfd_reloc_code_real = 743;
pub const BFD_RELOC_SH_USES: bfd_reloc_code_real = 742;
pub const BFD_RELOC_SH_SWITCH32: bfd_reloc_code_real = 741;
pub const BFD_RELOC_SH_SWITCH16: bfd_reloc_code_real = 740;
pub const BFD_RELOC_SH_PCRELIMM8BY4: bfd_reloc_code_real = 739;
pub const BFD_RELOC_SH_PCRELIMM8BY2: bfd_reloc_code_real = 738;
pub const BFD_RELOC_SH_IMM8BY4: bfd_reloc_code_real = 737;
pub const BFD_RELOC_SH_IMM8BY2: bfd_reloc_code_real = 736;
pub const BFD_RELOC_SH_IMM8: bfd_reloc_code_real = 735;
pub const BFD_RELOC_SH_IMM4BY4: bfd_reloc_code_real = 734;
pub const BFD_RELOC_SH_IMM4BY2: bfd_reloc_code_real = 733;
pub const BFD_RELOC_SH_IMM4: bfd_reloc_code_real = 732;
pub const BFD_RELOC_SH_DISP20BY8: bfd_reloc_code_real = 731;
pub const BFD_RELOC_SH_DISP20: bfd_reloc_code_real = 730;
pub const BFD_RELOC_SH_DISP12BY8: bfd_reloc_code_real = 729;
pub const BFD_RELOC_SH_DISP12BY4: bfd_reloc_code_real = 728;
pub const BFD_RELOC_SH_DISP12BY2: bfd_reloc_code_real = 727;
pub const BFD_RELOC_SH_DISP12: bfd_reloc_code_real = 726;
pub const BFD_RELOC_SH_IMM3U: bfd_reloc_code_real = 725;
pub const BFD_RELOC_SH_IMM3: bfd_reloc_code_real = 724;
pub const BFD_RELOC_SH_PCDISP12BY2: bfd_reloc_code_real = 723;
pub const BFD_RELOC_SH_PCDISP8BY2: bfd_reloc_code_real = 722;
pub const BFD_RELOC_ARM_THUMB_SHIFT: bfd_reloc_code_real = 721;
pub const BFD_RELOC_ARM_THUMB_IMM: bfd_reloc_code_real = 720;
pub const BFD_RELOC_ARM_THUMB_ADD: bfd_reloc_code_real = 719;
pub const BFD_RELOC_ARM_HWLITERAL: bfd_reloc_code_real = 718;
pub const BFD_RELOC_ARM_T32_OFFSET_IMM: bfd_reloc_code_real = 717;
pub const BFD_RELOC_ARM_T32_OFFSET_U8: bfd_reloc_code_real = 716;
pub const BFD_RELOC_ARM_OFFSET_IMM8: bfd_reloc_code_real = 715;
pub const BFD_RELOC_ARM_IN_POOL: bfd_reloc_code_real = 714;
pub const BFD_RELOC_ARM_LITERAL: bfd_reloc_code_real = 713;
pub const BFD_RELOC_ARM_LDR_IMM: bfd_reloc_code_real = 712;
pub const BFD_RELOC_ARM_ADR_IMM: bfd_reloc_code_real = 711;
pub const BFD_RELOC_ARM_T32_VLDR_VSTR_OFF_IMM: bfd_reloc_code_real = 710;
pub const BFD_RELOC_ARM_T32_CP_OFF_IMM_S2: bfd_reloc_code_real = 709;
pub const BFD_RELOC_ARM_T32_CP_OFF_IMM: bfd_reloc_code_real = 708;
pub const BFD_RELOC_ARM_CP_OFF_IMM_S2: bfd_reloc_code_real = 707;
pub const BFD_RELOC_ARM_CP_OFF_IMM: bfd_reloc_code_real = 706;
pub const BFD_RELOC_ARM_MULTI: bfd_reloc_code_real = 705;
pub const BFD_RELOC_ARM_SWI: bfd_reloc_code_real = 704;
pub const BFD_RELOC_ARM_HVC: bfd_reloc_code_real = 703;
pub const BFD_RELOC_ARM_SMC: bfd_reloc_code_real = 702;
pub const BFD_RELOC_ARM_SHIFT_IMM: bfd_reloc_code_real = 701;
pub const BFD_RELOC_ARM_T32_ADD_PC12: bfd_reloc_code_real = 700;
pub const BFD_RELOC_ARM_T32_IMM12: bfd_reloc_code_real = 699;
pub const BFD_RELOC_ARM_T32_ADD_IMM: bfd_reloc_code_real = 698;
pub const BFD_RELOC_ARM_T32_IMMEDIATE: bfd_reloc_code_real = 697;
pub const BFD_RELOC_ARM_ADRL_IMMEDIATE: bfd_reloc_code_real = 696;
pub const BFD_RELOC_ARM_IMMEDIATE: bfd_reloc_code_real = 695;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC: bfd_reloc_code_real = 694;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC: bfd_reloc_code_real = 693;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC: bfd_reloc_code_real = 692;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC: bfd_reloc_code_real = 691;
pub const BFD_RELOC_ARM_IRELATIVE: bfd_reloc_code_real = 690;
pub const BFD_RELOC_ARM_V4BX: bfd_reloc_code_real = 689;
pub const BFD_RELOC_ARM_LDC_SB_G2: bfd_reloc_code_real = 688;
pub const BFD_RELOC_ARM_LDC_SB_G1: bfd_reloc_code_real = 687;
pub const BFD_RELOC_ARM_LDC_SB_G0: bfd_reloc_code_real = 686;
pub const BFD_RELOC_ARM_LDRS_SB_G2: bfd_reloc_code_real = 685;
pub const BFD_RELOC_ARM_LDRS_SB_G1: bfd_reloc_code_real = 684;
pub const BFD_RELOC_ARM_LDRS_SB_G0: bfd_reloc_code_real = 683;
pub const BFD_RELOC_ARM_LDR_SB_G2: bfd_reloc_code_real = 682;
pub const BFD_RELOC_ARM_LDR_SB_G1: bfd_reloc_code_real = 681;
pub const BFD_RELOC_ARM_LDR_SB_G0: bfd_reloc_code_real = 680;
pub const BFD_RELOC_ARM_ALU_SB_G2: bfd_reloc_code_real = 679;
pub const BFD_RELOC_ARM_ALU_SB_G1: bfd_reloc_code_real = 678;
pub const BFD_RELOC_ARM_ALU_SB_G1_NC: bfd_reloc_code_real = 677;
pub const BFD_RELOC_ARM_ALU_SB_G0: bfd_reloc_code_real = 676;
pub const BFD_RELOC_ARM_ALU_SB_G0_NC: bfd_reloc_code_real = 675;
pub const BFD_RELOC_ARM_LDC_PC_G2: bfd_reloc_code_real = 674;
pub const BFD_RELOC_ARM_LDC_PC_G1: bfd_reloc_code_real = 673;
pub const BFD_RELOC_ARM_LDC_PC_G0: bfd_reloc_code_real = 672;
pub const BFD_RELOC_ARM_LDRS_PC_G2: bfd_reloc_code_real = 671;
pub const BFD_RELOC_ARM_LDRS_PC_G1: bfd_reloc_code_real = 670;
pub const BFD_RELOC_ARM_LDRS_PC_G0: bfd_reloc_code_real = 669;
pub const BFD_RELOC_ARM_LDR_PC_G2: bfd_reloc_code_real = 668;
pub const BFD_RELOC_ARM_LDR_PC_G1: bfd_reloc_code_real = 667;
pub const BFD_RELOC_ARM_LDR_PC_G0: bfd_reloc_code_real = 666;
pub const BFD_RELOC_ARM_ALU_PC_G2: bfd_reloc_code_real = 665;
pub const BFD_RELOC_ARM_ALU_PC_G1: bfd_reloc_code_real = 664;
pub const BFD_RELOC_ARM_ALU_PC_G1_NC: bfd_reloc_code_real = 663;
pub const BFD_RELOC_ARM_ALU_PC_G0: bfd_reloc_code_real = 662;
pub const BFD_RELOC_ARM_ALU_PC_G0_NC: bfd_reloc_code_real = 661;
pub const BFD_RELOC_ARM_TLS_DESC: bfd_reloc_code_real = 660;
pub const BFD_RELOC_ARM_THM_TLS_DESCSEQ: bfd_reloc_code_real = 659;
pub const BFD_RELOC_ARM_TLS_DESCSEQ: bfd_reloc_code_real = 658;
pub const BFD_RELOC_ARM_THM_TLS_CALL: bfd_reloc_code_real = 657;
pub const BFD_RELOC_ARM_TLS_CALL: bfd_reloc_code_real = 656;
pub const BFD_RELOC_ARM_TLS_GOTDESC: bfd_reloc_code_real = 655;
pub const BFD_RELOC_ARM_TLS_LE32: bfd_reloc_code_real = 654;
pub const BFD_RELOC_ARM_TLS_IE32: bfd_reloc_code_real = 653;
pub const BFD_RELOC_ARM_TLS_TPOFF32: bfd_reloc_code_real = 652;
pub const BFD_RELOC_ARM_TLS_DTPMOD32: bfd_reloc_code_real = 651;
pub const BFD_RELOC_ARM_TLS_DTPOFF32: bfd_reloc_code_real = 650;
pub const BFD_RELOC_ARM_TLS_LDM32: bfd_reloc_code_real = 649;
pub const BFD_RELOC_ARM_TLS_LDO32: bfd_reloc_code_real = 648;
pub const BFD_RELOC_ARM_TLS_GD32: bfd_reloc_code_real = 647;
pub const BFD_RELOC_ARM_GOT_PREL: bfd_reloc_code_real = 646;
pub const BFD_RELOC_ARM_GOTPC: bfd_reloc_code_real = 645;
pub const BFD_RELOC_ARM_GOTOFF: bfd_reloc_code_real = 644;
pub const BFD_RELOC_ARM_RELATIVE: bfd_reloc_code_real = 643;
pub const BFD_RELOC_ARM_PLT32: bfd_reloc_code_real = 642;
pub const BFD_RELOC_ARM_GOT32: bfd_reloc_code_real = 641;
pub const BFD_RELOC_ARM_GLOB_DAT: bfd_reloc_code_real = 640;
pub const BFD_RELOC_ARM_JUMP_SLOT: bfd_reloc_code_real = 639;
pub const BFD_RELOC_ARM_TLS_IE32_FDPIC: bfd_reloc_code_real = 638;
pub const BFD_RELOC_ARM_TLS_LDM32_FDPIC: bfd_reloc_code_real = 637;
pub const BFD_RELOC_ARM_TLS_GD32_FDPIC: bfd_reloc_code_real = 636;
pub const BFD_RELOC_ARM_FUNCDESC_VALUE: bfd_reloc_code_real = 635;
pub const BFD_RELOC_ARM_FUNCDESC: bfd_reloc_code_real = 634;
pub const BFD_RELOC_ARM_GOTOFFFUNCDESC: bfd_reloc_code_real = 633;
pub const BFD_RELOC_ARM_GOTFUNCDESC: bfd_reloc_code_real = 632;
pub const BFD_RELOC_ARM_THUMB_MOVT_PCREL: bfd_reloc_code_real = 631;
pub const BFD_RELOC_ARM_THUMB_MOVW_PCREL: bfd_reloc_code_real = 630;
pub const BFD_RELOC_ARM_THUMB_MOVT: bfd_reloc_code_real = 629;
pub const BFD_RELOC_ARM_THUMB_MOVW: bfd_reloc_code_real = 628;
pub const BFD_RELOC_ARM_MOVT_PCREL: bfd_reloc_code_real = 627;
pub const BFD_RELOC_ARM_MOVW_PCREL: bfd_reloc_code_real = 626;
pub const BFD_RELOC_ARM_MOVT: bfd_reloc_code_real = 625;
pub const BFD_RELOC_ARM_MOVW: bfd_reloc_code_real = 624;
pub const BFD_RELOC_ARM_PREL31: bfd_reloc_code_real = 623;
pub const BFD_RELOC_ARM_TARGET2: bfd_reloc_code_real = 622;
pub const BFD_RELOC_ARM_SBREL32: bfd_reloc_code_real = 621;
pub const BFD_RELOC_ARM_ROSEGREL32: bfd_reloc_code_real = 620;
pub const BFD_RELOC_ARM_TARGET1: bfd_reloc_code_real = 619;
pub const BFD_RELOC_ARM_THUMB_OFFSET: bfd_reloc_code_real = 618;
pub const BFD_RELOC_ARM_OFFSET_IMM: bfd_reloc_code_real = 617;
pub const BFD_RELOC_THUMB_PCREL_BRANCH25: bfd_reloc_code_real = 616;
pub const BFD_RELOC_THUMB_PCREL_BRANCH23: bfd_reloc_code_real = 615;
pub const BFD_RELOC_THUMB_PCREL_BRANCH20: bfd_reloc_code_real = 614;
pub const BFD_RELOC_THUMB_PCREL_BRANCH12: bfd_reloc_code_real = 613;
pub const BFD_RELOC_THUMB_PCREL_BRANCH9: bfd_reloc_code_real = 612;
pub const BFD_RELOC_THUMB_PCREL_BRANCH7: bfd_reloc_code_real = 611;
pub const BFD_RELOC_ARM_THUMB_LOOP12: bfd_reloc_code_real = 610;
pub const BFD_RELOC_ARM_THUMB_BF19: bfd_reloc_code_real = 609;
pub const BFD_RELOC_ARM_THUMB_BF13: bfd_reloc_code_real = 608;
pub const BFD_RELOC_ARM_THUMB_BF17: bfd_reloc_code_real = 607;
pub const BFD_RELOC_THUMB_PCREL_BFCSEL: bfd_reloc_code_real = 606;
pub const BFD_RELOC_THUMB_PCREL_BRANCH5: bfd_reloc_code_real = 605;
pub const BFD_RELOC_ARM_PCREL_JUMP: bfd_reloc_code_real = 604;
pub const BFD_RELOC_ARM_PCREL_CALL: bfd_reloc_code_real = 603;
pub const BFD_RELOC_THUMB_PCREL_BLX: bfd_reloc_code_real = 602;
pub const BFD_RELOC_ARM_PCREL_BLX: bfd_reloc_code_real = 601;
pub const BFD_RELOC_ARM_PCREL_BRANCH: bfd_reloc_code_real = 600;
pub const BFD_RELOC_CTOR: bfd_reloc_code_real = 599;
pub const BFD_RELOC_I370_D12: bfd_reloc_code_real = 598;
pub const BFD_RELOC_PPC64_TLS_PCREL: bfd_reloc_code_real = 597;
pub const BFD_RELOC_PPC64_GOT_DTPREL_PCREL34: bfd_reloc_code_real = 596;
pub const BFD_RELOC_PPC64_GOT_TPREL_PCREL34: bfd_reloc_code_real = 595;
pub const BFD_RELOC_PPC64_GOT_TLSLD_PCREL34: bfd_reloc_code_real = 594;
pub const BFD_RELOC_PPC64_GOT_TLSGD_PCREL34: bfd_reloc_code_real = 593;
pub const BFD_RELOC_PPC64_DTPREL34: bfd_reloc_code_real = 592;
pub const BFD_RELOC_PPC64_TPREL34: bfd_reloc_code_real = 591;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHESTA: bfd_reloc_code_real = 590;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHEST: bfd_reloc_code_real = 589;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHERA: bfd_reloc_code_real = 588;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHER: bfd_reloc_code_real = 587;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHA: bfd_reloc_code_real = 586;
pub const BFD_RELOC_PPC64_DTPREL16_HIGH: bfd_reloc_code_real = 585;
pub const BFD_RELOC_PPC64_DTPREL16_LO_DS: bfd_reloc_code_real = 584;
pub const BFD_RELOC_PPC64_DTPREL16_DS: bfd_reloc_code_real = 583;
pub const BFD_RELOC_PPC64_TPREL16_HIGHESTA: bfd_reloc_code_real = 582;
pub const BFD_RELOC_PPC64_TPREL16_HIGHEST: bfd_reloc_code_real = 581;
pub const BFD_RELOC_PPC64_TPREL16_HIGHERA: bfd_reloc_code_real = 580;
pub const BFD_RELOC_PPC64_TPREL16_HIGHER: bfd_reloc_code_real = 579;
pub const BFD_RELOC_PPC64_TPREL16_HIGHA: bfd_reloc_code_real = 578;
pub const BFD_RELOC_PPC64_TPREL16_HIGH: bfd_reloc_code_real = 577;
pub const BFD_RELOC_PPC64_TPREL16_LO_DS: bfd_reloc_code_real = 576;
pub const BFD_RELOC_PPC64_TPREL16_DS: bfd_reloc_code_real = 575;
pub const BFD_RELOC_PPC64_TLSML: bfd_reloc_code_real = 574;
pub const BFD_RELOC_PPC64_TLSM: bfd_reloc_code_real = 573;
pub const BFD_RELOC_PPC64_TLSIE: bfd_reloc_code_real = 572;
pub const BFD_RELOC_PPC64_TLSLE: bfd_reloc_code_real = 571;
pub const BFD_RELOC_PPC64_TLSLD: bfd_reloc_code_real = 570;
pub const BFD_RELOC_PPC64_TLSGD: bfd_reloc_code_real = 569;
pub const BFD_RELOC_PPC_GOT_DTPREL16_HA: bfd_reloc_code_real = 568;
pub const BFD_RELOC_PPC_GOT_DTPREL16_HI: bfd_reloc_code_real = 567;
pub const BFD_RELOC_PPC_GOT_DTPREL16_LO: bfd_reloc_code_real = 566;
pub const BFD_RELOC_PPC_GOT_DTPREL16: bfd_reloc_code_real = 565;
pub const BFD_RELOC_PPC_GOT_TPREL16_HA: bfd_reloc_code_real = 564;
pub const BFD_RELOC_PPC_GOT_TPREL16_HI: bfd_reloc_code_real = 563;
pub const BFD_RELOC_PPC_GOT_TPREL16_LO: bfd_reloc_code_real = 562;
pub const BFD_RELOC_PPC_GOT_TPREL16: bfd_reloc_code_real = 561;
pub const BFD_RELOC_PPC_GOT_TLSLD16_HA: bfd_reloc_code_real = 560;
pub const BFD_RELOC_PPC_GOT_TLSLD16_HI: bfd_reloc_code_real = 559;
pub const BFD_RELOC_PPC_GOT_TLSLD16_LO: bfd_reloc_code_real = 558;
pub const BFD_RELOC_PPC_GOT_TLSLD16: bfd_reloc_code_real = 557;
pub const BFD_RELOC_PPC_GOT_TLSGD16_HA: bfd_reloc_code_real = 556;
pub const BFD_RELOC_PPC_GOT_TLSGD16_HI: bfd_reloc_code_real = 555;
pub const BFD_RELOC_PPC_GOT_TLSGD16_LO: bfd_reloc_code_real = 554;
pub const BFD_RELOC_PPC_GOT_TLSGD16: bfd_reloc_code_real = 553;
pub const BFD_RELOC_PPC_DTPREL: bfd_reloc_code_real = 552;
pub const BFD_RELOC_PPC_DTPREL16_HA: bfd_reloc_code_real = 551;
pub const BFD_RELOC_PPC_DTPREL16_HI: bfd_reloc_code_real = 550;
pub const BFD_RELOC_PPC_DTPREL16_LO: bfd_reloc_code_real = 549;
pub const BFD_RELOC_PPC_DTPREL16: bfd_reloc_code_real = 548;
pub const BFD_RELOC_PPC_TPREL: bfd_reloc_code_real = 547;
pub const BFD_RELOC_PPC_TPREL16_HA: bfd_reloc_code_real = 546;
pub const BFD_RELOC_PPC_TPREL16_HI: bfd_reloc_code_real = 545;
pub const BFD_RELOC_PPC_TPREL16_LO: bfd_reloc_code_real = 544;
pub const BFD_RELOC_PPC_TPREL16: bfd_reloc_code_real = 543;
pub const BFD_RELOC_PPC_DTPMOD: bfd_reloc_code_real = 542;
pub const BFD_RELOC_PPC_TLSML: bfd_reloc_code_real = 541;
pub const BFD_RELOC_PPC_TLSM: bfd_reloc_code_real = 540;
pub const BFD_RELOC_PPC_TLSIE: bfd_reloc_code_real = 539;
pub const BFD_RELOC_PPC_TLSLE: bfd_reloc_code_real = 538;
pub const BFD_RELOC_PPC_TLSLD: bfd_reloc_code_real = 537;
pub const BFD_RELOC_PPC_TLSGD: bfd_reloc_code_real = 536;
pub const BFD_RELOC_PPC_TLS: bfd_reloc_code_real = 535;
pub const BFD_RELOC_PPC64_PCREL28: bfd_reloc_code_real = 534;
pub const BFD_RELOC_PPC64_D28: bfd_reloc_code_real = 533;
pub const BFD_RELOC_PPC64_REL16_HIGHESTA34: bfd_reloc_code_real = 532;
pub const BFD_RELOC_PPC64_REL16_HIGHEST34: bfd_reloc_code_real = 531;
pub const BFD_RELOC_PPC64_REL16_HIGHERA34: bfd_reloc_code_real = 530;
pub const BFD_RELOC_PPC64_REL16_HIGHER34: bfd_reloc_code_real = 529;
pub const BFD_RELOC_PPC64_ADDR16_HIGHESTA34: bfd_reloc_code_real = 528;
pub const BFD_RELOC_PPC64_ADDR16_HIGHEST34: bfd_reloc_code_real = 527;
pub const BFD_RELOC_PPC64_ADDR16_HIGHERA34: bfd_reloc_code_real = 526;
pub const BFD_RELOC_PPC64_ADDR16_HIGHER34: bfd_reloc_code_real = 525;
pub const BFD_RELOC_PPC64_PLT_PCREL34: bfd_reloc_code_real = 524;
pub const BFD_RELOC_PPC64_GOT_PCREL34: bfd_reloc_code_real = 523;
pub const BFD_RELOC_PPC64_PCREL34: bfd_reloc_code_real = 522;
pub const BFD_RELOC_PPC64_D34_HA30: bfd_reloc_code_real = 521;
pub const BFD_RELOC_PPC64_D34_HI30: bfd_reloc_code_real = 520;
pub const BFD_RELOC_PPC64_D34_LO: bfd_reloc_code_real = 519;
pub const BFD_RELOC_PPC64_D34: bfd_reloc_code_real = 518;
pub const BFD_RELOC_PPC64_REL24_NOTOC: bfd_reloc_code_real = 517;
pub const BFD_RELOC_PPC64_ENTRY: bfd_reloc_code_real = 516;
pub const BFD_RELOC_PPC64_ADDR64_LOCAL: bfd_reloc_code_real = 515;
pub const BFD_RELOC_PPC64_REL16_HIGHESTA: bfd_reloc_code_real = 514;
pub const BFD_RELOC_PPC64_REL16_HIGHEST: bfd_reloc_code_real = 513;
pub const BFD_RELOC_PPC64_REL16_HIGHERA: bfd_reloc_code_real = 512;
pub const BFD_RELOC_PPC64_REL16_HIGHER: bfd_reloc_code_real = 511;
pub const BFD_RELOC_PPC64_REL16_HIGHA: bfd_reloc_code_real = 510;
pub const BFD_RELOC_PPC64_REL16_HIGH: bfd_reloc_code_real = 509;
pub const BFD_RELOC_PPC64_ADDR16_HIGHA: bfd_reloc_code_real = 508;
pub const BFD_RELOC_PPC64_ADDR16_HIGH: bfd_reloc_code_real = 507;
pub const BFD_RELOC_PPC64_PLTGOT16_LO_DS: bfd_reloc_code_real = 506;
pub const BFD_RELOC_PPC64_PLTGOT16_DS: bfd_reloc_code_real = 505;
pub const BFD_RELOC_PPC64_TOC16_LO_DS: bfd_reloc_code_real = 504;
pub const BFD_RELOC_PPC64_TOC16_DS: bfd_reloc_code_real = 503;
pub const BFD_RELOC_PPC64_SECTOFF_LO_DS: bfd_reloc_code_real = 502;
pub const BFD_RELOC_PPC64_SECTOFF_DS: bfd_reloc_code_real = 501;
pub const BFD_RELOC_PPC64_PLT16_LO_DS: bfd_reloc_code_real = 500;
pub const BFD_RELOC_PPC64_GOT16_LO_DS: bfd_reloc_code_real = 499;
pub const BFD_RELOC_PPC64_GOT16_DS: bfd_reloc_code_real = 498;
pub const BFD_RELOC_PPC64_ADDR16_LO_DS: bfd_reloc_code_real = 497;
pub const BFD_RELOC_PPC64_ADDR16_DS: bfd_reloc_code_real = 496;
pub const BFD_RELOC_PPC64_PLTGOT16_HA: bfd_reloc_code_real = 495;
pub const BFD_RELOC_PPC64_PLTGOT16_HI: bfd_reloc_code_real = 494;
pub const BFD_RELOC_PPC64_PLTGOT16_LO: bfd_reloc_code_real = 493;
pub const BFD_RELOC_PPC64_PLTGOT16: bfd_reloc_code_real = 492;
pub const BFD_RELOC_PPC64_TOC: bfd_reloc_code_real = 491;
pub const BFD_RELOC_PPC64_TOC16_HA: bfd_reloc_code_real = 490;
pub const BFD_RELOC_PPC64_TOC16_HI: bfd_reloc_code_real = 489;
pub const BFD_RELOC_PPC64_TOC16_LO: bfd_reloc_code_real = 488;
pub const BFD_RELOC_PPC64_HIGHEST_S: bfd_reloc_code_real = 487;
pub const BFD_RELOC_PPC64_HIGHEST: bfd_reloc_code_real = 486;
pub const BFD_RELOC_PPC64_HIGHER_S: bfd_reloc_code_real = 485;
pub const BFD_RELOC_PPC64_HIGHER: bfd_reloc_code_real = 484;
pub const BFD_RELOC_PPC_NEG: bfd_reloc_code_real = 483;
pub const BFD_RELOC_PPC_REL16DX_HA: bfd_reloc_code_real = 482;
pub const BFD_RELOC_PPC_16DX_HA: bfd_reloc_code_real = 481;
pub const BFD_RELOC_PPC_VLE_SDAREL_HA16D: bfd_reloc_code_real = 480;
pub const BFD_RELOC_PPC_VLE_SDAREL_HA16A: bfd_reloc_code_real = 479;
pub const BFD_RELOC_PPC_VLE_SDAREL_HI16D: bfd_reloc_code_real = 478;
pub const BFD_RELOC_PPC_VLE_SDAREL_HI16A: bfd_reloc_code_real = 477;
pub const BFD_RELOC_PPC_VLE_SDAREL_LO16D: bfd_reloc_code_real = 476;
pub const BFD_RELOC_PPC_VLE_SDAREL_LO16A: bfd_reloc_code_real = 475;
pub const BFD_RELOC_PPC_VLE_SDA21_LO: bfd_reloc_code_real = 474;
pub const BFD_RELOC_PPC_VLE_SDA21: bfd_reloc_code_real = 473;
pub const BFD_RELOC_PPC_VLE_HA16D: bfd_reloc_code_real = 472;
pub const BFD_RELOC_PPC_VLE_HA16A: bfd_reloc_code_real = 471;
pub const BFD_RELOC_PPC_VLE_HI16D: bfd_reloc_code_real = 470;
pub const BFD_RELOC_PPC_VLE_HI16A: bfd_reloc_code_real = 469;
pub const BFD_RELOC_PPC_VLE_LO16D: bfd_reloc_code_real = 468;
pub const BFD_RELOC_PPC_VLE_LO16A: bfd_reloc_code_real = 467;
pub const BFD_RELOC_PPC_VLE_REL24: bfd_reloc_code_real = 466;
pub const BFD_RELOC_PPC_VLE_REL15: bfd_reloc_code_real = 465;
pub const BFD_RELOC_PPC_VLE_REL8: bfd_reloc_code_real = 464;
pub const BFD_RELOC_PPC_EMB_RELSDA: bfd_reloc_code_real = 463;
pub const BFD_RELOC_PPC_EMB_BIT_FLD: bfd_reloc_code_real = 462;
pub const BFD_RELOC_PPC_EMB_RELST_HA: bfd_reloc_code_real = 461;
pub const BFD_RELOC_PPC_EMB_RELST_HI: bfd_reloc_code_real = 460;
pub const BFD_RELOC_PPC_EMB_RELST_LO: bfd_reloc_code_real = 459;
pub const BFD_RELOC_PPC_EMB_RELSEC16: bfd_reloc_code_real = 458;
pub const BFD_RELOC_PPC_EMB_MRKREF: bfd_reloc_code_real = 457;
pub const BFD_RELOC_PPC_EMB_SDA21: bfd_reloc_code_real = 456;
pub const BFD_RELOC_PPC_EMB_SDA2REL: bfd_reloc_code_real = 455;
pub const BFD_RELOC_PPC_EMB_SDA2I16: bfd_reloc_code_real = 454;
pub const BFD_RELOC_PPC_EMB_SDAI16: bfd_reloc_code_real = 453;
pub const BFD_RELOC_PPC_EMB_NADDR16_HA: bfd_reloc_code_real = 452;
pub const BFD_RELOC_PPC_EMB_NADDR16_HI: bfd_reloc_code_real = 451;
pub const BFD_RELOC_PPC_EMB_NADDR16_LO: bfd_reloc_code_real = 450;
pub const BFD_RELOC_PPC_EMB_NADDR16: bfd_reloc_code_real = 449;
pub const BFD_RELOC_PPC_EMB_NADDR32: bfd_reloc_code_real = 448;
pub const BFD_RELOC_PPC_LOCAL24PC: bfd_reloc_code_real = 447;
pub const BFD_RELOC_PPC_RELATIVE: bfd_reloc_code_real = 446;
pub const BFD_RELOC_PPC_JMP_SLOT: bfd_reloc_code_real = 445;
pub const BFD_RELOC_PPC_GLOB_DAT: bfd_reloc_code_real = 444;
pub const BFD_RELOC_PPC_COPY: bfd_reloc_code_real = 443;
pub const BFD_RELOC_PPC_BA16_BRNTAKEN: bfd_reloc_code_real = 442;
pub const BFD_RELOC_PPC_BA16_BRTAKEN: bfd_reloc_code_real = 441;
pub const BFD_RELOC_PPC_BA16: bfd_reloc_code_real = 440;
pub const BFD_RELOC_PPC_B16_BRNTAKEN: bfd_reloc_code_real = 439;
pub const BFD_RELOC_PPC_B16_BRTAKEN: bfd_reloc_code_real = 438;
pub const BFD_RELOC_PPC_B16: bfd_reloc_code_real = 437;
pub const BFD_RELOC_PPC_TOC16_HI: bfd_reloc_code_real = 436;
pub const BFD_RELOC_PPC_TOC16_LO: bfd_reloc_code_real = 435;
pub const BFD_RELOC_PPC_TOC16: bfd_reloc_code_real = 434;
pub const BFD_RELOC_PPC_BA26: bfd_reloc_code_real = 433;
pub const BFD_RELOC_PPC_B26: bfd_reloc_code_real = 432;
pub const BFD_RELOC_PJ_CODE_REL32: bfd_reloc_code_real = 431;
pub const BFD_RELOC_PJ_CODE_REL16: bfd_reloc_code_real = 430;
pub const BFD_RELOC_PJ_CODE_DIR32: bfd_reloc_code_real = 429;
pub const BFD_RELOC_PJ_CODE_DIR16: bfd_reloc_code_real = 428;
pub const BFD_RELOC_PJ_CODE_LO16: bfd_reloc_code_real = 427;
pub const BFD_RELOC_PJ_CODE_HI16: bfd_reloc_code_real = 426;
pub const BFD_RELOC_PDP11_DISP_6_PCREL: bfd_reloc_code_real = 425;
pub const BFD_RELOC_PDP11_DISP_8_PCREL: bfd_reloc_code_real = 424;
pub const BFD_RELOC_NS32K_DISP_32_PCREL: bfd_reloc_code_real = 423;
pub const BFD_RELOC_NS32K_DISP_16_PCREL: bfd_reloc_code_real = 422;
pub const BFD_RELOC_NS32K_DISP_8_PCREL: bfd_reloc_code_real = 421;
pub const BFD_RELOC_NS32K_DISP_32: bfd_reloc_code_real = 420;
pub const BFD_RELOC_NS32K_DISP_16: bfd_reloc_code_real = 419;
pub const BFD_RELOC_NS32K_DISP_8: bfd_reloc_code_real = 418;
pub const BFD_RELOC_NS32K_IMM_32_PCREL: bfd_reloc_code_real = 417;
pub const BFD_RELOC_NS32K_IMM_16_PCREL: bfd_reloc_code_real = 416;
pub const BFD_RELOC_NS32K_IMM_8_PCREL: bfd_reloc_code_real = 415;
pub const BFD_RELOC_NS32K_IMM_32: bfd_reloc_code_real = 414;
pub const BFD_RELOC_NS32K_IMM_16: bfd_reloc_code_real = 413;
pub const BFD_RELOC_NS32K_IMM_8: bfd_reloc_code_real = 412;
pub const BFD_RELOC_X86_64_REX_GOTPCRELX: bfd_reloc_code_real = 411;
pub const BFD_RELOC_X86_64_GOTPCRELX: bfd_reloc_code_real = 410;
pub const BFD_RELOC_X86_64_PLT32_BND: bfd_reloc_code_real = 409;
pub const BFD_RELOC_X86_64_PC32_BND: bfd_reloc_code_real = 408;
pub const BFD_RELOC_X86_64_IRELATIVE: bfd_reloc_code_real = 407;
pub const BFD_RELOC_X86_64_TLSDESC: bfd_reloc_code_real = 406;
pub const BFD_RELOC_X86_64_TLSDESC_CALL: bfd_reloc_code_real = 405;
pub const BFD_RELOC_X86_64_GOTPC32_TLSDESC: bfd_reloc_code_real = 404;
pub const BFD_RELOC_X86_64_PLTOFF64: bfd_reloc_code_real = 403;
pub const BFD_RELOC_X86_64_GOTPLT64: bfd_reloc_code_real = 402;
pub const BFD_RELOC_X86_64_GOTPC64: bfd_reloc_code_real = 401;
pub const BFD_RELOC_X86_64_GOTPCREL64: bfd_reloc_code_real = 400;
pub const BFD_RELOC_X86_64_GOT64: bfd_reloc_code_real = 399;
pub const BFD_RELOC_X86_64_GOTPC32: bfd_reloc_code_real = 398;
pub const BFD_RELOC_X86_64_GOTOFF64: bfd_reloc_code_real = 397;
pub const BFD_RELOC_X86_64_TPOFF32: bfd_reloc_code_real = 396;
pub const BFD_RELOC_X86_64_GOTTPOFF: bfd_reloc_code_real = 395;
pub const BFD_RELOC_X86_64_DTPOFF32: bfd_reloc_code_real = 394;
pub const BFD_RELOC_X86_64_TLSLD: bfd_reloc_code_real = 393;
pub const BFD_RELOC_X86_64_TLSGD: bfd_reloc_code_real = 392;
pub const BFD_RELOC_X86_64_TPOFF64: bfd_reloc_code_real = 391;
pub const BFD_RELOC_X86_64_DTPOFF64: bfd_reloc_code_real = 390;
pub const BFD_RELOC_X86_64_DTPMOD64: bfd_reloc_code_real = 389;
pub const BFD_RELOC_X86_64_32S: bfd_reloc_code_real = 388;
pub const BFD_RELOC_X86_64_GOTPCREL: bfd_reloc_code_real = 387;
pub const BFD_RELOC_X86_64_RELATIVE: bfd_reloc_code_real = 386;
pub const BFD_RELOC_X86_64_JUMP_SLOT: bfd_reloc_code_real = 385;
pub const BFD_RELOC_X86_64_GLOB_DAT: bfd_reloc_code_real = 384;
pub const BFD_RELOC_X86_64_COPY: bfd_reloc_code_real = 383;
pub const BFD_RELOC_X86_64_PLT32: bfd_reloc_code_real = 382;
pub const BFD_RELOC_X86_64_GOT32: bfd_reloc_code_real = 381;
pub const BFD_RELOC_386_GOT32X: bfd_reloc_code_real = 380;
pub const BFD_RELOC_386_IRELATIVE: bfd_reloc_code_real = 379;
pub const BFD_RELOC_386_TLS_DESC: bfd_reloc_code_real = 378;
pub const BFD_RELOC_386_TLS_DESC_CALL: bfd_reloc_code_real = 377;
pub const BFD_RELOC_386_TLS_GOTDESC: bfd_reloc_code_real = 376;
pub const BFD_RELOC_386_TLS_TPOFF32: bfd_reloc_code_real = 375;
pub const BFD_RELOC_386_TLS_DTPOFF32: bfd_reloc_code_real = 374;
pub const BFD_RELOC_386_TLS_DTPMOD32: bfd_reloc_code_real = 373;
pub const BFD_RELOC_386_TLS_LE_32: bfd_reloc_code_real = 372;
pub const BFD_RELOC_386_TLS_IE_32: bfd_reloc_code_real = 371;
pub const BFD_RELOC_386_TLS_LDO_32: bfd_reloc_code_real = 370;
pub const BFD_RELOC_386_TLS_LDM: bfd_reloc_code_real = 369;
pub const BFD_RELOC_386_TLS_GD: bfd_reloc_code_real = 368;
pub const BFD_RELOC_386_TLS_LE: bfd_reloc_code_real = 367;
pub const BFD_RELOC_386_TLS_GOTIE: bfd_reloc_code_real = 366;
pub const BFD_RELOC_386_TLS_IE: bfd_reloc_code_real = 365;
pub const BFD_RELOC_386_TLS_TPOFF: bfd_reloc_code_real = 364;
pub const BFD_RELOC_386_GOTPC: bfd_reloc_code_real = 363;
pub const BFD_RELOC_386_GOTOFF: bfd_reloc_code_real = 362;
pub const BFD_RELOC_386_RELATIVE: bfd_reloc_code_real = 361;
pub const BFD_RELOC_386_JUMP_SLOT: bfd_reloc_code_real = 360;
pub const BFD_RELOC_386_GLOB_DAT: bfd_reloc_code_real = 359;
pub const BFD_RELOC_386_COPY: bfd_reloc_code_real = 358;
pub const BFD_RELOC_386_PLT32: bfd_reloc_code_real = 357;
pub const BFD_RELOC_386_GOT32: bfd_reloc_code_real = 356;
pub const BFD_RELOC_MN10300_16_PCREL: bfd_reloc_code_real = 355;
pub const BFD_RELOC_MN10300_32_PCREL: bfd_reloc_code_real = 354;
pub const BFD_RELOC_MN10300_TLS_TPOFF: bfd_reloc_code_real = 353;
pub const BFD_RELOC_MN10300_TLS_DTPOFF: bfd_reloc_code_real = 352;
pub const BFD_RELOC_MN10300_TLS_DTPMOD: bfd_reloc_code_real = 351;
pub const BFD_RELOC_MN10300_TLS_LE: bfd_reloc_code_real = 350;
pub const BFD_RELOC_MN10300_TLS_IE: bfd_reloc_code_real = 349;
pub const BFD_RELOC_MN10300_TLS_GOTIE: bfd_reloc_code_real = 348;
pub const BFD_RELOC_MN10300_TLS_LDO: bfd_reloc_code_real = 347;
pub const BFD_RELOC_MN10300_TLS_LD: bfd_reloc_code_real = 346;
pub const BFD_RELOC_MN10300_TLS_GD: bfd_reloc_code_real = 345;
pub const BFD_RELOC_MN10300_ALIGN: bfd_reloc_code_real = 344;
pub const BFD_RELOC_MN10300_SYM_DIFF: bfd_reloc_code_real = 343;
pub const BFD_RELOC_MN10300_RELATIVE: bfd_reloc_code_real = 342;
pub const BFD_RELOC_MN10300_JMP_SLOT: bfd_reloc_code_real = 341;
pub const BFD_RELOC_MN10300_GLOB_DAT: bfd_reloc_code_real = 340;
pub const BFD_RELOC_MN10300_COPY: bfd_reloc_code_real = 339;
pub const BFD_RELOC_MN10300_GOT16: bfd_reloc_code_real = 338;
pub const BFD_RELOC_MN10300_GOT24: bfd_reloc_code_real = 337;
pub const BFD_RELOC_MN10300_GOT32: bfd_reloc_code_real = 336;
pub const BFD_RELOC_MN10300_GOTOFF24: bfd_reloc_code_real = 335;
pub const BFD_RELOC_FRV_TLSMOFF: bfd_reloc_code_real = 334;
pub const BFD_RELOC_FRV_TLSOFF_RELAX: bfd_reloc_code_real = 333;
pub const BFD_RELOC_FRV_GETTLSOFF_RELAX: bfd_reloc_code_real = 332;
pub const BFD_RELOC_FRV_TLSDESC_RELAX: bfd_reloc_code_real = 331;
pub const BFD_RELOC_FRV_TLSOFF: bfd_reloc_code_real = 330;
pub const BFD_RELOC_FRV_GOTTLSOFFLO: bfd_reloc_code_real = 329;
pub const BFD_RELOC_FRV_GOTTLSOFFHI: bfd_reloc_code_real = 328;
pub const BFD_RELOC_FRV_GOTTLSOFF12: bfd_reloc_code_real = 327;
pub const BFD_RELOC_FRV_TLSMOFFLO: bfd_reloc_code_real = 326;
pub const BFD_RELOC_FRV_TLSMOFFHI: bfd_reloc_code_real = 325;
pub const BFD_RELOC_FRV_TLSMOFF12: bfd_reloc_code_real = 324;
pub const BFD_RELOC_FRV_GOTTLSDESCLO: bfd_reloc_code_real = 323;
pub const BFD_RELOC_FRV_GOTTLSDESCHI: bfd_reloc_code_real = 322;
pub const BFD_RELOC_FRV_GOTTLSDESC12: bfd_reloc_code_real = 321;
pub const BFD_RELOC_FRV_TLSDESC_VALUE: bfd_reloc_code_real = 320;
pub const BFD_RELOC_FRV_GETTLSOFF: bfd_reloc_code_real = 319;
pub const BFD_RELOC_FRV_GOTOFFLO: bfd_reloc_code_real = 318;
pub const BFD_RELOC_FRV_GOTOFFHI: bfd_reloc_code_real = 317;
pub const BFD_RELOC_FRV_GOTOFF12: bfd_reloc_code_real = 316;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFFLO: bfd_reloc_code_real = 315;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFFHI: bfd_reloc_code_real = 314;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFF12: bfd_reloc_code_real = 313;
pub const BFD_RELOC_FRV_FUNCDESC_VALUE: bfd_reloc_code_real = 312;
pub const BFD_RELOC_FRV_FUNCDESC_GOTLO: bfd_reloc_code_real = 311;
pub const BFD_RELOC_FRV_FUNCDESC_GOTHI: bfd_reloc_code_real = 310;
pub const BFD_RELOC_FRV_FUNCDESC_GOT12: bfd_reloc_code_real = 309;
pub const BFD_RELOC_FRV_FUNCDESC: bfd_reloc_code_real = 308;
pub const BFD_RELOC_FRV_GOTLO: bfd_reloc_code_real = 307;
pub const BFD_RELOC_FRV_GOTHI: bfd_reloc_code_real = 306;
pub const BFD_RELOC_FRV_GOT12: bfd_reloc_code_real = 305;
pub const BFD_RELOC_FRV_GPRELLO: bfd_reloc_code_real = 304;
pub const BFD_RELOC_FRV_GPRELHI: bfd_reloc_code_real = 303;
pub const BFD_RELOC_FRV_GPREL32: bfd_reloc_code_real = 302;
pub const BFD_RELOC_FRV_GPRELU12: bfd_reloc_code_real = 301;
pub const BFD_RELOC_FRV_GPREL12: bfd_reloc_code_real = 300;
pub const BFD_RELOC_FRV_HI16: bfd_reloc_code_real = 299;
pub const BFD_RELOC_FRV_LO16: bfd_reloc_code_real = 298;
pub const BFD_RELOC_FRV_LABEL24: bfd_reloc_code_real = 297;
pub const BFD_RELOC_FRV_LABEL16: bfd_reloc_code_real = 296;
pub const BFD_RELOC_FT32_DIFF32: bfd_reloc_code_real = 295;
pub const BFD_RELOC_FT32_15: bfd_reloc_code_real = 294;
pub const BFD_RELOC_FT32_SC1: bfd_reloc_code_real = 293;
pub const BFD_RELOC_FT32_SC0: bfd_reloc_code_real = 292;
pub const BFD_RELOC_FT32_RELAX: bfd_reloc_code_real = 291;
pub const BFD_RELOC_FT32_18: bfd_reloc_code_real = 290;
pub const BFD_RELOC_FT32_17: bfd_reloc_code_real = 289;
pub const BFD_RELOC_FT32_20: bfd_reloc_code_real = 288;
pub const BFD_RELOC_FT32_10: bfd_reloc_code_real = 287;
pub const BFD_RELOC_MOXIE_10_PCREL: bfd_reloc_code_real = 286;
pub const BFD_RELOC_MIPS_JUMP_SLOT: bfd_reloc_code_real = 285;
pub const BFD_RELOC_MIPS_COPY: bfd_reloc_code_real = 284;
pub const BFD_RELOC_MIPS_EH: bfd_reloc_code_real = 283;
pub const BFD_RELOC_MICROMIPS_TLS_TPREL_LO16: bfd_reloc_code_real = 282;
pub const BFD_RELOC_MIPS_TLS_TPREL_LO16: bfd_reloc_code_real = 281;
pub const BFD_RELOC_MICROMIPS_TLS_TPREL_HI16: bfd_reloc_code_real = 280;
pub const BFD_RELOC_MIPS_TLS_TPREL_HI16: bfd_reloc_code_real = 279;
pub const BFD_RELOC_MIPS_TLS_TPREL64: bfd_reloc_code_real = 278;
pub const BFD_RELOC_MIPS_TLS_TPREL32: bfd_reloc_code_real = 277;
pub const BFD_RELOC_MICROMIPS_TLS_GOTTPREL: bfd_reloc_code_real = 276;
pub const BFD_RELOC_MIPS_TLS_GOTTPREL: bfd_reloc_code_real = 275;
pub const BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16: bfd_reloc_code_real = 274;
pub const BFD_RELOC_MIPS_TLS_DTPREL_LO16: bfd_reloc_code_real = 273;
pub const BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16: bfd_reloc_code_real = 272;
pub const BFD_RELOC_MIPS_TLS_DTPREL_HI16: bfd_reloc_code_real = 271;
pub const BFD_RELOC_MICROMIPS_TLS_LDM: bfd_reloc_code_real = 270;
pub const BFD_RELOC_MIPS_TLS_LDM: bfd_reloc_code_real = 269;
pub const BFD_RELOC_MICROMIPS_TLS_GD: bfd_reloc_code_real = 268;
pub const BFD_RELOC_MIPS_TLS_GD: bfd_reloc_code_real = 267;
pub const BFD_RELOC_MIPS_TLS_DTPREL64: bfd_reloc_code_real = 266;
pub const BFD_RELOC_MIPS_TLS_DTPMOD64: bfd_reloc_code_real = 265;
pub const BFD_RELOC_MIPS_TLS_DTPREL32: bfd_reloc_code_real = 264;
pub const BFD_RELOC_MIPS_TLS_DTPMOD32: bfd_reloc_code_real = 263;
pub const BFD_RELOC_MICROMIPS_JALR: bfd_reloc_code_real = 262;
pub const BFD_RELOC_MIPS_JALR: bfd_reloc_code_real = 261;
pub const BFD_RELOC_MIPS_RELGOT: bfd_reloc_code_real = 260;
pub const BFD_RELOC_MIPS_REL16: bfd_reloc_code_real = 259;
pub const BFD_RELOC_MICROMIPS_SCN_DISP: bfd_reloc_code_real = 258;
pub const BFD_RELOC_MIPS_SCN_DISP: bfd_reloc_code_real = 257;
pub const BFD_RELOC_MICROMIPS_HIGHER: bfd_reloc_code_real = 256;
pub const BFD_RELOC_MIPS_HIGHER: bfd_reloc_code_real = 255;
pub const BFD_RELOC_MICROMIPS_HIGHEST: bfd_reloc_code_real = 254;
pub const BFD_RELOC_MIPS_HIGHEST: bfd_reloc_code_real = 253;
pub const BFD_RELOC_MIPS_DELETE: bfd_reloc_code_real = 252;
pub const BFD_RELOC_MIPS_INSERT_B: bfd_reloc_code_real = 251;
pub const BFD_RELOC_MIPS_INSERT_A: bfd_reloc_code_real = 250;
pub const BFD_RELOC_MIPS_SHIFT6: bfd_reloc_code_real = 249;
pub const BFD_RELOC_MIPS_SHIFT5: bfd_reloc_code_real = 248;
pub const BFD_RELOC_MICROMIPS_GOT_DISP: bfd_reloc_code_real = 247;
pub const BFD_RELOC_MIPS_GOT_DISP: bfd_reloc_code_real = 246;
pub const BFD_RELOC_MICROMIPS_GOT_OFST: bfd_reloc_code_real = 245;
pub const BFD_RELOC_MIPS_GOT_OFST: bfd_reloc_code_real = 244;
pub const BFD_RELOC_MICROMIPS_GOT_PAGE: bfd_reloc_code_real = 243;
pub const BFD_RELOC_MIPS_GOT_PAGE: bfd_reloc_code_real = 242;
pub const BFD_RELOC_MICROMIPS_SUB: bfd_reloc_code_real = 241;
pub const BFD_RELOC_MIPS_SUB: bfd_reloc_code_real = 240;
pub const BFD_RELOC_MICROMIPS_CALL_LO16: bfd_reloc_code_real = 239;
pub const BFD_RELOC_MIPS_CALL_LO16: bfd_reloc_code_real = 238;
pub const BFD_RELOC_MICROMIPS_CALL_HI16: bfd_reloc_code_real = 237;
pub const BFD_RELOC_MIPS_CALL_HI16: bfd_reloc_code_real = 236;
pub const BFD_RELOC_MICROMIPS_GOT_LO16: bfd_reloc_code_real = 235;
pub const BFD_RELOC_MIPS_GOT_LO16: bfd_reloc_code_real = 234;
pub const BFD_RELOC_MICROMIPS_GOT_HI16: bfd_reloc_code_real = 233;
pub const BFD_RELOC_MIPS_GOT_HI16: bfd_reloc_code_real = 232;
pub const BFD_RELOC_MICROMIPS_CALL16: bfd_reloc_code_real = 231;
pub const BFD_RELOC_MIPS_CALL16: bfd_reloc_code_real = 230;
pub const BFD_RELOC_MICROMIPS_GOT16: bfd_reloc_code_real = 229;
pub const BFD_RELOC_MIPS_GOT16: bfd_reloc_code_real = 228;
pub const BFD_RELOC_MICROMIPS_LO16: bfd_reloc_code_real = 227;
pub const BFD_RELOC_MICROMIPS_HI16_S: bfd_reloc_code_real = 226;
pub const BFD_RELOC_MICROMIPS_HI16: bfd_reloc_code_real = 225;
pub const BFD_RELOC_MICROMIPS_GPREL16: bfd_reloc_code_real = 224;
pub const BFD_RELOC_MIPS_19_PCREL_S2: bfd_reloc_code_real = 223;
pub const BFD_RELOC_MIPS_18_PCREL_S3: bfd_reloc_code_real = 222;
pub const BFD_RELOC_MIPS_26_PCREL_S2: bfd_reloc_code_real = 221;
pub const BFD_RELOC_MIPS_21_PCREL_S2: bfd_reloc_code_real = 220;
pub const BFD_RELOC_MIPS16_16_PCREL_S1: bfd_reloc_code_real = 219;
pub const BFD_RELOC_MICROMIPS_16_PCREL_S1: bfd_reloc_code_real = 218;
pub const BFD_RELOC_MICROMIPS_10_PCREL_S1: bfd_reloc_code_real = 217;
pub const BFD_RELOC_MICROMIPS_7_PCREL_S1: bfd_reloc_code_real = 216;
pub const BFD_RELOC_MICROMIPS_LITERAL: bfd_reloc_code_real = 215;
pub const BFD_RELOC_MIPS_LITERAL: bfd_reloc_code_real = 214;
pub const BFD_RELOC_MIPS16_TLS_TPREL_LO16: bfd_reloc_code_real = 213;
pub const BFD_RELOC_MIPS16_TLS_TPREL_HI16: bfd_reloc_code_real = 212;
pub const BFD_RELOC_MIPS16_TLS_GOTTPREL: bfd_reloc_code_real = 211;
pub const BFD_RELOC_MIPS16_TLS_DTPREL_LO16: bfd_reloc_code_real = 210;
pub const BFD_RELOC_MIPS16_TLS_DTPREL_HI16: bfd_reloc_code_real = 209;
pub const BFD_RELOC_MIPS16_TLS_LDM: bfd_reloc_code_real = 208;
pub const BFD_RELOC_MIPS16_TLS_GD: bfd_reloc_code_real = 207;
pub const BFD_RELOC_MIPS16_LO16: bfd_reloc_code_real = 206;
pub const BFD_RELOC_MIPS16_HI16_S: bfd_reloc_code_real = 205;
pub const BFD_RELOC_MIPS16_HI16: bfd_reloc_code_real = 204;
pub const BFD_RELOC_MIPS16_CALL16: bfd_reloc_code_real = 203;
pub const BFD_RELOC_MIPS16_GOT16: bfd_reloc_code_real = 202;
pub const BFD_RELOC_LO16_PCREL: bfd_reloc_code_real = 201;
pub const BFD_RELOC_HI16_S_PCREL: bfd_reloc_code_real = 200;
pub const BFD_RELOC_HI16_PCREL: bfd_reloc_code_real = 199;
pub const BFD_RELOC_LO16: bfd_reloc_code_real = 198;
pub const BFD_RELOC_HI16_S: bfd_reloc_code_real = 197;
pub const BFD_RELOC_HI16: bfd_reloc_code_real = 196;
pub const BFD_RELOC_MIPS16_GPREL: bfd_reloc_code_real = 195;
pub const BFD_RELOC_MIPS16_JMP: bfd_reloc_code_real = 194;
pub const BFD_RELOC_MICROMIPS_JMP: bfd_reloc_code_real = 193;
pub const BFD_RELOC_MIPS_JMP: bfd_reloc_code_real = 192;
pub const BFD_RELOC_ALPHA_TPREL16: bfd_reloc_code_real = 191;
pub const BFD_RELOC_ALPHA_TPREL_LO16: bfd_reloc_code_real = 190;
pub const BFD_RELOC_ALPHA_TPREL_HI16: bfd_reloc_code_real = 189;
pub const BFD_RELOC_ALPHA_TPREL64: bfd_reloc_code_real = 188;
pub const BFD_RELOC_ALPHA_GOTTPREL16: bfd_reloc_code_real = 187;
pub const BFD_RELOC_ALPHA_DTPREL16: bfd_reloc_code_real = 186;
pub const BFD_RELOC_ALPHA_DTPREL_LO16: bfd_reloc_code_real = 185;
pub const BFD_RELOC_ALPHA_DTPREL_HI16: bfd_reloc_code_real = 184;
pub const BFD_RELOC_ALPHA_DTPREL64: bfd_reloc_code_real = 183;
pub const BFD_RELOC_ALPHA_GOTDTPREL16: bfd_reloc_code_real = 182;
pub const BFD_RELOC_ALPHA_DTPMOD64: bfd_reloc_code_real = 181;
pub const BFD_RELOC_ALPHA_TLSLDM: bfd_reloc_code_real = 180;
pub const BFD_RELOC_ALPHA_TLSGD: bfd_reloc_code_real = 179;
pub const BFD_RELOC_ALPHA_BOH: bfd_reloc_code_real = 178;
pub const BFD_RELOC_ALPHA_LDA: bfd_reloc_code_real = 177;
pub const BFD_RELOC_ALPHA_BSR: bfd_reloc_code_real = 176;
pub const BFD_RELOC_ALPHA_NOP: bfd_reloc_code_real = 175;
pub const BFD_RELOC_ALPHA_BRSGP: bfd_reloc_code_real = 174;
pub const BFD_RELOC_ALPHA_GPREL_LO16: bfd_reloc_code_real = 173;
pub const BFD_RELOC_ALPHA_GPREL_HI16: bfd_reloc_code_real = 172;
pub const BFD_RELOC_ALPHA_CODEADDR: bfd_reloc_code_real = 171;
pub const BFD_RELOC_ALPHA_LINKAGE: bfd_reloc_code_real = 170;
pub const BFD_RELOC_ALPHA_HINT: bfd_reloc_code_real = 169;
pub const BFD_RELOC_ALPHA_LITUSE: bfd_reloc_code_real = 168;
pub const BFD_RELOC_ALPHA_ELF_LITERAL: bfd_reloc_code_real = 167;
pub const BFD_RELOC_ALPHA_LITERAL: bfd_reloc_code_real = 166;
pub const BFD_RELOC_ALPHA_GPDISP: bfd_reloc_code_real = 165;
pub const BFD_RELOC_ALPHA_GPDISP_LO16: bfd_reloc_code_real = 164;
pub const BFD_RELOC_ALPHA_GPDISP_HI16: bfd_reloc_code_real = 163;
pub const BFD_RELOC_SPU_ADD_PIC: bfd_reloc_code_real = 162;
pub const BFD_RELOC_SPU_PPU64: bfd_reloc_code_real = 161;
pub const BFD_RELOC_SPU_PPU32: bfd_reloc_code_real = 160;
pub const BFD_RELOC_SPU_HI16: bfd_reloc_code_real = 159;
pub const BFD_RELOC_SPU_LO16: bfd_reloc_code_real = 158;
pub const BFD_RELOC_SPU_PCREL16: bfd_reloc_code_real = 157;
pub const BFD_RELOC_SPU_PCREL9b: bfd_reloc_code_real = 156;
pub const BFD_RELOC_SPU_PCREL9a: bfd_reloc_code_real = 155;
pub const BFD_RELOC_SPU_IMM18: bfd_reloc_code_real = 154;
pub const BFD_RELOC_SPU_IMM16W: bfd_reloc_code_real = 153;
pub const BFD_RELOC_SPU_IMM16: bfd_reloc_code_real = 152;
pub const BFD_RELOC_SPU_IMM10W: bfd_reloc_code_real = 151;
pub const BFD_RELOC_SPU_IMM10: bfd_reloc_code_real = 150;
pub const BFD_RELOC_SPU_IMM8: bfd_reloc_code_real = 149;
pub const BFD_RELOC_SPU_IMM7: bfd_reloc_code_real = 148;
pub const BFD_RELOC_SPARC_TLS_TPOFF64: bfd_reloc_code_real = 147;
pub const BFD_RELOC_SPARC_TLS_TPOFF32: bfd_reloc_code_real = 146;
pub const BFD_RELOC_SPARC_TLS_DTPOFF64: bfd_reloc_code_real = 145;
pub const BFD_RELOC_SPARC_TLS_DTPOFF32: bfd_reloc_code_real = 144;
pub const BFD_RELOC_SPARC_TLS_DTPMOD64: bfd_reloc_code_real = 143;
pub const BFD_RELOC_SPARC_TLS_DTPMOD32: bfd_reloc_code_real = 142;
pub const BFD_RELOC_SPARC_TLS_LE_LOX10: bfd_reloc_code_real = 141;
pub const BFD_RELOC_SPARC_TLS_LE_HIX22: bfd_reloc_code_real = 140;
pub const BFD_RELOC_SPARC_TLS_IE_ADD: bfd_reloc_code_real = 139;
pub const BFD_RELOC_SPARC_TLS_IE_LDX: bfd_reloc_code_real = 138;
pub const BFD_RELOC_SPARC_TLS_IE_LD: bfd_reloc_code_real = 137;
pub const BFD_RELOC_SPARC_TLS_IE_LO10: bfd_reloc_code_real = 136;
pub const BFD_RELOC_SPARC_TLS_IE_HI22: bfd_reloc_code_real = 135;
pub const BFD_RELOC_SPARC_TLS_LDO_ADD: bfd_reloc_code_real = 134;
pub const BFD_RELOC_SPARC_TLS_LDO_LOX10: bfd_reloc_code_real = 133;
pub const BFD_RELOC_SPARC_TLS_LDO_HIX22: bfd_reloc_code_real = 132;
pub const BFD_RELOC_SPARC_TLS_LDM_CALL: bfd_reloc_code_real = 131;
pub const BFD_RELOC_SPARC_TLS_LDM_ADD: bfd_reloc_code_real = 130;
pub const BFD_RELOC_SPARC_TLS_LDM_LO10: bfd_reloc_code_real = 129;
pub const BFD_RELOC_SPARC_TLS_LDM_HI22: bfd_reloc_code_real = 128;
pub const BFD_RELOC_SPARC_TLS_GD_CALL: bfd_reloc_code_real = 127;
pub const BFD_RELOC_SPARC_TLS_GD_ADD: bfd_reloc_code_real = 126;
pub const BFD_RELOC_SPARC_TLS_GD_LO10: bfd_reloc_code_real = 125;
pub const BFD_RELOC_SPARC_TLS_GD_HI22: bfd_reloc_code_real = 124;
pub const BFD_RELOC_SPARC_REV32: bfd_reloc_code_real = 123;
pub const BFD_RELOC_SPARC_WDISP10: bfd_reloc_code_real = 122;
pub const BFD_RELOC_SPARC_SIZE64: bfd_reloc_code_real = 121;
pub const BFD_RELOC_SPARC_SIZE32: bfd_reloc_code_real = 120;
pub const BFD_RELOC_SPARC_H34: bfd_reloc_code_real = 119;
pub const BFD_RELOC_SPARC_REGISTER: bfd_reloc_code_real = 118;
pub const BFD_RELOC_SPARC_L44: bfd_reloc_code_real = 117;
pub const BFD_RELOC_SPARC_M44: bfd_reloc_code_real = 116;
pub const BFD_RELOC_SPARC_H44: bfd_reloc_code_real = 115;
pub const BFD_RELOC_SPARC_LOX10: bfd_reloc_code_real = 114;
pub const BFD_RELOC_SPARC_HIX22: bfd_reloc_code_real = 113;
pub const BFD_RELOC_SPARC_PLT64: bfd_reloc_code_real = 112;
pub const BFD_RELOC_SPARC_PLT32: bfd_reloc_code_real = 111;
pub const BFD_RELOC_SPARC_5: bfd_reloc_code_real = 110;
pub const BFD_RELOC_SPARC_6: bfd_reloc_code_real = 109;
pub const BFD_RELOC_SPARC_7: bfd_reloc_code_real = 108;
pub const BFD_RELOC_SPARC_WDISP19: bfd_reloc_code_real = 107;
pub const BFD_RELOC_SPARC_WDISP16: bfd_reloc_code_real = 106;
pub const BFD_RELOC_SPARC_PC_LM22: bfd_reloc_code_real = 105;
pub const BFD_RELOC_SPARC_PC_HM10: bfd_reloc_code_real = 104;
pub const BFD_RELOC_SPARC_PC_HH22: bfd_reloc_code_real = 103;
pub const BFD_RELOC_SPARC_LM22: bfd_reloc_code_real = 102;
pub const BFD_RELOC_SPARC_HM10: bfd_reloc_code_real = 101;
pub const BFD_RELOC_SPARC_HH22: bfd_reloc_code_real = 100;
pub const BFD_RELOC_SPARC_OLO10: bfd_reloc_code_real = 99;
pub const BFD_RELOC_SPARC_11: bfd_reloc_code_real = 98;
pub const BFD_RELOC_SPARC_10: bfd_reloc_code_real = 97;
pub const BFD_RELOC_SPARC_BASE22: bfd_reloc_code_real = 96;
pub const BFD_RELOC_SPARC_BASE13: bfd_reloc_code_real = 95;
pub const BFD_RELOC_SPARC_IRELATIVE: bfd_reloc_code_real = 94;
pub const BFD_RELOC_SPARC_JMP_IREL: bfd_reloc_code_real = 93;
pub const BFD_RELOC_SPARC_GOTDATA_OP: bfd_reloc_code_real = 92;
pub const BFD_RELOC_SPARC_GOTDATA_OP_LOX10: bfd_reloc_code_real = 91;
pub const BFD_RELOC_SPARC_GOTDATA_OP_HIX22: bfd_reloc_code_real = 90;
pub const BFD_RELOC_SPARC_GOTDATA_LOX10: bfd_reloc_code_real = 89;
pub const BFD_RELOC_SPARC_GOTDATA_HIX22: bfd_reloc_code_real = 88;
pub const BFD_RELOC_SPARC_UA64: bfd_reloc_code_real = 87;
pub const BFD_RELOC_SPARC_UA32: bfd_reloc_code_real = 86;
pub const BFD_RELOC_SPARC_UA16: bfd_reloc_code_real = 85;
pub const BFD_RELOC_SPARC_RELATIVE: bfd_reloc_code_real = 84;
pub const BFD_RELOC_SPARC_JMP_SLOT: bfd_reloc_code_real = 83;
pub const BFD_RELOC_SPARC_GLOB_DAT: bfd_reloc_code_real = 82;
pub const BFD_RELOC_SPARC_COPY: bfd_reloc_code_real = 81;
pub const BFD_RELOC_SPARC_WPLT30: bfd_reloc_code_real = 80;
pub const BFD_RELOC_SPARC_PC22: bfd_reloc_code_real = 79;
pub const BFD_RELOC_SPARC_PC10: bfd_reloc_code_real = 78;
pub const BFD_RELOC_SPARC_GOT22: bfd_reloc_code_real = 77;
pub const BFD_RELOC_SPARC_GOT13: bfd_reloc_code_real = 76;
pub const BFD_RELOC_SPARC_GOT10: bfd_reloc_code_real = 75;
pub const BFD_RELOC_SPARC13: bfd_reloc_code_real = 74;
pub const BFD_RELOC_SPARC22: bfd_reloc_code_real = 73;
pub const BFD_RELOC_SPARC_WDISP22: bfd_reloc_code_real = 72;
pub const BFD_RELOC_NONE: bfd_reloc_code_real = 71;
pub const BFD_RELOC_GPREL32: bfd_reloc_code_real = 70;
pub const BFD_RELOC_GPREL16: bfd_reloc_code_real = 69;
pub const BFD_RELOC_LO10: bfd_reloc_code_real = 68;
pub const BFD_RELOC_HI22: bfd_reloc_code_real = 67;
pub const BFD_RELOC_23_PCREL_S2: bfd_reloc_code_real = 66;
pub const BFD_RELOC_16_PCREL_S2: bfd_reloc_code_real = 65;
pub const BFD_RELOC_32_PCREL_S2: bfd_reloc_code_real = 64;
pub const BFD_RELOC_8_FFnn: bfd_reloc_code_real = 63;
pub const BFD_RELOC_RVA: bfd_reloc_code_real = 62;
pub const BFD_RELOC_8_BASEREL: bfd_reloc_code_real = 61;
pub const BFD_RELOC_HI16_S_BASEREL: bfd_reloc_code_real = 60;
pub const BFD_RELOC_HI16_BASEREL: bfd_reloc_code_real = 59;
pub const BFD_RELOC_LO16_BASEREL: bfd_reloc_code_real = 58;
pub const BFD_RELOC_16_BASEREL: bfd_reloc_code_real = 57;
pub const BFD_RELOC_32_BASEREL: bfd_reloc_code_real = 56;
pub const BFD_RELOC_68K_TLS_LE8: bfd_reloc_code_real = 55;
pub const BFD_RELOC_68K_TLS_LE16: bfd_reloc_code_real = 54;
pub const BFD_RELOC_68K_TLS_LE32: bfd_reloc_code_real = 53;
pub const BFD_RELOC_68K_TLS_IE8: bfd_reloc_code_real = 52;
pub const BFD_RELOC_68K_TLS_IE16: bfd_reloc_code_real = 51;
pub const BFD_RELOC_68K_TLS_IE32: bfd_reloc_code_real = 50;
pub const BFD_RELOC_68K_TLS_LDO8: bfd_reloc_code_real = 49;
pub const BFD_RELOC_68K_TLS_LDO16: bfd_reloc_code_real = 48;
pub const BFD_RELOC_68K_TLS_LDO32: bfd_reloc_code_real = 47;
pub const BFD_RELOC_68K_TLS_LDM8: bfd_reloc_code_real = 46;
pub const BFD_RELOC_68K_TLS_LDM16: bfd_reloc_code_real = 45;
pub const BFD_RELOC_68K_TLS_LDM32: bfd_reloc_code_real = 44;
pub const BFD_RELOC_68K_TLS_GD8: bfd_reloc_code_real = 43;
pub const BFD_RELOC_68K_TLS_GD16: bfd_reloc_code_real = 42;
pub const BFD_RELOC_68K_TLS_GD32: bfd_reloc_code_real = 41;
pub const BFD_RELOC_68K_RELATIVE: bfd_reloc_code_real = 40;
pub const BFD_RELOC_68K_JMP_SLOT: bfd_reloc_code_real = 39;
pub const BFD_RELOC_68K_GLOB_DAT: bfd_reloc_code_real = 38;
pub const BFD_RELOC_SIZE64: bfd_reloc_code_real = 37;
pub const BFD_RELOC_SIZE32: bfd_reloc_code_real = 36;
pub const BFD_RELOC_8_PLTOFF: bfd_reloc_code_real = 35;
pub const BFD_RELOC_HI16_S_PLTOFF: bfd_reloc_code_real = 34;
pub const BFD_RELOC_HI16_PLTOFF: bfd_reloc_code_real = 33;
pub const BFD_RELOC_LO16_PLTOFF: bfd_reloc_code_real = 32;
pub const BFD_RELOC_16_PLTOFF: bfd_reloc_code_real = 31;
pub const BFD_RELOC_32_PLTOFF: bfd_reloc_code_real = 30;
pub const BFD_RELOC_64_PLTOFF: bfd_reloc_code_real = 29;
pub const BFD_RELOC_8_PLT_PCREL: bfd_reloc_code_real = 28;
pub const BFD_RELOC_16_PLT_PCREL: bfd_reloc_code_real = 27;
pub const BFD_RELOC_24_PLT_PCREL: bfd_reloc_code_real = 26;
pub const BFD_RELOC_32_PLT_PCREL: bfd_reloc_code_real = 25;
pub const BFD_RELOC_64_PLT_PCREL: bfd_reloc_code_real = 24;
pub const BFD_RELOC_8_GOTOFF: bfd_reloc_code_real = 23;
pub const BFD_RELOC_HI16_S_GOTOFF: bfd_reloc_code_real = 22;
pub const BFD_RELOC_HI16_GOTOFF: bfd_reloc_code_real = 21;
pub const BFD_RELOC_LO16_GOTOFF: bfd_reloc_code_real = 20;
pub const BFD_RELOC_16_GOTOFF: bfd_reloc_code_real = 19;
pub const BFD_RELOC_32_GOTOFF: bfd_reloc_code_real = 18;
pub const BFD_RELOC_8_GOT_PCREL: bfd_reloc_code_real = 17;
pub const BFD_RELOC_16_GOT_PCREL: bfd_reloc_code_real = 16;
pub const BFD_RELOC_32_GOT_PCREL: bfd_reloc_code_real = 15;
pub const BFD_RELOC_32_SECREL: bfd_reloc_code_real = 14;
pub const BFD_RELOC_8_PCREL: bfd_reloc_code_real = 13;
pub const BFD_RELOC_12_PCREL: bfd_reloc_code_real = 12;
pub const BFD_RELOC_16_PCREL: bfd_reloc_code_real = 11;
pub const BFD_RELOC_24_PCREL: bfd_reloc_code_real = 10;
pub const BFD_RELOC_32_PCREL: bfd_reloc_code_real = 9;
pub const BFD_RELOC_64_PCREL: bfd_reloc_code_real = 8;
pub const BFD_RELOC_8: bfd_reloc_code_real = 7;
pub const BFD_RELOC_14: bfd_reloc_code_real = 6;
pub const BFD_RELOC_16: bfd_reloc_code_real = 5;
pub const BFD_RELOC_24: bfd_reloc_code_real = 4;
pub const BFD_RELOC_26: bfd_reloc_code_real = 3;
pub const BFD_RELOC_32: bfd_reloc_code_real = 2;
pub const BFD_RELOC_64: bfd_reloc_code_real = 1;
pub const _dummy_first_bfd_reloc_code_real: bfd_reloc_code_real = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub size: libc::c_uint,
    pub contents: *mut bfd_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub section: *mut asection,
}
pub type bfd_link_order_type = libc::c_uint;
pub const bfd_symbol_reloc_link_order: bfd_link_order_type = 4;
pub const bfd_section_reloc_link_order: bfd_link_order_type = 3;
pub const bfd_data_link_order: bfd_link_order_type = 2;
pub const bfd_indirect_link_order: bfd_link_order_type = 1;
pub const bfd_undefined_link_order: bfd_link_order_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_symbol {
    pub the_bfd: *mut bfd,
    pub name: *const libc::c_char,
    pub value: symvalue,
    pub flags: flagword,
    pub section: *mut bfd_section,
    pub udata: C2RustUnnamed_6,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub p: *mut libc::c_void,
    pub i: bfd_vma,
}
pub type flagword = libc::c_uint;
pub type symvalue = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct relent_chain {
    pub relent: arelent,
    pub next: *mut relent_chain,
}
pub type arelent = reloc_cache_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct reloc_cache_entry {
    pub sym_ptr_ptr: *mut *mut bfd_symbol,
    pub address: bfd_size_type,
    pub addend: bfd_vma,
    pub howto: *const reloc_howto_type,
}
pub type reloc_howto_type = reloc_howto_struct;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct reloc_howto_struct {
    pub type_0: libc::c_uint,
    #[bitfield(name = "size", ty = "libc::c_uint", bits = "0..=2")]
    #[bitfield(name = "bitsize", ty = "libc::c_uint", bits = "3..=9")]
    #[bitfield(name = "rightshift", ty = "libc::c_uint", bits = "10..=15")]
    #[bitfield(name = "bitpos", ty = "libc::c_uint", bits = "16..=21")]
    #[bitfield(name = "complain_on_overflow", ty = "complain_overflow", bits = "22..=23")]
    #[bitfield(name = "negate", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "pc_relative", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "partial_inplace", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "pcrel_offset", ty = "libc::c_uint", bits = "27..=27")]
    pub size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [u8; 4],
    pub src_mask: bfd_vma,
    pub dst_mask: bfd_vma,
    pub special_function: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut arelent,
            *mut bfd_symbol,
            *mut libc::c_void,
            *mut asection,
            *mut bfd,
            *mut *mut libc::c_char,
        ) -> bfd_reloc_status_type,
    >,
    pub name: *const libc::c_char,
}
pub type bfd_reloc_status_type = bfd_reloc_status;
pub type bfd_reloc_status = libc::c_uint;
pub const bfd_reloc_dangerous: bfd_reloc_status = 9;
pub const bfd_reloc_undefined: bfd_reloc_status = 8;
pub const bfd_reloc_other: bfd_reloc_status = 7;
pub const bfd_reloc_notsupported: bfd_reloc_status = 6;
pub const bfd_reloc_continue: bfd_reloc_status = 5;
pub const bfd_reloc_outofrange: bfd_reloc_status = 4;
pub const bfd_reloc_overflow: bfd_reloc_status = 3;
pub const bfd_reloc_ok: bfd_reloc_status = 2;
pub type complain_overflow = libc::c_uint;
pub const complain_overflow_unsigned: complain_overflow = 3;
pub const complain_overflow_signed: complain_overflow = 2;
pub const complain_overflow_bitfield: complain_overflow = 1;
pub const complain_overflow_dont: complain_overflow = 0;
pub type file_ptr = libc::c_long;
pub type alent = lineno_cache_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lineno_cache_entry {
    pub line_number: libc::c_uint,
    pub u: C2RustUnnamed_7,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub sym: *mut bfd_symbol,
    pub offset: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct relax_table {
    pub addr: bfd_vma,
    pub size: libc::c_int,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_hash_table {
    pub table: *mut *mut bfd_hash_entry,
    pub newfunc: Option::<
        unsafe extern "C" fn(
            *mut bfd_hash_entry,
            *mut bfd_hash_table,
            *const libc::c_char,
        ) -> *mut bfd_hash_entry,
    >,
    pub memory: *mut libc::c_void,
    pub size: libc::c_uint,
    pub count: libc::c_uint,
    pub entsize: libc::c_uint,
    #[bitfield(name = "frozen", ty = "libc::c_uint", bits = "0..=0")]
    pub frozen: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_hash_entry {
    pub next: *mut bfd_hash_entry,
    pub string: *const libc::c_char,
    pub hash: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_hash_table {
    pub table: bfd_hash_table,
    pub undefs: *mut bfd_link_hash_entry,
    pub undefs_tail: *mut bfd_link_hash_entry,
    pub hash_table_free: Option::<unsafe extern "C" fn(*mut bfd) -> ()>,
    pub type_0: bfd_link_hash_table_type,
}
pub type bfd_link_hash_table_type = libc::c_uint;
pub const bfd_link_elf_hash_table: bfd_link_hash_table_type = 1;
pub const bfd_link_generic_hash_table: bfd_link_hash_table_type = 0;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_link_hash_entry {
    pub root: bfd_hash_entry,
    #[bitfield(name = "type_0", ty = "bfd_link_hash_type", bits = "0..=7")]
    #[bitfield(name = "non_ir_ref_regular", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "non_ir_ref_dynamic", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "linker_def", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "ldscript_def", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "rel_from_abs", ty = "libc::c_uint", bits = "12..=12")]
    pub type_0_non_ir_ref_regular_non_ir_ref_dynamic_linker_def_ldscript_def_rel_from_abs: [u8; 2],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 6],
    pub u: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub undef: C2RustUnnamed_12,
    pub def: C2RustUnnamed_11,
    pub i: C2RustUnnamed_10,
    pub c: C2RustUnnamed_9,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub next: *mut bfd_link_hash_entry,
    pub p: *mut bfd_link_hash_common_entry,
    pub size: bfd_size_type,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_hash_common_entry {
    pub alignment_power: libc::c_uint,
    pub section: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub next: *mut bfd_link_hash_entry,
    pub link: *mut bfd_link_hash_entry,
    pub warning: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub next: *mut bfd_link_hash_entry,
    pub section: *mut asection,
    pub value: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub next: *mut bfd_link_hash_entry,
    pub abfd: *mut bfd,
}
pub type bfd_link_hash_type = libc::c_uint;
pub const bfd_link_hash_warning: bfd_link_hash_type = 7;
pub const bfd_link_hash_indirect: bfd_link_hash_type = 6;
pub const bfd_link_hash_common: bfd_link_hash_type = 5;
pub const bfd_link_hash_defweak: bfd_link_hash_type = 4;
pub const bfd_link_hash_defined: bfd_link_hash_type = 3;
pub const bfd_link_hash_undefweak: bfd_link_hash_type = 2;
pub const bfd_link_hash_undefined: bfd_link_hash_type = 1;
pub const bfd_link_hash_new: bfd_link_hash_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_callbacks {
    pub add_archive_element: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *const libc::c_char,
            *mut *mut bfd,
        ) -> bool,
    >,
    pub multiple_definition: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub multiple_common: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd,
            bfd_link_hash_type,
            bfd_vma,
        ) -> (),
    >,
    pub add_to_set: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            bfd_reloc_code_real_type,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub constructor: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            bool,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub warning: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub undefined_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
            bool,
        ) -> (),
    >,
    pub reloc_overflow: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *const libc::c_char,
            *const libc::c_char,
            bfd_vma,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub reloc_dangerous: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub unattached_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub notice: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd_link_hash_entry,
            *mut bfd,
            *mut asection,
            bfd_vma,
            flagword,
        ) -> bool,
    >,
    pub einfo: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub info: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub minfo: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub override_segment_assignment: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *mut asection,
            *mut asection,
            bool,
        ) -> bool,
    >,
    pub examine_strtab: Option::<unsafe extern "C" fn(*mut elf_strtab_hash) -> ()>,
    pub ctf_new_symbol: Option::<
        unsafe extern "C" fn(libc::c_int, *mut elf_internal_sym) -> (),
    >,
    pub ctf_new_dynsym: Option::<
        unsafe extern "C" fn(libc::c_int, *mut elf_internal_sym) -> (),
    >,
    pub emit_ctf: Option::<unsafe extern "C" fn() -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_sym {
    pub st_value: bfd_vma,
    pub st_size: bfd_vma,
    pub st_name: libc::c_ulong,
    pub st_info: libc::c_uchar,
    pub st_other: libc::c_uchar,
    pub st_target_internal: libc::c_uchar,
    pub st_shndx: libc::c_uint,
}
pub type bfd_signed_vma = libc::c_long;
pub type compressed_debug_section_type = libc::c_uint;
pub const COMPRESS_DEBUG_GABI_ZLIB: compressed_debug_section_type = 5;
pub const COMPRESS_DEBUG_GNU_ZLIB: compressed_debug_section_type = 3;
pub const COMPRESS_DEBUG: compressed_debug_section_type = 1;
pub const COMPRESS_DEBUG_NONE: compressed_debug_section_type = 0;
pub type textrel_check_method = libc::c_uint;
pub const textrel_check_error: textrel_check_method = 2;
pub const textrel_check_warning: textrel_check_method = 1;
pub const textrel_check_none: textrel_check_method = 0;
pub type report_method = libc::c_uint;
pub const RM_DIAGNOSE: report_method = 2;
pub const RM_IGNORE: report_method = 1;
pub const RM_NOT_YET_SET: report_method = 0;
pub type bfd_link_common_skip_ar_symbols = libc::c_uint;
pub const bfd_link_common_skip_all: bfd_link_common_skip_ar_symbols = 3;
pub const bfd_link_common_skip_data: bfd_link_common_skip_ar_symbols = 2;
pub const bfd_link_common_skip_text: bfd_link_common_skip_ar_symbols = 1;
pub const bfd_link_common_skip_none: bfd_link_common_skip_ar_symbols = 0;
pub type bfd_link_elf_stt_common = libc::c_uint;
pub const no_elf_stt_common: bfd_link_elf_stt_common = 2;
pub const elf_stt_common: bfd_link_elf_stt_common = 1;
pub const unchanged: bfd_link_elf_stt_common = 0;
pub type bfd_link_discard = libc::c_uint;
pub const discard_all: bfd_link_discard = 3;
pub const discard_l: bfd_link_discard = 2;
pub const discard_none: bfd_link_discard = 1;
pub const discard_sec_merge: bfd_link_discard = 0;
pub type bfd_link_strip = libc::c_uint;
pub const strip_all: bfd_link_strip = 3;
pub const strip_some: bfd_link_strip = 2;
pub const strip_debugger: bfd_link_strip = 1;
pub const strip_none: bfd_link_strip = 0;
pub type output_type = libc::c_uint;
pub const type_dll: output_type = 3;
pub const type_relocatable: output_type = 2;
pub const type_pie: output_type = 1;
pub const type_pde: output_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub after_write_object_contents: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub style: *const libc::c_char,
    pub sec: *mut asection,
}
pub type asymbol = bfd_symbol;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_segment_map {
    pub next: *mut elf_segment_map,
    pub p_type: libc::c_ulong,
    pub p_flags: libc::c_ulong,
    pub p_paddr: bfd_vma,
    pub p_vaddr_offset: bfd_vma,
    pub p_align: bfd_vma,
    pub p_size: bfd_vma,
    #[bitfield(name = "p_flags_valid", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "p_paddr_valid", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "p_align_valid", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "p_size_valid", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "includes_filehdr", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "includes_phdrs", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "no_sort_lma", ty = "libc::c_uint", bits = "6..=6")]
    pub p_flags_valid_p_paddr_valid_p_align_valid_p_size_valid_includes_filehdr_includes_phdrs_no_sort_lma: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
    pub idx: libc::c_uint,
    pub count: libc::c_uint,
    pub sections: [*mut asection; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct core_elf_obj_tdata {
    pub signal: libc::c_int,
    pub pid: libc::c_int,
    pub lwpid: libc::c_int,
    pub program: *mut libc::c_char,
    pub command: *mut libc::c_char,
}
pub type elf_gnu_osabi = libc::c_uint;
pub const elf_gnu_osabi_retain: elf_gnu_osabi = 8;
pub const elf_gnu_osabi_unique: elf_gnu_osabi = 4;
pub const elf_gnu_osabi_ifunc: elf_gnu_osabi = 2;
pub const elf_gnu_osabi_mbind: elf_gnu_osabi = 1;
pub type dynamic_lib_link_class = libc::c_uint;
pub const DYN_NO_NEEDED: dynamic_lib_link_class = 8;
pub const DYN_NO_ADD_NEEDED: dynamic_lib_link_class = 4;
pub const DYN_DT_NEEDED: dynamic_lib_link_class = 2;
pub const DYN_AS_NEEDED: dynamic_lib_link_class = 1;
pub const DYN_NORMAL: dynamic_lib_link_class = 0;
pub type elf_target_id = libc::c_uint;
pub const GENERIC_ELF_DATA: elf_target_id = 38;
pub const RISCV_ELF_DATA: elf_target_id = 37;
pub const TILEPRO_ELF_DATA: elf_target_id = 36;
pub const TILEGX_ELF_DATA: elf_target_id = 35;
pub const XTENSA_ELF_DATA: elf_target_id = 34;
pub const X86_64_ELF_DATA: elf_target_id = 33;
pub const TIC6X_ELF_DATA: elf_target_id = 32;
pub const SPU_ELF_DATA: elf_target_id = 31;
pub const SPARC_ELF_DATA: elf_target_id = 30;
pub const SH_ELF_DATA: elf_target_id = 29;
pub const S390_ELF_DATA: elf_target_id = 28;
pub const PRU_ELF_DATA: elf_target_id = 27;
pub const PPC64_ELF_DATA: elf_target_id = 26;
pub const PPC32_ELF_DATA: elf_target_id = 25;
pub const OR1K_ELF_DATA: elf_target_id = 24;
pub const NIOS2_ELF_DATA: elf_target_id = 23;
pub const NDS32_ELF_DATA: elf_target_id = 22;
pub const MN10300_ELF_DATA: elf_target_id = 21;
pub const MIPS_ELF_DATA: elf_target_id = 20;
pub const MICROBLAZE_ELF_DATA: elf_target_id = 19;
pub const METAG_ELF_DATA: elf_target_id = 18;
pub const M68K_ELF_DATA: elf_target_id = 17;
pub const M68HC11_ELF_DATA: elf_target_id = 16;
pub const M32R_ELF_DATA: elf_target_id = 15;
pub const LM32_ELF_DATA: elf_target_id = 14;
pub const IA64_ELF_DATA: elf_target_id = 13;
pub const I386_ELF_DATA: elf_target_id = 12;
pub const HPPA64_ELF_DATA: elf_target_id = 11;
pub const HPPA32_ELF_DATA: elf_target_id = 10;
pub const FRV_ELF_DATA: elf_target_id = 9;
pub const CSKY_ELF_DATA: elf_target_id = 8;
pub const CRIS_ELF_DATA: elf_target_id = 7;
pub const BFIN_ELF_DATA: elf_target_id = 6;
pub const AVR_ELF_DATA: elf_target_id = 5;
pub const ARM_ELF_DATA: elf_target_id = 4;
pub const ARC_ELF_DATA: elf_target_id = 3;
pub const ALPHA_ELF_DATA: elf_target_id = 2;
pub const AARCH64_ELF_DATA: elf_target_id = 1;
pub type Elf_Internal_Shdr = elf_internal_shdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_shdr {
    pub sh_name: libc::c_uint,
    pub sh_type: libc::c_uint,
    pub sh_flags: bfd_vma,
    pub sh_addr: bfd_vma,
    pub sh_offset: file_ptr,
    pub sh_size: bfd_size_type,
    pub sh_link: libc::c_uint,
    pub sh_info: libc::c_uint,
    pub sh_addralign: bfd_vma,
    pub sh_entsize: bfd_size_type,
    pub bfd_section: *mut asection,
    pub contents: *mut libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sdt_note {
    pub next: *mut sdt_note,
    pub size: bfd_size_type,
    pub data: [bfd_byte; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct obj_attribute_list {
    pub next: *mut obj_attribute_list,
    pub tag: libc::c_uint,
    pub attr: obj_attribute,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct obj_attribute {
    pub type_0: libc::c_int,
    pub i: libc::c_uint,
    pub s: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_property_list {
    pub next: *mut elf_property_list,
    pub property: elf_property,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_property {
    pub pr_type: libc::c_uint,
    pub pr_datasz: libc::c_uint,
    pub u: C2RustUnnamed_14,
    pub pr_kind: elf_property_kind,
}
pub type elf_property_kind = libc::c_uint;
pub const property_number: elf_property_kind = 4;
pub const property_remove: elf_property_kind = 3;
pub const property_corrupt: elf_property_kind = 2;
pub const property_ignored: elf_property_kind = 1;
pub const property_unknown: elf_property_kind = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_14 {
    pub number: bfd_vma,
}
pub type Elf_Internal_Verneed = elf_internal_verneed;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verneed {
    pub vn_version: libc::c_ushort,
    pub vn_cnt: libc::c_ushort,
    pub vn_file: libc::c_ulong,
    pub vn_aux: libc::c_ulong,
    pub vn_next: libc::c_ulong,
    pub vn_bfd: *mut bfd,
    pub vn_filename: *const libc::c_char,
    pub vn_auxptr: *mut elf_internal_vernaux,
    pub vn_nextref: *mut elf_internal_verneed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_vernaux {
    pub vna_hash: libc::c_ulong,
    pub vna_flags: libc::c_ushort,
    pub vna_other: libc::c_ushort,
    pub vna_name: libc::c_ulong,
    pub vna_next: libc::c_ulong,
    pub vna_nodename: *const libc::c_char,
    pub vna_nextptr: *mut elf_internal_vernaux,
}
pub type Elf_Internal_Verdef = elf_internal_verdef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verdef {
    pub vd_version: libc::c_ushort,
    pub vd_flags: libc::c_ushort,
    pub vd_ndx: libc::c_ushort,
    pub vd_cnt: libc::c_ushort,
    pub vd_hash: libc::c_ulong,
    pub vd_aux: libc::c_ulong,
    pub vd_next: libc::c_ulong,
    pub vd_bfd: *mut bfd,
    pub vd_nodename: *const libc::c_char,
    pub vd_nextdef: *mut elf_internal_verdef,
    pub vd_auxptr: *mut elf_internal_verdaux,
    pub vd_exp_refno: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verdaux {
    pub vda_name: libc::c_ulong,
    pub vda_next: libc::c_ulong,
    pub vda_nodename: *const libc::c_char,
    pub vda_nextptr: *mut elf_internal_verdaux,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub refcounts: *mut bfd_signed_vma,
    pub offsets: *mut bfd_vma,
    pub ents: *mut *mut got_entry,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_link_hash_entry {
    pub root: bfd_link_hash_entry,
    pub indx: libc::c_long,
    pub dynindx: libc::c_long,
    pub got: gotplt_union,
    pub plt: gotplt_union,
    pub size: bfd_size_type,
    pub dyn_relocs: *mut elf_dyn_relocs,
    #[bitfield(name = "type_0", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "other", ty = "libc::c_uint", bits = "8..=15")]
    #[bitfield(name = "target_internal", ty = "libc::c_uint", bits = "16..=23")]
    #[bitfield(name = "ref_regular", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "def_regular", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "ref_dynamic", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "def_dynamic", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "ref_regular_nonweak", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "ref_ir_nonweak", ty = "libc::c_uint", bits = "29..=29")]
    #[bitfield(name = "dynamic_adjusted", ty = "libc::c_uint", bits = "30..=30")]
    #[bitfield(name = "needs_copy", ty = "libc::c_uint", bits = "31..=31")]
    #[bitfield(name = "needs_plt", ty = "libc::c_uint", bits = "32..=32")]
    #[bitfield(name = "non_elf", ty = "libc::c_uint", bits = "33..=33")]
    #[bitfield(name = "versioned", ty = "elf_symbol_version", bits = "34..=35")]
    #[bitfield(name = "forced_local", ty = "libc::c_uint", bits = "36..=36")]
    #[bitfield(name = "dynamic", ty = "libc::c_uint", bits = "37..=37")]
    #[bitfield(name = "mark", ty = "libc::c_uint", bits = "38..=38")]
    #[bitfield(name = "non_got_ref", ty = "libc::c_uint", bits = "39..=39")]
    #[bitfield(name = "dynamic_def", ty = "libc::c_uint", bits = "40..=40")]
    #[bitfield(name = "ref_dynamic_nonweak", ty = "libc::c_uint", bits = "41..=41")]
    #[bitfield(name = "pointer_equality_needed", ty = "libc::c_uint", bits = "42..=42")]
    #[bitfield(name = "unique_global", ty = "libc::c_uint", bits = "43..=43")]
    #[bitfield(name = "protected_def", ty = "libc::c_uint", bits = "44..=44")]
    #[bitfield(name = "start_stop", ty = "libc::c_uint", bits = "45..=45")]
    #[bitfield(name = "is_weakalias", ty = "libc::c_uint", bits = "46..=46")]
    pub type_0_other_target_internal_ref_regular_def_regular_ref_dynamic_def_dynamic_ref_regular_nonweak_ref_ir_nonweak_dynamic_adjusted_needs_copy_needs_plt_non_elf_versioned_forced_local_dynamic_mark_non_got_ref_dynamic_def_ref_dynamic_nonweak_pointer_equality_needed_unique_global_protected_def_start_stop_is_weakalias: [u8; 6],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 2],
    pub dynstr_index: libc::c_ulong,
    pub u: C2RustUnnamed_18,
    pub verinfo: C2RustUnnamed_17,
    pub u2: C2RustUnnamed_16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_16 {
    pub start_stop_section: *mut asection,
    pub vtable: *mut elf_link_virtual_table_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_virtual_table_entry {
    pub size: size_t,
    pub used: *mut bool,
    pub parent: *mut elf_link_hash_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_17 {
    pub verdef: *mut Elf_Internal_Verdef,
    pub vertree: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_18 {
    pub alias: *mut elf_link_hash_entry,
    pub elf_hash_value: libc::c_ulong,
}
pub type elf_symbol_version = libc::c_uint;
pub const versioned_hidden: elf_symbol_version = 3;
pub const versioned: elf_symbol_version = 2;
pub const unversioned: elf_symbol_version = 1;
pub const unknown: elf_symbol_version = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_dyn_relocs {
    pub next: *mut elf_dyn_relocs,
    pub sec: *mut asection,
    pub count: bfd_size_type,
    pub pc_count: bfd_size_type,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union gotplt_union {
    pub refcount: bfd_signed_vma,
    pub offset: bfd_vma,
    pub glist: *mut got_entry,
    pub plist: *mut plt_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_section_list {
    pub hdr: Elf_Internal_Shdr,
    pub ndx: libc::c_uint,
    pub next: *mut elf_section_list,
}
pub type Elf_Internal_Phdr = elf_internal_phdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_phdr {
    pub p_type: libc::c_ulong,
    pub p_flags: libc::c_ulong,
    pub p_offset: bfd_vma,
    pub p_vaddr: bfd_vma,
    pub p_paddr: bfd_vma,
    pub p_filesz: bfd_vma,
    pub p_memsz: bfd_vma,
    pub p_align: bfd_vma,
}
pub type Elf_Internal_Ehdr = elf_internal_ehdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_ehdr {
    pub e_ident: [libc::c_uchar; 16],
    pub e_entry: bfd_vma,
    pub e_phoff: bfd_size_type,
    pub e_shoff: bfd_size_type,
    pub e_version: libc::c_ulong,
    pub e_flags: libc::c_ulong,
    pub e_type: libc::c_ushort,
    pub e_machine: libc::c_ushort,
    pub e_ehsize: libc::c_uint,
    pub e_phentsize: libc::c_uint,
    pub e_phnum: libc::c_uint,
    pub e_shentsize: libc::c_uint,
    pub e_shnum: libc::c_uint,
    pub e_shstrndx: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct artdata {
    pub first_file_filepos: file_ptr,
    pub cache: htab_t,
    pub archive_head: *mut bfd,
    pub symdefs: *mut carsym,
    pub symdef_count: symindex,
    pub extended_names: *mut libc::c_char,
    pub extended_names_size: bfd_size_type,
    pub armap_timestamp: libc::c_long,
    pub armap_datepos: file_ptr,
    pub tdata: *mut libc::c_void,
}
pub type symindex = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct carsym {
    pub name: *const libc::c_char,
    pub file_offset: file_ptr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_19 {
    pub next: *mut bfd,
    pub hash: *mut bfd_link_hash_table,
}
pub type ufile_ptr = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_arch_info {
    pub bits_per_word: libc::c_int,
    pub bits_per_address: libc::c_int,
    pub bits_per_byte: libc::c_int,
    pub arch: bfd_architecture,
    pub mach: libc::c_ulong,
    pub arch_name: *const libc::c_char,
    pub printable_name: *const libc::c_char,
    pub section_align_power: libc::c_uint,
    pub the_default: bool,
    pub compatible: Option::<
        unsafe extern "C" fn(
            *const bfd_arch_info,
            *const bfd_arch_info,
        ) -> *const bfd_arch_info,
    >,
    pub scan: Option::<
        unsafe extern "C" fn(*const bfd_arch_info, *const libc::c_char) -> bool,
    >,
    pub fill: Option::<
        unsafe extern "C" fn(bfd_size_type, bool, bool) -> *mut libc::c_void,
    >,
    pub next: *const bfd_arch_info,
    pub max_reloc_offset_into_insn: libc::c_int,
}
pub type bfd_architecture = libc::c_uint;
pub const bfd_arch_last: bfd_architecture = 88;
pub const bfd_arch_csky: bfd_architecture = 87;
pub const bfd_arch_nfp: bfd_architecture = 86;
pub const bfd_arch_pru: bfd_architecture = 85;
pub const bfd_arch_wasm32: bfd_architecture = 84;
pub const bfd_arch_visium: bfd_architecture = 83;
pub const bfd_arch_nios2: bfd_architecture = 82;
pub const bfd_arch_aarch64: bfd_architecture = 81;
pub const bfd_arch_tilegx: bfd_architecture = 80;
pub const bfd_arch_tilepro: bfd_architecture = 79;
pub const bfd_arch_microblaze: bfd_architecture = 78;
pub const bfd_arch_lm32: bfd_architecture = 77;
pub const bfd_arch_z80: bfd_architecture = 76;
pub const bfd_arch_xtensa: bfd_architecture = 75;
pub const bfd_arch_xgate: bfd_architecture = 74;
pub const bfd_arch_xc16x: bfd_architecture = 73;
pub const bfd_arch_msp430: bfd_architecture = 72;
pub const bfd_arch_xstormy16: bfd_architecture = 71;
pub const bfd_arch_mmix: bfd_architecture = 70;
pub const bfd_arch_score: bfd_architecture = 69;
pub const bfd_arch_s390: bfd_architecture = 68;
pub const bfd_arch_rx: bfd_architecture = 67;
pub const bfd_arch_rl78: bfd_architecture = 66;
pub const bfd_arch_riscv: bfd_architecture = 65;
pub const bfd_arch_cris: bfd_architecture = 64;
pub const bfd_arch_crx: bfd_architecture = 63;
pub const bfd_arch_cr16: bfd_architecture = 62;
pub const bfd_arch_bfin: bfd_architecture = 61;
pub const bfd_arch_avr: bfd_architecture = 60;
pub const bfd_arch_pj: bfd_architecture = 59;
pub const bfd_arch_mt: bfd_architecture = 58;
pub const bfd_arch_epiphany: bfd_architecture = 57;
pub const bfd_arch_bpf: bfd_architecture = 56;
pub const bfd_arch_iq2000: bfd_architecture = 55;
pub const bfd_arch_ip2k: bfd_architecture = 54;
pub const bfd_arch_ia64: bfd_architecture = 53;
pub const bfd_arch_metag: bfd_architecture = 52;
pub const bfd_arch_mep: bfd_architecture = 51;
pub const bfd_arch_mcore: bfd_architecture = 50;
pub const bfd_arch_ft32: bfd_architecture = 49;
pub const bfd_arch_moxie: bfd_architecture = 48;
pub const bfd_arch_frv: bfd_architecture = 47;
pub const bfd_arch_fr30: bfd_architecture = 46;
pub const bfd_arch_mn10300: bfd_architecture = 45;
pub const bfd_arch_mn10200: bfd_architecture = 44;
pub const bfd_arch_m32r: bfd_architecture = 43;
pub const bfd_arch_m32c: bfd_architecture = 42;
pub const bfd_arch_arc: bfd_architecture = 41;
pub const bfd_arch_v850_rh850: bfd_architecture = 40;
pub const bfd_arch_v850: bfd_architecture = 39;
pub const bfd_arch_tic6x: bfd_architecture = 38;
pub const bfd_arch_tic54x: bfd_architecture = 37;
pub const bfd_arch_tic4x: bfd_architecture = 36;
pub const bfd_arch_tic30: bfd_architecture = 35;
pub const bfd_arch_ns32k: bfd_architecture = 34;
pub const bfd_arch_nds32: bfd_architecture = 33;
pub const bfd_arch_arm: bfd_architecture = 32;
pub const bfd_arch_alpha: bfd_architecture = 31;
pub const bfd_arch_sh: bfd_architecture = 30;
pub const bfd_arch_z8k: bfd_architecture = 29;
pub const bfd_arch_s12z: bfd_architecture = 28;
pub const bfd_arch_m9s12xg: bfd_architecture = 27;
pub const bfd_arch_m9s12x: bfd_architecture = 26;
pub const bfd_arch_m68hc12: bfd_architecture = 25;
pub const bfd_arch_m68hc11: bfd_architecture = 24;
pub const bfd_arch_dlx: bfd_architecture = 23;
pub const bfd_arch_d30v: bfd_architecture = 22;
pub const bfd_arch_d10v: bfd_architecture = 21;
pub const bfd_arch_hppa: bfd_architecture = 20;
pub const bfd_arch_rs6000: bfd_architecture = 19;
pub const bfd_arch_powerpc: bfd_architecture = 18;
pub const bfd_arch_pdp11: bfd_architecture = 17;
pub const bfd_arch_h8300: bfd_architecture = 16;
pub const bfd_arch_pyramid: bfd_architecture = 15;
pub const bfd_arch_m98k: bfd_architecture = 14;
pub const bfd_arch_convex: bfd_architecture = 13;
pub const bfd_arch_romp: bfd_architecture = 12;
pub const bfd_arch_iamcu: bfd_architecture = 11;
pub const bfd_arch_k1om: bfd_architecture = 10;
pub const bfd_arch_l1om: bfd_architecture = 9;
pub const bfd_arch_i386: bfd_architecture = 8;
pub const bfd_arch_mips: bfd_architecture = 7;
pub const bfd_arch_spu: bfd_architecture = 6;
pub const bfd_arch_sparc: bfd_architecture = 5;
pub const bfd_arch_or1k: bfd_architecture = 4;
pub const bfd_arch_vax: bfd_architecture = 3;
pub const bfd_arch_m68k: bfd_architecture = 2;
pub const bfd_arch_obscure: bfd_architecture = 1;
pub const bfd_arch_unknown: bfd_architecture = 0;
pub type bfd_plugin_format = libc::c_uint;
pub const bfd_plugin_no: bfd_plugin_format = 2;
pub const bfd_plugin_yes: bfd_plugin_format = 1;
pub const bfd_plugin_unknown: bfd_plugin_format = 0;
pub type bfd_direction = libc::c_uint;
pub const both_direction: bfd_direction = 3;
pub const write_direction: bfd_direction = 2;
pub const read_direction: bfd_direction = 1;
pub const no_direction: bfd_direction = 0;
pub type bfd_format = libc::c_uint;
pub const bfd_type_end: bfd_format = 4;
pub const bfd_core: bfd_format = 3;
pub const bfd_archive: bfd_format = 2;
pub const bfd_object: bfd_format = 1;
pub const bfd_unknown: bfd_format = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_iovec {
    pub bread: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void, file_ptr) -> file_ptr,
    >,
    pub bwrite: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_void, file_ptr) -> file_ptr,
    >,
    pub btell: Option::<unsafe extern "C" fn(*mut bfd) -> file_ptr>,
    pub bseek: Option::<
        unsafe extern "C" fn(*mut bfd, file_ptr, libc::c_int) -> libc::c_int,
    >,
    pub bclose: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub bflush: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub bstat: Option::<unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int>,
    pub bmmap: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            bfd_size_type,
            libc::c_int,
            libc::c_int,
            file_ptr,
            *mut *mut libc::c_void,
            *mut bfd_size_type,
        ) -> *mut libc::c_void,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_target {
    pub name: *const libc::c_char,
    pub flavour: bfd_flavour,
    pub byteorder: bfd_endian,
    pub header_byteorder: bfd_endian,
    pub object_flags: flagword,
    pub section_flags: flagword,
    pub symbol_leading_char: libc::c_char,
    pub ar_pad_char: libc::c_char,
    pub ar_max_namelen: libc::c_uchar,
    pub match_priority: libc::c_uchar,
    pub keep_unused_section_symbols: bool,
    pub bfd_getx64: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t>,
    pub bfd_getx_signed_64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
    >,
    pub bfd_putx64: Option::<
        unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
    >,
    pub bfd_getx32: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_getx_signed_32: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_putx32: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_getx16: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_getx_signed_16: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_putx16: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_h_getx64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
    >,
    pub bfd_h_getx_signed_64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
    >,
    pub bfd_h_putx64: Option::<
        unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
    >,
    pub bfd_h_getx32: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_h_getx_signed_32: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_h_putx32: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_h_getx16: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_h_getx_signed_16: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_h_putx16: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub _bfd_check_format: [Option::<unsafe extern "C" fn(*mut bfd) -> bfd_cleanup>; 4],
    pub _bfd_set_format: [Option::<unsafe extern "C" fn(*mut bfd) -> bool>; 4],
    pub _bfd_write_contents: [Option::<unsafe extern "C" fn(*mut bfd) -> bool>; 4],
    pub _close_and_cleanup: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_free_cached_info: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _new_section_hook: Option::<unsafe extern "C" fn(*mut bfd, sec_ptr) -> bool>,
    pub _bfd_get_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut libc::c_void,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_get_section_contents_in_window: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut bfd_window,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_copy_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _bfd_merge_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_init_private_section_data: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut bfd,
            sec_ptr,
            *mut bfd_link_info,
        ) -> bool,
    >,
    pub _bfd_copy_private_section_data: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr, *mut bfd, sec_ptr) -> bool,
    >,
    pub _bfd_copy_private_symbol_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol, *mut bfd, *mut asymbol) -> bool,
    >,
    pub _bfd_copy_private_header_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _bfd_set_private_flags: Option::<
        unsafe extern "C" fn(*mut bfd, flagword) -> bool,
    >,
    pub _bfd_print_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
    >,
    pub _core_file_failing_command: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
    >,
    pub _core_file_failing_signal: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_int,
    >,
    pub _core_file_matches_executable_p: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _core_file_pid: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub _bfd_slurp_armap: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_slurp_extended_name_table: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_construct_extended_name_table: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut libc::c_char,
            *mut bfd_size_type,
            *mut *const libc::c_char,
        ) -> bool,
    >,
    pub _bfd_truncate_arname: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char, *mut libc::c_char) -> (),
    >,
    pub write_armap: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_uint,
            *mut orl,
            libc::c_uint,
            libc::c_int,
        ) -> bool,
    >,
    pub _bfd_read_ar_hdr_fn: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
    >,
    pub _bfd_write_ar_hdr_fn: Option::<unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool>,
    pub openr_next_archived_file: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
    >,
    pub _bfd_get_elt_at_index: Option::<
        unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
    >,
    pub _bfd_stat_arch_elt: Option::<
        unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
    >,
    pub _bfd_update_armap_timestamp: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_get_symtab_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_symtab: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut bfd_symbol) -> libc::c_long,
    >,
    pub _bfd_make_empty_symbol: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut bfd_symbol,
    >,
    pub _bfd_print_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            *mut bfd_symbol,
            bfd_print_symbol_type,
        ) -> (),
    >,
    pub _bfd_get_symbol_info: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_symbol, *mut symbol_info) -> (),
    >,
    pub _bfd_get_symbol_version_string: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_symbol,
            bool,
            *mut bool,
        ) -> *const libc::c_char,
    >,
    pub _bfd_is_local_label_name: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
    >,
    pub _bfd_is_target_special_symbol: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
    >,
    pub _get_lineno: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_symbol) -> *mut alent,
    >,
    pub _bfd_find_nearest_line: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut bfd_symbol,
            *mut bfd_section,
            bfd_vma,
            *mut *const libc::c_char,
            *mut *const libc::c_char,
            *mut libc::c_uint,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_find_line: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut bfd_symbol,
            *mut bfd_symbol,
            *mut *const libc::c_char,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_find_inliner_info: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *const libc::c_char,
            *mut *const libc::c_char,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_make_debug_symbol: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void, libc::c_ulong) -> *mut asymbol,
    >,
    pub _read_minisymbols: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bool,
            *mut *mut libc::c_void,
            *mut libc::c_uint,
        ) -> libc::c_long,
    >,
    pub _minisymbol_to_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bool,
            *const libc::c_void,
            *mut asymbol,
        ) -> *mut asymbol,
    >,
    pub _get_reloc_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
    >,
    pub _bfd_canonicalize_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut *mut arelent,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub _bfd_set_reloc: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr, *mut *mut arelent, libc::c_uint) -> (),
    >,
    pub reloc_type_lookup: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bfd_reloc_code_real_type,
        ) -> *const reloc_howto_type,
    >,
    pub reloc_name_lookup: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> *const reloc_howto_type,
    >,
    pub _bfd_set_arch_mach: Option::<
        unsafe extern "C" fn(*mut bfd, bfd_architecture, libc::c_ulong) -> bool,
    >,
    pub _bfd_set_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *const libc::c_void,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_sizeof_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
    >,
    pub _bfd_get_relocated_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_order,
            *mut bfd_byte,
            bool,
            *mut *mut bfd_symbol,
        ) -> *mut bfd_byte,
    >,
    pub _bfd_relax_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_section,
            *mut bfd_link_info,
            *mut bool,
        ) -> bool,
    >,
    pub _bfd_link_hash_table_create: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
    >,
    pub _bfd_link_add_symbols: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_link_just_syms: Option::<
        unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
    >,
    pub _bfd_copy_link_hash_symbol_type: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_hash_entry,
            *mut bfd_link_hash_entry,
        ) -> (),
    >,
    pub _bfd_final_link: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_link_split_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
    >,
    pub _bfd_link_check_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_gc_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_lookup_section_flags: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut flag_info, *mut asection) -> bool,
    >,
    pub _bfd_merge_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_is_group_section: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
    >,
    pub _bfd_group_name: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_section) -> *const libc::c_char,
    >,
    pub _bfd_discard_group: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
    >,
    pub _section_already_linked: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_define_common_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
        ) -> bool,
    >,
    pub _bfd_link_hide_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
        ) -> (),
    >,
    pub _bfd_define_start_stop: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut asection,
        ) -> *mut bfd_link_hash_entry,
    >,
    pub _bfd_get_dynamic_symtab_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_dynamic_symtab: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut bfd_symbol) -> libc::c_long,
    >,
    pub _bfd_get_synthetic_symtab: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_long,
            *mut *mut bfd_symbol,
            libc::c_long,
            *mut *mut bfd_symbol,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub _bfd_get_dynamic_reloc_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_dynamic_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut arelent,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub alternative_target: *const bfd_target,
    pub backend_data: *const libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct flag_info {
    pub only_with_flags: flagword,
    pub not_with_flags: flagword,
    pub flag_list: *mut flag_info_list,
    pub flags_initialized: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct flag_info_list {
    pub with: flag_type,
    pub name: *const libc::c_char,
    pub valid: bool,
    pub next: *mut flag_info_list,
}
pub type flag_type = libc::c_uint;
pub const without_flags: flag_type = 1;
pub const with_flags: flag_type = 0;
pub type sec_ptr = *mut bfd_section;
pub type symbol_info = _symbol_info;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _symbol_info {
    pub value: symvalue,
    pub type_0: libc::c_char,
    pub name: *const libc::c_char,
    pub stab_type: libc::c_uchar,
    pub stab_other: libc::c_char,
    pub stab_desc: libc::c_short,
    pub stab_name: *const libc::c_char,
}
pub type bfd_print_symbol_type = bfd_print_symbol;
pub type bfd_print_symbol = libc::c_uint;
pub const bfd_print_symbol_all: bfd_print_symbol = 2;
pub const bfd_print_symbol_more: bfd_print_symbol = 1;
pub const bfd_print_symbol_name: bfd_print_symbol = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct orl {
    pub name: *mut *mut libc::c_char,
    pub u: C2RustUnnamed_20,
    pub namidx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_20 {
    pub pos: file_ptr,
    pub abfd: *mut bfd,
}
pub type bfd_window = _bfd_window;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _bfd_window {
    pub data: *mut libc::c_void,
    pub size: bfd_size_type,
    pub i: *mut _bfd_window_internal,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct _bfd_window_internal {
    pub next: *mut _bfd_window_internal,
    pub data: *mut libc::c_void,
    pub size: bfd_size_type,
    #[bitfield(name = "refcount", ty = "libc::c_int", bits = "0..=30")]
    #[bitfield(name = "mapped", ty = "libc::c_uint", bits = "31..=31")]
    pub refcount_mapped: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
pub type bfd_cleanup = Option::<unsafe extern "C" fn(*mut bfd) -> ()>;
pub type bfd_endian = libc::c_uint;
pub const BFD_ENDIAN_UNKNOWN: bfd_endian = 2;
pub const BFD_ENDIAN_LITTLE: bfd_endian = 1;
pub const BFD_ENDIAN_BIG: bfd_endian = 0;
pub type bfd_flavour = libc::c_uint;
pub const bfd_target_sym_flavour: bfd_flavour = 20;
pub const bfd_target_pef_xlib_flavour: bfd_flavour = 19;
pub const bfd_target_pef_flavour: bfd_flavour = 18;
pub const bfd_target_mach_o_flavour: bfd_flavour = 17;
pub const bfd_target_mmo_flavour: bfd_flavour = 16;
pub const bfd_target_evax_flavour: bfd_flavour = 15;
pub const bfd_target_ovax_flavour: bfd_flavour = 14;
pub const bfd_target_msdos_flavour: bfd_flavour = 13;
pub const bfd_target_versados_flavour: bfd_flavour = 12;
pub const bfd_target_os9k_flavour: bfd_flavour = 11;
pub const bfd_target_som_flavour: bfd_flavour = 10;
pub const bfd_target_ihex_flavour: bfd_flavour = 9;
pub const bfd_target_verilog_flavour: bfd_flavour = 8;
pub const bfd_target_srec_flavour: bfd_flavour = 7;
pub const bfd_target_tekhex_flavour: bfd_flavour = 6;
pub const bfd_target_elf_flavour: bfd_flavour = 5;
pub const bfd_target_xcoff_flavour: bfd_flavour = 4;
pub const bfd_target_ecoff_flavour: bfd_flavour = 3;
pub const bfd_target_coff_flavour: bfd_flavour = 2;
pub const bfd_target_aout_flavour: bfd_flavour = 1;
pub const bfd_target_unknown_flavour: bfd_flavour = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stab_info {
    pub strings: *mut bfd_strtab_hash,
    pub includes: bfd_hash_table,
    pub stabstr: *mut bfd_section,
}
pub type bfd_error = libc::c_uint;
pub const bfd_error_invalid_error_code: bfd_error = 22;
pub const bfd_error_on_input: bfd_error = 21;
pub const bfd_error_sorry: bfd_error = 20;
pub const bfd_error_file_too_big: bfd_error = 19;
pub const bfd_error_file_truncated: bfd_error = 18;
pub const bfd_error_bad_value: bfd_error = 17;
pub const bfd_error_no_debug_section: bfd_error = 16;
pub const bfd_error_nonrepresentable_section: bfd_error = 15;
pub const bfd_error_no_contents: bfd_error = 14;
pub const bfd_error_file_ambiguously_recognized: bfd_error = 13;
pub const bfd_error_file_not_recognized: bfd_error = 12;
pub const bfd_error_missing_dso: bfd_error = 11;
pub const bfd_error_malformed_archive: bfd_error = 10;
pub const bfd_error_no_more_archived_files: bfd_error = 9;
pub const bfd_error_no_armap: bfd_error = 8;
pub const bfd_error_no_symbols: bfd_error = 7;
pub const bfd_error_no_memory: bfd_error = 6;
pub const bfd_error_invalid_operation: bfd_error = 5;
pub const bfd_error_wrong_object_format: bfd_error = 4;
pub const bfd_error_wrong_format: bfd_error = 3;
pub const bfd_error_invalid_target: bfd_error = 2;
pub const bfd_error_system_call: bfd_error = 1;
pub const bfd_error_no_error: bfd_error = 0;
pub type bfd_error_type = bfd_error;
pub type notice_asneeded_action = libc::c_uint;
pub const notice_needed: notice_asneeded_action = 2;
pub const notice_not_needed: notice_asneeded_action = 1;
pub const notice_as_needed: notice_asneeded_action = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Sym {
    pub st_name: [libc::c_uchar; 4],
    pub st_value: [libc::c_uchar; 4],
    pub st_size: [libc::c_uchar; 4],
    pub st_info: [libc::c_uchar; 1],
    pub st_other: [libc::c_uchar; 1],
    pub st_shndx: [libc::c_uchar; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Rel {
    pub r_offset: [libc::c_uchar; 4],
    pub r_info: [libc::c_uchar; 4],
}
pub type Elf_Internal_Sym = elf_internal_sym;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_note {
    pub namesz: libc::c_ulong,
    pub descsz: libc::c_ulong,
    pub type_0: libc::c_ulong,
    pub namedata: *mut libc::c_char,
    pub descdata: *mut libc::c_char,
    pub descpos: bfd_vma,
}
pub type Elf_Internal_Note = elf_internal_note;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_rela {
    pub r_offset: bfd_vma,
    pub r_info: bfd_vma,
    pub r_addend: bfd_vma,
}
pub type Elf_Internal_Rela = elf_internal_rela;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_dyn {
    pub d_tag: bfd_vma,
    pub d_un: C2RustUnnamed_21,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_21 {
    pub d_val: bfd_vma,
    pub d_ptr: bfd_vma,
}
pub type Elf_Internal_Dyn = elf_internal_dyn;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_symbol_type {
    pub symbol: asymbol,
    pub internal_elf_sym: Elf_Internal_Sym,
    pub tc_data: C2RustUnnamed_22,
    pub version: libc::c_ushort,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_22 {
    pub hppa_arg_reloc: libc::c_uint,
    pub mips_extr: *mut libc::c_void,
    pub any: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_local_dynamic_entry {
    pub next: *mut elf_link_local_dynamic_entry,
    pub input_bfd: *mut bfd,
    pub input_indx: libc::c_long,
    pub dynindx: libc::c_long,
    pub isym: Elf_Internal_Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_loaded_list {
    pub next: *mut elf_link_loaded_list,
    pub abfd: *mut bfd,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct eh_cie_fde {
    pub u: C2RustUnnamed_23,
    pub reloc_index: libc::c_uint,
    pub size: libc::c_uint,
    pub offset: libc::c_uint,
    pub new_offset: libc::c_uint,
    #[bitfield(name = "fde_encoding", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "lsda_encoding", ty = "libc::c_uint", bits = "8..=15")]
    #[bitfield(name = "lsda_offset", ty = "libc::c_uint", bits = "16..=23")]
    #[bitfield(name = "cie", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "removed", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "add_augmentation_size", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "make_relative", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "pad1", ty = "libc::c_uint", bits = "28..=31")]
    pub fde_encoding_lsda_encoding_lsda_offset_cie_removed_add_augmentation_size_make_relative_pad1: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
    pub set_loc: *mut libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_23 {
    pub fde: C2RustUnnamed_26,
    pub cie: C2RustUnnamed_24,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_24 {
    pub u: C2RustUnnamed_25,
    #[bitfield(name = "personality_offset", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "aug_str_len", ty = "libc::c_uint", bits = "8..=10")]
    #[bitfield(name = "aug_data_len", ty = "libc::c_uint", bits = "11..=15")]
    #[bitfield(name = "gc_mark", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "make_lsda_relative", ty = "libc::c_uint", bits = "17..=17")]
    #[bitfield(name = "make_per_encoding_relative", ty = "libc::c_uint", bits = "18..=18")]
    #[bitfield(name = "per_encoding_relative", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "per_encoding_aligned8", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "add_fde_encoding", ty = "libc::c_uint", bits = "21..=21")]
    #[bitfield(name = "merged", ty = "libc::c_uint", bits = "22..=22")]
    #[bitfield(name = "pad1", ty = "libc::c_uint", bits = "23..=31")]
    pub personality_offset_aug_str_len_aug_data_len_gc_mark_make_lsda_relative_make_per_encoding_relative_per_encoding_relative_per_encoding_aligned8_add_fde_encoding_merged_pad1: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_25 {
    pub full_cie: *mut cie,
    pub merged_with: *mut eh_cie_fde,
    pub sec: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_26 {
    pub cie_inf: *mut eh_cie_fde,
    pub next_for_section: *mut eh_cie_fde,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct eh_frame_array_ent {
    pub initial_loc: bfd_vma,
    pub range: bfd_size_type,
    pub fde: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_eh_frame_hdr_info {
    pub cies: *mut htab,
    pub fde_count: libc::c_uint,
    pub table: bool,
    pub array: *mut eh_frame_array_ent,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct compact_eh_frame_hdr_info {
    pub allocated_entries: libc::c_uint,
    pub entries: *mut *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct eh_frame_hdr_info {
    pub hdr_sec: *mut asection,
    pub array_count: libc::c_uint,
    pub frame_hdr_is_compact: bool,
    pub u: C2RustUnnamed_27,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_27 {
    pub dwarf: dwarf_eh_frame_hdr_info,
    pub compact: compact_eh_frame_hdr_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_sym_strtab {
    pub sym: Elf_Internal_Sym,
    pub dest_index: libc::c_ulong,
    pub destshndx_index: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_needed_list {
    pub next: *mut bfd_link_needed_list,
    pub by: *mut bfd,
    pub name: *const libc::c_char,
}
pub type elf_target_os = libc::c_uint;
pub const is_nacl: elf_target_os = 3;
pub const is_vxworks: elf_target_os = 2;
pub const is_solaris: elf_target_os = 1;
pub const is_normal: elf_target_os = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sym_cache {
    pub abfd: *mut bfd,
    pub indx: [libc::c_ulong; 32],
    pub sym: [Elf_Internal_Sym; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_hash_table {
    pub root: bfd_link_hash_table,
    pub hash_table_id: elf_target_id,
    pub dynamic_sections_created: bool,
    pub dynamic_relocs: bool,
    pub is_relocatable_executable: bool,
    pub ifunc_resolvers: bool,
    pub dt_pltgot_required: bool,
    pub dt_jmprel_required: bool,
    pub dynobj: *mut bfd,
    pub init_got_refcount: gotplt_union,
    pub init_plt_refcount: gotplt_union,
    pub init_got_offset: gotplt_union,
    pub init_plt_offset: gotplt_union,
    pub dynsymcount: bfd_size_type,
    pub local_dynsymcount: bfd_size_type,
    pub dynstr: *mut elf_strtab_hash,
    pub strtabcount: bfd_size_type,
    pub strtabsize: bfd_size_type,
    pub strtab: *mut elf_sym_strtab,
    pub bucketcount: bfd_size_type,
    pub needed: *mut bfd_link_needed_list,
    pub text_index_section: *mut asection,
    pub data_index_section: *mut asection,
    pub hgot: *mut elf_link_hash_entry,
    pub hplt: *mut elf_link_hash_entry,
    pub hdynamic: *mut elf_link_hash_entry,
    pub merge_info: *mut libc::c_void,
    pub stab_info: stab_info,
    pub eh_info: eh_frame_hdr_info,
    pub dynlocal: *mut elf_link_local_dynamic_entry,
    pub runpath: *mut bfd_link_needed_list,
    pub tls_sec: *mut asection,
    pub tls_size: bfd_size_type,
    pub tlsdesc_plt: bfd_vma,
    pub tlsdesc_got: bfd_vma,
    pub target_os: elf_target_os,
    pub dyn_loaded: *mut elf_link_loaded_list,
    pub sym_cache: sym_cache,
    pub sgot: *mut asection,
    pub sgotplt: *mut asection,
    pub srelgot: *mut asection,
    pub splt: *mut asection,
    pub srelplt: *mut asection,
    pub sdynbss: *mut asection,
    pub srelbss: *mut asection,
    pub sdynrelro: *mut asection,
    pub sreldynrelro: *mut asection,
    pub igotplt: *mut asection,
    pub iplt: *mut asection,
    pub irelplt: *mut asection,
    pub irelifunc: *mut asection,
    pub dynsym: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_size_info {
    pub sizeof_ehdr: libc::c_uchar,
    pub sizeof_phdr: libc::c_uchar,
    pub sizeof_shdr: libc::c_uchar,
    pub sizeof_rel: libc::c_uchar,
    pub sizeof_rela: libc::c_uchar,
    pub sizeof_sym: libc::c_uchar,
    pub sizeof_dyn: libc::c_uchar,
    pub sizeof_note: libc::c_uchar,
    pub sizeof_hash_entry: libc::c_uchar,
    pub int_rels_per_ext_rel: libc::c_uchar,
    pub arch_size: libc::c_uchar,
    pub log_file_align: libc::c_uchar,
    pub elfclass: libc::c_uchar,
    pub ev_current: libc::c_uchar,
    pub write_out_phdrs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const Elf_Internal_Phdr,
            libc::c_uint,
        ) -> libc::c_int,
    >,
    pub write_shdrs_and_ehdr: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub checksum_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    size_t,
                    *mut libc::c_void,
                ) -> (),
            >,
            *mut libc::c_void,
        ) -> bool,
    >,
    pub write_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_void) -> (),
    >,
    pub swap_symbol_in: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const libc::c_void,
            *const libc::c_void,
            *mut Elf_Internal_Sym,
        ) -> bool,
    >,
    pub swap_symbol_out: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const Elf_Internal_Sym,
            *mut libc::c_void,
            *mut libc::c_void,
        ) -> (),
    >,
    pub slurp_reloc_table: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut *mut asymbol, bool) -> bool,
    >,
    pub slurp_symbol_table: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut asymbol, bool) -> libc::c_long,
    >,
    pub swap_dyn_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_void, *mut Elf_Internal_Dyn) -> (),
    >,
    pub swap_dyn_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Dyn, *mut libc::c_void) -> (),
    >,
    pub swap_reloc_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    >,
    pub swap_reloc_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    >,
    pub swap_reloca_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    >,
    pub swap_reloca_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    >,
}
pub type elf_reloc_type_class = libc::c_uint;
pub const reloc_class_plt: elf_reloc_type_class = 4;
pub const reloc_class_ifunc: elf_reloc_type_class = 3;
pub const reloc_class_copy: elf_reloc_type_class = 2;
pub const reloc_class_relative: elf_reloc_type_class = 1;
pub const reloc_class_normal: elf_reloc_type_class = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_reloc_cookie {
    pub rels: *mut Elf_Internal_Rela,
    pub rel: *mut Elf_Internal_Rela,
    pub relend: *mut Elf_Internal_Rela,
    pub locsyms: *mut Elf_Internal_Sym,
    pub abfd: *mut bfd,
    pub locsymcount: size_t,
    pub extsymoff: size_t,
    pub sym_hashes: *mut *mut elf_link_hash_entry,
    pub r_sym_shift: libc::c_int,
    pub bad_symtab: bool,
}
pub type irix_compat_t = libc::c_uint;
pub const ict_irix6: irix_compat_t = 2;
pub const ict_irix5: irix_compat_t = 1;
pub const ict_none: irix_compat_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_special_section {
    pub prefix: *const libc::c_char,
    pub prefix_length: libc::c_uint,
    pub suffix_length: libc::c_int,
    pub type_0: libc::c_uint,
    pub attr: bfd_vma,
}
pub type elf_gc_mark_hook_fn = Option::<
    unsafe extern "C" fn(
        *mut asection,
        *mut bfd_link_info,
        *mut Elf_Internal_Rela,
        *mut elf_link_hash_entry,
        *mut Elf_Internal_Sym,
    ) -> *mut asection,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_section_reloc_data {
    pub hdr: *mut Elf_Internal_Shdr,
    pub count: libc::c_uint,
    pub idx: libc::c_int,
    pub hashes: *mut *mut elf_link_hash_entry,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_backend_data {
    pub arch: bfd_architecture,
    pub target_id: elf_target_id,
    pub target_os: elf_target_os,
    pub elf_machine_code: libc::c_int,
    pub elf_osabi: libc::c_int,
    pub maxpagesize: bfd_vma,
    pub minpagesize: bfd_vma,
    pub commonpagesize: bfd_vma,
    pub relropagesize: bfd_vma,
    pub dynamic_sec_flags: flagword,
    pub arch_data: *const libc::c_void,
    pub elf_info_to_howto: Option::<
        unsafe extern "C" fn(*mut bfd, *mut arelent, *mut Elf_Internal_Rela) -> bool,
    >,
    pub elf_info_to_howto_rel: Option::<
        unsafe extern "C" fn(*mut bfd, *mut arelent, *mut Elf_Internal_Rela) -> bool,
    >,
    pub elf_backend_sym_is_global: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
    >,
    pub elf_backend_object_p: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub elf_backend_symbol_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> (),
    >,
    pub elf_backend_symbol_table_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_symbol_type, libc::c_uint) -> bool,
    >,
    pub elf_backend_get_symbol_type: Option::<
        unsafe extern "C" fn(*mut Elf_Internal_Sym, libc::c_int) -> libc::c_int,
    >,
    pub elf_backend_archive_symbol_lookup: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *const libc::c_char,
        ) -> *mut bfd_link_hash_entry,
    >,
    pub elf_backend_name_local_section_symbols: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_section_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Shdr) -> bool,
    >,
    pub elf_backend_section_from_shdr: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Shdr,
            *const libc::c_char,
            libc::c_int,
        ) -> bool,
    >,
    pub elf_backend_section_flags: Option::<
        unsafe extern "C" fn(*const Elf_Internal_Shdr) -> bool,
    >,
    pub get_sec_type_attr: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection) -> *const bfd_elf_special_section,
    >,
    pub elf_backend_section_from_phdr: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Phdr,
            libc::c_int,
            *const libc::c_char,
        ) -> bool,
    >,
    pub elf_backend_fake_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Shdr, *mut asection) -> bool,
    >,
    pub elf_backend_section_from_bfd_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_int) -> bool,
    >,
    pub elf_add_symbol_hook: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut Elf_Internal_Sym,
            *mut *const libc::c_char,
            *mut flagword,
            *mut *mut asection,
            *mut bfd_vma,
        ) -> bool,
    >,
    pub elf_backend_link_output_symbol_hook: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut Elf_Internal_Sym,
            *mut asection,
            *mut elf_link_hash_entry,
        ) -> libc::c_int,
    >,
    pub elf_backend_create_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_omit_section_dynsym: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub relocs_compatible: Option::<
        unsafe extern "C" fn(*const bfd_target, *const bfd_target) -> bool,
    >,
    pub check_relocs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            *const Elf_Internal_Rela,
        ) -> bool,
    >,
    pub check_directives: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub notice_as_needed: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            notice_asneeded_action,
        ) -> bool,
    >,
    pub elf_backend_adjust_dynamic_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_always_size_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_size_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_strip_zero_sized_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> bool,
    >,
    pub elf_backend_init_index_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
    >,
    pub elf_backend_relocate_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd,
            *mut asection,
            *mut bfd_byte,
            *mut Elf_Internal_Rela,
            *mut Elf_Internal_Sym,
            *mut *mut asection,
        ) -> libc::c_int,
    >,
    pub elf_backend_finish_dynamic_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut Elf_Internal_Sym,
        ) -> bool,
    >,
    pub elf_backend_finish_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_begin_write_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
    >,
    pub elf_backend_final_write_processing: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_additional_program_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
    >,
    pub elf_backend_modify_segment_map: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_modify_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_allow_non_load_phdr: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Phdr, libc::c_uint) -> bool,
    >,
    pub gc_keep: Option::<unsafe extern "C" fn(*mut bfd_link_info) -> ()>,
    pub gc_mark_dynamic_ref: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, *mut libc::c_void) -> bool,
    >,
    pub gc_mark_hook: elf_gc_mark_hook_fn,
    pub gc_mark_extra_sections: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, elf_gc_mark_hook_fn) -> bool,
    >,
    pub elf_backend_init_file_header: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_print_symbol_all: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            *mut asymbol,
        ) -> *const libc::c_char,
    >,
    pub elf_backend_output_arch_local_syms: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const libc::c_char,
                    *mut Elf_Internal_Sym,
                    *mut asection,
                    *mut elf_link_hash_entry,
                ) -> libc::c_int,
            >,
        ) -> bool,
    >,
    pub elf_backend_output_arch_syms: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const libc::c_char,
                    *mut Elf_Internal_Sym,
                    *mut asection,
                    *mut elf_link_hash_entry,
                ) -> libc::c_int,
            >,
        ) -> bool,
    >,
    pub elf_backend_filter_implib_symbols: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut *mut asymbol,
            libc::c_long,
        ) -> libc::c_uint,
    >,
    pub elf_backend_copy_indirect_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut elf_link_hash_entry,
        ) -> (),
    >,
    pub elf_backend_hide_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry, bool) -> (),
    >,
    pub elf_backend_fixup_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_merge_symbol_attribute: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, libc::c_uint, bool, bool) -> (),
    >,
    pub elf_backend_get_target_dtag: Option::<
        unsafe extern "C" fn(bfd_vma) -> *mut libc::c_char,
    >,
    pub elf_backend_ignore_undef_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_emit_relocs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut asection,
            *mut Elf_Internal_Shdr,
            *mut Elf_Internal_Rela,
            *mut *mut elf_link_hash_entry,
        ) -> bool,
    >,
    pub elf_backend_update_relocs: Option::<
        unsafe extern "C" fn(*mut asection, *mut bfd_elf_section_reloc_data) -> (),
    >,
    pub elf_backend_count_relocs: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut asection) -> libc::c_uint,
    >,
    pub elf_backend_count_additional_relocs: Option::<
        unsafe extern "C" fn(*mut asection) -> libc::c_uint,
    >,
    pub sort_relocs_p: Option::<unsafe extern "C" fn(*mut asection) -> bool>,
    pub elf_backend_grok_prstatus: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_grok_psinfo: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_grok_freebsd_prstatus: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_write_core_note: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_char,
            *mut libc::c_int,
            libc::c_int,
            ...
        ) -> *mut libc::c_char,
    >,
    pub elf_backend_lookup_section_flags_hook: Option::<
        unsafe extern "C" fn(*mut libc::c_char) -> flagword,
    >,
    pub elf_backend_reloc_type_class: Option::<
        unsafe extern "C" fn(
            *const bfd_link_info,
            *const asection,
            *const Elf_Internal_Rela,
        ) -> elf_reloc_type_class,
    >,
    pub elf_backend_discard_info: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_reloc_cookie, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_ignore_discarded_relocs: Option::<
        unsafe extern "C" fn(*mut asection) -> bool,
    >,
    pub action_discarded: Option::<unsafe extern "C" fn(*mut asection) -> libc::c_uint>,
    pub elf_backend_eh_frame_address_size: Option::<
        unsafe extern "C" fn(*mut bfd, *const asection) -> libc::c_uint,
    >,
    pub elf_backend_can_make_relative_eh_frame: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub elf_backend_can_make_lsda_relative_eh_frame: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub elf_backend_encode_eh_address: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            bfd_vma,
            *mut asection,
            bfd_vma,
            *mut bfd_vma,
        ) -> bfd_byte,
    >,
    pub elf_backend_write_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            *mut bfd_byte,
        ) -> bool,
    >,
    pub elf_backend_elfsym_local_is_section: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_mips_irix_compat: Option::<
        unsafe extern "C" fn(*mut bfd) -> irix_compat_t,
    >,
    pub elf_backend_mips_rtype_to_howto: Option::<
        unsafe extern "C" fn(*mut bfd, libc::c_uint, bool) -> *const reloc_howto_type,
    >,
    pub elf_backend_ecoff_debug_swap: *const ecoff_debug_swap,
    pub elf_backend_bfd_from_remote_memory: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bfd_vma,
            bfd_size_type,
            *mut bfd_vma,
            Option::<
                unsafe extern "C" fn(
                    bfd_vma,
                    *mut bfd_byte,
                    bfd_size_type,
                ) -> libc::c_int,
            >,
        ) -> *mut bfd,
    >,
    pub elf_backend_core_find_build_id: Option::<
        unsafe extern "C" fn(*mut bfd, bfd_vma) -> bool,
    >,
    pub plt_sym_val: Option::<
        unsafe extern "C" fn(bfd_vma, *const asection, *const arelent) -> bfd_vma,
    >,
    pub common_definition: Option::<unsafe extern "C" fn(*mut Elf_Internal_Sym) -> bool>,
    pub common_section_index: Option::<
        unsafe extern "C" fn(*mut asection) -> libc::c_uint,
    >,
    pub common_section: Option::<unsafe extern "C" fn(*mut asection) -> *mut asection>,
    pub merge_symbol: Option::<
        unsafe extern "C" fn(
            *mut elf_link_hash_entry,
            *const Elf_Internal_Sym,
            *mut *mut asection,
            bool,
            bool,
            *mut bfd,
            *const asection,
        ) -> bool,
    >,
    pub elf_hash_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
    >,
    pub record_xhash_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, bfd_vma) -> (),
    >,
    pub is_function_type: Option::<unsafe extern "C" fn(libc::c_uint) -> bool>,
    pub maybe_function_sym: Option::<
        unsafe extern "C" fn(
            *const asymbol,
            *mut asection,
            *mut bfd_vma,
        ) -> bfd_size_type,
    >,
    pub get_reloc_section: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> *mut asection,
    >,
    pub elf_backend_copy_special_section_fields: Option::<
        unsafe extern "C" fn(
            *const bfd,
            *mut bfd,
            *const Elf_Internal_Shdr,
            *mut Elf_Internal_Shdr,
        ) -> bool,
    >,
    pub link_order_error_handler: Option::<
        unsafe extern "C" fn(*const libc::c_char, ...) -> (),
    >,
    pub relplt_name: *const libc::c_char,
    pub elf_machine_alt1: libc::c_int,
    pub elf_machine_alt2: libc::c_int,
    pub s: *const elf_size_info,
    pub special_sections: *const bfd_elf_special_section,
    pub got_header_size: bfd_vma,
    pub got_elt_size: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut bfd,
            libc::c_ulong,
        ) -> bfd_vma,
    >,
    pub obj_attrs_vendor: *const libc::c_char,
    pub obj_attrs_section: *const libc::c_char,
    pub obj_attrs_arg_type: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub obj_attrs_section_type: libc::c_uint,
    pub obj_attrs_order: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub obj_attrs_handle_unknown: Option::<
        unsafe extern "C" fn(*mut bfd, libc::c_int) -> bool,
    >,
    pub parse_gnu_properties: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_uint,
            *mut bfd_byte,
            libc::c_uint,
        ) -> elf_property_kind,
    >,
    pub merge_gnu_properties: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *mut bfd,
            *mut elf_property,
            *mut elf_property,
        ) -> bool,
    >,
    pub setup_gnu_properties: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> *mut bfd,
    >,
    pub fixup_gnu_properties: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut *mut elf_property_list) -> (),
    >,
    pub compact_eh_encoding: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> libc::c_int,
    >,
    pub cant_unwind_opcode: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> libc::c_int,
    >,
    pub symbol_section_index: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_symbol_type) -> libc::c_uint,
    >,
    pub init_secondary_reloc_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Shdr,
            *const libc::c_char,
            libc::c_uint,
        ) -> bool,
    >,
    pub slurp_secondary_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut *mut asymbol, bool) -> bool,
    >,
    pub write_secondary_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
    >,
    pub static_tls_alignment: libc::c_uint,
    pub stack_align: libc::c_uint,
    pub elf_strtab_flags: libc::c_ulong,
    #[bitfield(name = "collect", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "type_change_ok", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "may_use_rel_p", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "may_use_rela_p", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "default_use_rela_p", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "rela_plts_and_copies_p", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "rela_normal", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "dtrel_excludes_plt", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "sign_extend_vma", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "want_got_plt", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "plt_readonly", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "want_plt_sym", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "plt_not_loaded", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "plt_alignment", ty = "libc::c_uint", bits = "13..=16")]
    #[bitfield(name = "can_gc_sections", ty = "libc::c_uint", bits = "17..=17")]
    #[bitfield(name = "can_refcount", ty = "libc::c_uint", bits = "18..=18")]
    #[bitfield(name = "want_got_sym", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "want_dynbss", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "want_dynrelro", ty = "libc::c_uint", bits = "21..=21")]
    #[bitfield(name = "want_p_paddr_set_to_zero", ty = "libc::c_uint", bits = "22..=22")]
    #[bitfield(name = "no_page_alias", ty = "libc::c_uint", bits = "23..=23")]
    #[bitfield(name = "default_execstack", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "caches_rawsize", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "extern_protected_data", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "always_renumber_dynsyms", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "linux_prpsinfo32_ugid16", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "linux_prpsinfo64_ugid16", ty = "libc::c_uint", bits = "29..=29")]
    pub collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_section_data {
    pub this_hdr: Elf_Internal_Shdr,
    pub section_flag_info: *mut flag_info,
    pub rel: bfd_elf_section_reloc_data,
    pub rela: bfd_elf_section_reloc_data,
    pub this_idx: libc::c_int,
    pub dynindx: libc::c_int,
    pub linked_to: *mut asection,
    pub relocs: *mut Elf_Internal_Rela,
    pub local_dynrel: *mut libc::c_void,
    pub sreloc: *mut asection,
    pub group: C2RustUnnamed_28,
    pub sec_group: *mut asection,
    pub next_in_group: *mut asection,
    pub fde_list: *mut eh_cie_fde,
    pub eh_frame_entry: *mut asection,
    pub has_secondary_relocs: bool,
    pub sec_info: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_28 {
    pub name: *const libc::c_char,
    pub id: *mut bfd_symbol,
}
pub type elf_x86_prop_report = libc::c_uint;
pub const prop_report_shstk: elf_x86_prop_report = 8;
pub const prop_report_ibt: elf_x86_prop_report = 4;
pub const prop_report_error: elf_x86_prop_report = 2;
pub const prop_report_warning: elf_x86_prop_report = 1;
pub const prop_report_none: elf_x86_prop_report = 0;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_linker_x86_params {
    #[bitfield(name = "bndplt", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "ibtplt", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "ibt", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "shstk", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "lam_u48", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "lam_u57", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "no_reloc_overflow_check", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "call_nop_as_suffix", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "static_before_all_inputs", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "has_dynamic_linker", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "report_relative_reloc", ty = "libc::c_uint", bits = "10..=10")]
    pub bndplt_ibtplt_ibt_shstk_lam_u48_lam_u57_no_reloc_overflow_check_call_nop_as_suffix_static_before_all_inputs_has_dynamic_linker_report_relative_reloc: [u8; 2],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 2],
    pub isa_level: libc::c_uint,
    pub cet_report: elf_x86_prop_report,
    pub lam_u48_report: elf_x86_prop_report,
    pub lam_u57_report: elf_x86_prop_report,
    pub call_nop_byte: libc::c_char,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_x86_link_hash_entry {
    pub elf: elf_link_hash_entry,
    pub tls_type: libc::c_uchar,
    #[bitfield(name = "zero_undefweak", ty = "libc::c_uint", bits = "0..=1")]
    #[bitfield(name = "no_finish_dynamic_symbol", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "tls_get_addr", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "def_protected", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "local_ref", ty = "libc::c_uint", bits = "5..=6")]
    #[bitfield(name = "linker_def", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "gotoff_ref", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "needs_copy", ty = "libc::c_uint", bits = "9..=9")]
    pub zero_undefweak_no_finish_dynamic_symbol_tls_get_addr_def_protected_local_ref_linker_def_gotoff_ref_needs_copy: [u8; 2],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 5],
    pub plt_got: gotplt_union,
    pub plt_second: gotplt_union,
    pub tlsdesc_got: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_x86_lazy_plt_layout {
    pub plt0_entry: *const bfd_byte,
    pub plt0_entry_size: libc::c_uint,
    pub plt_entry: *const bfd_byte,
    pub plt_entry_size: libc::c_uint,
    pub plt_tlsdesc_entry: *const bfd_byte,
    pub plt_tlsdesc_entry_size: libc::c_uint,
    pub plt_tlsdesc_got1_offset: libc::c_uint,
    pub plt_tlsdesc_got2_offset: libc::c_uint,
    pub plt_tlsdesc_got1_insn_end: libc::c_uint,
    pub plt_tlsdesc_got2_insn_end: libc::c_uint,
    pub plt0_got1_offset: libc::c_uint,
    pub plt0_got2_offset: libc::c_uint,
    pub plt0_got2_insn_end: libc::c_uint,
    pub plt_got_offset: libc::c_uint,
    pub plt_reloc_offset: libc::c_uint,
    pub plt_plt_offset: libc::c_uint,
    pub plt_got_insn_size: libc::c_uint,
    pub plt_plt_insn_end: libc::c_uint,
    pub plt_lazy_offset: libc::c_uint,
    pub pic_plt0_entry: *const bfd_byte,
    pub pic_plt_entry: *const bfd_byte,
    pub eh_frame_plt: *const bfd_byte,
    pub eh_frame_plt_size: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_x86_non_lazy_plt_layout {
    pub plt_entry: *const bfd_byte,
    pub pic_plt_entry: *const bfd_byte,
    pub plt_entry_size: libc::c_uint,
    pub plt_got_offset: libc::c_uint,
    pub plt_got_insn_size: libc::c_uint,
    pub eh_frame_plt: *const bfd_byte,
    pub eh_frame_plt_size: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_x86_plt_layout {
    pub plt0_entry: *const bfd_byte,
    pub plt_entry: *const bfd_byte,
    pub plt_entry_size: libc::c_uint,
    pub has_plt0: libc::c_uint,
    pub plt_got_offset: libc::c_uint,
    pub plt_got_insn_size: libc::c_uint,
    pub iplt_alignment: libc::c_uint,
    pub eh_frame_plt: *const bfd_byte,
    pub eh_frame_plt_size: libc::c_uint,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_x86_link_hash_table {
    pub elf: elf_link_hash_table,
    pub interp: *mut asection,
    pub plt_eh_frame: *mut asection,
    pub plt_second: *mut asection,
    pub plt_second_eh_frame: *mut asection,
    pub plt_got: *mut asection,
    pub plt_got_eh_frame: *mut asection,
    pub plt: elf_x86_plt_layout,
    pub lazy_plt: *const elf_x86_lazy_plt_layout,
    pub non_lazy_plt: *const elf_x86_non_lazy_plt_layout,
    pub tls_ld_or_ldm_got: C2RustUnnamed_29,
    pub sgotplt_jump_table_size: bfd_vma,
    pub tls_module_base: *mut bfd_link_hash_entry,
    pub loc_hash_table: htab_t,
    pub loc_hash_memory: *mut libc::c_void,
    pub next_jump_slot_index: bfd_vma,
    pub next_irelative_index: bfd_vma,
    pub srelplt2: *mut asection,
    pub next_tls_desc_index: bfd_vma,
    pub plt0_pad_byte: bfd_byte,
    #[bitfield(name = "got_referenced", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "pcrel_plt", ty = "libc::c_uint", bits = "1..=1")]
    pub got_referenced_pcrel_plt: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 6],
    pub r_info: Option::<unsafe extern "C" fn(bfd_vma, bfd_vma) -> bfd_vma>,
    pub r_sym: Option::<unsafe extern "C" fn(bfd_vma) -> bfd_vma>,
    pub is_reloc_section: Option::<unsafe extern "C" fn(*const libc::c_char) -> bool>,
    pub sizeof_reloc: libc::c_uint,
    pub got_entry_size: libc::c_uint,
    pub pointer_r_type: libc::c_uint,
    pub dynamic_interpreter_size: libc::c_int,
    pub dynamic_interpreter: *const libc::c_char,
    pub tls_get_addr: *const libc::c_char,
    pub params: *mut elf_linker_x86_params,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_29 {
    pub refcount: bfd_signed_vma,
    pub offset: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_x86_init_table {
    pub lazy_plt: *const elf_x86_lazy_plt_layout,
    pub non_lazy_plt: *const elf_x86_non_lazy_plt_layout,
    pub lazy_ibt_plt: *const elf_x86_lazy_plt_layout,
    pub non_lazy_ibt_plt: *const elf_x86_non_lazy_plt_layout,
    pub plt0_pad_byte: bfd_byte,
    pub r_info: Option::<unsafe extern "C" fn(bfd_vma, bfd_vma) -> bfd_vma>,
    pub r_sym: Option::<unsafe extern "C" fn(bfd_vma) -> bfd_vma>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_x86_obj_tdata {
    pub root: elf_obj_tdata,
    pub local_got_tls_type: *mut libc::c_char,
    pub local_tlsdesc_gotent: *mut bfd_vma,
}
pub type elf_x86_plt_type = libc::c_int;
pub const plt_unknown: elf_x86_plt_type = -1;
pub const plt_second: elf_x86_plt_type = 4;
pub const plt_pic: elf_x86_plt_type = 2;
pub const plt_lazy: elf_x86_plt_type = 1;
pub const plt_non_lazy: elf_x86_plt_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_x86_plt {
    pub name: *const libc::c_char,
    pub sec: *mut asection,
    pub contents: *mut bfd_byte,
    pub type_0: elf_x86_plt_type,
    pub plt_got_offset: libc::c_uint,
    pub plt_entry_size: libc::c_uint,
    pub plt_got_insn_size: libc::c_uint,
    pub count: libc::c_long,
}
pub type dwarf_location_atom = libc::c_uint;
pub const DW_OP_AARCH64_operation: dwarf_location_atom = 234;
pub const DW_OP_PGI_omp_thread_num: dwarf_location_atom = 248;
pub const DW_OP_HP_tls: dwarf_location_atom = 230;
pub const DW_OP_HP_unmod_range: dwarf_location_atom = 229;
pub const DW_OP_HP_mod_range: dwarf_location_atom = 228;
pub const DW_OP_HP_fltconst8: dwarf_location_atom = 227;
pub const DW_OP_HP_fltconst4: dwarf_location_atom = 226;
pub const DW_OP_HP_is_value: dwarf_location_atom = 225;
pub const DW_OP_HP_unknown: dwarf_location_atom = 224;
pub const DW_OP_GNU_variable_value: dwarf_location_atom = 253;
pub const DW_OP_GNU_const_index: dwarf_location_atom = 252;
pub const DW_OP_GNU_addr_index: dwarf_location_atom = 251;
pub const DW_OP_GNU_parameter_ref: dwarf_location_atom = 250;
pub const DW_OP_GNU_reinterpret: dwarf_location_atom = 249;
pub const DW_OP_GNU_convert: dwarf_location_atom = 247;
pub const DW_OP_GNU_deref_type: dwarf_location_atom = 246;
pub const DW_OP_GNU_regval_type: dwarf_location_atom = 245;
pub const DW_OP_GNU_const_type: dwarf_location_atom = 244;
pub const DW_OP_GNU_entry_value: dwarf_location_atom = 243;
pub const DW_OP_GNU_implicit_pointer: dwarf_location_atom = 242;
pub const DW_OP_GNU_encoded_addr: dwarf_location_atom = 241;
pub const DW_OP_GNU_uninit: dwarf_location_atom = 240;
pub const DW_OP_GNU_push_tls_address: dwarf_location_atom = 224;
pub const DW_OP_hi_user: dwarf_location_atom = 255;
pub const DW_OP_lo_user: dwarf_location_atom = 224;
pub const DW_OP_reinterpret: dwarf_location_atom = 169;
pub const DW_OP_convert: dwarf_location_atom = 168;
pub const DW_OP_xderef_type: dwarf_location_atom = 167;
pub const DW_OP_deref_type: dwarf_location_atom = 166;
pub const DW_OP_regval_type: dwarf_location_atom = 165;
pub const DW_OP_const_type: dwarf_location_atom = 164;
pub const DW_OP_entry_value: dwarf_location_atom = 163;
pub const DW_OP_constx: dwarf_location_atom = 162;
pub const DW_OP_addrx: dwarf_location_atom = 161;
pub const DW_OP_implicit_pointer: dwarf_location_atom = 160;
pub const DW_OP_stack_value: dwarf_location_atom = 159;
pub const DW_OP_implicit_value: dwarf_location_atom = 158;
pub const DW_OP_bit_piece: dwarf_location_atom = 157;
pub const DW_OP_call_frame_cfa: dwarf_location_atom = 156;
pub const DW_OP_form_tls_address: dwarf_location_atom = 155;
pub const DW_OP_call_ref: dwarf_location_atom = 154;
pub const DW_OP_call4: dwarf_location_atom = 153;
pub const DW_OP_call2: dwarf_location_atom = 152;
pub const DW_OP_push_object_address: dwarf_location_atom = 151;
pub const DW_OP_nop: dwarf_location_atom = 150;
pub const DW_OP_xderef_size: dwarf_location_atom = 149;
pub const DW_OP_deref_size: dwarf_location_atom = 148;
pub const DW_OP_piece: dwarf_location_atom = 147;
pub const DW_OP_bregx: dwarf_location_atom = 146;
pub const DW_OP_fbreg: dwarf_location_atom = 145;
pub const DW_OP_regx: dwarf_location_atom = 144;
pub const DW_OP_breg31: dwarf_location_atom = 143;
pub const DW_OP_breg30: dwarf_location_atom = 142;
pub const DW_OP_breg29: dwarf_location_atom = 141;
pub const DW_OP_breg28: dwarf_location_atom = 140;
pub const DW_OP_breg27: dwarf_location_atom = 139;
pub const DW_OP_breg26: dwarf_location_atom = 138;
pub const DW_OP_breg25: dwarf_location_atom = 137;
pub const DW_OP_breg24: dwarf_location_atom = 136;
pub const DW_OP_breg23: dwarf_location_atom = 135;
pub const DW_OP_breg22: dwarf_location_atom = 134;
pub const DW_OP_breg21: dwarf_location_atom = 133;
pub const DW_OP_breg20: dwarf_location_atom = 132;
pub const DW_OP_breg19: dwarf_location_atom = 131;
pub const DW_OP_breg18: dwarf_location_atom = 130;
pub const DW_OP_breg17: dwarf_location_atom = 129;
pub const DW_OP_breg16: dwarf_location_atom = 128;
pub const DW_OP_breg15: dwarf_location_atom = 127;
pub const DW_OP_breg14: dwarf_location_atom = 126;
pub const DW_OP_breg13: dwarf_location_atom = 125;
pub const DW_OP_breg12: dwarf_location_atom = 124;
pub const DW_OP_breg11: dwarf_location_atom = 123;
pub const DW_OP_breg10: dwarf_location_atom = 122;
pub const DW_OP_breg9: dwarf_location_atom = 121;
pub const DW_OP_breg8: dwarf_location_atom = 120;
pub const DW_OP_breg7: dwarf_location_atom = 119;
pub const DW_OP_breg6: dwarf_location_atom = 118;
pub const DW_OP_breg5: dwarf_location_atom = 117;
pub const DW_OP_breg4: dwarf_location_atom = 116;
pub const DW_OP_breg3: dwarf_location_atom = 115;
pub const DW_OP_breg2: dwarf_location_atom = 114;
pub const DW_OP_breg1: dwarf_location_atom = 113;
pub const DW_OP_breg0: dwarf_location_atom = 112;
pub const DW_OP_reg31: dwarf_location_atom = 111;
pub const DW_OP_reg30: dwarf_location_atom = 110;
pub const DW_OP_reg29: dwarf_location_atom = 109;
pub const DW_OP_reg28: dwarf_location_atom = 108;
pub const DW_OP_reg27: dwarf_location_atom = 107;
pub const DW_OP_reg26: dwarf_location_atom = 106;
pub const DW_OP_reg25: dwarf_location_atom = 105;
pub const DW_OP_reg24: dwarf_location_atom = 104;
pub const DW_OP_reg23: dwarf_location_atom = 103;
pub const DW_OP_reg22: dwarf_location_atom = 102;
pub const DW_OP_reg21: dwarf_location_atom = 101;
pub const DW_OP_reg20: dwarf_location_atom = 100;
pub const DW_OP_reg19: dwarf_location_atom = 99;
pub const DW_OP_reg18: dwarf_location_atom = 98;
pub const DW_OP_reg17: dwarf_location_atom = 97;
pub const DW_OP_reg16: dwarf_location_atom = 96;
pub const DW_OP_reg15: dwarf_location_atom = 95;
pub const DW_OP_reg14: dwarf_location_atom = 94;
pub const DW_OP_reg13: dwarf_location_atom = 93;
pub const DW_OP_reg12: dwarf_location_atom = 92;
pub const DW_OP_reg11: dwarf_location_atom = 91;
pub const DW_OP_reg10: dwarf_location_atom = 90;
pub const DW_OP_reg9: dwarf_location_atom = 89;
pub const DW_OP_reg8: dwarf_location_atom = 88;
pub const DW_OP_reg7: dwarf_location_atom = 87;
pub const DW_OP_reg6: dwarf_location_atom = 86;
pub const DW_OP_reg5: dwarf_location_atom = 85;
pub const DW_OP_reg4: dwarf_location_atom = 84;
pub const DW_OP_reg3: dwarf_location_atom = 83;
pub const DW_OP_reg2: dwarf_location_atom = 82;
pub const DW_OP_reg1: dwarf_location_atom = 81;
pub const DW_OP_reg0: dwarf_location_atom = 80;
pub const DW_OP_lit31: dwarf_location_atom = 79;
pub const DW_OP_lit30: dwarf_location_atom = 78;
pub const DW_OP_lit29: dwarf_location_atom = 77;
pub const DW_OP_lit28: dwarf_location_atom = 76;
pub const DW_OP_lit27: dwarf_location_atom = 75;
pub const DW_OP_lit26: dwarf_location_atom = 74;
pub const DW_OP_lit25: dwarf_location_atom = 73;
pub const DW_OP_lit24: dwarf_location_atom = 72;
pub const DW_OP_lit23: dwarf_location_atom = 71;
pub const DW_OP_lit22: dwarf_location_atom = 70;
pub const DW_OP_lit21: dwarf_location_atom = 69;
pub const DW_OP_lit20: dwarf_location_atom = 68;
pub const DW_OP_lit19: dwarf_location_atom = 67;
pub const DW_OP_lit18: dwarf_location_atom = 66;
pub const DW_OP_lit17: dwarf_location_atom = 65;
pub const DW_OP_lit16: dwarf_location_atom = 64;
pub const DW_OP_lit15: dwarf_location_atom = 63;
pub const DW_OP_lit14: dwarf_location_atom = 62;
pub const DW_OP_lit13: dwarf_location_atom = 61;
pub const DW_OP_lit12: dwarf_location_atom = 60;
pub const DW_OP_lit11: dwarf_location_atom = 59;
pub const DW_OP_lit10: dwarf_location_atom = 58;
pub const DW_OP_lit9: dwarf_location_atom = 57;
pub const DW_OP_lit8: dwarf_location_atom = 56;
pub const DW_OP_lit7: dwarf_location_atom = 55;
pub const DW_OP_lit6: dwarf_location_atom = 54;
pub const DW_OP_lit5: dwarf_location_atom = 53;
pub const DW_OP_lit4: dwarf_location_atom = 52;
pub const DW_OP_lit3: dwarf_location_atom = 51;
pub const DW_OP_lit2: dwarf_location_atom = 50;
pub const DW_OP_lit1: dwarf_location_atom = 49;
pub const DW_OP_lit0: dwarf_location_atom = 48;
pub const DW_OP_skip: dwarf_location_atom = 47;
pub const DW_OP_ne: dwarf_location_atom = 46;
pub const DW_OP_lt: dwarf_location_atom = 45;
pub const DW_OP_le: dwarf_location_atom = 44;
pub const DW_OP_gt: dwarf_location_atom = 43;
pub const DW_OP_ge: dwarf_location_atom = 42;
pub const DW_OP_eq: dwarf_location_atom = 41;
pub const DW_OP_bra: dwarf_location_atom = 40;
pub const DW_OP_xor: dwarf_location_atom = 39;
pub const DW_OP_shra: dwarf_location_atom = 38;
pub const DW_OP_shr: dwarf_location_atom = 37;
pub const DW_OP_shl: dwarf_location_atom = 36;
pub const DW_OP_plus_uconst: dwarf_location_atom = 35;
pub const DW_OP_plus: dwarf_location_atom = 34;
pub const DW_OP_or: dwarf_location_atom = 33;
pub const DW_OP_not: dwarf_location_atom = 32;
pub const DW_OP_neg: dwarf_location_atom = 31;
pub const DW_OP_mul: dwarf_location_atom = 30;
pub const DW_OP_mod: dwarf_location_atom = 29;
pub const DW_OP_minus: dwarf_location_atom = 28;
pub const DW_OP_div: dwarf_location_atom = 27;
pub const DW_OP_and: dwarf_location_atom = 26;
pub const DW_OP_abs: dwarf_location_atom = 25;
pub const DW_OP_xderef: dwarf_location_atom = 24;
pub const DW_OP_rot: dwarf_location_atom = 23;
pub const DW_OP_swap: dwarf_location_atom = 22;
pub const DW_OP_pick: dwarf_location_atom = 21;
pub const DW_OP_over: dwarf_location_atom = 20;
pub const DW_OP_drop: dwarf_location_atom = 19;
pub const DW_OP_dup: dwarf_location_atom = 18;
pub const DW_OP_consts: dwarf_location_atom = 17;
pub const DW_OP_constu: dwarf_location_atom = 16;
pub const DW_OP_const8s: dwarf_location_atom = 15;
pub const DW_OP_const8u: dwarf_location_atom = 14;
pub const DW_OP_const4s: dwarf_location_atom = 13;
pub const DW_OP_const4u: dwarf_location_atom = 12;
pub const DW_OP_const2s: dwarf_location_atom = 11;
pub const DW_OP_const2u: dwarf_location_atom = 10;
pub const DW_OP_const1s: dwarf_location_atom = 9;
pub const DW_OP_const1u: dwarf_location_atom = 8;
pub const DW_OP_deref: dwarf_location_atom = 6;
pub const DW_OP_addr: dwarf_location_atom = 3;
pub type dwarf_call_frame_info = libc::c_uint;
pub const DW_CFA_GNU_negative_offset_extended: dwarf_call_frame_info = 47;
pub const DW_CFA_GNU_args_size: dwarf_call_frame_info = 46;
pub const DW_CFA_AARCH64_negate_ra_state: dwarf_call_frame_info = 45;
pub const DW_CFA_GNU_window_save: dwarf_call_frame_info = 45;
pub const DW_CFA_MIPS_advance_loc8: dwarf_call_frame_info = 29;
pub const DW_CFA_hi_user: dwarf_call_frame_info = 63;
pub const DW_CFA_lo_user: dwarf_call_frame_info = 28;
pub const DW_CFA_val_expression: dwarf_call_frame_info = 22;
pub const DW_CFA_val_offset_sf: dwarf_call_frame_info = 21;
pub const DW_CFA_val_offset: dwarf_call_frame_info = 20;
pub const DW_CFA_def_cfa_offset_sf: dwarf_call_frame_info = 19;
pub const DW_CFA_def_cfa_sf: dwarf_call_frame_info = 18;
pub const DW_CFA_offset_extended_sf: dwarf_call_frame_info = 17;
pub const DW_CFA_expression: dwarf_call_frame_info = 16;
pub const DW_CFA_def_cfa_expression: dwarf_call_frame_info = 15;
pub const DW_CFA_def_cfa_offset: dwarf_call_frame_info = 14;
pub const DW_CFA_def_cfa_register: dwarf_call_frame_info = 13;
pub const DW_CFA_def_cfa: dwarf_call_frame_info = 12;
pub const DW_CFA_restore_state: dwarf_call_frame_info = 11;
pub const DW_CFA_remember_state: dwarf_call_frame_info = 10;
pub const DW_CFA_register: dwarf_call_frame_info = 9;
pub const DW_CFA_same_value: dwarf_call_frame_info = 8;
pub const DW_CFA_undefined: dwarf_call_frame_info = 7;
pub const DW_CFA_restore_extended: dwarf_call_frame_info = 6;
pub const DW_CFA_offset_extended: dwarf_call_frame_info = 5;
pub const DW_CFA_advance_loc4: dwarf_call_frame_info = 4;
pub const DW_CFA_advance_loc2: dwarf_call_frame_info = 3;
pub const DW_CFA_advance_loc1: dwarf_call_frame_info = 2;
pub const DW_CFA_set_loc: dwarf_call_frame_info = 1;
pub const DW_CFA_nop: dwarf_call_frame_info = 0;
pub const DW_CFA_restore: dwarf_call_frame_info = 192;
pub const DW_CFA_offset: dwarf_call_frame_info = 128;
pub const DW_CFA_advance_loc: dwarf_call_frame_info = 64;
pub type elf_i386_reloc_type = libc::c_uint;
pub const R_386_max: elf_i386_reloc_type = 252;
pub const R_386_GNU_VTENTRY: elf_i386_reloc_type = 251;
pub const R_386_GNU_VTINHERIT: elf_i386_reloc_type = 250;
pub const R_386_USED_BY_INTEL_200: elf_i386_reloc_type = 200;
pub const R_386_GOT32X: elf_i386_reloc_type = 43;
pub const R_386_IRELATIVE: elf_i386_reloc_type = 42;
pub const R_386_TLS_DESC: elf_i386_reloc_type = 41;
pub const R_386_TLS_DESC_CALL: elf_i386_reloc_type = 40;
pub const R_386_TLS_GOTDESC: elf_i386_reloc_type = 39;
pub const R_386_SIZE32: elf_i386_reloc_type = 38;
pub const R_386_TLS_TPOFF32: elf_i386_reloc_type = 37;
pub const R_386_TLS_DTPOFF32: elf_i386_reloc_type = 36;
pub const R_386_TLS_DTPMOD32: elf_i386_reloc_type = 35;
pub const R_386_TLS_LE_32: elf_i386_reloc_type = 34;
pub const R_386_TLS_IE_32: elf_i386_reloc_type = 33;
pub const R_386_TLS_LDO_32: elf_i386_reloc_type = 32;
pub const R_386_TLS_LDM_POP: elf_i386_reloc_type = 31;
pub const R_386_TLS_LDM_CALL: elf_i386_reloc_type = 30;
pub const R_386_TLS_LDM_PUSH: elf_i386_reloc_type = 29;
pub const R_386_TLS_LDM_32: elf_i386_reloc_type = 28;
pub const R_386_TLS_GD_POP: elf_i386_reloc_type = 27;
pub const R_386_TLS_GD_CALL: elf_i386_reloc_type = 26;
pub const R_386_TLS_GD_PUSH: elf_i386_reloc_type = 25;
pub const R_386_TLS_GD_32: elf_i386_reloc_type = 24;
pub const R_386_PC8: elf_i386_reloc_type = 23;
pub const R_386_8: elf_i386_reloc_type = 22;
pub const R_386_PC16: elf_i386_reloc_type = 21;
pub const R_386_16: elf_i386_reloc_type = 20;
pub const R_386_TLS_LDM: elf_i386_reloc_type = 19;
pub const R_386_TLS_GD: elf_i386_reloc_type = 18;
pub const R_386_TLS_LE: elf_i386_reloc_type = 17;
pub const R_386_TLS_GOTIE: elf_i386_reloc_type = 16;
pub const R_386_TLS_IE: elf_i386_reloc_type = 15;
pub const R_386_TLS_TPOFF: elf_i386_reloc_type = 14;
pub const LAST_INVALID_RELOC: elf_i386_reloc_type = 13;
pub const FIRST_INVALID_RELOC: elf_i386_reloc_type = 12;
pub const R_386_32PLT: elf_i386_reloc_type = 11;
pub const R_386_GOTPC: elf_i386_reloc_type = 10;
pub const R_386_GOTOFF: elf_i386_reloc_type = 9;
pub const R_386_RELATIVE: elf_i386_reloc_type = 8;
pub const R_386_JUMP_SLOT: elf_i386_reloc_type = 7;
pub const R_386_GLOB_DAT: elf_i386_reloc_type = 6;
pub const R_386_COPY: elf_i386_reloc_type = 5;
pub const R_386_PLT32: elf_i386_reloc_type = 4;
pub const R_386_GOT32: elf_i386_reloc_type = 3;
pub const R_386_PC32: elf_i386_reloc_type = 2;
pub const R_386_32: elf_i386_reloc_type = 1;
pub const R_386_NONE: elf_i386_reloc_type = 0;
#[inline]
unsafe extern "C" fn bfd_section_name(mut sec: *const asection) -> *const libc::c_char {
    return (*sec).name;
}
#[inline]
unsafe extern "C" fn bfd_is_abs_section(mut sec: *const asection) -> bool {
    return sec
        == &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
            as *mut asection as *const asection;
}
#[inline]
unsafe extern "C" fn discarded_section(mut sec: *const asection) -> bool {
    return !bfd_is_abs_section(sec)
        && bfd_is_abs_section((*sec).output_section) as libc::c_int != 0
        && (*sec).sec_info_type() as libc::c_int != 2 as libc::c_int
        && (*sec).sec_info_type() as libc::c_int != 4 as libc::c_int;
}
#[inline]
unsafe extern "C" fn bfd_get_flavour(mut abfd: *const bfd) -> bfd_flavour {
    return (*(*abfd).xvec).flavour;
}
#[inline]
unsafe extern "C" fn is_elf_hash_table(mut htab: *const bfd_link_hash_table) -> bool {
    return (*htab).type_0 as libc::c_uint
        == bfd_link_elf_hash_table as libc::c_int as libc::c_uint;
}
#[inline]
unsafe extern "C" fn elf_hash_table(
    mut info: *const bfd_link_info,
) -> *mut elf_link_hash_table {
    return (*info).hash as *mut elf_link_hash_table;
}
#[inline]
unsafe extern "C" fn elf_hash_table_id(
    mut table: *const elf_link_hash_table,
) -> elf_target_id {
    return (*table).hash_table_id;
}
static mut elf_howto_table: [reloc_howto_type; 35] = [reloc_howto_type {
    type_0: 0,
    size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
    src_mask: 0,
    dst_mask: 0,
    special_function: None,
    name: 0 as *const libc::c_char,
}; 35];
unsafe extern "C" fn elf_i386_reloc_type_lookup(
    mut abfd: *mut bfd,
    mut code: bfd_reloc_code_real_type,
) -> *const reloc_howto_type {
    match code as libc::c_uint {
        71 => {
            return &*elf_howto_table.as_ptr().offset(R_386_NONE as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        2 => {
            return &*elf_howto_table.as_ptr().offset(R_386_32 as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        599 => {
            return &*elf_howto_table.as_ptr().offset(R_386_32 as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        9 => {
            return &*elf_howto_table.as_ptr().offset(R_386_PC32 as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        356 => {
            return &*elf_howto_table.as_ptr().offset(R_386_GOT32 as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        357 => {
            return &*elf_howto_table.as_ptr().offset(R_386_PLT32 as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        358 => {
            return &*elf_howto_table.as_ptr().offset(R_386_COPY as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        359 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(R_386_GLOB_DAT as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        360 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(R_386_JUMP_SLOT as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        361 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(R_386_RELATIVE as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        362 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(R_386_GOTOFF as libc::c_int as isize) as *const reloc_howto_type;
        }
        363 => {
            return &*elf_howto_table.as_ptr().offset(R_386_GOTPC as libc::c_int as isize)
                as *const reloc_howto_type;
        }
        364 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_TPOFF as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        365 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_IE as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        366 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_GOTIE as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        367 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_LE as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        368 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_GD as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        369 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_LDM as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        5 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_16 as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        11 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_PC16 as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        7 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_8 as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        13 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_PC8 as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))) as isize,
                ) as *const reloc_howto_type;
        }
        370 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_LDO_32 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        371 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_IE_32 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        372 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_LE_32 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        373 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_DTPMOD32 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        374 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_DTPOFF32 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        375 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_TPOFF32 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        36 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_SIZE32 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        376 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_GOTDESC as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        377 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_DESC_CALL as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        378 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_TLS_DESC as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        379 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_IRELATIVE as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        380 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_GOT32X as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        1510 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_GNU_VTINHERIT as libc::c_int
                        - (R_386_GNU_VTINHERIT as libc::c_int
                            - (R_386_GOT32X as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_LDO_32 as libc::c_int
                                    - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                        - (R_386_TLS_TPOFF as libc::c_int
                                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        1511 => {
            return &*elf_howto_table
                .as_ptr()
                .offset(
                    (R_386_GNU_VTENTRY as libc::c_int
                        - (R_386_GNU_VTINHERIT as libc::c_int
                            - (R_386_GOT32X as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_LDO_32 as libc::c_int
                                    - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                        - (R_386_TLS_TPOFF as libc::c_int
                                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))))
                        as isize,
                ) as *const reloc_howto_type;
        }
        _ => {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: unsupported relocation type: %#x\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                code as libc::c_int,
            );
            bfd_set_error(bfd_error_bad_value);
            return 0 as *const reloc_howto_type;
        }
    };
}
unsafe extern "C" fn elf_i386_reloc_name_lookup(
    mut abfd: *mut bfd,
    mut r_name: *const libc::c_char,
) -> *const reloc_howto_type {
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::core::mem::size_of::<[reloc_howto_type; 35]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<reloc_howto_type>() as libc::c_ulong)
    {
        if !(elf_howto_table[i as usize].name).is_null()
            && strcasecmp(elf_howto_table[i as usize].name, r_name) == 0 as libc::c_int
        {
            return &*elf_howto_table.as_ptr().offset(i as isize)
                as *const reloc_howto_type;
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as *const reloc_howto_type;
}
unsafe extern "C" fn elf_i386_rtype_to_howto(
    mut r_type: libc::c_uint,
) -> *const reloc_howto_type {
    let mut indx: libc::c_uint = 0;
    indx = r_type;
    if indx >= (R_386_GOTPC as libc::c_int + 1 as libc::c_int) as libc::c_uint
        && {
            indx = r_type
                .wrapping_sub(
                    (R_386_TLS_TPOFF as libc::c_int
                        - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))
                        as libc::c_uint,
                );
            indx
                .wrapping_sub(
                    (R_386_GOTPC as libc::c_int + 1 as libc::c_int) as libc::c_uint,
                )
                >= (R_386_PC8 as libc::c_int + 1 as libc::c_int
                    - (R_386_TLS_TPOFF as libc::c_int
                        - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))
                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)) as libc::c_uint
        }
        && {
            indx = r_type
                .wrapping_sub(
                    (R_386_TLS_LDO_32 as libc::c_int
                        - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                            - (R_386_TLS_TPOFF as libc::c_int
                                - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))))
                        as libc::c_uint,
                );
            indx
                .wrapping_sub(
                    (R_386_PC8 as libc::c_int + 1 as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))
                        as libc::c_uint,
                )
                >= (R_386_GOT32X as libc::c_int + 1 as libc::c_int
                    - (R_386_TLS_LDO_32 as libc::c_int
                        - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                            - (R_386_TLS_TPOFF as libc::c_int
                                - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))))
                    - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                        - (R_386_TLS_TPOFF as libc::c_int
                            - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))))
                    as libc::c_uint
        }
        && {
            indx = r_type
                .wrapping_sub(
                    (R_386_GNU_VTINHERIT as libc::c_int
                        - (R_386_GOT32X as libc::c_int + 1 as libc::c_int
                            - (R_386_TLS_LDO_32 as libc::c_int
                                - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                    - (R_386_TLS_TPOFF as libc::c_int
                                        - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))))))
                        as libc::c_uint,
                );
            indx
                .wrapping_sub(
                    (R_386_GOT32X as libc::c_int + 1 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int)))))
                        as libc::c_uint,
                )
                >= (R_386_GNU_VTENTRY as libc::c_int + 1 as libc::c_int
                    - (R_386_GNU_VTINHERIT as libc::c_int
                        - (R_386_GOT32X as libc::c_int + 1 as libc::c_int
                            - (R_386_TLS_LDO_32 as libc::c_int
                                - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                    - (R_386_TLS_TPOFF as libc::c_int
                                        - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))))))
                    - (R_386_GOT32X as libc::c_int + 1 as libc::c_int
                        - (R_386_TLS_LDO_32 as libc::c_int
                            - (R_386_PC8 as libc::c_int + 1 as libc::c_int
                                - (R_386_TLS_TPOFF as libc::c_int
                                    - (R_386_GOTPC as libc::c_int + 1 as libc::c_int))))))
                    as libc::c_uint
        }
    {
        return 0 as *const reloc_howto_type;
    }
    if elf_howto_table[indx as usize].type_0 != r_type {
        return 0 as *const reloc_howto_type;
    }
    return &*elf_howto_table.as_ptr().offset(indx as isize) as *const reloc_howto_type;
}
unsafe extern "C" fn elf_i386_info_to_howto_rel(
    mut abfd: *mut bfd,
    mut cache_ptr: *mut arelent,
    mut dst: *mut Elf_Internal_Rela,
) -> bool {
    let mut r_type: libc::c_uint = ((*dst).r_info & 0xff as libc::c_int as libc::c_ulong)
        as libc::c_uint;
    (*cache_ptr).howto = elf_i386_rtype_to_howto(r_type);
    if ((*cache_ptr).howto).is_null() {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: unsupported relocation type %#x\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            r_type,
        );
        bfd_set_error(bfd_error_bad_value);
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_i386_is_local_label_name(
    mut abfd: *mut bfd,
    mut name: *const libc::c_char,
) -> bool {
    if *name.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
        && *name.offset(1 as libc::c_int as isize) as libc::c_int == 'X' as i32
    {
        return 1 as libc::c_int != 0;
    }
    return _bfd_elf_is_local_label_name(abfd, name);
}
unsafe extern "C" fn elf_i386_grok_prstatus(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut offset: libc::c_int = 0;
    let mut size: size_t = 0;
    if (*note).namesz == 8 as libc::c_int as libc::c_ulong
        && strcmp((*note).namedata, b"FreeBSD\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        let mut pr_version: libc::c_int = (Some(
            ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")((*note).descdata as *const libc::c_void)
            as libc::c_int;
        if pr_version != 1 as libc::c_int {
            return 0 as libc::c_int != 0;
        }
        (*(*(*abfd).tdata.elf_obj_data).core)
            .signal = (Some(
            ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(
            ((*note).descdata).offset(20 as libc::c_int as isize) as *const libc::c_void,
        ) as libc::c_int;
        (*(*(*abfd).tdata.elf_obj_data).core)
            .lwpid = (Some(
            ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(
            ((*note).descdata).offset(24 as libc::c_int as isize) as *const libc::c_void,
        ) as libc::c_int;
        offset = 28 as libc::c_int;
        size = (Some(((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(
            ((*note).descdata).offset(8 as libc::c_int as isize) as *const libc::c_void,
        );
    } else {
        match (*note).descsz {
            144 => {
                (*(*(*abfd).tdata.elf_obj_data).core)
                    .signal = (Some(
                    ((*(*abfd).xvec).bfd_getx16).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*note).descdata).offset(12 as libc::c_int as isize)
                        as *const libc::c_void,
                ) as libc::c_int;
                (*(*(*abfd).tdata.elf_obj_data).core)
                    .lwpid = (Some(
                    ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*note).descdata).offset(24 as libc::c_int as isize)
                        as *const libc::c_void,
                ) as libc::c_int;
                offset = 72 as libc::c_int;
                size = 68 as libc::c_int as size_t;
            }
            _ => return 0 as libc::c_int != 0,
        }
    }
    return _bfd_elfcore_make_pseudosection(
        abfd,
        b".reg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        size,
        ((*note).descpos).wrapping_add(offset as libc::c_ulong),
    );
}
unsafe extern "C" fn elf_i386_grok_psinfo(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    if (*note).namesz == 8 as libc::c_int as libc::c_ulong
        && strcmp((*note).namedata, b"FreeBSD\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        let mut pr_version: libc::c_int = (Some(
            ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")((*note).descdata as *const libc::c_void)
            as libc::c_int;
        if pr_version != 1 as libc::c_int {
            return 0 as libc::c_int != 0;
        }
        (*(*(*abfd).tdata.elf_obj_data).core)
            .program = _bfd_elfcore_strndup(
            abfd,
            ((*note).descdata).offset(8 as libc::c_int as isize),
            17 as libc::c_int as size_t,
        );
        (*(*(*abfd).tdata.elf_obj_data).core)
            .command = _bfd_elfcore_strndup(
            abfd,
            ((*note).descdata).offset(25 as libc::c_int as isize),
            81 as libc::c_int as size_t,
        );
    } else {
        match (*note).descsz {
            124 => {
                (*(*(*abfd).tdata.elf_obj_data).core)
                    .pid = (Some(
                    ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*note).descdata).offset(12 as libc::c_int as isize)
                        as *const libc::c_void,
                ) as libc::c_int;
                (*(*(*abfd).tdata.elf_obj_data).core)
                    .program = _bfd_elfcore_strndup(
                    abfd,
                    ((*note).descdata).offset(28 as libc::c_int as isize),
                    16 as libc::c_int as size_t,
                );
                (*(*(*abfd).tdata.elf_obj_data).core)
                    .command = _bfd_elfcore_strndup(
                    abfd,
                    ((*note).descdata).offset(44 as libc::c_int as isize),
                    80 as libc::c_int as size_t,
                );
            }
            _ => return 0 as libc::c_int != 0,
        }
    }
    let mut command: *mut libc::c_char = (*(*(*abfd).tdata.elf_obj_data).core).command;
    let mut n: libc::c_int = strlen(command) as libc::c_int;
    if (0 as libc::c_int) < n
        && *command.offset((n - 1 as libc::c_int) as isize) as libc::c_int == ' ' as i32
    {
        *command.offset((n - 1 as libc::c_int) as isize) = '\0' as i32 as libc::c_char;
    }
    return 1 as libc::c_int != 0;
}
static mut elf_i386_lazy_plt0_entry: [bfd_byte; 12] = [
    0xff as libc::c_int as bfd_byte,
    0x35 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xff as libc::c_int as bfd_byte,
    0x25 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
];
static mut elf_i386_lazy_plt_entry: [bfd_byte; 16] = [
    0xff as libc::c_int as bfd_byte,
    0x25 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0x68 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xe9 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
];
static mut elf_i386_pic_lazy_plt0_entry: [bfd_byte; 12] = [
    0xff as libc::c_int as bfd_byte,
    0xb3 as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xff as libc::c_int as bfd_byte,
    0xa3 as libc::c_int as bfd_byte,
    8 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
];
static mut elf_i386_pic_lazy_plt_entry: [bfd_byte; 16] = [
    0xff as libc::c_int as bfd_byte,
    0xa3 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0x68 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xe9 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
];
static mut elf_i386_non_lazy_plt_entry: [bfd_byte; 8] = [
    0xff as libc::c_int as bfd_byte,
    0x25 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0x66 as libc::c_int as bfd_byte,
    0x90 as libc::c_int as bfd_byte,
];
static mut elf_i386_pic_non_lazy_plt_entry: [bfd_byte; 8] = [
    0xff as libc::c_int as bfd_byte,
    0xa3 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0x66 as libc::c_int as bfd_byte,
    0x90 as libc::c_int as bfd_byte,
];
static mut elf_i386_lazy_ibt_plt0_entry: [bfd_byte; 16] = [
    0xff as libc::c_int as bfd_byte,
    0x35 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xff as libc::c_int as bfd_byte,
    0x25 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xf as libc::c_int as bfd_byte,
    0x1f as libc::c_int as bfd_byte,
    0x40 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
];
static mut elf_i386_lazy_ibt_plt_entry: [bfd_byte; 16] = [
    0xf3 as libc::c_int as bfd_byte,
    0xf as libc::c_int as bfd_byte,
    0x1e as libc::c_int as bfd_byte,
    0xfb as libc::c_int as bfd_byte,
    0x68 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xe9 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0x66 as libc::c_int as bfd_byte,
    0x90 as libc::c_int as bfd_byte,
];
static mut elf_i386_pic_lazy_ibt_plt0_entry: [bfd_byte; 16] = [
    0xff as libc::c_int as bfd_byte,
    0xb3 as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xff as libc::c_int as bfd_byte,
    0xa3 as libc::c_int as bfd_byte,
    8 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0xf as libc::c_int as bfd_byte,
    0x1f as libc::c_int as bfd_byte,
    0x40 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
];
static mut elf_i386_non_lazy_ibt_plt_entry: [bfd_byte; 16] = [
    0xf3 as libc::c_int as bfd_byte,
    0xf as libc::c_int as bfd_byte,
    0x1e as libc::c_int as bfd_byte,
    0xfb as libc::c_int as bfd_byte,
    0xff as libc::c_int as bfd_byte,
    0x25 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0x66 as libc::c_int as bfd_byte,
    0xf as libc::c_int as bfd_byte,
    0x1f as libc::c_int as bfd_byte,
    0x44 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
];
static mut elf_i386_pic_non_lazy_ibt_plt_entry: [bfd_byte; 16] = [
    0xf3 as libc::c_int as bfd_byte,
    0xf as libc::c_int as bfd_byte,
    0x1e as libc::c_int as bfd_byte,
    0xfb as libc::c_int as bfd_byte,
    0xff as libc::c_int as bfd_byte,
    0xa3 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0x66 as libc::c_int as bfd_byte,
    0xf as libc::c_int as bfd_byte,
    0x1f as libc::c_int as bfd_byte,
    0x44 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
];
static mut elf_i386_eh_frame_lazy_plt: [bfd_byte; 64] = [
    20 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    'z' as i32 as bfd_byte,
    'R' as i32 as bfd_byte,
    0 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    0x7c as libc::c_int as bfd_byte,
    8 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    (0x10 as libc::c_int | 0xb as libc::c_int) as bfd_byte,
    DW_CFA_def_cfa as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    (DW_CFA_offset as libc::c_int + 8 as libc::c_int) as bfd_byte,
    1 as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    36 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    (20 as libc::c_int + 8 as libc::c_int) as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    DW_CFA_def_cfa_offset as libc::c_int as bfd_byte,
    8 as libc::c_int as bfd_byte,
    (DW_CFA_advance_loc as libc::c_int + 6 as libc::c_int) as bfd_byte,
    DW_CFA_def_cfa_offset as libc::c_int as bfd_byte,
    12 as libc::c_int as bfd_byte,
    (DW_CFA_advance_loc as libc::c_int + 10 as libc::c_int) as bfd_byte,
    DW_CFA_def_cfa_expression as libc::c_int as bfd_byte,
    11 as libc::c_int as bfd_byte,
    DW_OP_breg4 as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    DW_OP_breg8 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    DW_OP_lit15 as libc::c_int as bfd_byte,
    DW_OP_and as libc::c_int as bfd_byte,
    DW_OP_lit11 as libc::c_int as bfd_byte,
    DW_OP_ge as libc::c_int as bfd_byte,
    DW_OP_lit2 as libc::c_int as bfd_byte,
    DW_OP_shl as libc::c_int as bfd_byte,
    DW_OP_plus as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
];
static mut elf_i386_eh_frame_lazy_ibt_plt: [bfd_byte; 64] = [
    20 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    'z' as i32 as bfd_byte,
    'R' as i32 as bfd_byte,
    0 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    0x7c as libc::c_int as bfd_byte,
    8 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    (0x10 as libc::c_int | 0xb as libc::c_int) as bfd_byte,
    DW_CFA_def_cfa as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    (DW_CFA_offset as libc::c_int + 8 as libc::c_int) as bfd_byte,
    1 as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    36 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    (20 as libc::c_int + 8 as libc::c_int) as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    DW_CFA_def_cfa_offset as libc::c_int as bfd_byte,
    8 as libc::c_int as bfd_byte,
    (DW_CFA_advance_loc as libc::c_int + 6 as libc::c_int) as bfd_byte,
    DW_CFA_def_cfa_offset as libc::c_int as bfd_byte,
    12 as libc::c_int as bfd_byte,
    (DW_CFA_advance_loc as libc::c_int + 10 as libc::c_int) as bfd_byte,
    DW_CFA_def_cfa_expression as libc::c_int as bfd_byte,
    11 as libc::c_int as bfd_byte,
    DW_OP_breg4 as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    DW_OP_breg8 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    DW_OP_lit15 as libc::c_int as bfd_byte,
    DW_OP_and as libc::c_int as bfd_byte,
    DW_OP_lit9 as libc::c_int as bfd_byte,
    DW_OP_ge as libc::c_int as bfd_byte,
    DW_OP_lit2 as libc::c_int as bfd_byte,
    DW_OP_shl as libc::c_int as bfd_byte,
    DW_OP_plus as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
];
static mut elf_i386_eh_frame_non_lazy_plt: [bfd_byte; 44] = [
    20 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    'z' as i32 as bfd_byte,
    'R' as i32 as bfd_byte,
    0 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    0x7c as libc::c_int as bfd_byte,
    8 as libc::c_int as bfd_byte,
    1 as libc::c_int as bfd_byte,
    (0x10 as libc::c_int | 0xb as libc::c_int) as bfd_byte,
    DW_CFA_def_cfa as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    4 as libc::c_int as bfd_byte,
    (DW_CFA_offset as libc::c_int + 8 as libc::c_int) as bfd_byte,
    1 as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    16 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    (20 as libc::c_int + 8 as libc::c_int) as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    0 as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
    DW_CFA_nop as libc::c_int as bfd_byte,
];
static mut elf_i386_lazy_plt: elf_x86_lazy_plt_layout = unsafe {
    {
        let mut init = elf_x86_lazy_plt_layout {
            plt0_entry: elf_i386_lazy_plt0_entry.as_ptr(),
            plt0_entry_size: ::core::mem::size_of::<[bfd_byte; 12]>() as libc::c_ulong
                as libc::c_uint,
            plt_entry: elf_i386_lazy_plt_entry.as_ptr(),
            plt_entry_size: 16 as libc::c_int as libc::c_uint,
            plt_tlsdesc_entry: 0 as *const bfd_byte,
            plt_tlsdesc_entry_size: 0 as libc::c_int as libc::c_uint,
            plt_tlsdesc_got1_offset: 0 as libc::c_int as libc::c_uint,
            plt_tlsdesc_got2_offset: 0 as libc::c_int as libc::c_uint,
            plt_tlsdesc_got1_insn_end: 0 as libc::c_int as libc::c_uint,
            plt_tlsdesc_got2_insn_end: 0 as libc::c_int as libc::c_uint,
            plt0_got1_offset: 2 as libc::c_int as libc::c_uint,
            plt0_got2_offset: 8 as libc::c_int as libc::c_uint,
            plt0_got2_insn_end: 0 as libc::c_int as libc::c_uint,
            plt_got_offset: 2 as libc::c_int as libc::c_uint,
            plt_reloc_offset: 7 as libc::c_int as libc::c_uint,
            plt_plt_offset: 12 as libc::c_int as libc::c_uint,
            plt_got_insn_size: 0 as libc::c_int as libc::c_uint,
            plt_plt_insn_end: 0 as libc::c_int as libc::c_uint,
            plt_lazy_offset: 6 as libc::c_int as libc::c_uint,
            pic_plt0_entry: elf_i386_pic_lazy_plt0_entry.as_ptr(),
            pic_plt_entry: elf_i386_pic_lazy_plt_entry.as_ptr(),
            eh_frame_plt: elf_i386_eh_frame_lazy_plt.as_ptr(),
            eh_frame_plt_size: ::core::mem::size_of::<[bfd_byte; 64]>() as libc::c_ulong
                as libc::c_uint,
        };
        init
    }
};
static mut elf_i386_non_lazy_plt: elf_x86_non_lazy_plt_layout = unsafe {
    {
        let mut init = elf_x86_non_lazy_plt_layout {
            plt_entry: elf_i386_non_lazy_plt_entry.as_ptr(),
            pic_plt_entry: elf_i386_pic_non_lazy_plt_entry.as_ptr(),
            plt_entry_size: 8 as libc::c_int as libc::c_uint,
            plt_got_offset: 2 as libc::c_int as libc::c_uint,
            plt_got_insn_size: 0 as libc::c_int as libc::c_uint,
            eh_frame_plt: elf_i386_eh_frame_non_lazy_plt.as_ptr(),
            eh_frame_plt_size: ::core::mem::size_of::<[bfd_byte; 44]>() as libc::c_ulong
                as libc::c_uint,
        };
        init
    }
};
static mut elf_i386_lazy_ibt_plt: elf_x86_lazy_plt_layout = unsafe {
    {
        let mut init = elf_x86_lazy_plt_layout {
            plt0_entry: elf_i386_lazy_ibt_plt0_entry.as_ptr(),
            plt0_entry_size: ::core::mem::size_of::<[bfd_byte; 16]>() as libc::c_ulong
                as libc::c_uint,
            plt_entry: elf_i386_lazy_ibt_plt_entry.as_ptr(),
            plt_entry_size: 16 as libc::c_int as libc::c_uint,
            plt_tlsdesc_entry: 0 as *const bfd_byte,
            plt_tlsdesc_entry_size: 0 as libc::c_int as libc::c_uint,
            plt_tlsdesc_got1_offset: 0 as libc::c_int as libc::c_uint,
            plt_tlsdesc_got2_offset: 0 as libc::c_int as libc::c_uint,
            plt_tlsdesc_got1_insn_end: 0 as libc::c_int as libc::c_uint,
            plt_tlsdesc_got2_insn_end: 0 as libc::c_int as libc::c_uint,
            plt0_got1_offset: 2 as libc::c_int as libc::c_uint,
            plt0_got2_offset: 8 as libc::c_int as libc::c_uint,
            plt0_got2_insn_end: 0 as libc::c_int as libc::c_uint,
            plt_got_offset: (4 as libc::c_int + 2 as libc::c_int) as libc::c_uint,
            plt_reloc_offset: (4 as libc::c_int + 1 as libc::c_int) as libc::c_uint,
            plt_plt_offset: (4 as libc::c_int + 6 as libc::c_int) as libc::c_uint,
            plt_got_insn_size: 0 as libc::c_int as libc::c_uint,
            plt_plt_insn_end: 0 as libc::c_int as libc::c_uint,
            plt_lazy_offset: 0 as libc::c_int as libc::c_uint,
            pic_plt0_entry: elf_i386_pic_lazy_ibt_plt0_entry.as_ptr(),
            pic_plt_entry: elf_i386_lazy_ibt_plt_entry.as_ptr(),
            eh_frame_plt: elf_i386_eh_frame_lazy_ibt_plt.as_ptr(),
            eh_frame_plt_size: ::core::mem::size_of::<[bfd_byte; 64]>() as libc::c_ulong
                as libc::c_uint,
        };
        init
    }
};
static mut elf_i386_non_lazy_ibt_plt: elf_x86_non_lazy_plt_layout = unsafe {
    {
        let mut init = elf_x86_non_lazy_plt_layout {
            plt_entry: elf_i386_non_lazy_ibt_plt_entry.as_ptr(),
            pic_plt_entry: elf_i386_pic_non_lazy_ibt_plt_entry.as_ptr(),
            plt_entry_size: 16 as libc::c_int as libc::c_uint,
            plt_got_offset: (4 as libc::c_int + 2 as libc::c_int) as libc::c_uint,
            plt_got_insn_size: 0 as libc::c_int as libc::c_uint,
            eh_frame_plt: elf_i386_eh_frame_non_lazy_plt.as_ptr(),
            eh_frame_plt_size: ::core::mem::size_of::<[bfd_byte; 44]>() as libc::c_ulong
                as libc::c_uint,
        };
        init
    }
};
unsafe extern "C" fn elf_i386_check_tls_transition(
    mut sec: *mut asection,
    mut contents: *mut bfd_byte,
    mut symtab_hdr: *mut Elf_Internal_Shdr,
    mut sym_hashes: *mut *mut elf_link_hash_entry,
    mut r_type: libc::c_uint,
    mut rel: *const Elf_Internal_Rela,
    mut relend: *const Elf_Internal_Rela,
) -> bool {
    let mut val: libc::c_uint = 0;
    let mut type_0: libc::c_uint = 0;
    let mut reg: libc::c_uint = 0;
    let mut r_symndx: libc::c_ulong = 0;
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut offset: bfd_vma = 0;
    let mut call: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut indirect_call: bool = false;
    offset = (*rel).r_offset;
    match r_type {
        18 | 19 => {
            if offset < 2 as libc::c_int as libc::c_ulong
                || rel.offset(1 as libc::c_int as isize) >= relend
            {
                return 0 as libc::c_int != 0;
            }
            indirect_call = 0 as libc::c_int != 0;
            call = contents.offset(offset as isize).offset(4 as libc::c_int as isize);
            val = *call.offset(-(5 as libc::c_int as isize)) as libc::c_uint;
            type_0 = *call.offset(-(6 as libc::c_int as isize)) as libc::c_uint;
            if r_type == R_386_TLS_GD as libc::c_int as libc::c_uint {
                if offset.wrapping_add(10 as libc::c_int as libc::c_ulong) > (*sec).size
                    || type_0 != 0x8d as libc::c_int as libc::c_uint
                        && type_0 != 0x4 as libc::c_int as libc::c_uint
                {
                    return 0 as libc::c_int != 0;
                }
                if type_0 == 0x4 as libc::c_int as libc::c_uint {
                    if offset < 3 as libc::c_int as libc::c_ulong {
                        return 0 as libc::c_int != 0;
                    }
                    if *call.offset(-(7 as libc::c_int as isize)) as libc::c_int
                        != 0x8d as libc::c_int
                        || val != 0x1d as libc::c_int as libc::c_uint
                        || *call.offset(0 as libc::c_int as isize) as libc::c_int
                            != 0xe8 as libc::c_int
                    {
                        return 0 as libc::c_int != 0;
                    }
                } else {
                    reg = val & 7 as libc::c_int as libc::c_uint;
                    if val & 0xf8 as libc::c_int as libc::c_uint
                        != 0x80 as libc::c_int as libc::c_uint
                        || reg == 4 as libc::c_int as libc::c_uint
                        || reg == 0 as libc::c_int as libc::c_uint
                    {
                        return 0 as libc::c_int != 0;
                    }
                    indirect_call = *call.offset(0 as libc::c_int as isize)
                        as libc::c_int == 0xff as libc::c_int;
                    if !(reg == 3 as libc::c_int as libc::c_uint
                        && *call.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0xe8 as libc::c_int
                        && *call.offset(5 as libc::c_int as isize) as libc::c_int
                            == 0x90 as libc::c_int)
                        && !(*call.offset(0 as libc::c_int as isize) as libc::c_int
                            == 0x67 as libc::c_int
                            && *call.offset(1 as libc::c_int as isize) as libc::c_int
                                == 0xe8 as libc::c_int)
                        && !(indirect_call as libc::c_int != 0
                            && *call.offset(1 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int == 0x90 as libc::c_int
                            && (*call.offset(1 as libc::c_int as isize) as libc::c_int
                                & 0x7 as libc::c_int) as libc::c_uint == reg)
                    {
                        return 0 as libc::c_int != 0;
                    }
                }
            } else {
                if type_0 != 0x8d as libc::c_int as libc::c_uint
                    || offset.wrapping_add(9 as libc::c_int as libc::c_ulong)
                        > (*sec).size
                {
                    return 0 as libc::c_int != 0;
                }
                reg = val & 7 as libc::c_int as libc::c_uint;
                if val & 0xf8 as libc::c_int as libc::c_uint
                    != 0x80 as libc::c_int as libc::c_uint
                    || reg == 4 as libc::c_int as libc::c_uint
                    || reg == 0 as libc::c_int as libc::c_uint
                {
                    return 0 as libc::c_int != 0;
                }
                indirect_call = *call.offset(0 as libc::c_int as isize) as libc::c_int
                    == 0xff as libc::c_int;
                if !(reg == 3 as libc::c_int as libc::c_uint
                    && *call.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0xe8 as libc::c_int)
                    && !(*call.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0x67 as libc::c_int
                        && *call.offset(1 as libc::c_int as isize) as libc::c_int
                            == 0xe8 as libc::c_int)
                    && !(indirect_call as libc::c_int != 0
                        && *call.offset(1 as libc::c_int as isize) as libc::c_int
                            & 0xf8 as libc::c_int == 0x90 as libc::c_int
                        && (*call.offset(1 as libc::c_int as isize) as libc::c_int
                            & 0x7 as libc::c_int) as libc::c_uint == reg)
                {
                    return 0 as libc::c_int != 0;
                }
            }
            r_symndx = (*rel.offset(1 as libc::c_int as isize)).r_info
                >> 8 as libc::c_int;
            if r_symndx < (*symtab_hdr).sh_info as libc::c_ulong {
                return 0 as libc::c_int != 0;
            }
            h = *sym_hashes
                .offset(
                    r_symndx.wrapping_sub((*symtab_hdr).sh_info as libc::c_ulong)
                        as isize,
                );
            if h.is_null() || (*(h as *mut elf_x86_link_hash_entry)).tls_get_addr() == 0
            {
                return 0 as libc::c_int != 0
            } else if indirect_call {
                return (*rel.offset(1 as libc::c_int as isize)).r_info
                    & 0xff as libc::c_int as libc::c_ulong
                    == R_386_GOT32X as libc::c_int as libc::c_ulong
            } else {
                return (*rel.offset(1 as libc::c_int as isize)).r_info
                    & 0xff as libc::c_int as libc::c_ulong
                    == R_386_PC32 as libc::c_int as libc::c_ulong
                    || (*rel.offset(1 as libc::c_int as isize)).r_info
                        & 0xff as libc::c_int as libc::c_ulong
                        == R_386_PLT32 as libc::c_int as libc::c_ulong
            }
        }
        15 => {
            if offset < 1 as libc::c_int as libc::c_ulong
                || offset.wrapping_add(4 as libc::c_int as libc::c_ulong) > (*sec).size
            {
                return 0 as libc::c_int != 0;
            }
            val = (*(contents
                .offset(offset as isize)
                .offset(-(1 as libc::c_int as isize)) as *const libc::c_uchar) as bfd_vma
                & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
            if val == 0xa1 as libc::c_int as libc::c_uint {
                return 1 as libc::c_int != 0;
            }
            if offset < 2 as libc::c_int as libc::c_ulong {
                return 0 as libc::c_int != 0;
            }
            type_0 = (*(contents
                .offset(offset as isize)
                .offset(-(2 as libc::c_int as isize)) as *const libc::c_uchar) as bfd_vma
                & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
            return (type_0 == 0x8b as libc::c_int as libc::c_uint
                || type_0 == 0x3 as libc::c_int as libc::c_uint)
                && val & 0xc7 as libc::c_int as libc::c_uint
                    == 0x5 as libc::c_int as libc::c_uint;
        }
        16 | 33 => {
            if offset < 2 as libc::c_int as libc::c_ulong
                || offset.wrapping_add(4 as libc::c_int as libc::c_ulong) > (*sec).size
            {
                return 0 as libc::c_int != 0;
            }
            val = (*(contents
                .offset(offset as isize)
                .offset(-(1 as libc::c_int as isize)) as *const libc::c_uchar) as bfd_vma
                & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
            if val & 0xc0 as libc::c_int as libc::c_uint
                != 0x80 as libc::c_int as libc::c_uint
                || val & 7 as libc::c_int as libc::c_uint
                    == 4 as libc::c_int as libc::c_uint
            {
                return 0 as libc::c_int != 0;
            }
            type_0 = (*(contents
                .offset(offset as isize)
                .offset(-(2 as libc::c_int as isize)) as *const libc::c_uchar) as bfd_vma
                & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
            return type_0 == 0x8b as libc::c_int as libc::c_uint
                || type_0 == 0x2b as libc::c_int as libc::c_uint
                || type_0 == 0x3 as libc::c_int as libc::c_uint;
        }
        39 => {
            if offset < 2 as libc::c_int as libc::c_ulong
                || offset.wrapping_add(4 as libc::c_int as libc::c_ulong) > (*sec).size
            {
                return 0 as libc::c_int != 0;
            }
            if *(contents.offset(offset as isize).offset(-(2 as libc::c_int as isize))
                as *const libc::c_uchar) as bfd_vma
                & 0xff as libc::c_int as libc::c_ulong
                != 0x8d as libc::c_int as libc::c_ulong
            {
                return 0 as libc::c_int != 0;
            }
            val = (*(contents
                .offset(offset as isize)
                .offset(-(1 as libc::c_int as isize)) as *const libc::c_uchar) as bfd_vma
                & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
            return val & 0xc7 as libc::c_int as libc::c_uint
                == 0x83 as libc::c_int as libc::c_uint;
        }
        40 => {
            if offset.wrapping_add(2 as libc::c_int as libc::c_ulong) <= (*sec).size {
                call = contents.offset(offset as isize);
                return *call.offset(0 as libc::c_int as isize) as libc::c_int
                    == 0xff as libc::c_int
                    && *call.offset(1 as libc::c_int as isize) as libc::c_int
                        == 0x10 as libc::c_int;
            }
            return 0 as libc::c_int != 0;
        }
        _ => {
            _bfd_abort(
                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                1049 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 180],
                    &[libc::c_char; 180],
                >(
                    b"_Bool elf_i386_check_tls_transition(asection *, bfd_byte *, Elf_Internal_Shdr *, struct elf_link_hash_entry **, unsigned int, const Elf_Internal_Rela *, const Elf_Internal_Rela *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
}
unsafe extern "C" fn elf_i386_tls_transition(
    mut info: *mut bfd_link_info,
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut contents: *mut bfd_byte,
    mut symtab_hdr: *mut Elf_Internal_Shdr,
    mut sym_hashes: *mut *mut elf_link_hash_entry,
    mut r_type: *mut libc::c_uint,
    mut tls_type: libc::c_int,
    mut rel: *const Elf_Internal_Rela,
    mut relend: *const Elf_Internal_Rela,
    mut h: *mut elf_link_hash_entry,
    mut r_symndx: libc::c_ulong,
    mut from_relocate_section: bool,
) -> bool {
    let mut from_type: libc::c_uint = *r_type;
    let mut to_type: libc::c_uint = from_type;
    let mut check: bool = 1 as libc::c_int != 0;
    if !h.is_null()
        && ((*h).type_0() as libc::c_int == 2 as libc::c_int
            || (*h).type_0() as libc::c_int == 10 as libc::c_int)
    {
        return 1 as libc::c_int != 0;
    }
    match from_type {
        18 | 39 | 40 | 33 | 15 | 16 => {
            if (*info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int
            {
                if h.is_null() {
                    to_type = R_386_TLS_LE_32 as libc::c_int as libc::c_uint;
                } else if from_type != R_386_TLS_IE as libc::c_int as libc::c_uint
                    && from_type != R_386_TLS_GOTIE as libc::c_int as libc::c_uint
                {
                    to_type = R_386_TLS_IE_32 as libc::c_int as libc::c_uint;
                }
            }
            if from_relocate_section {
                let mut new_to_type: libc::c_uint = to_type;
                if ((*info).type_0() as libc::c_int == type_pde as libc::c_int
                    || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
                    && !h.is_null()
                    && (*h).dynindx == -(1 as libc::c_int) as libc::c_long
                    && tls_type & 4 as libc::c_int != 0
                {
                    new_to_type = R_386_TLS_LE_32 as libc::c_int as libc::c_uint;
                }
                if to_type == R_386_TLS_GD as libc::c_int as libc::c_uint
                    || to_type == R_386_TLS_GOTDESC as libc::c_int as libc::c_uint
                    || to_type == R_386_TLS_DESC_CALL as libc::c_int as libc::c_uint
                {
                    if tls_type == 5 as libc::c_int {
                        new_to_type = R_386_TLS_GOTIE as libc::c_int as libc::c_uint;
                    } else if tls_type & 4 as libc::c_int != 0 {
                        new_to_type = R_386_TLS_IE_32 as libc::c_int as libc::c_uint;
                    }
                }
                check = new_to_type != to_type && from_type == to_type;
                to_type = new_to_type;
            }
        }
        19 => {
            if (*info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int
            {
                to_type = R_386_TLS_LE_32 as libc::c_int as libc::c_uint;
            }
        }
        _ => return 1 as libc::c_int != 0,
    }
    if from_type == to_type {
        return 1 as libc::c_int != 0;
    }
    if check as libc::c_int != 0
        && !elf_i386_check_tls_transition(
            sec,
            contents,
            symtab_hdr,
            sym_hashes,
            from_type,
            rel,
            relend,
        )
    {
        let mut from: *const reloc_howto_type = 0 as *const reloc_howto_type;
        let mut to: *const reloc_howto_type = 0 as *const reloc_howto_type;
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        from = elf_i386_rtype_to_howto(from_type);
        to = elf_i386_rtype_to_howto(to_type);
        if !h.is_null() {
            name = (*h).root.root.string;
        } else {
            let mut htab: *mut elf_x86_link_hash_table = 0
                as *mut elf_x86_link_hash_table;
            htab = if is_elf_hash_table((*info).hash) as libc::c_int != 0
                && elf_hash_table_id((*info).hash as *mut elf_link_hash_table)
                    as libc::c_uint == I386_ELF_DATA as libc::c_int as libc::c_uint
            {
                (*info).hash as *mut elf_x86_link_hash_table
            } else {
                0 as *mut elf_x86_link_hash_table
            };
            if htab.is_null() {
                name = b"*unknown*\0" as *const u8 as *const libc::c_char;
            } else {
                let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
                isym = bfd_sym_from_r_symndx(&mut (*htab).elf.sym_cache, abfd, r_symndx);
                name = bfd_elf_sym_name(abfd, symtab_hdr, isym, 0 as *mut asection);
            }
        }
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: TLS transition from %s to %s against `%s' at %#lx in section `%pA' failed\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            (*from).name,
            (*to).name,
            name,
            (*rel).r_offset,
            sec,
        );
        bfd_set_error(bfd_error_bad_value);
        return 0 as libc::c_int != 0;
    }
    *r_type = to_type;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_i386_convert_load_reloc(
    mut abfd: *mut bfd,
    mut symtab_hdr: *mut Elf_Internal_Shdr,
    mut contents: *mut bfd_byte,
    mut r_type_p: *mut libc::c_uint,
    mut irel: *mut Elf_Internal_Rela,
    mut h: *mut elf_link_hash_entry,
    mut converted: *mut bool,
    mut link_info: *mut bfd_link_info,
) -> bool {
    let mut current_block: u64;
    let mut htab: *mut elf_x86_link_hash_table = 0 as *mut elf_x86_link_hash_table;
    let mut opcode: libc::c_uint = 0;
    let mut modrm: libc::c_uint = 0;
    let mut baseless: bool = false;
    let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut addend: libc::c_uint = 0;
    let mut nop: libc::c_uint = 0;
    let mut nop_offset: bfd_vma = 0;
    let mut is_pic: bool = false;
    let mut to_reloc_32: bool = false;
    let mut abs_symbol: bool = false;
    let mut r_type: libc::c_uint = 0;
    let mut r_symndx: libc::c_uint = 0;
    let mut roff: bfd_vma = (*irel).r_offset;
    let mut local_ref: bool = false;
    let mut eh: *mut elf_x86_link_hash_entry = 0 as *mut elf_x86_link_hash_entry;
    if roff < 2 as libc::c_int as libc::c_ulong {
        return 1 as libc::c_int != 0;
    }
    addend = (Some(((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(contents.offset(roff as isize) as *const libc::c_void) as libc::c_uint;
    if addend != 0 as libc::c_int as libc::c_uint {
        return 1 as libc::c_int != 0;
    }
    htab = if is_elf_hash_table((*link_info).hash) as libc::c_int != 0
        && elf_hash_table_id((*link_info).hash as *mut elf_link_hash_table)
            as libc::c_uint == I386_ELF_DATA as libc::c_int as libc::c_uint
    {
        (*link_info).hash as *mut elf_x86_link_hash_table
    } else {
        0 as *mut elf_x86_link_hash_table
    };
    is_pic = (*link_info).type_0() as libc::c_int == type_dll as libc::c_int
        || (*link_info).type_0() as libc::c_int == type_pie as libc::c_int;
    r_type = *r_type_p;
    r_symndx = ((*irel).r_info >> 8 as libc::c_int) as libc::c_uint;
    modrm = (*(contents.offset(roff as isize).offset(-(1 as libc::c_int as isize))
        as *const libc::c_uchar) as bfd_vma & 0xff as libc::c_int as libc::c_ulong)
        as libc::c_uint;
    baseless = modrm & 0xc7 as libc::c_int as libc::c_uint
        == 0x5 as libc::c_int as libc::c_uint;
    if !h.is_null() {
        local_ref = _bfd_x86_elf_link_symbol_references_local(link_info, h);
        isym = 0 as *mut Elf_Internal_Sym;
        abs_symbol = (((*h).root).type_0() as libc::c_int
            == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int)
            && bfd_is_abs_section((*h).root.u.def.section) as libc::c_int != 0
            && ((*h).root).rel_from_abs() == 0 && ((*h).root).ldscript_def() == 0;
    } else {
        local_ref = 1 as libc::c_int != 0;
        isym = bfd_sym_from_r_symndx(
            &mut (*htab).elf.sym_cache,
            abfd,
            r_symndx as libc::c_ulong,
        );
        abs_symbol = (*isym).st_shndx == (0xf as libc::c_uint).wrapping_neg();
    }
    if baseless as libc::c_int != 0 && is_pic as libc::c_int != 0 {
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        if h.is_null() {
            name = bfd_elf_sym_name(abfd, symtab_hdr, isym, 0 as *mut asection);
        } else {
            name = (*h).root.root.string;
        }
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: direct GOT relocation R_386_GOT32X against `%s' without base register can not be used when making a shared object\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            name,
        );
        return 0 as libc::c_int != 0;
    }
    opcode = (*(contents.offset(roff as isize).offset(-(2 as libc::c_int as isize))
        as *const libc::c_uchar) as bfd_vma & 0xff as libc::c_int as libc::c_ulong)
        as libc::c_uint;
    to_reloc_32 = !is_pic || baseless as libc::c_int != 0;
    eh = h as *mut elf_x86_link_hash_entry;
    if h.is_null() {
        if opcode == 0xff as libc::c_int as libc::c_uint {
            current_block = 10865375215162286109;
        } else {
            current_block = 14613269006741981099;
        }
    } else if ((*h).root).type_0() as libc::c_int
        == bfd_link_hash_undefweak as libc::c_int && (*eh).linker_def() == 0
        && local_ref as libc::c_int != 0
    {
        if opcode == 0xff as libc::c_int as libc::c_uint {
            if is_pic {
                return 1 as libc::c_int != 0
            } else {
                current_block = 10865375215162286109;
            }
        } else {
            to_reloc_32 = 1 as libc::c_int != 0;
            current_block = 14613269006741981099;
        }
    } else if opcode == 0xff as libc::c_int as libc::c_uint {
        if (((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int) && local_ref as libc::c_int != 0
        {
            current_block = 10865375215162286109;
        } else {
            current_block = 2472048668343472511;
        }
    } else {
        if h == (*htab).elf.hdynamic {
            return 1 as libc::c_int != 0;
        }
        if (*h).start_stop() as libc::c_int != 0
            || (*eh).linker_def() as libc::c_int != 0
            || ((*h).def_regular() as libc::c_int != 0
                || ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_defined as libc::c_int
                || ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_defweak as libc::c_int)
                && local_ref as libc::c_int != 0
        {
            current_block = 14613269006741981099;
        } else {
            current_block = 2472048668343472511;
        }
    }
    match current_block {
        10865375215162286109 => {
            if modrm == 0x15 as libc::c_int as libc::c_uint
                || modrm & 0xf8 as libc::c_int as libc::c_uint
                    == 0x90 as libc::c_int as libc::c_uint
            {
                modrm = 0xe8 as libc::c_int as libc::c_uint;
                if !eh.is_null() && (*eh).tls_get_addr() as libc::c_int != 0 {
                    nop = 0x67 as libc::c_int as libc::c_uint;
                    nop_offset = ((*irel).r_offset)
                        .wrapping_sub(2 as libc::c_int as libc::c_ulong);
                } else {
                    nop = (*(*htab).params).call_nop_byte as libc::c_uint;
                    if (*(*htab).params).call_nop_as_suffix() != 0 {
                        nop_offset = roff
                            .wrapping_add(3 as libc::c_int as libc::c_ulong);
                        (*irel)
                            .r_offset = ((*irel).r_offset as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as bfd_vma
                            as bfd_vma;
                    } else {
                        nop_offset = roff
                            .wrapping_sub(2 as libc::c_int as libc::c_ulong);
                    }
                }
            } else {
                modrm = 0xe9 as libc::c_int as libc::c_uint;
                nop = 0x90 as libc::c_int as libc::c_char as libc::c_uint;
                nop_offset = roff.wrapping_add(3 as libc::c_int as libc::c_ulong);
                (*irel)
                    .r_offset = ((*irel).r_offset as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as bfd_vma
                    as bfd_vma;
            }
            *(contents.offset(nop_offset as isize)
                as *mut libc::c_uchar) = (nop & 0xff as libc::c_int as libc::c_uint)
                as libc::c_uchar;
            *(contents
                .offset((*irel).r_offset as isize)
                .offset(-(1 as libc::c_int as isize))
                as *mut libc::c_uchar) = (modrm & 0xff as libc::c_int as libc::c_uint)
                as libc::c_uchar;
            (Some(((*(*abfd).xvec).bfd_putx32).expect("non-null function pointer")))
                .expect(
                    "non-null function pointer",
                )(
                -(4 as libc::c_int) as bfd_vma,
                contents.offset((*irel).r_offset as isize) as *mut libc::c_void,
            );
            (*irel)
                .r_info = (r_symndx << 8 as libc::c_int)
                .wrapping_add(
                    (R_386_PC32 as libc::c_int & 0xff as libc::c_int) as libc::c_uint,
                ) as bfd_vma;
            *r_type_p = R_386_PC32 as libc::c_int as libc::c_uint;
            *converted = 1 as libc::c_int != 0;
        }
        14613269006741981099 => {
            if opcode == 0x8b as libc::c_int as libc::c_uint {
                if abs_symbol as libc::c_int != 0 && local_ref as libc::c_int != 0 {
                    to_reloc_32 = 1 as libc::c_int != 0;
                }
                if to_reloc_32 {
                    r_type = R_386_32 as libc::c_int as libc::c_uint;
                    modrm = 0xc0 as libc::c_int as libc::c_uint
                        | (modrm & 0x38 as libc::c_int as libc::c_uint)
                            >> 3 as libc::c_int;
                    *(contents.offset(roff as isize).offset(-(1 as libc::c_int as isize))
                        as *mut libc::c_uchar) = (modrm
                        & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
                    opcode = 0xc7 as libc::c_int as libc::c_uint;
                } else {
                    r_type = R_386_GOTOFF as libc::c_int as libc::c_uint;
                    opcode = 0x8d as libc::c_int as libc::c_uint;
                }
            } else {
                if !to_reloc_32 {
                    return 1 as libc::c_int != 0;
                }
                if opcode == 0x85 as libc::c_int as libc::c_uint {
                    modrm = 0xc0 as libc::c_int as libc::c_uint
                        | (modrm & 0x38 as libc::c_int as libc::c_uint)
                            >> 3 as libc::c_int;
                    opcode = 0xf7 as libc::c_int as libc::c_uint;
                } else {
                    modrm = 0xc0 as libc::c_int as libc::c_uint
                        | (modrm & 0x38 as libc::c_int as libc::c_uint)
                            >> 3 as libc::c_int
                        | opcode & 0x3c as libc::c_int as libc::c_uint;
                    opcode = 0x81 as libc::c_int as libc::c_uint;
                }
                *(contents.offset(roff as isize).offset(-(1 as libc::c_int as isize))
                    as *mut libc::c_uchar) = (modrm
                    & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
                r_type = R_386_32 as libc::c_int as libc::c_uint;
            }
            *(contents.offset(roff as isize).offset(-(2 as libc::c_int as isize))
                as *mut libc::c_uchar) = (opcode & 0xff as libc::c_int as libc::c_uint)
                as libc::c_uchar;
            (*irel)
                .r_info = (r_symndx << 8 as libc::c_int)
                .wrapping_add(r_type & 0xff as libc::c_int as libc::c_uint) as bfd_vma;
            *r_type_p = r_type;
            *converted = 1 as libc::c_int != 0;
        }
        _ => {}
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_i386_check_relocs(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut sec: *mut asection,
    mut relocs: *const Elf_Internal_Rela,
) -> bool {
    let mut current_block: u64;
    let mut htab: *mut elf_x86_link_hash_table = 0 as *mut elf_x86_link_hash_table;
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut sym_hashes: *mut *mut elf_link_hash_entry = 0
        as *mut *mut elf_link_hash_entry;
    let mut rel: *const Elf_Internal_Rela = 0 as *const Elf_Internal_Rela;
    let mut rel_end: *const Elf_Internal_Rela = 0 as *const Elf_Internal_Rela;
    let mut sreloc: *mut asection = 0 as *mut asection;
    let mut contents: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut converted: bool = false;
    if (*info).type_0() as libc::c_int == type_relocatable as libc::c_int {
        return 1 as libc::c_int != 0;
    }
    htab = if is_elf_hash_table((*info).hash) as libc::c_int != 0
        && elf_hash_table_id((*info).hash as *mut elf_link_hash_table) as libc::c_uint
            == I386_ELF_DATA as libc::c_int as libc::c_uint
    {
        (*info).hash as *mut elf_x86_link_hash_table
    } else {
        0 as *mut elf_x86_link_hash_table
    };
    if htab.is_null() {
        (*sec).set_sec_flg0(1 as libc::c_int as libc::c_uint);
        return 0 as libc::c_int != 0;
    }
    if !(bfd_get_flavour(abfd) as libc::c_uint
        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && !((*abfd).tdata.elf_obj_data).is_null()
        && (*(*abfd).tdata.elf_obj_data).object_id() as libc::c_uint
            == (*htab).elf.hash_table_id as libc::c_uint)
    {
        bfd_assert(
            b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
            1488 as libc::c_int,
        );
    }
    if !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.contents)
        .is_null()
    {
        contents = (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .contents;
    } else if !bfd_malloc_and_get_section(abfd, sec, &mut contents) {
        (*sec).set_sec_flg0(1 as libc::c_int as libc::c_uint);
        return 0 as libc::c_int != 0;
    }
    symtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    sym_hashes = (*(*abfd).tdata.elf_obj_data).sym_hashes;
    converted = 0 as libc::c_int != 0;
    sreloc = 0 as *mut asection;
    rel_end = relocs.offset((*sec).reloc_count as isize);
    rel = relocs;
    loop {
        if !(rel < rel_end) {
            current_block = 12655303178690906525;
            break;
        }
        let mut r_type: libc::c_uint = 0;
        let mut r_symndx: libc::c_uint = 0;
        let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
        let mut eh: *mut elf_x86_link_hash_entry = 0 as *mut elf_x86_link_hash_entry;
        let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        let mut size_reloc: bool = false;
        let mut no_dynreloc: bool = false;
        r_symndx = ((*rel).r_info >> 8 as libc::c_int) as libc::c_uint;
        r_type = ((*rel).r_info & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
        if r_symndx as libc::c_ulong
            >= (if (*symtab_hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                ((*symtab_hdr).sh_size).wrapping_div((*symtab_hdr).sh_entsize)
            } else {
                0 as libc::c_int as libc::c_ulong
            })
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: bad symbol index: %d\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                r_symndx,
            );
            current_block = 9274136238786506530;
            break;
        } else {
            if r_symndx < (*symtab_hdr).sh_info {
                isym = bfd_sym_from_r_symndx(
                    &mut (*htab).elf.sym_cache,
                    abfd,
                    r_symndx as libc::c_ulong,
                );
                if isym.is_null() {
                    current_block = 9274136238786506530;
                    break;
                }
                if (*isym).st_info as libc::c_int & 0xf as libc::c_int
                    == 10 as libc::c_int
                {
                    h = _bfd_elf_x86_get_local_sym_hash(
                        htab,
                        abfd,
                        rel,
                        1 as libc::c_int != 0,
                    );
                    if h.is_null() {
                        current_block = 9274136238786506530;
                        break;
                    }
                    (*h)
                        .root
                        .root
                        .string = bfd_elf_sym_name(
                        abfd,
                        symtab_hdr,
                        isym,
                        0 as *mut asection,
                    );
                    (*h).set_type_0(10 as libc::c_int as libc::c_uint);
                    (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
                    (*h).set_ref_regular(1 as libc::c_int as libc::c_uint);
                    (*h).set_forced_local(1 as libc::c_int as libc::c_uint);
                    ((*h).root).set_type_0(bfd_link_hash_defined);
                } else {
                    h = 0 as *mut elf_link_hash_entry;
                }
            } else {
                isym = 0 as *mut Elf_Internal_Sym;
                h = *sym_hashes
                    .offset(r_symndx.wrapping_sub((*symtab_hdr).sh_info) as isize);
                while ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_indirect as libc::c_int
                    || ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_warning as libc::c_int
                {
                    h = (*h).root.u.i.link as *mut elf_link_hash_entry;
                }
            }
            eh = h as *mut elf_x86_link_hash_entry;
            if !h.is_null() {
                if r_type == R_386_GOTOFF as libc::c_int as libc::c_uint {
                    (*eh).set_gotoff_ref(1 as libc::c_int as libc::c_uint);
                }
                (*h).set_ref_regular(1 as libc::c_int as libc::c_uint);
            }
            if r_type == R_386_GOT32X as libc::c_int as libc::c_uint
                && (h.is_null() || (*h).type_0() as libc::c_int != 10 as libc::c_int)
            {
                let mut irel: *mut Elf_Internal_Rela = rel as *mut Elf_Internal_Rela;
                if !elf_i386_convert_load_reloc(
                    abfd,
                    symtab_hdr,
                    contents,
                    &mut r_type,
                    irel,
                    h,
                    &mut converted,
                    info,
                ) {
                    current_block = 9274136238786506530;
                    break;
                }
            }
            if !_bfd_elf_x86_valid_reloc_p(
                sec,
                info,
                htab,
                rel,
                h,
                isym,
                symtab_hdr,
                &mut no_dynreloc,
            ) {
                return 0 as libc::c_int != 0;
            }
            if !elf_i386_tls_transition(
                info,
                abfd,
                sec,
                contents,
                symtab_hdr,
                sym_hashes,
                &mut r_type,
                0 as libc::c_int,
                rel,
                rel_end,
                h,
                r_symndx as libc::c_ulong,
                0 as libc::c_int != 0,
            ) {
                current_block = 9274136238786506530;
                break;
            }
            if h == (*htab).elf.hgot {
                (*htab).set_got_referenced(1 as libc::c_int as libc::c_uint);
            }
            match r_type {
                19 => {
                    (*htab)
                        .tls_ld_or_ldm_got
                        .refcount = 1 as libc::c_int as bfd_signed_vma;
                    current_block = 8662283750246672775;
                }
                4 => {
                    if h.is_null() {
                        current_block = 7175849428784450219;
                    } else {
                        (*eh)
                            .set_zero_undefweak(
                                (*eh).zero_undefweak() & 0x2 as libc::c_int as libc::c_uint,
                            );
                        (*h).set_needs_plt(1 as libc::c_int as libc::c_uint);
                        (*h).plt.refcount = 1 as libc::c_int as bfd_signed_vma;
                        current_block = 7175849428784450219;
                    }
                }
                38 => {
                    size_reloc = 1 as libc::c_int != 0;
                    current_block = 6051265987666326968;
                }
                33 | 15 | 16 => {
                    if !((*info).type_0() as libc::c_int == type_pde as libc::c_int
                        || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
                    {
                        (*info).flags
                            |= ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_ulong;
                    }
                    current_block = 4888910987971495881;
                }
                3 | 43 | 18 | 39 | 40 => {
                    current_block = 4888910987971495881;
                }
                9 | 10 => {
                    current_block = 8662283750246672775;
                }
                34 | 17 => {
                    current_block = 10955797123936337399;
                }
                1 | 2 => {
                    if !eh.is_null()
                        && (*sec).flags & 0x10 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                    {
                        (*eh)
                            .set_zero_undefweak(
                                (*eh).zero_undefweak() | 0x2 as libc::c_int as libc::c_uint,
                            );
                    }
                    current_block = 16549312954885221309;
                }
                250 => {
                    if !bfd_elf_gc_record_vtinherit(abfd, sec, h, (*rel).r_offset) {
                        current_block = 9274136238786506530;
                        break;
                    }
                    current_block = 7175849428784450219;
                }
                251 => {
                    if !bfd_elf_gc_record_vtentry(abfd, sec, h, (*rel).r_offset) {
                        current_block = 9274136238786506530;
                        break;
                    }
                    current_block = 7175849428784450219;
                }
                _ => {
                    current_block = 7175849428784450219;
                }
            }
            match current_block {
                4888910987971495881 => {
                    let mut tls_type: libc::c_int = 0;
                    let mut old_tls_type: libc::c_int = 0;
                    match r_type {
                        18 => {
                            tls_type = 2 as libc::c_int;
                        }
                        39 | 40 => {
                            tls_type = 8 as libc::c_int;
                        }
                        33 => {
                            if (*rel).r_info & 0xff as libc::c_int as libc::c_ulong
                                == r_type as libc::c_ulong
                            {
                                tls_type = 6 as libc::c_int;
                            } else {
                                tls_type = 4 as libc::c_int;
                            }
                        }
                        15 | 16 => {
                            tls_type = 5 as libc::c_int;
                        }
                        3 | 43 | _ => {
                            tls_type = 1 as libc::c_int;
                        }
                    }
                    if !h.is_null() {
                        (*h).got.refcount = 1 as libc::c_int as bfd_signed_vma;
                        old_tls_type = (*(h as *mut elf_x86_link_hash_entry)).tls_type
                            as libc::c_int;
                    } else {
                        let mut local_got_refcounts: *mut bfd_signed_vma = 0
                            as *mut bfd_signed_vma;
                        local_got_refcounts = (*(*abfd).tdata.elf_obj_data)
                            .local_got
                            .refcounts;
                        if local_got_refcounts.is_null() {
                            let mut size: bfd_size_type = 0;
                            size = (*symtab_hdr).sh_info as bfd_size_type;
                            size = (size as libc::c_ulong)
                                .wrapping_mul(
                                    (::core::mem::size_of::<bfd_signed_vma>() as libc::c_ulong)
                                        .wrapping_add(
                                            ::core::mem::size_of::<bfd_vma>() as libc::c_ulong,
                                        )
                                        .wrapping_add(
                                            ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                        ),
                                ) as bfd_size_type as bfd_size_type;
                            local_got_refcounts = bfd_zalloc(abfd, size)
                                as *mut bfd_signed_vma;
                            if local_got_refcounts.is_null() {
                                current_block = 9274136238786506530;
                                break;
                            }
                            (*(*abfd).tdata.elf_obj_data)
                                .local_got
                                .refcounts = local_got_refcounts;
                            let ref mut fresh0 = (*((*abfd).tdata.any
                                as *mut elf_x86_obj_tdata))
                                .local_tlsdesc_gotent;
                            *fresh0 = local_got_refcounts
                                .offset((*symtab_hdr).sh_info as isize) as *mut bfd_vma;
                            let ref mut fresh1 = (*((*abfd).tdata.any
                                as *mut elf_x86_obj_tdata))
                                .local_got_tls_type;
                            *fresh1 = local_got_refcounts
                                .offset(
                                    (2 as libc::c_int as libc::c_uint)
                                        .wrapping_mul((*symtab_hdr).sh_info) as isize,
                                ) as *mut libc::c_char;
                        }
                        *local_got_refcounts
                            .offset(
                                r_symndx as isize,
                            ) = 1 as libc::c_int as bfd_signed_vma;
                        old_tls_type = *((*((*abfd).tdata.any as *mut elf_x86_obj_tdata))
                            .local_got_tls_type)
                            .offset(r_symndx as isize) as libc::c_int;
                    }
                    if old_tls_type & 4 as libc::c_int != 0
                        && tls_type & 4 as libc::c_int != 0
                    {
                        tls_type |= old_tls_type;
                    } else if old_tls_type != tls_type
                        && old_tls_type != 0 as libc::c_int
                        && (!(old_tls_type == 2 as libc::c_int
                            || old_tls_type == 2 as libc::c_int | 8 as libc::c_int
                            || (old_tls_type == 8 as libc::c_int
                                || old_tls_type == 2 as libc::c_int | 8 as libc::c_int))
                            || tls_type & 4 as libc::c_int == 0 as libc::c_int)
                    {
                        if old_tls_type & 4 as libc::c_int != 0
                            && (tls_type == 2 as libc::c_int
                                || tls_type == 2 as libc::c_int | 8 as libc::c_int
                                || (tls_type == 8 as libc::c_int
                                    || tls_type == 2 as libc::c_int | 8 as libc::c_int))
                        {
                            tls_type = old_tls_type;
                        } else if (old_tls_type == 2 as libc::c_int
                            || old_tls_type == 2 as libc::c_int | 8 as libc::c_int
                            || (old_tls_type == 8 as libc::c_int
                                || old_tls_type == 2 as libc::c_int | 8 as libc::c_int))
                            && (tls_type == 2 as libc::c_int
                                || tls_type == 2 as libc::c_int | 8 as libc::c_int
                                || (tls_type == 8 as libc::c_int
                                    || tls_type == 2 as libc::c_int | 8 as libc::c_int))
                        {
                            tls_type |= old_tls_type;
                        } else {
                            if !h.is_null() {
                                name = (*h).root.root.string;
                            } else {
                                name = bfd_elf_sym_name(
                                    abfd,
                                    symtab_hdr,
                                    isym,
                                    0 as *mut asection,
                                );
                            }
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: `%s' accessed both as normal and thread local symbol\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                name,
                            );
                            bfd_set_error(bfd_error_bad_value);
                            current_block = 9274136238786506530;
                            break;
                        }
                    }
                    if old_tls_type != tls_type {
                        if !h.is_null() {
                            (*(h as *mut elf_x86_link_hash_entry))
                                .tls_type = tls_type as libc::c_uchar;
                        } else {
                            *((*((*abfd).tdata.any as *mut elf_x86_obj_tdata))
                                .local_got_tls_type)
                                .offset(r_symndx as isize) = tls_type as libc::c_char;
                        }
                    }
                    current_block = 8662283750246672775;
                }
                _ => {}
            }
            match current_block {
                8662283750246672775 => {
                    if r_type != R_386_TLS_IE as libc::c_int as libc::c_uint {
                        if !eh.is_null() {
                            (*eh)
                                .set_zero_undefweak(
                                    (*eh).zero_undefweak() & 0x2 as libc::c_int as libc::c_uint,
                                );
                            if r_type == R_386_GOTOFF as libc::c_int as libc::c_uint
                                && ((*h).root).type_0() as libc::c_int
                                    == bfd_link_hash_undefweak as libc::c_int
                                && ((*info).type_0() as libc::c_int
                                    == type_pde as libc::c_int
                                    || (*info).type_0() as libc::c_int
                                        == type_pie as libc::c_int)
                            {
                                (*htab)
                                    .set_got_referenced(1 as libc::c_int as libc::c_uint);
                            }
                        }
                        current_block = 7175849428784450219;
                    } else {
                        current_block = 10955797123936337399;
                    }
                }
                _ => {}
            }
            match current_block {
                10955797123936337399 => {
                    if !eh.is_null() {
                        (*eh)
                            .set_zero_undefweak(
                                (*eh).zero_undefweak() & 0x2 as libc::c_int as libc::c_uint,
                            );
                    }
                    if (*info).type_0() as libc::c_int == type_pde as libc::c_int
                        || (*info).type_0() as libc::c_int == type_pie as libc::c_int
                    {
                        current_block = 7175849428784450219;
                    } else {
                        (*info).flags
                            |= ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_ulong;
                        current_block = 16549312954885221309;
                    }
                }
                _ => {}
            }
            match current_block {
                16549312954885221309 => {
                    if !h.is_null()
                        && ((*info).type_0() as libc::c_int == type_pde as libc::c_int
                            || (*info).type_0() as libc::c_int == type_pie as libc::c_int
                            || (*h).type_0() as libc::c_int == 10 as libc::c_int)
                    {
                        let mut func_pointer_ref: bool = 0 as libc::c_int != 0;
                        if r_type == R_386_PC32 as libc::c_int as libc::c_uint {
                            if (*sec).flags & 0x10 as libc::c_int as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                            {
                                (*h)
                                    .set_pointer_equality_needed(
                                        1 as libc::c_int as libc::c_uint,
                                    );
                            } else if (*h).type_0() as libc::c_int == 10 as libc::c_int
                                && ((*info).type_0() as libc::c_int
                                    == type_dll as libc::c_int
                                    || (*info).type_0() as libc::c_int
                                        == type_pie as libc::c_int)
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unsupported non-PIC call to IFUNC `%s'\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*h).root.root.string,
                                );
                                bfd_set_error(bfd_error_bad_value);
                                current_block = 9274136238786506530;
                                break;
                            }
                        } else {
                            (*h)
                                .set_pointer_equality_needed(
                                    1 as libc::c_int as libc::c_uint,
                                );
                            if r_type == R_386_32 as libc::c_int as libc::c_uint
                                && (*sec).flags & 0x8 as libc::c_int as libc::c_uint
                                    == 0 as libc::c_int as libc::c_uint
                            {
                                func_pointer_ref = 1 as libc::c_int != 0;
                            }
                        }
                        if !func_pointer_ref {
                            (*h).set_non_got_ref(1 as libc::c_int as libc::c_uint);
                            if (*h).def_regular() == 0
                                || (*sec).flags
                                    & (0x10 as libc::c_int | 0x8 as libc::c_int) as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                            {
                                (*h).plt.refcount = 1 as libc::c_int as bfd_signed_vma;
                            }
                        }
                    }
                    size_reloc = 0 as libc::c_int != 0;
                    current_block = 6051265987666326968;
                }
                _ => {}
            }
            match current_block {
                6051265987666326968 => {
                    if !no_dynreloc
                        && (((*info).type_0() as libc::c_int == type_dll as libc::c_int
                            || (*info).type_0() as libc::c_int
                                == type_pie as libc::c_int)
                            && (!(r_type == R_386_PC32 as libc::c_int as libc::c_uint)
                                || !h.is_null()
                                    && (!((*info).type_0() as libc::c_int
                                        == type_pie as libc::c_int
                                        || (*h).unique_global() == 0
                                            && ((*info).symbolic() as libc::c_int != 0
                                                || (*h).start_stop() as libc::c_int != 0
                                                || (*info).dynamic() as libc::c_int != 0
                                                    && (*h).dynamic() == 0))
                                        || ((*h).root).type_0() as libc::c_int
                                            == bfd_link_hash_defweak as libc::c_int
                                        || !((*info).type_0() as libc::c_int
                                            == type_pie as libc::c_int && 0 as libc::c_int != 0
                                            && (*h).plt.refcount > 0 as libc::c_int as libc::c_long
                                            && (*sec).flags & 0x10 as libc::c_int as libc::c_uint
                                                == 0 as libc::c_int as libc::c_uint
                                            && (*h).type_0() as libc::c_int == 2 as libc::c_int
                                            && (*h).def_dynamic() as libc::c_int != 0)
                                            && (*h).def_regular() == 0))
                            || !h.is_null()
                                && (*h).type_0() as libc::c_int == 10 as libc::c_int
                                && r_type == R_386_32 as libc::c_int as libc::c_uint
                                && (*sec).flags & 0x10 as libc::c_int as libc::c_uint
                                    == 0 as libc::c_int as libc::c_uint
                            || 1 as libc::c_int != 0
                                && !((*info).type_0() as libc::c_int
                                    == type_dll as libc::c_int
                                    || (*info).type_0() as libc::c_int
                                        == type_pie as libc::c_int) && !h.is_null()
                                && (((*h).root).type_0() as libc::c_int
                                    == bfd_link_hash_defweak as libc::c_int
                                    || (*h).def_regular() == 0))
                    {
                        let mut p: *mut elf_dyn_relocs = 0 as *mut elf_dyn_relocs;
                        let mut head: *mut *mut elf_dyn_relocs = 0
                            as *mut *mut elf_dyn_relocs;
                        if sreloc.is_null() {
                            sreloc = _bfd_elf_make_dynamic_reloc_section(
                                sec,
                                (*htab).elf.dynobj,
                                2 as libc::c_int as libc::c_uint,
                                abfd,
                                0 as libc::c_int != 0,
                            );
                            if sreloc.is_null() {
                                current_block = 9274136238786506530;
                                break;
                            }
                        }
                        if !h.is_null() {
                            head = &mut (*h).dyn_relocs;
                        } else {
                            let mut vpp: *mut *mut libc::c_void = 0
                                as *mut *mut libc::c_void;
                            let mut s: *mut asection = 0 as *mut asection;
                            isym = bfd_sym_from_r_symndx(
                                &mut (*htab).elf.sym_cache,
                                abfd,
                                r_symndx as libc::c_ulong,
                            );
                            if isym.is_null() {
                                current_block = 9274136238786506530;
                                break;
                            }
                            s = bfd_section_from_elf_index(abfd, (*isym).st_shndx);
                            if s.is_null() {
                                s = sec;
                            }
                            vpp = &mut (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                .local_dynrel;
                            head = vpp as *mut *mut elf_dyn_relocs;
                        }
                        p = *head;
                        if p.is_null() || (*p).sec != sec {
                            let mut amt: size_t = ::core::mem::size_of::<
                                elf_dyn_relocs,
                            >() as libc::c_ulong;
                            p = bfd_alloc((*htab).elf.dynobj, amt)
                                as *mut elf_dyn_relocs;
                            if p.is_null() {
                                current_block = 9274136238786506530;
                                break;
                            }
                            (*p).next = *head;
                            *head = p;
                            (*p).sec = sec;
                            (*p).count = 0 as libc::c_int as bfd_size_type;
                            (*p).pc_count = 0 as libc::c_int as bfd_size_type;
                        }
                        (*p)
                            .count = ((*p).count as libc::c_ulong)
                            .wrapping_add(1 as libc::c_int as libc::c_ulong)
                            as bfd_size_type as bfd_size_type;
                        if r_type == R_386_PC32 as libc::c_int as libc::c_uint
                            || size_reloc as libc::c_int != 0
                        {
                            (*p)
                                .pc_count = ((*p).pc_count as libc::c_ulong)
                                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                                as bfd_size_type as bfd_size_type;
                        }
                    }
                }
                _ => {}
            }
            rel = rel.offset(1);
            rel;
        }
    }
    match current_block {
        9274136238786506530 => {
            if (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.contents
                != contents
            {
                free(contents as *mut libc::c_void);
            }
            (*sec).set_sec_flg0(1 as libc::c_int as libc::c_uint);
            return 0 as libc::c_int != 0;
        }
        _ => {
            if (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.contents
                != contents
            {
                if !converted && (*info).keep_memory() == 0 {
                    free(contents as *mut libc::c_void);
                } else {
                    let ref mut fresh2 = (*((*sec).used_by_bfd
                        as *mut bfd_elf_section_data))
                        .this_hdr
                        .contents;
                    *fresh2 = contents;
                }
            }
            if (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).relocs
                != relocs as *mut Elf_Internal_Rela && converted as libc::c_int != 0
            {
                let ref mut fresh3 = (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
                    .relocs;
                *fresh3 = relocs as *mut Elf_Internal_Rela;
            }
            return 1 as libc::c_int != 0;
        }
    };
}
unsafe extern "C" fn elf_i386_fake_sections(
    mut abfd: *mut bfd,
    mut hdr: *mut Elf_Internal_Shdr,
    mut sec: *mut asection,
) -> bool {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    name = bfd_section_name(sec);
    if strcmp(name, b".reloc\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int
    {
        (*hdr).sh_type = 1 as libc::c_int as libc::c_uint;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_i386_tpoff(
    mut info: *mut bfd_link_info,
    mut address: bfd_vma,
) -> bfd_vma {
    let mut htab: *mut elf_link_hash_table = elf_hash_table(info);
    let mut bed: *const elf_backend_data = (*(*(*info).output_bfd).xvec).backend_data
        as *const elf_backend_data;
    let mut static_tls_size: bfd_vma = 0;
    if ((*htab).tls_sec).is_null() {
        return 0 as libc::c_int as bfd_vma;
    }
    static_tls_size = if ((*htab).tls_size)
        .wrapping_add((*bed).static_tls_alignment as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) >= (*htab).tls_size
    {
        ((*htab).tls_size)
            .wrapping_add(
                ((*bed).static_tls_alignment)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
            )
            & !(((*bed).static_tls_alignment)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) as bfd_vma)
    } else {
        !(0 as libc::c_int as bfd_vma)
    };
    return static_tls_size.wrapping_add((*(*htab).tls_sec).vma).wrapping_sub(address);
}
unsafe extern "C" fn elf_i386_relocate_section(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut input_bfd: *mut bfd,
    mut input_section: *mut asection,
    mut contents: *mut bfd_byte,
    mut relocs: *mut Elf_Internal_Rela,
    mut local_syms: *mut Elf_Internal_Sym,
    mut local_sections: *mut *mut asection,
) -> libc::c_int {
    let mut outrel: Elf_Internal_Rela = Elf_Internal_Rela {
        r_offset: 0,
        r_info: 0,
        r_addend: 0,
    };
    let mut sreloc: *mut asection = 0 as *mut asection;
    let mut offset: bfd_vma = 0;
    let mut name_0: *const libc::c_char = 0 as *const libc::c_char;
    let mut current_block: u64;
    let mut htab: *mut elf_x86_link_hash_table = 0 as *mut elf_x86_link_hash_table;
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut sym_hashes: *mut *mut elf_link_hash_entry = 0
        as *mut *mut elf_link_hash_entry;
    let mut local_got_offsets: *mut bfd_vma = 0 as *mut bfd_vma;
    let mut local_tlsdesc_gotents: *mut bfd_vma = 0 as *mut bfd_vma;
    let mut rel: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut wrel: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut relend: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut is_vxworks_tls: bool = false;
    let mut plt_entry_size: libc::c_uint = 0;
    if (*input_section).sec_flg0() != 0 {
        return 0 as libc::c_int;
    }
    htab = if is_elf_hash_table((*info).hash) as libc::c_int != 0
        && elf_hash_table_id((*info).hash as *mut elf_link_hash_table) as libc::c_uint
            == I386_ELF_DATA as libc::c_int as libc::c_uint
    {
        (*info).hash as *mut elf_x86_link_hash_table
    } else {
        0 as *mut elf_x86_link_hash_table
    };
    if htab.is_null() {
        return 0 as libc::c_int;
    }
    if !(bfd_get_flavour(input_bfd) as libc::c_uint
        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && !((*input_bfd).tdata.elf_obj_data).is_null()
        && (*(*input_bfd).tdata.elf_obj_data).object_id() as libc::c_uint
            == (*htab).elf.hash_table_id as libc::c_uint)
    {
        bfd_set_error(bfd_error_wrong_format);
        return 0 as libc::c_int;
    }
    symtab_hdr = &mut (*(*input_bfd).tdata.elf_obj_data).symtab_hdr;
    sym_hashes = (*(*input_bfd).tdata.elf_obj_data).sym_hashes;
    local_got_offsets = (*(*input_bfd).tdata.elf_obj_data).local_got.offsets;
    local_tlsdesc_gotents = (*((*input_bfd).tdata.any as *mut elf_x86_obj_tdata))
        .local_tlsdesc_gotent;
    is_vxworks_tls = (*htab).elf.target_os as libc::c_uint
        == is_vxworks as libc::c_int as libc::c_uint
        && ((*info).type_0() as libc::c_int == type_dll as libc::c_int
            || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
        && strcmp(
            (*(*input_section).output_section).name,
            b".tls_vars\0" as *const u8 as *const libc::c_char,
        ) == 0;
    _bfd_x86_elf_set_tls_module_base(info);
    plt_entry_size = (*htab).plt.plt_entry_size;
    wrel = relocs;
    rel = wrel;
    relend = relocs.offset((*input_section).reloc_count as isize);
    while rel < relend {
        let mut r_type: libc::c_uint = 0;
        let mut r_type_tls: libc::c_uint = 0;
        let mut howto: *const reloc_howto_type = 0 as *const reloc_howto_type;
        let mut r_symndx: libc::c_ulong = 0;
        let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
        let mut eh: *mut elf_x86_link_hash_entry = 0 as *mut elf_x86_link_hash_entry;
        let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        let mut sec: *mut asection = 0 as *mut asection;
        let mut off: bfd_vma = 0;
        let mut offplt: bfd_vma = 0;
        let mut plt_offset: bfd_vma = 0;
        let mut relocation: bfd_vma = 0;
        let mut unresolved_reloc: bool = false;
        let mut r: bfd_reloc_status_type = 0 as bfd_reloc_status_type;
        let mut indx: libc::c_uint = 0;
        let mut tls_type: libc::c_int = 0;
        let mut st_size: bfd_vma = 0;
        let mut resolved_plt: *mut asection = 0 as *mut asection;
        let mut resolved_to_zero: bool = false;
        let mut relative_reloc: bool = false;
        r_type = ((*rel).r_info & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
        if r_type == R_386_GNU_VTINHERIT as libc::c_int as libc::c_uint
            || r_type == R_386_GNU_VTENTRY as libc::c_int as libc::c_uint
        {
            if wrel != rel {
                *wrel = *rel;
            }
        } else {
            howto = elf_i386_rtype_to_howto(r_type);
            if howto.is_null() {
                return _bfd_unrecognized_reloc(input_bfd, input_section, r_type)
                    as libc::c_int;
            }
            r_symndx = (*rel).r_info >> 8 as libc::c_int;
            h = 0 as *mut elf_link_hash_entry;
            sym = 0 as *mut Elf_Internal_Sym;
            sec = 0 as *mut asection;
            unresolved_reloc = 0 as libc::c_int != 0;
            if r_symndx < (*symtab_hdr).sh_info as libc::c_ulong {
                sym = local_syms.offset(r_symndx as isize);
                sec = *local_sections.offset(r_symndx as isize);
                relocation = ((*(*sec).output_section).vma)
                    .wrapping_add((*sec).output_offset)
                    .wrapping_add((*sym).st_value);
                st_size = (*sym).st_size;
                if (*sym).st_info as libc::c_int & 0xf as libc::c_int == 3 as libc::c_int
                    && ((*sec).flags & 0x800000 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                        || (*info).type_0() as libc::c_int
                            == type_relocatable as libc::c_int
                            && (*sec).output_offset != 0 as libc::c_int as libc::c_ulong)
                {
                    let mut addend: bfd_vma = 0;
                    let mut where_0: *mut bfd_byte = contents
                        .offset((*rel).r_offset as isize);
                    match (*howto).size() as libc::c_int {
                        0 => {
                            addend = *(where_0 as *const libc::c_uchar) as bfd_vma
                                & 0xff as libc::c_int as libc::c_ulong;
                            if (*howto).pc_relative() != 0 {
                                addend = (addend ^ 0x80 as libc::c_int as libc::c_ulong)
                                    .wrapping_sub(0x80 as libc::c_int as libc::c_ulong);
                                addend = (addend as libc::c_ulong)
                                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as bfd_vma
                                    as bfd_vma;
                            }
                        }
                        1 => {
                            addend = (Some(
                                ((*(*input_bfd).xvec).bfd_getx16)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(where_0 as *const libc::c_void);
                            if (*howto).pc_relative() != 0 {
                                addend = (addend ^ 0x8000 as libc::c_int as libc::c_ulong)
                                    .wrapping_sub(0x8000 as libc::c_int as libc::c_ulong);
                                addend = (addend as libc::c_ulong)
                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as bfd_vma
                                    as bfd_vma;
                            }
                        }
                        2 => {
                            addend = (Some(
                                ((*(*input_bfd).xvec).bfd_getx32)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(where_0 as *const libc::c_void);
                            if (*howto).pc_relative() != 0 {
                                addend = (addend
                                    ^ 0x80000000 as libc::c_uint as libc::c_ulong)
                                    .wrapping_sub(0x80000000 as libc::c_uint as libc::c_ulong);
                                addend = (addend as libc::c_ulong)
                                    .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                                    as bfd_vma;
                            }
                        }
                        _ => {
                            _bfd_abort(
                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                2130 as libc::c_int,
                                (*::core::mem::transmute::<
                                    &[u8; 146],
                                    &[libc::c_char; 146],
                                >(
                                    b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                ))
                                    .as_ptr(),
                            );
                        }
                    }
                    if (*info).type_0() as libc::c_int == type_relocatable as libc::c_int
                    {
                        addend = (addend as libc::c_ulong)
                            .wrapping_add((*sec).output_offset) as bfd_vma as bfd_vma;
                    } else {
                        let mut msec: *mut asection = sec;
                        addend = _bfd_elf_rel_local_sym(
                            output_bfd,
                            sym,
                            &mut msec,
                            addend,
                        );
                        addend = (addend as libc::c_ulong).wrapping_sub(relocation)
                            as bfd_vma as bfd_vma;
                        addend = (addend as libc::c_ulong)
                            .wrapping_add(
                                ((*(*msec).output_section).vma)
                                    .wrapping_add((*msec).output_offset),
                            ) as bfd_vma as bfd_vma;
                    }
                    match (*howto).size() as libc::c_int {
                        0 => {
                            if (*howto).pc_relative() != 0 {
                                addend = (addend as libc::c_ulong)
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as bfd_vma
                                    as bfd_vma;
                            }
                            *(where_0
                                as *mut libc::c_uchar) = (addend
                                & 0xff as libc::c_int as libc::c_ulong) as libc::c_uchar;
                        }
                        1 => {
                            if (*howto).pc_relative() != 0 {
                                addend = (addend as libc::c_ulong)
                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong) as bfd_vma
                                    as bfd_vma;
                            }
                            (Some(
                                ((*(*input_bfd).xvec).bfd_putx16)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(addend, where_0 as *mut libc::c_void);
                        }
                        2 => {
                            if (*howto).pc_relative() != 0 {
                                addend = (addend as libc::c_ulong)
                                    .wrapping_sub(4 as libc::c_int as libc::c_ulong) as bfd_vma
                                    as bfd_vma;
                            }
                            (Some(
                                ((*(*input_bfd).xvec).bfd_putx32)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(addend, where_0 as *mut libc::c_void);
                        }
                        _ => {}
                    }
                } else if !((*info).type_0() as libc::c_int
                    == type_relocatable as libc::c_int)
                    && (*sym).st_info as libc::c_int & 0xf as libc::c_int
                        == 10 as libc::c_int
                {
                    h = _bfd_elf_x86_get_local_sym_hash(
                        htab,
                        input_bfd,
                        rel,
                        0 as libc::c_int != 0,
                    );
                    if h.is_null() {
                        _bfd_abort(
                            b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                            2171 as libc::c_int,
                            (*::core::mem::transmute::<
                                &[u8; 146],
                                &[libc::c_char; 146],
                            >(
                                b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                    (*h).root.u.def.value = (*sym).st_value;
                    (*h).root.u.def.section = sec;
                }
            } else {
                let mut warned: bool = false;
                let mut ignored: bool = false;
                if sym_hashes.is_null() {
                    return 0 as libc::c_int;
                }
                h = *sym_hashes
                    .offset(
                        r_symndx.wrapping_sub((*symtab_hdr).sh_info as libc::c_ulong)
                            as isize,
                    );
                if !((*info).wrap_hash).is_null()
                    && (*input_section).flags & 0x2000 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                {
                    h = unwrap_hash_lookup(info, input_bfd, &mut (*h).root)
                        as *mut elf_link_hash_entry;
                }
                while ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_indirect as libc::c_int
                    || ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_warning as libc::c_int
                {
                    h = (*h).root.u.i.link as *mut elf_link_hash_entry;
                }
                warned = 0 as libc::c_int != 0;
                ignored = 0 as libc::c_int != 0;
                unresolved_reloc = 0 as libc::c_int != 0;
                relocation = 0 as libc::c_int as bfd_vma;
                if ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_defined as libc::c_int
                    || ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_defweak as libc::c_int
                {
                    sec = (*h).root.u.def.section;
                    if sec.is_null() || ((*sec).output_section).is_null() {
                        unresolved_reloc = 1 as libc::c_int != 0;
                    } else {
                        relocation = ((*h).root.u.def.value)
                            .wrapping_add((*(*sec).output_section).vma)
                            .wrapping_add((*sec).output_offset);
                    }
                } else if !(((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_undefweak as libc::c_int)
                {
                    if (*info).unresolved_syms_in_objects() as libc::c_int
                        == RM_IGNORE as libc::c_int
                        && (*h).other() as libc::c_int & 0x3 as libc::c_int
                            == 0 as libc::c_int
                    {
                        ignored = 1 as libc::c_int != 0;
                    } else if !((*info).type_0() as libc::c_int
                        == type_relocatable as libc::c_int)
                    {
                        let mut err: bool = (*info).unresolved_syms_in_objects()
                            as libc::c_int == RM_DIAGNOSE as libc::c_int
                            && (*info).warn_unresolved_syms() == 0
                            || (*h).other() as libc::c_int & 0x3 as libc::c_int
                                != 0 as libc::c_int;
                        (Some(
                            ((*(*info).callbacks).undefined_symbol)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            info,
                            (*h).root.root.string,
                            input_bfd,
                            input_section,
                            (*rel).r_offset,
                            err,
                        );
                        warned = 1 as libc::c_int != 0;
                    }
                }
                st_size = (*h).size;
            }
            if !sec.is_null() && discarded_section(sec) as libc::c_int != 0 {
                _bfd_clear_contents(
                    howto,
                    input_bfd,
                    input_section,
                    contents,
                    (*rel).r_offset,
                );
                (*wrel).r_offset = (*rel).r_offset;
                (*wrel).r_info = 0 as libc::c_int as bfd_vma;
                (*wrel).r_addend = 0 as libc::c_int as bfd_vma;
                if (*info).type_0() as libc::c_int == type_relocatable as libc::c_int
                    && (*input_section).flags & 0x2000 as libc::c_int as libc::c_uint
                        != 0
                {
                    wrel = wrel.offset(-1);
                    wrel;
                }
            } else if (*info).type_0() as libc::c_int == type_relocatable as libc::c_int
            {
                if wrel != rel {
                    *wrel = *rel;
                }
            } else {
                eh = h as *mut elf_x86_link_hash_entry;
                if !h.is_null() && (*h).type_0() as libc::c_int == 10 as libc::c_int
                    && (*h).def_regular() as libc::c_int != 0
                {
                    let mut gotplt: *mut asection = 0 as *mut asection;
                    let mut base_got: *mut asection = 0 as *mut asection;
                    let mut plt_index: bfd_vma = 0;
                    let mut name: *const libc::c_char = 0 as *const libc::c_char;
                    if (*input_section).flags & 0x1 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        if (*((*input_section).used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_type == 7 as libc::c_int as libc::c_uint
                        {
                            current_block = 15582581812111903972;
                        } else if (*input_section).flags
                            & 0x2000 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        {
                            current_block = 1054647088692577877;
                        } else {
                            _bfd_abort(
                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                2238 as libc::c_int,
                                (*::core::mem::transmute::<
                                    &[u8; 146],
                                    &[libc::c_char; 146],
                                >(
                                    b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                ))
                                    .as_ptr(),
                            );
                        }
                    } else {
                        if !((*htab).elf.splt).is_null() {
                            if !((*htab).plt_second).is_null() {
                                resolved_plt = (*htab).plt_second;
                                plt_offset = (*eh).plt_second.offset;
                            } else {
                                resolved_plt = (*htab).elf.splt;
                                plt_offset = (*h).plt.offset;
                            }
                            gotplt = (*htab).elf.sgotplt;
                        } else {
                            resolved_plt = (*htab).elf.iplt;
                            plt_offset = (*h).plt.offset;
                            gotplt = (*htab).elf.igotplt;
                        }
                        match r_type {
                            3 | 43 => {
                                base_got = (*htab).elf.sgot;
                                off = (*h).got.offset;
                                if base_got.is_null() {
                                    _bfd_abort(
                                        b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                        2274 as libc::c_int,
                                        (*::core::mem::transmute::<
                                            &[u8; 146],
                                            &[libc::c_char; 146],
                                        >(
                                            b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                        ))
                                            .as_ptr(),
                                    );
                                }
                                if off == -(1 as libc::c_int) as bfd_vma {
                                    if (*h).plt.offset == -(1 as libc::c_int) as bfd_vma {
                                        _bfd_abort(
                                            b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                            2283 as libc::c_int,
                                            (*::core::mem::transmute::<
                                                &[u8; 146],
                                                &[libc::c_char; 146],
                                            >(
                                                b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                            ))
                                                .as_ptr(),
                                        );
                                    }
                                    if !((*htab).elf.splt).is_null() {
                                        plt_index = ((*h).plt.offset)
                                            .wrapping_div(plt_entry_size as libc::c_ulong)
                                            .wrapping_sub((*htab).plt.has_plt0 as libc::c_ulong);
                                        off = plt_index
                                            .wrapping_add(3 as libc::c_int as libc::c_ulong)
                                            .wrapping_mul(4 as libc::c_int as libc::c_ulong);
                                        base_got = (*htab).elf.sgotplt;
                                    } else {
                                        plt_index = ((*h).plt.offset)
                                            .wrapping_div(plt_entry_size as libc::c_ulong);
                                        off = plt_index
                                            .wrapping_mul(4 as libc::c_int as libc::c_ulong);
                                        base_got = (*htab).elf.igotplt;
                                    }
                                    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long
                                        || (*h).forced_local() as libc::c_int != 0
                                        || (*info).symbolic() as libc::c_int != 0
                                    {
                                        if off & 1 as libc::c_int as libc::c_ulong
                                            != 0 as libc::c_int as libc::c_ulong
                                        {
                                            off &= !(1 as libc::c_int) as libc::c_ulong;
                                        } else {
                                            (Some(
                                                ((*(*output_bfd).xvec).bfd_putx32)
                                                    .expect("non-null function pointer"),
                                            ))
                                                .expect(
                                                    "non-null function pointer",
                                                )(
                                                relocation,
                                                ((*base_got).contents).offset(off as isize)
                                                    as *mut libc::c_void,
                                            );
                                            (*h).got.offset |= 1 as libc::c_int as libc::c_ulong;
                                        }
                                    }
                                    relocation = off;
                                } else {
                                    relocation = ((*(*base_got).output_section).vma)
                                        .wrapping_add((*base_got).output_offset)
                                        .wrapping_add(off)
                                        .wrapping_sub((*(*gotplt).output_section).vma)
                                        .wrapping_sub((*gotplt).output_offset);
                                }
                                if (*rel).r_offset > 1 as libc::c_int as libc::c_ulong
                                    && *contents
                                        .offset((*rel).r_offset as isize)
                                        .offset(-(1 as libc::c_int as isize)) as libc::c_int
                                        & 0xc7 as libc::c_int == 0x5 as libc::c_int
                                    && *contents
                                        .offset((*rel).r_offset as isize)
                                        .offset(-(2 as libc::c_int as isize)) as libc::c_int
                                        != 0x8d as libc::c_int
                                {
                                    if (*info).type_0() as libc::c_int
                                        == type_dll as libc::c_int
                                        || (*info).type_0() as libc::c_int
                                            == type_pie as libc::c_int
                                    {
                                        current_block = 13418714505947323240;
                                    } else {
                                        relocation = (relocation as libc::c_ulong)
                                            .wrapping_add(
                                                ((*(*gotplt).output_section).vma)
                                                    .wrapping_add((*gotplt).output_offset),
                                            ) as bfd_vma as bfd_vma;
                                        current_block = 10641344571278079028;
                                    }
                                } else {
                                    if ((*htab).elf.splt).is_null() {
                                        relocation = (relocation as libc::c_ulong)
                                            .wrapping_add((*gotplt).output_offset) as bfd_vma
                                            as bfd_vma;
                                    }
                                    current_block = 10641344571278079028;
                                }
                            }
                            _ => {
                                if (*h).plt.offset == -(1 as libc::c_int) as bfd_vma {
                                    if r_type == R_386_32 as libc::c_int as libc::c_uint
                                        && (*input_section).flags
                                            & 0x10 as libc::c_int as libc::c_uint
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        current_block = 4300256962525374788;
                                    } else {
                                        current_block = 1352014687757861304;
                                    }
                                } else {
                                    relocation = ((*(*resolved_plt).output_section).vma)
                                        .wrapping_add((*resolved_plt).output_offset)
                                        .wrapping_add(plt_offset);
                                    match r_type {
                                        1 => {
                                            current_block = 3154811413700226090;
                                            match current_block {
                                                2196671332679918212 => {
                                                    relocation = (relocation as libc::c_ulong)
                                                        .wrapping_sub(
                                                            ((*(*gotplt).output_section).vma)
                                                                .wrapping_add((*gotplt).output_offset),
                                                        ) as bfd_vma as bfd_vma;
                                                    current_block = 10641344571278079028;
                                                }
                                                _ => {
                                                    if ((*info).type_0() as libc::c_int
                                                        == type_dll as libc::c_int
                                                        || (*info).type_0() as libc::c_int
                                                            == type_pie as libc::c_int)
                                                        && (*h).non_got_ref() as libc::c_int != 0
                                                        || (*h).plt.offset == -(1 as libc::c_int) as bfd_vma
                                                    {
                                                        outrel = Elf_Internal_Rela {
                                                            r_offset: 0,
                                                            r_info: 0,
                                                            r_addend: 0,
                                                        };
                                                        sreloc = 0 as *mut asection;
                                                        offset = 0;
                                                        current_block = 4300256962525374788;
                                                    } else {
                                                        current_block = 10641344571278079028;
                                                    }
                                                }
                                            }
                                        }
                                        2 | 4 => {
                                            current_block = 10641344571278079028;
                                        }
                                        9 => {
                                            current_block = 2196671332679918212;
                                            match current_block {
                                                2196671332679918212 => {
                                                    relocation = (relocation as libc::c_ulong)
                                                        .wrapping_sub(
                                                            ((*(*gotplt).output_section).vma)
                                                                .wrapping_add((*gotplt).output_offset),
                                                        ) as bfd_vma as bfd_vma;
                                                    current_block = 10641344571278079028;
                                                }
                                                _ => {
                                                    if ((*info).type_0() as libc::c_int
                                                        == type_dll as libc::c_int
                                                        || (*info).type_0() as libc::c_int
                                                            == type_pie as libc::c_int)
                                                        && (*h).non_got_ref() as libc::c_int != 0
                                                        || (*h).plt.offset == -(1 as libc::c_int) as bfd_vma
                                                    {
                                                        outrel = Elf_Internal_Rela {
                                                            r_offset: 0,
                                                            r_info: 0,
                                                            r_addend: 0,
                                                        };
                                                        sreloc = 0 as *mut asection;
                                                        offset = 0;
                                                        current_block = 4300256962525374788;
                                                    } else {
                                                        current_block = 10641344571278079028;
                                                    }
                                                }
                                            }
                                        }
                                        _ => {
                                            current_block = 1352014687757861304;
                                        }
                                    }
                                }
                                match current_block {
                                    10641344571278079028 => {}
                                    _ => {
                                        match current_block {
                                            1352014687757861304 => {
                                                if !((*h).root.root.string).is_null() {
                                                    name = (*h).root.root.string;
                                                } else {
                                                    name = bfd_elf_sym_name(
                                                        input_bfd,
                                                        symtab_hdr,
                                                        sym,
                                                        0 as *mut asection,
                                                    );
                                                }
                                                _bfd_error_handler(
                                                    dcgettext(
                                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                                        b"%pB: relocation %s against STT_GNU_IFUNC symbol `%s' isn't supported\0"
                                                            as *const u8 as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    input_bfd,
                                                    (*howto).name,
                                                    name,
                                                );
                                                bfd_set_error(bfd_error_bad_value);
                                                return 0 as libc::c_int;
                                            }
                                            _ => {
                                                offset = _bfd_elf_section_offset(
                                                    output_bfd,
                                                    info,
                                                    input_section,
                                                    (*rel).r_offset,
                                                );
                                                if offset == -(1 as libc::c_int) as bfd_vma
                                                    || offset == -(2 as libc::c_int) as bfd_vma
                                                {
                                                    _bfd_abort(
                                                        b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                        2398 as libc::c_int,
                                                        (*::core::mem::transmute::<
                                                            &[u8; 146],
                                                            &[libc::c_char; 146],
                                                        >(
                                                            b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                        ))
                                                            .as_ptr(),
                                                    );
                                                }
                                                outrel
                                                    .r_offset = ((*(*input_section).output_section).vma)
                                                    .wrapping_add((*input_section).output_offset)
                                                    .wrapping_add(offset);
                                                if (*h).dynindx == -(1 as libc::c_int) as libc::c_long
                                                    || (*h).forced_local() as libc::c_int != 0
                                                    || ((*info).type_0() as libc::c_int
                                                        == type_pde as libc::c_int
                                                        || (*info).type_0() as libc::c_int
                                                            == type_pie as libc::c_int)
                                                {
                                                    ((*(*info).callbacks).minfo)
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(
                                                        dcgettext(
                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                            b"Local IFUNC function `%s' in %pB\n\0" as *const u8
                                                                as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                        (*h).root.root.string,
                                                        (*(*h).root.u.def.section).owner,
                                                    );
                                                    outrel
                                                        .r_info = ((0 as libc::c_int as libc::c_uint)
                                                        << 8 as libc::c_int)
                                                        .wrapping_add(
                                                            (R_386_IRELATIVE as libc::c_int & 0xff as libc::c_int)
                                                                as libc::c_uint,
                                                        ) as bfd_vma;
                                                    if (*(*htab).params).report_relative_reloc() != 0 {
                                                        _bfd_x86_elf_link_report_relative_reloc(
                                                            info,
                                                            input_section,
                                                            h,
                                                            sym,
                                                            b"R_386_IRELATIVE\0" as *const u8 as *const libc::c_char,
                                                            &mut outrel as *mut Elf_Internal_Rela as *const libc::c_void,
                                                        );
                                                    }
                                                    (Some(
                                                        ((*(*output_bfd).xvec).bfd_putx32)
                                                            .expect("non-null function pointer"),
                                                    ))
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(
                                                        ((*h).root.u.def.value)
                                                            .wrapping_add(
                                                                (*(*(*h).root.u.def.section).output_section).vma,
                                                            )
                                                            .wrapping_add((*(*h).root.u.def.section).output_offset),
                                                        contents.offset(offset as isize) as *mut libc::c_void,
                                                    );
                                                } else {
                                                    outrel
                                                        .r_info = (((*h).dynindx as libc::c_uint)
                                                        << 8 as libc::c_int)
                                                        .wrapping_add(r_type & 0xff as libc::c_int as libc::c_uint)
                                                        as bfd_vma;
                                                }
                                                if (*info).type_0() as libc::c_int
                                                    == type_dll as libc::c_int
                                                    || (*info).type_0() as libc::c_int
                                                        == type_pie as libc::c_int
                                                {
                                                    sreloc = (*htab).elf.irelifunc;
                                                } else if !((*htab).elf.splt).is_null() {
                                                    sreloc = (*htab).elf.srelgot;
                                                } else {
                                                    sreloc = (*htab).elf.irelplt;
                                                }
                                                elf_append_rel(output_bfd, sreloc, &mut outrel);
                                            }
                                        }
                                        current_block = 1054647088692577877;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    current_block = 15582581812111903972;
                }
                match current_block {
                    1054647088692577877 => {}
                    _ => {
                        match current_block {
                            15582581812111903972 => {
                                resolved_to_zero = !eh.is_null()
                                    && (((*eh).elf.root).type_0() as libc::c_int
                                        == bfd_link_hash_undefweak as libc::c_int
                                        && (_bfd_x86_elf_link_symbol_references_local(
                                            info,
                                            &mut (*eh).elf,
                                        ) as libc::c_int != 0
                                            || ((*info).type_0() as libc::c_int
                                                == type_pde as libc::c_int
                                                || (*info).type_0() as libc::c_int
                                                    == type_pie as libc::c_int)
                                                && (*eh).zero_undefweak() as libc::c_int
                                                    > 0 as libc::c_int));
                                match r_type {
                                    43 | 3 => {
                                        if ((*htab).elf.sgot).is_null() {
                                            _bfd_abort(
                                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                2469 as libc::c_int,
                                                (*::core::mem::transmute::<
                                                    &[u8; 146],
                                                    &[libc::c_char; 146],
                                                >(
                                                    b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                ))
                                                    .as_ptr(),
                                            );
                                        }
                                        relative_reloc = 0 as libc::c_int != 0;
                                        if !h.is_null() {
                                            off = (*h).got.offset;
                                            if !((*htab).elf.dynamic_sections_created as libc::c_int
                                                != 0
                                                && ((*info).type_0() as libc::c_int
                                                    == type_dll as libc::c_int
                                                    || (*info).type_0() as libc::c_int
                                                        == type_pie as libc::c_int || (*h).forced_local() == 0)
                                                && ((*h).dynindx != -(1 as libc::c_int) as libc::c_long
                                                    || (*h).forced_local() as libc::c_int != 0))
                                                || ((*info).type_0() as libc::c_int
                                                    == type_dll as libc::c_int
                                                    || (*info).type_0() as libc::c_int
                                                        == type_pie as libc::c_int)
                                                    && _bfd_x86_elf_link_symbol_references_local(info, h)
                                                        as libc::c_int != 0
                                                || (*h).other() as libc::c_int & 0x3 as libc::c_int != 0
                                                    && ((*h).root).type_0() as libc::c_int
                                                        == bfd_link_hash_undefweak as libc::c_int
                                            {
                                                if off & 1 as libc::c_int as libc::c_ulong
                                                    != 0 as libc::c_int as libc::c_ulong
                                                {
                                                    off &= !(1 as libc::c_int) as libc::c_ulong;
                                                } else {
                                                    (Some(
                                                        ((*(*output_bfd).xvec).bfd_putx32)
                                                            .expect("non-null function pointer"),
                                                    ))
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(
                                                        relocation,
                                                        ((*(*htab).elf.sgot).contents).offset(off as isize)
                                                            as *mut libc::c_void,
                                                    );
                                                    (*h).got.offset |= 1 as libc::c_int as libc::c_ulong;
                                                    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long
                                                        && (*h).forced_local() == 0
                                                        && ((*h).root).type_0() as libc::c_int
                                                            != bfd_link_hash_undefweak as libc::c_int
                                                        && ((*info).type_0() as libc::c_int
                                                            == type_dll as libc::c_int
                                                            || (*info).type_0() as libc::c_int
                                                                == type_pie as libc::c_int)
                                                        && !((((*h).root).type_0() as libc::c_int
                                                            == bfd_link_hash_defined as libc::c_int
                                                            || ((*h).root).type_0() as libc::c_int
                                                                == bfd_link_hash_defweak as libc::c_int)
                                                            && bfd_is_abs_section((*h).root.u.def.section)
                                                                as libc::c_int != 0 && ((*h).root).rel_from_abs() == 0
                                                            && ((*h).root).ldscript_def() == 0)
                                                    {
                                                        (*eh)
                                                            .set_no_finish_dynamic_symbol(
                                                                1 as libc::c_int as libc::c_uint,
                                                            );
                                                        relative_reloc = 1 as libc::c_int != 0;
                                                    }
                                                }
                                            } else {
                                                unresolved_reloc = 0 as libc::c_int != 0;
                                            }
                                        } else {
                                            if local_got_offsets.is_null() {
                                                _bfd_abort(
                                                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                    2508 as libc::c_int,
                                                    (*::core::mem::transmute::<
                                                        &[u8; 146],
                                                        &[libc::c_char; 146],
                                                    >(
                                                        b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                    ))
                                                        .as_ptr(),
                                                );
                                            }
                                            off = *local_got_offsets.offset(r_symndx as isize);
                                            if off & 1 as libc::c_int as libc::c_ulong
                                                != 0 as libc::c_int as libc::c_ulong
                                            {
                                                off &= !(1 as libc::c_int) as libc::c_ulong;
                                            } else {
                                                (Some(
                                                    ((*(*output_bfd).xvec).bfd_putx32)
                                                        .expect("non-null function pointer"),
                                                ))
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(
                                                    relocation,
                                                    ((*(*htab).elf.sgot).contents).offset(off as isize)
                                                        as *mut libc::c_void,
                                                );
                                                let ref mut fresh4 = *local_got_offsets
                                                    .offset(r_symndx as isize);
                                                *fresh4 |= 1 as libc::c_int as libc::c_ulong;
                                                if (*info).type_0() as libc::c_int
                                                    == type_dll as libc::c_int
                                                    || (*info).type_0() as libc::c_int
                                                        == type_pie as libc::c_int
                                                {
                                                    relative_reloc = 1 as libc::c_int != 0;
                                                }
                                            }
                                        }
                                        if relative_reloc {
                                            let mut s: *mut asection = 0 as *mut asection;
                                            let mut outrel_0: Elf_Internal_Rela = Elf_Internal_Rela {
                                                r_offset: 0,
                                                r_info: 0,
                                                r_addend: 0,
                                            };
                                            s = (*htab).elf.srelgot;
                                            if s.is_null() {
                                                _bfd_abort(
                                                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                    2535 as libc::c_int,
                                                    (*::core::mem::transmute::<
                                                        &[u8; 146],
                                                        &[libc::c_char; 146],
                                                    >(
                                                        b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                    ))
                                                        .as_ptr(),
                                                );
                                            }
                                            outrel_0
                                                .r_offset = ((*(*(*htab).elf.sgot).output_section).vma)
                                                .wrapping_add((*(*htab).elf.sgot).output_offset)
                                                .wrapping_add(off);
                                            outrel_0
                                                .r_info = ((0 as libc::c_int as libc::c_uint)
                                                << 8 as libc::c_int)
                                                .wrapping_add(
                                                    (R_386_RELATIVE as libc::c_int & 0xff as libc::c_int)
                                                        as libc::c_uint,
                                                ) as bfd_vma;
                                            if (*(*htab).params).report_relative_reloc() != 0 {
                                                _bfd_x86_elf_link_report_relative_reloc(
                                                    info,
                                                    input_section,
                                                    h,
                                                    sym,
                                                    b"R_386_RELATIVE\0" as *const u8 as *const libc::c_char,
                                                    &mut outrel_0 as *mut Elf_Internal_Rela
                                                        as *const libc::c_void,
                                                );
                                            }
                                            elf_append_rel(output_bfd, s, &mut outrel_0);
                                        }
                                        if off >= -(2 as libc::c_int) as bfd_vma {
                                            _bfd_abort(
                                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                2551 as libc::c_int,
                                                (*::core::mem::transmute::<
                                                    &[u8; 146],
                                                    &[libc::c_char; 146],
                                                >(
                                                    b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                ))
                                                    .as_ptr(),
                                            );
                                        }
                                        relocation = ((*(*(*htab).elf.sgot).output_section).vma)
                                            .wrapping_add((*(*htab).elf.sgot).output_offset)
                                            .wrapping_add(off);
                                        if (*rel).r_offset > 1 as libc::c_int as libc::c_ulong
                                            && *contents
                                                .offset((*rel).r_offset as isize)
                                                .offset(-(1 as libc::c_int as isize)) as libc::c_int
                                                & 0xc7 as libc::c_int == 0x5 as libc::c_int
                                            && *contents
                                                .offset((*rel).r_offset as isize)
                                                .offset(-(2 as libc::c_int as isize)) as libc::c_int
                                                != 0x8d as libc::c_int
                                        {
                                            if (*info).type_0() as libc::c_int
                                                == type_dll as libc::c_int
                                                || (*info).type_0() as libc::c_int
                                                    == type_pie as libc::c_int
                                            {
                                                name_0 = 0 as *const libc::c_char;
                                                current_block = 13418714505947323240;
                                            } else {
                                                current_block = 966498249569804311;
                                            }
                                        } else {
                                            relocation = (relocation as libc::c_ulong)
                                                .wrapping_sub(
                                                    ((*(*(*htab).elf.sgotplt).output_section).vma)
                                                        .wrapping_add((*(*htab).elf.sgotplt).output_offset),
                                                ) as bfd_vma as bfd_vma;
                                            current_block = 966498249569804311;
                                        }
                                    }
                                    9 => {
                                        if !((*info).type_0() as libc::c_int
                                            == type_pde as libc::c_int
                                            || (*info).type_0() as libc::c_int
                                                == type_pie as libc::c_int) && !h.is_null()
                                        {
                                            if (*h).def_regular() == 0 {
                                                let mut v: *const libc::c_char = 0 as *const libc::c_char;
                                                match (*h).other() as libc::c_int & 0x3 as libc::c_int {
                                                    2 => {
                                                        v = dcgettext(
                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                            b"hidden symbol\0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        );
                                                    }
                                                    1 => {
                                                        v = dcgettext(
                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                            b"internal symbol\0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        );
                                                    }
                                                    3 => {
                                                        v = dcgettext(
                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                            b"protected symbol\0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        );
                                                    }
                                                    _ => {
                                                        v = dcgettext(
                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                            b"symbol\0" as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        );
                                                    }
                                                }
                                                _bfd_error_handler(
                                                    dcgettext(
                                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                                        b"%pB: relocation R_386_GOTOFF against undefined %s `%s' can not be used when making a shared object\0"
                                                            as *const u8 as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    input_bfd,
                                                    v,
                                                    (*h).root.root.string,
                                                );
                                                bfd_set_error(bfd_error_bad_value);
                                                return 0 as libc::c_int;
                                            } else if !_bfd_x86_elf_link_symbol_references_local(
                                                info,
                                                h,
                                            )
                                                && ((*h).type_0() as libc::c_int == 2 as libc::c_int
                                                    || (*h).type_0() as libc::c_int == 1 as libc::c_int)
                                                && (*h).other() as libc::c_int & 0x3 as libc::c_int
                                                    == 3 as libc::c_int
                                            {
                                                _bfd_error_handler(
                                                    dcgettext(
                                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                                        b"%pB: relocation R_386_GOTOFF against protected %s `%s' can not be used when making a shared object\0"
                                                            as *const u8 as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    input_bfd,
                                                    if (*h).type_0() as libc::c_int == 2 as libc::c_int {
                                                        b"function\0" as *const u8 as *const libc::c_char
                                                    } else {
                                                        b"data\0" as *const u8 as *const libc::c_char
                                                    },
                                                    (*h).root.root.string,
                                                );
                                                bfd_set_error(bfd_error_bad_value);
                                                return 0 as libc::c_int;
                                            }
                                        }
                                        relocation = (relocation as libc::c_ulong)
                                            .wrapping_sub(
                                                ((*(*(*htab).elf.sgotplt).output_section).vma)
                                                    .wrapping_add((*(*htab).elf.sgotplt).output_offset),
                                            ) as bfd_vma as bfd_vma;
                                        current_block = 966498249569804311;
                                    }
                                    10 => {
                                        relocation = ((*(*(*htab).elf.sgotplt).output_section).vma)
                                            .wrapping_add((*(*htab).elf.sgotplt).output_offset);
                                        unresolved_reloc = 0 as libc::c_int != 0;
                                        current_block = 966498249569804311;
                                    }
                                    4 => {
                                        if h.is_null() {
                                            current_block = 966498249569804311;
                                        } else if (*h).plt.offset == -(1 as libc::c_int) as bfd_vma
                                            && (*eh).plt_got.offset == -(1 as libc::c_int) as bfd_vma
                                            || ((*htab).elf.splt).is_null()
                                        {
                                            current_block = 966498249569804311;
                                        } else {
                                            if (*h).plt.offset != -(1 as libc::c_int) as bfd_vma {
                                                if !((*htab).plt_second).is_null() {
                                                    resolved_plt = (*htab).plt_second;
                                                    plt_offset = (*eh).plt_second.offset;
                                                } else {
                                                    resolved_plt = (*htab).elf.splt;
                                                    plt_offset = (*h).plt.offset;
                                                }
                                            } else {
                                                resolved_plt = (*htab).plt_got;
                                                plt_offset = (*eh).plt_got.offset;
                                            }
                                            relocation = ((*(*resolved_plt).output_section).vma)
                                                .wrapping_add((*resolved_plt).output_offset)
                                                .wrapping_add(plt_offset);
                                            unresolved_reloc = 0 as libc::c_int != 0;
                                            current_block = 966498249569804311;
                                        }
                                    }
                                    38 => {
                                        relocation = st_size;
                                        current_block = 13573926323309413337;
                                    }
                                    1 | 2 => {
                                        current_block = 13573926323309413337;
                                    }
                                    15 => {
                                        if !((*info).type_0() as libc::c_int
                                            == type_pde as libc::c_int
                                            || (*info).type_0() as libc::c_int
                                                == type_pie as libc::c_int)
                                        {
                                            let mut outrel_2: Elf_Internal_Rela = Elf_Internal_Rela {
                                                r_offset: 0,
                                                r_info: 0,
                                                r_addend: 0,
                                            };
                                            let mut sreloc_1: *mut asection = 0 as *mut asection;
                                            outrel_2
                                                .r_offset = ((*rel).r_offset)
                                                .wrapping_add((*(*input_section).output_section).vma)
                                                .wrapping_add((*input_section).output_offset);
                                            outrel_2
                                                .r_info = ((0 as libc::c_int as libc::c_uint)
                                                << 8 as libc::c_int)
                                                .wrapping_add(
                                                    (R_386_RELATIVE as libc::c_int & 0xff as libc::c_int)
                                                        as libc::c_uint,
                                                ) as bfd_vma;
                                            if (*(*htab).params).report_relative_reloc() != 0 {
                                                _bfd_x86_elf_link_report_relative_reloc(
                                                    info,
                                                    input_section,
                                                    h,
                                                    sym,
                                                    b"R_386_RELATIVE\0" as *const u8 as *const libc::c_char,
                                                    &mut outrel_2 as *mut Elf_Internal_Rela
                                                        as *const libc::c_void,
                                                );
                                            }
                                            sreloc_1 = (*((*input_section).used_by_bfd
                                                as *mut bfd_elf_section_data))
                                                .sreloc;
                                            if sreloc_1.is_null() {
                                                _bfd_abort(
                                                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                    2797 as libc::c_int,
                                                    (*::core::mem::transmute::<
                                                        &[u8; 146],
                                                        &[libc::c_char; 146],
                                                    >(
                                                        b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                    ))
                                                        .as_ptr(),
                                                );
                                            }
                                            elf_append_rel(output_bfd, sreloc_1, &mut outrel_2);
                                        }
                                        current_block = 14269709438892843349;
                                    }
                                    18 | 39 | 40 | 33 | 16 => {
                                        current_block = 14269709438892843349;
                                    }
                                    19 => {
                                        if !elf_i386_tls_transition(
                                            info,
                                            input_bfd,
                                            input_section,
                                            contents,
                                            symtab_hdr,
                                            sym_hashes,
                                            &mut r_type,
                                            0 as libc::c_int,
                                            rel,
                                            relend,
                                            h,
                                            r_symndx,
                                            1 as libc::c_int != 0,
                                        ) {
                                            return 0 as libc::c_int;
                                        }
                                        if r_type != R_386_TLS_LDM as libc::c_int as libc::c_uint {
                                            if !(r_type
                                                == R_386_TLS_LE_32 as libc::c_int as libc::c_uint)
                                            {
                                                bfd_assert(
                                                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                    3322 as libc::c_int,
                                                );
                                            }
                                            if *contents
                                                .offset((*rel).r_offset as isize)
                                                .offset(4 as libc::c_int as isize) as libc::c_int
                                                == 0xff as libc::c_int
                                                || *contents
                                                    .offset((*rel).r_offset as isize)
                                                    .offset(4 as libc::c_int as isize) as libc::c_int
                                                    == 0x67 as libc::c_int
                                            {
                                                memcpy(
                                                    contents
                                                        .offset((*rel).r_offset as isize)
                                                        .offset(-(2 as libc::c_int as isize)) as *mut libc::c_void,
                                                    b"e\xA1\0\0\0\0\x8D\xB6\0\0\0\0" as *const u8
                                                        as *const libc::c_char as *const libc::c_void,
                                                    12 as libc::c_int as libc::c_ulong,
                                                );
                                            } else {
                                                memcpy(
                                                    contents
                                                        .offset((*rel).r_offset as isize)
                                                        .offset(-(2 as libc::c_int as isize)) as *mut libc::c_void,
                                                    b"e\xA1\0\0\0\0\x90\x8Dt&\0" as *const u8
                                                        as *const libc::c_char as *const libc::c_void,
                                                    11 as libc::c_int as libc::c_ulong,
                                                );
                                            }
                                            rel = rel.offset(1);
                                            rel;
                                            wrel = wrel.offset(1);
                                            wrel;
                                            current_block = 1054647088692577877;
                                        } else {
                                            if ((*htab).elf.sgot).is_null() {
                                                _bfd_abort(
                                                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                    3337 as libc::c_int,
                                                    (*::core::mem::transmute::<
                                                        &[u8; 146],
                                                        &[libc::c_char; 146],
                                                    >(
                                                        b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                    ))
                                                        .as_ptr(),
                                                );
                                            }
                                            off = (*htab).tls_ld_or_ldm_got.offset;
                                            if off & 1 as libc::c_int as libc::c_ulong != 0 {
                                                off &= !(1 as libc::c_int) as libc::c_ulong;
                                            } else {
                                                let mut outrel_4: Elf_Internal_Rela = Elf_Internal_Rela {
                                                    r_offset: 0,
                                                    r_info: 0,
                                                    r_addend: 0,
                                                };
                                                if ((*htab).elf.srelgot).is_null() {
                                                    _bfd_abort(
                                                        b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                        3347 as libc::c_int,
                                                        (*::core::mem::transmute::<
                                                            &[u8; 146],
                                                            &[libc::c_char; 146],
                                                        >(
                                                            b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                        ))
                                                            .as_ptr(),
                                                    );
                                                }
                                                outrel_4
                                                    .r_offset = ((*(*(*htab).elf.sgot).output_section).vma)
                                                    .wrapping_add((*(*htab).elf.sgot).output_offset)
                                                    .wrapping_add(off);
                                                (Some(
                                                    ((*(*output_bfd).xvec).bfd_putx32)
                                                        .expect("non-null function pointer"),
                                                ))
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(
                                                    0 as libc::c_int as bfd_vma,
                                                    ((*(*htab).elf.sgot).contents).offset(off as isize)
                                                        as *mut libc::c_void,
                                                );
                                                (Some(
                                                    ((*(*output_bfd).xvec).bfd_putx32)
                                                        .expect("non-null function pointer"),
                                                ))
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(
                                                    0 as libc::c_int as bfd_vma,
                                                    ((*(*htab).elf.sgot).contents)
                                                        .offset(off as isize)
                                                        .offset(4 as libc::c_int as isize) as *mut libc::c_void,
                                                );
                                                outrel_4
                                                    .r_info = ((0 as libc::c_int as libc::c_uint)
                                                    << 8 as libc::c_int)
                                                    .wrapping_add(
                                                        (R_386_TLS_DTPMOD32 as libc::c_int & 0xff as libc::c_int)
                                                            as libc::c_uint,
                                                    ) as bfd_vma;
                                                elf_append_rel(
                                                    output_bfd,
                                                    (*htab).elf.srelgot,
                                                    &mut outrel_4,
                                                );
                                                (*htab).tls_ld_or_ldm_got.offset
                                                    |= 1 as libc::c_int as libc::c_ulong;
                                            }
                                            relocation = ((*(*(*htab).elf.sgot).output_section).vma)
                                                .wrapping_add((*(*htab).elf.sgot).output_offset)
                                                .wrapping_add(off)
                                                .wrapping_sub((*(*(*htab).elf.sgotplt).output_section).vma)
                                                .wrapping_sub((*(*htab).elf.sgotplt).output_offset);
                                            unresolved_reloc = 0 as libc::c_int != 0;
                                            current_block = 966498249569804311;
                                        }
                                    }
                                    32 => {
                                        if !((*info).type_0() as libc::c_int
                                            == type_pde as libc::c_int
                                            || (*info).type_0() as libc::c_int
                                                == type_pie as libc::c_int)
                                            || (*input_section).flags
                                                & 0x10 as libc::c_int as libc::c_uint
                                                == 0 as libc::c_int as libc::c_uint
                                        {
                                            relocation = (relocation as libc::c_ulong)
                                                .wrapping_sub(_bfd_x86_elf_dtpoff_base(info)) as bfd_vma
                                                as bfd_vma;
                                        } else {
                                            relocation = (elf_i386_tpoff(info, relocation))
                                                .wrapping_neg();
                                        }
                                        current_block = 966498249569804311;
                                    }
                                    34 | 17 => {
                                        if !((*info).type_0() as libc::c_int
                                            == type_pde as libc::c_int
                                            || (*info).type_0() as libc::c_int
                                                == type_pie as libc::c_int)
                                        {
                                            let mut outrel_5: Elf_Internal_Rela = Elf_Internal_Rela {
                                                r_offset: 0,
                                                r_info: 0,
                                                r_addend: 0,
                                            };
                                            let mut sreloc_3: *mut asection = 0 as *mut asection;
                                            outrel_5
                                                .r_offset = ((*rel).r_offset)
                                                .wrapping_add((*(*input_section).output_section).vma)
                                                .wrapping_add((*input_section).output_offset);
                                            if !h.is_null()
                                                && (*h).dynindx != -(1 as libc::c_int) as libc::c_long
                                            {
                                                indx = (*h).dynindx as libc::c_uint;
                                            } else {
                                                indx = 0 as libc::c_int as libc::c_uint;
                                            }
                                            if r_type == R_386_TLS_LE_32 as libc::c_int as libc::c_uint
                                            {
                                                outrel_5
                                                    .r_info = (indx << 8 as libc::c_int)
                                                    .wrapping_add(
                                                        (R_386_TLS_TPOFF32 as libc::c_int & 0xff as libc::c_int)
                                                            as libc::c_uint,
                                                    ) as bfd_vma;
                                            } else {
                                                outrel_5
                                                    .r_info = (indx << 8 as libc::c_int)
                                                    .wrapping_add(
                                                        (R_386_TLS_TPOFF as libc::c_int & 0xff as libc::c_int)
                                                            as libc::c_uint,
                                                    ) as bfd_vma;
                                            }
                                            sreloc_3 = (*((*input_section).used_by_bfd
                                                as *mut bfd_elf_section_data))
                                                .sreloc;
                                            if sreloc_3.is_null() {
                                                _bfd_abort(
                                                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                    3396 as libc::c_int,
                                                    (*::core::mem::transmute::<
                                                        &[u8; 146],
                                                        &[libc::c_char; 146],
                                                    >(
                                                        b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                    ))
                                                        .as_ptr(),
                                                );
                                            }
                                            elf_append_rel(output_bfd, sreloc_3, &mut outrel_5);
                                            if indx != 0 {
                                                current_block = 1054647088692577877;
                                            } else {
                                                if r_type == R_386_TLS_LE_32 as libc::c_int as libc::c_uint
                                                {
                                                    relocation = (_bfd_x86_elf_dtpoff_base(info))
                                                        .wrapping_sub(relocation);
                                                } else {
                                                    relocation = (relocation as libc::c_ulong)
                                                        .wrapping_sub(_bfd_x86_elf_dtpoff_base(info)) as bfd_vma
                                                        as bfd_vma;
                                                }
                                                current_block = 966498249569804311;
                                            }
                                        } else {
                                            if r_type == R_386_TLS_LE_32 as libc::c_int as libc::c_uint
                                            {
                                                relocation = elf_i386_tpoff(info, relocation);
                                            } else {
                                                relocation = (elf_i386_tpoff(info, relocation))
                                                    .wrapping_neg();
                                            }
                                            current_block = 966498249569804311;
                                        }
                                    }
                                    _ => {
                                        current_block = 966498249569804311;
                                    }
                                }
                                match current_block {
                                    13418714505947323240 => {}
                                    1054647088692577877 => {}
                                    _ => {
                                        match current_block {
                                            14269709438892843349 => {
                                                tls_type = 0 as libc::c_int;
                                                if h.is_null() && !local_got_offsets.is_null() {
                                                    tls_type = *((*((*input_bfd).tdata.any
                                                        as *mut elf_x86_obj_tdata))
                                                        .local_got_tls_type)
                                                        .offset(r_symndx as isize) as libc::c_int;
                                                } else if !h.is_null() {
                                                    tls_type = (*(h as *mut elf_x86_link_hash_entry)).tls_type
                                                        as libc::c_int;
                                                }
                                                if tls_type == 4 as libc::c_int {
                                                    tls_type = 6 as libc::c_int;
                                                }
                                                r_type_tls = r_type;
                                                if !elf_i386_tls_transition(
                                                    info,
                                                    input_bfd,
                                                    input_section,
                                                    contents,
                                                    symtab_hdr,
                                                    sym_hashes,
                                                    &mut r_type_tls,
                                                    tls_type,
                                                    rel,
                                                    relend,
                                                    h,
                                                    r_symndx,
                                                    1 as libc::c_int != 0,
                                                ) {
                                                    return 0 as libc::c_int;
                                                }
                                                if r_type_tls
                                                    == R_386_TLS_LE_32 as libc::c_int as libc::c_uint
                                                {
                                                    if unresolved_reloc {
                                                        bfd_assert(
                                                            b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                            2825 as libc::c_int,
                                                        );
                                                    }
                                                    if r_type == R_386_TLS_GD as libc::c_int as libc::c_uint {
                                                        let mut type_0: libc::c_uint = 0;
                                                        let mut roff: bfd_vma = 0;
                                                        type_0 = *contents
                                                            .offset((*rel).r_offset as isize)
                                                            .offset(-(2 as libc::c_int as isize)) as libc::c_uint;
                                                        if type_0 == 0x4 as libc::c_int as libc::c_uint {
                                                            roff = ((*rel).r_offset)
                                                                .wrapping_add(5 as libc::c_int as libc::c_ulong);
                                                        } else {
                                                            roff = ((*rel).r_offset)
                                                                .wrapping_add(6 as libc::c_int as libc::c_ulong);
                                                        }
                                                        memcpy(
                                                            contents
                                                                .offset(roff as isize)
                                                                .offset(-(8 as libc::c_int as isize)) as *mut libc::c_void,
                                                            b"e\xA1\0\0\0\0\x81\xE8\0\0\0\0" as *const u8
                                                                as *const libc::c_char as *const libc::c_void,
                                                            12 as libc::c_int as libc::c_ulong,
                                                        );
                                                        (Some(
                                                            ((*(*output_bfd).xvec).bfd_putx32)
                                                                .expect("non-null function pointer"),
                                                        ))
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(
                                                            elf_i386_tpoff(info, relocation),
                                                            contents.offset(roff as isize) as *mut libc::c_void,
                                                        );
                                                        rel = rel.offset(1);
                                                        rel;
                                                        wrel = wrel.offset(1);
                                                        wrel;
                                                    } else if r_type
                                                        == R_386_TLS_GOTDESC as libc::c_int as libc::c_uint
                                                    {
                                                        let mut val: libc::c_uint = 0;
                                                        let mut roff_0: bfd_vma = 0;
                                                        roff_0 = (*rel).r_offset;
                                                        val = (*(contents
                                                            .offset(roff_0 as isize)
                                                            .offset(-(1 as libc::c_int as isize))
                                                            as *const libc::c_uchar) as bfd_vma
                                                            & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
                                                        *(contents
                                                            .offset(roff_0 as isize)
                                                            .offset(-(1 as libc::c_int as isize))
                                                            as *mut libc::c_uchar) = ((val
                                                            ^ 0x86 as libc::c_int as libc::c_uint)
                                                            & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
                                                        (Some(
                                                            ((*(*output_bfd).xvec).bfd_putx32)
                                                                .expect("non-null function pointer"),
                                                        ))
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(
                                                            (elf_i386_tpoff(info, relocation)).wrapping_neg(),
                                                            contents.offset(roff_0 as isize) as *mut libc::c_void,
                                                        );
                                                    } else if r_type
                                                        == R_386_TLS_DESC_CALL as libc::c_int as libc::c_uint
                                                    {
                                                        let mut roff_1: bfd_vma = 0;
                                                        roff_1 = (*rel).r_offset;
                                                        *(contents.offset(roff_1 as isize)
                                                            as *mut libc::c_uchar) = (0x66 as libc::c_int
                                                            & 0xff as libc::c_int) as libc::c_uchar;
                                                        *(contents
                                                            .offset(roff_1 as isize)
                                                            .offset(1 as libc::c_int as isize)
                                                            as *mut libc::c_uchar) = (0x90 as libc::c_int
                                                            & 0xff as libc::c_int) as libc::c_uchar;
                                                    } else if r_type
                                                        == R_386_TLS_IE as libc::c_int as libc::c_uint
                                                    {
                                                        let mut val_0: libc::c_uint = 0;
                                                        val_0 = (*(contents
                                                            .offset((*rel).r_offset as isize)
                                                            .offset(-(1 as libc::c_int as isize))
                                                            as *const libc::c_uchar) as bfd_vma
                                                            & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
                                                        if val_0 == 0xa1 as libc::c_int as libc::c_uint {
                                                            *(contents
                                                                .offset((*rel).r_offset as isize)
                                                                .offset(-(1 as libc::c_int as isize))
                                                                as *mut libc::c_uchar) = (0xb8 as libc::c_int
                                                                & 0xff as libc::c_int) as libc::c_uchar;
                                                        } else {
                                                            let mut type_1: libc::c_uint = 0;
                                                            type_1 = (*(contents
                                                                .offset((*rel).r_offset as isize)
                                                                .offset(-(2 as libc::c_int as isize))
                                                                as *const libc::c_uchar) as bfd_vma
                                                                & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
                                                            match type_1 {
                                                                139 => {
                                                                    *(contents
                                                                        .offset((*rel).r_offset as isize)
                                                                        .offset(-(2 as libc::c_int as isize))
                                                                        as *mut libc::c_uchar) = (0xc7 as libc::c_int
                                                                        & 0xff as libc::c_int) as libc::c_uchar;
                                                                    *(contents
                                                                        .offset((*rel).r_offset as isize)
                                                                        .offset(-(1 as libc::c_int as isize))
                                                                        as *mut libc::c_uchar) = ((0xc0 as libc::c_int
                                                                        as libc::c_uint
                                                                        | val_0 >> 3 as libc::c_int
                                                                            & 7 as libc::c_int as libc::c_uint)
                                                                        & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
                                                                }
                                                                3 => {
                                                                    *(contents
                                                                        .offset((*rel).r_offset as isize)
                                                                        .offset(-(2 as libc::c_int as isize))
                                                                        as *mut libc::c_uchar) = (0x81 as libc::c_int
                                                                        & 0xff as libc::c_int) as libc::c_uchar;
                                                                    *(contents
                                                                        .offset((*rel).r_offset as isize)
                                                                        .offset(-(1 as libc::c_int as isize))
                                                                        as *mut libc::c_uchar) = ((0xc0 as libc::c_int
                                                                        as libc::c_uint
                                                                        | val_0 >> 3 as libc::c_int
                                                                            & 7 as libc::c_int as libc::c_uint)
                                                                        & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
                                                                }
                                                                _ => {
                                                                    bfd_assert(
                                                                        b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                        2954 as libc::c_int,
                                                                    );
                                                                }
                                                            }
                                                        }
                                                        (Some(
                                                            ((*(*output_bfd).xvec).bfd_putx32)
                                                                .expect("non-null function pointer"),
                                                        ))
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(
                                                            (elf_i386_tpoff(info, relocation)).wrapping_neg(),
                                                            contents.offset((*rel).r_offset as isize)
                                                                as *mut libc::c_void,
                                                        );
                                                    } else {
                                                        let mut val_1: libc::c_uint = 0;
                                                        let mut type_2: libc::c_uint = 0;
                                                        type_2 = (*(contents
                                                            .offset((*rel).r_offset as isize)
                                                            .offset(-(2 as libc::c_int as isize))
                                                            as *const libc::c_uchar) as bfd_vma
                                                            & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
                                                        val_1 = (*(contents
                                                            .offset((*rel).r_offset as isize)
                                                            .offset(-(1 as libc::c_int as isize))
                                                            as *const libc::c_uchar) as bfd_vma
                                                            & 0xff as libc::c_int as libc::c_ulong) as libc::c_uint;
                                                        if type_2 == 0x8b as libc::c_int as libc::c_uint {
                                                            *(contents
                                                                .offset((*rel).r_offset as isize)
                                                                .offset(-(2 as libc::c_int as isize))
                                                                as *mut libc::c_uchar) = (0xc7 as libc::c_int
                                                                & 0xff as libc::c_int) as libc::c_uchar;
                                                            *(contents
                                                                .offset((*rel).r_offset as isize)
                                                                .offset(-(1 as libc::c_int as isize))
                                                                as *mut libc::c_uchar) = ((0xc0 as libc::c_int
                                                                as libc::c_uint
                                                                | val_1 >> 3 as libc::c_int
                                                                    & 7 as libc::c_int as libc::c_uint)
                                                                & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
                                                        } else if type_2 == 0x2b as libc::c_int as libc::c_uint {
                                                            *(contents
                                                                .offset((*rel).r_offset as isize)
                                                                .offset(-(2 as libc::c_int as isize))
                                                                as *mut libc::c_uchar) = (0x81 as libc::c_int
                                                                & 0xff as libc::c_int) as libc::c_uchar;
                                                            *(contents
                                                                .offset((*rel).r_offset as isize)
                                                                .offset(-(1 as libc::c_int as isize))
                                                                as *mut libc::c_uchar) = ((0xe8 as libc::c_int
                                                                as libc::c_uint
                                                                | val_1 >> 3 as libc::c_int
                                                                    & 7 as libc::c_int as libc::c_uint)
                                                                & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
                                                        } else if type_2 == 0x3 as libc::c_int as libc::c_uint {
                                                            *(contents
                                                                .offset((*rel).r_offset as isize)
                                                                .offset(-(2 as libc::c_int as isize))
                                                                as *mut libc::c_uchar) = (0x81 as libc::c_int
                                                                & 0xff as libc::c_int) as libc::c_uchar;
                                                            *(contents
                                                                .offset((*rel).r_offset as isize)
                                                                .offset(-(1 as libc::c_int as isize))
                                                                as *mut libc::c_uchar) = ((0xc0 as libc::c_int
                                                                as libc::c_uint
                                                                | val_1 >> 3 as libc::c_int
                                                                    & 7 as libc::c_int as libc::c_uint)
                                                                & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
                                                        } else {
                                                            bfd_assert(
                                                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                3002 as libc::c_int,
                                                            );
                                                        }
                                                        if r_type == R_386_TLS_GOTIE as libc::c_int as libc::c_uint
                                                        {
                                                            (Some(
                                                                ((*(*output_bfd).xvec).bfd_putx32)
                                                                    .expect("non-null function pointer"),
                                                            ))
                                                                .expect(
                                                                    "non-null function pointer",
                                                                )(
                                                                (elf_i386_tpoff(info, relocation)).wrapping_neg(),
                                                                contents.offset((*rel).r_offset as isize)
                                                                    as *mut libc::c_void,
                                                            );
                                                        } else {
                                                            (Some(
                                                                ((*(*output_bfd).xvec).bfd_putx32)
                                                                    .expect("non-null function pointer"),
                                                            ))
                                                                .expect(
                                                                    "non-null function pointer",
                                                                )(
                                                                elf_i386_tpoff(info, relocation),
                                                                contents.offset((*rel).r_offset as isize)
                                                                    as *mut libc::c_void,
                                                            );
                                                        }
                                                    }
                                                    current_block = 1054647088692577877;
                                                } else {
                                                    if ((*htab).elf.sgot).is_null() {
                                                        _bfd_abort(
                                                            b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                            3014 as libc::c_int,
                                                            (*::core::mem::transmute::<
                                                                &[u8; 146],
                                                                &[libc::c_char; 146],
                                                            >(
                                                                b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                            ))
                                                                .as_ptr(),
                                                        );
                                                    }
                                                    if !h.is_null() {
                                                        off = (*h).got.offset;
                                                        offplt = (*(h as *mut elf_x86_link_hash_entry)).tlsdesc_got;
                                                    } else {
                                                        if local_got_offsets.is_null() {
                                                            _bfd_abort(
                                                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                3024 as libc::c_int,
                                                                (*::core::mem::transmute::<
                                                                    &[u8; 146],
                                                                    &[libc::c_char; 146],
                                                                >(
                                                                    b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                                ))
                                                                    .as_ptr(),
                                                            );
                                                        }
                                                        off = *local_got_offsets.offset(r_symndx as isize);
                                                        offplt = *local_tlsdesc_gotents.offset(r_symndx as isize);
                                                    }
                                                    if off & 1 as libc::c_int as libc::c_ulong
                                                        != 0 as libc::c_int as libc::c_ulong
                                                    {
                                                        off &= !(1 as libc::c_int) as libc::c_ulong;
                                                    } else {
                                                        let mut current_block_447: u64;
                                                        let mut outrel_3: Elf_Internal_Rela = Elf_Internal_Rela {
                                                            r_offset: 0,
                                                            r_info: 0,
                                                            r_addend: 0,
                                                        };
                                                        let mut dr_type: libc::c_int = 0;
                                                        let mut sreloc_2: *mut asection = 0 as *mut asection;
                                                        if ((*htab).elf.srelgot).is_null() {
                                                            _bfd_abort(
                                                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                3039 as libc::c_int,
                                                                (*::core::mem::transmute::<
                                                                    &[u8; 146],
                                                                    &[libc::c_char; 146],
                                                                >(
                                                                    b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                                ))
                                                                    .as_ptr(),
                                                            );
                                                        }
                                                        indx = (if !h.is_null()
                                                            && (*h).dynindx != -(1 as libc::c_int) as libc::c_long
                                                        {
                                                            (*h).dynindx
                                                        } else {
                                                            0 as libc::c_int as libc::c_long
                                                        }) as libc::c_uint;
                                                        if tls_type == 8 as libc::c_int
                                                            || tls_type == 2 as libc::c_int | 8 as libc::c_int
                                                        {
                                                            let mut loc: *mut bfd_byte = 0 as *mut bfd_byte;
                                                            outrel_3
                                                                .r_info = (indx << 8 as libc::c_int)
                                                                .wrapping_add(
                                                                    (R_386_TLS_DESC as libc::c_int & 0xff as libc::c_int)
                                                                        as libc::c_uint,
                                                                ) as bfd_vma;
                                                            if !(((*htab).sgotplt_jump_table_size)
                                                                .wrapping_add(offplt)
                                                                .wrapping_add(8 as libc::c_int as libc::c_ulong)
                                                                <= (*(*htab).elf.sgotplt).size)
                                                            {
                                                                bfd_assert(
                                                                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                    3048 as libc::c_int,
                                                                );
                                                            }
                                                            outrel_3
                                                                .r_offset = ((*(*(*htab).elf.sgotplt).output_section).vma)
                                                                .wrapping_add((*(*htab).elf.sgotplt).output_offset)
                                                                .wrapping_add(offplt)
                                                                .wrapping_add((*htab).sgotplt_jump_table_size);
                                                            sreloc_2 = (*htab).elf.srelplt;
                                                            loc = (*sreloc_2).contents;
                                                            let fresh5 = (*htab).next_tls_desc_index;
                                                            (*htab)
                                                                .next_tls_desc_index = ((*htab).next_tls_desc_index)
                                                                .wrapping_add(1);
                                                            loc = loc
                                                                .offset(
                                                                    fresh5
                                                                        .wrapping_mul(
                                                                            ::core::mem::size_of::<Elf32_External_Rel>()
                                                                                as libc::c_ulong,
                                                                        ) as isize,
                                                                );
                                                            if !(loc
                                                                .offset(
                                                                    ::core::mem::size_of::<Elf32_External_Rel>()
                                                                        as libc::c_ulong as isize,
                                                                )
                                                                <= ((*sreloc_2).contents).offset((*sreloc_2).size as isize))
                                                            {
                                                                bfd_assert(
                                                                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                    3058 as libc::c_int,
                                                                );
                                                            }
                                                            bfd_elf32_swap_reloc_out(output_bfd, &mut outrel_3, loc);
                                                            if indx == 0 as libc::c_int as libc::c_uint {
                                                                if unresolved_reloc {
                                                                    bfd_assert(
                                                                        b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                        3062 as libc::c_int,
                                                                    );
                                                                }
                                                                (Some(
                                                                    ((*(*output_bfd).xvec).bfd_putx32)
                                                                        .expect("non-null function pointer"),
                                                                ))
                                                                    .expect(
                                                                        "non-null function pointer",
                                                                    )(
                                                                    relocation.wrapping_sub(_bfd_x86_elf_dtpoff_base(info)),
                                                                    ((*(*htab).elf.sgotplt).contents)
                                                                        .offset(offplt as isize)
                                                                        .offset((*htab).sgotplt_jump_table_size as isize)
                                                                        .offset(4 as libc::c_int as isize) as *mut libc::c_void,
                                                                );
                                                            } else {
                                                                (Some(
                                                                    ((*(*output_bfd).xvec).bfd_putx32)
                                                                        .expect("non-null function pointer"),
                                                                ))
                                                                    .expect(
                                                                        "non-null function pointer",
                                                                    )(
                                                                    0 as libc::c_int as bfd_vma,
                                                                    ((*(*htab).elf.sgotplt).contents)
                                                                        .offset(offplt as isize)
                                                                        .offset((*htab).sgotplt_jump_table_size as isize)
                                                                        .offset(4 as libc::c_int as isize) as *mut libc::c_void,
                                                                );
                                                            }
                                                        }
                                                        sreloc_2 = (*htab).elf.srelgot;
                                                        outrel_3
                                                            .r_offset = ((*(*(*htab).elf.sgot).output_section).vma)
                                                            .wrapping_add((*(*htab).elf.sgot).output_offset)
                                                            .wrapping_add(off);
                                                        if tls_type == 2 as libc::c_int
                                                            || tls_type == 2 as libc::c_int | 8 as libc::c_int
                                                        {
                                                            dr_type = R_386_TLS_DTPMOD32 as libc::c_int;
                                                            current_block_447 = 13307745568682769394;
                                                        } else if tls_type == 8 as libc::c_int
                                                            || tls_type == 2 as libc::c_int | 8 as libc::c_int
                                                        {
                                                            current_block_447 = 10158911377363310161;
                                                        } else {
                                                            if tls_type == 5 as libc::c_int {
                                                                dr_type = R_386_TLS_TPOFF as libc::c_int;
                                                            } else {
                                                                dr_type = R_386_TLS_TPOFF32 as libc::c_int;
                                                            }
                                                            current_block_447 = 13307745568682769394;
                                                        }
                                                        match current_block_447 {
                                                            13307745568682769394 => {
                                                                if dr_type == R_386_TLS_TPOFF as libc::c_int
                                                                    && indx == 0 as libc::c_int as libc::c_uint
                                                                {
                                                                    (Some(
                                                                        ((*(*output_bfd).xvec).bfd_putx32)
                                                                            .expect("non-null function pointer"),
                                                                    ))
                                                                        .expect(
                                                                            "non-null function pointer",
                                                                        )(
                                                                        relocation.wrapping_sub(_bfd_x86_elf_dtpoff_base(info)),
                                                                        ((*(*htab).elf.sgot).contents).offset(off as isize)
                                                                            as *mut libc::c_void,
                                                                    );
                                                                } else if dr_type == R_386_TLS_TPOFF32 as libc::c_int
                                                                    && indx == 0 as libc::c_int as libc::c_uint
                                                                {
                                                                    (Some(
                                                                        ((*(*output_bfd).xvec).bfd_putx32)
                                                                            .expect("non-null function pointer"),
                                                                    ))
                                                                        .expect(
                                                                            "non-null function pointer",
                                                                        )(
                                                                        (_bfd_x86_elf_dtpoff_base(info)).wrapping_sub(relocation),
                                                                        ((*(*htab).elf.sgot).contents).offset(off as isize)
                                                                            as *mut libc::c_void,
                                                                    );
                                                                } else if dr_type != R_386_TLS_DESC as libc::c_int {
                                                                    (Some(
                                                                        ((*(*output_bfd).xvec).bfd_putx32)
                                                                            .expect("non-null function pointer"),
                                                                    ))
                                                                        .expect(
                                                                            "non-null function pointer",
                                                                        )(
                                                                        0 as libc::c_int as bfd_vma,
                                                                        ((*(*htab).elf.sgot).contents).offset(off as isize)
                                                                            as *mut libc::c_void,
                                                                    );
                                                                }
                                                                outrel_3
                                                                    .r_info = (indx << 8 as libc::c_int)
                                                                    .wrapping_add(
                                                                        (dr_type & 0xff as libc::c_int) as libc::c_uint,
                                                                    ) as bfd_vma;
                                                                elf_append_rel(output_bfd, sreloc_2, &mut outrel_3);
                                                                if tls_type == 2 as libc::c_int
                                                                    || tls_type == 2 as libc::c_int | 8 as libc::c_int
                                                                {
                                                                    if indx == 0 as libc::c_int as libc::c_uint {
                                                                        if unresolved_reloc {
                                                                            bfd_assert(
                                                                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                                3109 as libc::c_int,
                                                                            );
                                                                        }
                                                                        (Some(
                                                                            ((*(*output_bfd).xvec).bfd_putx32)
                                                                                .expect("non-null function pointer"),
                                                                        ))
                                                                            .expect(
                                                                                "non-null function pointer",
                                                                            )(
                                                                            relocation.wrapping_sub(_bfd_x86_elf_dtpoff_base(info)),
                                                                            ((*(*htab).elf.sgot).contents)
                                                                                .offset(off as isize)
                                                                                .offset(4 as libc::c_int as isize) as *mut libc::c_void,
                                                                        );
                                                                    } else {
                                                                        (Some(
                                                                            ((*(*output_bfd).xvec).bfd_putx32)
                                                                                .expect("non-null function pointer"),
                                                                        ))
                                                                            .expect(
                                                                                "non-null function pointer",
                                                                            )(
                                                                            0 as libc::c_int as bfd_vma,
                                                                            ((*(*htab).elf.sgot).contents)
                                                                                .offset(off as isize)
                                                                                .offset(4 as libc::c_int as isize) as *mut libc::c_void,
                                                                        );
                                                                        outrel_3
                                                                            .r_info = (indx << 8 as libc::c_int)
                                                                            .wrapping_add(
                                                                                (R_386_TLS_DTPOFF32 as libc::c_int & 0xff as libc::c_int)
                                                                                    as libc::c_uint,
                                                                            ) as bfd_vma;
                                                                        outrel_3
                                                                            .r_offset = (outrel_3.r_offset as libc::c_ulong)
                                                                            .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                                                                            as bfd_vma;
                                                                        elf_append_rel(output_bfd, sreloc_2, &mut outrel_3);
                                                                    }
                                                                } else if tls_type == 7 as libc::c_int {
                                                                    (Some(
                                                                        ((*(*output_bfd).xvec).bfd_putx32)
                                                                            .expect("non-null function pointer"),
                                                                    ))
                                                                        .expect(
                                                                            "non-null function pointer",
                                                                        )(
                                                                        if indx == 0 as libc::c_int as libc::c_uint {
                                                                            relocation.wrapping_sub(_bfd_x86_elf_dtpoff_base(info))
                                                                        } else {
                                                                            0 as libc::c_int as libc::c_ulong
                                                                        },
                                                                        ((*(*htab).elf.sgot).contents)
                                                                            .offset(off as isize)
                                                                            .offset(4 as libc::c_int as isize) as *mut libc::c_void,
                                                                    );
                                                                    outrel_3
                                                                        .r_info = (indx << 8 as libc::c_int)
                                                                        .wrapping_add(
                                                                            (R_386_TLS_TPOFF as libc::c_int & 0xff as libc::c_int)
                                                                                as libc::c_uint,
                                                                        ) as bfd_vma;
                                                                    outrel_3
                                                                        .r_offset = (outrel_3.r_offset as libc::c_ulong)
                                                                        .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                                                                        as bfd_vma;
                                                                    elf_append_rel(output_bfd, sreloc_2, &mut outrel_3);
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                        if !h.is_null() {
                                                            (*h).got.offset |= 1 as libc::c_int as libc::c_ulong;
                                                        } else {
                                                            let ref mut fresh6 = *local_got_offsets
                                                                .offset(r_symndx as isize);
                                                            *fresh6 |= 1 as libc::c_int as libc::c_ulong;
                                                        }
                                                    }
                                                    if off >= -(2 as libc::c_int) as bfd_vma
                                                        && !(tls_type == 8 as libc::c_int
                                                            || tls_type == 2 as libc::c_int | 8 as libc::c_int)
                                                    {
                                                        _bfd_abort(
                                                            b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                            3145 as libc::c_int,
                                                            (*::core::mem::transmute::<
                                                                &[u8; 146],
                                                                &[libc::c_char; 146],
                                                            >(
                                                                b"int elf_i386_relocate_section(bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **)\0",
                                                            ))
                                                                .as_ptr(),
                                                        );
                                                    }
                                                    if r_type_tls
                                                        == R_386_TLS_GOTDESC as libc::c_int as libc::c_uint
                                                        || r_type_tls
                                                            == R_386_TLS_DESC_CALL as libc::c_int as libc::c_uint
                                                    {
                                                        relocation = ((*htab).sgotplt_jump_table_size)
                                                            .wrapping_add(offplt);
                                                        unresolved_reloc = 0 as libc::c_int != 0;
                                                        current_block = 966498249569804311;
                                                    } else if r_type_tls == r_type {
                                                        let mut g_o_t: bfd_vma = ((*(*(*htab).elf.sgotplt)
                                                            .output_section)
                                                            .vma)
                                                            .wrapping_add((*(*htab).elf.sgotplt).output_offset);
                                                        relocation = ((*(*(*htab).elf.sgot).output_section).vma)
                                                            .wrapping_add((*(*htab).elf.sgot).output_offset)
                                                            .wrapping_add(off)
                                                            .wrapping_sub(g_o_t);
                                                        if (r_type == R_386_TLS_IE as libc::c_int as libc::c_uint
                                                            || r_type == R_386_TLS_GOTIE as libc::c_int as libc::c_uint)
                                                            && tls_type == 7 as libc::c_int
                                                        {
                                                            relocation = (relocation as libc::c_ulong)
                                                                .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                                                                as bfd_vma;
                                                        }
                                                        if r_type == R_386_TLS_IE as libc::c_int as libc::c_uint {
                                                            relocation = (relocation as libc::c_ulong)
                                                                .wrapping_add(g_o_t) as bfd_vma as bfd_vma;
                                                        }
                                                        unresolved_reloc = 0 as libc::c_int != 0;
                                                        current_block = 966498249569804311;
                                                    } else if r_type
                                                        == R_386_TLS_GD as libc::c_int as libc::c_uint
                                                    {
                                                        let mut val_2: libc::c_uint = 0;
                                                        let mut type_3: libc::c_uint = 0;
                                                        let mut roff_2: bfd_vma = 0;
                                                        type_3 = *contents
                                                            .offset((*rel).r_offset as isize)
                                                            .offset(-(2 as libc::c_int as isize)) as libc::c_uint;
                                                        val_2 = *contents
                                                            .offset((*rel).r_offset as isize)
                                                            .offset(-(1 as libc::c_int as isize)) as libc::c_uint;
                                                        if type_3 == 0x4 as libc::c_int as libc::c_uint {
                                                            val_2 >>= 3 as libc::c_int;
                                                            roff_2 = ((*rel).r_offset)
                                                                .wrapping_sub(3 as libc::c_int as libc::c_ulong);
                                                        } else {
                                                            roff_2 = ((*rel).r_offset)
                                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong);
                                                        }
                                                        memcpy(
                                                            contents.offset(roff_2 as isize) as *mut libc::c_void,
                                                            b"e\xA1\0\0\0\0+\x80\0\0\0\0" as *const u8
                                                                as *const libc::c_char as *const libc::c_void,
                                                            12 as libc::c_int as libc::c_ulong,
                                                        );
                                                        *contents
                                                            .offset(
                                                                roff_2.wrapping_add(7 as libc::c_int as libc::c_ulong)
                                                                    as isize,
                                                            ) = (0x80 as libc::c_int as libc::c_uint
                                                            | val_2 & 7 as libc::c_int as libc::c_uint) as bfd_byte;
                                                        if tls_type == 5 as libc::c_int {
                                                            *contents
                                                                .offset(
                                                                    roff_2.wrapping_add(6 as libc::c_int as libc::c_ulong)
                                                                        as isize,
                                                                ) = 0x3 as libc::c_int as bfd_byte;
                                                        }
                                                        (Some(
                                                            ((*(*output_bfd).xvec).bfd_putx32)
                                                                .expect("non-null function pointer"),
                                                        ))
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(
                                                            ((*(*(*htab).elf.sgot).output_section).vma)
                                                                .wrapping_add((*(*htab).elf.sgot).output_offset)
                                                                .wrapping_add(off)
                                                                .wrapping_sub((*(*(*htab).elf.sgotplt).output_section).vma)
                                                                .wrapping_sub((*(*htab).elf.sgotplt).output_offset),
                                                            contents
                                                                .offset(roff_2 as isize)
                                                                .offset(8 as libc::c_int as isize) as *mut libc::c_void,
                                                        );
                                                        rel = rel.offset(1);
                                                        rel;
                                                        wrel = wrel.offset(1);
                                                        wrel;
                                                        current_block = 1054647088692577877;
                                                    } else if r_type
                                                        == R_386_TLS_GOTDESC as libc::c_int as libc::c_uint
                                                    {
                                                        let mut roff_3: bfd_vma = 0;
                                                        roff_3 = (*rel).r_offset;
                                                        *(contents
                                                            .offset(roff_3 as isize)
                                                            .offset(-(2 as libc::c_int as isize))
                                                            as *mut libc::c_uchar) = (0x8b as libc::c_int
                                                            & 0xff as libc::c_int) as libc::c_uchar;
                                                        if tls_type == 7 as libc::c_int {
                                                            off = (off as libc::c_ulong)
                                                                .wrapping_add(4 as libc::c_int as libc::c_ulong) as bfd_vma
                                                                as bfd_vma;
                                                        }
                                                        (Some(
                                                            ((*(*output_bfd).xvec).bfd_putx32)
                                                                .expect("non-null function pointer"),
                                                        ))
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(
                                                            ((*(*(*htab).elf.sgot).output_section).vma)
                                                                .wrapping_add((*(*htab).elf.sgot).output_offset)
                                                                .wrapping_add(off)
                                                                .wrapping_sub((*(*(*htab).elf.sgotplt).output_section).vma)
                                                                .wrapping_sub((*(*htab).elf.sgotplt).output_offset),
                                                            contents.offset(roff_3 as isize) as *mut libc::c_void,
                                                        );
                                                        current_block = 1054647088692577877;
                                                    } else if r_type
                                                        == R_386_TLS_DESC_CALL as libc::c_int as libc::c_uint
                                                    {
                                                        let mut roff_4: bfd_vma = 0;
                                                        roff_4 = (*rel).r_offset;
                                                        if tls_type != 6 as libc::c_int {
                                                            *(contents.offset(roff_4 as isize)
                                                                as *mut libc::c_uchar) = (0x66 as libc::c_int
                                                                & 0xff as libc::c_int) as libc::c_uchar;
                                                            *(contents
                                                                .offset(roff_4 as isize)
                                                                .offset(1 as libc::c_int as isize)
                                                                as *mut libc::c_uchar) = (0x90 as libc::c_int
                                                                & 0xff as libc::c_int) as libc::c_uchar;
                                                        } else {
                                                            *(contents.offset(roff_4 as isize)
                                                                as *mut libc::c_uchar) = (0xf7 as libc::c_int
                                                                & 0xff as libc::c_int) as libc::c_uchar;
                                                            *(contents
                                                                .offset(roff_4 as isize)
                                                                .offset(1 as libc::c_int as isize)
                                                                as *mut libc::c_uchar) = (0xd8 as libc::c_int
                                                                & 0xff as libc::c_int) as libc::c_uchar;
                                                        }
                                                        current_block = 1054647088692577877;
                                                    } else {
                                                        if 0 as libc::c_int == 0 {
                                                            bfd_assert(
                                                                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                                                                3294 as libc::c_int,
                                                            );
                                                        }
                                                        current_block = 966498249569804311;
                                                    }
                                                }
                                            }
                                            13573926323309413337 => {
                                                if (*input_section).flags
                                                    & 0x1 as libc::c_int as libc::c_uint
                                                    == 0 as libc::c_int as libc::c_uint
                                                    || is_vxworks_tls as libc::c_int != 0
                                                {
                                                    current_block = 966498249569804311;
                                                } else if ((*info).type_0() as libc::c_int
                                                    == type_dll as libc::c_int
                                                    || (*info).type_0() as libc::c_int
                                                        == type_pie as libc::c_int)
                                                    && !(bfd_is_abs_section(sec) as libc::c_int != 0
                                                        && (eh.is_null()
                                                            || _bfd_elf_symbol_refs_local_p(
                                                                &mut (*eh).elf,
                                                                info,
                                                                0 as libc::c_int != 0,
                                                            ) as libc::c_int != 0)) && 0 as libc::c_int == 0
                                                    && (eh.is_null()
                                                        || (((*eh).elf).other() as libc::c_int & 0x3 as libc::c_int
                                                            == 0 as libc::c_int
                                                            && (!resolved_to_zero
                                                                || r_type == R_386_PC32 as libc::c_int as libc::c_uint)
                                                            || ((*eh).elf.root).type_0() as libc::c_int
                                                                != bfd_link_hash_undefweak as libc::c_int))
                                                    && (!(r_type == R_386_PC32 as libc::c_int as libc::c_uint)
                                                        && !(r_type == R_386_SIZE32 as libc::c_int as libc::c_uint)
                                                        || !_bfd_elf_symbol_refs_local_p(
                                                            eh as *mut elf_link_hash_entry,
                                                            info,
                                                            1 as libc::c_int != 0,
                                                        ))
                                                    || 1 as libc::c_int != 0
                                                        && !((*info).type_0() as libc::c_int
                                                            == type_dll as libc::c_int
                                                            || (*info).type_0() as libc::c_int
                                                                == type_pie as libc::c_int) && !eh.is_null()
                                                        && (*eh).elf.dynindx != -(1 as libc::c_int) as libc::c_long
                                                        && (((*eh).elf).non_got_ref() == 0
                                                            || ((*eh).elf.root).type_0() as libc::c_int
                                                                == bfd_link_hash_undefweak as libc::c_int
                                                                && !resolved_to_zero)
                                                        && (((*eh).elf).def_dynamic() as libc::c_int != 0
                                                            && ((*eh).elf).def_regular() == 0
                                                            || ((*eh).elf.root).type_0() as libc::c_int
                                                                == bfd_link_hash_undefined as libc::c_int)
                                                {
                                                    let mut outrel_1: Elf_Internal_Rela = Elf_Internal_Rela {
                                                        r_offset: 0,
                                                        r_info: 0,
                                                        r_addend: 0,
                                                    };
                                                    let mut skip: bool = false;
                                                    let mut relocate: bool = false;
                                                    let mut sreloc_0: *mut asection = 0 as *mut asection;
                                                    skip = 0 as libc::c_int != 0;
                                                    relocate = 0 as libc::c_int != 0;
                                                    outrel_1
                                                        .r_offset = _bfd_elf_section_offset(
                                                        output_bfd,
                                                        info,
                                                        input_section,
                                                        (*rel).r_offset,
                                                    );
                                                    if outrel_1.r_offset == -(1 as libc::c_int) as bfd_vma {
                                                        skip = 1 as libc::c_int != 0;
                                                    } else if outrel_1.r_offset
                                                        == -(2 as libc::c_int) as bfd_vma
                                                    {
                                                        skip = 1 as libc::c_int != 0;
                                                        relocate = 1 as libc::c_int != 0;
                                                    }
                                                    outrel_1
                                                        .r_offset = (outrel_1.r_offset as libc::c_ulong)
                                                        .wrapping_add(
                                                            ((*(*input_section).output_section).vma)
                                                                .wrapping_add((*input_section).output_offset),
                                                        ) as bfd_vma as bfd_vma;
                                                    if skip {
                                                        memset(
                                                            &mut outrel_1 as *mut Elf_Internal_Rela
                                                                as *mut libc::c_void,
                                                            0 as libc::c_int,
                                                            ::core::mem::size_of::<Elf_Internal_Rela>() as libc::c_ulong,
                                                        );
                                                    } else if !h.is_null()
                                                        && (*h).dynindx != -(1 as libc::c_int) as libc::c_long
                                                        && (r_type == R_386_PC32 as libc::c_int as libc::c_uint
                                                            || !((*info).type_0() as libc::c_int
                                                                == type_pde as libc::c_int
                                                                || (*info).type_0() as libc::c_int
                                                                    == type_pie as libc::c_int
                                                                || (*h).unique_global() == 0
                                                                    && ((*info).symbolic() as libc::c_int != 0
                                                                        || (*h).start_stop() as libc::c_int != 0
                                                                        || (*info).dynamic() as libc::c_int != 0
                                                                            && (*h).dynamic() == 0)) || (*h).def_regular() == 0)
                                                    {
                                                        outrel_1
                                                            .r_info = (((*h).dynindx as libc::c_uint)
                                                            << 8 as libc::c_int)
                                                            .wrapping_add(r_type & 0xff as libc::c_int as libc::c_uint)
                                                            as bfd_vma;
                                                    } else {
                                                        relocate = 1 as libc::c_int != 0;
                                                        outrel_1
                                                            .r_info = ((0 as libc::c_int as libc::c_uint)
                                                            << 8 as libc::c_int)
                                                            .wrapping_add(
                                                                (R_386_RELATIVE as libc::c_int & 0xff as libc::c_int)
                                                                    as libc::c_uint,
                                                            ) as bfd_vma;
                                                        if (*(*htab).params).report_relative_reloc() != 0 {
                                                            _bfd_x86_elf_link_report_relative_reloc(
                                                                info,
                                                                input_section,
                                                                h,
                                                                sym,
                                                                b"R_386_RELATIVE\0" as *const u8 as *const libc::c_char,
                                                                &mut outrel_1 as *mut Elf_Internal_Rela
                                                                    as *const libc::c_void,
                                                            );
                                                        }
                                                    }
                                                    sreloc_0 = (*((*input_section).used_by_bfd
                                                        as *mut bfd_elf_section_data))
                                                        .sreloc;
                                                    if sreloc_0.is_null() || ((*sreloc_0).contents).is_null() {
                                                        r = bfd_reloc_notsupported;
                                                        current_block = 1363834337379247030;
                                                    } else {
                                                        elf_append_rel(output_bfd, sreloc_0, &mut outrel_1);
                                                        if !relocate {
                                                            current_block = 1054647088692577877;
                                                        } else {
                                                            current_block = 966498249569804311;
                                                        }
                                                    }
                                                } else {
                                                    current_block = 966498249569804311;
                                                }
                                            }
                                            _ => {}
                                        }
                                        match current_block {
                                            1054647088692577877 => {}
                                            1363834337379247030 => {}
                                            _ => {
                                                if unresolved_reloc as libc::c_int != 0
                                                    && !((*input_section).flags
                                                        & 0x2000 as libc::c_int as libc::c_uint
                                                        != 0 as libc::c_int as libc::c_uint
                                                        && (*h).def_dynamic() as libc::c_int != 0)
                                                    && _bfd_elf_section_offset(
                                                        output_bfd,
                                                        info,
                                                        input_section,
                                                        (*rel).r_offset,
                                                    ) != -(1 as libc::c_int) as bfd_vma
                                                {
                                                    _bfd_error_handler(
                                                        dcgettext(
                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                            b"%pB(%pA+%#lx): unresolvable %s relocation against symbol `%s'\0"
                                                                as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                        input_bfd,
                                                        input_section,
                                                        (*rel).r_offset,
                                                        (*howto).name,
                                                        (*h).root.root.string,
                                                    );
                                                    return 0 as libc::c_int;
                                                }
                                                current_block = 10641344571278079028;
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                        match current_block {
                            1054647088692577877 => {}
                            _ => {
                                match current_block {
                                    13418714505947323240 => {
                                        if h.is_null() || ((*h).root.root.string).is_null() {
                                            name_0 = bfd_elf_sym_name(
                                                input_bfd,
                                                symtab_hdr,
                                                sym,
                                                0 as *mut asection,
                                            );
                                        } else {
                                            name_0 = (*h).root.root.string;
                                        }
                                        _bfd_error_handler(
                                            dcgettext(
                                                b"bfd\0" as *const u8 as *const libc::c_char,
                                                b"%pB: direct GOT relocation %s against `%s' without base register can not be used when making a shared object\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            input_bfd,
                                            (*howto).name,
                                            name_0,
                                        );
                                        bfd_set_error(bfd_error_bad_value);
                                        return 0 as libc::c_int;
                                    }
                                    10641344571278079028 => {
                                        r = _bfd_final_link_relocate(
                                            howto,
                                            input_bfd,
                                            input_section,
                                            contents,
                                            (*rel).r_offset,
                                            relocation,
                                            0 as libc::c_int as bfd_vma,
                                        );
                                    }
                                    _ => {}
                                }
                                if r as libc::c_uint
                                    != bfd_reloc_ok as libc::c_int as libc::c_uint
                                {
                                    let mut name_1: *const libc::c_char = 0
                                        as *const libc::c_char;
                                    if !h.is_null() {
                                        name_1 = (*h).root.root.string;
                                    } else {
                                        name_1 = bfd_elf_string_from_elf_section(
                                            input_bfd,
                                            (*symtab_hdr).sh_link,
                                            (*sym).st_name as libc::c_uint,
                                        );
                                        if name_1.is_null() {
                                            return 0 as libc::c_int;
                                        }
                                        if *name_1 as libc::c_int == '\0' as i32 {
                                            name_1 = bfd_section_name(sec);
                                        }
                                    }
                                    if r as libc::c_uint
                                        == bfd_reloc_overflow as libc::c_int as libc::c_uint
                                    {
                                        (Some(
                                            ((*(*info).callbacks).reloc_overflow)
                                                .expect("non-null function pointer"),
                                        ))
                                            .expect(
                                                "non-null function pointer",
                                            )(
                                            info,
                                            if !h.is_null() {
                                                &mut (*h).root
                                            } else {
                                                0 as *mut bfd_link_hash_entry
                                            },
                                            name_1,
                                            (*howto).name,
                                            0 as libc::c_int as bfd_vma,
                                            input_bfd,
                                            input_section,
                                            (*rel).r_offset,
                                        );
                                    } else {
                                        _bfd_error_handler(
                                            dcgettext(
                                                b"bfd\0" as *const u8 as *const libc::c_char,
                                                b"%pB(%pA+%#lx): reloc against `%s': error %d\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            input_bfd,
                                            input_section,
                                            (*rel).r_offset,
                                            name_1,
                                            r as libc::c_int,
                                        );
                                        return 0 as libc::c_int;
                                    }
                                }
                                if wrel != rel {
                                    *wrel = *rel;
                                }
                            }
                        }
                    }
                }
            }
        }
        wrel = wrel.offset(1);
        wrel;
        rel = rel.offset(1);
        rel;
    }
    if wrel != rel {
        let mut rel_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut deleted: size_t = rel.offset_from(wrel) as libc::c_long as size_t;
        rel_hdr = _bfd_elf_single_rel_hdr((*input_section).output_section);
        (*rel_hdr)
            .sh_size = ((*rel_hdr).sh_size as libc::c_ulong)
            .wrapping_sub(((*rel_hdr).sh_entsize).wrapping_mul(deleted)) as bfd_size_type
            as bfd_size_type;
        if (*rel_hdr).sh_size == 0 as libc::c_int as libc::c_ulong {
            (*rel_hdr).sh_size = (*rel_hdr).sh_entsize;
            deleted = (deleted as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as size_t as size_t;
        }
        rel_hdr = _bfd_elf_single_rel_hdr(input_section);
        (*rel_hdr)
            .sh_size = ((*rel_hdr).sh_size as libc::c_ulong)
            .wrapping_sub(((*rel_hdr).sh_entsize).wrapping_mul(deleted)) as bfd_size_type
            as bfd_size_type;
        (*input_section)
            .reloc_count = ((*input_section).reloc_count as libc::c_ulong)
            .wrapping_sub(deleted) as libc::c_uint as libc::c_uint;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn elf_i386_finish_dynamic_symbol(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
    mut sym: *mut Elf_Internal_Sym,
) -> bool {
    let mut current_block: u64;
    let mut htab: *mut elf_x86_link_hash_table = 0 as *mut elf_x86_link_hash_table;
    let mut plt_entry_size: libc::c_uint = 0;
    let mut eh: *mut elf_x86_link_hash_entry = 0 as *mut elf_x86_link_hash_entry;
    let mut local_undefweak: bool = false;
    let mut use_plt_second: bool = false;
    htab = if is_elf_hash_table((*info).hash) as libc::c_int != 0
        && elf_hash_table_id((*info).hash as *mut elf_link_hash_table) as libc::c_uint
            == I386_ELF_DATA as libc::c_int as libc::c_uint
    {
        (*info).hash as *mut elf_x86_link_hash_table
    } else {
        0 as *mut elf_x86_link_hash_table
    };
    if htab.is_null() {
        return 0 as libc::c_int != 0;
    }
    plt_entry_size = (*htab).plt.plt_entry_size;
    use_plt_second = !((*htab).elf.splt).is_null() && !((*htab).plt_second).is_null();
    eh = h as *mut elf_x86_link_hash_entry;
    if (*eh).no_finish_dynamic_symbol() != 0 {
        _bfd_abort(
            b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
            3526 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 118],
                &[libc::c_char; 118],
            >(
                b"_Bool elf_i386_finish_dynamic_symbol(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, Elf_Internal_Sym *)\0",
            ))
                .as_ptr(),
        );
    }
    local_undefweak = ((*eh).elf.root).type_0() as libc::c_int
        == bfd_link_hash_undefweak as libc::c_int
        && (_bfd_x86_elf_link_symbol_references_local(info, &mut (*eh).elf)
            as libc::c_int != 0
            || ((*info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
                && (*eh).zero_undefweak() as libc::c_int > 0 as libc::c_int);
    if (*h).plt.offset != -(1 as libc::c_int) as bfd_vma {
        let mut plt_index: bfd_vma = 0;
        let mut plt_offset: bfd_vma = 0;
        let mut got_offset: bfd_vma = 0;
        let mut rel: Elf_Internal_Rela = Elf_Internal_Rela {
            r_offset: 0,
            r_info: 0,
            r_addend: 0,
        };
        let mut loc: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut plt: *mut asection = 0 as *mut asection;
        let mut resolved_plt: *mut asection = 0 as *mut asection;
        let mut gotplt: *mut asection = 0 as *mut asection;
        let mut relplt: *mut asection = 0 as *mut asection;
        if !((*htab).elf.splt).is_null() {
            plt = (*htab).elf.splt;
            gotplt = (*htab).elf.sgotplt;
            relplt = (*htab).elf.srelplt;
        } else {
            plt = (*htab).elf.iplt;
            gotplt = (*htab).elf.igotplt;
            relplt = (*htab).elf.irelplt;
        }
        if (*h).dynindx == -(1 as libc::c_int) as libc::c_long && !local_undefweak
            && !(((*h).forced_local() as libc::c_int != 0
                || ((*info).type_0() as libc::c_int == type_pde as libc::c_int
                    || (*info).type_0() as libc::c_int == type_pie as libc::c_int))
                && (*h).def_regular() as libc::c_int != 0
                && (*h).type_0() as libc::c_int == 10 as libc::c_int) || plt.is_null()
            || gotplt.is_null() || relplt.is_null()
        {
            _bfd_abort(
                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                3556 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 118],
                    &[libc::c_char; 118],
                >(
                    b"_Bool elf_i386_finish_dynamic_symbol(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, Elf_Internal_Sym *)\0",
                ))
                    .as_ptr(),
            );
        }
        if plt == (*htab).elf.splt {
            got_offset = ((*h).plt.offset)
                .wrapping_div(plt_entry_size as libc::c_ulong)
                .wrapping_sub((*htab).plt.has_plt0 as libc::c_ulong);
            got_offset = got_offset
                .wrapping_add(3 as libc::c_int as libc::c_ulong)
                .wrapping_mul(4 as libc::c_int as libc::c_ulong);
        } else {
            got_offset = ((*h).plt.offset).wrapping_div(plt_entry_size as libc::c_ulong);
            got_offset = got_offset.wrapping_mul(4 as libc::c_int as libc::c_ulong);
        }
        memcpy(
            ((*plt).contents).offset((*h).plt.offset as isize) as *mut libc::c_void,
            (*htab).plt.plt_entry as *const libc::c_void,
            plt_entry_size as libc::c_ulong,
        );
        if use_plt_second {
            let mut plt_entry: *const bfd_byte = 0 as *const bfd_byte;
            if (*info).type_0() as libc::c_int == type_dll as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int
            {
                plt_entry = (*(*htab).non_lazy_plt).pic_plt_entry;
            } else {
                plt_entry = (*(*htab).non_lazy_plt).plt_entry;
            }
            memcpy(
                ((*(*htab).plt_second).contents).offset((*eh).plt_second.offset as isize)
                    as *mut libc::c_void,
                plt_entry as *const libc::c_void,
                (*(*htab).non_lazy_plt).plt_entry_size as libc::c_ulong,
            );
            resolved_plt = (*htab).plt_second;
            plt_offset = (*eh).plt_second.offset;
        } else {
            resolved_plt = plt;
            plt_offset = (*h).plt.offset;
        }
        if !((*info).type_0() as libc::c_int == type_dll as libc::c_int
            || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
        {
            (Some(
                ((*(*output_bfd).xvec).bfd_putx32).expect("non-null function pointer"),
            ))
                .expect(
                    "non-null function pointer",
                )(
                ((*(*gotplt).output_section).vma)
                    .wrapping_add((*gotplt).output_offset)
                    .wrapping_add(got_offset),
                ((*resolved_plt).contents)
                    .offset(plt_offset as isize)
                    .offset((*htab).plt.plt_got_offset as isize) as *mut libc::c_void,
            );
            if (*htab).elf.target_os as libc::c_uint
                == is_vxworks as libc::c_int as libc::c_uint
            {
                let mut s: libc::c_int = 0;
                let mut k: libc::c_int = 0;
                let mut reloc_index: libc::c_int = 0;
                s = ((*h).plt.offset)
                    .wrapping_sub((*htab).plt.plt_entry_size as libc::c_ulong)
                    .wrapping_div((*htab).plt.plt_entry_size as libc::c_ulong)
                    as libc::c_int;
                if (*info).type_0() as libc::c_int == type_dll as libc::c_int
                    || (*info).type_0() as libc::c_int == type_pie as libc::c_int
                {
                    k = 0 as libc::c_int;
                } else {
                    k = 2 as libc::c_int;
                }
                reloc_index = k + s * 2 as libc::c_int;
                loc = ((*(*htab).srelplt2).contents)
                    .offset(
                        (reloc_index as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<Elf32_External_Rel>()
                                    as libc::c_ulong,
                            ) as isize,
                    );
                rel
                    .r_offset = ((*(*plt).output_section).vma)
                    .wrapping_add((*plt).output_offset)
                    .wrapping_add((*h).plt.offset)
                    .wrapping_add(2 as libc::c_int as libc::c_ulong);
                rel
                    .r_info = (((*(*htab).elf.hgot).indx as libc::c_uint)
                    << 8 as libc::c_int)
                    .wrapping_add(
                        (R_386_32 as libc::c_int & 0xff as libc::c_int) as libc::c_uint,
                    ) as bfd_vma;
                bfd_elf32_swap_reloc_out(output_bfd, &mut rel, loc);
                rel
                    .r_offset = ((*(*(*htab).elf.sgotplt).output_section).vma)
                    .wrapping_add((*(*htab).elf.sgotplt).output_offset)
                    .wrapping_add(got_offset);
                rel
                    .r_info = (((*(*htab).elf.hplt).indx as libc::c_uint)
                    << 8 as libc::c_int)
                    .wrapping_add(
                        (R_386_32 as libc::c_int & 0xff as libc::c_int) as libc::c_uint,
                    ) as bfd_vma;
                bfd_elf32_swap_reloc_out(
                    output_bfd,
                    &mut rel,
                    loc
                        .offset(
                            ::core::mem::size_of::<Elf32_External_Rel>() as libc::c_ulong
                                as isize,
                        ),
                );
            }
        } else {
            (Some(
                ((*(*output_bfd).xvec).bfd_putx32).expect("non-null function pointer"),
            ))
                .expect(
                    "non-null function pointer",
                )(
                got_offset,
                ((*resolved_plt).contents)
                    .offset(plt_offset as isize)
                    .offset((*htab).plt.plt_got_offset as isize) as *mut libc::c_void,
            );
        }
        if !local_undefweak {
            if (*htab).plt.has_plt0 != 0 {
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*(*plt).output_section).vma)
                        .wrapping_add((*plt).output_offset)
                        .wrapping_add((*h).plt.offset)
                        .wrapping_add(
                            (*(*htab).lazy_plt).plt_lazy_offset as libc::c_ulong,
                        ),
                    ((*gotplt).contents).offset(got_offset as isize) as *mut libc::c_void,
                );
            }
            rel
                .r_offset = ((*(*gotplt).output_section).vma)
                .wrapping_add((*gotplt).output_offset)
                .wrapping_add(got_offset);
            if (*h).dynindx == -(1 as libc::c_int) as libc::c_long
                || ((*info).type_0() as libc::c_int == type_pde as libc::c_int
                    || (*info).type_0() as libc::c_int == type_pie as libc::c_int
                    || (*h).other() as libc::c_int & 0x3 as libc::c_int
                        != 0 as libc::c_int) && (*h).def_regular() as libc::c_int != 0
                    && (*h).type_0() as libc::c_int == 10 as libc::c_int
            {
                ((*(*info).callbacks).minfo)
                    .expect(
                        "non-null function pointer",
                    )(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"Local IFUNC function `%s' in %pB\n\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*h).root.root.string,
                    (*(*h).root.u.def.section).owner,
                );
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*h).root.u.def.value)
                        .wrapping_add((*(*(*h).root.u.def.section).output_section).vma)
                        .wrapping_add((*(*h).root.u.def.section).output_offset),
                    ((*gotplt).contents).offset(got_offset as isize) as *mut libc::c_void,
                );
                rel
                    .r_info = ((0 as libc::c_int as libc::c_uint) << 8 as libc::c_int)
                    .wrapping_add(
                        (R_386_IRELATIVE as libc::c_int & 0xff as libc::c_int)
                            as libc::c_uint,
                    ) as bfd_vma;
                if (*(*htab).params).report_relative_reloc() != 0 {
                    _bfd_x86_elf_link_report_relative_reloc(
                        info,
                        relplt,
                        h,
                        sym,
                        b"R_386_IRELATIVE\0" as *const u8 as *const libc::c_char,
                        &mut rel as *mut Elf_Internal_Rela as *const libc::c_void,
                    );
                }
                let fresh7 = (*htab).next_irelative_index;
                (*htab)
                    .next_irelative_index = ((*htab).next_irelative_index)
                    .wrapping_sub(1);
                plt_index = fresh7;
            } else {
                rel
                    .r_info = (((*h).dynindx as libc::c_uint) << 8 as libc::c_int)
                    .wrapping_add(
                        (R_386_JUMP_SLOT as libc::c_int & 0xff as libc::c_int)
                            as libc::c_uint,
                    ) as bfd_vma;
                let fresh8 = (*htab).next_jump_slot_index;
                (*htab)
                    .next_jump_slot_index = ((*htab).next_jump_slot_index)
                    .wrapping_add(1);
                plt_index = fresh8;
            }
            loc = ((*relplt).contents)
                .offset(
                    plt_index
                        .wrapping_mul(
                            ::core::mem::size_of::<Elf32_External_Rel>() as libc::c_ulong,
                        ) as isize,
                );
            bfd_elf32_swap_reloc_out(output_bfd, &mut rel, loc);
            if plt == (*htab).elf.splt && (*htab).plt.has_plt0 != 0 {
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    plt_index
                        .wrapping_mul(
                            ::core::mem::size_of::<Elf32_External_Rel>() as libc::c_ulong,
                        ),
                    ((*plt).contents)
                        .offset((*h).plt.offset as isize)
                        .offset((*(*htab).lazy_plt).plt_reloc_offset as isize)
                        as *mut libc::c_void,
                );
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*h).plt.offset)
                        .wrapping_add(
                            (*(*htab).lazy_plt).plt_plt_offset as libc::c_ulong,
                        )
                        .wrapping_add(4 as libc::c_int as libc::c_ulong)
                        .wrapping_neg(),
                    ((*plt).contents)
                        .offset((*h).plt.offset as isize)
                        .offset((*(*htab).lazy_plt).plt_plt_offset as isize)
                        as *mut libc::c_void,
                );
            }
        }
    } else if (*eh).plt_got.offset != -(1 as libc::c_int) as bfd_vma {
        let mut got_offset_0: bfd_vma = 0;
        let mut plt_offset_0: bfd_vma = 0;
        let mut plt_0: *mut asection = 0 as *mut asection;
        let mut got: *mut asection = 0 as *mut asection;
        let mut gotplt_0: *mut asection = 0 as *mut asection;
        let mut got_plt_entry: *const bfd_byte = 0 as *const bfd_byte;
        plt_0 = (*htab).plt_got;
        got = (*htab).elf.sgot;
        gotplt_0 = (*htab).elf.sgotplt;
        got_offset_0 = (*h).got.offset;
        if got_offset_0 == -(1 as libc::c_int) as bfd_vma || plt_0.is_null()
            || got.is_null() || gotplt_0.is_null()
        {
            _bfd_abort(
                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                3739 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 118],
                    &[libc::c_char; 118],
                >(
                    b"_Bool elf_i386_finish_dynamic_symbol(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, Elf_Internal_Sym *)\0",
                ))
                    .as_ptr(),
            );
        }
        if !((*info).type_0() as libc::c_int == type_dll as libc::c_int
            || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
        {
            got_plt_entry = (*(*htab).non_lazy_plt).plt_entry;
            got_offset_0 = (got_offset_0 as libc::c_ulong)
                .wrapping_add(
                    ((*(*got).output_section).vma).wrapping_add((*got).output_offset),
                ) as bfd_vma as bfd_vma;
        } else {
            got_plt_entry = (*(*htab).non_lazy_plt).pic_plt_entry;
            got_offset_0 = (got_offset_0 as libc::c_ulong)
                .wrapping_add(
                    ((*(*got).output_section).vma)
                        .wrapping_add((*got).output_offset)
                        .wrapping_sub((*(*gotplt_0).output_section).vma)
                        .wrapping_sub((*gotplt_0).output_offset),
                ) as bfd_vma as bfd_vma;
        }
        plt_offset_0 = (*eh).plt_got.offset;
        memcpy(
            ((*plt_0).contents).offset(plt_offset_0 as isize) as *mut libc::c_void,
            got_plt_entry as *const libc::c_void,
            (*(*htab).non_lazy_plt).plt_entry_size as libc::c_ulong,
        );
        (Some(((*(*output_bfd).xvec).bfd_putx32).expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(
            got_offset_0,
            ((*plt_0).contents)
                .offset(plt_offset_0 as isize)
                .offset((*(*htab).non_lazy_plt).plt_got_offset as isize)
                as *mut libc::c_void,
        );
    }
    if !local_undefweak && (*h).def_regular() == 0
        && ((*h).plt.offset != -(1 as libc::c_int) as bfd_vma
            || (*eh).plt_got.offset != -(1 as libc::c_int) as bfd_vma)
    {
        (*sym).st_shndx = 0 as libc::c_int as libc::c_uint;
        if (*h).pointer_equality_needed() == 0 {
            (*sym).st_value = 0 as libc::c_int as bfd_vma;
        }
    }
    _bfd_x86_elf_link_fixup_ifunc_symbol(info, htab, h, sym);
    if (*h).got.offset != -(1 as libc::c_int) as bfd_vma
        && !((*(h as *mut elf_x86_link_hash_entry)).tls_type as libc::c_int
            == 2 as libc::c_int
            || (*(h as *mut elf_x86_link_hash_entry)).tls_type as libc::c_int
                == 2 as libc::c_int | 8 as libc::c_int
            || ((*(h as *mut elf_x86_link_hash_entry)).tls_type as libc::c_int
                == 8 as libc::c_int
                || (*(h as *mut elf_x86_link_hash_entry)).tls_type as libc::c_int
                    == 2 as libc::c_int | 8 as libc::c_int))
        && (*(h as *mut elf_x86_link_hash_entry)).tls_type as libc::c_int
            & 4 as libc::c_int == 0 as libc::c_int && !local_undefweak
    {
        let mut rel_0: Elf_Internal_Rela = Elf_Internal_Rela {
            r_offset: 0,
            r_info: 0,
            r_addend: 0,
        };
        let mut relgot: *mut asection = (*htab).elf.srelgot;
        let mut relative_reloc_name: *const libc::c_char = 0 as *const libc::c_char;
        if ((*htab).elf.sgot).is_null() || ((*htab).elf.srelgot).is_null() {
            _bfd_abort(
                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                3799 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 118],
                    &[libc::c_char; 118],
                >(
                    b"_Bool elf_i386_finish_dynamic_symbol(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, Elf_Internal_Sym *)\0",
                ))
                    .as_ptr(),
            );
        }
        rel_0
            .r_offset = ((*(*(*htab).elf.sgot).output_section).vma)
            .wrapping_add((*(*htab).elf.sgot).output_offset)
            .wrapping_add((*h).got.offset & !(1 as libc::c_int as bfd_vma));
        if (*h).def_regular() as libc::c_int != 0
            && (*h).type_0() as libc::c_int == 10 as libc::c_int
        {
            if (*h).plt.offset == -(1 as libc::c_int) as bfd_vma {
                if ((*htab).elf.splt).is_null() {
                    relgot = (*htab).elf.irelplt;
                }
                if _bfd_x86_elf_link_symbol_references_local(info, h) {
                    ((*(*info).callbacks).minfo)
                        .expect(
                            "non-null function pointer",
                        )(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"Local IFUNC function `%s' in %pB\n\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*h).root.root.string,
                        (*(*h).root.u.def.section).owner,
                    );
                    (Some(
                        ((*(*output_bfd).xvec).bfd_putx32)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        ((*h).root.u.def.value)
                            .wrapping_add(
                                (*(*(*h).root.u.def.section).output_section).vma,
                            )
                            .wrapping_add((*(*h).root.u.def.section).output_offset),
                        ((*(*htab).elf.sgot).contents).offset((*h).got.offset as isize)
                            as *mut libc::c_void,
                    );
                    rel_0
                        .r_info = ((0 as libc::c_int as libc::c_uint)
                        << 8 as libc::c_int)
                        .wrapping_add(
                            (R_386_IRELATIVE as libc::c_int & 0xff as libc::c_int)
                                as libc::c_uint,
                        ) as bfd_vma;
                    relative_reloc_name = b"R_386_IRELATIVE\0" as *const u8
                        as *const libc::c_char;
                    current_block = 9073771928613846474;
                } else {
                    current_block = 8599093700587430100;
                }
            } else if (*info).type_0() as libc::c_int == type_dll as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int
            {
                current_block = 8599093700587430100;
            } else {
                let mut plt_1: *mut asection = 0 as *mut asection;
                let mut plt_offset_1: bfd_vma = 0;
                if (*h).pointer_equality_needed() == 0 {
                    _bfd_abort(
                        b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                        3850 as libc::c_int,
                        (*::core::mem::transmute::<
                            &[u8; 118],
                            &[libc::c_char; 118],
                        >(
                            b"_Bool elf_i386_finish_dynamic_symbol(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, Elf_Internal_Sym *)\0",
                        ))
                            .as_ptr(),
                    );
                }
                if !((*htab).plt_second).is_null() {
                    plt_1 = (*htab).plt_second;
                    plt_offset_1 = (*eh).plt_second.offset;
                } else {
                    plt_1 = if !((*htab).elf.splt).is_null() {
                        (*htab).elf.splt
                    } else {
                        (*htab).elf.iplt
                    };
                    plt_offset_1 = (*h).plt.offset;
                }
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*(*plt_1).output_section).vma)
                        .wrapping_add((*plt_1).output_offset)
                        .wrapping_add(plt_offset_1),
                    ((*(*htab).elf.sgot).contents).offset((*h).got.offset as isize)
                        as *mut libc::c_void,
                );
                return 1 as libc::c_int != 0;
            }
        } else if ((*info).type_0() as libc::c_int == type_dll as libc::c_int
            || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
            && _bfd_x86_elf_link_symbol_references_local(info, h) as libc::c_int != 0
        {
            if !((*h).got.offset & 1 as libc::c_int as libc::c_ulong
                != 0 as libc::c_int as libc::c_ulong)
            {
                bfd_assert(
                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                    3875 as libc::c_int,
                );
            }
            rel_0
                .r_info = ((0 as libc::c_int as libc::c_uint) << 8 as libc::c_int)
                .wrapping_add(
                    (R_386_RELATIVE as libc::c_int & 0xff as libc::c_int) as libc::c_uint,
                ) as bfd_vma;
            relative_reloc_name = b"R_386_RELATIVE\0" as *const u8
                as *const libc::c_char;
            current_block = 9073771928613846474;
        } else {
            if !((*h).got.offset & 1 as libc::c_int as libc::c_ulong
                == 0 as libc::c_int as libc::c_ulong)
            {
                bfd_assert(
                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                    3881 as libc::c_int,
                );
            }
            current_block = 8599093700587430100;
        }
        match current_block {
            8599093700587430100 => {
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    0 as libc::c_int as bfd_vma,
                    ((*(*htab).elf.sgot).contents).offset((*h).got.offset as isize)
                        as *mut libc::c_void,
                );
                rel_0
                    .r_info = (((*h).dynindx as libc::c_uint) << 8 as libc::c_int)
                    .wrapping_add(
                        (R_386_GLOB_DAT as libc::c_int & 0xff as libc::c_int)
                            as libc::c_uint,
                    ) as bfd_vma;
            }
            _ => {}
        }
        if !relative_reloc_name.is_null()
            && (*(*htab).params).report_relative_reloc() as libc::c_int != 0
        {
            _bfd_x86_elf_link_report_relative_reloc(
                info,
                relgot,
                h,
                sym,
                relative_reloc_name,
                &mut rel_0 as *mut Elf_Internal_Rela as *const libc::c_void,
            );
        }
        elf_append_rel(output_bfd, relgot, &mut rel_0);
    }
    if (*h).needs_copy() != 0 {
        let mut rel_1: Elf_Internal_Rela = Elf_Internal_Rela {
            r_offset: 0,
            r_info: 0,
            r_addend: 0,
        };
        let mut s_0: *mut asection = 0 as *mut asection;
        if (*h).dynindx == -(1 as libc::c_int) as libc::c_long
            || ((*h).root).type_0() as libc::c_int
                != bfd_link_hash_defined as libc::c_int
                && ((*h).root).type_0() as libc::c_int
                    != bfd_link_hash_defweak as libc::c_int
            || ((*htab).elf.srelbss).is_null() || ((*htab).elf.sreldynrelro).is_null()
        {
            _bfd_abort(
                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                3902 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 118],
                    &[libc::c_char; 118],
                >(
                    b"_Bool elf_i386_finish_dynamic_symbol(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, Elf_Internal_Sym *)\0",
                ))
                    .as_ptr(),
            );
        }
        rel_1
            .r_offset = ((*h).root.u.def.value)
            .wrapping_add((*(*(*h).root.u.def.section).output_section).vma)
            .wrapping_add((*(*h).root.u.def.section).output_offset);
        rel_1
            .r_info = (((*h).dynindx as libc::c_uint) << 8 as libc::c_int)
            .wrapping_add(
                (R_386_COPY as libc::c_int & 0xff as libc::c_int) as libc::c_uint,
            ) as bfd_vma;
        if (*h).root.u.def.section == (*htab).elf.sdynrelro {
            s_0 = (*htab).elf.sreldynrelro;
        } else {
            s_0 = (*htab).elf.srelbss;
        }
        elf_append_rel(output_bfd, s_0, &mut rel_1);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_i386_finish_local_dynamic_symbol(
    mut slot: *mut *mut libc::c_void,
    mut inf: *mut libc::c_void,
) -> libc::c_int {
    let mut h: *mut elf_link_hash_entry = *slot as *mut elf_link_hash_entry;
    let mut info: *mut bfd_link_info = inf as *mut bfd_link_info;
    return elf_i386_finish_dynamic_symbol(
        (*info).output_bfd,
        info,
        h,
        0 as *mut Elf_Internal_Sym,
    ) as libc::c_int;
}
unsafe extern "C" fn elf_i386_pie_finish_undefweak_symbol(
    mut bh: *mut bfd_hash_entry,
    mut inf: *mut libc::c_void,
) -> bool {
    let mut h: *mut elf_link_hash_entry = bh as *mut elf_link_hash_entry;
    let mut info: *mut bfd_link_info = inf as *mut bfd_link_info;
    if ((*h).root).type_0() as libc::c_int != bfd_link_hash_undefweak as libc::c_int
        || (*h).dynindx != -(1 as libc::c_int) as libc::c_long
    {
        return 1 as libc::c_int != 0;
    }
    return elf_i386_finish_dynamic_symbol(
        (*info).output_bfd,
        info,
        h,
        0 as *mut Elf_Internal_Sym,
    );
}
unsafe extern "C" fn elf_i386_reloc_type_class(
    mut info: *const bfd_link_info,
    mut rel_sec: *const asection,
    mut rela: *const Elf_Internal_Rela,
) -> elf_reloc_type_class {
    let mut abfd: *mut bfd = (*info).output_bfd;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut htab: *mut elf_link_hash_table = elf_hash_table(info);
    if !((*htab).dynsym).is_null() && !((*(*htab).dynsym).contents).is_null() {
        let mut r_symndx: libc::c_ulong = (*rela).r_info >> 8 as libc::c_int;
        if r_symndx != 0 as libc::c_int as libc::c_ulong {
            let mut sym: Elf_Internal_Sym = Elf_Internal_Sym {
                st_value: 0,
                st_size: 0,
                st_name: 0,
                st_info: 0,
                st_other: 0,
                st_target_internal: 0,
                st_shndx: 0,
            };
            if !((*(*bed).s).swap_symbol_in)
                .expect(
                    "non-null function pointer",
                )(
                abfd,
                ((*(*htab).dynsym).contents)
                    .offset(
                        r_symndx
                            .wrapping_mul(
                                ::core::mem::size_of::<Elf32_External_Sym>()
                                    as libc::c_ulong,
                            ) as isize,
                    ) as *const libc::c_void,
                0 as *const libc::c_void,
                &mut sym,
            )
            {
                _bfd_abort(
                    b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                    3977 as libc::c_int,
                    (*::core::mem::transmute::<
                        &[u8; 127],
                        &[libc::c_char; 127],
                    >(
                        b"enum elf_reloc_type_class elf_i386_reloc_type_class(const struct bfd_link_info *, const asection *, const Elf_Internal_Rela *)\0",
                    ))
                        .as_ptr(),
                );
            }
            if sym.st_info as libc::c_int & 0xf as libc::c_int == 10 as libc::c_int {
                return reloc_class_ifunc;
            }
        }
    }
    match (*rela).r_info & 0xff as libc::c_int as libc::c_ulong {
        42 => return reloc_class_ifunc,
        8 => return reloc_class_relative,
        7 => return reloc_class_plt,
        5 => return reloc_class_copy,
        _ => return reloc_class_normal,
    };
}
unsafe extern "C" fn elf_i386_finish_dynamic_sections(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut htab: *mut elf_x86_link_hash_table = 0 as *mut elf_x86_link_hash_table;
    htab = _bfd_x86_elf_finish_dynamic_sections(output_bfd, info);
    if htab.is_null() {
        return 0 as libc::c_int != 0;
    }
    if !(*htab).elf.dynamic_sections_created {
        return 1 as libc::c_int != 0;
    }
    if !((*htab).elf.splt).is_null()
        && (*(*htab).elf.splt).size > 0 as libc::c_int as libc::c_ulong
    {
        (*((*(*(*htab).elf.splt).output_section).used_by_bfd
            as *mut bfd_elf_section_data))
            .this_hdr
            .sh_entsize = 4 as libc::c_int as bfd_size_type;
        if (*htab).plt.has_plt0 != 0 {
            memcpy(
                (*(*htab).elf.splt).contents as *mut libc::c_void,
                (*htab).plt.plt0_entry as *const libc::c_void,
                (*(*htab).lazy_plt).plt0_entry_size as libc::c_ulong,
            );
            memset(
                ((*(*htab).elf.splt).contents)
                    .offset((*(*htab).lazy_plt).plt0_entry_size as isize)
                    as *mut libc::c_void,
                (*htab).plt0_pad_byte as libc::c_int,
                ((*htab).plt.plt_entry_size)
                    .wrapping_sub((*(*htab).lazy_plt).plt0_entry_size) as libc::c_ulong,
            );
            if !((*info).type_0() as libc::c_int == type_dll as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
            {
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*(*(*htab).elf.sgotplt).output_section).vma)
                        .wrapping_add((*(*htab).elf.sgotplt).output_offset)
                        .wrapping_add(4 as libc::c_int as libc::c_ulong),
                    ((*(*htab).elf.splt).contents)
                        .offset((*(*htab).lazy_plt).plt0_got1_offset as isize)
                        as *mut libc::c_void,
                );
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*(*(*htab).elf.sgotplt).output_section).vma)
                        .wrapping_add((*(*htab).elf.sgotplt).output_offset)
                        .wrapping_add(8 as libc::c_int as libc::c_ulong),
                    ((*(*htab).elf.splt).contents)
                        .offset((*(*htab).lazy_plt).plt0_got2_offset as isize)
                        as *mut libc::c_void,
                );
                if (*htab).elf.target_os as libc::c_uint
                    == is_vxworks as libc::c_int as libc::c_uint
                {
                    let mut rel: Elf_Internal_Rela = Elf_Internal_Rela {
                        r_offset: 0,
                        r_info: 0,
                        r_addend: 0,
                    };
                    let mut num_plts: libc::c_int = ((*(*htab).elf.splt).size)
                        .wrapping_div((*htab).plt.plt_entry_size as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
                    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                    let mut srelplt2: *mut asection = (*htab).srelplt2;
                    rel
                        .r_offset = ((*(*(*htab).elf.splt).output_section).vma)
                        .wrapping_add((*(*htab).elf.splt).output_offset)
                        .wrapping_add(
                            (*(*htab).lazy_plt).plt0_got1_offset as libc::c_ulong,
                        );
                    rel
                        .r_info = (((*(*htab).elf.hgot).indx as libc::c_uint)
                        << 8 as libc::c_int)
                        .wrapping_add(
                            (R_386_32 as libc::c_int & 0xff as libc::c_int)
                                as libc::c_uint,
                        ) as bfd_vma;
                    bfd_elf32_swap_reloc_out(output_bfd, &mut rel, (*srelplt2).contents);
                    rel
                        .r_offset = ((*(*(*htab).elf.splt).output_section).vma)
                        .wrapping_add((*(*htab).elf.splt).output_offset)
                        .wrapping_add(
                            (*(*htab).lazy_plt).plt0_got2_offset as libc::c_ulong,
                        );
                    rel
                        .r_info = (((*(*htab).elf.hgot).indx as libc::c_uint)
                        << 8 as libc::c_int)
                        .wrapping_add(
                            (R_386_32 as libc::c_int & 0xff as libc::c_int)
                                as libc::c_uint,
                        ) as bfd_vma;
                    bfd_elf32_swap_reloc_out(
                        output_bfd,
                        &mut rel,
                        ((*srelplt2).contents)
                            .offset(
                                ::core::mem::size_of::<Elf32_External_Rel>()
                                    as libc::c_ulong as isize,
                            ),
                    );
                    p = (*srelplt2).contents;
                    if (*info).type_0() as libc::c_int == type_dll as libc::c_int
                        || (*info).type_0() as libc::c_int == type_pie as libc::c_int
                    {
                        p = p
                            .offset(
                                (0 as libc::c_int as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<Elf32_External_Rel>()
                                            as libc::c_ulong,
                                    ) as isize,
                            );
                    } else {
                        p = p
                            .offset(
                                (2 as libc::c_int as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<Elf32_External_Rel>()
                                            as libc::c_ulong,
                                    ) as isize,
                            );
                    }
                    while num_plts != 0 {
                        bfd_elf32_swap_reloc_in(output_bfd, p, &mut rel);
                        rel
                            .r_info = (((*(*htab).elf.hgot).indx as libc::c_uint)
                            << 8 as libc::c_int)
                            .wrapping_add(
                                (R_386_32 as libc::c_int & 0xff as libc::c_int)
                                    as libc::c_uint,
                            ) as bfd_vma;
                        bfd_elf32_swap_reloc_out(output_bfd, &mut rel, p);
                        p = p
                            .offset(
                                ::core::mem::size_of::<Elf32_External_Rel>()
                                    as libc::c_ulong as isize,
                            );
                        bfd_elf32_swap_reloc_in(output_bfd, p, &mut rel);
                        rel
                            .r_info = (((*(*htab).elf.hplt).indx as libc::c_uint)
                            << 8 as libc::c_int)
                            .wrapping_add(
                                (R_386_32 as libc::c_int & 0xff as libc::c_int)
                                    as libc::c_uint,
                            ) as bfd_vma;
                        bfd_elf32_swap_reloc_out(output_bfd, &mut rel, p);
                        p = p
                            .offset(
                                ::core::mem::size_of::<Elf32_External_Rel>()
                                    as libc::c_ulong as isize,
                            );
                        num_plts -= 1;
                        num_plts;
                    }
                }
            }
        }
    }
    if (*info).type_0() as libc::c_int == type_pie as libc::c_int {
        bfd_hash_traverse(
            &mut (*(*info).hash).table,
            Some(
                elf_i386_pie_finish_undefweak_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            info as *mut libc::c_void,
        );
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_i386_output_arch_local_syms(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut flaginfo: *mut libc::c_void,
    mut func: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *mut Elf_Internal_Sym,
            *mut asection,
            *mut elf_link_hash_entry,
        ) -> libc::c_int,
    >,
) -> bool {
    let mut htab: *mut elf_x86_link_hash_table = if is_elf_hash_table((*info).hash)
        as libc::c_int != 0
        && elf_hash_table_id((*info).hash as *mut elf_link_hash_table) as libc::c_uint
            == I386_ELF_DATA as libc::c_int as libc::c_uint
    {
        (*info).hash as *mut elf_x86_link_hash_table
    } else {
        0 as *mut elf_x86_link_hash_table
    };
    if htab.is_null() {
        return 0 as libc::c_int != 0;
    }
    htab_traverse(
        (*htab).loc_hash_table,
        Some(
            elf_i386_finish_local_dynamic_symbol
                as unsafe extern "C" fn(
                    *mut *mut libc::c_void,
                    *mut libc::c_void,
                ) -> libc::c_int,
        ),
        info as *mut libc::c_void,
    );
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_i386_get_synthetic_symtab(
    mut abfd: *mut bfd,
    mut symcount: libc::c_long,
    mut syms: *mut *mut asymbol,
    mut dynsymcount: libc::c_long,
    mut dynsyms: *mut *mut asymbol,
    mut ret: *mut *mut asymbol,
) -> libc::c_long {
    let mut count: libc::c_long = 0;
    let mut i: libc::c_long = 0;
    let mut n: libc::c_long = 0;
    let mut j: libc::c_int = 0;
    let mut plt_contents: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut relsize: libc::c_long = 0;
    let mut lazy_plt: *const elf_x86_lazy_plt_layout = 0
        as *const elf_x86_lazy_plt_layout;
    let mut non_lazy_plt: *const elf_x86_non_lazy_plt_layout = 0
        as *const elf_x86_non_lazy_plt_layout;
    let mut lazy_ibt_plt: *const elf_x86_lazy_plt_layout = 0
        as *const elf_x86_lazy_plt_layout;
    let mut non_lazy_ibt_plt: *const elf_x86_non_lazy_plt_layout = 0
        as *const elf_x86_non_lazy_plt_layout;
    let mut plt: *mut asection = 0 as *mut asection;
    let mut got_addr: bfd_vma = 0;
    let mut plt_type: elf_x86_plt_type = plt_non_lazy;
    let mut plts: [elf_x86_plt; 4] = [
        {
            let mut init = elf_x86_plt {
                name: b".plt\0" as *const u8 as *const libc::c_char,
                sec: 0 as *mut asection,
                contents: 0 as *mut bfd_byte,
                type_0: plt_unknown,
                plt_got_offset: 0 as libc::c_int as libc::c_uint,
                plt_entry_size: 0 as libc::c_int as libc::c_uint,
                plt_got_insn_size: 0 as libc::c_int as libc::c_uint,
                count: 0 as libc::c_int as libc::c_long,
            };
            init
        },
        {
            let mut init = elf_x86_plt {
                name: b".plt.got\0" as *const u8 as *const libc::c_char,
                sec: 0 as *mut asection,
                contents: 0 as *mut bfd_byte,
                type_0: plt_non_lazy,
                plt_got_offset: 0 as libc::c_int as libc::c_uint,
                plt_entry_size: 0 as libc::c_int as libc::c_uint,
                plt_got_insn_size: 0 as libc::c_int as libc::c_uint,
                count: 0 as libc::c_int as libc::c_long,
            };
            init
        },
        {
            let mut init = elf_x86_plt {
                name: b".plt.sec\0" as *const u8 as *const libc::c_char,
                sec: 0 as *mut asection,
                contents: 0 as *mut bfd_byte,
                type_0: plt_second,
                plt_got_offset: 0 as libc::c_int as libc::c_uint,
                plt_entry_size: 0 as libc::c_int as libc::c_uint,
                plt_got_insn_size: 0 as libc::c_int as libc::c_uint,
                count: 0 as libc::c_int as libc::c_long,
            };
            init
        },
        {
            let mut init = elf_x86_plt {
                name: 0 as *const libc::c_char,
                sec: 0 as *mut asection,
                contents: 0 as *mut bfd_byte,
                type_0: plt_non_lazy,
                plt_got_offset: 0 as libc::c_int as libc::c_uint,
                plt_entry_size: 0 as libc::c_int as libc::c_uint,
                plt_got_insn_size: 0 as libc::c_int as libc::c_uint,
                count: 0 as libc::c_int as libc::c_long,
            };
            init
        },
    ];
    *ret = 0 as *mut asymbol;
    if (*abfd).flags & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int as libc::c_long;
    }
    if dynsymcount <= 0 as libc::c_int as libc::c_long {
        return 0 as libc::c_int as libc::c_long;
    }
    relsize = (Some(
        ((*(*abfd).xvec)._bfd_get_dynamic_reloc_upper_bound)
            .expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(abfd);
    if relsize <= 0 as libc::c_int as libc::c_long {
        return -(1 as libc::c_int) as libc::c_long;
    }
    non_lazy_plt = 0 as *const elf_x86_non_lazy_plt_layout;
    lazy_plt = 0 as *const elf_x86_lazy_plt_layout;
    non_lazy_ibt_plt = 0 as *const elf_x86_non_lazy_plt_layout;
    lazy_ibt_plt = 0 as *const elf_x86_lazy_plt_layout;
    match (*((*(*abfd).xvec).backend_data as *const elf_backend_data)).target_os
        as libc::c_uint
    {
        0 | 1 => {
            non_lazy_plt = &elf_i386_non_lazy_plt;
            lazy_ibt_plt = &elf_i386_lazy_ibt_plt;
            non_lazy_ibt_plt = &elf_i386_non_lazy_ibt_plt;
        }
        2 => {}
        _ => {
            _bfd_abort(
                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                4195 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 90],
                    &[libc::c_char; 90],
                >(
                    b"long elf_i386_get_synthetic_symtab(bfd *, long, asymbol **, long, asymbol **, asymbol **)\0",
                ))
                    .as_ptr(),
            );
        }
    }
    lazy_plt = &elf_i386_lazy_plt;
    got_addr = 0 as libc::c_int as bfd_vma;
    count = 0 as libc::c_int as libc::c_long;
    j = 0 as libc::c_int;
    while !(plts[j as usize].name).is_null() {
        plt = bfd_get_section_by_name(abfd, plts[j as usize].name);
        if !(plt.is_null() || (*plt).size == 0 as libc::c_int as libc::c_ulong) {
            plt_contents = bfd_malloc((*plt).size) as *mut bfd_byte;
            if plt_contents.is_null() {
                break;
            }
            if !bfd_get_section_contents(
                abfd,
                plt,
                plt_contents as *mut libc::c_void,
                0 as libc::c_int as file_ptr,
                (*plt).size,
            ) {
                free(plt_contents as *mut libc::c_void);
                break;
            } else {
                plt_type = plt_unknown;
                if plts[j as usize].type_0 as libc::c_int == plt_unknown as libc::c_int
                    && (*plt).size
                        >= ((*lazy_plt).plt0_entry_size)
                            .wrapping_add((*lazy_plt).plt_entry_size) as libc::c_ulong
                {
                    if memcmp(
                        plt_contents as *const libc::c_void,
                        (*lazy_plt).plt0_entry as *const libc::c_void,
                        (*lazy_plt).plt0_got1_offset as libc::c_ulong,
                    ) == 0 as libc::c_int
                    {
                        if !lazy_ibt_plt.is_null()
                            && memcmp(
                                plt_contents
                                    .offset((*lazy_ibt_plt).plt0_entry_size as isize)
                                    as *const libc::c_void,
                                (*lazy_ibt_plt).plt_entry as *const libc::c_void,
                                (*lazy_ibt_plt).plt_got_offset as libc::c_ulong,
                            ) == 0 as libc::c_int
                        {
                            plt_type = (plt_lazy as libc::c_int
                                | plt_second as libc::c_int) as elf_x86_plt_type;
                        } else {
                            plt_type = plt_lazy;
                        }
                    } else if memcmp(
                        plt_contents as *const libc::c_void,
                        (*lazy_plt).pic_plt0_entry as *const libc::c_void,
                        (*lazy_plt).plt0_got1_offset as libc::c_ulong,
                    ) == 0 as libc::c_int
                    {
                        if !lazy_ibt_plt.is_null()
                            && memcmp(
                                plt_contents
                                    .offset((*lazy_ibt_plt).plt0_entry_size as isize)
                                    as *const libc::c_void,
                                (*lazy_ibt_plt).pic_plt_entry as *const libc::c_void,
                                (*lazy_ibt_plt).plt_got_offset as libc::c_ulong,
                            ) == 0 as libc::c_int
                        {
                            plt_type = (plt_lazy as libc::c_int | plt_pic as libc::c_int
                                | plt_second as libc::c_int) as elf_x86_plt_type;
                        } else {
                            plt_type = (plt_lazy as libc::c_int | plt_pic as libc::c_int)
                                as elf_x86_plt_type;
                        }
                    }
                }
                if !non_lazy_plt.is_null()
                    && (plt_type as libc::c_int == plt_unknown as libc::c_int
                        || plt_type as libc::c_int == plt_non_lazy as libc::c_int)
                    && (*plt).size >= (*non_lazy_plt).plt_entry_size as libc::c_ulong
                {
                    if memcmp(
                        plt_contents as *const libc::c_void,
                        (*non_lazy_plt).plt_entry as *const libc::c_void,
                        (*non_lazy_plt).plt_got_offset as libc::c_ulong,
                    ) == 0 as libc::c_int
                    {
                        plt_type = plt_non_lazy;
                    } else if memcmp(
                        plt_contents as *const libc::c_void,
                        (*non_lazy_plt).pic_plt_entry as *const libc::c_void,
                        (*non_lazy_plt).plt_got_offset as libc::c_ulong,
                    ) == 0 as libc::c_int
                    {
                        plt_type = plt_pic;
                    }
                }
                if !non_lazy_ibt_plt.is_null()
                    && (plt_type as libc::c_int == plt_unknown as libc::c_int
                        || plt_type as libc::c_int == plt_second as libc::c_int)
                    && (*plt).size >= (*non_lazy_ibt_plt).plt_entry_size as libc::c_ulong
                {
                    if memcmp(
                        plt_contents as *const libc::c_void,
                        (*non_lazy_ibt_plt).plt_entry as *const libc::c_void,
                        (*non_lazy_ibt_plt).plt_got_offset as libc::c_ulong,
                    ) == 0 as libc::c_int
                    {
                        plt_type = plt_second;
                        non_lazy_plt = non_lazy_ibt_plt;
                    } else if memcmp(
                        plt_contents as *const libc::c_void,
                        (*non_lazy_ibt_plt).pic_plt_entry as *const libc::c_void,
                        (*non_lazy_ibt_plt).plt_got_offset as libc::c_ulong,
                    ) == 0 as libc::c_int
                    {
                        plt_type = (plt_second as libc::c_int | plt_pic as libc::c_int)
                            as elf_x86_plt_type;
                        non_lazy_plt = non_lazy_ibt_plt;
                    }
                }
                if plt_type as libc::c_int == plt_unknown as libc::c_int {
                    free(plt_contents as *mut libc::c_void);
                } else {
                    plts[j as usize].sec = plt;
                    plts[j as usize].type_0 = plt_type;
                    if plt_type as libc::c_int & plt_lazy as libc::c_int != 0 {
                        plts[j as usize].plt_got_offset = (*lazy_plt).plt_got_offset;
                        plts[j as usize].plt_entry_size = (*lazy_plt).plt_entry_size;
                        i = 1 as libc::c_int as libc::c_long;
                    } else {
                        plts[j as usize].plt_got_offset = (*non_lazy_plt).plt_got_offset;
                        plts[j as usize].plt_entry_size = (*non_lazy_plt).plt_entry_size;
                        i = 0 as libc::c_int as libc::c_long;
                    }
                    if plt_type as libc::c_int
                        & (plt_lazy as libc::c_int | plt_second as libc::c_int)
                        == plt_lazy as libc::c_int | plt_second as libc::c_int
                    {
                        plts[j as usize].count = 0 as libc::c_int as libc::c_long;
                    } else {
                        n = ((*plt).size)
                            .wrapping_div(
                                plts[j as usize].plt_entry_size as libc::c_ulong,
                            ) as libc::c_long;
                        plts[j as usize].count = n;
                        count += n - i;
                    }
                    plts[j as usize].contents = plt_contents;
                    if plt_type as libc::c_int & plt_pic as libc::c_int != 0 {
                        got_addr = -(1 as libc::c_int) as bfd_vma;
                    }
                }
            }
        }
        j += 1;
        j;
    }
    return _bfd_x86_elf_get_synthetic_symtab(
        abfd,
        count,
        relsize,
        got_addr,
        plts.as_mut_ptr(),
        dynsyms,
        ret,
    );
}
unsafe extern "C" fn elf_i386_link_setup_gnu_properties(
    mut info: *mut bfd_link_info,
) -> *mut bfd {
    let mut init_table: elf_x86_init_table = elf_x86_init_table {
        lazy_plt: 0 as *const elf_x86_lazy_plt_layout,
        non_lazy_plt: 0 as *const elf_x86_non_lazy_plt_layout,
        lazy_ibt_plt: 0 as *const elf_x86_lazy_plt_layout,
        non_lazy_ibt_plt: 0 as *const elf_x86_non_lazy_plt_layout,
        plt0_pad_byte: 0,
        r_info: None,
        r_sym: None,
    };
    match (*((*(*(*info).output_bfd).xvec).backend_data as *const elf_backend_data))
        .target_os as libc::c_uint
    {
        0 | 1 => {
            init_table.plt0_pad_byte = 0 as libc::c_int as bfd_byte;
            init_table.lazy_plt = &elf_i386_lazy_plt;
            init_table.non_lazy_plt = &elf_i386_non_lazy_plt;
            init_table.lazy_ibt_plt = &elf_i386_lazy_ibt_plt;
            init_table.non_lazy_ibt_plt = &elf_i386_non_lazy_ibt_plt;
        }
        2 => {
            init_table.plt0_pad_byte = 0x90 as libc::c_int as bfd_byte;
            init_table.lazy_plt = &elf_i386_lazy_plt;
            init_table.non_lazy_plt = 0 as *const elf_x86_non_lazy_plt_layout;
            init_table.lazy_ibt_plt = 0 as *const elf_x86_lazy_plt_layout;
            init_table.non_lazy_ibt_plt = 0 as *const elf_x86_non_lazy_plt_layout;
        }
        _ => {
            _bfd_abort(
                b"elf32-i386.c\0" as *const u8 as *const libc::c_char,
                4360 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 64],
                    &[libc::c_char; 64],
                >(b"bfd *elf_i386_link_setup_gnu_properties(struct bfd_link_info *)\0"))
                    .as_ptr(),
            );
        }
    }
    init_table
        .r_info = Some(
        elf32_r_info as unsafe extern "C" fn(bfd_vma, bfd_vma) -> bfd_vma,
    );
    init_table.r_sym = Some(elf32_r_sym as unsafe extern "C" fn(bfd_vma) -> bfd_vma);
    return _bfd_x86_elf_link_setup_gnu_properties(info, &mut init_table);
}
static mut elf32_i386_sol2_bed: elf_backend_data = elf_backend_data {
    arch: bfd_arch_unknown,
    target_id: 0 as elf_target_id,
    target_os: is_normal,
    elf_machine_code: 0,
    elf_osabi: 0,
    maxpagesize: 0,
    minpagesize: 0,
    commonpagesize: 0,
    relropagesize: 0,
    dynamic_sec_flags: 0,
    arch_data: 0 as *const libc::c_void,
    elf_info_to_howto: None,
    elf_info_to_howto_rel: None,
    elf_backend_sym_is_global: None,
    elf_backend_object_p: None,
    elf_backend_symbol_processing: None,
    elf_backend_symbol_table_processing: None,
    elf_backend_get_symbol_type: None,
    elf_backend_archive_symbol_lookup: None,
    elf_backend_name_local_section_symbols: None,
    elf_backend_section_processing: None,
    elf_backend_section_from_shdr: None,
    elf_backend_section_flags: None,
    get_sec_type_attr: None,
    elf_backend_section_from_phdr: None,
    elf_backend_fake_sections: None,
    elf_backend_section_from_bfd_section: None,
    elf_add_symbol_hook: None,
    elf_backend_link_output_symbol_hook: None,
    elf_backend_create_dynamic_sections: None,
    elf_backend_omit_section_dynsym: None,
    relocs_compatible: None,
    check_relocs: None,
    check_directives: None,
    notice_as_needed: None,
    elf_backend_adjust_dynamic_symbol: None,
    elf_backend_always_size_sections: None,
    elf_backend_size_dynamic_sections: None,
    elf_backend_strip_zero_sized_dynamic_sections: None,
    elf_backend_init_index_section: None,
    elf_backend_relocate_section: None,
    elf_backend_finish_dynamic_symbol: None,
    elf_backend_finish_dynamic_sections: None,
    elf_backend_begin_write_processing: None,
    elf_backend_final_write_processing: None,
    elf_backend_additional_program_headers: None,
    elf_backend_modify_segment_map: None,
    elf_backend_modify_headers: None,
    elf_backend_allow_non_load_phdr: None,
    gc_keep: None,
    gc_mark_dynamic_ref: None,
    gc_mark_hook: None,
    gc_mark_extra_sections: None,
    elf_backend_init_file_header: None,
    elf_backend_print_symbol_all: None,
    elf_backend_output_arch_local_syms: None,
    elf_backend_output_arch_syms: None,
    elf_backend_filter_implib_symbols: None,
    elf_backend_copy_indirect_symbol: None,
    elf_backend_hide_symbol: None,
    elf_backend_fixup_symbol: None,
    elf_backend_merge_symbol_attribute: None,
    elf_backend_get_target_dtag: None,
    elf_backend_ignore_undef_symbol: None,
    elf_backend_emit_relocs: None,
    elf_backend_update_relocs: None,
    elf_backend_count_relocs: None,
    elf_backend_count_additional_relocs: None,
    sort_relocs_p: None,
    elf_backend_grok_prstatus: None,
    elf_backend_grok_psinfo: None,
    elf_backend_grok_freebsd_prstatus: None,
    elf_backend_write_core_note: None,
    elf_backend_lookup_section_flags_hook: None,
    elf_backend_reloc_type_class: None,
    elf_backend_discard_info: None,
    elf_backend_ignore_discarded_relocs: None,
    action_discarded: None,
    elf_backend_eh_frame_address_size: None,
    elf_backend_can_make_relative_eh_frame: None,
    elf_backend_can_make_lsda_relative_eh_frame: None,
    elf_backend_encode_eh_address: None,
    elf_backend_write_section: None,
    elf_backend_elfsym_local_is_section: None,
    elf_backend_mips_irix_compat: None,
    elf_backend_mips_rtype_to_howto: None,
    elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
    elf_backend_bfd_from_remote_memory: None,
    elf_backend_core_find_build_id: None,
    plt_sym_val: None,
    common_definition: None,
    common_section_index: None,
    common_section: None,
    merge_symbol: None,
    elf_hash_symbol: None,
    record_xhash_symbol: None,
    is_function_type: None,
    maybe_function_sym: None,
    get_reloc_section: None,
    elf_backend_copy_special_section_fields: None,
    link_order_error_handler: None,
    relplt_name: 0 as *const libc::c_char,
    elf_machine_alt1: 0,
    elf_machine_alt2: 0,
    s: 0 as *const elf_size_info,
    special_sections: 0 as *const bfd_elf_special_section,
    got_header_size: 0,
    got_elt_size: None,
    obj_attrs_vendor: 0 as *const libc::c_char,
    obj_attrs_section: 0 as *const libc::c_char,
    obj_attrs_arg_type: None,
    obj_attrs_section_type: 0,
    obj_attrs_order: None,
    obj_attrs_handle_unknown: None,
    parse_gnu_properties: None,
    merge_gnu_properties: None,
    setup_gnu_properties: None,
    fixup_gnu_properties: None,
    compact_eh_encoding: None,
    cant_unwind_opcode: None,
    symbol_section_index: None,
    init_secondary_reloc_section: None,
    slurp_secondary_relocs: None,
    write_secondary_relocs: None,
    static_tls_alignment: 0,
    stack_align: 0,
    elf_strtab_flags: 0,
    collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
    c2rust_padding: [0; 4],
};
static mut elf32_i386_fbsd_bed: elf_backend_data = elf_backend_data {
    arch: bfd_arch_unknown,
    target_id: 0 as elf_target_id,
    target_os: is_normal,
    elf_machine_code: 0,
    elf_osabi: 0,
    maxpagesize: 0,
    minpagesize: 0,
    commonpagesize: 0,
    relropagesize: 0,
    dynamic_sec_flags: 0,
    arch_data: 0 as *const libc::c_void,
    elf_info_to_howto: None,
    elf_info_to_howto_rel: None,
    elf_backend_sym_is_global: None,
    elf_backend_object_p: None,
    elf_backend_symbol_processing: None,
    elf_backend_symbol_table_processing: None,
    elf_backend_get_symbol_type: None,
    elf_backend_archive_symbol_lookup: None,
    elf_backend_name_local_section_symbols: None,
    elf_backend_section_processing: None,
    elf_backend_section_from_shdr: None,
    elf_backend_section_flags: None,
    get_sec_type_attr: None,
    elf_backend_section_from_phdr: None,
    elf_backend_fake_sections: None,
    elf_backend_section_from_bfd_section: None,
    elf_add_symbol_hook: None,
    elf_backend_link_output_symbol_hook: None,
    elf_backend_create_dynamic_sections: None,
    elf_backend_omit_section_dynsym: None,
    relocs_compatible: None,
    check_relocs: None,
    check_directives: None,
    notice_as_needed: None,
    elf_backend_adjust_dynamic_symbol: None,
    elf_backend_always_size_sections: None,
    elf_backend_size_dynamic_sections: None,
    elf_backend_strip_zero_sized_dynamic_sections: None,
    elf_backend_init_index_section: None,
    elf_backend_relocate_section: None,
    elf_backend_finish_dynamic_symbol: None,
    elf_backend_finish_dynamic_sections: None,
    elf_backend_begin_write_processing: None,
    elf_backend_final_write_processing: None,
    elf_backend_additional_program_headers: None,
    elf_backend_modify_segment_map: None,
    elf_backend_modify_headers: None,
    elf_backend_allow_non_load_phdr: None,
    gc_keep: None,
    gc_mark_dynamic_ref: None,
    gc_mark_hook: None,
    gc_mark_extra_sections: None,
    elf_backend_init_file_header: None,
    elf_backend_print_symbol_all: None,
    elf_backend_output_arch_local_syms: None,
    elf_backend_output_arch_syms: None,
    elf_backend_filter_implib_symbols: None,
    elf_backend_copy_indirect_symbol: None,
    elf_backend_hide_symbol: None,
    elf_backend_fixup_symbol: None,
    elf_backend_merge_symbol_attribute: None,
    elf_backend_get_target_dtag: None,
    elf_backend_ignore_undef_symbol: None,
    elf_backend_emit_relocs: None,
    elf_backend_update_relocs: None,
    elf_backend_count_relocs: None,
    elf_backend_count_additional_relocs: None,
    sort_relocs_p: None,
    elf_backend_grok_prstatus: None,
    elf_backend_grok_psinfo: None,
    elf_backend_grok_freebsd_prstatus: None,
    elf_backend_write_core_note: None,
    elf_backend_lookup_section_flags_hook: None,
    elf_backend_reloc_type_class: None,
    elf_backend_discard_info: None,
    elf_backend_ignore_discarded_relocs: None,
    action_discarded: None,
    elf_backend_eh_frame_address_size: None,
    elf_backend_can_make_relative_eh_frame: None,
    elf_backend_can_make_lsda_relative_eh_frame: None,
    elf_backend_encode_eh_address: None,
    elf_backend_write_section: None,
    elf_backend_elfsym_local_is_section: None,
    elf_backend_mips_irix_compat: None,
    elf_backend_mips_rtype_to_howto: None,
    elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
    elf_backend_bfd_from_remote_memory: None,
    elf_backend_core_find_build_id: None,
    plt_sym_val: None,
    common_definition: None,
    common_section_index: None,
    common_section: None,
    merge_symbol: None,
    elf_hash_symbol: None,
    record_xhash_symbol: None,
    is_function_type: None,
    maybe_function_sym: None,
    get_reloc_section: None,
    elf_backend_copy_special_section_fields: None,
    link_order_error_handler: None,
    relplt_name: 0 as *const libc::c_char,
    elf_machine_alt1: 0,
    elf_machine_alt2: 0,
    s: 0 as *const elf_size_info,
    special_sections: 0 as *const bfd_elf_special_section,
    got_header_size: 0,
    got_elt_size: None,
    obj_attrs_vendor: 0 as *const libc::c_char,
    obj_attrs_section: 0 as *const libc::c_char,
    obj_attrs_arg_type: None,
    obj_attrs_section_type: 0,
    obj_attrs_order: None,
    obj_attrs_handle_unknown: None,
    parse_gnu_properties: None,
    merge_gnu_properties: None,
    setup_gnu_properties: None,
    fixup_gnu_properties: None,
    compact_eh_encoding: None,
    cant_unwind_opcode: None,
    symbol_section_index: None,
    init_secondary_reloc_section: None,
    slurp_secondary_relocs: None,
    write_secondary_relocs: None,
    static_tls_alignment: 0,
    stack_align: 0,
    elf_strtab_flags: 0,
    collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
    c2rust_padding: [0; 4],
};
static mut elf32_i386_vxworks_bed: elf_backend_data = elf_backend_data {
    arch: bfd_arch_unknown,
    target_id: 0 as elf_target_id,
    target_os: is_normal,
    elf_machine_code: 0,
    elf_osabi: 0,
    maxpagesize: 0,
    minpagesize: 0,
    commonpagesize: 0,
    relropagesize: 0,
    dynamic_sec_flags: 0,
    arch_data: 0 as *const libc::c_void,
    elf_info_to_howto: None,
    elf_info_to_howto_rel: None,
    elf_backend_sym_is_global: None,
    elf_backend_object_p: None,
    elf_backend_symbol_processing: None,
    elf_backend_symbol_table_processing: None,
    elf_backend_get_symbol_type: None,
    elf_backend_archive_symbol_lookup: None,
    elf_backend_name_local_section_symbols: None,
    elf_backend_section_processing: None,
    elf_backend_section_from_shdr: None,
    elf_backend_section_flags: None,
    get_sec_type_attr: None,
    elf_backend_section_from_phdr: None,
    elf_backend_fake_sections: None,
    elf_backend_section_from_bfd_section: None,
    elf_add_symbol_hook: None,
    elf_backend_link_output_symbol_hook: None,
    elf_backend_create_dynamic_sections: None,
    elf_backend_omit_section_dynsym: None,
    relocs_compatible: None,
    check_relocs: None,
    check_directives: None,
    notice_as_needed: None,
    elf_backend_adjust_dynamic_symbol: None,
    elf_backend_always_size_sections: None,
    elf_backend_size_dynamic_sections: None,
    elf_backend_strip_zero_sized_dynamic_sections: None,
    elf_backend_init_index_section: None,
    elf_backend_relocate_section: None,
    elf_backend_finish_dynamic_symbol: None,
    elf_backend_finish_dynamic_sections: None,
    elf_backend_begin_write_processing: None,
    elf_backend_final_write_processing: None,
    elf_backend_additional_program_headers: None,
    elf_backend_modify_segment_map: None,
    elf_backend_modify_headers: None,
    elf_backend_allow_non_load_phdr: None,
    gc_keep: None,
    gc_mark_dynamic_ref: None,
    gc_mark_hook: None,
    gc_mark_extra_sections: None,
    elf_backend_init_file_header: None,
    elf_backend_print_symbol_all: None,
    elf_backend_output_arch_local_syms: None,
    elf_backend_output_arch_syms: None,
    elf_backend_filter_implib_symbols: None,
    elf_backend_copy_indirect_symbol: None,
    elf_backend_hide_symbol: None,
    elf_backend_fixup_symbol: None,
    elf_backend_merge_symbol_attribute: None,
    elf_backend_get_target_dtag: None,
    elf_backend_ignore_undef_symbol: None,
    elf_backend_emit_relocs: None,
    elf_backend_update_relocs: None,
    elf_backend_count_relocs: None,
    elf_backend_count_additional_relocs: None,
    sort_relocs_p: None,
    elf_backend_grok_prstatus: None,
    elf_backend_grok_psinfo: None,
    elf_backend_grok_freebsd_prstatus: None,
    elf_backend_write_core_note: None,
    elf_backend_lookup_section_flags_hook: None,
    elf_backend_reloc_type_class: None,
    elf_backend_discard_info: None,
    elf_backend_ignore_discarded_relocs: None,
    action_discarded: None,
    elf_backend_eh_frame_address_size: None,
    elf_backend_can_make_relative_eh_frame: None,
    elf_backend_can_make_lsda_relative_eh_frame: None,
    elf_backend_encode_eh_address: None,
    elf_backend_write_section: None,
    elf_backend_elfsym_local_is_section: None,
    elf_backend_mips_irix_compat: None,
    elf_backend_mips_rtype_to_howto: None,
    elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
    elf_backend_bfd_from_remote_memory: None,
    elf_backend_core_find_build_id: None,
    plt_sym_val: None,
    common_definition: None,
    common_section_index: None,
    common_section: None,
    merge_symbol: None,
    elf_hash_symbol: None,
    record_xhash_symbol: None,
    is_function_type: None,
    maybe_function_sym: None,
    get_reloc_section: None,
    elf_backend_copy_special_section_fields: None,
    link_order_error_handler: None,
    relplt_name: 0 as *const libc::c_char,
    elf_machine_alt1: 0,
    elf_machine_alt2: 0,
    s: 0 as *const elf_size_info,
    special_sections: 0 as *const bfd_elf_special_section,
    got_header_size: 0,
    got_elt_size: None,
    obj_attrs_vendor: 0 as *const libc::c_char,
    obj_attrs_section: 0 as *const libc::c_char,
    obj_attrs_arg_type: None,
    obj_attrs_section_type: 0,
    obj_attrs_order: None,
    obj_attrs_handle_unknown: None,
    parse_gnu_properties: None,
    merge_gnu_properties: None,
    setup_gnu_properties: None,
    fixup_gnu_properties: None,
    compact_eh_encoding: None,
    cant_unwind_opcode: None,
    symbol_section_index: None,
    init_secondary_reloc_section: None,
    slurp_secondary_relocs: None,
    write_secondary_relocs: None,
    static_tls_alignment: 0,
    stack_align: 0,
    elf_strtab_flags: 0,
    collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
    c2rust_padding: [0; 4],
};
static mut elf32_i386_bed: elf_backend_data = elf_backend_data {
    arch: bfd_arch_unknown,
    target_id: 0 as elf_target_id,
    target_os: is_normal,
    elf_machine_code: 0,
    elf_osabi: 0,
    maxpagesize: 0,
    minpagesize: 0,
    commonpagesize: 0,
    relropagesize: 0,
    dynamic_sec_flags: 0,
    arch_data: 0 as *const libc::c_void,
    elf_info_to_howto: None,
    elf_info_to_howto_rel: None,
    elf_backend_sym_is_global: None,
    elf_backend_object_p: None,
    elf_backend_symbol_processing: None,
    elf_backend_symbol_table_processing: None,
    elf_backend_get_symbol_type: None,
    elf_backend_archive_symbol_lookup: None,
    elf_backend_name_local_section_symbols: None,
    elf_backend_section_processing: None,
    elf_backend_section_from_shdr: None,
    elf_backend_section_flags: None,
    get_sec_type_attr: None,
    elf_backend_section_from_phdr: None,
    elf_backend_fake_sections: None,
    elf_backend_section_from_bfd_section: None,
    elf_add_symbol_hook: None,
    elf_backend_link_output_symbol_hook: None,
    elf_backend_create_dynamic_sections: None,
    elf_backend_omit_section_dynsym: None,
    relocs_compatible: None,
    check_relocs: None,
    check_directives: None,
    notice_as_needed: None,
    elf_backend_adjust_dynamic_symbol: None,
    elf_backend_always_size_sections: None,
    elf_backend_size_dynamic_sections: None,
    elf_backend_strip_zero_sized_dynamic_sections: None,
    elf_backend_init_index_section: None,
    elf_backend_relocate_section: None,
    elf_backend_finish_dynamic_symbol: None,
    elf_backend_finish_dynamic_sections: None,
    elf_backend_begin_write_processing: None,
    elf_backend_final_write_processing: None,
    elf_backend_additional_program_headers: None,
    elf_backend_modify_segment_map: None,
    elf_backend_modify_headers: None,
    elf_backend_allow_non_load_phdr: None,
    gc_keep: None,
    gc_mark_dynamic_ref: None,
    gc_mark_hook: None,
    gc_mark_extra_sections: None,
    elf_backend_init_file_header: None,
    elf_backend_print_symbol_all: None,
    elf_backend_output_arch_local_syms: None,
    elf_backend_output_arch_syms: None,
    elf_backend_filter_implib_symbols: None,
    elf_backend_copy_indirect_symbol: None,
    elf_backend_hide_symbol: None,
    elf_backend_fixup_symbol: None,
    elf_backend_merge_symbol_attribute: None,
    elf_backend_get_target_dtag: None,
    elf_backend_ignore_undef_symbol: None,
    elf_backend_emit_relocs: None,
    elf_backend_update_relocs: None,
    elf_backend_count_relocs: None,
    elf_backend_count_additional_relocs: None,
    sort_relocs_p: None,
    elf_backend_grok_prstatus: None,
    elf_backend_grok_psinfo: None,
    elf_backend_grok_freebsd_prstatus: None,
    elf_backend_write_core_note: None,
    elf_backend_lookup_section_flags_hook: None,
    elf_backend_reloc_type_class: None,
    elf_backend_discard_info: None,
    elf_backend_ignore_discarded_relocs: None,
    action_discarded: None,
    elf_backend_eh_frame_address_size: None,
    elf_backend_can_make_relative_eh_frame: None,
    elf_backend_can_make_lsda_relative_eh_frame: None,
    elf_backend_encode_eh_address: None,
    elf_backend_write_section: None,
    elf_backend_elfsym_local_is_section: None,
    elf_backend_mips_irix_compat: None,
    elf_backend_mips_rtype_to_howto: None,
    elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
    elf_backend_bfd_from_remote_memory: None,
    elf_backend_core_find_build_id: None,
    plt_sym_val: None,
    common_definition: None,
    common_section_index: None,
    common_section: None,
    merge_symbol: None,
    elf_hash_symbol: None,
    record_xhash_symbol: None,
    is_function_type: None,
    maybe_function_sym: None,
    get_reloc_section: None,
    elf_backend_copy_special_section_fields: None,
    link_order_error_handler: None,
    relplt_name: 0 as *const libc::c_char,
    elf_machine_alt1: 0,
    elf_machine_alt2: 0,
    s: 0 as *const elf_size_info,
    special_sections: 0 as *const bfd_elf_special_section,
    got_header_size: 0,
    got_elt_size: None,
    obj_attrs_vendor: 0 as *const libc::c_char,
    obj_attrs_section: 0 as *const libc::c_char,
    obj_attrs_arg_type: None,
    obj_attrs_section_type: 0,
    obj_attrs_order: None,
    obj_attrs_handle_unknown: None,
    parse_gnu_properties: None,
    merge_gnu_properties: None,
    setup_gnu_properties: None,
    fixup_gnu_properties: None,
    compact_eh_encoding: None,
    cant_unwind_opcode: None,
    symbol_section_index: None,
    init_secondary_reloc_section: None,
    slurp_secondary_relocs: None,
    write_secondary_relocs: None,
    static_tls_alignment: 0,
    stack_align: 0,
    elf_strtab_flags: 0,
    collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
    c2rust_padding: [0; 4],
};
static mut elf32_iamcu_bed: elf_backend_data = elf_backend_data {
    arch: bfd_arch_unknown,
    target_id: 0 as elf_target_id,
    target_os: is_normal,
    elf_machine_code: 0,
    elf_osabi: 0,
    maxpagesize: 0,
    minpagesize: 0,
    commonpagesize: 0,
    relropagesize: 0,
    dynamic_sec_flags: 0,
    arch_data: 0 as *const libc::c_void,
    elf_info_to_howto: None,
    elf_info_to_howto_rel: None,
    elf_backend_sym_is_global: None,
    elf_backend_object_p: None,
    elf_backend_symbol_processing: None,
    elf_backend_symbol_table_processing: None,
    elf_backend_get_symbol_type: None,
    elf_backend_archive_symbol_lookup: None,
    elf_backend_name_local_section_symbols: None,
    elf_backend_section_processing: None,
    elf_backend_section_from_shdr: None,
    elf_backend_section_flags: None,
    get_sec_type_attr: None,
    elf_backend_section_from_phdr: None,
    elf_backend_fake_sections: None,
    elf_backend_section_from_bfd_section: None,
    elf_add_symbol_hook: None,
    elf_backend_link_output_symbol_hook: None,
    elf_backend_create_dynamic_sections: None,
    elf_backend_omit_section_dynsym: None,
    relocs_compatible: None,
    check_relocs: None,
    check_directives: None,
    notice_as_needed: None,
    elf_backend_adjust_dynamic_symbol: None,
    elf_backend_always_size_sections: None,
    elf_backend_size_dynamic_sections: None,
    elf_backend_strip_zero_sized_dynamic_sections: None,
    elf_backend_init_index_section: None,
    elf_backend_relocate_section: None,
    elf_backend_finish_dynamic_symbol: None,
    elf_backend_finish_dynamic_sections: None,
    elf_backend_begin_write_processing: None,
    elf_backend_final_write_processing: None,
    elf_backend_additional_program_headers: None,
    elf_backend_modify_segment_map: None,
    elf_backend_modify_headers: None,
    elf_backend_allow_non_load_phdr: None,
    gc_keep: None,
    gc_mark_dynamic_ref: None,
    gc_mark_hook: None,
    gc_mark_extra_sections: None,
    elf_backend_init_file_header: None,
    elf_backend_print_symbol_all: None,
    elf_backend_output_arch_local_syms: None,
    elf_backend_output_arch_syms: None,
    elf_backend_filter_implib_symbols: None,
    elf_backend_copy_indirect_symbol: None,
    elf_backend_hide_symbol: None,
    elf_backend_fixup_symbol: None,
    elf_backend_merge_symbol_attribute: None,
    elf_backend_get_target_dtag: None,
    elf_backend_ignore_undef_symbol: None,
    elf_backend_emit_relocs: None,
    elf_backend_update_relocs: None,
    elf_backend_count_relocs: None,
    elf_backend_count_additional_relocs: None,
    sort_relocs_p: None,
    elf_backend_grok_prstatus: None,
    elf_backend_grok_psinfo: None,
    elf_backend_grok_freebsd_prstatus: None,
    elf_backend_write_core_note: None,
    elf_backend_lookup_section_flags_hook: None,
    elf_backend_reloc_type_class: None,
    elf_backend_discard_info: None,
    elf_backend_ignore_discarded_relocs: None,
    action_discarded: None,
    elf_backend_eh_frame_address_size: None,
    elf_backend_can_make_relative_eh_frame: None,
    elf_backend_can_make_lsda_relative_eh_frame: None,
    elf_backend_encode_eh_address: None,
    elf_backend_write_section: None,
    elf_backend_elfsym_local_is_section: None,
    elf_backend_mips_irix_compat: None,
    elf_backend_mips_rtype_to_howto: None,
    elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
    elf_backend_bfd_from_remote_memory: None,
    elf_backend_core_find_build_id: None,
    plt_sym_val: None,
    common_definition: None,
    common_section_index: None,
    common_section: None,
    merge_symbol: None,
    elf_hash_symbol: None,
    record_xhash_symbol: None,
    is_function_type: None,
    maybe_function_sym: None,
    get_reloc_section: None,
    elf_backend_copy_special_section_fields: None,
    link_order_error_handler: None,
    relplt_name: 0 as *const libc::c_char,
    elf_machine_alt1: 0,
    elf_machine_alt2: 0,
    s: 0 as *const elf_size_info,
    special_sections: 0 as *const bfd_elf_special_section,
    got_header_size: 0,
    got_elt_size: None,
    obj_attrs_vendor: 0 as *const libc::c_char,
    obj_attrs_section: 0 as *const libc::c_char,
    obj_attrs_arg_type: None,
    obj_attrs_section_type: 0,
    obj_attrs_order: None,
    obj_attrs_handle_unknown: None,
    parse_gnu_properties: None,
    merge_gnu_properties: None,
    setup_gnu_properties: None,
    fixup_gnu_properties: None,
    compact_eh_encoding: None,
    cant_unwind_opcode: None,
    symbol_section_index: None,
    init_secondary_reloc_section: None,
    slurp_secondary_relocs: None,
    write_secondary_relocs: None,
    static_tls_alignment: 0,
    stack_align: 0,
    elf_strtab_flags: 0,
    collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
    c2rust_padding: [0; 4],
};
#[no_mangle]
pub static mut iamcu_elf32_vec: bfd_target = bfd_target {
    name: 0 as *const libc::c_char,
    flavour: bfd_target_unknown_flavour,
    byteorder: BFD_ENDIAN_BIG,
    header_byteorder: BFD_ENDIAN_BIG,
    object_flags: 0,
    section_flags: 0,
    symbol_leading_char: 0,
    ar_pad_char: 0,
    ar_max_namelen: 0,
    match_priority: 0,
    keep_unused_section_symbols: false,
    bfd_getx64: None,
    bfd_getx_signed_64: None,
    bfd_putx64: None,
    bfd_getx32: None,
    bfd_getx_signed_32: None,
    bfd_putx32: None,
    bfd_getx16: None,
    bfd_getx_signed_16: None,
    bfd_putx16: None,
    bfd_h_getx64: None,
    bfd_h_getx_signed_64: None,
    bfd_h_putx64: None,
    bfd_h_getx32: None,
    bfd_h_getx_signed_32: None,
    bfd_h_putx32: None,
    bfd_h_getx16: None,
    bfd_h_getx_signed_16: None,
    bfd_h_putx16: None,
    _bfd_check_format: [None; 4],
    _bfd_set_format: [None; 4],
    _bfd_write_contents: [None; 4],
    _close_and_cleanup: None,
    _bfd_free_cached_info: None,
    _new_section_hook: None,
    _bfd_get_section_contents: None,
    _bfd_get_section_contents_in_window: None,
    _bfd_copy_private_bfd_data: None,
    _bfd_merge_private_bfd_data: None,
    _bfd_init_private_section_data: None,
    _bfd_copy_private_section_data: None,
    _bfd_copy_private_symbol_data: None,
    _bfd_copy_private_header_data: None,
    _bfd_set_private_flags: None,
    _bfd_print_private_bfd_data: None,
    _core_file_failing_command: None,
    _core_file_failing_signal: None,
    _core_file_matches_executable_p: None,
    _core_file_pid: None,
    _bfd_slurp_armap: None,
    _bfd_slurp_extended_name_table: None,
    _bfd_construct_extended_name_table: None,
    _bfd_truncate_arname: None,
    write_armap: None,
    _bfd_read_ar_hdr_fn: None,
    _bfd_write_ar_hdr_fn: None,
    openr_next_archived_file: None,
    _bfd_get_elt_at_index: None,
    _bfd_stat_arch_elt: None,
    _bfd_update_armap_timestamp: None,
    _bfd_get_symtab_upper_bound: None,
    _bfd_canonicalize_symtab: None,
    _bfd_make_empty_symbol: None,
    _bfd_print_symbol: None,
    _bfd_get_symbol_info: None,
    _bfd_get_symbol_version_string: None,
    _bfd_is_local_label_name: None,
    _bfd_is_target_special_symbol: None,
    _get_lineno: None,
    _bfd_find_nearest_line: None,
    _bfd_find_line: None,
    _bfd_find_inliner_info: None,
    _bfd_make_debug_symbol: None,
    _read_minisymbols: None,
    _minisymbol_to_symbol: None,
    _get_reloc_upper_bound: None,
    _bfd_canonicalize_reloc: None,
    _bfd_set_reloc: None,
    reloc_type_lookup: None,
    reloc_name_lookup: None,
    _bfd_set_arch_mach: None,
    _bfd_set_section_contents: None,
    _bfd_sizeof_headers: None,
    _bfd_get_relocated_section_contents: None,
    _bfd_relax_section: None,
    _bfd_link_hash_table_create: None,
    _bfd_link_add_symbols: None,
    _bfd_link_just_syms: None,
    _bfd_copy_link_hash_symbol_type: None,
    _bfd_final_link: None,
    _bfd_link_split_section: None,
    _bfd_link_check_relocs: None,
    _bfd_gc_sections: None,
    _bfd_lookup_section_flags: None,
    _bfd_merge_sections: None,
    _bfd_is_group_section: None,
    _bfd_group_name: None,
    _bfd_discard_group: None,
    _section_already_linked: None,
    _bfd_define_common_symbol: None,
    _bfd_link_hide_symbol: None,
    _bfd_define_start_stop: None,
    _bfd_get_dynamic_symtab_upper_bound: None,
    _bfd_canonicalize_dynamic_symtab: None,
    _bfd_get_synthetic_symtab: None,
    _bfd_get_dynamic_reloc_upper_bound: None,
    _bfd_canonicalize_dynamic_reloc: None,
    alternative_target: 0 as *const bfd_target,
    backend_data: 0 as *const libc::c_void,
};
#[no_mangle]
pub static mut i386_elf32_sol2_vec: bfd_target = bfd_target {
    name: 0 as *const libc::c_char,
    flavour: bfd_target_unknown_flavour,
    byteorder: BFD_ENDIAN_BIG,
    header_byteorder: BFD_ENDIAN_BIG,
    object_flags: 0,
    section_flags: 0,
    symbol_leading_char: 0,
    ar_pad_char: 0,
    ar_max_namelen: 0,
    match_priority: 0,
    keep_unused_section_symbols: false,
    bfd_getx64: None,
    bfd_getx_signed_64: None,
    bfd_putx64: None,
    bfd_getx32: None,
    bfd_getx_signed_32: None,
    bfd_putx32: None,
    bfd_getx16: None,
    bfd_getx_signed_16: None,
    bfd_putx16: None,
    bfd_h_getx64: None,
    bfd_h_getx_signed_64: None,
    bfd_h_putx64: None,
    bfd_h_getx32: None,
    bfd_h_getx_signed_32: None,
    bfd_h_putx32: None,
    bfd_h_getx16: None,
    bfd_h_getx_signed_16: None,
    bfd_h_putx16: None,
    _bfd_check_format: [None; 4],
    _bfd_set_format: [None; 4],
    _bfd_write_contents: [None; 4],
    _close_and_cleanup: None,
    _bfd_free_cached_info: None,
    _new_section_hook: None,
    _bfd_get_section_contents: None,
    _bfd_get_section_contents_in_window: None,
    _bfd_copy_private_bfd_data: None,
    _bfd_merge_private_bfd_data: None,
    _bfd_init_private_section_data: None,
    _bfd_copy_private_section_data: None,
    _bfd_copy_private_symbol_data: None,
    _bfd_copy_private_header_data: None,
    _bfd_set_private_flags: None,
    _bfd_print_private_bfd_data: None,
    _core_file_failing_command: None,
    _core_file_failing_signal: None,
    _core_file_matches_executable_p: None,
    _core_file_pid: None,
    _bfd_slurp_armap: None,
    _bfd_slurp_extended_name_table: None,
    _bfd_construct_extended_name_table: None,
    _bfd_truncate_arname: None,
    write_armap: None,
    _bfd_read_ar_hdr_fn: None,
    _bfd_write_ar_hdr_fn: None,
    openr_next_archived_file: None,
    _bfd_get_elt_at_index: None,
    _bfd_stat_arch_elt: None,
    _bfd_update_armap_timestamp: None,
    _bfd_get_symtab_upper_bound: None,
    _bfd_canonicalize_symtab: None,
    _bfd_make_empty_symbol: None,
    _bfd_print_symbol: None,
    _bfd_get_symbol_info: None,
    _bfd_get_symbol_version_string: None,
    _bfd_is_local_label_name: None,
    _bfd_is_target_special_symbol: None,
    _get_lineno: None,
    _bfd_find_nearest_line: None,
    _bfd_find_line: None,
    _bfd_find_inliner_info: None,
    _bfd_make_debug_symbol: None,
    _read_minisymbols: None,
    _minisymbol_to_symbol: None,
    _get_reloc_upper_bound: None,
    _bfd_canonicalize_reloc: None,
    _bfd_set_reloc: None,
    reloc_type_lookup: None,
    reloc_name_lookup: None,
    _bfd_set_arch_mach: None,
    _bfd_set_section_contents: None,
    _bfd_sizeof_headers: None,
    _bfd_get_relocated_section_contents: None,
    _bfd_relax_section: None,
    _bfd_link_hash_table_create: None,
    _bfd_link_add_symbols: None,
    _bfd_link_just_syms: None,
    _bfd_copy_link_hash_symbol_type: None,
    _bfd_final_link: None,
    _bfd_link_split_section: None,
    _bfd_link_check_relocs: None,
    _bfd_gc_sections: None,
    _bfd_lookup_section_flags: None,
    _bfd_merge_sections: None,
    _bfd_is_group_section: None,
    _bfd_group_name: None,
    _bfd_discard_group: None,
    _section_already_linked: None,
    _bfd_define_common_symbol: None,
    _bfd_link_hide_symbol: None,
    _bfd_define_start_stop: None,
    _bfd_get_dynamic_symtab_upper_bound: None,
    _bfd_canonicalize_dynamic_symtab: None,
    _bfd_get_synthetic_symtab: None,
    _bfd_get_dynamic_reloc_upper_bound: None,
    _bfd_canonicalize_dynamic_reloc: None,
    alternative_target: 0 as *const bfd_target,
    backend_data: 0 as *const libc::c_void,
};
#[no_mangle]
pub static mut i386_elf32_vxworks_vec: bfd_target = bfd_target {
    name: 0 as *const libc::c_char,
    flavour: bfd_target_unknown_flavour,
    byteorder: BFD_ENDIAN_BIG,
    header_byteorder: BFD_ENDIAN_BIG,
    object_flags: 0,
    section_flags: 0,
    symbol_leading_char: 0,
    ar_pad_char: 0,
    ar_max_namelen: 0,
    match_priority: 0,
    keep_unused_section_symbols: false,
    bfd_getx64: None,
    bfd_getx_signed_64: None,
    bfd_putx64: None,
    bfd_getx32: None,
    bfd_getx_signed_32: None,
    bfd_putx32: None,
    bfd_getx16: None,
    bfd_getx_signed_16: None,
    bfd_putx16: None,
    bfd_h_getx64: None,
    bfd_h_getx_signed_64: None,
    bfd_h_putx64: None,
    bfd_h_getx32: None,
    bfd_h_getx_signed_32: None,
    bfd_h_putx32: None,
    bfd_h_getx16: None,
    bfd_h_getx_signed_16: None,
    bfd_h_putx16: None,
    _bfd_check_format: [None; 4],
    _bfd_set_format: [None; 4],
    _bfd_write_contents: [None; 4],
    _close_and_cleanup: None,
    _bfd_free_cached_info: None,
    _new_section_hook: None,
    _bfd_get_section_contents: None,
    _bfd_get_section_contents_in_window: None,
    _bfd_copy_private_bfd_data: None,
    _bfd_merge_private_bfd_data: None,
    _bfd_init_private_section_data: None,
    _bfd_copy_private_section_data: None,
    _bfd_copy_private_symbol_data: None,
    _bfd_copy_private_header_data: None,
    _bfd_set_private_flags: None,
    _bfd_print_private_bfd_data: None,
    _core_file_failing_command: None,
    _core_file_failing_signal: None,
    _core_file_matches_executable_p: None,
    _core_file_pid: None,
    _bfd_slurp_armap: None,
    _bfd_slurp_extended_name_table: None,
    _bfd_construct_extended_name_table: None,
    _bfd_truncate_arname: None,
    write_armap: None,
    _bfd_read_ar_hdr_fn: None,
    _bfd_write_ar_hdr_fn: None,
    openr_next_archived_file: None,
    _bfd_get_elt_at_index: None,
    _bfd_stat_arch_elt: None,
    _bfd_update_armap_timestamp: None,
    _bfd_get_symtab_upper_bound: None,
    _bfd_canonicalize_symtab: None,
    _bfd_make_empty_symbol: None,
    _bfd_print_symbol: None,
    _bfd_get_symbol_info: None,
    _bfd_get_symbol_version_string: None,
    _bfd_is_local_label_name: None,
    _bfd_is_target_special_symbol: None,
    _get_lineno: None,
    _bfd_find_nearest_line: None,
    _bfd_find_line: None,
    _bfd_find_inliner_info: None,
    _bfd_make_debug_symbol: None,
    _read_minisymbols: None,
    _minisymbol_to_symbol: None,
    _get_reloc_upper_bound: None,
    _bfd_canonicalize_reloc: None,
    _bfd_set_reloc: None,
    reloc_type_lookup: None,
    reloc_name_lookup: None,
    _bfd_set_arch_mach: None,
    _bfd_set_section_contents: None,
    _bfd_sizeof_headers: None,
    _bfd_get_relocated_section_contents: None,
    _bfd_relax_section: None,
    _bfd_link_hash_table_create: None,
    _bfd_link_add_symbols: None,
    _bfd_link_just_syms: None,
    _bfd_copy_link_hash_symbol_type: None,
    _bfd_final_link: None,
    _bfd_link_split_section: None,
    _bfd_link_check_relocs: None,
    _bfd_gc_sections: None,
    _bfd_lookup_section_flags: None,
    _bfd_merge_sections: None,
    _bfd_is_group_section: None,
    _bfd_group_name: None,
    _bfd_discard_group: None,
    _section_already_linked: None,
    _bfd_define_common_symbol: None,
    _bfd_link_hide_symbol: None,
    _bfd_define_start_stop: None,
    _bfd_get_dynamic_symtab_upper_bound: None,
    _bfd_canonicalize_dynamic_symtab: None,
    _bfd_get_synthetic_symtab: None,
    _bfd_get_dynamic_reloc_upper_bound: None,
    _bfd_canonicalize_dynamic_reloc: None,
    alternative_target: 0 as *const bfd_target,
    backend_data: 0 as *const libc::c_void,
};
#[no_mangle]
pub static mut i386_elf32_vec: bfd_target = bfd_target {
    name: 0 as *const libc::c_char,
    flavour: bfd_target_unknown_flavour,
    byteorder: BFD_ENDIAN_BIG,
    header_byteorder: BFD_ENDIAN_BIG,
    object_flags: 0,
    section_flags: 0,
    symbol_leading_char: 0,
    ar_pad_char: 0,
    ar_max_namelen: 0,
    match_priority: 0,
    keep_unused_section_symbols: false,
    bfd_getx64: None,
    bfd_getx_signed_64: None,
    bfd_putx64: None,
    bfd_getx32: None,
    bfd_getx_signed_32: None,
    bfd_putx32: None,
    bfd_getx16: None,
    bfd_getx_signed_16: None,
    bfd_putx16: None,
    bfd_h_getx64: None,
    bfd_h_getx_signed_64: None,
    bfd_h_putx64: None,
    bfd_h_getx32: None,
    bfd_h_getx_signed_32: None,
    bfd_h_putx32: None,
    bfd_h_getx16: None,
    bfd_h_getx_signed_16: None,
    bfd_h_putx16: None,
    _bfd_check_format: [None; 4],
    _bfd_set_format: [None; 4],
    _bfd_write_contents: [None; 4],
    _close_and_cleanup: None,
    _bfd_free_cached_info: None,
    _new_section_hook: None,
    _bfd_get_section_contents: None,
    _bfd_get_section_contents_in_window: None,
    _bfd_copy_private_bfd_data: None,
    _bfd_merge_private_bfd_data: None,
    _bfd_init_private_section_data: None,
    _bfd_copy_private_section_data: None,
    _bfd_copy_private_symbol_data: None,
    _bfd_copy_private_header_data: None,
    _bfd_set_private_flags: None,
    _bfd_print_private_bfd_data: None,
    _core_file_failing_command: None,
    _core_file_failing_signal: None,
    _core_file_matches_executable_p: None,
    _core_file_pid: None,
    _bfd_slurp_armap: None,
    _bfd_slurp_extended_name_table: None,
    _bfd_construct_extended_name_table: None,
    _bfd_truncate_arname: None,
    write_armap: None,
    _bfd_read_ar_hdr_fn: None,
    _bfd_write_ar_hdr_fn: None,
    openr_next_archived_file: None,
    _bfd_get_elt_at_index: None,
    _bfd_stat_arch_elt: None,
    _bfd_update_armap_timestamp: None,
    _bfd_get_symtab_upper_bound: None,
    _bfd_canonicalize_symtab: None,
    _bfd_make_empty_symbol: None,
    _bfd_print_symbol: None,
    _bfd_get_symbol_info: None,
    _bfd_get_symbol_version_string: None,
    _bfd_is_local_label_name: None,
    _bfd_is_target_special_symbol: None,
    _get_lineno: None,
    _bfd_find_nearest_line: None,
    _bfd_find_line: None,
    _bfd_find_inliner_info: None,
    _bfd_make_debug_symbol: None,
    _read_minisymbols: None,
    _minisymbol_to_symbol: None,
    _get_reloc_upper_bound: None,
    _bfd_canonicalize_reloc: None,
    _bfd_set_reloc: None,
    reloc_type_lookup: None,
    reloc_name_lookup: None,
    _bfd_set_arch_mach: None,
    _bfd_set_section_contents: None,
    _bfd_sizeof_headers: None,
    _bfd_get_relocated_section_contents: None,
    _bfd_relax_section: None,
    _bfd_link_hash_table_create: None,
    _bfd_link_add_symbols: None,
    _bfd_link_just_syms: None,
    _bfd_copy_link_hash_symbol_type: None,
    _bfd_final_link: None,
    _bfd_link_split_section: None,
    _bfd_link_check_relocs: None,
    _bfd_gc_sections: None,
    _bfd_lookup_section_flags: None,
    _bfd_merge_sections: None,
    _bfd_is_group_section: None,
    _bfd_group_name: None,
    _bfd_discard_group: None,
    _section_already_linked: None,
    _bfd_define_common_symbol: None,
    _bfd_link_hide_symbol: None,
    _bfd_define_start_stop: None,
    _bfd_get_dynamic_symtab_upper_bound: None,
    _bfd_canonicalize_dynamic_symtab: None,
    _bfd_get_synthetic_symtab: None,
    _bfd_get_dynamic_reloc_upper_bound: None,
    _bfd_canonicalize_dynamic_reloc: None,
    alternative_target: 0 as *const bfd_target,
    backend_data: 0 as *const libc::c_void,
};
#[no_mangle]
pub static mut i386_elf32_fbsd_vec: bfd_target = bfd_target {
    name: 0 as *const libc::c_char,
    flavour: bfd_target_unknown_flavour,
    byteorder: BFD_ENDIAN_BIG,
    header_byteorder: BFD_ENDIAN_BIG,
    object_flags: 0,
    section_flags: 0,
    symbol_leading_char: 0,
    ar_pad_char: 0,
    ar_max_namelen: 0,
    match_priority: 0,
    keep_unused_section_symbols: false,
    bfd_getx64: None,
    bfd_getx_signed_64: None,
    bfd_putx64: None,
    bfd_getx32: None,
    bfd_getx_signed_32: None,
    bfd_putx32: None,
    bfd_getx16: None,
    bfd_getx_signed_16: None,
    bfd_putx16: None,
    bfd_h_getx64: None,
    bfd_h_getx_signed_64: None,
    bfd_h_putx64: None,
    bfd_h_getx32: None,
    bfd_h_getx_signed_32: None,
    bfd_h_putx32: None,
    bfd_h_getx16: None,
    bfd_h_getx_signed_16: None,
    bfd_h_putx16: None,
    _bfd_check_format: [None; 4],
    _bfd_set_format: [None; 4],
    _bfd_write_contents: [None; 4],
    _close_and_cleanup: None,
    _bfd_free_cached_info: None,
    _new_section_hook: None,
    _bfd_get_section_contents: None,
    _bfd_get_section_contents_in_window: None,
    _bfd_copy_private_bfd_data: None,
    _bfd_merge_private_bfd_data: None,
    _bfd_init_private_section_data: None,
    _bfd_copy_private_section_data: None,
    _bfd_copy_private_symbol_data: None,
    _bfd_copy_private_header_data: None,
    _bfd_set_private_flags: None,
    _bfd_print_private_bfd_data: None,
    _core_file_failing_command: None,
    _core_file_failing_signal: None,
    _core_file_matches_executable_p: None,
    _core_file_pid: None,
    _bfd_slurp_armap: None,
    _bfd_slurp_extended_name_table: None,
    _bfd_construct_extended_name_table: None,
    _bfd_truncate_arname: None,
    write_armap: None,
    _bfd_read_ar_hdr_fn: None,
    _bfd_write_ar_hdr_fn: None,
    openr_next_archived_file: None,
    _bfd_get_elt_at_index: None,
    _bfd_stat_arch_elt: None,
    _bfd_update_armap_timestamp: None,
    _bfd_get_symtab_upper_bound: None,
    _bfd_canonicalize_symtab: None,
    _bfd_make_empty_symbol: None,
    _bfd_print_symbol: None,
    _bfd_get_symbol_info: None,
    _bfd_get_symbol_version_string: None,
    _bfd_is_local_label_name: None,
    _bfd_is_target_special_symbol: None,
    _get_lineno: None,
    _bfd_find_nearest_line: None,
    _bfd_find_line: None,
    _bfd_find_inliner_info: None,
    _bfd_make_debug_symbol: None,
    _read_minisymbols: None,
    _minisymbol_to_symbol: None,
    _get_reloc_upper_bound: None,
    _bfd_canonicalize_reloc: None,
    _bfd_set_reloc: None,
    reloc_type_lookup: None,
    reloc_name_lookup: None,
    _bfd_set_arch_mach: None,
    _bfd_set_section_contents: None,
    _bfd_sizeof_headers: None,
    _bfd_get_relocated_section_contents: None,
    _bfd_relax_section: None,
    _bfd_link_hash_table_create: None,
    _bfd_link_add_symbols: None,
    _bfd_link_just_syms: None,
    _bfd_copy_link_hash_symbol_type: None,
    _bfd_final_link: None,
    _bfd_link_split_section: None,
    _bfd_link_check_relocs: None,
    _bfd_gc_sections: None,
    _bfd_lookup_section_flags: None,
    _bfd_merge_sections: None,
    _bfd_is_group_section: None,
    _bfd_group_name: None,
    _bfd_discard_group: None,
    _section_already_linked: None,
    _bfd_define_common_symbol: None,
    _bfd_link_hide_symbol: None,
    _bfd_define_start_stop: None,
    _bfd_get_dynamic_symtab_upper_bound: None,
    _bfd_canonicalize_dynamic_symtab: None,
    _bfd_get_synthetic_symtab: None,
    _bfd_get_dynamic_reloc_upper_bound: None,
    _bfd_canonicalize_dynamic_reloc: None,
    alternative_target: 0 as *const bfd_target,
    backend_data: 0 as *const libc::c_void,
};
unsafe extern "C" fn elf_i386_fbsd_init_file_header(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    if !_bfd_elf_init_file_header(abfd, info) {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf32_i386_copy_solaris_special_section_fields(
    mut ibfd: *const bfd,
    mut obfd: *mut bfd,
    mut isection: *const Elf_Internal_Shdr,
    mut osection: *mut Elf_Internal_Shdr,
) -> bool {
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn elf32_iamcu_elf_object_p(mut abfd: *mut bfd) -> bool {
    bfd_default_set_arch_mach(
        abfd,
        bfd_arch_iamcu,
        ((1 as libc::c_int) << 2 as libc::c_int | (1 as libc::c_int) << 8 as libc::c_int)
            as libc::c_ulong,
    );
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn run_static_initializers() {
    elf_howto_table = [
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_NONE as libc::c_int as libc::c_uint,
                src_mask: 0 as libc::c_int as bfd_vma,
                dst_mask: 0 as libc::c_int as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_NONE\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (3 as libc::c_int) < 0 as libc::c_int {
                    -(3 as libc::c_int)
                } else {
                    3 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(0 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((3 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_PC32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_PC32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(1 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(1 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_GOT32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_GOT32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_PLT32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_PLT32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(1 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(1 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_COPY as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_COPY\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_GLOB_DAT as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_GLOB_DAT\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_JUMP_SLOT as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_JUMP_SLOT\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_RELATIVE as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_RELATIVE\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_GOTOFF as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_GOTOFF\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_GOTPC as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_GOTPC\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(1 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(1 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_TPOFF as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_TPOFF\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_IE as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_IE\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_GOTIE as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_GOTIE\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_LE as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_LE\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_GD as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_GD\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_LDM as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_LDM\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_16 as libc::c_int as libc::c_uint,
                src_mask: 0xffff as libc::c_int as bfd_vma,
                dst_mask: 0xffff as libc::c_int as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_16\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (1 as libc::c_int) < 0 as libc::c_int {
                    -(1 as libc::c_int)
                } else {
                    1 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(16 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_bitfield);
            init.set_negate(
                ((1 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_PC16 as libc::c_int as libc::c_uint,
                src_mask: 0xffff as libc::c_int as bfd_vma,
                dst_mask: 0xffff as libc::c_int as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_PC16\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (1 as libc::c_int) < 0 as libc::c_int {
                    -(1 as libc::c_int)
                } else {
                    1 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(16 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_bitfield);
            init.set_negate(
                ((1 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(1 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(1 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_8 as libc::c_int as libc::c_uint,
                src_mask: 0xff as libc::c_int as bfd_vma,
                dst_mask: 0xff as libc::c_int as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_8\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (0 as libc::c_int) < 0 as libc::c_int {
                    -(0 as libc::c_int)
                } else {
                    0 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(8 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_bitfield);
            init.set_negate(
                ((0 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_PC8 as libc::c_int as libc::c_uint,
                src_mask: 0xff as libc::c_int as bfd_vma,
                dst_mask: 0xff as libc::c_int as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_PC8\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (0 as libc::c_int) < 0 as libc::c_int {
                    -(0 as libc::c_int)
                } else {
                    0 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(8 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_signed);
            init.set_negate(
                ((0 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(1 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(1 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_LDO_32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_LDO_32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_IE_32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_IE_32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_LE_32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_LE_32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_DTPMOD32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_DTPMOD32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_DTPOFF32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_DTPOFF32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_TPOFF32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_TPOFF32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_SIZE32 as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_SIZE32\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_GOTDESC as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_GOTDESC\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_DESC_CALL as libc::c_int as libc::c_uint,
                src_mask: 0 as libc::c_int as bfd_vma,
                dst_mask: 0 as libc::c_int as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_DESC_CALL\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (3 as libc::c_int) < 0 as libc::c_int {
                    -(3 as libc::c_int)
                } else {
                    3 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(0 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((3 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(0 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_TLS_DESC as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_TLS_DESC\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_IRELATIVE as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_IRELATIVE\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_GOT32X as libc::c_int as libc::c_uint,
                src_mask: 0xffffffff as libc::c_uint as bfd_vma,
                dst_mask: 0xffffffff as libc::c_uint as bfd_vma,
                special_function: Some(
                    bfd_elf_generic_reloc
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut asymbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_GOT32X\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(32 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(1 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_GNU_VTINHERIT as libc::c_int as libc::c_uint,
                src_mask: 0 as libc::c_int as bfd_vma,
                dst_mask: 0 as libc::c_int as bfd_vma,
                special_function: None,
                name: b"R_386_GNU_VTINHERIT\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(0 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(0 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
        {
            let mut init = reloc_howto_struct {
                size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [0; 4],
                type_0: R_386_GNU_VTENTRY as libc::c_int as libc::c_uint,
                src_mask: 0 as libc::c_int as bfd_vma,
                dst_mask: 0 as libc::c_int as bfd_vma,
                special_function: Some(
                    _bfd_elf_rel_vtable_reloc_fn
                        as unsafe extern "C" fn(
                            *mut bfd,
                            *mut arelent,
                            *mut bfd_symbol,
                            *mut libc::c_void,
                            *mut asection,
                            *mut bfd,
                            *mut *mut libc::c_char,
                        ) -> bfd_reloc_status_type,
                ),
                name: b"R_386_GNU_VTENTRY\0" as *const u8 as *const libc::c_char,
            };
            init.set_size(
                (if (2 as libc::c_int) < 0 as libc::c_int {
                    -(2 as libc::c_int)
                } else {
                    2 as libc::c_int
                }) as libc::c_uint,
            );
            init.set_bitsize(0 as libc::c_int as libc::c_uint);
            init.set_rightshift(0 as libc::c_int as libc::c_uint);
            init.set_bitpos(0 as libc::c_int as libc::c_uint);
            init.set_complain_on_overflow(complain_overflow_dont);
            init.set_negate(
                ((2 as libc::c_int) < 0 as libc::c_int) as libc::c_int as libc::c_uint,
            );
            init.set_pc_relative(0 as libc::c_int as libc::c_uint);
            init.set_partial_inplace(0 as libc::c_int as libc::c_uint);
            init.set_pcrel_offset(0 as libc::c_int as libc::c_uint);
            init
        },
    ];
    elf32_i386_sol2_bed = {
        let mut init = elf_backend_data {
            collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
            c2rust_padding: [0; 4],
            arch: bfd_arch_i386,
            target_id: I386_ELF_DATA,
            target_os: is_solaris,
            elf_machine_code: 3 as libc::c_int,
            elf_osabi: 0 as libc::c_int,
            maxpagesize: 0x1000 as libc::c_int as bfd_vma,
            minpagesize: 0x1000 as libc::c_int as bfd_vma,
            commonpagesize: 0x1000 as libc::c_int as bfd_vma,
            relropagesize: 0x1000 as libc::c_int as bfd_vma,
            dynamic_sec_flags: (0x1 as libc::c_int | 0x2 as libc::c_int
                | 0x100 as libc::c_int | 0x4000 as libc::c_int | 0x100000 as libc::c_int)
                as flagword,
            arch_data: 0 as *const libc::c_void,
            elf_info_to_howto: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_info_to_howto_rel: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_backend_sym_is_global: None,
            elf_backend_object_p: None,
            elf_backend_symbol_processing: None,
            elf_backend_symbol_table_processing: None,
            elf_backend_get_symbol_type: None,
            elf_backend_archive_symbol_lookup: Some(
                _bfd_elf_archive_symbol_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *const libc::c_char,
                    ) -> *mut bfd_link_hash_entry,
            ),
            elf_backend_name_local_section_symbols: None,
            elf_backend_section_processing: None,
            elf_backend_section_from_shdr: Some(
                _bfd_elf_make_section_from_shdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_int,
                    ) -> bool,
            ),
            elf_backend_section_flags: None,
            get_sec_type_attr: Some(
                _bfd_elf_get_sec_type_attr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                    ) -> *const bfd_elf_special_section,
            ),
            elf_backend_section_from_phdr: Some(
                _bfd_elf_make_section_from_phdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Phdr,
                        libc::c_int,
                        *const libc::c_char,
                    ) -> bool,
            ),
            elf_backend_fake_sections: Some(
                elf_i386_fake_sections
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_section_from_bfd_section: None,
            elf_add_symbol_hook: None,
            elf_backend_link_output_symbol_hook: None,
            elf_backend_create_dynamic_sections: Some(
                _bfd_elf_create_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_omit_section_dynsym: Some(
                _bfd_elf_omit_section_dynsym_all
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            relocs_compatible: Some(
                _bfd_elf_relocs_compatible
                    as unsafe extern "C" fn(*const bfd_target, *const bfd_target) -> bool,
            ),
            check_relocs: Some(
                elf_i386_check_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        *const Elf_Internal_Rela,
                    ) -> bool,
            ),
            check_directives: None,
            notice_as_needed: Some(
                _bfd_elf_notice_as_needed
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        notice_asneeded_action,
                    ) -> bool,
            ),
            elf_backend_adjust_dynamic_symbol: Some(
                _bfd_x86_elf_adjust_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_always_size_sections: Some(
                _bfd_x86_elf_always_size_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_size_dynamic_sections: Some(
                _bfd_x86_elf_size_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_strip_zero_sized_dynamic_sections: None,
            elf_backend_init_index_section: Some(
                _bfd_void_bfd_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
            ),
            elf_backend_relocate_section: Some(
                elf_i386_relocate_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_byte,
                        *mut Elf_Internal_Rela,
                        *mut Elf_Internal_Sym,
                        *mut *mut asection,
                    ) -> libc::c_int,
            ),
            elf_backend_finish_dynamic_symbol: Some(
                elf_i386_finish_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> bool,
            ),
            elf_backend_finish_dynamic_sections: Some(
                elf_i386_finish_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_begin_write_processing: None,
            elf_backend_final_write_processing: Some(
                _bfd_elf_final_write_processing as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            elf_backend_additional_program_headers: None,
            elf_backend_modify_segment_map: None,
            elf_backend_modify_headers: Some(
                _bfd_elf_modify_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_allow_non_load_phdr: None,
            gc_keep: Some(
                _bfd_elf_gc_keep as unsafe extern "C" fn(*mut bfd_link_info) -> (),
            ),
            gc_mark_dynamic_ref: Some(
                bfd_elf_gc_mark_dynamic_ref_symbol
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            gc_mark_hook: Some(
                _bfd_x86_elf_gc_mark_hook
                    as unsafe extern "C" fn(
                        *mut asection,
                        *mut bfd_link_info,
                        *mut Elf_Internal_Rela,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> *mut asection,
            ),
            gc_mark_extra_sections: Some(
                _bfd_elf_gc_mark_extra_sections
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        elf_gc_mark_hook_fn,
                    ) -> bool,
            ),
            elf_backend_init_file_header: Some(
                _bfd_elf_init_file_header
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_print_symbol_all: None,
            elf_backend_output_arch_local_syms: Some(
                elf_i386_output_arch_local_syms
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut libc::c_void,
                        Option::<
                            unsafe extern "C" fn(
                                *mut libc::c_void,
                                *const libc::c_char,
                                *mut Elf_Internal_Sym,
                                *mut asection,
                                *mut elf_link_hash_entry,
                            ) -> libc::c_int,
                        >,
                    ) -> bool,
            ),
            elf_backend_output_arch_syms: None,
            elf_backend_filter_implib_symbols: None,
            elf_backend_copy_indirect_symbol: Some(
                _bfd_x86_elf_copy_indirect_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut elf_link_hash_entry,
                    ) -> (),
            ),
            elf_backend_hide_symbol: Some(
                _bfd_x86_elf_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        bool,
                    ) -> (),
            ),
            elf_backend_fixup_symbol: Some(
                _bfd_x86_elf_fixup_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_merge_symbol_attribute: Some(
                _bfd_x86_elf_merge_symbol_attribute
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        libc::c_uint,
                        bool,
                        bool,
                    ) -> (),
            ),
            elf_backend_get_target_dtag: None,
            elf_backend_ignore_undef_symbol: None,
            elf_backend_emit_relocs: Some(
                _bfd_elf_link_output_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut Elf_Internal_Shdr,
                        *mut Elf_Internal_Rela,
                        *mut *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_update_relocs: None,
            elf_backend_count_relocs: None,
            elf_backend_count_additional_relocs: None,
            sort_relocs_p: None,
            elf_backend_grok_prstatus: Some(
                elf_i386_grok_prstatus
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_psinfo: Some(
                elf_i386_grok_psinfo
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_freebsd_prstatus: None,
            elf_backend_write_core_note: None,
            elf_backend_lookup_section_flags_hook: None,
            elf_backend_reloc_type_class: Some(
                elf_i386_reloc_type_class
                    as unsafe extern "C" fn(
                        *const bfd_link_info,
                        *const asection,
                        *const Elf_Internal_Rela,
                    ) -> elf_reloc_type_class,
            ),
            elf_backend_discard_info: None,
            elf_backend_ignore_discarded_relocs: None,
            action_discarded: Some(
                _bfd_elf_default_action_discarded
                    as unsafe extern "C" fn(*mut bfd_section) -> libc::c_uint,
            ),
            elf_backend_eh_frame_address_size: Some(
                _bfd_elf_eh_frame_address_size
                    as unsafe extern "C" fn(*mut bfd, *const asection) -> libc::c_uint,
            ),
            elf_backend_can_make_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_can_make_lsda_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_encode_eh_address: Some(
                _bfd_elf_encode_eh_address
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        bfd_vma,
                        *mut asection,
                        bfd_vma,
                        *mut bfd_vma,
                    ) -> bfd_byte,
            ),
            elf_backend_write_section: None,
            elf_backend_elfsym_local_is_section: None,
            elf_backend_mips_irix_compat: None,
            elf_backend_mips_rtype_to_howto: None,
            elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
            elf_backend_bfd_from_remote_memory: Some(
                _bfd_elf32_bfd_from_remote_memory
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_vma,
                        bfd_size_type,
                        *mut bfd_vma,
                        Option::<
                            unsafe extern "C" fn(
                                bfd_vma,
                                *mut bfd_byte,
                                bfd_size_type,
                            ) -> libc::c_int,
                        >,
                    ) -> *mut bfd,
            ),
            elf_backend_core_find_build_id: Some(
                _bfd_elf32_core_find_build_id
                    as unsafe extern "C" fn(*mut bfd, bfd_vma) -> bool,
            ),
            plt_sym_val: None,
            common_definition: Some(
                _bfd_elf_common_definition
                    as unsafe extern "C" fn(*mut Elf_Internal_Sym) -> bool,
            ),
            common_section_index: Some(
                _bfd_elf_common_section_index
                    as unsafe extern "C" fn(*mut asection) -> libc::c_uint,
            ),
            common_section: Some(
                _bfd_elf_common_section
                    as unsafe extern "C" fn(*mut asection) -> *mut asection,
            ),
            merge_symbol: None,
            elf_hash_symbol: Some(
                _bfd_x86_elf_hash_symbol
                    as unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
            ),
            record_xhash_symbol: None,
            is_function_type: Some(
                _bfd_elf_is_function_type as unsafe extern "C" fn(libc::c_uint) -> bool,
            ),
            maybe_function_sym: Some(
                _bfd_elf_maybe_function_sym
                    as unsafe extern "C" fn(
                        *const asymbol,
                        *mut asection,
                        *mut bfd_vma,
                    ) -> bfd_size_type,
            ),
            get_reloc_section: Some(
                _bfd_elf_plt_get_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *mut asection,
            ),
            elf_backend_copy_special_section_fields: Some(
                elf32_i386_copy_solaris_special_section_fields
                    as unsafe extern "C" fn(
                        *const bfd,
                        *mut bfd,
                        *const Elf_Internal_Shdr,
                        *mut Elf_Internal_Shdr,
                    ) -> bool,
            ),
            link_order_error_handler: Some(
                _bfd_error_handler
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
            ),
            relplt_name: 0 as *const libc::c_char,
            elf_machine_alt1: 0 as libc::c_int,
            elf_machine_alt2: 0 as libc::c_int,
            s: &_bfd_elf32_size_info,
            special_sections: 0 as *const bfd_elf_special_section,
            got_header_size: 12 as libc::c_int as bfd_vma,
            got_elt_size: Some(
                _bfd_elf_default_got_elt_size
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut bfd,
                        libc::c_ulong,
                    ) -> bfd_vma,
            ),
            obj_attrs_vendor: 0 as *const libc::c_char,
            obj_attrs_section: 0 as *const libc::c_char,
            obj_attrs_arg_type: None,
            obj_attrs_section_type: 0x6ffffff5 as libc::c_int as libc::c_uint,
            obj_attrs_order: None,
            obj_attrs_handle_unknown: None,
            parse_gnu_properties: Some(
                _bfd_x86_elf_parse_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut bfd_byte,
                        libc::c_uint,
                    ) -> elf_property_kind,
            ),
            merge_gnu_properties: Some(
                _bfd_x86_elf_merge_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut bfd,
                        *mut elf_property,
                        *mut elf_property,
                    ) -> bool,
            ),
            setup_gnu_properties: Some(
                elf_i386_link_setup_gnu_properties
                    as unsafe extern "C" fn(*mut bfd_link_info) -> *mut bfd,
            ),
            fixup_gnu_properties: Some(
                _bfd_x86_elf_link_fixup_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut *mut elf_property_list,
                    ) -> (),
            ),
            compact_eh_encoding: None,
            cant_unwind_opcode: None,
            symbol_section_index: None,
            init_secondary_reloc_section: Some(
                _bfd_elf_init_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_uint,
                    ) -> bool,
            ),
            slurp_secondary_relocs: Some(
                _bfd_elf_slurp_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut *mut asymbol,
                        bool,
                    ) -> bool,
            ),
            write_secondary_relocs: Some(
                _bfd_elf_write_secondary_reloc_section
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            static_tls_alignment: 8 as libc::c_int as libc::c_uint,
            stack_align: 16 as libc::c_int as libc::c_uint,
            elf_strtab_flags: ((1 as libc::c_int) << 5 as libc::c_int) as libc::c_ulong,
        };
        init.set_collect(0 as libc::c_int as libc::c_uint);
        init.set_type_change_ok(0 as libc::c_int as libc::c_uint);
        init.set_may_use_rel_p(1 as libc::c_int as libc::c_uint);
        init.set_may_use_rela_p((1 as libc::c_int == 0) as libc::c_int as libc::c_uint);
        init.set_default_use_rela_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_plts_and_copies_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_normal(0 as libc::c_int as libc::c_uint);
        init.set_dtrel_excludes_plt(1 as libc::c_int as libc::c_uint);
        init.set_sign_extend_vma(0 as libc::c_int as libc::c_uint);
        init.set_want_got_plt(1 as libc::c_int as libc::c_uint);
        init.set_plt_readonly(1 as libc::c_int as libc::c_uint);
        init.set_want_plt_sym(1 as libc::c_int as libc::c_uint);
        init.set_plt_not_loaded(0 as libc::c_int as libc::c_uint);
        init.set_plt_alignment(4 as libc::c_int as libc::c_uint);
        init.set_can_gc_sections(1 as libc::c_int as libc::c_uint);
        init.set_can_refcount(1 as libc::c_int as libc::c_uint);
        init.set_want_got_sym(1 as libc::c_int as libc::c_uint);
        init.set_want_dynbss(1 as libc::c_int as libc::c_uint);
        init.set_want_dynrelro(1 as libc::c_int as libc::c_uint);
        init.set_want_p_paddr_set_to_zero(0 as libc::c_int as libc::c_uint);
        init.set_no_page_alias(0 as libc::c_int as libc::c_uint);
        init.set_default_execstack(1 as libc::c_int as libc::c_uint);
        init.set_caches_rawsize(1 as libc::c_int as libc::c_uint);
        init.set_extern_protected_data(1 as libc::c_int as libc::c_uint);
        init.set_always_renumber_dynsyms(0 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo32_ugid16(1 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo64_ugid16(0 as libc::c_int as libc::c_uint);
        init
    };
    elf32_i386_fbsd_bed = {
        let mut init = elf_backend_data {
            collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
            c2rust_padding: [0; 4],
            arch: bfd_arch_i386,
            target_id: I386_ELF_DATA,
            target_os: is_normal,
            elf_machine_code: 3 as libc::c_int,
            elf_osabi: 9 as libc::c_int,
            maxpagesize: 0x1000 as libc::c_int as bfd_vma,
            minpagesize: 0x1000 as libc::c_int as bfd_vma,
            commonpagesize: 0x1000 as libc::c_int as bfd_vma,
            relropagesize: 0x1000 as libc::c_int as bfd_vma,
            dynamic_sec_flags: (0x1 as libc::c_int | 0x2 as libc::c_int
                | 0x100 as libc::c_int | 0x4000 as libc::c_int | 0x100000 as libc::c_int)
                as flagword,
            arch_data: 0 as *const libc::c_void,
            elf_info_to_howto: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_info_to_howto_rel: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_backend_sym_is_global: None,
            elf_backend_object_p: None,
            elf_backend_symbol_processing: None,
            elf_backend_symbol_table_processing: None,
            elf_backend_get_symbol_type: None,
            elf_backend_archive_symbol_lookup: Some(
                _bfd_elf_archive_symbol_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *const libc::c_char,
                    ) -> *mut bfd_link_hash_entry,
            ),
            elf_backend_name_local_section_symbols: None,
            elf_backend_section_processing: None,
            elf_backend_section_from_shdr: Some(
                _bfd_elf_make_section_from_shdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_int,
                    ) -> bool,
            ),
            elf_backend_section_flags: None,
            get_sec_type_attr: Some(
                _bfd_elf_get_sec_type_attr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                    ) -> *const bfd_elf_special_section,
            ),
            elf_backend_section_from_phdr: Some(
                _bfd_elf_make_section_from_phdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Phdr,
                        libc::c_int,
                        *const libc::c_char,
                    ) -> bool,
            ),
            elf_backend_fake_sections: Some(
                elf_i386_fake_sections
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_section_from_bfd_section: None,
            elf_add_symbol_hook: None,
            elf_backend_link_output_symbol_hook: None,
            elf_backend_create_dynamic_sections: Some(
                _bfd_elf_create_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_omit_section_dynsym: Some(
                _bfd_elf_omit_section_dynsym_all
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            relocs_compatible: Some(
                _bfd_elf_relocs_compatible
                    as unsafe extern "C" fn(*const bfd_target, *const bfd_target) -> bool,
            ),
            check_relocs: Some(
                elf_i386_check_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        *const Elf_Internal_Rela,
                    ) -> bool,
            ),
            check_directives: None,
            notice_as_needed: Some(
                _bfd_elf_notice_as_needed
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        notice_asneeded_action,
                    ) -> bool,
            ),
            elf_backend_adjust_dynamic_symbol: Some(
                _bfd_x86_elf_adjust_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_always_size_sections: Some(
                _bfd_x86_elf_always_size_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_size_dynamic_sections: Some(
                _bfd_x86_elf_size_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_strip_zero_sized_dynamic_sections: None,
            elf_backend_init_index_section: Some(
                _bfd_void_bfd_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
            ),
            elf_backend_relocate_section: Some(
                elf_i386_relocate_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_byte,
                        *mut Elf_Internal_Rela,
                        *mut Elf_Internal_Sym,
                        *mut *mut asection,
                    ) -> libc::c_int,
            ),
            elf_backend_finish_dynamic_symbol: Some(
                elf_i386_finish_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> bool,
            ),
            elf_backend_finish_dynamic_sections: Some(
                elf_i386_finish_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_begin_write_processing: None,
            elf_backend_final_write_processing: Some(
                _bfd_elf_final_write_processing as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            elf_backend_additional_program_headers: None,
            elf_backend_modify_segment_map: None,
            elf_backend_modify_headers: Some(
                _bfd_elf_modify_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_allow_non_load_phdr: None,
            gc_keep: Some(
                _bfd_elf_gc_keep as unsafe extern "C" fn(*mut bfd_link_info) -> (),
            ),
            gc_mark_dynamic_ref: Some(
                bfd_elf_gc_mark_dynamic_ref_symbol
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            gc_mark_hook: Some(
                _bfd_x86_elf_gc_mark_hook
                    as unsafe extern "C" fn(
                        *mut asection,
                        *mut bfd_link_info,
                        *mut Elf_Internal_Rela,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> *mut asection,
            ),
            gc_mark_extra_sections: Some(
                _bfd_elf_gc_mark_extra_sections
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        elf_gc_mark_hook_fn,
                    ) -> bool,
            ),
            elf_backend_init_file_header: Some(
                elf_i386_fbsd_init_file_header
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_print_symbol_all: None,
            elf_backend_output_arch_local_syms: Some(
                elf_i386_output_arch_local_syms
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut libc::c_void,
                        Option::<
                            unsafe extern "C" fn(
                                *mut libc::c_void,
                                *const libc::c_char,
                                *mut Elf_Internal_Sym,
                                *mut asection,
                                *mut elf_link_hash_entry,
                            ) -> libc::c_int,
                        >,
                    ) -> bool,
            ),
            elf_backend_output_arch_syms: None,
            elf_backend_filter_implib_symbols: None,
            elf_backend_copy_indirect_symbol: Some(
                _bfd_x86_elf_copy_indirect_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut elf_link_hash_entry,
                    ) -> (),
            ),
            elf_backend_hide_symbol: Some(
                _bfd_x86_elf_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        bool,
                    ) -> (),
            ),
            elf_backend_fixup_symbol: Some(
                _bfd_x86_elf_fixup_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_merge_symbol_attribute: Some(
                _bfd_x86_elf_merge_symbol_attribute
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        libc::c_uint,
                        bool,
                        bool,
                    ) -> (),
            ),
            elf_backend_get_target_dtag: None,
            elf_backend_ignore_undef_symbol: None,
            elf_backend_emit_relocs: Some(
                _bfd_elf_link_output_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut Elf_Internal_Shdr,
                        *mut Elf_Internal_Rela,
                        *mut *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_update_relocs: None,
            elf_backend_count_relocs: None,
            elf_backend_count_additional_relocs: None,
            sort_relocs_p: None,
            elf_backend_grok_prstatus: Some(
                elf_i386_grok_prstatus
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_psinfo: Some(
                elf_i386_grok_psinfo
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_freebsd_prstatus: None,
            elf_backend_write_core_note: None,
            elf_backend_lookup_section_flags_hook: None,
            elf_backend_reloc_type_class: Some(
                elf_i386_reloc_type_class
                    as unsafe extern "C" fn(
                        *const bfd_link_info,
                        *const asection,
                        *const Elf_Internal_Rela,
                    ) -> elf_reloc_type_class,
            ),
            elf_backend_discard_info: None,
            elf_backend_ignore_discarded_relocs: None,
            action_discarded: Some(
                _bfd_elf_default_action_discarded
                    as unsafe extern "C" fn(*mut bfd_section) -> libc::c_uint,
            ),
            elf_backend_eh_frame_address_size: Some(
                _bfd_elf_eh_frame_address_size
                    as unsafe extern "C" fn(*mut bfd, *const asection) -> libc::c_uint,
            ),
            elf_backend_can_make_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_can_make_lsda_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_encode_eh_address: Some(
                _bfd_elf_encode_eh_address
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        bfd_vma,
                        *mut asection,
                        bfd_vma,
                        *mut bfd_vma,
                    ) -> bfd_byte,
            ),
            elf_backend_write_section: None,
            elf_backend_elfsym_local_is_section: None,
            elf_backend_mips_irix_compat: None,
            elf_backend_mips_rtype_to_howto: None,
            elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
            elf_backend_bfd_from_remote_memory: Some(
                _bfd_elf32_bfd_from_remote_memory
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_vma,
                        bfd_size_type,
                        *mut bfd_vma,
                        Option::<
                            unsafe extern "C" fn(
                                bfd_vma,
                                *mut bfd_byte,
                                bfd_size_type,
                            ) -> libc::c_int,
                        >,
                    ) -> *mut bfd,
            ),
            elf_backend_core_find_build_id: Some(
                _bfd_elf32_core_find_build_id
                    as unsafe extern "C" fn(*mut bfd, bfd_vma) -> bool,
            ),
            plt_sym_val: None,
            common_definition: Some(
                _bfd_elf_common_definition
                    as unsafe extern "C" fn(*mut Elf_Internal_Sym) -> bool,
            ),
            common_section_index: Some(
                _bfd_elf_common_section_index
                    as unsafe extern "C" fn(*mut asection) -> libc::c_uint,
            ),
            common_section: Some(
                _bfd_elf_common_section
                    as unsafe extern "C" fn(*mut asection) -> *mut asection,
            ),
            merge_symbol: None,
            elf_hash_symbol: Some(
                _bfd_x86_elf_hash_symbol
                    as unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
            ),
            record_xhash_symbol: None,
            is_function_type: Some(
                _bfd_elf_is_function_type as unsafe extern "C" fn(libc::c_uint) -> bool,
            ),
            maybe_function_sym: Some(
                _bfd_elf_maybe_function_sym
                    as unsafe extern "C" fn(
                        *const asymbol,
                        *mut asection,
                        *mut bfd_vma,
                    ) -> bfd_size_type,
            ),
            get_reloc_section: Some(
                _bfd_elf_plt_get_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *mut asection,
            ),
            elf_backend_copy_special_section_fields: Some(
                _bfd_elf_copy_special_section_fields
                    as unsafe extern "C" fn(
                        *const bfd,
                        *mut bfd,
                        *const Elf_Internal_Shdr,
                        *mut Elf_Internal_Shdr,
                    ) -> bool,
            ),
            link_order_error_handler: Some(
                _bfd_error_handler
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
            ),
            relplt_name: 0 as *const libc::c_char,
            elf_machine_alt1: 0 as libc::c_int,
            elf_machine_alt2: 0 as libc::c_int,
            s: &_bfd_elf32_size_info,
            special_sections: 0 as *const bfd_elf_special_section,
            got_header_size: 12 as libc::c_int as bfd_vma,
            got_elt_size: Some(
                _bfd_elf_default_got_elt_size
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut bfd,
                        libc::c_ulong,
                    ) -> bfd_vma,
            ),
            obj_attrs_vendor: 0 as *const libc::c_char,
            obj_attrs_section: 0 as *const libc::c_char,
            obj_attrs_arg_type: None,
            obj_attrs_section_type: 0x6ffffff5 as libc::c_int as libc::c_uint,
            obj_attrs_order: None,
            obj_attrs_handle_unknown: None,
            parse_gnu_properties: Some(
                _bfd_x86_elf_parse_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut bfd_byte,
                        libc::c_uint,
                    ) -> elf_property_kind,
            ),
            merge_gnu_properties: Some(
                _bfd_x86_elf_merge_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut bfd,
                        *mut elf_property,
                        *mut elf_property,
                    ) -> bool,
            ),
            setup_gnu_properties: Some(
                elf_i386_link_setup_gnu_properties
                    as unsafe extern "C" fn(*mut bfd_link_info) -> *mut bfd,
            ),
            fixup_gnu_properties: Some(
                _bfd_x86_elf_link_fixup_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut *mut elf_property_list,
                    ) -> (),
            ),
            compact_eh_encoding: None,
            cant_unwind_opcode: None,
            symbol_section_index: None,
            init_secondary_reloc_section: Some(
                _bfd_elf_init_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_uint,
                    ) -> bool,
            ),
            slurp_secondary_relocs: Some(
                _bfd_elf_slurp_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut *mut asymbol,
                        bool,
                    ) -> bool,
            ),
            write_secondary_relocs: Some(
                _bfd_elf_write_secondary_reloc_section
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            static_tls_alignment: 1 as libc::c_int as libc::c_uint,
            stack_align: 16 as libc::c_int as libc::c_uint,
            elf_strtab_flags: 0 as libc::c_int as libc::c_ulong,
        };
        init.set_collect(0 as libc::c_int as libc::c_uint);
        init.set_type_change_ok(0 as libc::c_int as libc::c_uint);
        init.set_may_use_rel_p(1 as libc::c_int as libc::c_uint);
        init.set_may_use_rela_p((1 as libc::c_int == 0) as libc::c_int as libc::c_uint);
        init.set_default_use_rela_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_plts_and_copies_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_normal(0 as libc::c_int as libc::c_uint);
        init.set_dtrel_excludes_plt(1 as libc::c_int as libc::c_uint);
        init.set_sign_extend_vma(0 as libc::c_int as libc::c_uint);
        init.set_want_got_plt(1 as libc::c_int as libc::c_uint);
        init.set_plt_readonly(1 as libc::c_int as libc::c_uint);
        init.set_want_plt_sym(0 as libc::c_int as libc::c_uint);
        init.set_plt_not_loaded(0 as libc::c_int as libc::c_uint);
        init.set_plt_alignment(4 as libc::c_int as libc::c_uint);
        init.set_can_gc_sections(1 as libc::c_int as libc::c_uint);
        init.set_can_refcount(1 as libc::c_int as libc::c_uint);
        init.set_want_got_sym(1 as libc::c_int as libc::c_uint);
        init.set_want_dynbss(1 as libc::c_int as libc::c_uint);
        init.set_want_dynrelro(1 as libc::c_int as libc::c_uint);
        init.set_want_p_paddr_set_to_zero(0 as libc::c_int as libc::c_uint);
        init.set_no_page_alias(0 as libc::c_int as libc::c_uint);
        init.set_default_execstack(1 as libc::c_int as libc::c_uint);
        init.set_caches_rawsize(1 as libc::c_int as libc::c_uint);
        init.set_extern_protected_data(1 as libc::c_int as libc::c_uint);
        init.set_always_renumber_dynsyms(0 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo32_ugid16(1 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo64_ugid16(0 as libc::c_int as libc::c_uint);
        init
    };
    elf32_i386_vxworks_bed = {
        let mut init = elf_backend_data {
            collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
            c2rust_padding: [0; 4],
            arch: bfd_arch_i386,
            target_id: I386_ELF_DATA,
            target_os: is_vxworks,
            elf_machine_code: 3 as libc::c_int,
            elf_osabi: 0 as libc::c_int,
            maxpagesize: 0x1000 as libc::c_int as bfd_vma,
            minpagesize: 0x1000 as libc::c_int as bfd_vma,
            commonpagesize: 0x1000 as libc::c_int as bfd_vma,
            relropagesize: 0x1000 as libc::c_int as bfd_vma,
            dynamic_sec_flags: (0x1 as libc::c_int | 0x2 as libc::c_int
                | 0x100 as libc::c_int | 0x4000 as libc::c_int | 0x100000 as libc::c_int)
                as flagword,
            arch_data: 0 as *const libc::c_void,
            elf_info_to_howto: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_info_to_howto_rel: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_backend_sym_is_global: None,
            elf_backend_object_p: None,
            elf_backend_symbol_processing: None,
            elf_backend_symbol_table_processing: None,
            elf_backend_get_symbol_type: None,
            elf_backend_archive_symbol_lookup: Some(
                _bfd_elf_archive_symbol_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *const libc::c_char,
                    ) -> *mut bfd_link_hash_entry,
            ),
            elf_backend_name_local_section_symbols: None,
            elf_backend_section_processing: None,
            elf_backend_section_from_shdr: Some(
                _bfd_elf_make_section_from_shdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_int,
                    ) -> bool,
            ),
            elf_backend_section_flags: None,
            get_sec_type_attr: Some(
                _bfd_elf_get_sec_type_attr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                    ) -> *const bfd_elf_special_section,
            ),
            elf_backend_section_from_phdr: Some(
                _bfd_elf_make_section_from_phdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Phdr,
                        libc::c_int,
                        *const libc::c_char,
                    ) -> bool,
            ),
            elf_backend_fake_sections: Some(
                elf_i386_fake_sections
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_section_from_bfd_section: None,
            elf_add_symbol_hook: Some(
                elf_vxworks_add_symbol_hook
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut Elf_Internal_Sym,
                        *mut *const libc::c_char,
                        *mut flagword,
                        *mut *mut asection,
                        *mut bfd_vma,
                    ) -> bool,
            ),
            elf_backend_link_output_symbol_hook: Some(
                elf_vxworks_link_output_symbol_hook
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *const libc::c_char,
                        *mut Elf_Internal_Sym,
                        *mut asection,
                        *mut elf_link_hash_entry,
                    ) -> libc::c_int,
            ),
            elf_backend_create_dynamic_sections: Some(
                _bfd_elf_create_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_omit_section_dynsym: Some(
                _bfd_elf_omit_section_dynsym_all
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            relocs_compatible: Some(
                _bfd_elf_default_relocs_compatible
                    as unsafe extern "C" fn(*const bfd_target, *const bfd_target) -> bool,
            ),
            check_relocs: Some(
                elf_i386_check_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        *const Elf_Internal_Rela,
                    ) -> bool,
            ),
            check_directives: None,
            notice_as_needed: Some(
                _bfd_elf_notice_as_needed
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        notice_asneeded_action,
                    ) -> bool,
            ),
            elf_backend_adjust_dynamic_symbol: Some(
                _bfd_x86_elf_adjust_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_always_size_sections: Some(
                _bfd_x86_elf_always_size_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_size_dynamic_sections: Some(
                _bfd_x86_elf_size_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_strip_zero_sized_dynamic_sections: None,
            elf_backend_init_index_section: Some(
                _bfd_void_bfd_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
            ),
            elf_backend_relocate_section: Some(
                elf_i386_relocate_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_byte,
                        *mut Elf_Internal_Rela,
                        *mut Elf_Internal_Sym,
                        *mut *mut asection,
                    ) -> libc::c_int,
            ),
            elf_backend_finish_dynamic_symbol: Some(
                elf_i386_finish_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> bool,
            ),
            elf_backend_finish_dynamic_sections: Some(
                elf_i386_finish_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_begin_write_processing: None,
            elf_backend_final_write_processing: Some(
                elf_vxworks_final_write_processing
                    as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            elf_backend_additional_program_headers: None,
            elf_backend_modify_segment_map: None,
            elf_backend_modify_headers: Some(
                _bfd_elf_modify_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_allow_non_load_phdr: None,
            gc_keep: Some(
                _bfd_elf_gc_keep as unsafe extern "C" fn(*mut bfd_link_info) -> (),
            ),
            gc_mark_dynamic_ref: Some(
                bfd_elf_gc_mark_dynamic_ref_symbol
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            gc_mark_hook: Some(
                _bfd_x86_elf_gc_mark_hook
                    as unsafe extern "C" fn(
                        *mut asection,
                        *mut bfd_link_info,
                        *mut Elf_Internal_Rela,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> *mut asection,
            ),
            gc_mark_extra_sections: Some(
                _bfd_elf_gc_mark_extra_sections
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        elf_gc_mark_hook_fn,
                    ) -> bool,
            ),
            elf_backend_init_file_header: Some(
                _bfd_elf_init_file_header
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_print_symbol_all: None,
            elf_backend_output_arch_local_syms: Some(
                elf_i386_output_arch_local_syms
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut libc::c_void,
                        Option::<
                            unsafe extern "C" fn(
                                *mut libc::c_void,
                                *const libc::c_char,
                                *mut Elf_Internal_Sym,
                                *mut asection,
                                *mut elf_link_hash_entry,
                            ) -> libc::c_int,
                        >,
                    ) -> bool,
            ),
            elf_backend_output_arch_syms: None,
            elf_backend_filter_implib_symbols: None,
            elf_backend_copy_indirect_symbol: Some(
                _bfd_x86_elf_copy_indirect_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut elf_link_hash_entry,
                    ) -> (),
            ),
            elf_backend_hide_symbol: Some(
                _bfd_x86_elf_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        bool,
                    ) -> (),
            ),
            elf_backend_fixup_symbol: Some(
                _bfd_x86_elf_fixup_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_merge_symbol_attribute: Some(
                _bfd_x86_elf_merge_symbol_attribute
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        libc::c_uint,
                        bool,
                        bool,
                    ) -> (),
            ),
            elf_backend_get_target_dtag: None,
            elf_backend_ignore_undef_symbol: None,
            elf_backend_emit_relocs: Some(
                elf_vxworks_emit_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut Elf_Internal_Shdr,
                        *mut Elf_Internal_Rela,
                        *mut *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_update_relocs: None,
            elf_backend_count_relocs: None,
            elf_backend_count_additional_relocs: None,
            sort_relocs_p: None,
            elf_backend_grok_prstatus: Some(
                elf_i386_grok_prstatus
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_psinfo: Some(
                elf_i386_grok_psinfo
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_freebsd_prstatus: None,
            elf_backend_write_core_note: None,
            elf_backend_lookup_section_flags_hook: None,
            elf_backend_reloc_type_class: Some(
                elf_i386_reloc_type_class
                    as unsafe extern "C" fn(
                        *const bfd_link_info,
                        *const asection,
                        *const Elf_Internal_Rela,
                    ) -> elf_reloc_type_class,
            ),
            elf_backend_discard_info: None,
            elf_backend_ignore_discarded_relocs: None,
            action_discarded: Some(
                _bfd_elf_default_action_discarded
                    as unsafe extern "C" fn(*mut bfd_section) -> libc::c_uint,
            ),
            elf_backend_eh_frame_address_size: Some(
                _bfd_elf_eh_frame_address_size
                    as unsafe extern "C" fn(*mut bfd, *const asection) -> libc::c_uint,
            ),
            elf_backend_can_make_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_can_make_lsda_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_encode_eh_address: Some(
                _bfd_elf_encode_eh_address
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        bfd_vma,
                        *mut asection,
                        bfd_vma,
                        *mut bfd_vma,
                    ) -> bfd_byte,
            ),
            elf_backend_write_section: None,
            elf_backend_elfsym_local_is_section: None,
            elf_backend_mips_irix_compat: None,
            elf_backend_mips_rtype_to_howto: None,
            elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
            elf_backend_bfd_from_remote_memory: Some(
                _bfd_elf32_bfd_from_remote_memory
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_vma,
                        bfd_size_type,
                        *mut bfd_vma,
                        Option::<
                            unsafe extern "C" fn(
                                bfd_vma,
                                *mut bfd_byte,
                                bfd_size_type,
                            ) -> libc::c_int,
                        >,
                    ) -> *mut bfd,
            ),
            elf_backend_core_find_build_id: Some(
                _bfd_elf32_core_find_build_id
                    as unsafe extern "C" fn(*mut bfd, bfd_vma) -> bool,
            ),
            plt_sym_val: None,
            common_definition: Some(
                _bfd_elf_common_definition
                    as unsafe extern "C" fn(*mut Elf_Internal_Sym) -> bool,
            ),
            common_section_index: Some(
                _bfd_elf_common_section_index
                    as unsafe extern "C" fn(*mut asection) -> libc::c_uint,
            ),
            common_section: Some(
                _bfd_elf_common_section
                    as unsafe extern "C" fn(*mut asection) -> *mut asection,
            ),
            merge_symbol: None,
            elf_hash_symbol: Some(
                _bfd_x86_elf_hash_symbol
                    as unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
            ),
            record_xhash_symbol: None,
            is_function_type: Some(
                _bfd_elf_is_function_type as unsafe extern "C" fn(libc::c_uint) -> bool,
            ),
            maybe_function_sym: Some(
                _bfd_elf_maybe_function_sym
                    as unsafe extern "C" fn(
                        *const asymbol,
                        *mut asection,
                        *mut bfd_vma,
                    ) -> bfd_size_type,
            ),
            get_reloc_section: Some(
                _bfd_elf_plt_get_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *mut asection,
            ),
            elf_backend_copy_special_section_fields: Some(
                _bfd_elf_copy_special_section_fields
                    as unsafe extern "C" fn(
                        *const bfd,
                        *mut bfd,
                        *const Elf_Internal_Shdr,
                        *mut Elf_Internal_Shdr,
                    ) -> bool,
            ),
            link_order_error_handler: Some(
                _bfd_error_handler
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
            ),
            relplt_name: 0 as *const libc::c_char,
            elf_machine_alt1: 0 as libc::c_int,
            elf_machine_alt2: 0 as libc::c_int,
            s: &_bfd_elf32_size_info,
            special_sections: 0 as *const bfd_elf_special_section,
            got_header_size: 12 as libc::c_int as bfd_vma,
            got_elt_size: Some(
                _bfd_elf_default_got_elt_size
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut bfd,
                        libc::c_ulong,
                    ) -> bfd_vma,
            ),
            obj_attrs_vendor: 0 as *const libc::c_char,
            obj_attrs_section: 0 as *const libc::c_char,
            obj_attrs_arg_type: None,
            obj_attrs_section_type: 0x6ffffff5 as libc::c_int as libc::c_uint,
            obj_attrs_order: None,
            obj_attrs_handle_unknown: None,
            parse_gnu_properties: Some(
                _bfd_x86_elf_parse_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut bfd_byte,
                        libc::c_uint,
                    ) -> elf_property_kind,
            ),
            merge_gnu_properties: Some(
                _bfd_x86_elf_merge_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut bfd,
                        *mut elf_property,
                        *mut elf_property,
                    ) -> bool,
            ),
            setup_gnu_properties: Some(
                elf_i386_link_setup_gnu_properties
                    as unsafe extern "C" fn(*mut bfd_link_info) -> *mut bfd,
            ),
            fixup_gnu_properties: Some(
                _bfd_x86_elf_link_fixup_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut *mut elf_property_list,
                    ) -> (),
            ),
            compact_eh_encoding: None,
            cant_unwind_opcode: None,
            symbol_section_index: None,
            init_secondary_reloc_section: Some(
                _bfd_elf_init_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_uint,
                    ) -> bool,
            ),
            slurp_secondary_relocs: Some(
                _bfd_elf_slurp_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut *mut asymbol,
                        bool,
                    ) -> bool,
            ),
            write_secondary_relocs: Some(
                _bfd_elf_write_secondary_reloc_section
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            static_tls_alignment: 1 as libc::c_int as libc::c_uint,
            stack_align: 16 as libc::c_int as libc::c_uint,
            elf_strtab_flags: 0 as libc::c_int as libc::c_ulong,
        };
        init.set_collect(0 as libc::c_int as libc::c_uint);
        init.set_type_change_ok(0 as libc::c_int as libc::c_uint);
        init.set_may_use_rel_p(1 as libc::c_int as libc::c_uint);
        init.set_may_use_rela_p((1 as libc::c_int == 0) as libc::c_int as libc::c_uint);
        init.set_default_use_rela_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_plts_and_copies_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_normal(0 as libc::c_int as libc::c_uint);
        init.set_dtrel_excludes_plt(1 as libc::c_int as libc::c_uint);
        init.set_sign_extend_vma(0 as libc::c_int as libc::c_uint);
        init.set_want_got_plt(1 as libc::c_int as libc::c_uint);
        init.set_plt_readonly(1 as libc::c_int as libc::c_uint);
        init.set_want_plt_sym(1 as libc::c_int as libc::c_uint);
        init.set_plt_not_loaded(0 as libc::c_int as libc::c_uint);
        init.set_plt_alignment(4 as libc::c_int as libc::c_uint);
        init.set_can_gc_sections(1 as libc::c_int as libc::c_uint);
        init.set_can_refcount(1 as libc::c_int as libc::c_uint);
        init.set_want_got_sym(1 as libc::c_int as libc::c_uint);
        init.set_want_dynbss(1 as libc::c_int as libc::c_uint);
        init.set_want_dynrelro(1 as libc::c_int as libc::c_uint);
        init.set_want_p_paddr_set_to_zero(0 as libc::c_int as libc::c_uint);
        init.set_no_page_alias(0 as libc::c_int as libc::c_uint);
        init.set_default_execstack(1 as libc::c_int as libc::c_uint);
        init.set_caches_rawsize(1 as libc::c_int as libc::c_uint);
        init.set_extern_protected_data(1 as libc::c_int as libc::c_uint);
        init.set_always_renumber_dynsyms(0 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo32_ugid16(1 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo64_ugid16(0 as libc::c_int as libc::c_uint);
        init
    };
    elf32_i386_bed = {
        let mut init = elf_backend_data {
            collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
            c2rust_padding: [0; 4],
            arch: bfd_arch_i386,
            target_id: I386_ELF_DATA,
            target_os: is_normal,
            elf_machine_code: 3 as libc::c_int,
            elf_osabi: 0 as libc::c_int,
            maxpagesize: 0x1000 as libc::c_int as bfd_vma,
            minpagesize: 0x1000 as libc::c_int as bfd_vma,
            commonpagesize: 0x1000 as libc::c_int as bfd_vma,
            relropagesize: 0x1000 as libc::c_int as bfd_vma,
            dynamic_sec_flags: (0x1 as libc::c_int | 0x2 as libc::c_int
                | 0x100 as libc::c_int | 0x4000 as libc::c_int | 0x100000 as libc::c_int)
                as flagword,
            arch_data: 0 as *const libc::c_void,
            elf_info_to_howto: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_info_to_howto_rel: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_backend_sym_is_global: None,
            elf_backend_object_p: None,
            elf_backend_symbol_processing: None,
            elf_backend_symbol_table_processing: None,
            elf_backend_get_symbol_type: None,
            elf_backend_archive_symbol_lookup: Some(
                _bfd_elf_archive_symbol_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *const libc::c_char,
                    ) -> *mut bfd_link_hash_entry,
            ),
            elf_backend_name_local_section_symbols: None,
            elf_backend_section_processing: None,
            elf_backend_section_from_shdr: Some(
                _bfd_elf_make_section_from_shdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_int,
                    ) -> bool,
            ),
            elf_backend_section_flags: None,
            get_sec_type_attr: Some(
                _bfd_elf_get_sec_type_attr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                    ) -> *const bfd_elf_special_section,
            ),
            elf_backend_section_from_phdr: Some(
                _bfd_elf_make_section_from_phdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Phdr,
                        libc::c_int,
                        *const libc::c_char,
                    ) -> bool,
            ),
            elf_backend_fake_sections: Some(
                elf_i386_fake_sections
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_section_from_bfd_section: None,
            elf_add_symbol_hook: None,
            elf_backend_link_output_symbol_hook: None,
            elf_backend_create_dynamic_sections: Some(
                _bfd_elf_create_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_omit_section_dynsym: Some(
                _bfd_elf_omit_section_dynsym_all
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            relocs_compatible: Some(
                _bfd_elf_relocs_compatible
                    as unsafe extern "C" fn(*const bfd_target, *const bfd_target) -> bool,
            ),
            check_relocs: Some(
                elf_i386_check_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        *const Elf_Internal_Rela,
                    ) -> bool,
            ),
            check_directives: None,
            notice_as_needed: Some(
                _bfd_elf_notice_as_needed
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        notice_asneeded_action,
                    ) -> bool,
            ),
            elf_backend_adjust_dynamic_symbol: Some(
                _bfd_x86_elf_adjust_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_always_size_sections: Some(
                _bfd_x86_elf_always_size_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_size_dynamic_sections: Some(
                _bfd_x86_elf_size_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_strip_zero_sized_dynamic_sections: None,
            elf_backend_init_index_section: Some(
                _bfd_void_bfd_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
            ),
            elf_backend_relocate_section: Some(
                elf_i386_relocate_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_byte,
                        *mut Elf_Internal_Rela,
                        *mut Elf_Internal_Sym,
                        *mut *mut asection,
                    ) -> libc::c_int,
            ),
            elf_backend_finish_dynamic_symbol: Some(
                elf_i386_finish_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> bool,
            ),
            elf_backend_finish_dynamic_sections: Some(
                elf_i386_finish_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_begin_write_processing: None,
            elf_backend_final_write_processing: Some(
                _bfd_elf_final_write_processing as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            elf_backend_additional_program_headers: None,
            elf_backend_modify_segment_map: None,
            elf_backend_modify_headers: Some(
                _bfd_elf_modify_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_allow_non_load_phdr: None,
            gc_keep: Some(
                _bfd_elf_gc_keep as unsafe extern "C" fn(*mut bfd_link_info) -> (),
            ),
            gc_mark_dynamic_ref: Some(
                bfd_elf_gc_mark_dynamic_ref_symbol
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            gc_mark_hook: Some(
                _bfd_x86_elf_gc_mark_hook
                    as unsafe extern "C" fn(
                        *mut asection,
                        *mut bfd_link_info,
                        *mut Elf_Internal_Rela,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> *mut asection,
            ),
            gc_mark_extra_sections: Some(
                _bfd_elf_gc_mark_extra_sections
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        elf_gc_mark_hook_fn,
                    ) -> bool,
            ),
            elf_backend_init_file_header: Some(
                _bfd_elf_init_file_header
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_print_symbol_all: None,
            elf_backend_output_arch_local_syms: Some(
                elf_i386_output_arch_local_syms
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut libc::c_void,
                        Option::<
                            unsafe extern "C" fn(
                                *mut libc::c_void,
                                *const libc::c_char,
                                *mut Elf_Internal_Sym,
                                *mut asection,
                                *mut elf_link_hash_entry,
                            ) -> libc::c_int,
                        >,
                    ) -> bool,
            ),
            elf_backend_output_arch_syms: None,
            elf_backend_filter_implib_symbols: None,
            elf_backend_copy_indirect_symbol: Some(
                _bfd_x86_elf_copy_indirect_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut elf_link_hash_entry,
                    ) -> (),
            ),
            elf_backend_hide_symbol: Some(
                _bfd_x86_elf_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        bool,
                    ) -> (),
            ),
            elf_backend_fixup_symbol: Some(
                _bfd_x86_elf_fixup_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_merge_symbol_attribute: Some(
                _bfd_x86_elf_merge_symbol_attribute
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        libc::c_uint,
                        bool,
                        bool,
                    ) -> (),
            ),
            elf_backend_get_target_dtag: None,
            elf_backend_ignore_undef_symbol: None,
            elf_backend_emit_relocs: Some(
                _bfd_elf_link_output_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut Elf_Internal_Shdr,
                        *mut Elf_Internal_Rela,
                        *mut *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_update_relocs: None,
            elf_backend_count_relocs: None,
            elf_backend_count_additional_relocs: None,
            sort_relocs_p: None,
            elf_backend_grok_prstatus: Some(
                elf_i386_grok_prstatus
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_psinfo: Some(
                elf_i386_grok_psinfo
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_freebsd_prstatus: None,
            elf_backend_write_core_note: None,
            elf_backend_lookup_section_flags_hook: None,
            elf_backend_reloc_type_class: Some(
                elf_i386_reloc_type_class
                    as unsafe extern "C" fn(
                        *const bfd_link_info,
                        *const asection,
                        *const Elf_Internal_Rela,
                    ) -> elf_reloc_type_class,
            ),
            elf_backend_discard_info: None,
            elf_backend_ignore_discarded_relocs: None,
            action_discarded: Some(
                _bfd_elf_default_action_discarded
                    as unsafe extern "C" fn(*mut bfd_section) -> libc::c_uint,
            ),
            elf_backend_eh_frame_address_size: Some(
                _bfd_elf_eh_frame_address_size
                    as unsafe extern "C" fn(*mut bfd, *const asection) -> libc::c_uint,
            ),
            elf_backend_can_make_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_can_make_lsda_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_encode_eh_address: Some(
                _bfd_elf_encode_eh_address
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        bfd_vma,
                        *mut asection,
                        bfd_vma,
                        *mut bfd_vma,
                    ) -> bfd_byte,
            ),
            elf_backend_write_section: None,
            elf_backend_elfsym_local_is_section: None,
            elf_backend_mips_irix_compat: None,
            elf_backend_mips_rtype_to_howto: None,
            elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
            elf_backend_bfd_from_remote_memory: Some(
                _bfd_elf32_bfd_from_remote_memory
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_vma,
                        bfd_size_type,
                        *mut bfd_vma,
                        Option::<
                            unsafe extern "C" fn(
                                bfd_vma,
                                *mut bfd_byte,
                                bfd_size_type,
                            ) -> libc::c_int,
                        >,
                    ) -> *mut bfd,
            ),
            elf_backend_core_find_build_id: Some(
                _bfd_elf32_core_find_build_id
                    as unsafe extern "C" fn(*mut bfd, bfd_vma) -> bool,
            ),
            plt_sym_val: None,
            common_definition: Some(
                _bfd_elf_common_definition
                    as unsafe extern "C" fn(*mut Elf_Internal_Sym) -> bool,
            ),
            common_section_index: Some(
                _bfd_elf_common_section_index
                    as unsafe extern "C" fn(*mut asection) -> libc::c_uint,
            ),
            common_section: Some(
                _bfd_elf_common_section
                    as unsafe extern "C" fn(*mut asection) -> *mut asection,
            ),
            merge_symbol: None,
            elf_hash_symbol: Some(
                _bfd_x86_elf_hash_symbol
                    as unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
            ),
            record_xhash_symbol: None,
            is_function_type: Some(
                _bfd_elf_is_function_type as unsafe extern "C" fn(libc::c_uint) -> bool,
            ),
            maybe_function_sym: Some(
                _bfd_elf_maybe_function_sym
                    as unsafe extern "C" fn(
                        *const asymbol,
                        *mut asection,
                        *mut bfd_vma,
                    ) -> bfd_size_type,
            ),
            get_reloc_section: Some(
                _bfd_elf_plt_get_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *mut asection,
            ),
            elf_backend_copy_special_section_fields: Some(
                _bfd_elf_copy_special_section_fields
                    as unsafe extern "C" fn(
                        *const bfd,
                        *mut bfd,
                        *const Elf_Internal_Shdr,
                        *mut Elf_Internal_Shdr,
                    ) -> bool,
            ),
            link_order_error_handler: Some(
                _bfd_error_handler
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
            ),
            relplt_name: 0 as *const libc::c_char,
            elf_machine_alt1: 0 as libc::c_int,
            elf_machine_alt2: 0 as libc::c_int,
            s: &_bfd_elf32_size_info,
            special_sections: 0 as *const bfd_elf_special_section,
            got_header_size: 12 as libc::c_int as bfd_vma,
            got_elt_size: Some(
                _bfd_elf_default_got_elt_size
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut bfd,
                        libc::c_ulong,
                    ) -> bfd_vma,
            ),
            obj_attrs_vendor: 0 as *const libc::c_char,
            obj_attrs_section: 0 as *const libc::c_char,
            obj_attrs_arg_type: None,
            obj_attrs_section_type: 0x6ffffff5 as libc::c_int as libc::c_uint,
            obj_attrs_order: None,
            obj_attrs_handle_unknown: None,
            parse_gnu_properties: Some(
                _bfd_x86_elf_parse_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut bfd_byte,
                        libc::c_uint,
                    ) -> elf_property_kind,
            ),
            merge_gnu_properties: Some(
                _bfd_x86_elf_merge_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut bfd,
                        *mut elf_property,
                        *mut elf_property,
                    ) -> bool,
            ),
            setup_gnu_properties: Some(
                elf_i386_link_setup_gnu_properties
                    as unsafe extern "C" fn(*mut bfd_link_info) -> *mut bfd,
            ),
            fixup_gnu_properties: Some(
                _bfd_x86_elf_link_fixup_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut *mut elf_property_list,
                    ) -> (),
            ),
            compact_eh_encoding: None,
            cant_unwind_opcode: None,
            symbol_section_index: None,
            init_secondary_reloc_section: Some(
                _bfd_elf_init_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_uint,
                    ) -> bool,
            ),
            slurp_secondary_relocs: Some(
                _bfd_elf_slurp_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut *mut asymbol,
                        bool,
                    ) -> bool,
            ),
            write_secondary_relocs: Some(
                _bfd_elf_write_secondary_reloc_section
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            static_tls_alignment: 1 as libc::c_int as libc::c_uint,
            stack_align: 16 as libc::c_int as libc::c_uint,
            elf_strtab_flags: 0 as libc::c_int as libc::c_ulong,
        };
        init.set_collect(0 as libc::c_int as libc::c_uint);
        init.set_type_change_ok(0 as libc::c_int as libc::c_uint);
        init.set_may_use_rel_p(1 as libc::c_int as libc::c_uint);
        init.set_may_use_rela_p((1 as libc::c_int == 0) as libc::c_int as libc::c_uint);
        init.set_default_use_rela_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_plts_and_copies_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_normal(0 as libc::c_int as libc::c_uint);
        init.set_dtrel_excludes_plt(1 as libc::c_int as libc::c_uint);
        init.set_sign_extend_vma(0 as libc::c_int as libc::c_uint);
        init.set_want_got_plt(1 as libc::c_int as libc::c_uint);
        init.set_plt_readonly(1 as libc::c_int as libc::c_uint);
        init.set_want_plt_sym(0 as libc::c_int as libc::c_uint);
        init.set_plt_not_loaded(0 as libc::c_int as libc::c_uint);
        init.set_plt_alignment(4 as libc::c_int as libc::c_uint);
        init.set_can_gc_sections(1 as libc::c_int as libc::c_uint);
        init.set_can_refcount(1 as libc::c_int as libc::c_uint);
        init.set_want_got_sym(1 as libc::c_int as libc::c_uint);
        init.set_want_dynbss(1 as libc::c_int as libc::c_uint);
        init.set_want_dynrelro(1 as libc::c_int as libc::c_uint);
        init.set_want_p_paddr_set_to_zero(0 as libc::c_int as libc::c_uint);
        init.set_no_page_alias(0 as libc::c_int as libc::c_uint);
        init.set_default_execstack(1 as libc::c_int as libc::c_uint);
        init.set_caches_rawsize(1 as libc::c_int as libc::c_uint);
        init.set_extern_protected_data(1 as libc::c_int as libc::c_uint);
        init.set_always_renumber_dynsyms(0 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo32_ugid16(1 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo64_ugid16(0 as libc::c_int as libc::c_uint);
        init
    };
    elf32_iamcu_bed = {
        let mut init = elf_backend_data {
            collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [0; 4],
            c2rust_padding: [0; 4],
            arch: bfd_arch_iamcu,
            target_id: I386_ELF_DATA,
            target_os: is_normal,
            elf_machine_code: 6 as libc::c_int,
            elf_osabi: 0 as libc::c_int,
            maxpagesize: 0x1000 as libc::c_int as bfd_vma,
            minpagesize: 0x1000 as libc::c_int as bfd_vma,
            commonpagesize: 0x1000 as libc::c_int as bfd_vma,
            relropagesize: 0x1000 as libc::c_int as bfd_vma,
            dynamic_sec_flags: (0x1 as libc::c_int | 0x2 as libc::c_int
                | 0x100 as libc::c_int | 0x4000 as libc::c_int | 0x100000 as libc::c_int)
                as flagword,
            arch_data: 0 as *const libc::c_void,
            elf_info_to_howto: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_info_to_howto_rel: Some(
                elf_i386_info_to_howto_rel
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut arelent,
                        *mut Elf_Internal_Rela,
                    ) -> bool,
            ),
            elf_backend_sym_is_global: None,
            elf_backend_object_p: Some(
                elf32_iamcu_elf_object_p as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            elf_backend_symbol_processing: None,
            elf_backend_symbol_table_processing: None,
            elf_backend_get_symbol_type: None,
            elf_backend_archive_symbol_lookup: Some(
                _bfd_elf_archive_symbol_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *const libc::c_char,
                    ) -> *mut bfd_link_hash_entry,
            ),
            elf_backend_name_local_section_symbols: None,
            elf_backend_section_processing: None,
            elf_backend_section_from_shdr: Some(
                _bfd_elf_make_section_from_shdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_int,
                    ) -> bool,
            ),
            elf_backend_section_flags: None,
            get_sec_type_attr: Some(
                _bfd_elf_get_sec_type_attr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                    ) -> *const bfd_elf_special_section,
            ),
            elf_backend_section_from_phdr: Some(
                _bfd_elf_make_section_from_phdr
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Phdr,
                        libc::c_int,
                        *const libc::c_char,
                    ) -> bool,
            ),
            elf_backend_fake_sections: Some(
                elf_i386_fake_sections
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_section_from_bfd_section: None,
            elf_add_symbol_hook: None,
            elf_backend_link_output_symbol_hook: None,
            elf_backend_create_dynamic_sections: Some(
                _bfd_elf_create_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_omit_section_dynsym: Some(
                _bfd_elf_omit_section_dynsym_all
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            relocs_compatible: Some(
                _bfd_elf_relocs_compatible
                    as unsafe extern "C" fn(*const bfd_target, *const bfd_target) -> bool,
            ),
            check_relocs: Some(
                elf_i386_check_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        *const Elf_Internal_Rela,
                    ) -> bool,
            ),
            check_directives: None,
            notice_as_needed: Some(
                _bfd_elf_notice_as_needed
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        notice_asneeded_action,
                    ) -> bool,
            ),
            elf_backend_adjust_dynamic_symbol: Some(
                _bfd_x86_elf_adjust_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_always_size_sections: Some(
                _bfd_x86_elf_always_size_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_size_dynamic_sections: Some(
                _bfd_x86_elf_size_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_strip_zero_sized_dynamic_sections: None,
            elf_backend_init_index_section: Some(
                _bfd_void_bfd_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
            ),
            elf_backend_relocate_section: Some(
                elf_i386_relocate_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_byte,
                        *mut Elf_Internal_Rela,
                        *mut Elf_Internal_Sym,
                        *mut *mut asection,
                    ) -> libc::c_int,
            ),
            elf_backend_finish_dynamic_symbol: Some(
                elf_i386_finish_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> bool,
            ),
            elf_backend_finish_dynamic_sections: Some(
                elf_i386_finish_dynamic_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_begin_write_processing: None,
            elf_backend_final_write_processing: Some(
                _bfd_elf_final_write_processing as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            elf_backend_additional_program_headers: None,
            elf_backend_modify_segment_map: None,
            elf_backend_modify_headers: Some(
                _bfd_elf_modify_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_allow_non_load_phdr: None,
            gc_keep: Some(
                _bfd_elf_gc_keep as unsafe extern "C" fn(*mut bfd_link_info) -> (),
            ),
            gc_mark_dynamic_ref: Some(
                bfd_elf_gc_mark_dynamic_ref_symbol
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            gc_mark_hook: Some(
                _bfd_x86_elf_gc_mark_hook
                    as unsafe extern "C" fn(
                        *mut asection,
                        *mut bfd_link_info,
                        *mut Elf_Internal_Rela,
                        *mut elf_link_hash_entry,
                        *mut Elf_Internal_Sym,
                    ) -> *mut asection,
            ),
            gc_mark_extra_sections: Some(
                _bfd_elf_gc_mark_extra_sections
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        elf_gc_mark_hook_fn,
                    ) -> bool,
            ),
            elf_backend_init_file_header: Some(
                _bfd_elf_init_file_header
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            elf_backend_print_symbol_all: None,
            elf_backend_output_arch_local_syms: Some(
                elf_i386_output_arch_local_syms
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut libc::c_void,
                        Option::<
                            unsafe extern "C" fn(
                                *mut libc::c_void,
                                *const libc::c_char,
                                *mut Elf_Internal_Sym,
                                *mut asection,
                                *mut elf_link_hash_entry,
                            ) -> libc::c_int,
                        >,
                    ) -> bool,
            ),
            elf_backend_output_arch_syms: None,
            elf_backend_filter_implib_symbols: None,
            elf_backend_copy_indirect_symbol: Some(
                _bfd_x86_elf_copy_indirect_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut elf_link_hash_entry,
                    ) -> (),
            ),
            elf_backend_hide_symbol: Some(
                _bfd_x86_elf_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        bool,
                    ) -> (),
            ),
            elf_backend_fixup_symbol: Some(
                _bfd_x86_elf_fixup_symbol
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_merge_symbol_attribute: Some(
                _bfd_x86_elf_merge_symbol_attribute
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        libc::c_uint,
                        bool,
                        bool,
                    ) -> (),
            ),
            elf_backend_get_target_dtag: None,
            elf_backend_ignore_undef_symbol: None,
            elf_backend_emit_relocs: Some(
                _bfd_elf_link_output_relocs
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut Elf_Internal_Shdr,
                        *mut Elf_Internal_Rela,
                        *mut *mut elf_link_hash_entry,
                    ) -> bool,
            ),
            elf_backend_update_relocs: None,
            elf_backend_count_relocs: None,
            elf_backend_count_additional_relocs: None,
            sort_relocs_p: None,
            elf_backend_grok_prstatus: Some(
                elf_i386_grok_prstatus
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_psinfo: Some(
                elf_i386_grok_psinfo
                    as unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
            ),
            elf_backend_grok_freebsd_prstatus: None,
            elf_backend_write_core_note: None,
            elf_backend_lookup_section_flags_hook: None,
            elf_backend_reloc_type_class: Some(
                elf_i386_reloc_type_class
                    as unsafe extern "C" fn(
                        *const bfd_link_info,
                        *const asection,
                        *const Elf_Internal_Rela,
                    ) -> elf_reloc_type_class,
            ),
            elf_backend_discard_info: None,
            elf_backend_ignore_discarded_relocs: None,
            action_discarded: Some(
                _bfd_elf_default_action_discarded
                    as unsafe extern "C" fn(*mut bfd_section) -> libc::c_uint,
            ),
            elf_backend_eh_frame_address_size: Some(
                _bfd_elf_eh_frame_address_size
                    as unsafe extern "C" fn(*mut bfd, *const asection) -> libc::c_uint,
            ),
            elf_backend_can_make_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_can_make_lsda_relative_eh_frame: Some(
                _bfd_elf_can_make_relative
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                    ) -> bool,
            ),
            elf_backend_encode_eh_address: Some(
                _bfd_elf_encode_eh_address
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut asection,
                        bfd_vma,
                        *mut asection,
                        bfd_vma,
                        *mut bfd_vma,
                    ) -> bfd_byte,
            ),
            elf_backend_write_section: None,
            elf_backend_elfsym_local_is_section: None,
            elf_backend_mips_irix_compat: None,
            elf_backend_mips_rtype_to_howto: None,
            elf_backend_ecoff_debug_swap: 0 as *const ecoff_debug_swap,
            elf_backend_bfd_from_remote_memory: Some(
                _bfd_elf32_bfd_from_remote_memory
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_vma,
                        bfd_size_type,
                        *mut bfd_vma,
                        Option::<
                            unsafe extern "C" fn(
                                bfd_vma,
                                *mut bfd_byte,
                                bfd_size_type,
                            ) -> libc::c_int,
                        >,
                    ) -> *mut bfd,
            ),
            elf_backend_core_find_build_id: Some(
                _bfd_elf32_core_find_build_id
                    as unsafe extern "C" fn(*mut bfd, bfd_vma) -> bool,
            ),
            plt_sym_val: None,
            common_definition: Some(
                _bfd_elf_common_definition
                    as unsafe extern "C" fn(*mut Elf_Internal_Sym) -> bool,
            ),
            common_section_index: Some(
                _bfd_elf_common_section_index
                    as unsafe extern "C" fn(*mut asection) -> libc::c_uint,
            ),
            common_section: Some(
                _bfd_elf_common_section
                    as unsafe extern "C" fn(*mut asection) -> *mut asection,
            ),
            merge_symbol: None,
            elf_hash_symbol: Some(
                _bfd_x86_elf_hash_symbol
                    as unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
            ),
            record_xhash_symbol: None,
            is_function_type: Some(
                _bfd_elf_is_function_type as unsafe extern "C" fn(libc::c_uint) -> bool,
            ),
            maybe_function_sym: Some(
                _bfd_elf_maybe_function_sym
                    as unsafe extern "C" fn(
                        *const asymbol,
                        *mut asection,
                        *mut bfd_vma,
                    ) -> bfd_size_type,
            ),
            get_reloc_section: Some(
                _bfd_elf_plt_get_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *mut asection,
            ),
            elf_backend_copy_special_section_fields: Some(
                _bfd_elf_copy_special_section_fields
                    as unsafe extern "C" fn(
                        *const bfd,
                        *mut bfd,
                        *const Elf_Internal_Shdr,
                        *mut Elf_Internal_Shdr,
                    ) -> bool,
            ),
            link_order_error_handler: Some(
                _bfd_error_handler
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
            ),
            relplt_name: 0 as *const libc::c_char,
            elf_machine_alt1: 0 as libc::c_int,
            elf_machine_alt2: 0 as libc::c_int,
            s: &_bfd_elf32_size_info,
            special_sections: 0 as *const bfd_elf_special_section,
            got_header_size: 12 as libc::c_int as bfd_vma,
            got_elt_size: Some(
                _bfd_elf_default_got_elt_size
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut elf_link_hash_entry,
                        *mut bfd,
                        libc::c_ulong,
                    ) -> bfd_vma,
            ),
            obj_attrs_vendor: 0 as *const libc::c_char,
            obj_attrs_section: 0 as *const libc::c_char,
            obj_attrs_arg_type: None,
            obj_attrs_section_type: 0x6ffffff5 as libc::c_int as libc::c_uint,
            obj_attrs_order: None,
            obj_attrs_handle_unknown: None,
            parse_gnu_properties: Some(
                _bfd_x86_elf_parse_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut bfd_byte,
                        libc::c_uint,
                    ) -> elf_property_kind,
            ),
            merge_gnu_properties: Some(
                _bfd_x86_elf_merge_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut bfd,
                        *mut bfd,
                        *mut elf_property,
                        *mut elf_property,
                    ) -> bool,
            ),
            setup_gnu_properties: Some(
                elf_i386_link_setup_gnu_properties
                    as unsafe extern "C" fn(*mut bfd_link_info) -> *mut bfd,
            ),
            fixup_gnu_properties: Some(
                _bfd_x86_elf_link_fixup_gnu_properties
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut *mut elf_property_list,
                    ) -> (),
            ),
            compact_eh_encoding: None,
            cant_unwind_opcode: None,
            symbol_section_index: None,
            init_secondary_reloc_section: Some(
                _bfd_elf_init_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut Elf_Internal_Shdr,
                        *const libc::c_char,
                        libc::c_uint,
                    ) -> bool,
            ),
            slurp_secondary_relocs: Some(
                _bfd_elf_slurp_secondary_reloc_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut *mut asymbol,
                        bool,
                    ) -> bool,
            ),
            write_secondary_relocs: Some(
                _bfd_elf_write_secondary_reloc_section
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            static_tls_alignment: 1 as libc::c_int as libc::c_uint,
            stack_align: 16 as libc::c_int as libc::c_uint,
            elf_strtab_flags: 0 as libc::c_int as libc::c_ulong,
        };
        init.set_collect(0 as libc::c_int as libc::c_uint);
        init.set_type_change_ok(0 as libc::c_int as libc::c_uint);
        init.set_may_use_rel_p(1 as libc::c_int as libc::c_uint);
        init.set_may_use_rela_p((1 as libc::c_int == 0) as libc::c_int as libc::c_uint);
        init.set_default_use_rela_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_plts_and_copies_p(
            (1 as libc::c_int == 0) as libc::c_int as libc::c_uint,
        );
        init.set_rela_normal(0 as libc::c_int as libc::c_uint);
        init.set_dtrel_excludes_plt(1 as libc::c_int as libc::c_uint);
        init.set_sign_extend_vma(0 as libc::c_int as libc::c_uint);
        init.set_want_got_plt(1 as libc::c_int as libc::c_uint);
        init.set_plt_readonly(1 as libc::c_int as libc::c_uint);
        init.set_want_plt_sym(0 as libc::c_int as libc::c_uint);
        init.set_plt_not_loaded(0 as libc::c_int as libc::c_uint);
        init.set_plt_alignment(4 as libc::c_int as libc::c_uint);
        init.set_can_gc_sections(1 as libc::c_int as libc::c_uint);
        init.set_can_refcount(1 as libc::c_int as libc::c_uint);
        init.set_want_got_sym(1 as libc::c_int as libc::c_uint);
        init.set_want_dynbss(1 as libc::c_int as libc::c_uint);
        init.set_want_dynrelro(1 as libc::c_int as libc::c_uint);
        init.set_want_p_paddr_set_to_zero(0 as libc::c_int as libc::c_uint);
        init.set_no_page_alias(0 as libc::c_int as libc::c_uint);
        init.set_default_execstack(1 as libc::c_int as libc::c_uint);
        init.set_caches_rawsize(1 as libc::c_int as libc::c_uint);
        init.set_extern_protected_data(1 as libc::c_int as libc::c_uint);
        init.set_always_renumber_dynsyms(0 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo32_ugid16(1 as libc::c_int as libc::c_uint);
        init.set_linux_prpsinfo64_ugid16(0 as libc::c_int as libc::c_uint);
        init
    };
    iamcu_elf32_vec = {
        let mut init = bfd_target {
            name: b"elf32-iamcu\0" as *const u8 as *const libc::c_char,
            flavour: bfd_target_elf_flavour,
            byteorder: BFD_ENDIAN_LITTLE,
            header_byteorder: BFD_ENDIAN_LITTLE,
            object_flags: (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int
                | 0x8 as libc::c_int | 0x10 as libc::c_int | 0x20 as libc::c_int
                | 0x40 as libc::c_int | 0x80 as libc::c_int | 0x100 as libc::c_int
                | 0x4000 as libc::c_int | 0x8000 as libc::c_int | 0x20000 as libc::c_int
                | 0x40000 as libc::c_int | 0x80000 as libc::c_int) as flagword,
            section_flags: (0x100 as libc::c_int | 0x1 as libc::c_int
                | 0x2 as libc::c_int | 0x4 as libc::c_int | 0x8 as libc::c_int
                | 0x10 as libc::c_int | 0x20 as libc::c_int | 0x2000 as libc::c_int
                | 0x8000 as libc::c_int | 0x10000 as libc::c_int
                | 0x400000 as libc::c_int | 0x800000 as libc::c_int
                | 0x1000000 as libc::c_int | 0x2000000 as libc::c_int) as flagword,
            symbol_leading_char: 0 as libc::c_int as libc::c_char,
            ar_pad_char: '/' as i32 as libc::c_char,
            ar_max_namelen: 15 as libc::c_int as libc::c_uchar,
            match_priority: (if bfd_arch_iamcu as libc::c_int
                == bfd_arch_unknown as libc::c_int
            {
                2 as libc::c_int
            } else if 0 as libc::c_int == 0 as libc::c_int {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uchar,
            keep_unused_section_symbols: 0 as libc::c_int != 0,
            bfd_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_h_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_h_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_h_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            _bfd_check_format: [
                Some(_bfd_dummy_target as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup),
                Some(
                    bfd_elf32_object_p as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_generic_archive_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_elf32_core_file_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
            ],
            _bfd_set_format: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(_bfd_x86_elf_mkobject as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(_bfd_generic_mkarchive as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(bfd_elf_mkcorefile as unsafe extern "C" fn(*mut bfd) -> bool),
            ],
            _bfd_write_contents: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_object_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_write_archive_contents as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_corefile_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
            ],
            _close_and_cleanup: Some(
                _bfd_elf_close_and_cleanup as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_free_cached_info: Some(
                _bfd_free_cached_info as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _new_section_hook: Some(
                _bfd_elf_new_section_hook
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _bfd_get_section_contents: Some(
                _bfd_generic_get_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_get_section_contents_in_window: Some(
                _bfd_generic_get_section_contents_in_window
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_window,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_copy_private_bfd_data: Some(
                _bfd_elf_copy_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_merge_private_bfd_data: Some(
                _bfd_bool_bfd_link_true
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_init_private_section_data: Some(
                _bfd_elf_init_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_copy_private_section_data: Some(
                _bfd_elf_copy_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_copy_private_symbol_data: Some(
                _bfd_elf_copy_private_symbol_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut bfd,
                        *mut asymbol,
                    ) -> bool,
            ),
            _bfd_copy_private_header_data: Some(
                _bfd_elf_copy_private_header_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_set_private_flags: Some(
                _bfd_bool_bfd_uint_true
                    as unsafe extern "C" fn(*mut bfd, libc::c_uint) -> bool,
            ),
            _bfd_print_private_bfd_data: Some(
                _bfd_elf_print_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
            ),
            _core_file_failing_command: Some(
                bfd_elf32_core_file_failing_command
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
            ),
            _core_file_failing_signal: Some(
                bfd_elf32_core_file_failing_signal
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _core_file_matches_executable_p: Some(
                bfd_elf32_core_file_matches_executable_p
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _core_file_pid: Some(
                bfd_elf32_core_file_pid as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _bfd_slurp_armap: Some(
                bfd_slurp_armap as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_slurp_extended_name_table: Some(
                _bfd_slurp_extended_name_table as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_construct_extended_name_table: Some(
                _bfd_archive_coff_construct_extended_name_table
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut libc::c_char,
                        *mut bfd_size_type,
                        *mut *const libc::c_char,
                    ) -> bool,
            ),
            _bfd_truncate_arname: Some(
                bfd_dont_truncate_arname
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                        *mut libc::c_char,
                    ) -> (),
            ),
            write_armap: Some(
                _bfd_coff_write_armap
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut orl,
                        libc::c_uint,
                        libc::c_int,
                    ) -> bool,
            ),
            _bfd_read_ar_hdr_fn: Some(
                _bfd_generic_read_ar_hdr
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
            ),
            _bfd_write_ar_hdr_fn: Some(
                _bfd_generic_write_ar_hdr
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            openr_next_archived_file: Some(
                bfd_generic_openr_next_archived_file
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
            ),
            _bfd_get_elt_at_index: Some(
                _bfd_generic_get_elt_at_index
                    as unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
            ),
            _bfd_stat_arch_elt: Some(
                bfd_generic_stat_arch_elt
                    as unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
            ),
            _bfd_update_armap_timestamp: Some(
                _bfd_bool_bfd_true as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_get_symtab_upper_bound: Some(
                _bfd_elf_get_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_symtab: Some(
                _bfd_elf_canonicalize_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_make_empty_symbol: Some(
                _bfd_elf_make_empty_symbol
                    as unsafe extern "C" fn(*mut bfd) -> *mut asymbol,
            ),
            _bfd_print_symbol: Some(
                bfd_elf_print_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        *mut asymbol,
                        bfd_print_symbol_type,
                    ) -> (),
            ),
            _bfd_get_symbol_info: Some(
                _bfd_elf_get_symbol_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut symbol_info,
                    ) -> (),
            ),
            _bfd_get_symbol_version_string: Some(
                _bfd_elf_get_symbol_version_string
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        bool,
                        *mut bool,
                    ) -> *const libc::c_char,
            ),
            _bfd_is_local_label_name: Some(
                elf_i386_is_local_label_name
                    as unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
            ),
            _bfd_is_target_special_symbol: Some(
                _bfd_bool_bfd_asymbol_false
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
            ),
            _get_lineno: Some(
                _bfd_elf_get_lineno
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> *mut alent,
            ),
            _bfd_find_nearest_line: Some(
                _bfd_elf_find_nearest_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asection,
                        bfd_vma,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_line: Some(
                _bfd_elf_find_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asymbol,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_inliner_info: Some(
                _bfd_elf_find_inliner_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_make_debug_symbol: Some(
                _bfd_nosymbols_bfd_make_debug_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        libc::c_ulong,
                    ) -> *mut asymbol,
            ),
            _read_minisymbols: Some(
                _bfd_generic_read_minisymbols
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *mut *mut libc::c_void,
                        *mut libc::c_uint,
                    ) -> libc::c_long,
            ),
            _minisymbol_to_symbol: Some(
                _bfd_generic_minisymbol_to_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *const libc::c_void,
                        *mut asymbol,
                    ) -> *mut asymbol,
            ),
            _get_reloc_upper_bound: Some(
                _bfd_elf_get_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
            ),
            _bfd_canonicalize_reloc: Some(
                _bfd_elf_canonicalize_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_set_reloc: Some(
                _bfd_generic_set_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        libc::c_uint,
                    ) -> (),
            ),
            reloc_type_lookup: Some(
                elf_i386_reloc_type_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_reloc_code_real_type,
                    ) -> *const reloc_howto_type,
            ),
            reloc_name_lookup: Some(
                elf_i386_reloc_name_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *const reloc_howto_type,
            ),
            _bfd_set_arch_mach: Some(
                _bfd_elf_set_arch_mach
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_architecture,
                        libc::c_ulong,
                    ) -> bool,
            ),
            _bfd_set_section_contents: Some(
                _bfd_elf_set_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *const libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_sizeof_headers: Some(
                _bfd_elf_sizeof_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
            ),
            _bfd_get_relocated_section_contents: Some(
                bfd_generic_get_relocated_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_order,
                        *mut bfd_byte,
                        bool,
                        *mut *mut asymbol,
                    ) -> *mut bfd_byte,
            ),
            _bfd_relax_section: Some(
                bfd_generic_relax_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                        *mut bool,
                    ) -> bool,
            ),
            _bfd_link_hash_table_create: Some(
                _bfd_x86_elf_link_hash_table_create
                    as unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
            ),
            _bfd_link_add_symbols: Some(
                bfd_elf_link_add_symbols
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_just_syms: Some(
                _bfd_generic_link_just_syms
                    as unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
            ),
            _bfd_copy_link_hash_symbol_type: Some(
                _bfd_elf_copy_link_hash_symbol_type
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_hash_entry,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_final_link: Some(
                bfd_elf_final_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_split_section: Some(
                _bfd_generic_link_split_section
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
            ),
            _bfd_link_check_relocs: Some(
                _bfd_x86_elf_link_check_relocs
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_gc_sections: Some(
                bfd_elf_gc_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_lookup_section_flags: Some(
                bfd_elf_lookup_section_flags
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut flag_info,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_merge_sections: Some(
                _bfd_elf_merge_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_is_group_section: Some(
                bfd_elf_is_group_section
                    as unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
            ),
            _bfd_group_name: Some(
                bfd_elf_group_name
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const bfd_section,
                    ) -> *const libc::c_char,
            ),
            _bfd_discard_group: Some(
                bfd_generic_discard_group
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _section_already_linked: Some(
                _bfd_elf_section_already_linked
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_define_common_symbol: Some(
                bfd_generic_define_common_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> bool,
            ),
            _bfd_link_hide_symbol: Some(
                _bfd_elf_link_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_define_start_stop: Some(
                bfd_elf_define_start_stop
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *const libc::c_char,
                        *mut asection,
                    ) -> *mut bfd_link_hash_entry,
            ),
            _bfd_get_dynamic_symtab_upper_bound: Some(
                _bfd_elf_get_dynamic_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_symtab: Some(
                _bfd_elf_canonicalize_dynamic_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_get_synthetic_symtab: Some(
                elf_i386_get_synthetic_symtab
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_long,
                        *mut *mut asymbol,
                        libc::c_long,
                        *mut *mut asymbol,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_get_dynamic_reloc_upper_bound: Some(
                _bfd_elf_get_dynamic_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_reloc: Some(
                _bfd_elf_canonicalize_dynamic_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            alternative_target: 0 as *const bfd_target,
            backend_data: &elf32_iamcu_bed as *const elf_backend_data
                as *const libc::c_void,
        };
        init
    };
    i386_elf32_sol2_vec = {
        let mut init = bfd_target {
            name: b"elf32-i386-sol2\0" as *const u8 as *const libc::c_char,
            flavour: bfd_target_elf_flavour,
            byteorder: BFD_ENDIAN_LITTLE,
            header_byteorder: BFD_ENDIAN_LITTLE,
            object_flags: (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int
                | 0x8 as libc::c_int | 0x10 as libc::c_int | 0x20 as libc::c_int
                | 0x40 as libc::c_int | 0x80 as libc::c_int | 0x100 as libc::c_int
                | 0x4000 as libc::c_int | 0x8000 as libc::c_int | 0x20000 as libc::c_int
                | 0x40000 as libc::c_int | 0x80000 as libc::c_int) as flagword,
            section_flags: (0x100 as libc::c_int | 0x1 as libc::c_int
                | 0x2 as libc::c_int | 0x4 as libc::c_int | 0x8 as libc::c_int
                | 0x10 as libc::c_int | 0x20 as libc::c_int | 0x2000 as libc::c_int
                | 0x8000 as libc::c_int | 0x10000 as libc::c_int
                | 0x400000 as libc::c_int | 0x800000 as libc::c_int
                | 0x1000000 as libc::c_int | 0x2000000 as libc::c_int) as flagword,
            symbol_leading_char: 0 as libc::c_int as libc::c_char,
            ar_pad_char: '/' as i32 as libc::c_char,
            ar_max_namelen: 15 as libc::c_int as libc::c_uchar,
            match_priority: (if bfd_arch_i386 as libc::c_int
                == bfd_arch_unknown as libc::c_int
            {
                2 as libc::c_int
            } else if 0 as libc::c_int == 0 as libc::c_int {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uchar,
            keep_unused_section_symbols: 0 as libc::c_int != 0,
            bfd_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_h_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_h_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_h_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            _bfd_check_format: [
                Some(_bfd_dummy_target as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup),
                Some(
                    bfd_elf32_object_p as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_generic_archive_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_elf32_core_file_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
            ],
            _bfd_set_format: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(_bfd_x86_elf_mkobject as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(_bfd_generic_mkarchive as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(bfd_elf_mkcorefile as unsafe extern "C" fn(*mut bfd) -> bool),
            ],
            _bfd_write_contents: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_object_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_write_archive_contents as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_corefile_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
            ],
            _close_and_cleanup: Some(
                _bfd_elf_close_and_cleanup as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_free_cached_info: Some(
                _bfd_free_cached_info as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _new_section_hook: Some(
                _bfd_elf_new_section_hook
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _bfd_get_section_contents: Some(
                _bfd_generic_get_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_get_section_contents_in_window: Some(
                _bfd_generic_get_section_contents_in_window
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_window,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_copy_private_bfd_data: Some(
                _bfd_elf_copy_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_merge_private_bfd_data: Some(
                _bfd_bool_bfd_link_true
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_init_private_section_data: Some(
                _bfd_elf_init_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_copy_private_section_data: Some(
                _bfd_elf_copy_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_copy_private_symbol_data: Some(
                _bfd_elf_copy_private_symbol_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut bfd,
                        *mut asymbol,
                    ) -> bool,
            ),
            _bfd_copy_private_header_data: Some(
                _bfd_elf_copy_private_header_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_set_private_flags: Some(
                _bfd_bool_bfd_uint_true
                    as unsafe extern "C" fn(*mut bfd, libc::c_uint) -> bool,
            ),
            _bfd_print_private_bfd_data: Some(
                _bfd_elf_print_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
            ),
            _core_file_failing_command: Some(
                bfd_elf32_core_file_failing_command
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
            ),
            _core_file_failing_signal: Some(
                bfd_elf32_core_file_failing_signal
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _core_file_matches_executable_p: Some(
                bfd_elf32_core_file_matches_executable_p
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _core_file_pid: Some(
                bfd_elf32_core_file_pid as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _bfd_slurp_armap: Some(
                bfd_slurp_armap as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_slurp_extended_name_table: Some(
                _bfd_slurp_extended_name_table as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_construct_extended_name_table: Some(
                _bfd_archive_coff_construct_extended_name_table
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut libc::c_char,
                        *mut bfd_size_type,
                        *mut *const libc::c_char,
                    ) -> bool,
            ),
            _bfd_truncate_arname: Some(
                bfd_dont_truncate_arname
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                        *mut libc::c_char,
                    ) -> (),
            ),
            write_armap: Some(
                _bfd_coff_write_armap
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut orl,
                        libc::c_uint,
                        libc::c_int,
                    ) -> bool,
            ),
            _bfd_read_ar_hdr_fn: Some(
                _bfd_generic_read_ar_hdr
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
            ),
            _bfd_write_ar_hdr_fn: Some(
                _bfd_generic_write_ar_hdr
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            openr_next_archived_file: Some(
                bfd_generic_openr_next_archived_file
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
            ),
            _bfd_get_elt_at_index: Some(
                _bfd_generic_get_elt_at_index
                    as unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
            ),
            _bfd_stat_arch_elt: Some(
                bfd_generic_stat_arch_elt
                    as unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
            ),
            _bfd_update_armap_timestamp: Some(
                _bfd_bool_bfd_true as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_get_symtab_upper_bound: Some(
                _bfd_elf_get_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_symtab: Some(
                _bfd_elf_canonicalize_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_make_empty_symbol: Some(
                _bfd_elf_make_empty_symbol
                    as unsafe extern "C" fn(*mut bfd) -> *mut asymbol,
            ),
            _bfd_print_symbol: Some(
                bfd_elf_print_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        *mut asymbol,
                        bfd_print_symbol_type,
                    ) -> (),
            ),
            _bfd_get_symbol_info: Some(
                _bfd_elf_get_symbol_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut symbol_info,
                    ) -> (),
            ),
            _bfd_get_symbol_version_string: Some(
                _bfd_elf_get_symbol_version_string
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        bool,
                        *mut bool,
                    ) -> *const libc::c_char,
            ),
            _bfd_is_local_label_name: Some(
                elf_i386_is_local_label_name
                    as unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
            ),
            _bfd_is_target_special_symbol: Some(
                _bfd_bool_bfd_asymbol_false
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
            ),
            _get_lineno: Some(
                _bfd_elf_get_lineno
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> *mut alent,
            ),
            _bfd_find_nearest_line: Some(
                _bfd_elf_find_nearest_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asection,
                        bfd_vma,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_line: Some(
                _bfd_elf_find_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asymbol,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_inliner_info: Some(
                _bfd_elf_find_inliner_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_make_debug_symbol: Some(
                _bfd_nosymbols_bfd_make_debug_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        libc::c_ulong,
                    ) -> *mut asymbol,
            ),
            _read_minisymbols: Some(
                _bfd_generic_read_minisymbols
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *mut *mut libc::c_void,
                        *mut libc::c_uint,
                    ) -> libc::c_long,
            ),
            _minisymbol_to_symbol: Some(
                _bfd_generic_minisymbol_to_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *const libc::c_void,
                        *mut asymbol,
                    ) -> *mut asymbol,
            ),
            _get_reloc_upper_bound: Some(
                _bfd_elf_get_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
            ),
            _bfd_canonicalize_reloc: Some(
                _bfd_elf_canonicalize_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_set_reloc: Some(
                _bfd_generic_set_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        libc::c_uint,
                    ) -> (),
            ),
            reloc_type_lookup: Some(
                elf_i386_reloc_type_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_reloc_code_real_type,
                    ) -> *const reloc_howto_type,
            ),
            reloc_name_lookup: Some(
                elf_i386_reloc_name_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *const reloc_howto_type,
            ),
            _bfd_set_arch_mach: Some(
                _bfd_elf_set_arch_mach
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_architecture,
                        libc::c_ulong,
                    ) -> bool,
            ),
            _bfd_set_section_contents: Some(
                _bfd_elf_set_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *const libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_sizeof_headers: Some(
                _bfd_elf_sizeof_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
            ),
            _bfd_get_relocated_section_contents: Some(
                bfd_generic_get_relocated_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_order,
                        *mut bfd_byte,
                        bool,
                        *mut *mut asymbol,
                    ) -> *mut bfd_byte,
            ),
            _bfd_relax_section: Some(
                bfd_generic_relax_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                        *mut bool,
                    ) -> bool,
            ),
            _bfd_link_hash_table_create: Some(
                _bfd_x86_elf_link_hash_table_create
                    as unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
            ),
            _bfd_link_add_symbols: Some(
                bfd_elf_link_add_symbols
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_just_syms: Some(
                _bfd_generic_link_just_syms
                    as unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
            ),
            _bfd_copy_link_hash_symbol_type: Some(
                _bfd_elf_copy_link_hash_symbol_type
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_hash_entry,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_final_link: Some(
                bfd_elf_final_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_split_section: Some(
                _bfd_generic_link_split_section
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
            ),
            _bfd_link_check_relocs: Some(
                _bfd_x86_elf_link_check_relocs
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_gc_sections: Some(
                bfd_elf_gc_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_lookup_section_flags: Some(
                bfd_elf_lookup_section_flags
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut flag_info,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_merge_sections: Some(
                _bfd_elf_merge_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_is_group_section: Some(
                bfd_elf_is_group_section
                    as unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
            ),
            _bfd_group_name: Some(
                bfd_elf_group_name
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const bfd_section,
                    ) -> *const libc::c_char,
            ),
            _bfd_discard_group: Some(
                bfd_generic_discard_group
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _section_already_linked: Some(
                _bfd_elf_section_already_linked
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_define_common_symbol: Some(
                bfd_generic_define_common_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> bool,
            ),
            _bfd_link_hide_symbol: Some(
                _bfd_elf_link_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_define_start_stop: Some(
                bfd_elf_define_start_stop
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *const libc::c_char,
                        *mut asection,
                    ) -> *mut bfd_link_hash_entry,
            ),
            _bfd_get_dynamic_symtab_upper_bound: Some(
                _bfd_elf_get_dynamic_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_symtab: Some(
                _bfd_elf_canonicalize_dynamic_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_get_synthetic_symtab: Some(
                elf_i386_get_synthetic_symtab
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_long,
                        *mut *mut asymbol,
                        libc::c_long,
                        *mut *mut asymbol,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_get_dynamic_reloc_upper_bound: Some(
                _bfd_elf_get_dynamic_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_reloc: Some(
                _bfd_elf_canonicalize_dynamic_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            alternative_target: 0 as *const bfd_target,
            backend_data: &elf32_i386_sol2_bed as *const elf_backend_data
                as *const libc::c_void,
        };
        init
    };
    i386_elf32_vxworks_vec = {
        let mut init = bfd_target {
            name: b"elf32-i386-vxworks\0" as *const u8 as *const libc::c_char,
            flavour: bfd_target_elf_flavour,
            byteorder: BFD_ENDIAN_LITTLE,
            header_byteorder: BFD_ENDIAN_LITTLE,
            object_flags: (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int
                | 0x8 as libc::c_int | 0x10 as libc::c_int | 0x20 as libc::c_int
                | 0x40 as libc::c_int | 0x80 as libc::c_int | 0x100 as libc::c_int
                | 0x4000 as libc::c_int | 0x8000 as libc::c_int | 0x20000 as libc::c_int
                | 0x40000 as libc::c_int | 0x80000 as libc::c_int) as flagword,
            section_flags: (0x100 as libc::c_int | 0x1 as libc::c_int
                | 0x2 as libc::c_int | 0x4 as libc::c_int | 0x8 as libc::c_int
                | 0x10 as libc::c_int | 0x20 as libc::c_int | 0x2000 as libc::c_int
                | 0x8000 as libc::c_int | 0x10000 as libc::c_int
                | 0x400000 as libc::c_int | 0x800000 as libc::c_int
                | 0x1000000 as libc::c_int | 0x2000000 as libc::c_int) as flagword,
            symbol_leading_char: 0 as libc::c_int as libc::c_char,
            ar_pad_char: '/' as i32 as libc::c_char,
            ar_max_namelen: 15 as libc::c_int as libc::c_uchar,
            match_priority: (if bfd_arch_i386 as libc::c_int
                == bfd_arch_unknown as libc::c_int
            {
                2 as libc::c_int
            } else if 0 as libc::c_int == 0 as libc::c_int {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uchar,
            keep_unused_section_symbols: 0 as libc::c_int != 0,
            bfd_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_h_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_h_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_h_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            _bfd_check_format: [
                Some(_bfd_dummy_target as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup),
                Some(
                    bfd_elf32_object_p as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_generic_archive_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_elf32_core_file_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
            ],
            _bfd_set_format: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(_bfd_x86_elf_mkobject as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(_bfd_generic_mkarchive as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(bfd_elf_mkcorefile as unsafe extern "C" fn(*mut bfd) -> bool),
            ],
            _bfd_write_contents: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_object_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_write_archive_contents as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_corefile_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
            ],
            _close_and_cleanup: Some(
                _bfd_elf_close_and_cleanup as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_free_cached_info: Some(
                _bfd_free_cached_info as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _new_section_hook: Some(
                _bfd_elf_new_section_hook
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _bfd_get_section_contents: Some(
                _bfd_generic_get_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_get_section_contents_in_window: Some(
                _bfd_generic_get_section_contents_in_window
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_window,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_copy_private_bfd_data: Some(
                _bfd_elf_copy_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_merge_private_bfd_data: Some(
                _bfd_bool_bfd_link_true
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_init_private_section_data: Some(
                _bfd_elf_init_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_copy_private_section_data: Some(
                _bfd_elf_copy_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_copy_private_symbol_data: Some(
                _bfd_elf_copy_private_symbol_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut bfd,
                        *mut asymbol,
                    ) -> bool,
            ),
            _bfd_copy_private_header_data: Some(
                _bfd_elf_copy_private_header_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_set_private_flags: Some(
                _bfd_bool_bfd_uint_true
                    as unsafe extern "C" fn(*mut bfd, libc::c_uint) -> bool,
            ),
            _bfd_print_private_bfd_data: Some(
                _bfd_elf_print_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
            ),
            _core_file_failing_command: Some(
                bfd_elf32_core_file_failing_command
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
            ),
            _core_file_failing_signal: Some(
                bfd_elf32_core_file_failing_signal
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _core_file_matches_executable_p: Some(
                bfd_elf32_core_file_matches_executable_p
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _core_file_pid: Some(
                bfd_elf32_core_file_pid as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _bfd_slurp_armap: Some(
                bfd_slurp_armap as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_slurp_extended_name_table: Some(
                _bfd_slurp_extended_name_table as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_construct_extended_name_table: Some(
                _bfd_archive_coff_construct_extended_name_table
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut libc::c_char,
                        *mut bfd_size_type,
                        *mut *const libc::c_char,
                    ) -> bool,
            ),
            _bfd_truncate_arname: Some(
                bfd_dont_truncate_arname
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                        *mut libc::c_char,
                    ) -> (),
            ),
            write_armap: Some(
                _bfd_coff_write_armap
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut orl,
                        libc::c_uint,
                        libc::c_int,
                    ) -> bool,
            ),
            _bfd_read_ar_hdr_fn: Some(
                _bfd_generic_read_ar_hdr
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
            ),
            _bfd_write_ar_hdr_fn: Some(
                _bfd_generic_write_ar_hdr
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            openr_next_archived_file: Some(
                bfd_generic_openr_next_archived_file
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
            ),
            _bfd_get_elt_at_index: Some(
                _bfd_generic_get_elt_at_index
                    as unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
            ),
            _bfd_stat_arch_elt: Some(
                bfd_generic_stat_arch_elt
                    as unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
            ),
            _bfd_update_armap_timestamp: Some(
                _bfd_bool_bfd_true as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_get_symtab_upper_bound: Some(
                _bfd_elf_get_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_symtab: Some(
                _bfd_elf_canonicalize_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_make_empty_symbol: Some(
                _bfd_elf_make_empty_symbol
                    as unsafe extern "C" fn(*mut bfd) -> *mut asymbol,
            ),
            _bfd_print_symbol: Some(
                bfd_elf_print_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        *mut asymbol,
                        bfd_print_symbol_type,
                    ) -> (),
            ),
            _bfd_get_symbol_info: Some(
                _bfd_elf_get_symbol_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut symbol_info,
                    ) -> (),
            ),
            _bfd_get_symbol_version_string: Some(
                _bfd_elf_get_symbol_version_string
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        bool,
                        *mut bool,
                    ) -> *const libc::c_char,
            ),
            _bfd_is_local_label_name: Some(
                elf_i386_is_local_label_name
                    as unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
            ),
            _bfd_is_target_special_symbol: Some(
                _bfd_bool_bfd_asymbol_false
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
            ),
            _get_lineno: Some(
                _bfd_elf_get_lineno
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> *mut alent,
            ),
            _bfd_find_nearest_line: Some(
                _bfd_elf_find_nearest_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asection,
                        bfd_vma,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_line: Some(
                _bfd_elf_find_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asymbol,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_inliner_info: Some(
                _bfd_elf_find_inliner_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_make_debug_symbol: Some(
                _bfd_nosymbols_bfd_make_debug_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        libc::c_ulong,
                    ) -> *mut asymbol,
            ),
            _read_minisymbols: Some(
                _bfd_generic_read_minisymbols
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *mut *mut libc::c_void,
                        *mut libc::c_uint,
                    ) -> libc::c_long,
            ),
            _minisymbol_to_symbol: Some(
                _bfd_generic_minisymbol_to_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *const libc::c_void,
                        *mut asymbol,
                    ) -> *mut asymbol,
            ),
            _get_reloc_upper_bound: Some(
                _bfd_elf_get_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
            ),
            _bfd_canonicalize_reloc: Some(
                _bfd_elf_canonicalize_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_set_reloc: Some(
                _bfd_generic_set_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        libc::c_uint,
                    ) -> (),
            ),
            reloc_type_lookup: Some(
                elf_i386_reloc_type_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_reloc_code_real_type,
                    ) -> *const reloc_howto_type,
            ),
            reloc_name_lookup: Some(
                elf_i386_reloc_name_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *const reloc_howto_type,
            ),
            _bfd_set_arch_mach: Some(
                _bfd_elf_set_arch_mach
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_architecture,
                        libc::c_ulong,
                    ) -> bool,
            ),
            _bfd_set_section_contents: Some(
                _bfd_elf_set_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *const libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_sizeof_headers: Some(
                _bfd_elf_sizeof_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
            ),
            _bfd_get_relocated_section_contents: Some(
                bfd_generic_get_relocated_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_order,
                        *mut bfd_byte,
                        bool,
                        *mut *mut asymbol,
                    ) -> *mut bfd_byte,
            ),
            _bfd_relax_section: Some(
                bfd_generic_relax_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                        *mut bool,
                    ) -> bool,
            ),
            _bfd_link_hash_table_create: Some(
                _bfd_x86_elf_link_hash_table_create
                    as unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
            ),
            _bfd_link_add_symbols: Some(
                bfd_elf_link_add_symbols
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_just_syms: Some(
                _bfd_generic_link_just_syms
                    as unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
            ),
            _bfd_copy_link_hash_symbol_type: Some(
                _bfd_elf_copy_link_hash_symbol_type
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_hash_entry,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_final_link: Some(
                bfd_elf_final_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_split_section: Some(
                _bfd_generic_link_split_section
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
            ),
            _bfd_link_check_relocs: Some(
                _bfd_x86_elf_link_check_relocs
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_gc_sections: Some(
                bfd_elf_gc_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_lookup_section_flags: Some(
                bfd_elf_lookup_section_flags
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut flag_info,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_merge_sections: Some(
                _bfd_elf_merge_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_is_group_section: Some(
                bfd_elf_is_group_section
                    as unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
            ),
            _bfd_group_name: Some(
                bfd_elf_group_name
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const bfd_section,
                    ) -> *const libc::c_char,
            ),
            _bfd_discard_group: Some(
                bfd_generic_discard_group
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _section_already_linked: Some(
                _bfd_elf_section_already_linked
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_define_common_symbol: Some(
                bfd_generic_define_common_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> bool,
            ),
            _bfd_link_hide_symbol: Some(
                _bfd_elf_link_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_define_start_stop: Some(
                bfd_elf_define_start_stop
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *const libc::c_char,
                        *mut asection,
                    ) -> *mut bfd_link_hash_entry,
            ),
            _bfd_get_dynamic_symtab_upper_bound: Some(
                _bfd_elf_get_dynamic_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_symtab: Some(
                _bfd_elf_canonicalize_dynamic_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_get_synthetic_symtab: Some(
                elf_i386_get_synthetic_symtab
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_long,
                        *mut *mut asymbol,
                        libc::c_long,
                        *mut *mut asymbol,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_get_dynamic_reloc_upper_bound: Some(
                _bfd_elf_get_dynamic_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_reloc: Some(
                _bfd_elf_canonicalize_dynamic_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            alternative_target: 0 as *const bfd_target,
            backend_data: &elf32_i386_vxworks_bed as *const elf_backend_data
                as *const libc::c_void,
        };
        init
    };
    i386_elf32_vec = {
        let mut init = bfd_target {
            name: b"elf32-i386\0" as *const u8 as *const libc::c_char,
            flavour: bfd_target_elf_flavour,
            byteorder: BFD_ENDIAN_LITTLE,
            header_byteorder: BFD_ENDIAN_LITTLE,
            object_flags: (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int
                | 0x8 as libc::c_int | 0x10 as libc::c_int | 0x20 as libc::c_int
                | 0x40 as libc::c_int | 0x80 as libc::c_int | 0x100 as libc::c_int
                | 0x4000 as libc::c_int | 0x8000 as libc::c_int | 0x20000 as libc::c_int
                | 0x40000 as libc::c_int | 0x80000 as libc::c_int) as flagword,
            section_flags: (0x100 as libc::c_int | 0x1 as libc::c_int
                | 0x2 as libc::c_int | 0x4 as libc::c_int | 0x8 as libc::c_int
                | 0x10 as libc::c_int | 0x20 as libc::c_int | 0x2000 as libc::c_int
                | 0x8000 as libc::c_int | 0x10000 as libc::c_int
                | 0x400000 as libc::c_int | 0x800000 as libc::c_int
                | 0x1000000 as libc::c_int | 0x2000000 as libc::c_int) as flagword,
            symbol_leading_char: 0 as libc::c_int as libc::c_char,
            ar_pad_char: '/' as i32 as libc::c_char,
            ar_max_namelen: 15 as libc::c_int as libc::c_uchar,
            match_priority: (if bfd_arch_i386 as libc::c_int
                == bfd_arch_unknown as libc::c_int
            {
                2 as libc::c_int
            } else if 0 as libc::c_int == 0 as libc::c_int {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uchar,
            keep_unused_section_symbols: 0 as libc::c_int != 0,
            bfd_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_h_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_h_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_h_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            _bfd_check_format: [
                Some(_bfd_dummy_target as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup),
                Some(
                    bfd_elf32_object_p as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_generic_archive_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_elf32_core_file_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
            ],
            _bfd_set_format: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(_bfd_x86_elf_mkobject as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(_bfd_generic_mkarchive as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(bfd_elf_mkcorefile as unsafe extern "C" fn(*mut bfd) -> bool),
            ],
            _bfd_write_contents: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_object_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_write_archive_contents as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_corefile_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
            ],
            _close_and_cleanup: Some(
                _bfd_elf_close_and_cleanup as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_free_cached_info: Some(
                _bfd_free_cached_info as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _new_section_hook: Some(
                _bfd_elf_new_section_hook
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _bfd_get_section_contents: Some(
                _bfd_generic_get_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_get_section_contents_in_window: Some(
                _bfd_generic_get_section_contents_in_window
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_window,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_copy_private_bfd_data: Some(
                _bfd_elf_copy_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_merge_private_bfd_data: Some(
                _bfd_bool_bfd_link_true
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_init_private_section_data: Some(
                _bfd_elf_init_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_copy_private_section_data: Some(
                _bfd_elf_copy_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_copy_private_symbol_data: Some(
                _bfd_elf_copy_private_symbol_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut bfd,
                        *mut asymbol,
                    ) -> bool,
            ),
            _bfd_copy_private_header_data: Some(
                _bfd_elf_copy_private_header_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_set_private_flags: Some(
                _bfd_bool_bfd_uint_true
                    as unsafe extern "C" fn(*mut bfd, libc::c_uint) -> bool,
            ),
            _bfd_print_private_bfd_data: Some(
                _bfd_elf_print_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
            ),
            _core_file_failing_command: Some(
                bfd_elf32_core_file_failing_command
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
            ),
            _core_file_failing_signal: Some(
                bfd_elf32_core_file_failing_signal
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _core_file_matches_executable_p: Some(
                bfd_elf32_core_file_matches_executable_p
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _core_file_pid: Some(
                bfd_elf32_core_file_pid as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _bfd_slurp_armap: Some(
                bfd_slurp_armap as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_slurp_extended_name_table: Some(
                _bfd_slurp_extended_name_table as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_construct_extended_name_table: Some(
                _bfd_archive_coff_construct_extended_name_table
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut libc::c_char,
                        *mut bfd_size_type,
                        *mut *const libc::c_char,
                    ) -> bool,
            ),
            _bfd_truncate_arname: Some(
                bfd_dont_truncate_arname
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                        *mut libc::c_char,
                    ) -> (),
            ),
            write_armap: Some(
                _bfd_coff_write_armap
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut orl,
                        libc::c_uint,
                        libc::c_int,
                    ) -> bool,
            ),
            _bfd_read_ar_hdr_fn: Some(
                _bfd_generic_read_ar_hdr
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
            ),
            _bfd_write_ar_hdr_fn: Some(
                _bfd_generic_write_ar_hdr
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            openr_next_archived_file: Some(
                bfd_generic_openr_next_archived_file
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
            ),
            _bfd_get_elt_at_index: Some(
                _bfd_generic_get_elt_at_index
                    as unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
            ),
            _bfd_stat_arch_elt: Some(
                bfd_generic_stat_arch_elt
                    as unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
            ),
            _bfd_update_armap_timestamp: Some(
                _bfd_bool_bfd_true as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_get_symtab_upper_bound: Some(
                _bfd_elf_get_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_symtab: Some(
                _bfd_elf_canonicalize_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_make_empty_symbol: Some(
                _bfd_elf_make_empty_symbol
                    as unsafe extern "C" fn(*mut bfd) -> *mut asymbol,
            ),
            _bfd_print_symbol: Some(
                bfd_elf_print_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        *mut asymbol,
                        bfd_print_symbol_type,
                    ) -> (),
            ),
            _bfd_get_symbol_info: Some(
                _bfd_elf_get_symbol_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut symbol_info,
                    ) -> (),
            ),
            _bfd_get_symbol_version_string: Some(
                _bfd_elf_get_symbol_version_string
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        bool,
                        *mut bool,
                    ) -> *const libc::c_char,
            ),
            _bfd_is_local_label_name: Some(
                elf_i386_is_local_label_name
                    as unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
            ),
            _bfd_is_target_special_symbol: Some(
                _bfd_bool_bfd_asymbol_false
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
            ),
            _get_lineno: Some(
                _bfd_elf_get_lineno
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> *mut alent,
            ),
            _bfd_find_nearest_line: Some(
                _bfd_elf_find_nearest_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asection,
                        bfd_vma,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_line: Some(
                _bfd_elf_find_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asymbol,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_inliner_info: Some(
                _bfd_elf_find_inliner_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_make_debug_symbol: Some(
                _bfd_nosymbols_bfd_make_debug_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        libc::c_ulong,
                    ) -> *mut asymbol,
            ),
            _read_minisymbols: Some(
                _bfd_generic_read_minisymbols
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *mut *mut libc::c_void,
                        *mut libc::c_uint,
                    ) -> libc::c_long,
            ),
            _minisymbol_to_symbol: Some(
                _bfd_generic_minisymbol_to_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *const libc::c_void,
                        *mut asymbol,
                    ) -> *mut asymbol,
            ),
            _get_reloc_upper_bound: Some(
                _bfd_elf_get_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
            ),
            _bfd_canonicalize_reloc: Some(
                _bfd_elf_canonicalize_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_set_reloc: Some(
                _bfd_generic_set_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        libc::c_uint,
                    ) -> (),
            ),
            reloc_type_lookup: Some(
                elf_i386_reloc_type_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_reloc_code_real_type,
                    ) -> *const reloc_howto_type,
            ),
            reloc_name_lookup: Some(
                elf_i386_reloc_name_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *const reloc_howto_type,
            ),
            _bfd_set_arch_mach: Some(
                _bfd_elf_set_arch_mach
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_architecture,
                        libc::c_ulong,
                    ) -> bool,
            ),
            _bfd_set_section_contents: Some(
                _bfd_elf_set_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *const libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_sizeof_headers: Some(
                _bfd_elf_sizeof_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
            ),
            _bfd_get_relocated_section_contents: Some(
                bfd_generic_get_relocated_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_order,
                        *mut bfd_byte,
                        bool,
                        *mut *mut asymbol,
                    ) -> *mut bfd_byte,
            ),
            _bfd_relax_section: Some(
                bfd_generic_relax_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                        *mut bool,
                    ) -> bool,
            ),
            _bfd_link_hash_table_create: Some(
                _bfd_x86_elf_link_hash_table_create
                    as unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
            ),
            _bfd_link_add_symbols: Some(
                bfd_elf_link_add_symbols
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_just_syms: Some(
                _bfd_generic_link_just_syms
                    as unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
            ),
            _bfd_copy_link_hash_symbol_type: Some(
                _bfd_elf_copy_link_hash_symbol_type
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_hash_entry,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_final_link: Some(
                bfd_elf_final_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_split_section: Some(
                _bfd_generic_link_split_section
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
            ),
            _bfd_link_check_relocs: Some(
                _bfd_x86_elf_link_check_relocs
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_gc_sections: Some(
                bfd_elf_gc_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_lookup_section_flags: Some(
                bfd_elf_lookup_section_flags
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut flag_info,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_merge_sections: Some(
                _bfd_elf_merge_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_is_group_section: Some(
                bfd_elf_is_group_section
                    as unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
            ),
            _bfd_group_name: Some(
                bfd_elf_group_name
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const bfd_section,
                    ) -> *const libc::c_char,
            ),
            _bfd_discard_group: Some(
                bfd_generic_discard_group
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _section_already_linked: Some(
                _bfd_elf_section_already_linked
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_define_common_symbol: Some(
                bfd_generic_define_common_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> bool,
            ),
            _bfd_link_hide_symbol: Some(
                _bfd_elf_link_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_define_start_stop: Some(
                bfd_elf_define_start_stop
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *const libc::c_char,
                        *mut asection,
                    ) -> *mut bfd_link_hash_entry,
            ),
            _bfd_get_dynamic_symtab_upper_bound: Some(
                _bfd_elf_get_dynamic_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_symtab: Some(
                _bfd_elf_canonicalize_dynamic_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_get_synthetic_symtab: Some(
                elf_i386_get_synthetic_symtab
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_long,
                        *mut *mut asymbol,
                        libc::c_long,
                        *mut *mut asymbol,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_get_dynamic_reloc_upper_bound: Some(
                _bfd_elf_get_dynamic_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_reloc: Some(
                _bfd_elf_canonicalize_dynamic_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            alternative_target: 0 as *const bfd_target,
            backend_data: &elf32_i386_bed as *const elf_backend_data
                as *const libc::c_void,
        };
        init
    };
    i386_elf32_fbsd_vec = {
        let mut init = bfd_target {
            name: b"elf32-i386-freebsd\0" as *const u8 as *const libc::c_char,
            flavour: bfd_target_elf_flavour,
            byteorder: BFD_ENDIAN_LITTLE,
            header_byteorder: BFD_ENDIAN_LITTLE,
            object_flags: (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int
                | 0x8 as libc::c_int | 0x10 as libc::c_int | 0x20 as libc::c_int
                | 0x40 as libc::c_int | 0x80 as libc::c_int | 0x100 as libc::c_int
                | 0x4000 as libc::c_int | 0x8000 as libc::c_int | 0x20000 as libc::c_int
                | 0x40000 as libc::c_int | 0x80000 as libc::c_int) as flagword,
            section_flags: (0x100 as libc::c_int | 0x1 as libc::c_int
                | 0x2 as libc::c_int | 0x4 as libc::c_int | 0x8 as libc::c_int
                | 0x10 as libc::c_int | 0x20 as libc::c_int | 0x2000 as libc::c_int
                | 0x8000 as libc::c_int | 0x10000 as libc::c_int
                | 0x400000 as libc::c_int | 0x800000 as libc::c_int
                | 0x1000000 as libc::c_int | 0x2000000 as libc::c_int) as flagword,
            symbol_leading_char: 0 as libc::c_int as libc::c_char,
            ar_pad_char: '/' as i32 as libc::c_char,
            ar_max_namelen: 15 as libc::c_int as libc::c_uchar,
            match_priority: (if bfd_arch_i386 as libc::c_int
                == bfd_arch_unknown as libc::c_int
            {
                2 as libc::c_int
            } else if 9 as libc::c_int == 0 as libc::c_int {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uchar,
            keep_unused_section_symbols: 0 as libc::c_int != 0,
            bfd_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx64: Some(
                bfd_getl64 as unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
            ),
            bfd_h_getx_signed_64: Some(
                bfd_getl_signed_64
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
            ),
            bfd_h_putx64: Some(
                bfd_putl64 as unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
            ),
            bfd_h_getx32: Some(
                bfd_getl32 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_32: Some(
                bfd_getl_signed_32
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx32: Some(
                bfd_putl32 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            bfd_h_getx16: Some(
                bfd_getl16 as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            ),
            bfd_h_getx_signed_16: Some(
                bfd_getl_signed_16
                    as unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
            ),
            bfd_h_putx16: Some(
                bfd_putl16 as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> (),
            ),
            _bfd_check_format: [
                Some(_bfd_dummy_target as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup),
                Some(
                    bfd_elf32_object_p as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_generic_archive_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
                Some(
                    bfd_elf32_core_file_p
                        as unsafe extern "C" fn(*mut bfd) -> bfd_cleanup,
                ),
            ],
            _bfd_set_format: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(_bfd_x86_elf_mkobject as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(_bfd_generic_mkarchive as unsafe extern "C" fn(*mut bfd) -> bool),
                Some(bfd_elf_mkcorefile as unsafe extern "C" fn(*mut bfd) -> bool),
            ],
            _bfd_write_contents: [
                Some(
                    _bfd_bool_bfd_false_error as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_object_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_write_archive_contents as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
                Some(
                    _bfd_elf_write_corefile_contents
                        as unsafe extern "C" fn(*mut bfd) -> bool,
                ),
            ],
            _close_and_cleanup: Some(
                _bfd_elf_close_and_cleanup as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_free_cached_info: Some(
                _bfd_free_cached_info as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _new_section_hook: Some(
                _bfd_elf_new_section_hook
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _bfd_get_section_contents: Some(
                _bfd_generic_get_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_get_section_contents_in_window: Some(
                _bfd_generic_get_section_contents_in_window
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_window,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_copy_private_bfd_data: Some(
                _bfd_elf_copy_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_merge_private_bfd_data: Some(
                _bfd_bool_bfd_link_true
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_init_private_section_data: Some(
                _bfd_elf_init_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_copy_private_section_data: Some(
                _bfd_elf_copy_private_section_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_copy_private_symbol_data: Some(
                _bfd_elf_copy_private_symbol_data
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut bfd,
                        *mut asymbol,
                    ) -> bool,
            ),
            _bfd_copy_private_header_data: Some(
                _bfd_elf_copy_private_header_data
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _bfd_set_private_flags: Some(
                _bfd_bool_bfd_uint_true
                    as unsafe extern "C" fn(*mut bfd, libc::c_uint) -> bool,
            ),
            _bfd_print_private_bfd_data: Some(
                _bfd_elf_print_private_bfd_data
                    as unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
            ),
            _core_file_failing_command: Some(
                bfd_elf32_core_file_failing_command
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
            ),
            _core_file_failing_signal: Some(
                bfd_elf32_core_file_failing_signal
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _core_file_matches_executable_p: Some(
                bfd_elf32_core_file_matches_executable_p
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            _core_file_pid: Some(
                bfd_elf32_core_file_pid as unsafe extern "C" fn(*mut bfd) -> libc::c_int,
            ),
            _bfd_slurp_armap: Some(
                bfd_slurp_armap as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_slurp_extended_name_table: Some(
                _bfd_slurp_extended_name_table as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_construct_extended_name_table: Some(
                _bfd_archive_coff_construct_extended_name_table
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut libc::c_char,
                        *mut bfd_size_type,
                        *mut *const libc::c_char,
                    ) -> bool,
            ),
            _bfd_truncate_arname: Some(
                bfd_dont_truncate_arname
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                        *mut libc::c_char,
                    ) -> (),
            ),
            write_armap: Some(
                _bfd_coff_write_armap
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_uint,
                        *mut orl,
                        libc::c_uint,
                        libc::c_int,
                    ) -> bool,
            ),
            _bfd_read_ar_hdr_fn: Some(
                _bfd_generic_read_ar_hdr
                    as unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
            ),
            _bfd_write_ar_hdr_fn: Some(
                _bfd_generic_write_ar_hdr
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
            ),
            openr_next_archived_file: Some(
                bfd_generic_openr_next_archived_file
                    as unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
            ),
            _bfd_get_elt_at_index: Some(
                _bfd_generic_get_elt_at_index
                    as unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
            ),
            _bfd_stat_arch_elt: Some(
                bfd_generic_stat_arch_elt
                    as unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
            ),
            _bfd_update_armap_timestamp: Some(
                _bfd_bool_bfd_true as unsafe extern "C" fn(*mut bfd) -> bool,
            ),
            _bfd_get_symtab_upper_bound: Some(
                _bfd_elf_get_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_symtab: Some(
                _bfd_elf_canonicalize_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_make_empty_symbol: Some(
                _bfd_elf_make_empty_symbol
                    as unsafe extern "C" fn(*mut bfd) -> *mut asymbol,
            ),
            _bfd_print_symbol: Some(
                bfd_elf_print_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        *mut asymbol,
                        bfd_print_symbol_type,
                    ) -> (),
            ),
            _bfd_get_symbol_info: Some(
                _bfd_elf_get_symbol_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        *mut symbol_info,
                    ) -> (),
            ),
            _bfd_get_symbol_version_string: Some(
                _bfd_elf_get_symbol_version_string
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asymbol,
                        bool,
                        *mut bool,
                    ) -> *const libc::c_char,
            ),
            _bfd_is_local_label_name: Some(
                elf_i386_is_local_label_name
                    as unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
            ),
            _bfd_is_target_special_symbol: Some(
                _bfd_bool_bfd_asymbol_false
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
            ),
            _get_lineno: Some(
                _bfd_elf_get_lineno
                    as unsafe extern "C" fn(*mut bfd, *mut asymbol) -> *mut alent,
            ),
            _bfd_find_nearest_line: Some(
                _bfd_elf_find_nearest_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asection,
                        bfd_vma,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_line: Some(
                _bfd_elf_find_line
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut asymbol,
                        *mut asymbol,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_find_inliner_info: Some(
                _bfd_elf_find_inliner_info
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *const libc::c_char,
                        *mut *const libc::c_char,
                        *mut libc::c_uint,
                    ) -> bool,
            ),
            _bfd_make_debug_symbol: Some(
                _bfd_nosymbols_bfd_make_debug_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut libc::c_void,
                        libc::c_ulong,
                    ) -> *mut asymbol,
            ),
            _read_minisymbols: Some(
                _bfd_generic_read_minisymbols
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *mut *mut libc::c_void,
                        *mut libc::c_uint,
                    ) -> libc::c_long,
            ),
            _minisymbol_to_symbol: Some(
                _bfd_generic_minisymbol_to_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bool,
                        *const libc::c_void,
                        *mut asymbol,
                    ) -> *mut asymbol,
            ),
            _get_reloc_upper_bound: Some(
                _bfd_elf_get_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
            ),
            _bfd_canonicalize_reloc: Some(
                _bfd_elf_canonicalize_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_set_reloc: Some(
                _bfd_generic_set_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *mut *mut arelent,
                        libc::c_uint,
                    ) -> (),
            ),
            reloc_type_lookup: Some(
                elf_i386_reloc_type_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_reloc_code_real_type,
                    ) -> *const reloc_howto_type,
            ),
            reloc_name_lookup: Some(
                elf_i386_reloc_name_lookup
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const libc::c_char,
                    ) -> *const reloc_howto_type,
            ),
            _bfd_set_arch_mach: Some(
                _bfd_elf_set_arch_mach
                    as unsafe extern "C" fn(
                        *mut bfd,
                        bfd_architecture,
                        libc::c_ulong,
                    ) -> bool,
            ),
            _bfd_set_section_contents: Some(
                _bfd_elf_set_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        sec_ptr,
                        *const libc::c_void,
                        file_ptr,
                        bfd_size_type,
                    ) -> bool,
            ),
            _bfd_sizeof_headers: Some(
                _bfd_elf_sizeof_headers
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
            ),
            _bfd_get_relocated_section_contents: Some(
                bfd_generic_get_relocated_section_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_order,
                        *mut bfd_byte,
                        bool,
                        *mut *mut asymbol,
                    ) -> *mut bfd_byte,
            ),
            _bfd_relax_section: Some(
                bfd_generic_relax_section
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                        *mut bool,
                    ) -> bool,
            ),
            _bfd_link_hash_table_create: Some(
                _bfd_x86_elf_link_hash_table_create
                    as unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
            ),
            _bfd_link_add_symbols: Some(
                bfd_elf_link_add_symbols
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_just_syms: Some(
                _bfd_generic_link_just_syms
                    as unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
            ),
            _bfd_copy_link_hash_symbol_type: Some(
                _bfd_elf_copy_link_hash_symbol_type
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_hash_entry,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_final_link: Some(
                bfd_elf_final_link
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_link_split_section: Some(
                _bfd_generic_link_split_section
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
            ),
            _bfd_link_check_relocs: Some(
                _bfd_x86_elf_link_check_relocs
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_gc_sections: Some(
                bfd_elf_gc_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_lookup_section_flags: Some(
                bfd_elf_lookup_section_flags
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *mut flag_info,
                        *mut asection,
                    ) -> bool,
            ),
            _bfd_merge_sections: Some(
                _bfd_elf_merge_sections
                    as unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
            ),
            _bfd_is_group_section: Some(
                bfd_elf_is_group_section
                    as unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
            ),
            _bfd_group_name: Some(
                bfd_elf_group_name
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *const bfd_section,
                    ) -> *const libc::c_char,
            ),
            _bfd_discard_group: Some(
                bfd_generic_discard_group
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
            ),
            _section_already_linked: Some(
                _bfd_elf_section_already_linked
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut bfd_link_info,
                    ) -> bool,
            ),
            _bfd_define_common_symbol: Some(
                bfd_generic_define_common_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> bool,
            ),
            _bfd_link_hide_symbol: Some(
                _bfd_elf_link_hide_symbol
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut bfd_link_info,
                        *mut bfd_link_hash_entry,
                    ) -> (),
            ),
            _bfd_define_start_stop: Some(
                bfd_elf_define_start_stop
                    as unsafe extern "C" fn(
                        *mut bfd_link_info,
                        *const libc::c_char,
                        *mut asection,
                    ) -> *mut bfd_link_hash_entry,
            ),
            _bfd_get_dynamic_symtab_upper_bound: Some(
                _bfd_elf_get_dynamic_symtab_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_symtab: Some(
                _bfd_elf_canonicalize_dynamic_symtab
                    as unsafe extern "C" fn(*mut bfd, *mut *mut asymbol) -> libc::c_long,
            ),
            _bfd_get_synthetic_symtab: Some(
                elf_i386_get_synthetic_symtab
                    as unsafe extern "C" fn(
                        *mut bfd,
                        libc::c_long,
                        *mut *mut asymbol,
                        libc::c_long,
                        *mut *mut asymbol,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            _bfd_get_dynamic_reloc_upper_bound: Some(
                _bfd_elf_get_dynamic_reloc_upper_bound
                    as unsafe extern "C" fn(*mut bfd) -> libc::c_long,
            ),
            _bfd_canonicalize_dynamic_reloc: Some(
                _bfd_elf_canonicalize_dynamic_reloc
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut *mut arelent,
                        *mut *mut asymbol,
                    ) -> libc::c_long,
            ),
            alternative_target: 0 as *const bfd_target,
            backend_data: &elf32_i386_fbsd_bed as *const elf_backend_data
                as *const libc::c_void,
        };
        init
    };
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
