use ::libc;
use ::c2rust_bitfields;
extern "C" {
    pub type bfd_sym_data_struct;
    pub type bfd_pef_xlib_data_struct;
    pub type bfd_pef_data_struct;
    pub type mach_o_fat_data_struct;
    pub type mach_o_data_struct;
    pub type netbsd_core_struct;
    pub type versados_data_struct;
    pub type cisco_core_struct;
    pub type osf_core_struct;
    pub type lynx_core_struct;
    pub type sgi_core_struct;
    pub type hppabsd_core_struct;
    pub type hpux_core_struct;
    pub type som_data_struct;
    pub type trad_core_struct;
    pub type sco5_core_struct;
    pub type sun_core_struct;
    pub type mmo_data_struct;
    pub type elf_strtab_hash;
    pub type dwarf1_debug;
    pub type got_entry;
    pub type plt_entry;
    pub type tekhex_data_struct;
    pub type ihex_data_struct;
    pub type verilog_data_struct;
    pub type srec_data_struct;
    pub type ecoff_tdata;
    pub type xcoff_tdata;
    pub type pe_tdata;
    pub type coff_tdata;
    pub type aout_data_struct;
    pub type bfd_strtab_hash;
    pub type ecoff_debug_swap;
    pub type cie;
    fn ffs(__i: libc::c_int) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn strtoul(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulong;
    fn free(_: *mut libc::c_void);
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn dcgettext(
        __domainname: *const libc::c_char,
        __msgid: *const libc::c_char,
        __category: libc::c_int,
    ) -> *mut libc::c_char;
    fn bfd_hash_table_init(
        _: *mut bfd_hash_table,
        _: Option::<
            unsafe extern "C" fn(
                *mut bfd_hash_entry,
                *mut bfd_hash_table,
                *const libc::c_char,
            ) -> *mut bfd_hash_entry,
        >,
        _: libc::c_uint,
    ) -> bool;
    fn bfd_hash_table_free(_: *mut bfd_hash_table);
    fn bfd_hash_lookup(
        _: *mut bfd_hash_table,
        _: *const libc::c_char,
        create: bool,
        copy: bool,
    ) -> *mut bfd_hash_entry;
    fn bfd_hash_newfunc(
        _: *mut bfd_hash_entry,
        _: *mut bfd_hash_table,
        _: *const libc::c_char,
    ) -> *mut bfd_hash_entry;
    fn bfd_hash_allocate(_: *mut bfd_hash_table, _: libc::c_uint) -> *mut libc::c_void;
    fn bfd_hash_traverse(
        _: *mut bfd_hash_table,
        _: Option::<
            unsafe extern "C" fn(*mut bfd_hash_entry, *mut libc::c_void) -> bool,
        >,
        info: *mut libc::c_void,
    );
    fn bfd_bread(_: *mut libc::c_void, _: bfd_size_type, _: *mut bfd) -> bfd_size_type;
    fn bfd_bwrite(
        _: *const libc::c_void,
        _: bfd_size_type,
        _: *mut bfd,
    ) -> bfd_size_type;
    fn bfd_seek(_: *mut bfd, _: file_ptr, _: libc::c_int) -> libc::c_int;
    fn bfd_close(abfd: *mut bfd) -> bool;
    fn bfd_alloc(abfd: *mut bfd, wanted: bfd_size_type) -> *mut libc::c_void;
    fn bfd_zalloc(abfd: *mut bfd, wanted: bfd_size_type) -> *mut libc::c_void;
    fn bfd_get_file_size(abfd: *mut bfd) -> ufile_ptr;
    static mut _bfd_std_section: [asection; 4];
    fn bfd_section_list_clear(_: *mut bfd);
    fn bfd_get_section_by_name(
        abfd: *mut bfd,
        name: *const libc::c_char,
    ) -> *mut asection;
    fn bfd_get_next_section_by_name(ibfd: *mut bfd, sec: *mut asection) -> *mut asection;
    fn bfd_get_linker_section(
        abfd: *mut bfd,
        name: *const libc::c_char,
    ) -> *mut asection;
    fn bfd_make_section_anyway_with_flags(
        abfd: *mut bfd,
        name: *const libc::c_char,
        flags: flagword,
    ) -> *mut asection;
    fn bfd_make_section_with_flags(
        _: *mut bfd,
        name: *const libc::c_char,
        flags: flagword,
    ) -> *mut asection;
    fn bfd_map_over_sections(
        abfd: *mut bfd,
        func: Option::<
            unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_void) -> (),
        >,
        obj: *mut libc::c_void,
    );
    fn bfd_set_section_size(sec: *mut asection, val: bfd_size_type) -> bool;
    fn bfd_set_section_contents(
        abfd: *mut bfd,
        section: *mut asection,
        data: *const libc::c_void,
        offset: file_ptr,
        count: bfd_size_type,
    ) -> bool;
    fn bfd_get_section_contents(
        abfd: *mut bfd,
        section: *mut asection,
        location: *mut libc::c_void,
        offset: file_ptr,
        count: bfd_size_type,
    ) -> bool;
    fn bfd_malloc_and_get_section(
        abfd: *mut bfd,
        section: *mut asection,
        buf: *mut *mut bfd_byte,
    ) -> bool;
    fn bfd_get_arch(abfd: *const bfd) -> bfd_architecture;
    fn bfd_get_mach(abfd: *const bfd) -> libc::c_ulong;
    fn bfd_octets_per_byte(abfd: *const bfd, sec: *const asection) -> libc::c_uint;
    fn bfd_get_reloc_size(_: *const reloc_howto_type) -> libc::c_uint;
    fn bfd_check_overflow(
        how: complain_overflow,
        bitsize: libc::c_uint,
        rightshift: libc::c_uint,
        addrsize: libc::c_uint,
        relocation: bfd_vma,
    ) -> bfd_reloc_status_type;
    fn bfd_reloc_type_lookup(
        abfd: *mut bfd,
        code: bfd_reloc_code_real_type,
    ) -> *const reloc_howto_type;
    fn bfd_set_symtab(
        abfd: *mut bfd,
        location: *mut *mut asymbol,
        count: libc::c_uint,
    ) -> bool;
    fn bfd_set_error(error_tag: bfd_error_type);
    fn _bfd_error_handler(fmt: *const libc::c_char, _: ...);
    fn bfd_set_file_flags(abfd: *mut bfd, flags: flagword) -> bool;
    fn bfd_set_start_address(abfd: *mut bfd, vma: bfd_vma) -> bool;
    fn bfd_openr_next_archived_file(archive: *mut bfd, previous: *mut bfd) -> *mut bfd;
    fn bfd_check_format(abfd: *mut bfd, format: bfd_format) -> bool;
    fn bfd_set_format(abfd: *mut bfd, format: bfd_format) -> bool;
    fn bfd_find_version_for_sym(
        verdefs: *mut bfd_elf_version_tree,
        sym_name: *const libc::c_char,
        hide: *mut bool,
    ) -> *mut bfd_elf_version_tree;
    fn bfd_hide_sym_by_version(
        verdefs: *mut bfd_elf_version_tree,
        sym_name: *const libc::c_char,
    ) -> bool;
    fn bfd_get_full_section_contents(
        abfd: *mut bfd,
        section: *mut asection,
        ptr: *mut *mut bfd_byte,
    ) -> bool;
    fn bfd_link_hash_lookup(
        _: *mut bfd_link_hash_table,
        _: *const libc::c_char,
        create: bool,
        copy: bool,
        follow: bool,
    ) -> *mut bfd_link_hash_entry;
    fn bfd_wrapped_link_hash_lookup(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *const libc::c_char,
        _: bool,
        _: bool,
        _: bool,
    ) -> *mut bfd_link_hash_entry;
    fn bfd_link_hash_traverse(
        _: *mut bfd_link_hash_table,
        _: Option::<
            unsafe extern "C" fn(*mut bfd_link_hash_entry, *mut libc::c_void) -> bool,
        >,
        _: *mut libc::c_void,
    );
    fn bfd_link_repair_undef_list(table: *mut bfd_link_hash_table);
    fn _bfd_handle_already_linked(
        _: *mut bfd_section,
        _: *mut bfd_section_already_linked,
        _: *mut bfd_link_info,
    ) -> bool;
    fn _bfd_nearby_section(
        _: *mut bfd,
        _: *mut bfd_section,
        _: bfd_vma,
    ) -> *mut bfd_section;
    fn _bfd_fix_excluded_sec_syms(_: *mut bfd, _: *mut bfd_link_info);
    fn bfd_malloc(_: bfd_size_type) -> *mut libc::c_void;
    fn bfd_release(_: *mut bfd, _: *mut libc::c_void);
    fn _bfd_get_elt_at_filepos(_: *mut bfd, _: file_ptr) -> *mut bfd;
    fn _bfd_link_hash_newfunc(
        entry: *mut bfd_hash_entry,
        table: *mut bfd_hash_table,
        string: *const libc::c_char,
    ) -> *mut bfd_hash_entry;
    fn _bfd_link_hash_table_init(
        _: *mut bfd_link_hash_table,
        _: *mut bfd,
        _: Option::<
            unsafe extern "C" fn(
                *mut bfd_hash_entry,
                *mut bfd_hash_table,
                *const libc::c_char,
            ) -> *mut bfd_hash_entry,
        >,
        _: libc::c_uint,
    ) -> bool;
    fn _bfd_generic_link_hash_table_free(_: *mut bfd);
    fn _bfd_generic_link_add_one_symbol(
        _: *mut bfd_link_info,
        _: *mut bfd,
        name: *const libc::c_char,
        _: flagword,
        _: *mut asection,
        _: bfd_vma,
        _: *const libc::c_char,
        copy: bool,
        constructor: bool,
        _: *mut *mut bfd_link_hash_entry,
    ) -> bool;
    fn _bfd_default_link_order(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
        _: *mut bfd_link_order,
    ) -> bool;
    fn _bfd_relocate_contents(
        _: *const reloc_howto_type,
        _: *mut bfd,
        _: bfd_vma,
        _: *mut bfd_byte,
    ) -> bfd_reloc_status_type;
    fn _bfd_link_section_stabs(
        _: *mut bfd,
        _: *mut stab_info,
        _: *mut asection,
        _: *mut asection,
        _: *mut *mut libc::c_void,
        _: *mut bfd_size_type,
    ) -> bool;
    fn _bfd_discard_section_stabs(
        _: *mut bfd,
        _: *mut asection,
        _: *mut libc::c_void,
        _: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> bool>,
        _: *mut libc::c_void,
    ) -> bool;
    fn _bfd_write_section_stabs(
        _: *mut bfd,
        _: *mut stab_info,
        _: *mut asection,
        _: *mut *mut libc::c_void,
        _: *mut bfd_byte,
    ) -> bool;
    fn _bfd_write_stab_strings(_: *mut bfd, _: *mut stab_info) -> bool;
    fn _bfd_add_merge_section(
        _: *mut bfd,
        _: *mut *mut libc::c_void,
        _: *mut asection,
        _: *mut *mut libc::c_void,
    ) -> bool;
    fn _bfd_merge_sections(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut libc::c_void,
        _: Option::<unsafe extern "C" fn(*mut bfd, *mut asection) -> ()>,
    ) -> bool;
    fn _bfd_write_merged_section(
        _: *mut bfd,
        _: *mut asection,
        _: *mut libc::c_void,
    ) -> bool;
    fn _bfd_merged_section_offset(
        _: *mut bfd,
        _: *mut *mut asection,
        _: *mut libc::c_void,
        _: bfd_vma,
    ) -> bfd_vma;
    fn _bfd_merge_sections_free(_: *mut libc::c_void);
    fn bfd_assert(_: *const libc::c_char, _: libc::c_int);
    fn _bfd_abort(_: *const libc::c_char, _: libc::c_int, _: *const libc::c_char) -> !;
    fn bfd_section_already_linked_table_lookup(
        _: *const libc::c_char,
    ) -> *mut bfd_section_already_linked_hash_entry;
    fn bfd_section_already_linked_table_insert(
        _: *mut bfd_section_already_linked_hash_entry,
        _: *mut asection,
    ) -> bool;
    fn bfd_realloc(MEM: *mut libc::c_void, SIZE: bfd_size_type) -> *mut libc::c_void;
    fn bfd_zmalloc(SIZE: bfd_size_type) -> *mut libc::c_void;
    fn bfd_log2(x: bfd_vma) -> libc::c_uint;
    fn _bfd_elf_swap_verdef_in(
        _: *mut bfd,
        _: *const Elf_External_Verdef,
        _: *mut Elf_Internal_Verdef,
    );
    fn _bfd_elf_swap_verdef_out(
        _: *mut bfd,
        _: *const Elf_Internal_Verdef,
        _: *mut Elf_External_Verdef,
    );
    fn _bfd_elf_swap_verdaux_in(
        _: *mut bfd,
        _: *const Elf_External_Verdaux,
        _: *mut Elf_Internal_Verdaux,
    );
    fn _bfd_elf_swap_verdaux_out(
        _: *mut bfd,
        _: *const Elf_Internal_Verdaux,
        _: *mut Elf_External_Verdaux,
    );
    fn _bfd_elf_swap_verneed_in(
        _: *mut bfd,
        _: *const Elf_External_Verneed,
        _: *mut Elf_Internal_Verneed,
    );
    fn _bfd_elf_swap_verneed_out(
        _: *mut bfd,
        _: *const Elf_Internal_Verneed,
        _: *mut Elf_External_Verneed,
    );
    fn _bfd_elf_swap_vernaux_in(
        _: *mut bfd,
        _: *const Elf_External_Vernaux,
        _: *mut Elf_Internal_Vernaux,
    );
    fn _bfd_elf_swap_vernaux_out(
        _: *mut bfd,
        _: *const Elf_Internal_Vernaux,
        _: *mut Elf_External_Vernaux,
    );
    fn _bfd_elf_swap_versym_in(
        _: *mut bfd,
        _: *const Elf_External_Versym,
        _: *mut Elf_Internal_Versym,
    );
    fn _bfd_elf_swap_versym_out(
        _: *mut bfd,
        _: *const Elf_Internal_Versym,
        _: *mut Elf_External_Versym,
    );
    fn _bfd_elf_section_from_bfd_section(_: *mut bfd, _: *mut asection) -> libc::c_uint;
    fn bfd_elf_string_from_elf_section(
        _: *mut bfd,
        _: libc::c_uint,
        _: libc::c_uint,
    ) -> *mut libc::c_char;
    fn bfd_elf_get_elf_syms(
        _: *mut bfd,
        _: *mut Elf_Internal_Shdr,
        _: size_t,
        _: size_t,
        _: *mut Elf_Internal_Sym,
        _: *mut libc::c_void,
        _: *mut Elf_External_Sym_Shndx,
    ) -> *mut Elf_Internal_Sym;
    fn bfd_elf_sym_name(
        _: *mut bfd,
        _: *mut Elf_Internal_Shdr,
        _: *mut Elf_Internal_Sym,
        _: *mut asection,
    ) -> *const libc::c_char;
    fn _bfd_elf_rel_local_sym(
        _: *mut bfd,
        _: *mut Elf_Internal_Sym,
        _: *mut *mut asection,
        _: bfd_vma,
    ) -> bfd_vma;
    fn _bfd_elf_section_offset(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
        _: bfd_vma,
    ) -> bfd_vma;
    fn bfd_elf_hash(_: *const libc::c_char) -> libc::c_ulong;
    fn bfd_elf_gnu_hash(_: *const libc::c_char) -> libc::c_ulong;
    fn _bfd_elf_slurp_version_tables(_: *mut bfd, _: bool) -> bool;
    fn bfd_elf_set_group_contents(_: *mut bfd, _: *mut asection, _: *mut libc::c_void);
    fn _bfd_elf_filter_global_symbols(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut *mut asymbol,
        _: libc::c_long,
    ) -> libc::c_uint;
    fn _bfd_elf_fixup_group_sections(_: *mut bfd, _: *mut asection) -> bool;
    fn bfd_section_from_elf_index(_: *mut bfd, _: libc::c_uint) -> *mut asection;
    fn _bfd_elf_strtab_init() -> *mut elf_strtab_hash;
    fn _bfd_elf_strtab_free(_: *mut elf_strtab_hash);
    fn _bfd_elf_strtab_add(
        _: *mut elf_strtab_hash,
        _: *const libc::c_char,
        _: bool,
    ) -> size_t;
    fn _bfd_elf_strtab_addref(_: *mut elf_strtab_hash, _: size_t);
    fn _bfd_elf_strtab_delref(_: *mut elf_strtab_hash, _: size_t);
    fn _bfd_elf_strtab_refcount(_: *mut elf_strtab_hash, _: size_t) -> libc::c_uint;
    fn _bfd_elf_strtab_save(_: *mut elf_strtab_hash) -> *mut libc::c_void;
    fn _bfd_elf_strtab_restore(_: *mut elf_strtab_hash, _: *mut libc::c_void);
    fn _bfd_elf_strtab_size(_: *mut elf_strtab_hash) -> bfd_size_type;
    fn _bfd_elf_strtab_offset(_: *mut elf_strtab_hash, _: size_t) -> bfd_size_type;
    fn _bfd_elf_strtab_emit(_: *mut bfd, _: *mut elf_strtab_hash) -> bool;
    fn _bfd_elf_strtab_finalize(_: *mut elf_strtab_hash);
    fn _bfd_elf_parse_eh_frame_entry(
        _: *mut bfd_link_info,
        _: *mut asection,
        _: *mut elf_reloc_cookie,
    ) -> bool;
    fn _bfd_elf_parse_eh_frame(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
        _: *mut elf_reloc_cookie,
    );
    fn _bfd_elf_end_eh_frame_parsing(info: *mut bfd_link_info) -> bool;
    fn _bfd_elf_discard_section_eh_frame(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
        _: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> bool>,
        _: *mut elf_reloc_cookie,
    ) -> bool;
    fn _bfd_elf_adjust_eh_frame_global_symbol(
        _: *mut elf_link_hash_entry,
        _: *mut libc::c_void,
    ) -> bool;
    fn _bfd_elf_discard_section_eh_frame_hdr(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_elf_write_section_eh_frame(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
        _: *mut bfd_byte,
    ) -> bool;
    fn _bfd_elf_write_section_eh_frame_entry(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
        _: *mut bfd_byte,
    ) -> bool;
    fn _bfd_elf_fixup_eh_frame_hdr(_: *mut bfd_link_info) -> bool;
    fn _bfd_elf_write_section_eh_frame_hdr(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn _bfd_elf_maybe_strip_eh_frame_hdr(_: *mut bfd_link_info) -> bool;
    fn _bfd_elf_compute_section_file_positions(
        _: *mut bfd,
        _: *mut bfd_link_info,
    ) -> bool;
    fn _bfd_elf_assign_file_position_for_section(
        _: *mut Elf_Internal_Shdr,
        _: file_ptr,
        _: bool,
    ) -> file_ptr;
    fn _bfd_elf_map_sections_to_segments(_: *mut bfd, _: *mut bfd_link_info) -> bool;
    fn bfd_elf_set_obj_attr_contents(_: *mut bfd, _: *mut bfd_byte, _: bfd_vma);
    fn bfd_elf_obj_attr_size(_: *mut bfd) -> bfd_vma;
    fn _bfd_elf_gc_mark_fdes(
        _: *mut bfd_link_info,
        _: *mut asection,
        _: *mut asection,
        _: elf_gc_mark_hook_fn,
        _: *mut elf_reloc_cookie,
    ) -> bool;
    static _sch_istable: [libc::c_ushort; 256];
    fn lbasename(_: *const libc::c_char) -> *const libc::c_char;
    fn objalloc_free_block(_: *mut objalloc, _: *mut libc::c_void);
    fn bfd_link_plugin_object_p(_: *mut bfd) -> bool;
}
pub type size_t = libc::c_ulong;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __compar_fn_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type hashval_t = libc::c_uint;
pub type htab_hash = Option::<unsafe extern "C" fn(*const libc::c_void) -> hashval_t>;
pub type htab_eq = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
pub type htab_del = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type htab_alloc = Option::<
    unsafe extern "C" fn(size_t, size_t) -> *mut libc::c_void,
>;
pub type htab_free = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type htab_alloc_with_arg = Option::<
    unsafe extern "C" fn(*mut libc::c_void, size_t, size_t) -> *mut libc::c_void,
>;
pub type htab_free_with_arg = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct htab {
    pub hash_f: htab_hash,
    pub eq_f: htab_eq,
    pub del_f: htab_del,
    pub entries: *mut *mut libc::c_void,
    pub size: size_t,
    pub n_elements: size_t,
    pub n_deleted: size_t,
    pub searches: libc::c_uint,
    pub collisions: libc::c_uint,
    pub alloc_f: htab_alloc,
    pub free_f: htab_free,
    pub alloc_arg: *mut libc::c_void,
    pub alloc_with_arg_f: htab_alloc_with_arg,
    pub free_with_arg_f: htab_free_with_arg,
    pub size_prime_index: libc::c_uint,
}
pub type htab_t = *mut htab;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type bfd_int64_t = libc::c_long;
pub type bfd_uint64_t = libc::c_ulong;
pub type bfd_hostptr_t = libc::c_ulong;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd {
    pub filename: *const libc::c_char,
    pub xvec: *const bfd_target,
    pub iostream: *mut libc::c_void,
    pub iovec: *const bfd_iovec,
    pub lru_prev: *mut bfd,
    pub lru_next: *mut bfd,
    pub where_0: ufile_ptr,
    pub mtime: libc::c_long,
    pub id: libc::c_uint,
    pub flags: flagword,
    #[bitfield(name = "format", ty = "bfd_format", bits = "0..=2")]
    #[bitfield(name = "direction", ty = "bfd_direction", bits = "3..=4")]
    #[bitfield(name = "cacheable", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "target_defaulted", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "opened_once", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "mtime_set", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "no_export", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "output_has_begun", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "has_armap", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "is_thin_archive", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "no_element_cache", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "selective_search", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "is_linker_output", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "is_linker_input", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "plugin_format", ty = "bfd_plugin_format", bits = "17..=18")]
    #[bitfield(name = "lto_output", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "lto_slim_object", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "read_only", ty = "libc::c_uint", bits = "21..=21")]
    pub format_direction_cacheable_target_defaulted_opened_once_mtime_set_no_export_output_has_begun_has_armap_is_thin_archive_no_element_cache_selective_search_is_linker_output_is_linker_input_plugin_format_lto_output_lto_slim_object_read_only: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 5],
    pub plugin_dummy_bfd: *mut bfd,
    pub origin: ufile_ptr,
    pub proxy_origin: ufile_ptr,
    pub section_htab: bfd_hash_table,
    pub sections: *mut bfd_section,
    pub section_last: *mut bfd_section,
    pub section_count: libc::c_uint,
    pub archive_plugin_fd: libc::c_int,
    pub archive_plugin_fd_open_count: libc::c_uint,
    pub archive_pass: libc::c_int,
    pub start_address: bfd_vma,
    pub outsymbols: *mut *mut bfd_symbol,
    pub symcount: libc::c_uint,
    pub dynsymcount: libc::c_uint,
    pub arch_info: *const bfd_arch_info,
    pub size: ufile_ptr,
    pub arelt_data: *mut libc::c_void,
    pub my_archive: *mut bfd,
    pub archive_next: *mut bfd,
    pub archive_head: *mut bfd,
    pub nested_archives: *mut bfd,
    pub link: C2RustUnnamed_19,
    pub tdata: C2RustUnnamed,
    pub usrdata: *mut libc::c_void,
    pub memory: *mut libc::c_void,
    pub build_id: *const bfd_build_id,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_build_id {
    pub size: bfd_size_type,
    pub data: [bfd_byte; 1],
}
pub type bfd_byte = libc::c_uchar;
pub type bfd_size_type = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
    pub aout_data: *mut aout_data_struct,
    pub aout_ar_data: *mut artdata,
    pub coff_obj_data: *mut coff_tdata,
    pub pe_obj_data: *mut pe_tdata,
    pub xcoff_obj_data: *mut xcoff_tdata,
    pub ecoff_obj_data: *mut ecoff_tdata,
    pub srec_data: *mut srec_data_struct,
    pub verilog_data: *mut verilog_data_struct,
    pub ihex_data: *mut ihex_data_struct,
    pub tekhex_data: *mut tekhex_data_struct,
    pub elf_obj_data: *mut elf_obj_tdata,
    pub mmo_data: *mut mmo_data_struct,
    pub sun_core_data: *mut sun_core_struct,
    pub sco5_core_data: *mut sco5_core_struct,
    pub trad_core_data: *mut trad_core_struct,
    pub som_data: *mut som_data_struct,
    pub hpux_core_data: *mut hpux_core_struct,
    pub hppabsd_core_data: *mut hppabsd_core_struct,
    pub sgi_core_data: *mut sgi_core_struct,
    pub lynx_core_data: *mut lynx_core_struct,
    pub osf_core_data: *mut osf_core_struct,
    pub cisco_core_data: *mut cisco_core_struct,
    pub versados_data: *mut versados_data_struct,
    pub netbsd_core_data: *mut netbsd_core_struct,
    pub mach_o_data: *mut mach_o_data_struct,
    pub mach_o_fat_data: *mut mach_o_fat_data_struct,
    pub plugin_data: *mut plugin_data_struct,
    pub pef_data: *mut bfd_pef_data_struct,
    pub pef_xlib_data: *mut bfd_pef_xlib_data_struct,
    pub sym_data: *mut bfd_sym_data_struct,
    pub any: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct plugin_data_struct {
    pub nsyms: libc::c_int,
    pub syms: *const ld_plugin_symbol,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ld_plugin_symbol {
    pub name: *mut libc::c_char,
    pub version: *mut libc::c_char,
    pub def: libc::c_char,
    pub symbol_type: libc::c_char,
    pub section_kind: libc::c_char,
    pub unused: libc::c_char,
    pub visibility: libc::c_int,
    pub size: uint64_t,
    pub comdat_key: *mut libc::c_char,
    pub resolution: libc::c_int,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_obj_tdata {
    pub elf_header: [Elf_Internal_Ehdr; 1],
    pub elf_sect_ptr: *mut *mut Elf_Internal_Shdr,
    pub phdr: *mut Elf_Internal_Phdr,
    pub symtab_hdr: Elf_Internal_Shdr,
    pub shstrtab_hdr: Elf_Internal_Shdr,
    pub strtab_hdr: Elf_Internal_Shdr,
    pub dynsymtab_hdr: Elf_Internal_Shdr,
    pub dynstrtab_hdr: Elf_Internal_Shdr,
    pub dynversym_hdr: Elf_Internal_Shdr,
    pub dynverref_hdr: Elf_Internal_Shdr,
    pub dynverdef_hdr: Elf_Internal_Shdr,
    pub symtab_shndx_list: *mut elf_section_list,
    pub gp: bfd_vma,
    pub gp_size: libc::c_uint,
    pub num_elf_sections: libc::c_uint,
    pub being_created: *mut libc::c_uchar,
    pub sym_hashes: *mut *mut elf_link_hash_entry,
    pub local_got: C2RustUnnamed_15,
    pub dt_name: *const libc::c_char,
    pub dt_audit: *const libc::c_char,
    pub line_info: *mut libc::c_void,
    pub dwarf1_find_line_info: *mut dwarf1_debug,
    pub dwarf2_find_line_info: *mut libc::c_void,
    pub elf_find_function_cache: *mut libc::c_void,
    pub cverdefs: libc::c_uint,
    pub cverrefs: libc::c_uint,
    pub verdef: *mut Elf_Internal_Verdef,
    pub verref: *mut Elf_Internal_Verneed,
    pub eh_frame_section: *mut asection,
    pub symbuf: *mut libc::c_void,
    pub properties: *mut elf_property_list,
    pub known_obj_attributes: [[obj_attribute; 71]; 2],
    pub other_obj_attributes: [*mut obj_attribute_list; 2],
    pub sdt_note_head: *mut sdt_note,
    pub group_sect_ptr: *mut *mut Elf_Internal_Shdr,
    pub num_group: libc::c_uint,
    pub group_search_offset: libc::c_uint,
    pub symtab_section: libc::c_uint,
    pub dynsymtab_section: libc::c_uint,
    pub dynversym_section: libc::c_uint,
    pub dynverdef_section: libc::c_uint,
    pub dynverref_section: libc::c_uint,
    #[bitfield(name = "object_id", ty = "elf_target_id", bits = "0..=5")]
    #[bitfield(name = "dyn_lib_class", ty = "dynamic_lib_link_class", bits = "6..=9")]
    #[bitfield(name = "has_gnu_osabi", ty = "elf_gnu_osabi", bits = "10..=13")]
    #[bitfield(name = "has_no_copy_on_protected", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "bad_symtab", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "is_pie", ty = "libc::c_uint", bits = "16..=16")]
    pub object_id_dyn_lib_class_has_gnu_osabi_has_no_copy_on_protected_bad_symtab_is_pie: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub core: *mut core_elf_obj_tdata,
    pub o: *mut output_elf_obj_tdata,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct output_elf_obj_tdata {
    pub seg_map: *mut elf_segment_map,
    pub strtab_ptr: *mut elf_strtab_hash,
    pub section_syms: *mut *mut asymbol,
    pub eh_frame_hdr: *mut asection,
    pub build_id: C2RustUnnamed_13,
    pub program_header_size: bfd_size_type,
    pub next_file_pos: file_ptr,
    pub link_info: *mut bfd_link_info,
    pub num_section_syms: libc::c_int,
    pub shstrtab_section: libc::c_uint,
    pub strtab_section: libc::c_uint,
    pub stack_flags: libc::c_uint,
    pub flags_init: bool,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_link_info {
    #[bitfield(name = "type_0", ty = "output_type", bits = "0..=1")]
    #[bitfield(name = "symbolic", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "nocopyreloc", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "export_dynamic", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "create_default_symver", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "gc_sections", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "gc_keep_exported", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "notice_all", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "lto_plugin_active", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "lto_all_symbols_read", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "strip_discarded", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "dynamic_data", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "resolve_section_groups", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "big_endian", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "strip", ty = "bfd_link_strip", bits = "15..=16")]
    #[bitfield(name = "discard", ty = "bfd_link_discard", bits = "17..=18")]
    #[bitfield(name = "elf_stt_common", ty = "bfd_link_elf_stt_common", bits = "19..=20")]
    #[bitfield(name = "common_skip_ar_symbols", ty = "bfd_link_common_skip_ar_symbols", bits = "21..=22")]
    #[bitfield(name = "unresolved_syms_in_objects", ty = "report_method", bits = "23..=24")]
    #[bitfield(name = "unresolved_syms_in_shared_libs", ty = "report_method", bits = "25..=26")]
    #[bitfield(name = "warn_unresolved_syms", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "static_link", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "keep_memory", ty = "libc::c_uint", bits = "29..=29")]
    #[bitfield(name = "emitrelocations", ty = "libc::c_uint", bits = "30..=30")]
    #[bitfield(name = "relro", ty = "libc::c_uint", bits = "31..=31")]
    #[bitfield(name = "separate_code", ty = "libc::c_uint", bits = "32..=32")]
    #[bitfield(name = "eh_frame_hdr_type", ty = "libc::c_uint", bits = "33..=34")]
    #[bitfield(name = "textrel_check", ty = "textrel_check_method", bits = "35..=36")]
    #[bitfield(name = "emit_hash", ty = "libc::c_uint", bits = "37..=37")]
    #[bitfield(name = "emit_gnu_hash", ty = "libc::c_uint", bits = "38..=38")]
    #[bitfield(name = "reduce_memory_overheads", ty = "libc::c_uint", bits = "39..=39")]
    #[bitfield(name = "traditional_format", ty = "libc::c_uint", bits = "40..=40")]
    #[bitfield(name = "combreloc", ty = "libc::c_uint", bits = "41..=41")]
    #[bitfield(name = "default_imported_symver", ty = "libc::c_uint", bits = "42..=42")]
    #[bitfield(name = "new_dtags", ty = "libc::c_uint", bits = "43..=43")]
    #[bitfield(name = "no_ld_generated_unwind_info", ty = "libc::c_uint", bits = "44..=44")]
    #[bitfield(name = "task_link", ty = "libc::c_uint", bits = "45..=45")]
    #[bitfield(name = "allow_multiple_definition", ty = "libc::c_uint", bits = "46..=46")]
    #[bitfield(name = "prohibit_multiple_definition_absolute", ty = "libc::c_uint", bits = "47..=47")]
    #[bitfield(name = "warn_multiple_definition", ty = "libc::c_uint", bits = "48..=48")]
    #[bitfield(name = "allow_undefined_version", ty = "libc::c_uint", bits = "49..=49")]
    #[bitfield(name = "dynamic", ty = "libc::c_uint", bits = "50..=50")]
    #[bitfield(name = "execstack", ty = "libc::c_uint", bits = "51..=51")]
    #[bitfield(name = "noexecstack", ty = "libc::c_uint", bits = "52..=52")]
    #[bitfield(name = "optimize", ty = "libc::c_uint", bits = "53..=53")]
    #[bitfield(name = "print_gc_sections", ty = "libc::c_uint", bits = "54..=54")]
    #[bitfield(name = "warn_alternate_em", ty = "libc::c_uint", bits = "55..=55")]
    #[bitfield(name = "user_phdrs", ty = "libc::c_uint", bits = "56..=56")]
    #[bitfield(name = "load_phdrs", ty = "libc::c_uint", bits = "57..=57")]
    #[bitfield(name = "check_relocs_after_open_input", ty = "libc::c_uint", bits = "58..=58")]
    #[bitfield(name = "nointerp", ty = "libc::c_uint", bits = "59..=59")]
    #[bitfield(name = "inhibit_common_definition", ty = "libc::c_uint", bits = "60..=60")]
    #[bitfield(name = "has_map_file", ty = "libc::c_uint", bits = "61..=61")]
    #[bitfield(name = "non_contiguous_regions", ty = "libc::c_uint", bits = "62..=62")]
    #[bitfield(name = "non_contiguous_regions_warnings", ty = "libc::c_uint", bits = "63..=63")]
    #[bitfield(name = "unique_symbol", ty = "libc::c_uint", bits = "64..=64")]
    pub type_0_symbolic_nocopyreloc_export_dynamic_create_default_symver_gc_sections_gc_keep_exported_notice_all_lto_plugin_active_lto_all_symbols_read_strip_discarded_dynamic_data_resolve_section_groups_big_endian_strip_discard_elf_stt_common_common_skip_ar_symbols_unresolved_syms_in_objects_unresolved_syms_in_shared_libs_warn_unresolved_syms_static_link_keep_memory_emitrelocations_relro_separate_code_eh_frame_hdr_type_textrel_check_emit_hash_emit_gnu_hash_reduce_memory_overheads_traditional_format_combreloc_default_imported_symver_new_dtags_no_ld_generated_unwind_info_task_link_allow_multiple_definition_prohibit_multiple_definition_absolute_warn_multiple_definition_allow_undefined_version_dynamic_execstack_noexecstack_optimize_print_gc_sections_warn_alternate_em_user_phdrs_load_phdrs_check_relocs_after_open_input_nointerp_inhibit_common_definition_has_map_file_non_contiguous_regions_non_contiguous_regions_warnings_unique_symbol: [u8; 9],
    pub wrap_char: libc::c_char,
    pub path_separator: libc::c_char,
    pub compress_debug: compressed_debug_section_type,
    pub stacksize: bfd_signed_vma,
    pub disable_target_specific_optimizations: libc::c_int,
    pub callbacks: *const bfd_link_callbacks,
    pub hash: *mut bfd_link_hash_table,
    pub keep_hash: *mut bfd_hash_table,
    pub notice_hash: *mut bfd_hash_table,
    pub wrap_hash: *mut bfd_hash_table,
    pub ignore_hash: *mut bfd_hash_table,
    pub output_bfd: *mut bfd,
    pub out_implib_bfd: *mut bfd,
    pub input_bfds: *mut bfd,
    pub input_bfds_tail: *mut *mut bfd,
    pub create_object_symbols_section: *mut asection,
    pub gc_sym_list: *mut bfd_sym_chain,
    pub base_file: *mut libc::c_void,
    pub init_function: *const libc::c_char,
    pub fini_function: *const libc::c_char,
    pub relax_pass: libc::c_int,
    pub relax_trip: libc::c_int,
    pub extern_protected_data: libc::c_int,
    pub dynamic_undefined_weak: libc::c_int,
    pub pei386_auto_import: libc::c_int,
    pub pei386_runtime_pseudo_reloc: libc::c_int,
    pub spare_dynamic_tags: libc::c_uint,
    pub flags: bfd_vma,
    pub flags_1: bfd_vma,
    pub gnu_flags_1: bfd_vma,
    pub start_stop_gc: libc::c_int,
    pub start_stop_visibility: libc::c_uint,
    pub maxpagesize: bfd_vma,
    pub commonpagesize: bfd_vma,
    pub relro_start: bfd_vma,
    pub relro_end: bfd_vma,
    pub dynamic_list: *mut bfd_elf_dynamic_list,
    pub version_info: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_tree {
    pub next: *mut bfd_elf_version_tree,
    pub name: *const libc::c_char,
    pub vernum: libc::c_uint,
    pub globals: bfd_elf_version_expr_head,
    pub locals: bfd_elf_version_expr_head,
    pub deps: *mut bfd_elf_version_deps,
    pub name_indx: libc::c_uint,
    pub used: libc::c_int,
    pub match_0: Option::<
        unsafe extern "C" fn(
            *mut bfd_elf_version_expr_head,
            *mut bfd_elf_version_expr,
            *const libc::c_char,
        ) -> *mut bfd_elf_version_expr,
    >,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_elf_version_expr {
    pub next: *mut bfd_elf_version_expr,
    pub pattern: *const libc::c_char,
    #[bitfield(name = "literal", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "symver", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "script", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "mask", ty = "libc::c_uint", bits = "3..=5")]
    pub literal_symver_script_mask: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 7],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_expr_head {
    pub list: *mut bfd_elf_version_expr,
    pub htab: *mut libc::c_void,
    pub remaining: *mut bfd_elf_version_expr,
    pub mask: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_deps {
    pub next: *mut bfd_elf_version_deps,
    pub version_needed: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_dynamic_list {
    pub head: bfd_elf_version_expr_head,
    pub match_0: Option::<
        unsafe extern "C" fn(
            *mut bfd_elf_version_expr_head,
            *mut bfd_elf_version_expr,
            *const libc::c_char,
        ) -> *mut bfd_elf_version_expr,
    >,
}
pub type bfd_vma = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_sym_chain {
    pub next: *mut bfd_sym_chain,
    pub name: *const libc::c_char,
}
pub type asection = bfd_section;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_section {
    pub name: *const libc::c_char,
    pub id: libc::c_uint,
    pub section_id: libc::c_uint,
    pub index: libc::c_uint,
    pub next: *mut bfd_section,
    pub prev: *mut bfd_section,
    pub flags: flagword,
    #[bitfield(name = "user_set_vma", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "linker_mark", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "linker_has_input", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "gc_mark", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "compress_status", ty = "libc::c_uint", bits = "4..=5")]
    #[bitfield(name = "segment_mark", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "sec_info_type", ty = "libc::c_uint", bits = "7..=9")]
    #[bitfield(name = "use_rela_p", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "sec_flg0", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "sec_flg1", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "sec_flg2", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "sec_flg3", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "sec_flg4", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "sec_flg5", ty = "libc::c_uint", bits = "16..=16")]
    pub user_set_vma_linker_mark_linker_has_input_gc_mark_compress_status_segment_mark_sec_info_type_use_rela_p_sec_flg0_sec_flg1_sec_flg2_sec_flg3_sec_flg4_sec_flg5: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub vma: bfd_vma,
    pub lma: bfd_vma,
    pub size: bfd_size_type,
    pub rawsize: bfd_size_type,
    pub compressed_size: bfd_size_type,
    pub relax: *mut relax_table,
    pub relax_count: libc::c_int,
    pub output_offset: bfd_vma,
    pub output_section: *mut bfd_section,
    pub alignment_power: libc::c_uint,
    pub relocation: *mut reloc_cache_entry,
    pub orelocation: *mut *mut reloc_cache_entry,
    pub reloc_count: libc::c_uint,
    pub filepos: file_ptr,
    pub rel_filepos: file_ptr,
    pub line_filepos: file_ptr,
    pub userdata: *mut libc::c_void,
    pub contents: *mut libc::c_uchar,
    pub lineno: *mut alent,
    pub lineno_count: libc::c_uint,
    pub entsize: libc::c_uint,
    pub kept_section: *mut bfd_section,
    pub moving_line_filepos: file_ptr,
    pub target_index: libc::c_int,
    pub used_by_bfd: *mut libc::c_void,
    pub constructor_chain: *mut relent_chain,
    pub owner: *mut bfd,
    pub symbol: *mut bfd_symbol,
    pub symbol_ptr_ptr: *mut *mut bfd_symbol,
    pub map_head: C2RustUnnamed_0,
    pub map_tail: C2RustUnnamed_0,
    pub already_assigned: *mut bfd_section,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub link_order: *mut bfd_link_order,
    pub s: *mut bfd_section,
    pub linked_to_symbol_name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_order {
    pub next: *mut bfd_link_order,
    pub type_0: bfd_link_order_type,
    pub offset: bfd_vma,
    pub size: bfd_size_type,
    pub u: C2RustUnnamed_1,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub indirect: C2RustUnnamed_5,
    pub data: C2RustUnnamed_4,
    pub reloc: C2RustUnnamed_2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub p: *mut bfd_link_order_reloc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_order_reloc {
    pub reloc: bfd_reloc_code_real_type,
    pub u: C2RustUnnamed_3,
    pub addend: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub section: *mut asection,
    pub name: *const libc::c_char,
}
pub type bfd_reloc_code_real_type = bfd_reloc_code_real;
pub type bfd_reloc_code_real = libc::c_uint;
pub const BFD_RELOC_UNUSED: bfd_reloc_code_real = 2383;
pub const BFD_RELOC_S12Z_OPR: bfd_reloc_code_real = 2382;
pub const BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4: bfd_reloc_code_real = 2381;
pub const BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4: bfd_reloc_code_real = 2380;
pub const BFD_RELOC_CKCORE_IRELATIVE: bfd_reloc_code_real = 2379;
pub const BFD_RELOC_CKCORE_CALLGRAPH: bfd_reloc_code_real = 2378;
pub const BFD_RELOC_CKCORE_NOJSRI: bfd_reloc_code_real = 2377;
pub const BFD_RELOC_CKCORE_PCREL_FLRW_IMM8BY4: bfd_reloc_code_real = 2376;
pub const BFD_RELOC_CKCORE_TLS_TPOFF32: bfd_reloc_code_real = 2375;
pub const BFD_RELOC_CKCORE_TLS_DTPOFF32: bfd_reloc_code_real = 2374;
pub const BFD_RELOC_CKCORE_TLS_DTPMOD32: bfd_reloc_code_real = 2373;
pub const BFD_RELOC_CKCORE_TLS_LDO32: bfd_reloc_code_real = 2372;
pub const BFD_RELOC_CKCORE_TLS_LDM32: bfd_reloc_code_real = 2371;
pub const BFD_RELOC_CKCORE_TLS_GD32: bfd_reloc_code_real = 2370;
pub const BFD_RELOC_CKCORE_TLS_IE32: bfd_reloc_code_real = 2369;
pub const BFD_RELOC_CKCORE_TLS_LE32: bfd_reloc_code_real = 2368;
pub const BFD_RELOC_CKCORE_PCREL_IMM7BY4: bfd_reloc_code_real = 2367;
pub const BFD_RELOC_CKCORE_PLT_IMM18BY4: bfd_reloc_code_real = 2366;
pub const BFD_RELOC_CKCORE_GOT_IMM18BY4: bfd_reloc_code_real = 2365;
pub const BFD_RELOC_CKCORE_GOTOFF_IMM18: bfd_reloc_code_real = 2364;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18BY4: bfd_reloc_code_real = 2363;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18BY2: bfd_reloc_code_real = 2362;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18: bfd_reloc_code_real = 2361;
pub const BFD_RELOC_CKCORE_PCREL_IMM18BY2: bfd_reloc_code_real = 2360;
pub const BFD_RELOC_CKCORE_DOFFSET_LO16: bfd_reloc_code_real = 2359;
pub const BFD_RELOC_CKCORE_TOFFSET_LO16: bfd_reloc_code_real = 2358;
pub const BFD_RELOC_CKCORE_PCREL_JSR_IMM26BY2: bfd_reloc_code_real = 2357;
pub const BFD_RELOC_CKCORE_ADDRPLT_LO16: bfd_reloc_code_real = 2356;
pub const BFD_RELOC_CKCORE_ADDRPLT_HI16: bfd_reloc_code_real = 2355;
pub const BFD_RELOC_CKCORE_ADDRGOT_LO16: bfd_reloc_code_real = 2354;
pub const BFD_RELOC_CKCORE_ADDRGOT_HI16: bfd_reloc_code_real = 2353;
pub const BFD_RELOC_CKCORE_PLT_LO16: bfd_reloc_code_real = 2352;
pub const BFD_RELOC_CKCORE_PLT_HI16: bfd_reloc_code_real = 2351;
pub const BFD_RELOC_CKCORE_PLT12: bfd_reloc_code_real = 2350;
pub const BFD_RELOC_CKCORE_GOT_LO16: bfd_reloc_code_real = 2349;
pub const BFD_RELOC_CKCORE_GOT_HI16: bfd_reloc_code_real = 2348;
pub const BFD_RELOC_CKCORE_GOT12: bfd_reloc_code_real = 2347;
pub const BFD_RELOC_CKCORE_GOTOFF_LO16: bfd_reloc_code_real = 2346;
pub const BFD_RELOC_CKCORE_GOTOFF_HI16: bfd_reloc_code_real = 2345;
pub const BFD_RELOC_CKCORE_GOTPC_LO16: bfd_reloc_code_real = 2344;
pub const BFD_RELOC_CKCORE_GOTPC_HI16: bfd_reloc_code_real = 2343;
pub const BFD_RELOC_CKCORE_ADDR_LO16: bfd_reloc_code_real = 2342;
pub const BFD_RELOC_CKCORE_ADDR_HI16: bfd_reloc_code_real = 2341;
pub const BFD_RELOC_CKCORE_PCREL_IMM10BY4: bfd_reloc_code_real = 2340;
pub const BFD_RELOC_CKCORE_PCREL_IMM10BY2: bfd_reloc_code_real = 2339;
pub const BFD_RELOC_CKCORE_PCREL_IMM16BY4: bfd_reloc_code_real = 2338;
pub const BFD_RELOC_CKCORE_PCREL_IMM16BY2: bfd_reloc_code_real = 2337;
pub const BFD_RELOC_CKCORE_PCREL_IMM26BY2: bfd_reloc_code_real = 2336;
pub const BFD_RELOC_CKCORE_ADDRPLT: bfd_reloc_code_real = 2335;
pub const BFD_RELOC_CKCORE_ADDRGOT: bfd_reloc_code_real = 2334;
pub const BFD_RELOC_CKCORE_PLT32: bfd_reloc_code_real = 2333;
pub const BFD_RELOC_CKCORE_GOT32: bfd_reloc_code_real = 2332;
pub const BFD_RELOC_CKCORE_GOTPC: bfd_reloc_code_real = 2331;
pub const BFD_RELOC_CKCORE_GOTOFF: bfd_reloc_code_real = 2330;
pub const BFD_RELOC_CKCORE_JUMP_SLOT: bfd_reloc_code_real = 2329;
pub const BFD_RELOC_CKCORE_GLOB_DAT: bfd_reloc_code_real = 2328;
pub const BFD_RELOC_CKCORE_COPY: bfd_reloc_code_real = 2327;
pub const BFD_RELOC_CKCORE_RELATIVE: bfd_reloc_code_real = 2326;
pub const BFD_RELOC_CKCORE_GNU_VTENTRY: bfd_reloc_code_real = 2325;
pub const BFD_RELOC_CKCORE_GNU_VTINHERIT: bfd_reloc_code_real = 2324;
pub const BFD_RELOC_CKCORE_PCREL_JSR_IMM11BY2: bfd_reloc_code_real = 2323;
pub const BFD_RELOC_CKCORE_PCREL32: bfd_reloc_code_real = 2322;
pub const BFD_RELOC_CKCORE_PCREL_IMM4BY2: bfd_reloc_code_real = 2321;
pub const BFD_RELOC_CKCORE_PCREL_IMM11BY2: bfd_reloc_code_real = 2320;
pub const BFD_RELOC_CKCORE_PCREL_IMM8BY4: bfd_reloc_code_real = 2319;
pub const BFD_RELOC_CKCORE_ADDR32: bfd_reloc_code_real = 2318;
pub const BFD_RELOC_CKCORE_NONE: bfd_reloc_code_real = 2317;
pub const BFD_RELOC_WASM32_PLT_SIG: bfd_reloc_code_real = 2316;
pub const BFD_RELOC_WASM32_INDEX: bfd_reloc_code_real = 2315;
pub const BFD_RELOC_WASM32_CODE_POINTER: bfd_reloc_code_real = 2314;
pub const BFD_RELOC_WASM32_COPY: bfd_reloc_code_real = 2313;
pub const BFD_RELOC_WASM32_ABS32_CODE: bfd_reloc_code_real = 2312;
pub const BFD_RELOC_WASM32_PLT_INDEX: bfd_reloc_code_real = 2311;
pub const BFD_RELOC_WASM32_LEB128_PLT: bfd_reloc_code_real = 2310;
pub const BFD_RELOC_WASM32_LEB128_GOT_CODE: bfd_reloc_code_real = 2309;
pub const BFD_RELOC_WASM32_LEB128_GOT: bfd_reloc_code_real = 2308;
pub const BFD_RELOC_WASM32_LEB128: bfd_reloc_code_real = 2307;
pub const BFD_RELOC_VISIUM_IM16_PCREL: bfd_reloc_code_real = 2306;
pub const BFD_RELOC_VISIUM_LO16_PCREL: bfd_reloc_code_real = 2305;
pub const BFD_RELOC_VISIUM_HI16_PCREL: bfd_reloc_code_real = 2304;
pub const BFD_RELOC_VISIUM_REL16: bfd_reloc_code_real = 2303;
pub const BFD_RELOC_VISIUM_IM16: bfd_reloc_code_real = 2302;
pub const BFD_RELOC_VISIUM_LO16: bfd_reloc_code_real = 2301;
pub const BFD_RELOC_VISIUM_HI16: bfd_reloc_code_real = 2300;
pub const BFD_RELOC_EPIPHANY_IMM8: bfd_reloc_code_real = 2299;
pub const BFD_RELOC_EPIPHANY_IMM11: bfd_reloc_code_real = 2298;
pub const BFD_RELOC_EPIPHANY_SIMM11: bfd_reloc_code_real = 2297;
pub const BFD_RELOC_EPIPHANY_LOW: bfd_reloc_code_real = 2296;
pub const BFD_RELOC_EPIPHANY_HIGH: bfd_reloc_code_real = 2295;
pub const BFD_RELOC_EPIPHANY_SIMM24: bfd_reloc_code_real = 2294;
pub const BFD_RELOC_EPIPHANY_SIMM8: bfd_reloc_code_real = 2293;
pub const BFD_RELOC_BPF_DISP32: bfd_reloc_code_real = 2292;
pub const BFD_RELOC_BPF_DISP16: bfd_reloc_code_real = 2291;
pub const BFD_RELOC_BPF_16: bfd_reloc_code_real = 2290;
pub const BFD_RELOC_BPF_32: bfd_reloc_code_real = 2289;
pub const BFD_RELOC_BPF_64: bfd_reloc_code_real = 2288;
pub const BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD: bfd_reloc_code_real = 2287;
pub const BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD: bfd_reloc_code_real = 2286;
pub const BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD: bfd_reloc_code_real = 2285;
pub const BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD: bfd_reloc_code_real = 2284;
pub const BFD_RELOC_TILEGX_TLS_IE_LOAD: bfd_reloc_code_real = 2283;
pub const BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD: bfd_reloc_code_real = 2282;
pub const BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD: bfd_reloc_code_real = 2281;
pub const BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD: bfd_reloc_code_real = 2280;
pub const BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD: bfd_reloc_code_real = 2279;
pub const BFD_RELOC_TILEGX_TLS_GD_CALL: bfd_reloc_code_real = 2278;
pub const BFD_RELOC_TILEGX_TLS_TPOFF32: bfd_reloc_code_real = 2277;
pub const BFD_RELOC_TILEGX_TLS_DTPOFF32: bfd_reloc_code_real = 2276;
pub const BFD_RELOC_TILEGX_TLS_DTPMOD32: bfd_reloc_code_real = 2275;
pub const BFD_RELOC_TILEGX_TLS_TPOFF64: bfd_reloc_code_real = 2274;
pub const BFD_RELOC_TILEGX_TLS_DTPOFF64: bfd_reloc_code_real = 2273;
pub const BFD_RELOC_TILEGX_TLS_DTPMOD64: bfd_reloc_code_real = 2272;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE: bfd_reloc_code_real = 2271;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE: bfd_reloc_code_real = 2270;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE: bfd_reloc_code_real = 2269;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE: bfd_reloc_code_real = 2268;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL: bfd_reloc_code_real = 2267;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL: bfd_reloc_code_real = 2266;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL: bfd_reloc_code_real = 2265;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL: bfd_reloc_code_real = 2264;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL: bfd_reloc_code_real = 2263;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL: bfd_reloc_code_real = 2262;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE: bfd_reloc_code_real = 2261;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE: bfd_reloc_code_real = 2260;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD: bfd_reloc_code_real = 2259;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD: bfd_reloc_code_real = 2258;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD: bfd_reloc_code_real = 2257;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD: bfd_reloc_code_real = 2256;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE: bfd_reloc_code_real = 2255;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE: bfd_reloc_code_real = 2254;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE: bfd_reloc_code_real = 2253;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE: bfd_reloc_code_real = 2252;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE: bfd_reloc_code_real = 2251;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE: bfd_reloc_code_real = 2250;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD: bfd_reloc_code_real = 2249;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD: bfd_reloc_code_real = 2248;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL: bfd_reloc_code_real = 2247;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL: bfd_reloc_code_real = 2246;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT: bfd_reloc_code_real = 2245;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT: bfd_reloc_code_real = 2244;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT: bfd_reloc_code_real = 2243;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT: bfd_reloc_code_real = 2242;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL: bfd_reloc_code_real = 2241;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL: bfd_reloc_code_real = 2240;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL: bfd_reloc_code_real = 2239;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL: bfd_reloc_code_real = 2238;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL: bfd_reloc_code_real = 2237;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL: bfd_reloc_code_real = 2236;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT: bfd_reloc_code_real = 2235;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT: bfd_reloc_code_real = 2234;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL: bfd_reloc_code_real = 2233;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL: bfd_reloc_code_real = 2232;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL: bfd_reloc_code_real = 2231;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL: bfd_reloc_code_real = 2230;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL: bfd_reloc_code_real = 2229;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL: bfd_reloc_code_real = 2228;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL: bfd_reloc_code_real = 2227;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL: bfd_reloc_code_real = 2226;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL: bfd_reloc_code_real = 2225;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL: bfd_reloc_code_real = 2224;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL: bfd_reloc_code_real = 2223;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL: bfd_reloc_code_real = 2222;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL: bfd_reloc_code_real = 2221;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL: bfd_reloc_code_real = 2220;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST: bfd_reloc_code_real = 2219;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST: bfd_reloc_code_real = 2218;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST: bfd_reloc_code_real = 2217;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST: bfd_reloc_code_real = 2216;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST: bfd_reloc_code_real = 2215;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST: bfd_reloc_code_real = 2214;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3: bfd_reloc_code_real = 2213;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3: bfd_reloc_code_real = 2212;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2: bfd_reloc_code_real = 2211;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2: bfd_reloc_code_real = 2210;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1: bfd_reloc_code_real = 2209;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1: bfd_reloc_code_real = 2208;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0: bfd_reloc_code_real = 2207;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0: bfd_reloc_code_real = 2206;
pub const BFD_RELOC_TILEGX_SHAMT_Y1: bfd_reloc_code_real = 2205;
pub const BFD_RELOC_TILEGX_SHAMT_Y0: bfd_reloc_code_real = 2204;
pub const BFD_RELOC_TILEGX_SHAMT_X1: bfd_reloc_code_real = 2203;
pub const BFD_RELOC_TILEGX_SHAMT_X0: bfd_reloc_code_real = 2202;
pub const BFD_RELOC_TILEGX_MMEND_X0: bfd_reloc_code_real = 2201;
pub const BFD_RELOC_TILEGX_MMSTART_X0: bfd_reloc_code_real = 2200;
pub const BFD_RELOC_TILEGX_MF_IMM14_X1: bfd_reloc_code_real = 2199;
pub const BFD_RELOC_TILEGX_MT_IMM14_X1: bfd_reloc_code_real = 2198;
pub const BFD_RELOC_TILEGX_DEST_IMM8_X1: bfd_reloc_code_real = 2197;
pub const BFD_RELOC_TILEGX_IMM8_Y1: bfd_reloc_code_real = 2196;
pub const BFD_RELOC_TILEGX_IMM8_X1: bfd_reloc_code_real = 2195;
pub const BFD_RELOC_TILEGX_IMM8_Y0: bfd_reloc_code_real = 2194;
pub const BFD_RELOC_TILEGX_IMM8_X0: bfd_reloc_code_real = 2193;
pub const BFD_RELOC_TILEGX_JUMPOFF_X1_PLT: bfd_reloc_code_real = 2192;
pub const BFD_RELOC_TILEGX_JUMPOFF_X1: bfd_reloc_code_real = 2191;
pub const BFD_RELOC_TILEGX_BROFF_X1: bfd_reloc_code_real = 2190;
pub const BFD_RELOC_TILEGX_RELATIVE: bfd_reloc_code_real = 2189;
pub const BFD_RELOC_TILEGX_JMP_SLOT: bfd_reloc_code_real = 2188;
pub const BFD_RELOC_TILEGX_GLOB_DAT: bfd_reloc_code_real = 2187;
pub const BFD_RELOC_TILEGX_COPY: bfd_reloc_code_real = 2186;
pub const BFD_RELOC_TILEGX_HW2_LAST: bfd_reloc_code_real = 2185;
pub const BFD_RELOC_TILEGX_HW1_LAST: bfd_reloc_code_real = 2184;
pub const BFD_RELOC_TILEGX_HW0_LAST: bfd_reloc_code_real = 2183;
pub const BFD_RELOC_TILEGX_HW3: bfd_reloc_code_real = 2182;
pub const BFD_RELOC_TILEGX_HW2: bfd_reloc_code_real = 2181;
pub const BFD_RELOC_TILEGX_HW1: bfd_reloc_code_real = 2180;
pub const BFD_RELOC_TILEGX_HW0: bfd_reloc_code_real = 2179;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA: bfd_reloc_code_real = 2178;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA: bfd_reloc_code_real = 2177;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI: bfd_reloc_code_real = 2176;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI: bfd_reloc_code_real = 2175;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO: bfd_reloc_code_real = 2174;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO: bfd_reloc_code_real = 2173;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE: bfd_reloc_code_real = 2172;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE: bfd_reloc_code_real = 2171;
pub const BFD_RELOC_TILEPRO_TLS_TPOFF32: bfd_reloc_code_real = 2170;
pub const BFD_RELOC_TILEPRO_TLS_DTPOFF32: bfd_reloc_code_real = 2169;
pub const BFD_RELOC_TILEPRO_TLS_DTPMOD32: bfd_reloc_code_real = 2168;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA: bfd_reloc_code_real = 2167;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA: bfd_reloc_code_real = 2166;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI: bfd_reloc_code_real = 2165;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI: bfd_reloc_code_real = 2164;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO: bfd_reloc_code_real = 2163;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO: bfd_reloc_code_real = 2162;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE: bfd_reloc_code_real = 2161;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE: bfd_reloc_code_real = 2160;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA: bfd_reloc_code_real = 2159;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA: bfd_reloc_code_real = 2158;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI: bfd_reloc_code_real = 2157;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI: bfd_reloc_code_real = 2156;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO: bfd_reloc_code_real = 2155;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO: bfd_reloc_code_real = 2154;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD: bfd_reloc_code_real = 2153;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD: bfd_reloc_code_real = 2152;
pub const BFD_RELOC_TILEPRO_TLS_IE_LOAD: bfd_reloc_code_real = 2151;
pub const BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD: bfd_reloc_code_real = 2150;
pub const BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD: bfd_reloc_code_real = 2149;
pub const BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD: bfd_reloc_code_real = 2148;
pub const BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD: bfd_reloc_code_real = 2147;
pub const BFD_RELOC_TILEPRO_TLS_GD_CALL: bfd_reloc_code_real = 2146;
pub const BFD_RELOC_TILEPRO_SHAMT_Y1: bfd_reloc_code_real = 2145;
pub const BFD_RELOC_TILEPRO_SHAMT_Y0: bfd_reloc_code_real = 2144;
pub const BFD_RELOC_TILEPRO_SHAMT_X1: bfd_reloc_code_real = 2143;
pub const BFD_RELOC_TILEPRO_SHAMT_X0: bfd_reloc_code_real = 2142;
pub const BFD_RELOC_TILEPRO_MMEND_X1: bfd_reloc_code_real = 2141;
pub const BFD_RELOC_TILEPRO_MMSTART_X1: bfd_reloc_code_real = 2140;
pub const BFD_RELOC_TILEPRO_MMEND_X0: bfd_reloc_code_real = 2139;
pub const BFD_RELOC_TILEPRO_MMSTART_X0: bfd_reloc_code_real = 2138;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA: bfd_reloc_code_real = 2137;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA: bfd_reloc_code_real = 2136;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI: bfd_reloc_code_real = 2135;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI: bfd_reloc_code_real = 2134;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO: bfd_reloc_code_real = 2133;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO: bfd_reloc_code_real = 2132;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT: bfd_reloc_code_real = 2131;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT: bfd_reloc_code_real = 2130;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL: bfd_reloc_code_real = 2129;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL: bfd_reloc_code_real = 2128;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL: bfd_reloc_code_real = 2127;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL: bfd_reloc_code_real = 2126;
pub const BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL: bfd_reloc_code_real = 2125;
pub const BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL: bfd_reloc_code_real = 2124;
pub const BFD_RELOC_TILEPRO_IMM16_X1_PCREL: bfd_reloc_code_real = 2123;
pub const BFD_RELOC_TILEPRO_IMM16_X0_PCREL: bfd_reloc_code_real = 2122;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HA: bfd_reloc_code_real = 2121;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HA: bfd_reloc_code_real = 2120;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HI: bfd_reloc_code_real = 2119;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HI: bfd_reloc_code_real = 2118;
pub const BFD_RELOC_TILEPRO_IMM16_X1_LO: bfd_reloc_code_real = 2117;
pub const BFD_RELOC_TILEPRO_IMM16_X0_LO: bfd_reloc_code_real = 2116;
pub const BFD_RELOC_TILEPRO_IMM16_X1: bfd_reloc_code_real = 2115;
pub const BFD_RELOC_TILEPRO_IMM16_X0: bfd_reloc_code_real = 2114;
pub const BFD_RELOC_TILEPRO_MF_IMM15_X1: bfd_reloc_code_real = 2113;
pub const BFD_RELOC_TILEPRO_MT_IMM15_X1: bfd_reloc_code_real = 2112;
pub const BFD_RELOC_TILEPRO_DEST_IMM8_X1: bfd_reloc_code_real = 2111;
pub const BFD_RELOC_TILEPRO_IMM8_Y1: bfd_reloc_code_real = 2110;
pub const BFD_RELOC_TILEPRO_IMM8_X1: bfd_reloc_code_real = 2109;
pub const BFD_RELOC_TILEPRO_IMM8_Y0: bfd_reloc_code_real = 2108;
pub const BFD_RELOC_TILEPRO_IMM8_X0: bfd_reloc_code_real = 2107;
pub const BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT: bfd_reloc_code_real = 2106;
pub const BFD_RELOC_TILEPRO_JOFFLONG_X1: bfd_reloc_code_real = 2105;
pub const BFD_RELOC_TILEPRO_BROFF_X1: bfd_reloc_code_real = 2104;
pub const BFD_RELOC_TILEPRO_RELATIVE: bfd_reloc_code_real = 2103;
pub const BFD_RELOC_TILEPRO_JMP_SLOT: bfd_reloc_code_real = 2102;
pub const BFD_RELOC_TILEPRO_GLOB_DAT: bfd_reloc_code_real = 2101;
pub const BFD_RELOC_TILEPRO_COPY: bfd_reloc_code_real = 2100;
pub const BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC: bfd_reloc_code_real = 2099;
pub const BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2098;
pub const BFD_RELOC_AARCH64_LD_GOT_LO12_NC: bfd_reloc_code_real = 2097;
pub const BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12_NC: bfd_reloc_code_real = 2096;
pub const BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12: bfd_reloc_code_real = 2095;
pub const BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC: bfd_reloc_code_real = 2094;
pub const BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12: bfd_reloc_code_real = 2093;
pub const BFD_RELOC_AARCH64_LDST_LO12: bfd_reloc_code_real = 2092;
pub const BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP: bfd_reloc_code_real = 2091;
pub const BFD_RELOC_AARCH64_RELOC_END: bfd_reloc_code_real = 2090;
pub const BFD_RELOC_AARCH64_IRELATIVE: bfd_reloc_code_real = 2089;
pub const BFD_RELOC_AARCH64_TLSDESC: bfd_reloc_code_real = 2088;
pub const BFD_RELOC_AARCH64_TLS_TPREL: bfd_reloc_code_real = 2087;
pub const BFD_RELOC_AARCH64_TLS_DTPREL: bfd_reloc_code_real = 2086;
pub const BFD_RELOC_AARCH64_TLS_DTPMOD: bfd_reloc_code_real = 2085;
pub const BFD_RELOC_AARCH64_RELATIVE: bfd_reloc_code_real = 2084;
pub const BFD_RELOC_AARCH64_JUMP_SLOT: bfd_reloc_code_real = 2083;
pub const BFD_RELOC_AARCH64_GLOB_DAT: bfd_reloc_code_real = 2082;
pub const BFD_RELOC_AARCH64_COPY: bfd_reloc_code_real = 2081;
pub const BFD_RELOC_AARCH64_TLSDESC_CALL: bfd_reloc_code_real = 2080;
pub const BFD_RELOC_AARCH64_TLSDESC_ADD: bfd_reloc_code_real = 2079;
pub const BFD_RELOC_AARCH64_TLSDESC_LDR: bfd_reloc_code_real = 2078;
pub const BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC: bfd_reloc_code_real = 2077;
pub const BFD_RELOC_AARCH64_TLSDESC_OFF_G1: bfd_reloc_code_real = 2076;
pub const BFD_RELOC_AARCH64_TLSDESC_ADD_LO12: bfd_reloc_code_real = 2075;
pub const BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC: bfd_reloc_code_real = 2074;
pub const BFD_RELOC_AARCH64_TLSDESC_LD64_LO12: bfd_reloc_code_real = 2073;
pub const BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21: bfd_reloc_code_real = 2072;
pub const BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21: bfd_reloc_code_real = 2071;
pub const BFD_RELOC_AARCH64_TLSDESC_LD_PREL19: bfd_reloc_code_real = 2070;
pub const BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12_NC: bfd_reloc_code_real = 2069;
pub const BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12: bfd_reloc_code_real = 2068;
pub const BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12_NC: bfd_reloc_code_real = 2067;
pub const BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12: bfd_reloc_code_real = 2066;
pub const BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12_NC: bfd_reloc_code_real = 2065;
pub const BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12: bfd_reloc_code_real = 2064;
pub const BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12_NC: bfd_reloc_code_real = 2063;
pub const BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12: bfd_reloc_code_real = 2062;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC: bfd_reloc_code_real = 2061;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12: bfd_reloc_code_real = 2060;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12: bfd_reloc_code_real = 2059;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC: bfd_reloc_code_real = 2058;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0: bfd_reloc_code_real = 2057;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC: bfd_reloc_code_real = 2056;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1: bfd_reloc_code_real = 2055;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2: bfd_reloc_code_real = 2054;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2: bfd_reloc_code_real = 2053;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC: bfd_reloc_code_real = 2052;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1: bfd_reloc_code_real = 2051;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC: bfd_reloc_code_real = 2050;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0: bfd_reloc_code_real = 2049;
pub const BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC: bfd_reloc_code_real = 2048;
pub const BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12: bfd_reloc_code_real = 2047;
pub const BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC: bfd_reloc_code_real = 2046;
pub const BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12: bfd_reloc_code_real = 2045;
pub const BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC: bfd_reloc_code_real = 2044;
pub const BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12: bfd_reloc_code_real = 2043;
pub const BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC: bfd_reloc_code_real = 2042;
pub const BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12: bfd_reloc_code_real = 2041;
pub const BFD_RELOC_AARCH64_TLSLD_ADR_PREL21: bfd_reloc_code_real = 2040;
pub const BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21: bfd_reloc_code_real = 2039;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC: bfd_reloc_code_real = 2038;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC: bfd_reloc_code_real = 2037;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12: bfd_reloc_code_real = 2036;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12: bfd_reloc_code_real = 2035;
pub const BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1: bfd_reloc_code_real = 2034;
pub const BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC: bfd_reloc_code_real = 2033;
pub const BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19: bfd_reloc_code_real = 2032;
pub const BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2031;
pub const BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2030;
pub const BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21: bfd_reloc_code_real = 2029;
pub const BFD_RELOC_AARCH64_TLSGD_MOVW_G1: bfd_reloc_code_real = 2028;
pub const BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC: bfd_reloc_code_real = 2027;
pub const BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC: bfd_reloc_code_real = 2026;
pub const BFD_RELOC_AARCH64_TLSGD_ADR_PREL21: bfd_reloc_code_real = 2025;
pub const BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21: bfd_reloc_code_real = 2024;
pub const BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15: bfd_reloc_code_real = 2023;
pub const BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14: bfd_reloc_code_real = 2022;
pub const BFD_RELOC_AARCH64_LD64_GOTOFF_LO15: bfd_reloc_code_real = 2021;
pub const BFD_RELOC_AARCH64_MOVW_GOTOFF_G1: bfd_reloc_code_real = 2020;
pub const BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC: bfd_reloc_code_real = 2019;
pub const BFD_RELOC_AARCH64_LD32_GOT_LO12_NC: bfd_reloc_code_real = 2018;
pub const BFD_RELOC_AARCH64_LD64_GOT_LO12_NC: bfd_reloc_code_real = 2017;
pub const BFD_RELOC_AARCH64_ADR_GOT_PAGE: bfd_reloc_code_real = 2016;
pub const BFD_RELOC_AARCH64_GOT_LD_PREL19: bfd_reloc_code_real = 2015;
pub const BFD_RELOC_AARCH64_LDST128_LO12: bfd_reloc_code_real = 2014;
pub const BFD_RELOC_AARCH64_LDST64_LO12: bfd_reloc_code_real = 2013;
pub const BFD_RELOC_AARCH64_LDST32_LO12: bfd_reloc_code_real = 2012;
pub const BFD_RELOC_AARCH64_LDST16_LO12: bfd_reloc_code_real = 2011;
pub const BFD_RELOC_AARCH64_CALL26: bfd_reloc_code_real = 2010;
pub const BFD_RELOC_AARCH64_JUMP26: bfd_reloc_code_real = 2009;
pub const BFD_RELOC_AARCH64_BRANCH19: bfd_reloc_code_real = 2008;
pub const BFD_RELOC_AARCH64_TSTBR14: bfd_reloc_code_real = 2007;
pub const BFD_RELOC_AARCH64_LDST8_LO12: bfd_reloc_code_real = 2006;
pub const BFD_RELOC_AARCH64_ADD_LO12: bfd_reloc_code_real = 2005;
pub const BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL: bfd_reloc_code_real = 2004;
pub const BFD_RELOC_AARCH64_ADR_HI21_PCREL: bfd_reloc_code_real = 2003;
pub const BFD_RELOC_AARCH64_ADR_LO21_PCREL: bfd_reloc_code_real = 2002;
pub const BFD_RELOC_AARCH64_LD_LO19_PCREL: bfd_reloc_code_real = 2001;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G3: bfd_reloc_code_real = 2000;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G2_NC: bfd_reloc_code_real = 1999;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G2: bfd_reloc_code_real = 1998;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G1_NC: bfd_reloc_code_real = 1997;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G1: bfd_reloc_code_real = 1996;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G0_NC: bfd_reloc_code_real = 1995;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G0: bfd_reloc_code_real = 1994;
pub const BFD_RELOC_AARCH64_MOVW_G2_S: bfd_reloc_code_real = 1993;
pub const BFD_RELOC_AARCH64_MOVW_G1_S: bfd_reloc_code_real = 1992;
pub const BFD_RELOC_AARCH64_MOVW_G0_S: bfd_reloc_code_real = 1991;
pub const BFD_RELOC_AARCH64_MOVW_G3: bfd_reloc_code_real = 1990;
pub const BFD_RELOC_AARCH64_MOVW_G2_NC: bfd_reloc_code_real = 1989;
pub const BFD_RELOC_AARCH64_MOVW_G2: bfd_reloc_code_real = 1988;
pub const BFD_RELOC_AARCH64_MOVW_G1_NC: bfd_reloc_code_real = 1987;
pub const BFD_RELOC_AARCH64_MOVW_G1: bfd_reloc_code_real = 1986;
pub const BFD_RELOC_AARCH64_MOVW_G0_NC: bfd_reloc_code_real = 1985;
pub const BFD_RELOC_AARCH64_MOVW_G0: bfd_reloc_code_real = 1984;
pub const BFD_RELOC_AARCH64_16_PCREL: bfd_reloc_code_real = 1983;
pub const BFD_RELOC_AARCH64_32_PCREL: bfd_reloc_code_real = 1982;
pub const BFD_RELOC_AARCH64_64_PCREL: bfd_reloc_code_real = 1981;
pub const BFD_RELOC_AARCH64_16: bfd_reloc_code_real = 1980;
pub const BFD_RELOC_AARCH64_32: bfd_reloc_code_real = 1979;
pub const BFD_RELOC_AARCH64_64: bfd_reloc_code_real = 1978;
pub const BFD_RELOC_AARCH64_NONE: bfd_reloc_code_real = 1977;
pub const BFD_RELOC_AARCH64_NULL: bfd_reloc_code_real = 1976;
pub const BFD_RELOC_AARCH64_RELOC_START: bfd_reloc_code_real = 1975;
pub const BFD_RELOC_MICROBLAZE_64_TEXTREL: bfd_reloc_code_real = 1974;
pub const BFD_RELOC_MICROBLAZE_64_TEXTPCREL: bfd_reloc_code_real = 1973;
pub const BFD_RELOC_MICROBLAZE_64_TLSTPREL: bfd_reloc_code_real = 1972;
pub const BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL: bfd_reloc_code_real = 1971;
pub const BFD_RELOC_MICROBLAZE_64_TLSDTPREL: bfd_reloc_code_real = 1970;
pub const BFD_RELOC_MICROBLAZE_32_TLSDTPREL: bfd_reloc_code_real = 1969;
pub const BFD_RELOC_MICROBLAZE_32_TLSDTPMOD: bfd_reloc_code_real = 1968;
pub const BFD_RELOC_MICROBLAZE_64_TLSLD: bfd_reloc_code_real = 1967;
pub const BFD_RELOC_MICROBLAZE_64_TLSGD: bfd_reloc_code_real = 1966;
pub const BFD_RELOC_MICROBLAZE_64_TLS: bfd_reloc_code_real = 1965;
pub const BFD_RELOC_MICROBLAZE_COPY: bfd_reloc_code_real = 1964;
pub const BFD_RELOC_MICROBLAZE_32_GOTOFF: bfd_reloc_code_real = 1963;
pub const BFD_RELOC_MICROBLAZE_64_GOTOFF: bfd_reloc_code_real = 1962;
pub const BFD_RELOC_MICROBLAZE_64_PLT: bfd_reloc_code_real = 1961;
pub const BFD_RELOC_MICROBLAZE_64_GOT: bfd_reloc_code_real = 1960;
pub const BFD_RELOC_MICROBLAZE_64_GOTPC: bfd_reloc_code_real = 1959;
pub const BFD_RELOC_MICROBLAZE_64_NONE: bfd_reloc_code_real = 1958;
pub const BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM: bfd_reloc_code_real = 1957;
pub const BFD_RELOC_MICROBLAZE_32_RWSDA: bfd_reloc_code_real = 1956;
pub const BFD_RELOC_MICROBLAZE_32_ROSDA: bfd_reloc_code_real = 1955;
pub const BFD_RELOC_MICROBLAZE_32_LO_PCREL: bfd_reloc_code_real = 1954;
pub const BFD_RELOC_MICROBLAZE_32_LO: bfd_reloc_code_real = 1953;
pub const BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT: bfd_reloc_code_real = 1952;
pub const BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12: bfd_reloc_code_real = 1951;
pub const BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21: bfd_reloc_code_real = 1950;
pub const BFD_RELOC_MACH_O_ARM64_ADDEND: bfd_reloc_code_real = 1949;
pub const BFD_RELOC_MACH_O_X86_64_TLV: bfd_reloc_code_real = 1948;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_4: bfd_reloc_code_real = 1947;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_2: bfd_reloc_code_real = 1946;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_1: bfd_reloc_code_real = 1945;
pub const BFD_RELOC_MACH_O_X86_64_GOT_LOAD: bfd_reloc_code_real = 1944;
pub const BFD_RELOC_MACH_O_X86_64_GOT: bfd_reloc_code_real = 1943;
pub const BFD_RELOC_MACH_O_X86_64_BRANCH8: bfd_reloc_code_real = 1942;
pub const BFD_RELOC_MACH_O_X86_64_BRANCH32: bfd_reloc_code_real = 1941;
pub const BFD_RELOC_MACH_O_SUBTRACTOR64: bfd_reloc_code_real = 1940;
pub const BFD_RELOC_MACH_O_SUBTRACTOR32: bfd_reloc_code_real = 1939;
pub const BFD_RELOC_MACH_O_PAIR: bfd_reloc_code_real = 1938;
pub const BFD_RELOC_MACH_O_LOCAL_SECTDIFF: bfd_reloc_code_real = 1937;
pub const BFD_RELOC_MACH_O_SECTDIFF: bfd_reloc_code_real = 1936;
pub const BFD_RELOC_LM32_RELATIVE: bfd_reloc_code_real = 1935;
pub const BFD_RELOC_LM32_JMP_SLOT: bfd_reloc_code_real = 1934;
pub const BFD_RELOC_LM32_GLOB_DAT: bfd_reloc_code_real = 1933;
pub const BFD_RELOC_LM32_COPY: bfd_reloc_code_real = 1932;
pub const BFD_RELOC_LM32_GOTOFF_LO16: bfd_reloc_code_real = 1931;
pub const BFD_RELOC_LM32_GOTOFF_HI16: bfd_reloc_code_real = 1930;
pub const BFD_RELOC_LM32_16_GOT: bfd_reloc_code_real = 1929;
pub const BFD_RELOC_LM32_BRANCH: bfd_reloc_code_real = 1928;
pub const BFD_RELOC_LM32_CALL: bfd_reloc_code_real = 1927;
pub const BFD_RELOC_Z8K_IMM4L: bfd_reloc_code_real = 1926;
pub const BFD_RELOC_Z8K_CALLR: bfd_reloc_code_real = 1925;
pub const BFD_RELOC_Z8K_DISP7: bfd_reloc_code_real = 1924;
pub const BFD_RELOC_Z80_16_BE: bfd_reloc_code_real = 1923;
pub const BFD_RELOC_Z80_WORD1: bfd_reloc_code_real = 1922;
pub const BFD_RELOC_Z80_WORD0: bfd_reloc_code_real = 1921;
pub const BFD_RELOC_Z80_BYTE3: bfd_reloc_code_real = 1920;
pub const BFD_RELOC_Z80_BYTE2: bfd_reloc_code_real = 1919;
pub const BFD_RELOC_Z80_BYTE1: bfd_reloc_code_real = 1918;
pub const BFD_RELOC_Z80_BYTE0: bfd_reloc_code_real = 1917;
pub const BFD_RELOC_Z80_DISP8: bfd_reloc_code_real = 1916;
pub const BFD_RELOC_XTENSA_NDIFF32: bfd_reloc_code_real = 1915;
pub const BFD_RELOC_XTENSA_NDIFF16: bfd_reloc_code_real = 1914;
pub const BFD_RELOC_XTENSA_NDIFF8: bfd_reloc_code_real = 1913;
pub const BFD_RELOC_XTENSA_PDIFF32: bfd_reloc_code_real = 1912;
pub const BFD_RELOC_XTENSA_PDIFF16: bfd_reloc_code_real = 1911;
pub const BFD_RELOC_XTENSA_PDIFF8: bfd_reloc_code_real = 1910;
pub const BFD_RELOC_XTENSA_TLS_CALL: bfd_reloc_code_real = 1909;
pub const BFD_RELOC_XTENSA_TLS_ARG: bfd_reloc_code_real = 1908;
pub const BFD_RELOC_XTENSA_TLS_FUNC: bfd_reloc_code_real = 1907;
pub const BFD_RELOC_XTENSA_TLS_TPOFF: bfd_reloc_code_real = 1906;
pub const BFD_RELOC_XTENSA_TLS_DTPOFF: bfd_reloc_code_real = 1905;
pub const BFD_RELOC_XTENSA_TLSDESC_ARG: bfd_reloc_code_real = 1904;
pub const BFD_RELOC_XTENSA_TLSDESC_FN: bfd_reloc_code_real = 1903;
pub const BFD_RELOC_XTENSA_ASM_SIMPLIFY: bfd_reloc_code_real = 1902;
pub const BFD_RELOC_XTENSA_ASM_EXPAND: bfd_reloc_code_real = 1901;
pub const BFD_RELOC_XTENSA_OP2: bfd_reloc_code_real = 1900;
pub const BFD_RELOC_XTENSA_OP1: bfd_reloc_code_real = 1899;
pub const BFD_RELOC_XTENSA_OP0: bfd_reloc_code_real = 1898;
pub const BFD_RELOC_XTENSA_SLOT14_ALT: bfd_reloc_code_real = 1897;
pub const BFD_RELOC_XTENSA_SLOT13_ALT: bfd_reloc_code_real = 1896;
pub const BFD_RELOC_XTENSA_SLOT12_ALT: bfd_reloc_code_real = 1895;
pub const BFD_RELOC_XTENSA_SLOT11_ALT: bfd_reloc_code_real = 1894;
pub const BFD_RELOC_XTENSA_SLOT10_ALT: bfd_reloc_code_real = 1893;
pub const BFD_RELOC_XTENSA_SLOT9_ALT: bfd_reloc_code_real = 1892;
pub const BFD_RELOC_XTENSA_SLOT8_ALT: bfd_reloc_code_real = 1891;
pub const BFD_RELOC_XTENSA_SLOT7_ALT: bfd_reloc_code_real = 1890;
pub const BFD_RELOC_XTENSA_SLOT6_ALT: bfd_reloc_code_real = 1889;
pub const BFD_RELOC_XTENSA_SLOT5_ALT: bfd_reloc_code_real = 1888;
pub const BFD_RELOC_XTENSA_SLOT4_ALT: bfd_reloc_code_real = 1887;
pub const BFD_RELOC_XTENSA_SLOT3_ALT: bfd_reloc_code_real = 1886;
pub const BFD_RELOC_XTENSA_SLOT2_ALT: bfd_reloc_code_real = 1885;
pub const BFD_RELOC_XTENSA_SLOT1_ALT: bfd_reloc_code_real = 1884;
pub const BFD_RELOC_XTENSA_SLOT0_ALT: bfd_reloc_code_real = 1883;
pub const BFD_RELOC_XTENSA_SLOT14_OP: bfd_reloc_code_real = 1882;
pub const BFD_RELOC_XTENSA_SLOT13_OP: bfd_reloc_code_real = 1881;
pub const BFD_RELOC_XTENSA_SLOT12_OP: bfd_reloc_code_real = 1880;
pub const BFD_RELOC_XTENSA_SLOT11_OP: bfd_reloc_code_real = 1879;
pub const BFD_RELOC_XTENSA_SLOT10_OP: bfd_reloc_code_real = 1878;
pub const BFD_RELOC_XTENSA_SLOT9_OP: bfd_reloc_code_real = 1877;
pub const BFD_RELOC_XTENSA_SLOT8_OP: bfd_reloc_code_real = 1876;
pub const BFD_RELOC_XTENSA_SLOT7_OP: bfd_reloc_code_real = 1875;
pub const BFD_RELOC_XTENSA_SLOT6_OP: bfd_reloc_code_real = 1874;
pub const BFD_RELOC_XTENSA_SLOT5_OP: bfd_reloc_code_real = 1873;
pub const BFD_RELOC_XTENSA_SLOT4_OP: bfd_reloc_code_real = 1872;
pub const BFD_RELOC_XTENSA_SLOT3_OP: bfd_reloc_code_real = 1871;
pub const BFD_RELOC_XTENSA_SLOT2_OP: bfd_reloc_code_real = 1870;
pub const BFD_RELOC_XTENSA_SLOT1_OP: bfd_reloc_code_real = 1869;
pub const BFD_RELOC_XTENSA_SLOT0_OP: bfd_reloc_code_real = 1868;
pub const BFD_RELOC_XTENSA_DIFF32: bfd_reloc_code_real = 1867;
pub const BFD_RELOC_XTENSA_DIFF16: bfd_reloc_code_real = 1866;
pub const BFD_RELOC_XTENSA_DIFF8: bfd_reloc_code_real = 1865;
pub const BFD_RELOC_XTENSA_PLT: bfd_reloc_code_real = 1864;
pub const BFD_RELOC_XTENSA_RELATIVE: bfd_reloc_code_real = 1863;
pub const BFD_RELOC_XTENSA_JMP_SLOT: bfd_reloc_code_real = 1862;
pub const BFD_RELOC_XTENSA_GLOB_DAT: bfd_reloc_code_real = 1861;
pub const BFD_RELOC_XTENSA_RTLD: bfd_reloc_code_real = 1860;
pub const BFD_RELOC_IQ2000_UHI16: bfd_reloc_code_real = 1859;
pub const BFD_RELOC_IQ2000_OFFSET_21: bfd_reloc_code_real = 1858;
pub const BFD_RELOC_IQ2000_OFFSET_16: bfd_reloc_code_real = 1857;
pub const BFD_RELOC_PRU_GNU_DIFF32_PMEM: bfd_reloc_code_real = 1856;
pub const BFD_RELOC_PRU_GNU_DIFF16_PMEM: bfd_reloc_code_real = 1855;
pub const BFD_RELOC_PRU_GNU_DIFF32: bfd_reloc_code_real = 1854;
pub const BFD_RELOC_PRU_GNU_DIFF16: bfd_reloc_code_real = 1853;
pub const BFD_RELOC_PRU_GNU_DIFF8: bfd_reloc_code_real = 1852;
pub const BFD_RELOC_PRU_16_PMEM: bfd_reloc_code_real = 1851;
pub const BFD_RELOC_PRU_32_PMEM: bfd_reloc_code_real = 1850;
pub const BFD_RELOC_PRU_U8_PCREL: bfd_reloc_code_real = 1849;
pub const BFD_RELOC_PRU_S10_PCREL: bfd_reloc_code_real = 1848;
pub const BFD_RELOC_PRU_LDI32: bfd_reloc_code_real = 1847;
pub const BFD_RELOC_PRU_U16_PMEMIMM: bfd_reloc_code_real = 1846;
pub const BFD_RELOC_PRU_U16: bfd_reloc_code_real = 1845;
pub const BFD_RELOC_NIOS2_R2_T1X1I6_2: bfd_reloc_code_real = 1844;
pub const BFD_RELOC_NIOS2_R2_T1X1I6: bfd_reloc_code_real = 1843;
pub const BFD_RELOC_NIOS2_R2_L5I4X1: bfd_reloc_code_real = 1842;
pub const BFD_RELOC_NIOS2_R2_F1I5_2: bfd_reloc_code_real = 1841;
pub const BFD_RELOC_NIOS2_R2_X2L5: bfd_reloc_code_real = 1840;
pub const BFD_RELOC_NIOS2_R2_X1I7_2: bfd_reloc_code_real = 1839;
pub const BFD_RELOC_NIOS2_R2_T2I4_2: bfd_reloc_code_real = 1838;
pub const BFD_RELOC_NIOS2_R2_T2I4_1: bfd_reloc_code_real = 1837;
pub const BFD_RELOC_NIOS2_R2_T2I4: bfd_reloc_code_real = 1836;
pub const BFD_RELOC_NIOS2_R2_T1I7_2: bfd_reloc_code_real = 1835;
pub const BFD_RELOC_NIOS2_R2_T1I7_1_PCREL: bfd_reloc_code_real = 1834;
pub const BFD_RELOC_NIOS2_R2_I10_1_PCREL: bfd_reloc_code_real = 1833;
pub const BFD_RELOC_NIOS2_R2_S12: bfd_reloc_code_real = 1832;
pub const BFD_RELOC_NIOS2_CALL_HA: bfd_reloc_code_real = 1831;
pub const BFD_RELOC_NIOS2_CALL_LO: bfd_reloc_code_real = 1830;
pub const BFD_RELOC_NIOS2_GOT_HA: bfd_reloc_code_real = 1829;
pub const BFD_RELOC_NIOS2_GOT_LO: bfd_reloc_code_real = 1828;
pub const BFD_RELOC_NIOS2_CALL26_NOAT: bfd_reloc_code_real = 1827;
pub const BFD_RELOC_NIOS2_GOTOFF: bfd_reloc_code_real = 1826;
pub const BFD_RELOC_NIOS2_RELATIVE: bfd_reloc_code_real = 1825;
pub const BFD_RELOC_NIOS2_JUMP_SLOT: bfd_reloc_code_real = 1824;
pub const BFD_RELOC_NIOS2_GLOB_DAT: bfd_reloc_code_real = 1823;
pub const BFD_RELOC_NIOS2_COPY: bfd_reloc_code_real = 1822;
pub const BFD_RELOC_NIOS2_TLS_TPREL: bfd_reloc_code_real = 1821;
pub const BFD_RELOC_NIOS2_TLS_DTPREL: bfd_reloc_code_real = 1820;
pub const BFD_RELOC_NIOS2_TLS_DTPMOD: bfd_reloc_code_real = 1819;
pub const BFD_RELOC_NIOS2_TLS_LE16: bfd_reloc_code_real = 1818;
pub const BFD_RELOC_NIOS2_TLS_IE16: bfd_reloc_code_real = 1817;
pub const BFD_RELOC_NIOS2_TLS_LDO16: bfd_reloc_code_real = 1816;
pub const BFD_RELOC_NIOS2_TLS_LDM16: bfd_reloc_code_real = 1815;
pub const BFD_RELOC_NIOS2_TLS_GD16: bfd_reloc_code_real = 1814;
pub const BFD_RELOC_NIOS2_PCREL_HA: bfd_reloc_code_real = 1813;
pub const BFD_RELOC_NIOS2_PCREL_LO: bfd_reloc_code_real = 1812;
pub const BFD_RELOC_NIOS2_GOTOFF_HA: bfd_reloc_code_real = 1811;
pub const BFD_RELOC_NIOS2_GOTOFF_LO: bfd_reloc_code_real = 1810;
pub const BFD_RELOC_NIOS2_CALL16: bfd_reloc_code_real = 1809;
pub const BFD_RELOC_NIOS2_GOT16: bfd_reloc_code_real = 1808;
pub const BFD_RELOC_NIOS2_ALIGN: bfd_reloc_code_real = 1807;
pub const BFD_RELOC_NIOS2_CALLR: bfd_reloc_code_real = 1806;
pub const BFD_RELOC_NIOS2_CJMP: bfd_reloc_code_real = 1805;
pub const BFD_RELOC_NIOS2_UJMP: bfd_reloc_code_real = 1804;
pub const BFD_RELOC_NIOS2_GPREL: bfd_reloc_code_real = 1803;
pub const BFD_RELOC_NIOS2_HIADJ16: bfd_reloc_code_real = 1802;
pub const BFD_RELOC_NIOS2_LO16: bfd_reloc_code_real = 1801;
pub const BFD_RELOC_NIOS2_HI16: bfd_reloc_code_real = 1800;
pub const BFD_RELOC_NIOS2_IMM8: bfd_reloc_code_real = 1799;
pub const BFD_RELOC_NIOS2_IMM6: bfd_reloc_code_real = 1798;
pub const BFD_RELOC_NIOS2_CACHE_OPX: bfd_reloc_code_real = 1797;
pub const BFD_RELOC_NIOS2_IMM5: bfd_reloc_code_real = 1796;
pub const BFD_RELOC_NIOS2_CALL26: bfd_reloc_code_real = 1795;
pub const BFD_RELOC_NIOS2_U16: bfd_reloc_code_real = 1794;
pub const BFD_RELOC_NIOS2_S16: bfd_reloc_code_real = 1793;
pub const BFD_RELOC_MSP430_SUB_ULEB128: bfd_reloc_code_real = 1792;
pub const BFD_RELOC_MSP430_SET_ULEB128: bfd_reloc_code_real = 1791;
pub const BFD_RELOC_MSP430_SYM_DIFF: bfd_reloc_code_real = 1790;
pub const BFD_RELOC_MSP430_PREL31: bfd_reloc_code_real = 1789;
pub const BFD_RELOC_MSP430_ABS_HI16: bfd_reloc_code_real = 1788;
pub const BFD_RELOC_MSP430X_ABS16: bfd_reloc_code_real = 1787;
pub const BFD_RELOC_MSP430X_PCR20_CALL: bfd_reloc_code_real = 1786;
pub const BFD_RELOC_MSP430X_PCR16: bfd_reloc_code_real = 1785;
pub const BFD_RELOC_MSP430X_ABS20_ADR_DST: bfd_reloc_code_real = 1784;
pub const BFD_RELOC_MSP430X_ABS20_ADR_SRC: bfd_reloc_code_real = 1783;
pub const BFD_RELOC_MSP430X_ABS20_EXT_ODST: bfd_reloc_code_real = 1782;
pub const BFD_RELOC_MSP430X_ABS20_EXT_DST: bfd_reloc_code_real = 1781;
pub const BFD_RELOC_MSP430X_ABS20_EXT_SRC: bfd_reloc_code_real = 1780;
pub const BFD_RELOC_MSP430X_PCR20_EXT_ODST: bfd_reloc_code_real = 1779;
pub const BFD_RELOC_MSP430X_PCR20_EXT_DST: bfd_reloc_code_real = 1778;
pub const BFD_RELOC_MSP430X_PCR20_EXT_SRC: bfd_reloc_code_real = 1777;
pub const BFD_RELOC_MSP430_ABS8: bfd_reloc_code_real = 1776;
pub const BFD_RELOC_MSP430_RL_PCREL: bfd_reloc_code_real = 1775;
pub const BFD_RELOC_MSP430_2X_PCREL: bfd_reloc_code_real = 1774;
pub const BFD_RELOC_MSP430_16_BYTE: bfd_reloc_code_real = 1773;
pub const BFD_RELOC_MSP430_16_PCREL_BYTE: bfd_reloc_code_real = 1772;
pub const BFD_RELOC_MSP430_16: bfd_reloc_code_real = 1771;
pub const BFD_RELOC_MSP430_16_PCREL: bfd_reloc_code_real = 1770;
pub const BFD_RELOC_MSP430_10_PCREL: bfd_reloc_code_real = 1769;
pub const BFD_RELOC_MT_PCINSN8: bfd_reloc_code_real = 1768;
pub const BFD_RELOC_MT_GNU_VTENTRY: bfd_reloc_code_real = 1767;
pub const BFD_RELOC_MT_GNU_VTINHERIT: bfd_reloc_code_real = 1766;
pub const BFD_RELOC_MT_LO16: bfd_reloc_code_real = 1765;
pub const BFD_RELOC_MT_HI16: bfd_reloc_code_real = 1764;
pub const BFD_RELOC_MT_PC16: bfd_reloc_code_real = 1763;
pub const BFD_RELOC_VAX_RELATIVE: bfd_reloc_code_real = 1762;
pub const BFD_RELOC_VAX_JMP_SLOT: bfd_reloc_code_real = 1761;
pub const BFD_RELOC_VAX_GLOB_DAT: bfd_reloc_code_real = 1760;
pub const BFD_RELOC_XC16X_SOF: bfd_reloc_code_real = 1759;
pub const BFD_RELOC_XC16X_SEG: bfd_reloc_code_real = 1758;
pub const BFD_RELOC_XC16X_POF: bfd_reloc_code_real = 1757;
pub const BFD_RELOC_XC16X_PAG: bfd_reloc_code_real = 1756;
pub const BFD_RELOC_RELC: bfd_reloc_code_real = 1755;
pub const BFD_RELOC_XSTORMY16_FPTR16: bfd_reloc_code_real = 1754;
pub const BFD_RELOC_XSTORMY16_24: bfd_reloc_code_real = 1753;
pub const BFD_RELOC_XSTORMY16_12: bfd_reloc_code_real = 1752;
pub const BFD_RELOC_XSTORMY16_REL_12: bfd_reloc_code_real = 1751;
pub const BFD_RELOC_H8_DISP32A16: bfd_reloc_code_real = 1750;
pub const BFD_RELOC_H8_DIR32A16: bfd_reloc_code_real = 1749;
pub const BFD_RELOC_H8_DIR24R8: bfd_reloc_code_real = 1748;
pub const BFD_RELOC_H8_DIR24A8: bfd_reloc_code_real = 1747;
pub const BFD_RELOC_H8_DIR16R8: bfd_reloc_code_real = 1746;
pub const BFD_RELOC_H8_DIR16A8: bfd_reloc_code_real = 1745;
pub const BFD_RELOC_OR1K_TLS_DTPMOD: bfd_reloc_code_real = 1744;
pub const BFD_RELOC_OR1K_TLS_DTPOFF: bfd_reloc_code_real = 1743;
pub const BFD_RELOC_OR1K_TLS_TPOFF: bfd_reloc_code_real = 1742;
pub const BFD_RELOC_OR1K_TLS_LE_SLO16: bfd_reloc_code_real = 1741;
pub const BFD_RELOC_OR1K_TLS_LE_LO16: bfd_reloc_code_real = 1740;
pub const BFD_RELOC_OR1K_TLS_LE_AHI16: bfd_reloc_code_real = 1739;
pub const BFD_RELOC_OR1K_TLS_LE_HI16: bfd_reloc_code_real = 1738;
pub const BFD_RELOC_OR1K_TLS_IE_LO13: bfd_reloc_code_real = 1737;
pub const BFD_RELOC_OR1K_TLS_IE_PG21: bfd_reloc_code_real = 1736;
pub const BFD_RELOC_OR1K_TLS_IE_LO16: bfd_reloc_code_real = 1735;
pub const BFD_RELOC_OR1K_TLS_IE_AHI16: bfd_reloc_code_real = 1734;
pub const BFD_RELOC_OR1K_TLS_IE_HI16: bfd_reloc_code_real = 1733;
pub const BFD_RELOC_OR1K_TLS_LDO_LO16: bfd_reloc_code_real = 1732;
pub const BFD_RELOC_OR1K_TLS_LDO_HI16: bfd_reloc_code_real = 1731;
pub const BFD_RELOC_OR1K_TLS_LDM_LO13: bfd_reloc_code_real = 1730;
pub const BFD_RELOC_OR1K_TLS_LDM_PG21: bfd_reloc_code_real = 1729;
pub const BFD_RELOC_OR1K_TLS_LDM_LO16: bfd_reloc_code_real = 1728;
pub const BFD_RELOC_OR1K_TLS_LDM_HI16: bfd_reloc_code_real = 1727;
pub const BFD_RELOC_OR1K_TLS_GD_LO13: bfd_reloc_code_real = 1726;
pub const BFD_RELOC_OR1K_TLS_GD_PG21: bfd_reloc_code_real = 1725;
pub const BFD_RELOC_OR1K_TLS_GD_LO16: bfd_reloc_code_real = 1724;
pub const BFD_RELOC_OR1K_TLS_GD_HI16: bfd_reloc_code_real = 1723;
pub const BFD_RELOC_OR1K_RELATIVE: bfd_reloc_code_real = 1722;
pub const BFD_RELOC_OR1K_JMP_SLOT: bfd_reloc_code_real = 1721;
pub const BFD_RELOC_OR1K_GLOB_DAT: bfd_reloc_code_real = 1720;
pub const BFD_RELOC_OR1K_COPY: bfd_reloc_code_real = 1719;
pub const BFD_RELOC_OR1K_GOTOFF_SLO16: bfd_reloc_code_real = 1718;
pub const BFD_RELOC_OR1K_PLTA26: bfd_reloc_code_real = 1717;
pub const BFD_RELOC_OR1K_PLT26: bfd_reloc_code_real = 1716;
pub const BFD_RELOC_OR1K_GOT_LO13: bfd_reloc_code_real = 1715;
pub const BFD_RELOC_OR1K_GOT_PG21: bfd_reloc_code_real = 1714;
pub const BFD_RELOC_OR1K_GOT16: bfd_reloc_code_real = 1713;
pub const BFD_RELOC_OR1K_GOT_AHI16: bfd_reloc_code_real = 1712;
pub const BFD_RELOC_OR1K_GOTPC_LO16: bfd_reloc_code_real = 1711;
pub const BFD_RELOC_OR1K_GOTPC_HI16: bfd_reloc_code_real = 1710;
pub const BFD_RELOC_OR1K_SLO13: bfd_reloc_code_real = 1709;
pub const BFD_RELOC_OR1K_LO13: bfd_reloc_code_real = 1708;
pub const BFD_RELOC_OR1K_PCREL_PG21: bfd_reloc_code_real = 1707;
pub const BFD_RELOC_OR1K_SLO16: bfd_reloc_code_real = 1706;
pub const BFD_RELOC_OR1K_REL_26: bfd_reloc_code_real = 1705;
pub const BFD_RELOC_CRIS_32_IE: bfd_reloc_code_real = 1704;
pub const BFD_RELOC_CRIS_DTPMOD: bfd_reloc_code_real = 1703;
pub const BFD_RELOC_CRIS_16_TPREL: bfd_reloc_code_real = 1702;
pub const BFD_RELOC_CRIS_32_TPREL: bfd_reloc_code_real = 1701;
pub const BFD_RELOC_CRIS_16_GOT_TPREL: bfd_reloc_code_real = 1700;
pub const BFD_RELOC_CRIS_32_GOT_TPREL: bfd_reloc_code_real = 1699;
pub const BFD_RELOC_CRIS_16_DTPREL: bfd_reloc_code_real = 1698;
pub const BFD_RELOC_CRIS_32_DTPREL: bfd_reloc_code_real = 1697;
pub const BFD_RELOC_CRIS_DTP: bfd_reloc_code_real = 1696;
pub const BFD_RELOC_CRIS_32_GD: bfd_reloc_code_real = 1695;
pub const BFD_RELOC_CRIS_16_GOT_GD: bfd_reloc_code_real = 1694;
pub const BFD_RELOC_CRIS_32_GOT_GD: bfd_reloc_code_real = 1693;
pub const BFD_RELOC_CRIS_32_PLT_PCREL: bfd_reloc_code_real = 1692;
pub const BFD_RELOC_CRIS_32_PLT_GOTREL: bfd_reloc_code_real = 1691;
pub const BFD_RELOC_CRIS_32_GOTREL: bfd_reloc_code_real = 1690;
pub const BFD_RELOC_CRIS_16_GOTPLT: bfd_reloc_code_real = 1689;
pub const BFD_RELOC_CRIS_32_GOTPLT: bfd_reloc_code_real = 1688;
pub const BFD_RELOC_CRIS_16_GOT: bfd_reloc_code_real = 1687;
pub const BFD_RELOC_CRIS_32_GOT: bfd_reloc_code_real = 1686;
pub const BFD_RELOC_CRIS_RELATIVE: bfd_reloc_code_real = 1685;
pub const BFD_RELOC_CRIS_JUMP_SLOT: bfd_reloc_code_real = 1684;
pub const BFD_RELOC_CRIS_GLOB_DAT: bfd_reloc_code_real = 1683;
pub const BFD_RELOC_CRIS_COPY: bfd_reloc_code_real = 1682;
pub const BFD_RELOC_CRIS_UNSIGNED_4: bfd_reloc_code_real = 1681;
pub const BFD_RELOC_CRIS_LAPCQ_OFFSET: bfd_reloc_code_real = 1680;
pub const BFD_RELOC_CRIS_UNSIGNED_16: bfd_reloc_code_real = 1679;
pub const BFD_RELOC_CRIS_SIGNED_16: bfd_reloc_code_real = 1678;
pub const BFD_RELOC_CRIS_UNSIGNED_8: bfd_reloc_code_real = 1677;
pub const BFD_RELOC_CRIS_SIGNED_8: bfd_reloc_code_real = 1676;
pub const BFD_RELOC_CRIS_UNSIGNED_6: bfd_reloc_code_real = 1675;
pub const BFD_RELOC_CRIS_SIGNED_6: bfd_reloc_code_real = 1674;
pub const BFD_RELOC_CRIS_UNSIGNED_5: bfd_reloc_code_real = 1673;
pub const BFD_RELOC_CRIS_BDISP8: bfd_reloc_code_real = 1672;
pub const BFD_RELOC_CRX_SWITCH32: bfd_reloc_code_real = 1671;
pub const BFD_RELOC_CRX_SWITCH16: bfd_reloc_code_real = 1670;
pub const BFD_RELOC_CRX_SWITCH8: bfd_reloc_code_real = 1669;
pub const BFD_RELOC_CRX_IMM32: bfd_reloc_code_real = 1668;
pub const BFD_RELOC_CRX_IMM16: bfd_reloc_code_real = 1667;
pub const BFD_RELOC_CRX_NUM32: bfd_reloc_code_real = 1666;
pub const BFD_RELOC_CRX_NUM16: bfd_reloc_code_real = 1665;
pub const BFD_RELOC_CRX_NUM8: bfd_reloc_code_real = 1664;
pub const BFD_RELOC_CRX_ABS32: bfd_reloc_code_real = 1663;
pub const BFD_RELOC_CRX_ABS16: bfd_reloc_code_real = 1662;
pub const BFD_RELOC_CRX_REGREL32: bfd_reloc_code_real = 1661;
pub const BFD_RELOC_CRX_REGREL28: bfd_reloc_code_real = 1660;
pub const BFD_RELOC_CRX_REGREL22: bfd_reloc_code_real = 1659;
pub const BFD_RELOC_CRX_REGREL12: bfd_reloc_code_real = 1658;
pub const BFD_RELOC_CRX_REL32: bfd_reloc_code_real = 1657;
pub const BFD_RELOC_CRX_REL24: bfd_reloc_code_real = 1656;
pub const BFD_RELOC_CRX_REL16: bfd_reloc_code_real = 1655;
pub const BFD_RELOC_CRX_REL8_CMP: bfd_reloc_code_real = 1654;
pub const BFD_RELOC_CRX_REL8: bfd_reloc_code_real = 1653;
pub const BFD_RELOC_CRX_REL4: bfd_reloc_code_real = 1652;
pub const BFD_RELOC_CR16_GLOB_DAT: bfd_reloc_code_real = 1651;
pub const BFD_RELOC_CR16_GOTC_REGREL20: bfd_reloc_code_real = 1650;
pub const BFD_RELOC_CR16_GOT_REGREL20: bfd_reloc_code_real = 1649;
pub const BFD_RELOC_CR16_SWITCH32: bfd_reloc_code_real = 1648;
pub const BFD_RELOC_CR16_SWITCH16: bfd_reloc_code_real = 1647;
pub const BFD_RELOC_CR16_SWITCH8: bfd_reloc_code_real = 1646;
pub const BFD_RELOC_CR16_DISP24a: bfd_reloc_code_real = 1645;
pub const BFD_RELOC_CR16_DISP24: bfd_reloc_code_real = 1644;
pub const BFD_RELOC_CR16_DISP20: bfd_reloc_code_real = 1643;
pub const BFD_RELOC_CR16_DISP16: bfd_reloc_code_real = 1642;
pub const BFD_RELOC_CR16_DISP8: bfd_reloc_code_real = 1641;
pub const BFD_RELOC_CR16_DISP4: bfd_reloc_code_real = 1640;
pub const BFD_RELOC_CR16_IMM32a: bfd_reloc_code_real = 1639;
pub const BFD_RELOC_CR16_IMM32: bfd_reloc_code_real = 1638;
pub const BFD_RELOC_CR16_IMM24: bfd_reloc_code_real = 1637;
pub const BFD_RELOC_CR16_IMM20: bfd_reloc_code_real = 1636;
pub const BFD_RELOC_CR16_IMM16: bfd_reloc_code_real = 1635;
pub const BFD_RELOC_CR16_IMM8: bfd_reloc_code_real = 1634;
pub const BFD_RELOC_CR16_IMM4: bfd_reloc_code_real = 1633;
pub const BFD_RELOC_CR16_ABS24: bfd_reloc_code_real = 1632;
pub const BFD_RELOC_CR16_ABS20: bfd_reloc_code_real = 1631;
pub const BFD_RELOC_CR16_REGREL20a: bfd_reloc_code_real = 1630;
pub const BFD_RELOC_CR16_REGREL20: bfd_reloc_code_real = 1629;
pub const BFD_RELOC_CR16_REGREL16: bfd_reloc_code_real = 1628;
pub const BFD_RELOC_CR16_REGREL14a: bfd_reloc_code_real = 1627;
pub const BFD_RELOC_CR16_REGREL14: bfd_reloc_code_real = 1626;
pub const BFD_RELOC_CR16_REGREL4a: bfd_reloc_code_real = 1625;
pub const BFD_RELOC_CR16_REGREL4: bfd_reloc_code_real = 1624;
pub const BFD_RELOC_CR16_REGREL0: bfd_reloc_code_real = 1623;
pub const BFD_RELOC_CR16_NUM32a: bfd_reloc_code_real = 1622;
pub const BFD_RELOC_CR16_NUM32: bfd_reloc_code_real = 1621;
pub const BFD_RELOC_CR16_NUM16: bfd_reloc_code_real = 1620;
pub const BFD_RELOC_CR16_NUM8: bfd_reloc_code_real = 1619;
pub const BFD_RELOC_S12Z_15_PCREL: bfd_reloc_code_real = 1618;
pub const BFD_RELOC_M68HC12_HI8XG: bfd_reloc_code_real = 1617;
pub const BFD_RELOC_M68HC12_LO8XG: bfd_reloc_code_real = 1616;
pub const BFD_RELOC_M68HC12_10_PCREL: bfd_reloc_code_real = 1615;
pub const BFD_RELOC_M68HC12_9_PCREL: bfd_reloc_code_real = 1614;
pub const BFD_RELOC_M68HC12_16B: bfd_reloc_code_real = 1613;
pub const BFD_RELOC_M68HC12_9B: bfd_reloc_code_real = 1612;
pub const BFD_RELOC_XGATE_IMM5: bfd_reloc_code_real = 1611;
pub const BFD_RELOC_XGATE_IMM4: bfd_reloc_code_real = 1610;
pub const BFD_RELOC_XGATE_IMM3: bfd_reloc_code_real = 1609;
pub const BFD_RELOC_XGATE_IMM8_HI: bfd_reloc_code_real = 1608;
pub const BFD_RELOC_XGATE_IMM8_LO: bfd_reloc_code_real = 1607;
pub const BFD_RELOC_XGATE_PCREL_10: bfd_reloc_code_real = 1606;
pub const BFD_RELOC_XGATE_PCREL_9: bfd_reloc_code_real = 1605;
pub const BFD_RELOC_XGATE_24: bfd_reloc_code_real = 1604;
pub const BFD_RELOC_XGATE_GPAGE: bfd_reloc_code_real = 1603;
pub const BFD_RELOC_XGATE_LO16: bfd_reloc_code_real = 1602;
pub const BFD_RELOC_XGATE_RL_GROUP: bfd_reloc_code_real = 1601;
pub const BFD_RELOC_XGATE_RL_JUMP: bfd_reloc_code_real = 1600;
pub const BFD_RELOC_M68HC12_5B: bfd_reloc_code_real = 1599;
pub const BFD_RELOC_M68HC11_24: bfd_reloc_code_real = 1598;
pub const BFD_RELOC_M68HC11_PAGE: bfd_reloc_code_real = 1597;
pub const BFD_RELOC_M68HC11_LO16: bfd_reloc_code_real = 1596;
pub const BFD_RELOC_M68HC11_RL_GROUP: bfd_reloc_code_real = 1595;
pub const BFD_RELOC_M68HC11_RL_JUMP: bfd_reloc_code_real = 1594;
pub const BFD_RELOC_M68HC11_3B: bfd_reloc_code_real = 1593;
pub const BFD_RELOC_M68HC11_LO8: bfd_reloc_code_real = 1592;
pub const BFD_RELOC_M68HC11_HI8: bfd_reloc_code_real = 1591;
pub const BFD_RELOC_IA64_LTOFF_DTPREL22: bfd_reloc_code_real = 1590;
pub const BFD_RELOC_IA64_DTPREL64LSB: bfd_reloc_code_real = 1589;
pub const BFD_RELOC_IA64_DTPREL64MSB: bfd_reloc_code_real = 1588;
pub const BFD_RELOC_IA64_DTPREL32LSB: bfd_reloc_code_real = 1587;
pub const BFD_RELOC_IA64_DTPREL32MSB: bfd_reloc_code_real = 1586;
pub const BFD_RELOC_IA64_DTPREL64I: bfd_reloc_code_real = 1585;
pub const BFD_RELOC_IA64_DTPREL22: bfd_reloc_code_real = 1584;
pub const BFD_RELOC_IA64_DTPREL14: bfd_reloc_code_real = 1583;
pub const BFD_RELOC_IA64_LTOFF_DTPMOD22: bfd_reloc_code_real = 1582;
pub const BFD_RELOC_IA64_DTPMOD64LSB: bfd_reloc_code_real = 1581;
pub const BFD_RELOC_IA64_DTPMOD64MSB: bfd_reloc_code_real = 1580;
pub const BFD_RELOC_IA64_LTOFF_TPREL22: bfd_reloc_code_real = 1579;
pub const BFD_RELOC_IA64_TPREL64LSB: bfd_reloc_code_real = 1578;
pub const BFD_RELOC_IA64_TPREL64MSB: bfd_reloc_code_real = 1577;
pub const BFD_RELOC_IA64_TPREL64I: bfd_reloc_code_real = 1576;
pub const BFD_RELOC_IA64_TPREL22: bfd_reloc_code_real = 1575;
pub const BFD_RELOC_IA64_TPREL14: bfd_reloc_code_real = 1574;
pub const BFD_RELOC_IA64_LDXMOV: bfd_reloc_code_real = 1573;
pub const BFD_RELOC_IA64_LTOFF22X: bfd_reloc_code_real = 1572;
pub const BFD_RELOC_IA64_COPY: bfd_reloc_code_real = 1571;
pub const BFD_RELOC_IA64_IPLTLSB: bfd_reloc_code_real = 1570;
pub const BFD_RELOC_IA64_IPLTMSB: bfd_reloc_code_real = 1569;
pub const BFD_RELOC_IA64_LTV64LSB: bfd_reloc_code_real = 1568;
pub const BFD_RELOC_IA64_LTV64MSB: bfd_reloc_code_real = 1567;
pub const BFD_RELOC_IA64_LTV32LSB: bfd_reloc_code_real = 1566;
pub const BFD_RELOC_IA64_LTV32MSB: bfd_reloc_code_real = 1565;
pub const BFD_RELOC_IA64_REL64LSB: bfd_reloc_code_real = 1564;
pub const BFD_RELOC_IA64_REL64MSB: bfd_reloc_code_real = 1563;
pub const BFD_RELOC_IA64_REL32LSB: bfd_reloc_code_real = 1562;
pub const BFD_RELOC_IA64_REL32MSB: bfd_reloc_code_real = 1561;
pub const BFD_RELOC_IA64_SECREL64LSB: bfd_reloc_code_real = 1560;
pub const BFD_RELOC_IA64_SECREL64MSB: bfd_reloc_code_real = 1559;
pub const BFD_RELOC_IA64_SECREL32LSB: bfd_reloc_code_real = 1558;
pub const BFD_RELOC_IA64_SECREL32MSB: bfd_reloc_code_real = 1557;
pub const BFD_RELOC_IA64_SEGREL64LSB: bfd_reloc_code_real = 1556;
pub const BFD_RELOC_IA64_SEGREL64MSB: bfd_reloc_code_real = 1555;
pub const BFD_RELOC_IA64_SEGREL32LSB: bfd_reloc_code_real = 1554;
pub const BFD_RELOC_IA64_SEGREL32MSB: bfd_reloc_code_real = 1553;
pub const BFD_RELOC_IA64_LTOFF_FPTR64LSB: bfd_reloc_code_real = 1552;
pub const BFD_RELOC_IA64_LTOFF_FPTR64MSB: bfd_reloc_code_real = 1551;
pub const BFD_RELOC_IA64_LTOFF_FPTR32LSB: bfd_reloc_code_real = 1550;
pub const BFD_RELOC_IA64_LTOFF_FPTR32MSB: bfd_reloc_code_real = 1549;
pub const BFD_RELOC_IA64_LTOFF_FPTR64I: bfd_reloc_code_real = 1548;
pub const BFD_RELOC_IA64_LTOFF_FPTR22: bfd_reloc_code_real = 1547;
pub const BFD_RELOC_IA64_PCREL64LSB: bfd_reloc_code_real = 1546;
pub const BFD_RELOC_IA64_PCREL64MSB: bfd_reloc_code_real = 1545;
pub const BFD_RELOC_IA64_PCREL32LSB: bfd_reloc_code_real = 1544;
pub const BFD_RELOC_IA64_PCREL32MSB: bfd_reloc_code_real = 1543;
pub const BFD_RELOC_IA64_PCREL64I: bfd_reloc_code_real = 1542;
pub const BFD_RELOC_IA64_PCREL60B: bfd_reloc_code_real = 1541;
pub const BFD_RELOC_IA64_PCREL22: bfd_reloc_code_real = 1540;
pub const BFD_RELOC_IA64_PCREL21F: bfd_reloc_code_real = 1539;
pub const BFD_RELOC_IA64_PCREL21M: bfd_reloc_code_real = 1538;
pub const BFD_RELOC_IA64_PCREL21BI: bfd_reloc_code_real = 1537;
pub const BFD_RELOC_IA64_PCREL21B: bfd_reloc_code_real = 1536;
pub const BFD_RELOC_IA64_FPTR64LSB: bfd_reloc_code_real = 1535;
pub const BFD_RELOC_IA64_FPTR64MSB: bfd_reloc_code_real = 1534;
pub const BFD_RELOC_IA64_FPTR32LSB: bfd_reloc_code_real = 1533;
pub const BFD_RELOC_IA64_FPTR32MSB: bfd_reloc_code_real = 1532;
pub const BFD_RELOC_IA64_FPTR64I: bfd_reloc_code_real = 1531;
pub const BFD_RELOC_IA64_PLTOFF64LSB: bfd_reloc_code_real = 1530;
pub const BFD_RELOC_IA64_PLTOFF64MSB: bfd_reloc_code_real = 1529;
pub const BFD_RELOC_IA64_PLTOFF64I: bfd_reloc_code_real = 1528;
pub const BFD_RELOC_IA64_PLTOFF22: bfd_reloc_code_real = 1527;
pub const BFD_RELOC_IA64_LTOFF64I: bfd_reloc_code_real = 1526;
pub const BFD_RELOC_IA64_LTOFF22: bfd_reloc_code_real = 1525;
pub const BFD_RELOC_IA64_GPREL64LSB: bfd_reloc_code_real = 1524;
pub const BFD_RELOC_IA64_GPREL64MSB: bfd_reloc_code_real = 1523;
pub const BFD_RELOC_IA64_GPREL32LSB: bfd_reloc_code_real = 1522;
pub const BFD_RELOC_IA64_GPREL32MSB: bfd_reloc_code_real = 1521;
pub const BFD_RELOC_IA64_GPREL64I: bfd_reloc_code_real = 1520;
pub const BFD_RELOC_IA64_GPREL22: bfd_reloc_code_real = 1519;
pub const BFD_RELOC_IA64_DIR64LSB: bfd_reloc_code_real = 1518;
pub const BFD_RELOC_IA64_DIR64MSB: bfd_reloc_code_real = 1517;
pub const BFD_RELOC_IA64_DIR32LSB: bfd_reloc_code_real = 1516;
pub const BFD_RELOC_IA64_DIR32MSB: bfd_reloc_code_real = 1515;
pub const BFD_RELOC_IA64_IMM64: bfd_reloc_code_real = 1514;
pub const BFD_RELOC_IA64_IMM22: bfd_reloc_code_real = 1513;
pub const BFD_RELOC_IA64_IMM14: bfd_reloc_code_real = 1512;
pub const BFD_RELOC_VTABLE_ENTRY: bfd_reloc_code_real = 1511;
pub const BFD_RELOC_VTABLE_INHERIT: bfd_reloc_code_real = 1510;
pub const BFD_RELOC_VPE4KMATH_INSN: bfd_reloc_code_real = 1509;
pub const BFD_RELOC_VPE4KMATH_DATA: bfd_reloc_code_real = 1508;
pub const BFD_RELOC_IP2K_FR_OFFSET: bfd_reloc_code_real = 1507;
pub const BFD_RELOC_IP2K_TEXT: bfd_reloc_code_real = 1506;
pub const BFD_RELOC_IP2K_PC_SKIP: bfd_reloc_code_real = 1505;
pub const BFD_RELOC_IP2K_HI8INSN: bfd_reloc_code_real = 1504;
pub const BFD_RELOC_IP2K_LO8INSN: bfd_reloc_code_real = 1503;
pub const BFD_RELOC_IP2K_EX8DATA: bfd_reloc_code_real = 1502;
pub const BFD_RELOC_IP2K_HI8DATA: bfd_reloc_code_real = 1501;
pub const BFD_RELOC_IP2K_LO8DATA: bfd_reloc_code_real = 1500;
pub const BFD_RELOC_IP2K_PAGE3: bfd_reloc_code_real = 1499;
pub const BFD_RELOC_IP2K_ADDR16CJP: bfd_reloc_code_real = 1498;
pub const BFD_RELOC_IP2K_BANK: bfd_reloc_code_real = 1497;
pub const BFD_RELOC_IP2K_FR9: bfd_reloc_code_real = 1496;
pub const BFD_RELOC_SCORE_DUMMY_HI16: bfd_reloc_code_real = 1495;
pub const BFD_RELOC_SCORE_CALL15: bfd_reloc_code_real = 1494;
pub const BFD_RELOC_SCORE_GOT_LO16: bfd_reloc_code_real = 1493;
pub const BFD_RELOC_SCORE_GOT15: bfd_reloc_code_real = 1492;
pub const BFD_RELOC_SCORE_BCMP: bfd_reloc_code_real = 1491;
pub const BFD_RELOC_SCORE16_BRANCH: bfd_reloc_code_real = 1490;
pub const BFD_RELOC_SCORE16_JMP: bfd_reloc_code_real = 1489;
pub const BFD_RELOC_SCORE_IMM32: bfd_reloc_code_real = 1488;
pub const BFD_RELOC_SCORE_IMM30: bfd_reloc_code_real = 1487;
pub const BFD_RELOC_SCORE_BRANCH: bfd_reloc_code_real = 1486;
pub const BFD_RELOC_SCORE_JMP: bfd_reloc_code_real = 1485;
pub const BFD_RELOC_SCORE_DUMMY2: bfd_reloc_code_real = 1484;
pub const BFD_RELOC_SCORE_GPREL15: bfd_reloc_code_real = 1483;
pub const BFD_RELOC_390_IRELATIVE: bfd_reloc_code_real = 1482;
pub const BFD_RELOC_390_TLS_GOTIE20: bfd_reloc_code_real = 1481;
pub const BFD_RELOC_390_GOTPLT20: bfd_reloc_code_real = 1480;
pub const BFD_RELOC_390_GOT20: bfd_reloc_code_real = 1479;
pub const BFD_RELOC_390_20: bfd_reloc_code_real = 1478;
pub const BFD_RELOC_390_TLS_TPOFF: bfd_reloc_code_real = 1477;
pub const BFD_RELOC_390_TLS_DTPOFF: bfd_reloc_code_real = 1476;
pub const BFD_RELOC_390_TLS_DTPMOD: bfd_reloc_code_real = 1475;
pub const BFD_RELOC_390_TLS_LDO64: bfd_reloc_code_real = 1474;
pub const BFD_RELOC_390_TLS_LDO32: bfd_reloc_code_real = 1473;
pub const BFD_RELOC_390_TLS_LE64: bfd_reloc_code_real = 1472;
pub const BFD_RELOC_390_TLS_LE32: bfd_reloc_code_real = 1471;
pub const BFD_RELOC_390_TLS_IEENT: bfd_reloc_code_real = 1470;
pub const BFD_RELOC_390_TLS_IE64: bfd_reloc_code_real = 1469;
pub const BFD_RELOC_390_TLS_IE32: bfd_reloc_code_real = 1468;
pub const BFD_RELOC_390_TLS_LDM64: bfd_reloc_code_real = 1467;
pub const BFD_RELOC_390_TLS_LDM32: bfd_reloc_code_real = 1466;
pub const BFD_RELOC_390_TLS_GOTIE64: bfd_reloc_code_real = 1465;
pub const BFD_RELOC_390_TLS_GOTIE32: bfd_reloc_code_real = 1464;
pub const BFD_RELOC_390_TLS_GOTIE12: bfd_reloc_code_real = 1463;
pub const BFD_RELOC_390_TLS_GD64: bfd_reloc_code_real = 1462;
pub const BFD_RELOC_390_TLS_GD32: bfd_reloc_code_real = 1461;
pub const BFD_RELOC_390_TLS_LDCALL: bfd_reloc_code_real = 1460;
pub const BFD_RELOC_390_TLS_GDCALL: bfd_reloc_code_real = 1459;
pub const BFD_RELOC_390_TLS_LOAD: bfd_reloc_code_real = 1458;
pub const BFD_RELOC_390_PLTOFF64: bfd_reloc_code_real = 1457;
pub const BFD_RELOC_390_PLTOFF32: bfd_reloc_code_real = 1456;
pub const BFD_RELOC_390_PLTOFF16: bfd_reloc_code_real = 1455;
pub const BFD_RELOC_390_GOTPLTENT: bfd_reloc_code_real = 1454;
pub const BFD_RELOC_390_GOTPLT64: bfd_reloc_code_real = 1453;
pub const BFD_RELOC_390_GOTPLT32: bfd_reloc_code_real = 1452;
pub const BFD_RELOC_390_GOTPLT16: bfd_reloc_code_real = 1451;
pub const BFD_RELOC_390_GOTPLT12: bfd_reloc_code_real = 1450;
pub const BFD_RELOC_390_GOTOFF64: bfd_reloc_code_real = 1449;
pub const BFD_RELOC_390_GOTENT: bfd_reloc_code_real = 1448;
pub const BFD_RELOC_390_PLT64: bfd_reloc_code_real = 1447;
pub const BFD_RELOC_390_GOT64: bfd_reloc_code_real = 1446;
pub const BFD_RELOC_390_GOTPCDBL: bfd_reloc_code_real = 1445;
pub const BFD_RELOC_390_PLT32DBL: bfd_reloc_code_real = 1444;
pub const BFD_RELOC_390_PC32DBL: bfd_reloc_code_real = 1443;
pub const BFD_RELOC_390_PLT24DBL: bfd_reloc_code_real = 1442;
pub const BFD_RELOC_390_PC24DBL: bfd_reloc_code_real = 1441;
pub const BFD_RELOC_390_PLT16DBL: bfd_reloc_code_real = 1440;
pub const BFD_RELOC_390_PC16DBL: bfd_reloc_code_real = 1439;
pub const BFD_RELOC_390_PLT12DBL: bfd_reloc_code_real = 1438;
pub const BFD_RELOC_390_PC12DBL: bfd_reloc_code_real = 1437;
pub const BFD_RELOC_390_GOT16: bfd_reloc_code_real = 1436;
pub const BFD_RELOC_390_GOTPC: bfd_reloc_code_real = 1435;
pub const BFD_RELOC_390_RELATIVE: bfd_reloc_code_real = 1434;
pub const BFD_RELOC_390_JMP_SLOT: bfd_reloc_code_real = 1433;
pub const BFD_RELOC_390_GLOB_DAT: bfd_reloc_code_real = 1432;
pub const BFD_RELOC_390_COPY: bfd_reloc_code_real = 1431;
pub const BFD_RELOC_390_PLT32: bfd_reloc_code_real = 1430;
pub const BFD_RELOC_390_GOT12: bfd_reloc_code_real = 1429;
pub const BFD_RELOC_390_12: bfd_reloc_code_real = 1428;
pub const BFD_RELOC_RX_RELAX: bfd_reloc_code_real = 1427;
pub const BFD_RELOC_RX_ABS16UL: bfd_reloc_code_real = 1426;
pub const BFD_RELOC_RX_ABS16UW: bfd_reloc_code_real = 1425;
pub const BFD_RELOC_RX_ABS16U: bfd_reloc_code_real = 1424;
pub const BFD_RELOC_RX_ABS32_REV: bfd_reloc_code_real = 1423;
pub const BFD_RELOC_RX_ABS32: bfd_reloc_code_real = 1422;
pub const BFD_RELOC_RX_ABS16_REV: bfd_reloc_code_real = 1421;
pub const BFD_RELOC_RX_ABS16: bfd_reloc_code_real = 1420;
pub const BFD_RELOC_RX_ABS8: bfd_reloc_code_real = 1419;
pub const BFD_RELOC_RX_OP_NEG: bfd_reloc_code_real = 1418;
pub const BFD_RELOC_RX_OP_SUBTRACT: bfd_reloc_code_real = 1417;
pub const BFD_RELOC_RX_SYM: bfd_reloc_code_real = 1416;
pub const BFD_RELOC_RX_GPRELL: bfd_reloc_code_real = 1415;
pub const BFD_RELOC_RX_GPRELW: bfd_reloc_code_real = 1414;
pub const BFD_RELOC_RX_GPRELB: bfd_reloc_code_real = 1413;
pub const BFD_RELOC_RX_DIFF: bfd_reloc_code_real = 1412;
pub const BFD_RELOC_RX_DIR3U_PCREL: bfd_reloc_code_real = 1411;
pub const BFD_RELOC_RX_24U: bfd_reloc_code_real = 1410;
pub const BFD_RELOC_RX_16U: bfd_reloc_code_real = 1409;
pub const BFD_RELOC_RX_8U: bfd_reloc_code_real = 1408;
pub const BFD_RELOC_RX_32_OP: bfd_reloc_code_real = 1407;
pub const BFD_RELOC_RX_24_OP: bfd_reloc_code_real = 1406;
pub const BFD_RELOC_RX_16_OP: bfd_reloc_code_real = 1405;
pub const BFD_RELOC_RX_NEG32: bfd_reloc_code_real = 1404;
pub const BFD_RELOC_RX_NEG24: bfd_reloc_code_real = 1403;
pub const BFD_RELOC_RX_NEG16: bfd_reloc_code_real = 1402;
pub const BFD_RELOC_RX_NEG8: bfd_reloc_code_real = 1401;
pub const BFD_RELOC_RL78_SADDR: bfd_reloc_code_real = 1400;
pub const BFD_RELOC_RL78_CODE: bfd_reloc_code_real = 1399;
pub const BFD_RELOC_RL78_LO16: bfd_reloc_code_real = 1398;
pub const BFD_RELOC_RL78_HI8: bfd_reloc_code_real = 1397;
pub const BFD_RELOC_RL78_HI16: bfd_reloc_code_real = 1396;
pub const BFD_RELOC_RL78_RELAX: bfd_reloc_code_real = 1395;
pub const BFD_RELOC_RL78_ABS16UL: bfd_reloc_code_real = 1394;
pub const BFD_RELOC_RL78_ABS16UW: bfd_reloc_code_real = 1393;
pub const BFD_RELOC_RL78_ABS16U: bfd_reloc_code_real = 1392;
pub const BFD_RELOC_RL78_ABS32_REV: bfd_reloc_code_real = 1391;
pub const BFD_RELOC_RL78_ABS32: bfd_reloc_code_real = 1390;
pub const BFD_RELOC_RL78_ABS16_REV: bfd_reloc_code_real = 1389;
pub const BFD_RELOC_RL78_ABS16: bfd_reloc_code_real = 1388;
pub const BFD_RELOC_RL78_ABS8: bfd_reloc_code_real = 1387;
pub const BFD_RELOC_RL78_OP_SHRA: bfd_reloc_code_real = 1386;
pub const BFD_RELOC_RL78_OP_AND: bfd_reloc_code_real = 1385;
pub const BFD_RELOC_RL78_OP_NEG: bfd_reloc_code_real = 1384;
pub const BFD_RELOC_RL78_OP_SUBTRACT: bfd_reloc_code_real = 1383;
pub const BFD_RELOC_RL78_SYM: bfd_reloc_code_real = 1382;
pub const BFD_RELOC_RL78_GPRELL: bfd_reloc_code_real = 1381;
pub const BFD_RELOC_RL78_GPRELW: bfd_reloc_code_real = 1380;
pub const BFD_RELOC_RL78_GPRELB: bfd_reloc_code_real = 1379;
pub const BFD_RELOC_RL78_DIFF: bfd_reloc_code_real = 1378;
pub const BFD_RELOC_RL78_DIR3U_PCREL: bfd_reloc_code_real = 1377;
pub const BFD_RELOC_RL78_24U: bfd_reloc_code_real = 1376;
pub const BFD_RELOC_RL78_16U: bfd_reloc_code_real = 1375;
pub const BFD_RELOC_RL78_8U: bfd_reloc_code_real = 1374;
pub const BFD_RELOC_RL78_32_OP: bfd_reloc_code_real = 1373;
pub const BFD_RELOC_RL78_24_OP: bfd_reloc_code_real = 1372;
pub const BFD_RELOC_RL78_16_OP: bfd_reloc_code_real = 1371;
pub const BFD_RELOC_RL78_NEG32: bfd_reloc_code_real = 1370;
pub const BFD_RELOC_RL78_NEG24: bfd_reloc_code_real = 1369;
pub const BFD_RELOC_RL78_NEG16: bfd_reloc_code_real = 1368;
pub const BFD_RELOC_RL78_NEG8: bfd_reloc_code_real = 1367;
pub const BFD_RELOC_RISCV_32_PCREL: bfd_reloc_code_real = 1366;
pub const BFD_RELOC_RISCV_SET32: bfd_reloc_code_real = 1365;
pub const BFD_RELOC_RISCV_SET16: bfd_reloc_code_real = 1364;
pub const BFD_RELOC_RISCV_SET8: bfd_reloc_code_real = 1363;
pub const BFD_RELOC_RISCV_SET6: bfd_reloc_code_real = 1362;
pub const BFD_RELOC_RISCV_SUB6: bfd_reloc_code_real = 1361;
pub const BFD_RELOC_RISCV_CFA: bfd_reloc_code_real = 1360;
pub const BFD_RELOC_RISCV_RELAX: bfd_reloc_code_real = 1359;
pub const BFD_RELOC_RISCV_TPREL_S: bfd_reloc_code_real = 1358;
pub const BFD_RELOC_RISCV_TPREL_I: bfd_reloc_code_real = 1357;
pub const BFD_RELOC_RISCV_GPREL_S: bfd_reloc_code_real = 1356;
pub const BFD_RELOC_RISCV_GPREL_I: bfd_reloc_code_real = 1355;
pub const BFD_RELOC_RISCV_RVC_LUI: bfd_reloc_code_real = 1354;
pub const BFD_RELOC_RISCV_RVC_JUMP: bfd_reloc_code_real = 1353;
pub const BFD_RELOC_RISCV_RVC_BRANCH: bfd_reloc_code_real = 1352;
pub const BFD_RELOC_RISCV_ALIGN: bfd_reloc_code_real = 1351;
pub const BFD_RELOC_RISCV_TLS_TPREL64: bfd_reloc_code_real = 1350;
pub const BFD_RELOC_RISCV_TLS_TPREL32: bfd_reloc_code_real = 1349;
pub const BFD_RELOC_RISCV_TLS_DTPREL64: bfd_reloc_code_real = 1348;
pub const BFD_RELOC_RISCV_TLS_DTPMOD64: bfd_reloc_code_real = 1347;
pub const BFD_RELOC_RISCV_TLS_DTPREL32: bfd_reloc_code_real = 1346;
pub const BFD_RELOC_RISCV_TLS_DTPMOD32: bfd_reloc_code_real = 1345;
pub const BFD_RELOC_RISCV_JMP: bfd_reloc_code_real = 1344;
pub const BFD_RELOC_RISCV_TLS_GD_HI20: bfd_reloc_code_real = 1343;
pub const BFD_RELOC_RISCV_TLS_GOT_HI20: bfd_reloc_code_real = 1342;
pub const BFD_RELOC_RISCV_GOT_HI20: bfd_reloc_code_real = 1341;
pub const BFD_RELOC_RISCV_SUB64: bfd_reloc_code_real = 1340;
pub const BFD_RELOC_RISCV_SUB32: bfd_reloc_code_real = 1339;
pub const BFD_RELOC_RISCV_SUB16: bfd_reloc_code_real = 1338;
pub const BFD_RELOC_RISCV_SUB8: bfd_reloc_code_real = 1337;
pub const BFD_RELOC_RISCV_ADD64: bfd_reloc_code_real = 1336;
pub const BFD_RELOC_RISCV_ADD32: bfd_reloc_code_real = 1335;
pub const BFD_RELOC_RISCV_ADD16: bfd_reloc_code_real = 1334;
pub const BFD_RELOC_RISCV_ADD8: bfd_reloc_code_real = 1333;
pub const BFD_RELOC_RISCV_CALL_PLT: bfd_reloc_code_real = 1332;
pub const BFD_RELOC_RISCV_CALL: bfd_reloc_code_real = 1331;
pub const BFD_RELOC_RISCV_TPREL_ADD: bfd_reloc_code_real = 1330;
pub const BFD_RELOC_RISCV_TPREL_LO12_S: bfd_reloc_code_real = 1329;
pub const BFD_RELOC_RISCV_TPREL_LO12_I: bfd_reloc_code_real = 1328;
pub const BFD_RELOC_RISCV_TPREL_HI20: bfd_reloc_code_real = 1327;
pub const BFD_RELOC_RISCV_GPREL12_S: bfd_reloc_code_real = 1326;
pub const BFD_RELOC_RISCV_GPREL12_I: bfd_reloc_code_real = 1325;
pub const BFD_RELOC_RISCV_LO12_S: bfd_reloc_code_real = 1324;
pub const BFD_RELOC_RISCV_LO12_I: bfd_reloc_code_real = 1323;
pub const BFD_RELOC_RISCV_PCREL_LO12_S: bfd_reloc_code_real = 1322;
pub const BFD_RELOC_RISCV_PCREL_LO12_I: bfd_reloc_code_real = 1321;
pub const BFD_RELOC_RISCV_PCREL_HI20: bfd_reloc_code_real = 1320;
pub const BFD_RELOC_RISCV_HI20: bfd_reloc_code_real = 1319;
pub const BFD_RELOC_AVR_PORT5: bfd_reloc_code_real = 1318;
pub const BFD_RELOC_AVR_PORT6: bfd_reloc_code_real = 1317;
pub const BFD_RELOC_AVR_LDS_STS_16: bfd_reloc_code_real = 1316;
pub const BFD_RELOC_AVR_DIFF32: bfd_reloc_code_real = 1315;
pub const BFD_RELOC_AVR_DIFF16: bfd_reloc_code_real = 1314;
pub const BFD_RELOC_AVR_DIFF8: bfd_reloc_code_real = 1313;
pub const BFD_RELOC_AVR_8_HLO: bfd_reloc_code_real = 1312;
pub const BFD_RELOC_AVR_8_HI: bfd_reloc_code_real = 1311;
pub const BFD_RELOC_AVR_8_LO: bfd_reloc_code_real = 1310;
pub const BFD_RELOC_AVR_6_ADIW: bfd_reloc_code_real = 1309;
pub const BFD_RELOC_AVR_6: bfd_reloc_code_real = 1308;
pub const BFD_RELOC_AVR_LDI: bfd_reloc_code_real = 1307;
pub const BFD_RELOC_AVR_CALL: bfd_reloc_code_real = 1306;
pub const BFD_RELOC_AVR_HH8_LDI_PM_NEG: bfd_reloc_code_real = 1305;
pub const BFD_RELOC_AVR_HI8_LDI_PM_NEG: bfd_reloc_code_real = 1304;
pub const BFD_RELOC_AVR_LO8_LDI_PM_NEG: bfd_reloc_code_real = 1303;
pub const BFD_RELOC_AVR_HH8_LDI_PM: bfd_reloc_code_real = 1302;
pub const BFD_RELOC_AVR_HI8_LDI_GS: bfd_reloc_code_real = 1301;
pub const BFD_RELOC_AVR_HI8_LDI_PM: bfd_reloc_code_real = 1300;
pub const BFD_RELOC_AVR_LO8_LDI_GS: bfd_reloc_code_real = 1299;
pub const BFD_RELOC_AVR_LO8_LDI_PM: bfd_reloc_code_real = 1298;
pub const BFD_RELOC_AVR_MS8_LDI_NEG: bfd_reloc_code_real = 1297;
pub const BFD_RELOC_AVR_HH8_LDI_NEG: bfd_reloc_code_real = 1296;
pub const BFD_RELOC_AVR_HI8_LDI_NEG: bfd_reloc_code_real = 1295;
pub const BFD_RELOC_AVR_LO8_LDI_NEG: bfd_reloc_code_real = 1294;
pub const BFD_RELOC_AVR_MS8_LDI: bfd_reloc_code_real = 1293;
pub const BFD_RELOC_AVR_HH8_LDI: bfd_reloc_code_real = 1292;
pub const BFD_RELOC_AVR_HI8_LDI: bfd_reloc_code_real = 1291;
pub const BFD_RELOC_AVR_LO8_LDI: bfd_reloc_code_real = 1290;
pub const BFD_RELOC_AVR_16_PM: bfd_reloc_code_real = 1289;
pub const BFD_RELOC_AVR_13_PCREL: bfd_reloc_code_real = 1288;
pub const BFD_RELOC_AVR_7_PCREL: bfd_reloc_code_real = 1287;
pub const BFD_RELOC_MMIX_LOCAL: bfd_reloc_code_real = 1286;
pub const BFD_RELOC_MMIX_BASE_PLUS_OFFSET: bfd_reloc_code_real = 1285;
pub const BFD_RELOC_MMIX_REG: bfd_reloc_code_real = 1284;
pub const BFD_RELOC_MMIX_REG_OR_BYTE: bfd_reloc_code_real = 1283;
pub const BFD_RELOC_MMIX_ADDR27: bfd_reloc_code_real = 1282;
pub const BFD_RELOC_MMIX_ADDR19: bfd_reloc_code_real = 1281;
pub const BFD_RELOC_MMIX_JMP_3: bfd_reloc_code_real = 1280;
pub const BFD_RELOC_MMIX_JMP_2: bfd_reloc_code_real = 1279;
pub const BFD_RELOC_MMIX_JMP_1: bfd_reloc_code_real = 1278;
pub const BFD_RELOC_MMIX_JMP: bfd_reloc_code_real = 1277;
pub const BFD_RELOC_MMIX_PUSHJ_STUBBABLE: bfd_reloc_code_real = 1276;
pub const BFD_RELOC_MMIX_PUSHJ_3: bfd_reloc_code_real = 1275;
pub const BFD_RELOC_MMIX_PUSHJ_2: bfd_reloc_code_real = 1274;
pub const BFD_RELOC_MMIX_PUSHJ_1: bfd_reloc_code_real = 1273;
pub const BFD_RELOC_MMIX_PUSHJ: bfd_reloc_code_real = 1272;
pub const BFD_RELOC_MMIX_CBRANCH_3: bfd_reloc_code_real = 1271;
pub const BFD_RELOC_MMIX_CBRANCH_2: bfd_reloc_code_real = 1270;
pub const BFD_RELOC_MMIX_CBRANCH_1: bfd_reloc_code_real = 1269;
pub const BFD_RELOC_MMIX_CBRANCH_J: bfd_reloc_code_real = 1268;
pub const BFD_RELOC_MMIX_CBRANCH: bfd_reloc_code_real = 1267;
pub const BFD_RELOC_MMIX_GETA_3: bfd_reloc_code_real = 1266;
pub const BFD_RELOC_MMIX_GETA_2: bfd_reloc_code_real = 1265;
pub const BFD_RELOC_MMIX_GETA_1: bfd_reloc_code_real = 1264;
pub const BFD_RELOC_MMIX_GETA: bfd_reloc_code_real = 1263;
pub const BFD_RELOC_METAG_TLS_LE_LO16: bfd_reloc_code_real = 1262;
pub const BFD_RELOC_METAG_TLS_LE_HI16: bfd_reloc_code_real = 1261;
pub const BFD_RELOC_METAG_TLS_LE: bfd_reloc_code_real = 1260;
pub const BFD_RELOC_METAG_TLS_DTPOFF: bfd_reloc_code_real = 1259;
pub const BFD_RELOC_METAG_TLS_DTPMOD: bfd_reloc_code_real = 1258;
pub const BFD_RELOC_METAG_TLS_TPOFF: bfd_reloc_code_real = 1257;
pub const BFD_RELOC_METAG_TLS_IENONPIC_LO16: bfd_reloc_code_real = 1256;
pub const BFD_RELOC_METAG_TLS_IENONPIC_HI16: bfd_reloc_code_real = 1255;
pub const BFD_RELOC_METAG_TLS_IENONPIC: bfd_reloc_code_real = 1254;
pub const BFD_RELOC_METAG_TLS_IE: bfd_reloc_code_real = 1253;
pub const BFD_RELOC_METAG_TLS_LDO: bfd_reloc_code_real = 1252;
pub const BFD_RELOC_METAG_TLS_LDO_LO16: bfd_reloc_code_real = 1251;
pub const BFD_RELOC_METAG_TLS_LDO_HI16: bfd_reloc_code_real = 1250;
pub const BFD_RELOC_METAG_TLS_LDM: bfd_reloc_code_real = 1249;
pub const BFD_RELOC_METAG_TLS_GD: bfd_reloc_code_real = 1248;
pub const BFD_RELOC_METAG_GLOB_DAT: bfd_reloc_code_real = 1247;
pub const BFD_RELOC_METAG_RELATIVE: bfd_reloc_code_real = 1246;
pub const BFD_RELOC_METAG_JMP_SLOT: bfd_reloc_code_real = 1245;
pub const BFD_RELOC_METAG_COPY: bfd_reloc_code_real = 1244;
pub const BFD_RELOC_METAG_PLT: bfd_reloc_code_real = 1243;
pub const BFD_RELOC_METAG_GOTOFF: bfd_reloc_code_real = 1242;
pub const BFD_RELOC_METAG_RELBRANCH_PLT: bfd_reloc_code_real = 1241;
pub const BFD_RELOC_METAG_LO16_PLT: bfd_reloc_code_real = 1240;
pub const BFD_RELOC_METAG_HI16_PLT: bfd_reloc_code_real = 1239;
pub const BFD_RELOC_METAG_LO16_GOTPC: bfd_reloc_code_real = 1238;
pub const BFD_RELOC_METAG_HI16_GOTPC: bfd_reloc_code_real = 1237;
pub const BFD_RELOC_METAG_GETSET_GOT: bfd_reloc_code_real = 1236;
pub const BFD_RELOC_METAG_GETSET_GOTOFF: bfd_reloc_code_real = 1235;
pub const BFD_RELOC_METAG_LO16_GOTOFF: bfd_reloc_code_real = 1234;
pub const BFD_RELOC_METAG_HI16_GOTOFF: bfd_reloc_code_real = 1233;
pub const BFD_RELOC_METAG_REL16: bfd_reloc_code_real = 1232;
pub const BFD_RELOC_METAG_REL8: bfd_reloc_code_real = 1231;
pub const BFD_RELOC_METAG_LOOG: bfd_reloc_code_real = 1230;
pub const BFD_RELOC_METAG_HIOG: bfd_reloc_code_real = 1229;
pub const BFD_RELOC_METAG_GETSETOFF: bfd_reloc_code_real = 1228;
pub const BFD_RELOC_METAG_RELBRANCH: bfd_reloc_code_real = 1227;
pub const BFD_RELOC_METAG_LOADDR16: bfd_reloc_code_real = 1226;
pub const BFD_RELOC_METAG_HIADDR16: bfd_reloc_code_real = 1225;
pub const BFD_RELOC_MEP_GNU_VTENTRY: bfd_reloc_code_real = 1224;
pub const BFD_RELOC_MEP_GNU_VTINHERIT: bfd_reloc_code_real = 1223;
pub const BFD_RELOC_MEP_ADDR24A4: bfd_reloc_code_real = 1222;
pub const BFD_RELOC_MEP_UIMM24: bfd_reloc_code_real = 1221;
pub const BFD_RELOC_MEP_TPREL7A4: bfd_reloc_code_real = 1220;
pub const BFD_RELOC_MEP_TPREL7A2: bfd_reloc_code_real = 1219;
pub const BFD_RELOC_MEP_TPREL7: bfd_reloc_code_real = 1218;
pub const BFD_RELOC_MEP_TPREL: bfd_reloc_code_real = 1217;
pub const BFD_RELOC_MEP_GPREL: bfd_reloc_code_real = 1216;
pub const BFD_RELOC_MEP_HI16S: bfd_reloc_code_real = 1215;
pub const BFD_RELOC_MEP_HI16U: bfd_reloc_code_real = 1214;
pub const BFD_RELOC_MEP_LOW16: bfd_reloc_code_real = 1213;
pub const BFD_RELOC_MEP_PCABS24A2: bfd_reloc_code_real = 1212;
pub const BFD_RELOC_MEP_PCREL24A2: bfd_reloc_code_real = 1211;
pub const BFD_RELOC_MEP_PCREL17A2: bfd_reloc_code_real = 1210;
pub const BFD_RELOC_MEP_PCREL12A2: bfd_reloc_code_real = 1209;
pub const BFD_RELOC_MEP_PCREL8A2: bfd_reloc_code_real = 1208;
pub const BFD_RELOC_MEP_32: bfd_reloc_code_real = 1207;
pub const BFD_RELOC_MEP_16: bfd_reloc_code_real = 1206;
pub const BFD_RELOC_MEP_8: bfd_reloc_code_real = 1205;
pub const BFD_RELOC_MCORE_RVA: bfd_reloc_code_real = 1204;
pub const BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2: bfd_reloc_code_real = 1203;
pub const BFD_RELOC_MCORE_PCREL_32: bfd_reloc_code_real = 1202;
pub const BFD_RELOC_MCORE_PCREL_IMM4BY2: bfd_reloc_code_real = 1201;
pub const BFD_RELOC_MCORE_PCREL_IMM11BY2: bfd_reloc_code_real = 1200;
pub const BFD_RELOC_MCORE_PCREL_IMM8BY4: bfd_reloc_code_real = 1199;
pub const BFD_RELOC_FR30_12_PCREL: bfd_reloc_code_real = 1198;
pub const BFD_RELOC_FR30_9_PCREL: bfd_reloc_code_real = 1197;
pub const BFD_RELOC_FR30_10_IN_8: bfd_reloc_code_real = 1196;
pub const BFD_RELOC_FR30_9_IN_8: bfd_reloc_code_real = 1195;
pub const BFD_RELOC_FR30_8_IN_8: bfd_reloc_code_real = 1194;
pub const BFD_RELOC_FR30_6_IN_4: bfd_reloc_code_real = 1193;
pub const BFD_RELOC_FR30_20: bfd_reloc_code_real = 1192;
pub const BFD_RELOC_FR30_48: bfd_reloc_code_real = 1191;
pub const BFD_RELOC_C6000_NOCMP: bfd_reloc_code_real = 1190;
pub const BFD_RELOC_C6000_FPHEAD: bfd_reloc_code_real = 1189;
pub const BFD_RELOC_C6000_ALIGN: bfd_reloc_code_real = 1188;
pub const BFD_RELOC_C6000_PCR_L16: bfd_reloc_code_real = 1187;
pub const BFD_RELOC_C6000_PCR_H16: bfd_reloc_code_real = 1186;
pub const BFD_RELOC_C6000_EHTYPE: bfd_reloc_code_real = 1185;
pub const BFD_RELOC_C6000_JUMP_SLOT: bfd_reloc_code_real = 1184;
pub const BFD_RELOC_C6000_COPY: bfd_reloc_code_real = 1183;
pub const BFD_RELOC_C6000_PREL31: bfd_reloc_code_real = 1182;
pub const BFD_RELOC_C6000_DSBT_INDEX: bfd_reloc_code_real = 1181;
pub const BFD_RELOC_C6000_SBR_GOT_H16_W: bfd_reloc_code_real = 1180;
pub const BFD_RELOC_C6000_SBR_GOT_L16_W: bfd_reloc_code_real = 1179;
pub const BFD_RELOC_C6000_SBR_GOT_U15_W: bfd_reloc_code_real = 1178;
pub const BFD_RELOC_C6000_SBR_H16_W: bfd_reloc_code_real = 1177;
pub const BFD_RELOC_C6000_SBR_H16_H: bfd_reloc_code_real = 1176;
pub const BFD_RELOC_C6000_SBR_H16_B: bfd_reloc_code_real = 1175;
pub const BFD_RELOC_C6000_SBR_L16_W: bfd_reloc_code_real = 1174;
pub const BFD_RELOC_C6000_SBR_L16_H: bfd_reloc_code_real = 1173;
pub const BFD_RELOC_C6000_SBR_L16_B: bfd_reloc_code_real = 1172;
pub const BFD_RELOC_C6000_SBR_S16: bfd_reloc_code_real = 1171;
pub const BFD_RELOC_C6000_SBR_U15_W: bfd_reloc_code_real = 1170;
pub const BFD_RELOC_C6000_SBR_U15_H: bfd_reloc_code_real = 1169;
pub const BFD_RELOC_C6000_SBR_U15_B: bfd_reloc_code_real = 1168;
pub const BFD_RELOC_C6000_ABS_H16: bfd_reloc_code_real = 1167;
pub const BFD_RELOC_C6000_ABS_L16: bfd_reloc_code_real = 1166;
pub const BFD_RELOC_C6000_ABS_S16: bfd_reloc_code_real = 1165;
pub const BFD_RELOC_C6000_PCR_S7: bfd_reloc_code_real = 1164;
pub const BFD_RELOC_C6000_PCR_S10: bfd_reloc_code_real = 1163;
pub const BFD_RELOC_C6000_PCR_S12: bfd_reloc_code_real = 1162;
pub const BFD_RELOC_C6000_PCR_S21: bfd_reloc_code_real = 1161;
pub const BFD_RELOC_TIC54X_MS7_OF_23: bfd_reloc_code_real = 1160;
pub const BFD_RELOC_TIC54X_16_OF_23: bfd_reloc_code_real = 1159;
pub const BFD_RELOC_TIC54X_23: bfd_reloc_code_real = 1158;
pub const BFD_RELOC_TIC54X_PARTMS9: bfd_reloc_code_real = 1157;
pub const BFD_RELOC_TIC54X_PARTLS7: bfd_reloc_code_real = 1156;
pub const BFD_RELOC_TIC30_LDP: bfd_reloc_code_real = 1155;
pub const BFD_RELOC_V850_DATA: bfd_reloc_code_real = 1154;
pub const BFD_RELOC_V850_CODE: bfd_reloc_code_real = 1153;
pub const BFD_RELOC_V850_32_GOTOFF: bfd_reloc_code_real = 1152;
pub const BFD_RELOC_V850_16_GOTOFF: bfd_reloc_code_real = 1151;
pub const BFD_RELOC_V850_RELATIVE: bfd_reloc_code_real = 1150;
pub const BFD_RELOC_V850_JMP_SLOT: bfd_reloc_code_real = 1149;
pub const BFD_RELOC_V850_GLOB_DAT: bfd_reloc_code_real = 1148;
pub const BFD_RELOC_V850_COPY: bfd_reloc_code_real = 1147;
pub const BFD_RELOC_V850_32_PLT_PCREL: bfd_reloc_code_real = 1146;
pub const BFD_RELOC_V850_22_PLT_PCREL: bfd_reloc_code_real = 1145;
pub const BFD_RELOC_V850_32_GOT: bfd_reloc_code_real = 1144;
pub const BFD_RELOC_V850_16_GOT: bfd_reloc_code_real = 1143;
pub const BFD_RELOC_V850_32_GOTPCREL: bfd_reloc_code_real = 1142;
pub const BFD_RELOC_V850_CALLT_15_16_OFFSET: bfd_reloc_code_real = 1141;
pub const BFD_RELOC_V850_LO16_S1: bfd_reloc_code_real = 1140;
pub const BFD_RELOC_V850_16_S1: bfd_reloc_code_real = 1139;
pub const BFD_RELOC_V850_16_SPLIT_OFFSET: bfd_reloc_code_real = 1138;
pub const BFD_RELOC_V850_32_ABS: bfd_reloc_code_real = 1137;
pub const BFD_RELOC_V850_32_PCREL: bfd_reloc_code_real = 1136;
pub const BFD_RELOC_V850_23: bfd_reloc_code_real = 1135;
pub const BFD_RELOC_V850_17_PCREL: bfd_reloc_code_real = 1134;
pub const BFD_RELOC_V850_16_PCREL: bfd_reloc_code_real = 1133;
pub const BFD_RELOC_V850_LO16_SPLIT_OFFSET: bfd_reloc_code_real = 1132;
pub const BFD_RELOC_V850_ALIGN: bfd_reloc_code_real = 1131;
pub const BFD_RELOC_V850_LONGJUMP: bfd_reloc_code_real = 1130;
pub const BFD_RELOC_V850_LONGCALL: bfd_reloc_code_real = 1129;
pub const BFD_RELOC_V850_CALLT_16_16_OFFSET: bfd_reloc_code_real = 1128;
pub const BFD_RELOC_V850_CALLT_6_7_OFFSET: bfd_reloc_code_real = 1127;
pub const BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET: bfd_reloc_code_real = 1126;
pub const BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET: bfd_reloc_code_real = 1125;
pub const BFD_RELOC_V850_TDA_4_4_OFFSET: bfd_reloc_code_real = 1124;
pub const BFD_RELOC_V850_TDA_4_5_OFFSET: bfd_reloc_code_real = 1123;
pub const BFD_RELOC_V850_TDA_16_16_OFFSET: bfd_reloc_code_real = 1122;
pub const BFD_RELOC_V850_TDA_7_7_OFFSET: bfd_reloc_code_real = 1121;
pub const BFD_RELOC_V850_TDA_7_8_OFFSET: bfd_reloc_code_real = 1120;
pub const BFD_RELOC_V850_TDA_6_8_OFFSET: bfd_reloc_code_real = 1119;
pub const BFD_RELOC_V850_ZDA_15_16_OFFSET: bfd_reloc_code_real = 1118;
pub const BFD_RELOC_V850_ZDA_16_16_OFFSET: bfd_reloc_code_real = 1117;
pub const BFD_RELOC_V850_SDA_15_16_OFFSET: bfd_reloc_code_real = 1116;
pub const BFD_RELOC_V850_SDA_16_16_OFFSET: bfd_reloc_code_real = 1115;
pub const BFD_RELOC_V850_22_PCREL: bfd_reloc_code_real = 1114;
pub const BFD_RELOC_V850_9_PCREL: bfd_reloc_code_real = 1113;
pub const BFD_RELOC_NDS32_LSI: bfd_reloc_code_real = 1112;
pub const BFD_RELOC_NDS32_GROUP: bfd_reloc_code_real = 1111;
pub const BFD_RELOC_NDS32_REMOVE: bfd_reloc_code_real = 1110;
pub const BFD_RELOC_NDS32_TLS_DESC_MEM: bfd_reloc_code_real = 1109;
pub const BFD_RELOC_NDS32_TLS_DESC_CALL: bfd_reloc_code_real = 1108;
pub const BFD_RELOC_NDS32_TLS_DESC_FUNC: bfd_reloc_code_real = 1107;
pub const BFD_RELOC_NDS32_TLS_DESC_ADD: bfd_reloc_code_real = 1106;
pub const BFD_RELOC_NDS32_TLS_DESC_SDA17S2: bfd_reloc_code_real = 1105;
pub const BFD_RELOC_NDS32_TLS_DESC_20: bfd_reloc_code_real = 1104;
pub const BFD_RELOC_NDS32_TLS_DESC_LO12: bfd_reloc_code_real = 1103;
pub const BFD_RELOC_NDS32_TLS_DESC_HI20: bfd_reloc_code_real = 1102;
pub const BFD_RELOC_NDS32_TLS_DESC: bfd_reloc_code_real = 1101;
pub const BFD_RELOC_NDS32_TLS_IEGP_LW: bfd_reloc_code_real = 1100;
pub const BFD_RELOC_NDS32_TLS_IEGP_LO12S2: bfd_reloc_code_real = 1099;
pub const BFD_RELOC_NDS32_TLS_IEGP_LO12: bfd_reloc_code_real = 1098;
pub const BFD_RELOC_NDS32_TLS_IEGP_HI20: bfd_reloc_code_real = 1097;
pub const BFD_RELOC_NDS32_TLS_IE_LO12S2: bfd_reloc_code_real = 1096;
pub const BFD_RELOC_NDS32_TLS_IE_LO12: bfd_reloc_code_real = 1095;
pub const BFD_RELOC_NDS32_TLS_IE_HI20: bfd_reloc_code_real = 1094;
pub const BFD_RELOC_NDS32_TLS_LE_LS: bfd_reloc_code_real = 1093;
pub const BFD_RELOC_NDS32_TLS_LE_ADD: bfd_reloc_code_real = 1092;
pub const BFD_RELOC_NDS32_TLS_LE_15S2: bfd_reloc_code_real = 1091;
pub const BFD_RELOC_NDS32_TLS_LE_15S1: bfd_reloc_code_real = 1090;
pub const BFD_RELOC_NDS32_TLS_LE_15S0: bfd_reloc_code_real = 1089;
pub const BFD_RELOC_NDS32_TLS_LE_20: bfd_reloc_code_real = 1088;
pub const BFD_RELOC_NDS32_TLS_LE_LO12: bfd_reloc_code_real = 1087;
pub const BFD_RELOC_NDS32_TLS_LE_HI20: bfd_reloc_code_real = 1086;
pub const BFD_RELOC_NDS32_GOTTPOFF: bfd_reloc_code_real = 1085;
pub const BFD_RELOC_NDS32_TPOFF: bfd_reloc_code_real = 1084;
pub const BFD_RELOC_NDS32_10IFCU_PCREL: bfd_reloc_code_real = 1083;
pub const BFD_RELOC_NDS32_17IFC_PCREL: bfd_reloc_code_real = 1082;
pub const BFD_RELOC_NDS32_TRAN: bfd_reloc_code_real = 1081;
pub const BFD_RELOC_NDS32_DATA: bfd_reloc_code_real = 1080;
pub const BFD_RELOC_NDS32_25_ABS: bfd_reloc_code_real = 1079;
pub const BFD_RELOC_NDS32_EMPTY: bfd_reloc_code_real = 1078;
pub const BFD_RELOC_NDS32_DIFF_ULEB128: bfd_reloc_code_real = 1077;
pub const BFD_RELOC_NDS32_DIFF32: bfd_reloc_code_real = 1076;
pub const BFD_RELOC_NDS32_DIFF16: bfd_reloc_code_real = 1075;
pub const BFD_RELOC_NDS32_DIFF8: bfd_reloc_code_real = 1074;
pub const BFD_RELOC_NDS32_SUBTRAHEND: bfd_reloc_code_real = 1073;
pub const BFD_RELOC_NDS32_MINUEND: bfd_reloc_code_real = 1072;
pub const BFD_RELOC_NDS32_RELAX_REGION_END: bfd_reloc_code_real = 1071;
pub const BFD_RELOC_NDS32_RELAX_REGION_BEGIN: bfd_reloc_code_real = 1070;
pub const BFD_RELOC_NDS32_PLTBLOCK: bfd_reloc_code_real = 1069;
pub const BFD_RELOC_NDS32_PTR_RESOLVED: bfd_reloc_code_real = 1068;
pub const BFD_RELOC_NDS32_PTR_COUNT: bfd_reloc_code_real = 1067;
pub const BFD_RELOC_NDS32_PTR: bfd_reloc_code_real = 1066;
pub const BFD_RELOC_NDS32_MULCALL_SUFF: bfd_reloc_code_real = 1065;
pub const BFD_RELOC_NDS32_PLT_GOT_SUFF: bfd_reloc_code_real = 1064;
pub const BFD_RELOC_NDS32_GOTOFF_SUFF: bfd_reloc_code_real = 1063;
pub const BFD_RELOC_NDS32_GOT_SUFF: bfd_reloc_code_real = 1062;
pub const BFD_RELOC_NDS32_RELAX_ENTRY: bfd_reloc_code_real = 1061;
pub const BFD_RELOC_NDS32_SDA_FP7U2_RELA: bfd_reloc_code_real = 1060;
pub const BFD_RELOC_NDS32_10_UPCREL: bfd_reloc_code_real = 1059;
pub const BFD_RELOC_NDS32_5: bfd_reloc_code_real = 1058;
pub const BFD_RELOC_NDS32_GOT17S2: bfd_reloc_code_real = 1057;
pub const BFD_RELOC_NDS32_GOT15S2: bfd_reloc_code_real = 1056;
pub const BFD_RELOC_NDS32_GOTOFF_LO19: bfd_reloc_code_real = 1055;
pub const BFD_RELOC_NDS32_GOTOFF_LO15: bfd_reloc_code_real = 1054;
pub const BFD_RELOC_NDS32_GOT_LO19: bfd_reloc_code_real = 1053;
pub const BFD_RELOC_NDS32_GOT_LO15: bfd_reloc_code_real = 1052;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO19: bfd_reloc_code_real = 1051;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO15: bfd_reloc_code_real = 1050;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO20: bfd_reloc_code_real = 1049;
pub const BFD_RELOC_NDS32_UPDATE_TA: bfd_reloc_code_real = 1048;
pub const BFD_RELOC_NDS32_DWARF2_LEB: bfd_reloc_code_real = 1047;
pub const BFD_RELOC_NDS32_DWARF2_OP2: bfd_reloc_code_real = 1046;
pub const BFD_RELOC_NDS32_DWARF2_OP1: bfd_reloc_code_real = 1045;
pub const BFD_RELOC_NDS32_LO12S2_SP: bfd_reloc_code_real = 1044;
pub const BFD_RELOC_NDS32_LO12S2_DP: bfd_reloc_code_real = 1043;
pub const BFD_RELOC_NDS32_SDA12S2_SP: bfd_reloc_code_real = 1042;
pub const BFD_RELOC_NDS32_SDA12S2_DP: bfd_reloc_code_real = 1041;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO12: bfd_reloc_code_real = 1040;
pub const BFD_RELOC_NDS32_PLT_GOTREL_HI20: bfd_reloc_code_real = 1039;
pub const BFD_RELOC_NDS32_PLTREL_LO12: bfd_reloc_code_real = 1038;
pub const BFD_RELOC_NDS32_PLTREL_HI20: bfd_reloc_code_real = 1037;
pub const BFD_RELOC_NDS32_LONGJUMP7: bfd_reloc_code_real = 1036;
pub const BFD_RELOC_NDS32_LONGJUMP6: bfd_reloc_code_real = 1035;
pub const BFD_RELOC_NDS32_LONGJUMP5: bfd_reloc_code_real = 1034;
pub const BFD_RELOC_NDS32_LONGJUMP4: bfd_reloc_code_real = 1033;
pub const BFD_RELOC_NDS32_LONGCALL6: bfd_reloc_code_real = 1032;
pub const BFD_RELOC_NDS32_LONGCALL5: bfd_reloc_code_real = 1031;
pub const BFD_RELOC_NDS32_LONGCALL4: bfd_reloc_code_real = 1030;
pub const BFD_RELOC_NDS32_25_FIXED: bfd_reloc_code_real = 1029;
pub const BFD_RELOC_NDS32_17_FIXED: bfd_reloc_code_real = 1028;
pub const BFD_RELOC_NDS32_15_FIXED: bfd_reloc_code_real = 1027;
pub const BFD_RELOC_NDS32_9_FIXED: bfd_reloc_code_real = 1026;
pub const BFD_RELOC_NDS32_LOADSTORE: bfd_reloc_code_real = 1025;
pub const BFD_RELOC_NDS32_LONGJUMP3: bfd_reloc_code_real = 1024;
pub const BFD_RELOC_NDS32_LONGJUMP2: bfd_reloc_code_real = 1023;
pub const BFD_RELOC_NDS32_LONGJUMP1: bfd_reloc_code_real = 1022;
pub const BFD_RELOC_NDS32_LONGCALL3: bfd_reloc_code_real = 1021;
pub const BFD_RELOC_NDS32_LONGCALL2: bfd_reloc_code_real = 1020;
pub const BFD_RELOC_NDS32_LONGCALL1: bfd_reloc_code_real = 1019;
pub const BFD_RELOC_NDS32_LABEL: bfd_reloc_code_real = 1018;
pub const BFD_RELOC_NDS32_INSN16: bfd_reloc_code_real = 1017;
pub const BFD_RELOC_NDS32_GOTPC_LO12: bfd_reloc_code_real = 1016;
pub const BFD_RELOC_NDS32_GOTPC_HI20: bfd_reloc_code_real = 1015;
pub const BFD_RELOC_NDS32_GOT_LO12: bfd_reloc_code_real = 1014;
pub const BFD_RELOC_NDS32_GOT_HI20: bfd_reloc_code_real = 1013;
pub const BFD_RELOC_NDS32_GOTPC20: bfd_reloc_code_real = 1012;
pub const BFD_RELOC_NDS32_GOTOFF_LO12: bfd_reloc_code_real = 1011;
pub const BFD_RELOC_NDS32_GOTOFF_HI20: bfd_reloc_code_real = 1010;
pub const BFD_RELOC_NDS32_GOTOFF: bfd_reloc_code_real = 1009;
pub const BFD_RELOC_NDS32_RELATIVE: bfd_reloc_code_real = 1008;
pub const BFD_RELOC_NDS32_JMP_SLOT: bfd_reloc_code_real = 1007;
pub const BFD_RELOC_NDS32_GLOB_DAT: bfd_reloc_code_real = 1006;
pub const BFD_RELOC_NDS32_COPY: bfd_reloc_code_real = 1005;
pub const BFD_RELOC_NDS32_25_PLTREL: bfd_reloc_code_real = 1004;
pub const BFD_RELOC_NDS32_9_PLTREL: bfd_reloc_code_real = 1003;
pub const BFD_RELOC_NDS32_GOT20: bfd_reloc_code_real = 1002;
pub const BFD_RELOC_NDS32_SDA19S0: bfd_reloc_code_real = 1001;
pub const BFD_RELOC_NDS32_SDA18S1: bfd_reloc_code_real = 1000;
pub const BFD_RELOC_NDS32_SDA17S2: bfd_reloc_code_real = 999;
pub const BFD_RELOC_NDS32_SDA16S3: bfd_reloc_code_real = 998;
pub const BFD_RELOC_NDS32_SDA15S0: bfd_reloc_code_real = 997;
pub const BFD_RELOC_NDS32_SDA15S1: bfd_reloc_code_real = 996;
pub const BFD_RELOC_NDS32_SDA15S2: bfd_reloc_code_real = 995;
pub const BFD_RELOC_NDS32_SDA15S3: bfd_reloc_code_real = 994;
pub const BFD_RELOC_NDS32_LO12S0_ORI: bfd_reloc_code_real = 993;
pub const BFD_RELOC_NDS32_LO12S0: bfd_reloc_code_real = 992;
pub const BFD_RELOC_NDS32_LO12S1: bfd_reloc_code_real = 991;
pub const BFD_RELOC_NDS32_LO12S2: bfd_reloc_code_real = 990;
pub const BFD_RELOC_NDS32_LO12S3: bfd_reloc_code_real = 989;
pub const BFD_RELOC_NDS32_HI20: bfd_reloc_code_real = 988;
pub const BFD_RELOC_NDS32_25_PCREL: bfd_reloc_code_real = 987;
pub const BFD_RELOC_NDS32_17_PCREL: bfd_reloc_code_real = 986;
pub const BFD_RELOC_NDS32_15_PCREL: bfd_reloc_code_real = 985;
pub const BFD_RELOC_NDS32_WORD_9_PCREL: bfd_reloc_code_real = 984;
pub const BFD_RELOC_NDS32_9_PCREL: bfd_reloc_code_real = 983;
pub const BFD_RELOC_NDS32_20: bfd_reloc_code_real = 982;
pub const BFD_RELOC_M32R_GOTPC_LO: bfd_reloc_code_real = 981;
pub const BFD_RELOC_M32R_GOTPC_HI_SLO: bfd_reloc_code_real = 980;
pub const BFD_RELOC_M32R_GOTPC_HI_ULO: bfd_reloc_code_real = 979;
pub const BFD_RELOC_M32R_GOT16_LO: bfd_reloc_code_real = 978;
pub const BFD_RELOC_M32R_GOT16_HI_SLO: bfd_reloc_code_real = 977;
pub const BFD_RELOC_M32R_GOT16_HI_ULO: bfd_reloc_code_real = 976;
pub const BFD_RELOC_M32R_GOTPC24: bfd_reloc_code_real = 975;
pub const BFD_RELOC_M32R_GOTOFF_LO: bfd_reloc_code_real = 974;
pub const BFD_RELOC_M32R_GOTOFF_HI_SLO: bfd_reloc_code_real = 973;
pub const BFD_RELOC_M32R_GOTOFF_HI_ULO: bfd_reloc_code_real = 972;
pub const BFD_RELOC_M32R_GOTOFF: bfd_reloc_code_real = 971;
pub const BFD_RELOC_M32R_RELATIVE: bfd_reloc_code_real = 970;
pub const BFD_RELOC_M32R_JMP_SLOT: bfd_reloc_code_real = 969;
pub const BFD_RELOC_M32R_GLOB_DAT: bfd_reloc_code_real = 968;
pub const BFD_RELOC_M32R_COPY: bfd_reloc_code_real = 967;
pub const BFD_RELOC_M32R_26_PLTREL: bfd_reloc_code_real = 966;
pub const BFD_RELOC_M32R_GOT24: bfd_reloc_code_real = 965;
pub const BFD_RELOC_M32R_SDA16: bfd_reloc_code_real = 964;
pub const BFD_RELOC_M32R_LO16: bfd_reloc_code_real = 963;
pub const BFD_RELOC_M32R_HI16_SLO: bfd_reloc_code_real = 962;
pub const BFD_RELOC_M32R_HI16_ULO: bfd_reloc_code_real = 961;
pub const BFD_RELOC_M32R_26_PCREL: bfd_reloc_code_real = 960;
pub const BFD_RELOC_M32R_18_PCREL: bfd_reloc_code_real = 959;
pub const BFD_RELOC_M32R_10_PCREL: bfd_reloc_code_real = 958;
pub const BFD_RELOC_M32R_24: bfd_reloc_code_real = 957;
pub const BFD_RELOC_M32C_RL_2ADDR: bfd_reloc_code_real = 956;
pub const BFD_RELOC_M32C_RL_1ADDR: bfd_reloc_code_real = 955;
pub const BFD_RELOC_M32C_RL_JUMP: bfd_reloc_code_real = 954;
pub const BFD_RELOC_M32C_HI8: bfd_reloc_code_real = 953;
pub const BFD_RELOC_DLX_JMP26: bfd_reloc_code_real = 952;
pub const BFD_RELOC_DLX_LO16: bfd_reloc_code_real = 951;
pub const BFD_RELOC_DLX_HI16_S: bfd_reloc_code_real = 950;
pub const BFD_RELOC_D30V_32_PCREL: bfd_reloc_code_real = 949;
pub const BFD_RELOC_D30V_32: bfd_reloc_code_real = 948;
pub const BFD_RELOC_D30V_21_PCREL_R: bfd_reloc_code_real = 947;
pub const BFD_RELOC_D30V_21_PCREL: bfd_reloc_code_real = 946;
pub const BFD_RELOC_D30V_21: bfd_reloc_code_real = 945;
pub const BFD_RELOC_D30V_15_PCREL_R: bfd_reloc_code_real = 944;
pub const BFD_RELOC_D30V_15_PCREL: bfd_reloc_code_real = 943;
pub const BFD_RELOC_D30V_15: bfd_reloc_code_real = 942;
pub const BFD_RELOC_D30V_9_PCREL_R: bfd_reloc_code_real = 941;
pub const BFD_RELOC_D30V_9_PCREL: bfd_reloc_code_real = 940;
pub const BFD_RELOC_D30V_6: bfd_reloc_code_real = 939;
pub const BFD_RELOC_D10V_18_PCREL: bfd_reloc_code_real = 938;
pub const BFD_RELOC_D10V_18: bfd_reloc_code_real = 937;
pub const BFD_RELOC_D10V_10_PCREL_L: bfd_reloc_code_real = 936;
pub const BFD_RELOC_D10V_10_PCREL_R: bfd_reloc_code_real = 935;
pub const BFD_ARELOC_BFIN_ADDR: bfd_reloc_code_real = 934;
pub const BFD_ARELOC_BFIN_HWPAGE: bfd_reloc_code_real = 933;
pub const BFD_ARELOC_BFIN_PAGE: bfd_reloc_code_real = 932;
pub const BFD_ARELOC_BFIN_COMP: bfd_reloc_code_real = 931;
pub const BFD_ARELOC_BFIN_NEG: bfd_reloc_code_real = 930;
pub const BFD_ARELOC_BFIN_LEN: bfd_reloc_code_real = 929;
pub const BFD_ARELOC_BFIN_LOR: bfd_reloc_code_real = 928;
pub const BFD_ARELOC_BFIN_LAND: bfd_reloc_code_real = 927;
pub const BFD_ARELOC_BFIN_XOR: bfd_reloc_code_real = 926;
pub const BFD_ARELOC_BFIN_OR: bfd_reloc_code_real = 925;
pub const BFD_ARELOC_BFIN_AND: bfd_reloc_code_real = 924;
pub const BFD_ARELOC_BFIN_RSHIFT: bfd_reloc_code_real = 923;
pub const BFD_ARELOC_BFIN_LSHIFT: bfd_reloc_code_real = 922;
pub const BFD_ARELOC_BFIN_MOD: bfd_reloc_code_real = 921;
pub const BFD_ARELOC_BFIN_DIV: bfd_reloc_code_real = 920;
pub const BFD_ARELOC_BFIN_MULT: bfd_reloc_code_real = 919;
pub const BFD_ARELOC_BFIN_SUB: bfd_reloc_code_real = 918;
pub const BFD_ARELOC_BFIN_ADD: bfd_reloc_code_real = 917;
pub const BFD_ARELOC_BFIN_CONST: bfd_reloc_code_real = 916;
pub const BFD_ARELOC_BFIN_PUSH: bfd_reloc_code_real = 915;
pub const BFD_RELOC_BFIN_PLTPC: bfd_reloc_code_real = 914;
pub const BFD_RELOC_BFIN_GOT: bfd_reloc_code_real = 913;
pub const BFD_RELOC_BFIN_GOTOFFLO: bfd_reloc_code_real = 912;
pub const BFD_RELOC_BFIN_GOTOFFHI: bfd_reloc_code_real = 911;
pub const BFD_RELOC_BFIN_GOTOFF17M4: bfd_reloc_code_real = 910;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO: bfd_reloc_code_real = 909;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI: bfd_reloc_code_real = 908;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4: bfd_reloc_code_real = 907;
pub const BFD_RELOC_BFIN_FUNCDESC_VALUE: bfd_reloc_code_real = 906;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTLO: bfd_reloc_code_real = 905;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTHI: bfd_reloc_code_real = 904;
pub const BFD_RELOC_BFIN_FUNCDESC_GOT17M4: bfd_reloc_code_real = 903;
pub const BFD_RELOC_BFIN_FUNCDESC: bfd_reloc_code_real = 902;
pub const BFD_RELOC_BFIN_GOTLO: bfd_reloc_code_real = 901;
pub const BFD_RELOC_BFIN_GOTHI: bfd_reloc_code_real = 900;
pub const BFD_RELOC_BFIN_GOT17M4: bfd_reloc_code_real = 899;
pub const BFD_RELOC_BFIN_24_PCREL_JUMP_L: bfd_reloc_code_real = 898;
pub const BFD_RELOC_BFIN_24_PCREL_CALL_X: bfd_reloc_code_real = 897;
pub const BFD_RELOC_BFIN_12_PCREL_JUMP_S: bfd_reloc_code_real = 896;
pub const BFD_RELOC_BFIN_12_PCREL_JUMP: bfd_reloc_code_real = 895;
pub const BFD_RELOC_BFIN_11_PCREL: bfd_reloc_code_real = 894;
pub const BFD_RELOC_BFIN_10_PCREL: bfd_reloc_code_real = 893;
pub const BFD_RELOC_BFIN_16_LOW: bfd_reloc_code_real = 892;
pub const BFD_RELOC_BFIN_5_PCREL: bfd_reloc_code_real = 891;
pub const BFD_RELOC_BFIN_4_PCREL: bfd_reloc_code_real = 890;
pub const BFD_RELOC_BFIN_16_HIGH: bfd_reloc_code_real = 889;
pub const BFD_RELOC_BFIN_16_IMM: bfd_reloc_code_real = 888;
pub const BFD_RELOC_ARC_JLI_SECTOFF: bfd_reloc_code_real = 887;
pub const BFD_RELOC_ARC_NPS_CMEM16: bfd_reloc_code_real = 886;
pub const BFD_RELOC_ARC_S21H_PCREL_PLT: bfd_reloc_code_real = 885;
pub const BFD_RELOC_ARC_S25W_PCREL_PLT: bfd_reloc_code_real = 884;
pub const BFD_RELOC_ARC_TLS_LE_32: bfd_reloc_code_real = 883;
pub const BFD_RELOC_ARC_TLS_LE_S9: bfd_reloc_code_real = 882;
pub const BFD_RELOC_ARC_TLS_DTPOFF_S9: bfd_reloc_code_real = 881;
pub const BFD_RELOC_ARC_TLS_DTPOFF: bfd_reloc_code_real = 880;
pub const BFD_RELOC_ARC_TLS_IE_GOT: bfd_reloc_code_real = 879;
pub const BFD_RELOC_ARC_TLS_GD_CALL: bfd_reloc_code_real = 878;
pub const BFD_RELOC_ARC_TLS_GD_LD: bfd_reloc_code_real = 877;
pub const BFD_RELOC_ARC_TLS_GD_GOT: bfd_reloc_code_real = 876;
pub const BFD_RELOC_ARC_TLS_TPOFF: bfd_reloc_code_real = 875;
pub const BFD_RELOC_ARC_TLS_DTPMOD: bfd_reloc_code_real = 874;
pub const BFD_RELOC_ARC_S25H_PCREL_PLT: bfd_reloc_code_real = 873;
pub const BFD_RELOC_ARC_S21W_PCREL_PLT: bfd_reloc_code_real = 872;
pub const BFD_RELOC_ARC_GOTPC: bfd_reloc_code_real = 871;
pub const BFD_RELOC_ARC_GOTOFF: bfd_reloc_code_real = 870;
pub const BFD_RELOC_ARC_RELATIVE: bfd_reloc_code_real = 869;
pub const BFD_RELOC_ARC_JMP_SLOT: bfd_reloc_code_real = 868;
pub const BFD_RELOC_ARC_GLOB_DAT: bfd_reloc_code_real = 867;
pub const BFD_RELOC_ARC_COPY: bfd_reloc_code_real = 866;
pub const BFD_RELOC_ARC_PLT32: bfd_reloc_code_real = 865;
pub const BFD_RELOC_ARC_GOTPC32: bfd_reloc_code_real = 864;
pub const BFD_RELOC_ARC_GOT32: bfd_reloc_code_real = 863;
pub const BFD_RELOC_ARC_PC32: bfd_reloc_code_real = 862;
pub const BFD_RELOC_ARC_32_PCREL: bfd_reloc_code_real = 861;
pub const BFD_RELOC_ARC_SDA16_ST2: bfd_reloc_code_real = 860;
pub const BFD_RELOC_ARC_SDA_12: bfd_reloc_code_real = 859;
pub const BFD_RELOC_ARC_SECTOFF_2: bfd_reloc_code_real = 858;
pub const BFD_RELOC_ARC_SECTOFF_1: bfd_reloc_code_real = 857;
pub const BFD_RELOC_ARC_SECTOFF_ME_2: bfd_reloc_code_real = 856;
pub const BFD_RELOC_ARC_SECTOFF_ME_1: bfd_reloc_code_real = 855;
pub const BFD_RELOC_AC_SECTOFF_S9_2: bfd_reloc_code_real = 854;
pub const BFD_RELOC_AC_SECTOFF_S9_1: bfd_reloc_code_real = 853;
pub const BFD_RELOC_AC_SECTOFF_S9: bfd_reloc_code_real = 852;
pub const BFD_RELOC_AC_SECTOFF_U8_2: bfd_reloc_code_real = 851;
pub const BFD_RELOC_AC_SECTOFF_U8_1: bfd_reloc_code_real = 850;
pub const BFD_RELOC_AC_SECTOFF_U8: bfd_reloc_code_real = 849;
pub const BFD_RELOC_ARC_W_ME: bfd_reloc_code_real = 848;
pub const BFD_RELOC_ARC_SDA32_ME: bfd_reloc_code_real = 847;
pub const BFD_RELOC_ARC_SECTOFF_ME: bfd_reloc_code_real = 846;
pub const BFD_RELOC_ARC_N32_ME: bfd_reloc_code_real = 845;
pub const BFD_RELOC_ARC_32_ME_S: bfd_reloc_code_real = 844;
pub const BFD_RELOC_ARC_32_ME: bfd_reloc_code_real = 843;
pub const BFD_RELOC_ARC_W: bfd_reloc_code_real = 842;
pub const BFD_RELOC_ARC_S13_PCREL: bfd_reloc_code_real = 841;
pub const BFD_RELOC_ARC_SDA16_LD2: bfd_reloc_code_real = 840;
pub const BFD_RELOC_ARC_SDA16_LD1: bfd_reloc_code_real = 839;
pub const BFD_RELOC_ARC_SDA16_LD: bfd_reloc_code_real = 838;
pub const BFD_RELOC_ARC_SDA_LDST2: bfd_reloc_code_real = 837;
pub const BFD_RELOC_ARC_SDA_LDST1: bfd_reloc_code_real = 836;
pub const BFD_RELOC_ARC_SDA_LDST: bfd_reloc_code_real = 835;
pub const BFD_RELOC_ARC_SDA32: bfd_reloc_code_real = 834;
pub const BFD_RELOC_ARC_S25W_PCREL: bfd_reloc_code_real = 833;
pub const BFD_RELOC_ARC_S25H_PCREL: bfd_reloc_code_real = 832;
pub const BFD_RELOC_ARC_S21W_PCREL: bfd_reloc_code_real = 831;
pub const BFD_RELOC_ARC_S21H_PCREL: bfd_reloc_code_real = 830;
pub const BFD_RELOC_ARC_SECTOFF: bfd_reloc_code_real = 829;
pub const BFD_RELOC_ARC_SDA: bfd_reloc_code_real = 828;
pub const BFD_RELOC_ARC_N32: bfd_reloc_code_real = 827;
pub const BFD_RELOC_ARC_N24: bfd_reloc_code_real = 826;
pub const BFD_RELOC_ARC_N16: bfd_reloc_code_real = 825;
pub const BFD_RELOC_ARC_N8: bfd_reloc_code_real = 824;
pub const BFD_RELOC_ARC_32: bfd_reloc_code_real = 823;
pub const BFD_RELOC_ARC_24: bfd_reloc_code_real = 822;
pub const BFD_RELOC_ARC_16: bfd_reloc_code_real = 821;
pub const BFD_RELOC_ARC_8: bfd_reloc_code_real = 820;
pub const BFD_RELOC_ARC_NONE: bfd_reloc_code_real = 819;
pub const BFD_RELOC_SH_FUNCDESC: bfd_reloc_code_real = 818;
pub const BFD_RELOC_SH_GOTOFFFUNCDESC20: bfd_reloc_code_real = 817;
pub const BFD_RELOC_SH_GOTOFFFUNCDESC: bfd_reloc_code_real = 816;
pub const BFD_RELOC_SH_GOTFUNCDESC20: bfd_reloc_code_real = 815;
pub const BFD_RELOC_SH_GOTFUNCDESC: bfd_reloc_code_real = 814;
pub const BFD_RELOC_SH_GOTOFF20: bfd_reloc_code_real = 813;
pub const BFD_RELOC_SH_GOT20: bfd_reloc_code_real = 812;
pub const BFD_RELOC_SH_TLS_TPOFF32: bfd_reloc_code_real = 811;
pub const BFD_RELOC_SH_TLS_DTPOFF32: bfd_reloc_code_real = 810;
pub const BFD_RELOC_SH_TLS_DTPMOD32: bfd_reloc_code_real = 809;
pub const BFD_RELOC_SH_TLS_LE_32: bfd_reloc_code_real = 808;
pub const BFD_RELOC_SH_TLS_IE_32: bfd_reloc_code_real = 807;
pub const BFD_RELOC_SH_TLS_LDO_32: bfd_reloc_code_real = 806;
pub const BFD_RELOC_SH_TLS_LD_32: bfd_reloc_code_real = 805;
pub const BFD_RELOC_SH_TLS_GD_32: bfd_reloc_code_real = 804;
pub const BFD_RELOC_SH_PT_16: bfd_reloc_code_real = 803;
pub const BFD_RELOC_SH_IMM_HI16_PCREL: bfd_reloc_code_real = 802;
pub const BFD_RELOC_SH_IMM_HI16: bfd_reloc_code_real = 801;
pub const BFD_RELOC_SH_IMM_MEDHI16_PCREL: bfd_reloc_code_real = 800;
pub const BFD_RELOC_SH_IMM_MEDHI16: bfd_reloc_code_real = 799;
pub const BFD_RELOC_SH_IMM_MEDLOW16_PCREL: bfd_reloc_code_real = 798;
pub const BFD_RELOC_SH_IMM_MEDLOW16: bfd_reloc_code_real = 797;
pub const BFD_RELOC_SH_IMM_LOW16_PCREL: bfd_reloc_code_real = 796;
pub const BFD_RELOC_SH_IMM_LOW16: bfd_reloc_code_real = 795;
pub const BFD_RELOC_SH_IMMU16: bfd_reloc_code_real = 794;
pub const BFD_RELOC_SH_IMMS16: bfd_reloc_code_real = 793;
pub const BFD_RELOC_SH_IMMS10BY8: bfd_reloc_code_real = 792;
pub const BFD_RELOC_SH_IMMS10BY4: bfd_reloc_code_real = 791;
pub const BFD_RELOC_SH_IMMS10BY2: bfd_reloc_code_real = 790;
pub const BFD_RELOC_SH_IMMS10: bfd_reloc_code_real = 789;
pub const BFD_RELOC_SH_IMMU6: bfd_reloc_code_real = 788;
pub const BFD_RELOC_SH_IMMS6BY32: bfd_reloc_code_real = 787;
pub const BFD_RELOC_SH_IMMS6: bfd_reloc_code_real = 786;
pub const BFD_RELOC_SH_IMMU5: bfd_reloc_code_real = 785;
pub const BFD_RELOC_SH_SHMEDIA_CODE: bfd_reloc_code_real = 784;
pub const BFD_RELOC_SH_GOTPLT32: bfd_reloc_code_real = 783;
pub const BFD_RELOC_SH_GOTPLT10BY8: bfd_reloc_code_real = 782;
pub const BFD_RELOC_SH_GOTPLT10BY4: bfd_reloc_code_real = 781;
pub const BFD_RELOC_SH_GOT10BY8: bfd_reloc_code_real = 780;
pub const BFD_RELOC_SH_GOT10BY4: bfd_reloc_code_real = 779;
pub const BFD_RELOC_SH_RELATIVE64: bfd_reloc_code_real = 778;
pub const BFD_RELOC_SH_JMP_SLOT64: bfd_reloc_code_real = 777;
pub const BFD_RELOC_SH_GLOB_DAT64: bfd_reloc_code_real = 776;
pub const BFD_RELOC_SH_COPY64: bfd_reloc_code_real = 775;
pub const BFD_RELOC_SH_GOTPC_HI16: bfd_reloc_code_real = 774;
pub const BFD_RELOC_SH_GOTPC_MEDHI16: bfd_reloc_code_real = 773;
pub const BFD_RELOC_SH_GOTPC_MEDLOW16: bfd_reloc_code_real = 772;
pub const BFD_RELOC_SH_GOTPC_LOW16: bfd_reloc_code_real = 771;
pub const BFD_RELOC_SH_GOTOFF_HI16: bfd_reloc_code_real = 770;
pub const BFD_RELOC_SH_GOTOFF_MEDHI16: bfd_reloc_code_real = 769;
pub const BFD_RELOC_SH_GOTOFF_MEDLOW16: bfd_reloc_code_real = 768;
pub const BFD_RELOC_SH_GOTOFF_LOW16: bfd_reloc_code_real = 767;
pub const BFD_RELOC_SH_PLT_HI16: bfd_reloc_code_real = 766;
pub const BFD_RELOC_SH_PLT_MEDHI16: bfd_reloc_code_real = 765;
pub const BFD_RELOC_SH_PLT_MEDLOW16: bfd_reloc_code_real = 764;
pub const BFD_RELOC_SH_PLT_LOW16: bfd_reloc_code_real = 763;
pub const BFD_RELOC_SH_GOTPLT_HI16: bfd_reloc_code_real = 762;
pub const BFD_RELOC_SH_GOTPLT_MEDHI16: bfd_reloc_code_real = 761;
pub const BFD_RELOC_SH_GOTPLT_MEDLOW16: bfd_reloc_code_real = 760;
pub const BFD_RELOC_SH_GOTPLT_LOW16: bfd_reloc_code_real = 759;
pub const BFD_RELOC_SH_GOT_HI16: bfd_reloc_code_real = 758;
pub const BFD_RELOC_SH_GOT_MEDHI16: bfd_reloc_code_real = 757;
pub const BFD_RELOC_SH_GOT_MEDLOW16: bfd_reloc_code_real = 756;
pub const BFD_RELOC_SH_GOT_LOW16: bfd_reloc_code_real = 755;
pub const BFD_RELOC_SH_GOTPC: bfd_reloc_code_real = 754;
pub const BFD_RELOC_SH_RELATIVE: bfd_reloc_code_real = 753;
pub const BFD_RELOC_SH_JMP_SLOT: bfd_reloc_code_real = 752;
pub const BFD_RELOC_SH_GLOB_DAT: bfd_reloc_code_real = 751;
pub const BFD_RELOC_SH_COPY: bfd_reloc_code_real = 750;
pub const BFD_RELOC_SH_LOOP_END: bfd_reloc_code_real = 749;
pub const BFD_RELOC_SH_LOOP_START: bfd_reloc_code_real = 748;
pub const BFD_RELOC_SH_LABEL: bfd_reloc_code_real = 747;
pub const BFD_RELOC_SH_DATA: bfd_reloc_code_real = 746;
pub const BFD_RELOC_SH_CODE: bfd_reloc_code_real = 745;
pub const BFD_RELOC_SH_ALIGN: bfd_reloc_code_real = 744;
pub const BFD_RELOC_SH_COUNT: bfd_reloc_code_real = 743;
pub const BFD_RELOC_SH_USES: bfd_reloc_code_real = 742;
pub const BFD_RELOC_SH_SWITCH32: bfd_reloc_code_real = 741;
pub const BFD_RELOC_SH_SWITCH16: bfd_reloc_code_real = 740;
pub const BFD_RELOC_SH_PCRELIMM8BY4: bfd_reloc_code_real = 739;
pub const BFD_RELOC_SH_PCRELIMM8BY2: bfd_reloc_code_real = 738;
pub const BFD_RELOC_SH_IMM8BY4: bfd_reloc_code_real = 737;
pub const BFD_RELOC_SH_IMM8BY2: bfd_reloc_code_real = 736;
pub const BFD_RELOC_SH_IMM8: bfd_reloc_code_real = 735;
pub const BFD_RELOC_SH_IMM4BY4: bfd_reloc_code_real = 734;
pub const BFD_RELOC_SH_IMM4BY2: bfd_reloc_code_real = 733;
pub const BFD_RELOC_SH_IMM4: bfd_reloc_code_real = 732;
pub const BFD_RELOC_SH_DISP20BY8: bfd_reloc_code_real = 731;
pub const BFD_RELOC_SH_DISP20: bfd_reloc_code_real = 730;
pub const BFD_RELOC_SH_DISP12BY8: bfd_reloc_code_real = 729;
pub const BFD_RELOC_SH_DISP12BY4: bfd_reloc_code_real = 728;
pub const BFD_RELOC_SH_DISP12BY2: bfd_reloc_code_real = 727;
pub const BFD_RELOC_SH_DISP12: bfd_reloc_code_real = 726;
pub const BFD_RELOC_SH_IMM3U: bfd_reloc_code_real = 725;
pub const BFD_RELOC_SH_IMM3: bfd_reloc_code_real = 724;
pub const BFD_RELOC_SH_PCDISP12BY2: bfd_reloc_code_real = 723;
pub const BFD_RELOC_SH_PCDISP8BY2: bfd_reloc_code_real = 722;
pub const BFD_RELOC_ARM_THUMB_SHIFT: bfd_reloc_code_real = 721;
pub const BFD_RELOC_ARM_THUMB_IMM: bfd_reloc_code_real = 720;
pub const BFD_RELOC_ARM_THUMB_ADD: bfd_reloc_code_real = 719;
pub const BFD_RELOC_ARM_HWLITERAL: bfd_reloc_code_real = 718;
pub const BFD_RELOC_ARM_T32_OFFSET_IMM: bfd_reloc_code_real = 717;
pub const BFD_RELOC_ARM_T32_OFFSET_U8: bfd_reloc_code_real = 716;
pub const BFD_RELOC_ARM_OFFSET_IMM8: bfd_reloc_code_real = 715;
pub const BFD_RELOC_ARM_IN_POOL: bfd_reloc_code_real = 714;
pub const BFD_RELOC_ARM_LITERAL: bfd_reloc_code_real = 713;
pub const BFD_RELOC_ARM_LDR_IMM: bfd_reloc_code_real = 712;
pub const BFD_RELOC_ARM_ADR_IMM: bfd_reloc_code_real = 711;
pub const BFD_RELOC_ARM_T32_VLDR_VSTR_OFF_IMM: bfd_reloc_code_real = 710;
pub const BFD_RELOC_ARM_T32_CP_OFF_IMM_S2: bfd_reloc_code_real = 709;
pub const BFD_RELOC_ARM_T32_CP_OFF_IMM: bfd_reloc_code_real = 708;
pub const BFD_RELOC_ARM_CP_OFF_IMM_S2: bfd_reloc_code_real = 707;
pub const BFD_RELOC_ARM_CP_OFF_IMM: bfd_reloc_code_real = 706;
pub const BFD_RELOC_ARM_MULTI: bfd_reloc_code_real = 705;
pub const BFD_RELOC_ARM_SWI: bfd_reloc_code_real = 704;
pub const BFD_RELOC_ARM_HVC: bfd_reloc_code_real = 703;
pub const BFD_RELOC_ARM_SMC: bfd_reloc_code_real = 702;
pub const BFD_RELOC_ARM_SHIFT_IMM: bfd_reloc_code_real = 701;
pub const BFD_RELOC_ARM_T32_ADD_PC12: bfd_reloc_code_real = 700;
pub const BFD_RELOC_ARM_T32_IMM12: bfd_reloc_code_real = 699;
pub const BFD_RELOC_ARM_T32_ADD_IMM: bfd_reloc_code_real = 698;
pub const BFD_RELOC_ARM_T32_IMMEDIATE: bfd_reloc_code_real = 697;
pub const BFD_RELOC_ARM_ADRL_IMMEDIATE: bfd_reloc_code_real = 696;
pub const BFD_RELOC_ARM_IMMEDIATE: bfd_reloc_code_real = 695;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC: bfd_reloc_code_real = 694;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC: bfd_reloc_code_real = 693;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC: bfd_reloc_code_real = 692;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC: bfd_reloc_code_real = 691;
pub const BFD_RELOC_ARM_IRELATIVE: bfd_reloc_code_real = 690;
pub const BFD_RELOC_ARM_V4BX: bfd_reloc_code_real = 689;
pub const BFD_RELOC_ARM_LDC_SB_G2: bfd_reloc_code_real = 688;
pub const BFD_RELOC_ARM_LDC_SB_G1: bfd_reloc_code_real = 687;
pub const BFD_RELOC_ARM_LDC_SB_G0: bfd_reloc_code_real = 686;
pub const BFD_RELOC_ARM_LDRS_SB_G2: bfd_reloc_code_real = 685;
pub const BFD_RELOC_ARM_LDRS_SB_G1: bfd_reloc_code_real = 684;
pub const BFD_RELOC_ARM_LDRS_SB_G0: bfd_reloc_code_real = 683;
pub const BFD_RELOC_ARM_LDR_SB_G2: bfd_reloc_code_real = 682;
pub const BFD_RELOC_ARM_LDR_SB_G1: bfd_reloc_code_real = 681;
pub const BFD_RELOC_ARM_LDR_SB_G0: bfd_reloc_code_real = 680;
pub const BFD_RELOC_ARM_ALU_SB_G2: bfd_reloc_code_real = 679;
pub const BFD_RELOC_ARM_ALU_SB_G1: bfd_reloc_code_real = 678;
pub const BFD_RELOC_ARM_ALU_SB_G1_NC: bfd_reloc_code_real = 677;
pub const BFD_RELOC_ARM_ALU_SB_G0: bfd_reloc_code_real = 676;
pub const BFD_RELOC_ARM_ALU_SB_G0_NC: bfd_reloc_code_real = 675;
pub const BFD_RELOC_ARM_LDC_PC_G2: bfd_reloc_code_real = 674;
pub const BFD_RELOC_ARM_LDC_PC_G1: bfd_reloc_code_real = 673;
pub const BFD_RELOC_ARM_LDC_PC_G0: bfd_reloc_code_real = 672;
pub const BFD_RELOC_ARM_LDRS_PC_G2: bfd_reloc_code_real = 671;
pub const BFD_RELOC_ARM_LDRS_PC_G1: bfd_reloc_code_real = 670;
pub const BFD_RELOC_ARM_LDRS_PC_G0: bfd_reloc_code_real = 669;
pub const BFD_RELOC_ARM_LDR_PC_G2: bfd_reloc_code_real = 668;
pub const BFD_RELOC_ARM_LDR_PC_G1: bfd_reloc_code_real = 667;
pub const BFD_RELOC_ARM_LDR_PC_G0: bfd_reloc_code_real = 666;
pub const BFD_RELOC_ARM_ALU_PC_G2: bfd_reloc_code_real = 665;
pub const BFD_RELOC_ARM_ALU_PC_G1: bfd_reloc_code_real = 664;
pub const BFD_RELOC_ARM_ALU_PC_G1_NC: bfd_reloc_code_real = 663;
pub const BFD_RELOC_ARM_ALU_PC_G0: bfd_reloc_code_real = 662;
pub const BFD_RELOC_ARM_ALU_PC_G0_NC: bfd_reloc_code_real = 661;
pub const BFD_RELOC_ARM_TLS_DESC: bfd_reloc_code_real = 660;
pub const BFD_RELOC_ARM_THM_TLS_DESCSEQ: bfd_reloc_code_real = 659;
pub const BFD_RELOC_ARM_TLS_DESCSEQ: bfd_reloc_code_real = 658;
pub const BFD_RELOC_ARM_THM_TLS_CALL: bfd_reloc_code_real = 657;
pub const BFD_RELOC_ARM_TLS_CALL: bfd_reloc_code_real = 656;
pub const BFD_RELOC_ARM_TLS_GOTDESC: bfd_reloc_code_real = 655;
pub const BFD_RELOC_ARM_TLS_LE32: bfd_reloc_code_real = 654;
pub const BFD_RELOC_ARM_TLS_IE32: bfd_reloc_code_real = 653;
pub const BFD_RELOC_ARM_TLS_TPOFF32: bfd_reloc_code_real = 652;
pub const BFD_RELOC_ARM_TLS_DTPMOD32: bfd_reloc_code_real = 651;
pub const BFD_RELOC_ARM_TLS_DTPOFF32: bfd_reloc_code_real = 650;
pub const BFD_RELOC_ARM_TLS_LDM32: bfd_reloc_code_real = 649;
pub const BFD_RELOC_ARM_TLS_LDO32: bfd_reloc_code_real = 648;
pub const BFD_RELOC_ARM_TLS_GD32: bfd_reloc_code_real = 647;
pub const BFD_RELOC_ARM_GOT_PREL: bfd_reloc_code_real = 646;
pub const BFD_RELOC_ARM_GOTPC: bfd_reloc_code_real = 645;
pub const BFD_RELOC_ARM_GOTOFF: bfd_reloc_code_real = 644;
pub const BFD_RELOC_ARM_RELATIVE: bfd_reloc_code_real = 643;
pub const BFD_RELOC_ARM_PLT32: bfd_reloc_code_real = 642;
pub const BFD_RELOC_ARM_GOT32: bfd_reloc_code_real = 641;
pub const BFD_RELOC_ARM_GLOB_DAT: bfd_reloc_code_real = 640;
pub const BFD_RELOC_ARM_JUMP_SLOT: bfd_reloc_code_real = 639;
pub const BFD_RELOC_ARM_TLS_IE32_FDPIC: bfd_reloc_code_real = 638;
pub const BFD_RELOC_ARM_TLS_LDM32_FDPIC: bfd_reloc_code_real = 637;
pub const BFD_RELOC_ARM_TLS_GD32_FDPIC: bfd_reloc_code_real = 636;
pub const BFD_RELOC_ARM_FUNCDESC_VALUE: bfd_reloc_code_real = 635;
pub const BFD_RELOC_ARM_FUNCDESC: bfd_reloc_code_real = 634;
pub const BFD_RELOC_ARM_GOTOFFFUNCDESC: bfd_reloc_code_real = 633;
pub const BFD_RELOC_ARM_GOTFUNCDESC: bfd_reloc_code_real = 632;
pub const BFD_RELOC_ARM_THUMB_MOVT_PCREL: bfd_reloc_code_real = 631;
pub const BFD_RELOC_ARM_THUMB_MOVW_PCREL: bfd_reloc_code_real = 630;
pub const BFD_RELOC_ARM_THUMB_MOVT: bfd_reloc_code_real = 629;
pub const BFD_RELOC_ARM_THUMB_MOVW: bfd_reloc_code_real = 628;
pub const BFD_RELOC_ARM_MOVT_PCREL: bfd_reloc_code_real = 627;
pub const BFD_RELOC_ARM_MOVW_PCREL: bfd_reloc_code_real = 626;
pub const BFD_RELOC_ARM_MOVT: bfd_reloc_code_real = 625;
pub const BFD_RELOC_ARM_MOVW: bfd_reloc_code_real = 624;
pub const BFD_RELOC_ARM_PREL31: bfd_reloc_code_real = 623;
pub const BFD_RELOC_ARM_TARGET2: bfd_reloc_code_real = 622;
pub const BFD_RELOC_ARM_SBREL32: bfd_reloc_code_real = 621;
pub const BFD_RELOC_ARM_ROSEGREL32: bfd_reloc_code_real = 620;
pub const BFD_RELOC_ARM_TARGET1: bfd_reloc_code_real = 619;
pub const BFD_RELOC_ARM_THUMB_OFFSET: bfd_reloc_code_real = 618;
pub const BFD_RELOC_ARM_OFFSET_IMM: bfd_reloc_code_real = 617;
pub const BFD_RELOC_THUMB_PCREL_BRANCH25: bfd_reloc_code_real = 616;
pub const BFD_RELOC_THUMB_PCREL_BRANCH23: bfd_reloc_code_real = 615;
pub const BFD_RELOC_THUMB_PCREL_BRANCH20: bfd_reloc_code_real = 614;
pub const BFD_RELOC_THUMB_PCREL_BRANCH12: bfd_reloc_code_real = 613;
pub const BFD_RELOC_THUMB_PCREL_BRANCH9: bfd_reloc_code_real = 612;
pub const BFD_RELOC_THUMB_PCREL_BRANCH7: bfd_reloc_code_real = 611;
pub const BFD_RELOC_ARM_THUMB_LOOP12: bfd_reloc_code_real = 610;
pub const BFD_RELOC_ARM_THUMB_BF19: bfd_reloc_code_real = 609;
pub const BFD_RELOC_ARM_THUMB_BF13: bfd_reloc_code_real = 608;
pub const BFD_RELOC_ARM_THUMB_BF17: bfd_reloc_code_real = 607;
pub const BFD_RELOC_THUMB_PCREL_BFCSEL: bfd_reloc_code_real = 606;
pub const BFD_RELOC_THUMB_PCREL_BRANCH5: bfd_reloc_code_real = 605;
pub const BFD_RELOC_ARM_PCREL_JUMP: bfd_reloc_code_real = 604;
pub const BFD_RELOC_ARM_PCREL_CALL: bfd_reloc_code_real = 603;
pub const BFD_RELOC_THUMB_PCREL_BLX: bfd_reloc_code_real = 602;
pub const BFD_RELOC_ARM_PCREL_BLX: bfd_reloc_code_real = 601;
pub const BFD_RELOC_ARM_PCREL_BRANCH: bfd_reloc_code_real = 600;
pub const BFD_RELOC_CTOR: bfd_reloc_code_real = 599;
pub const BFD_RELOC_I370_D12: bfd_reloc_code_real = 598;
pub const BFD_RELOC_PPC64_TLS_PCREL: bfd_reloc_code_real = 597;
pub const BFD_RELOC_PPC64_GOT_DTPREL_PCREL34: bfd_reloc_code_real = 596;
pub const BFD_RELOC_PPC64_GOT_TPREL_PCREL34: bfd_reloc_code_real = 595;
pub const BFD_RELOC_PPC64_GOT_TLSLD_PCREL34: bfd_reloc_code_real = 594;
pub const BFD_RELOC_PPC64_GOT_TLSGD_PCREL34: bfd_reloc_code_real = 593;
pub const BFD_RELOC_PPC64_DTPREL34: bfd_reloc_code_real = 592;
pub const BFD_RELOC_PPC64_TPREL34: bfd_reloc_code_real = 591;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHESTA: bfd_reloc_code_real = 590;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHEST: bfd_reloc_code_real = 589;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHERA: bfd_reloc_code_real = 588;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHER: bfd_reloc_code_real = 587;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHA: bfd_reloc_code_real = 586;
pub const BFD_RELOC_PPC64_DTPREL16_HIGH: bfd_reloc_code_real = 585;
pub const BFD_RELOC_PPC64_DTPREL16_LO_DS: bfd_reloc_code_real = 584;
pub const BFD_RELOC_PPC64_DTPREL16_DS: bfd_reloc_code_real = 583;
pub const BFD_RELOC_PPC64_TPREL16_HIGHESTA: bfd_reloc_code_real = 582;
pub const BFD_RELOC_PPC64_TPREL16_HIGHEST: bfd_reloc_code_real = 581;
pub const BFD_RELOC_PPC64_TPREL16_HIGHERA: bfd_reloc_code_real = 580;
pub const BFD_RELOC_PPC64_TPREL16_HIGHER: bfd_reloc_code_real = 579;
pub const BFD_RELOC_PPC64_TPREL16_HIGHA: bfd_reloc_code_real = 578;
pub const BFD_RELOC_PPC64_TPREL16_HIGH: bfd_reloc_code_real = 577;
pub const BFD_RELOC_PPC64_TPREL16_LO_DS: bfd_reloc_code_real = 576;
pub const BFD_RELOC_PPC64_TPREL16_DS: bfd_reloc_code_real = 575;
pub const BFD_RELOC_PPC64_TLSML: bfd_reloc_code_real = 574;
pub const BFD_RELOC_PPC64_TLSM: bfd_reloc_code_real = 573;
pub const BFD_RELOC_PPC64_TLSIE: bfd_reloc_code_real = 572;
pub const BFD_RELOC_PPC64_TLSLE: bfd_reloc_code_real = 571;
pub const BFD_RELOC_PPC64_TLSLD: bfd_reloc_code_real = 570;
pub const BFD_RELOC_PPC64_TLSGD: bfd_reloc_code_real = 569;
pub const BFD_RELOC_PPC_GOT_DTPREL16_HA: bfd_reloc_code_real = 568;
pub const BFD_RELOC_PPC_GOT_DTPREL16_HI: bfd_reloc_code_real = 567;
pub const BFD_RELOC_PPC_GOT_DTPREL16_LO: bfd_reloc_code_real = 566;
pub const BFD_RELOC_PPC_GOT_DTPREL16: bfd_reloc_code_real = 565;
pub const BFD_RELOC_PPC_GOT_TPREL16_HA: bfd_reloc_code_real = 564;
pub const BFD_RELOC_PPC_GOT_TPREL16_HI: bfd_reloc_code_real = 563;
pub const BFD_RELOC_PPC_GOT_TPREL16_LO: bfd_reloc_code_real = 562;
pub const BFD_RELOC_PPC_GOT_TPREL16: bfd_reloc_code_real = 561;
pub const BFD_RELOC_PPC_GOT_TLSLD16_HA: bfd_reloc_code_real = 560;
pub const BFD_RELOC_PPC_GOT_TLSLD16_HI: bfd_reloc_code_real = 559;
pub const BFD_RELOC_PPC_GOT_TLSLD16_LO: bfd_reloc_code_real = 558;
pub const BFD_RELOC_PPC_GOT_TLSLD16: bfd_reloc_code_real = 557;
pub const BFD_RELOC_PPC_GOT_TLSGD16_HA: bfd_reloc_code_real = 556;
pub const BFD_RELOC_PPC_GOT_TLSGD16_HI: bfd_reloc_code_real = 555;
pub const BFD_RELOC_PPC_GOT_TLSGD16_LO: bfd_reloc_code_real = 554;
pub const BFD_RELOC_PPC_GOT_TLSGD16: bfd_reloc_code_real = 553;
pub const BFD_RELOC_PPC_DTPREL: bfd_reloc_code_real = 552;
pub const BFD_RELOC_PPC_DTPREL16_HA: bfd_reloc_code_real = 551;
pub const BFD_RELOC_PPC_DTPREL16_HI: bfd_reloc_code_real = 550;
pub const BFD_RELOC_PPC_DTPREL16_LO: bfd_reloc_code_real = 549;
pub const BFD_RELOC_PPC_DTPREL16: bfd_reloc_code_real = 548;
pub const BFD_RELOC_PPC_TPREL: bfd_reloc_code_real = 547;
pub const BFD_RELOC_PPC_TPREL16_HA: bfd_reloc_code_real = 546;
pub const BFD_RELOC_PPC_TPREL16_HI: bfd_reloc_code_real = 545;
pub const BFD_RELOC_PPC_TPREL16_LO: bfd_reloc_code_real = 544;
pub const BFD_RELOC_PPC_TPREL16: bfd_reloc_code_real = 543;
pub const BFD_RELOC_PPC_DTPMOD: bfd_reloc_code_real = 542;
pub const BFD_RELOC_PPC_TLSML: bfd_reloc_code_real = 541;
pub const BFD_RELOC_PPC_TLSM: bfd_reloc_code_real = 540;
pub const BFD_RELOC_PPC_TLSIE: bfd_reloc_code_real = 539;
pub const BFD_RELOC_PPC_TLSLE: bfd_reloc_code_real = 538;
pub const BFD_RELOC_PPC_TLSLD: bfd_reloc_code_real = 537;
pub const BFD_RELOC_PPC_TLSGD: bfd_reloc_code_real = 536;
pub const BFD_RELOC_PPC_TLS: bfd_reloc_code_real = 535;
pub const BFD_RELOC_PPC64_PCREL28: bfd_reloc_code_real = 534;
pub const BFD_RELOC_PPC64_D28: bfd_reloc_code_real = 533;
pub const BFD_RELOC_PPC64_REL16_HIGHESTA34: bfd_reloc_code_real = 532;
pub const BFD_RELOC_PPC64_REL16_HIGHEST34: bfd_reloc_code_real = 531;
pub const BFD_RELOC_PPC64_REL16_HIGHERA34: bfd_reloc_code_real = 530;
pub const BFD_RELOC_PPC64_REL16_HIGHER34: bfd_reloc_code_real = 529;
pub const BFD_RELOC_PPC64_ADDR16_HIGHESTA34: bfd_reloc_code_real = 528;
pub const BFD_RELOC_PPC64_ADDR16_HIGHEST34: bfd_reloc_code_real = 527;
pub const BFD_RELOC_PPC64_ADDR16_HIGHERA34: bfd_reloc_code_real = 526;
pub const BFD_RELOC_PPC64_ADDR16_HIGHER34: bfd_reloc_code_real = 525;
pub const BFD_RELOC_PPC64_PLT_PCREL34: bfd_reloc_code_real = 524;
pub const BFD_RELOC_PPC64_GOT_PCREL34: bfd_reloc_code_real = 523;
pub const BFD_RELOC_PPC64_PCREL34: bfd_reloc_code_real = 522;
pub const BFD_RELOC_PPC64_D34_HA30: bfd_reloc_code_real = 521;
pub const BFD_RELOC_PPC64_D34_HI30: bfd_reloc_code_real = 520;
pub const BFD_RELOC_PPC64_D34_LO: bfd_reloc_code_real = 519;
pub const BFD_RELOC_PPC64_D34: bfd_reloc_code_real = 518;
pub const BFD_RELOC_PPC64_REL24_NOTOC: bfd_reloc_code_real = 517;
pub const BFD_RELOC_PPC64_ENTRY: bfd_reloc_code_real = 516;
pub const BFD_RELOC_PPC64_ADDR64_LOCAL: bfd_reloc_code_real = 515;
pub const BFD_RELOC_PPC64_REL16_HIGHESTA: bfd_reloc_code_real = 514;
pub const BFD_RELOC_PPC64_REL16_HIGHEST: bfd_reloc_code_real = 513;
pub const BFD_RELOC_PPC64_REL16_HIGHERA: bfd_reloc_code_real = 512;
pub const BFD_RELOC_PPC64_REL16_HIGHER: bfd_reloc_code_real = 511;
pub const BFD_RELOC_PPC64_REL16_HIGHA: bfd_reloc_code_real = 510;
pub const BFD_RELOC_PPC64_REL16_HIGH: bfd_reloc_code_real = 509;
pub const BFD_RELOC_PPC64_ADDR16_HIGHA: bfd_reloc_code_real = 508;
pub const BFD_RELOC_PPC64_ADDR16_HIGH: bfd_reloc_code_real = 507;
pub const BFD_RELOC_PPC64_PLTGOT16_LO_DS: bfd_reloc_code_real = 506;
pub const BFD_RELOC_PPC64_PLTGOT16_DS: bfd_reloc_code_real = 505;
pub const BFD_RELOC_PPC64_TOC16_LO_DS: bfd_reloc_code_real = 504;
pub const BFD_RELOC_PPC64_TOC16_DS: bfd_reloc_code_real = 503;
pub const BFD_RELOC_PPC64_SECTOFF_LO_DS: bfd_reloc_code_real = 502;
pub const BFD_RELOC_PPC64_SECTOFF_DS: bfd_reloc_code_real = 501;
pub const BFD_RELOC_PPC64_PLT16_LO_DS: bfd_reloc_code_real = 500;
pub const BFD_RELOC_PPC64_GOT16_LO_DS: bfd_reloc_code_real = 499;
pub const BFD_RELOC_PPC64_GOT16_DS: bfd_reloc_code_real = 498;
pub const BFD_RELOC_PPC64_ADDR16_LO_DS: bfd_reloc_code_real = 497;
pub const BFD_RELOC_PPC64_ADDR16_DS: bfd_reloc_code_real = 496;
pub const BFD_RELOC_PPC64_PLTGOT16_HA: bfd_reloc_code_real = 495;
pub const BFD_RELOC_PPC64_PLTGOT16_HI: bfd_reloc_code_real = 494;
pub const BFD_RELOC_PPC64_PLTGOT16_LO: bfd_reloc_code_real = 493;
pub const BFD_RELOC_PPC64_PLTGOT16: bfd_reloc_code_real = 492;
pub const BFD_RELOC_PPC64_TOC: bfd_reloc_code_real = 491;
pub const BFD_RELOC_PPC64_TOC16_HA: bfd_reloc_code_real = 490;
pub const BFD_RELOC_PPC64_TOC16_HI: bfd_reloc_code_real = 489;
pub const BFD_RELOC_PPC64_TOC16_LO: bfd_reloc_code_real = 488;
pub const BFD_RELOC_PPC64_HIGHEST_S: bfd_reloc_code_real = 487;
pub const BFD_RELOC_PPC64_HIGHEST: bfd_reloc_code_real = 486;
pub const BFD_RELOC_PPC64_HIGHER_S: bfd_reloc_code_real = 485;
pub const BFD_RELOC_PPC64_HIGHER: bfd_reloc_code_real = 484;
pub const BFD_RELOC_PPC_NEG: bfd_reloc_code_real = 483;
pub const BFD_RELOC_PPC_REL16DX_HA: bfd_reloc_code_real = 482;
pub const BFD_RELOC_PPC_16DX_HA: bfd_reloc_code_real = 481;
pub const BFD_RELOC_PPC_VLE_SDAREL_HA16D: bfd_reloc_code_real = 480;
pub const BFD_RELOC_PPC_VLE_SDAREL_HA16A: bfd_reloc_code_real = 479;
pub const BFD_RELOC_PPC_VLE_SDAREL_HI16D: bfd_reloc_code_real = 478;
pub const BFD_RELOC_PPC_VLE_SDAREL_HI16A: bfd_reloc_code_real = 477;
pub const BFD_RELOC_PPC_VLE_SDAREL_LO16D: bfd_reloc_code_real = 476;
pub const BFD_RELOC_PPC_VLE_SDAREL_LO16A: bfd_reloc_code_real = 475;
pub const BFD_RELOC_PPC_VLE_SDA21_LO: bfd_reloc_code_real = 474;
pub const BFD_RELOC_PPC_VLE_SDA21: bfd_reloc_code_real = 473;
pub const BFD_RELOC_PPC_VLE_HA16D: bfd_reloc_code_real = 472;
pub const BFD_RELOC_PPC_VLE_HA16A: bfd_reloc_code_real = 471;
pub const BFD_RELOC_PPC_VLE_HI16D: bfd_reloc_code_real = 470;
pub const BFD_RELOC_PPC_VLE_HI16A: bfd_reloc_code_real = 469;
pub const BFD_RELOC_PPC_VLE_LO16D: bfd_reloc_code_real = 468;
pub const BFD_RELOC_PPC_VLE_LO16A: bfd_reloc_code_real = 467;
pub const BFD_RELOC_PPC_VLE_REL24: bfd_reloc_code_real = 466;
pub const BFD_RELOC_PPC_VLE_REL15: bfd_reloc_code_real = 465;
pub const BFD_RELOC_PPC_VLE_REL8: bfd_reloc_code_real = 464;
pub const BFD_RELOC_PPC_EMB_RELSDA: bfd_reloc_code_real = 463;
pub const BFD_RELOC_PPC_EMB_BIT_FLD: bfd_reloc_code_real = 462;
pub const BFD_RELOC_PPC_EMB_RELST_HA: bfd_reloc_code_real = 461;
pub const BFD_RELOC_PPC_EMB_RELST_HI: bfd_reloc_code_real = 460;
pub const BFD_RELOC_PPC_EMB_RELST_LO: bfd_reloc_code_real = 459;
pub const BFD_RELOC_PPC_EMB_RELSEC16: bfd_reloc_code_real = 458;
pub const BFD_RELOC_PPC_EMB_MRKREF: bfd_reloc_code_real = 457;
pub const BFD_RELOC_PPC_EMB_SDA21: bfd_reloc_code_real = 456;
pub const BFD_RELOC_PPC_EMB_SDA2REL: bfd_reloc_code_real = 455;
pub const BFD_RELOC_PPC_EMB_SDA2I16: bfd_reloc_code_real = 454;
pub const BFD_RELOC_PPC_EMB_SDAI16: bfd_reloc_code_real = 453;
pub const BFD_RELOC_PPC_EMB_NADDR16_HA: bfd_reloc_code_real = 452;
pub const BFD_RELOC_PPC_EMB_NADDR16_HI: bfd_reloc_code_real = 451;
pub const BFD_RELOC_PPC_EMB_NADDR16_LO: bfd_reloc_code_real = 450;
pub const BFD_RELOC_PPC_EMB_NADDR16: bfd_reloc_code_real = 449;
pub const BFD_RELOC_PPC_EMB_NADDR32: bfd_reloc_code_real = 448;
pub const BFD_RELOC_PPC_LOCAL24PC: bfd_reloc_code_real = 447;
pub const BFD_RELOC_PPC_RELATIVE: bfd_reloc_code_real = 446;
pub const BFD_RELOC_PPC_JMP_SLOT: bfd_reloc_code_real = 445;
pub const BFD_RELOC_PPC_GLOB_DAT: bfd_reloc_code_real = 444;
pub const BFD_RELOC_PPC_COPY: bfd_reloc_code_real = 443;
pub const BFD_RELOC_PPC_BA16_BRNTAKEN: bfd_reloc_code_real = 442;
pub const BFD_RELOC_PPC_BA16_BRTAKEN: bfd_reloc_code_real = 441;
pub const BFD_RELOC_PPC_BA16: bfd_reloc_code_real = 440;
pub const BFD_RELOC_PPC_B16_BRNTAKEN: bfd_reloc_code_real = 439;
pub const BFD_RELOC_PPC_B16_BRTAKEN: bfd_reloc_code_real = 438;
pub const BFD_RELOC_PPC_B16: bfd_reloc_code_real = 437;
pub const BFD_RELOC_PPC_TOC16_HI: bfd_reloc_code_real = 436;
pub const BFD_RELOC_PPC_TOC16_LO: bfd_reloc_code_real = 435;
pub const BFD_RELOC_PPC_TOC16: bfd_reloc_code_real = 434;
pub const BFD_RELOC_PPC_BA26: bfd_reloc_code_real = 433;
pub const BFD_RELOC_PPC_B26: bfd_reloc_code_real = 432;
pub const BFD_RELOC_PJ_CODE_REL32: bfd_reloc_code_real = 431;
pub const BFD_RELOC_PJ_CODE_REL16: bfd_reloc_code_real = 430;
pub const BFD_RELOC_PJ_CODE_DIR32: bfd_reloc_code_real = 429;
pub const BFD_RELOC_PJ_CODE_DIR16: bfd_reloc_code_real = 428;
pub const BFD_RELOC_PJ_CODE_LO16: bfd_reloc_code_real = 427;
pub const BFD_RELOC_PJ_CODE_HI16: bfd_reloc_code_real = 426;
pub const BFD_RELOC_PDP11_DISP_6_PCREL: bfd_reloc_code_real = 425;
pub const BFD_RELOC_PDP11_DISP_8_PCREL: bfd_reloc_code_real = 424;
pub const BFD_RELOC_NS32K_DISP_32_PCREL: bfd_reloc_code_real = 423;
pub const BFD_RELOC_NS32K_DISP_16_PCREL: bfd_reloc_code_real = 422;
pub const BFD_RELOC_NS32K_DISP_8_PCREL: bfd_reloc_code_real = 421;
pub const BFD_RELOC_NS32K_DISP_32: bfd_reloc_code_real = 420;
pub const BFD_RELOC_NS32K_DISP_16: bfd_reloc_code_real = 419;
pub const BFD_RELOC_NS32K_DISP_8: bfd_reloc_code_real = 418;
pub const BFD_RELOC_NS32K_IMM_32_PCREL: bfd_reloc_code_real = 417;
pub const BFD_RELOC_NS32K_IMM_16_PCREL: bfd_reloc_code_real = 416;
pub const BFD_RELOC_NS32K_IMM_8_PCREL: bfd_reloc_code_real = 415;
pub const BFD_RELOC_NS32K_IMM_32: bfd_reloc_code_real = 414;
pub const BFD_RELOC_NS32K_IMM_16: bfd_reloc_code_real = 413;
pub const BFD_RELOC_NS32K_IMM_8: bfd_reloc_code_real = 412;
pub const BFD_RELOC_X86_64_REX_GOTPCRELX: bfd_reloc_code_real = 411;
pub const BFD_RELOC_X86_64_GOTPCRELX: bfd_reloc_code_real = 410;
pub const BFD_RELOC_X86_64_PLT32_BND: bfd_reloc_code_real = 409;
pub const BFD_RELOC_X86_64_PC32_BND: bfd_reloc_code_real = 408;
pub const BFD_RELOC_X86_64_IRELATIVE: bfd_reloc_code_real = 407;
pub const BFD_RELOC_X86_64_TLSDESC: bfd_reloc_code_real = 406;
pub const BFD_RELOC_X86_64_TLSDESC_CALL: bfd_reloc_code_real = 405;
pub const BFD_RELOC_X86_64_GOTPC32_TLSDESC: bfd_reloc_code_real = 404;
pub const BFD_RELOC_X86_64_PLTOFF64: bfd_reloc_code_real = 403;
pub const BFD_RELOC_X86_64_GOTPLT64: bfd_reloc_code_real = 402;
pub const BFD_RELOC_X86_64_GOTPC64: bfd_reloc_code_real = 401;
pub const BFD_RELOC_X86_64_GOTPCREL64: bfd_reloc_code_real = 400;
pub const BFD_RELOC_X86_64_GOT64: bfd_reloc_code_real = 399;
pub const BFD_RELOC_X86_64_GOTPC32: bfd_reloc_code_real = 398;
pub const BFD_RELOC_X86_64_GOTOFF64: bfd_reloc_code_real = 397;
pub const BFD_RELOC_X86_64_TPOFF32: bfd_reloc_code_real = 396;
pub const BFD_RELOC_X86_64_GOTTPOFF: bfd_reloc_code_real = 395;
pub const BFD_RELOC_X86_64_DTPOFF32: bfd_reloc_code_real = 394;
pub const BFD_RELOC_X86_64_TLSLD: bfd_reloc_code_real = 393;
pub const BFD_RELOC_X86_64_TLSGD: bfd_reloc_code_real = 392;
pub const BFD_RELOC_X86_64_TPOFF64: bfd_reloc_code_real = 391;
pub const BFD_RELOC_X86_64_DTPOFF64: bfd_reloc_code_real = 390;
pub const BFD_RELOC_X86_64_DTPMOD64: bfd_reloc_code_real = 389;
pub const BFD_RELOC_X86_64_32S: bfd_reloc_code_real = 388;
pub const BFD_RELOC_X86_64_GOTPCREL: bfd_reloc_code_real = 387;
pub const BFD_RELOC_X86_64_RELATIVE: bfd_reloc_code_real = 386;
pub const BFD_RELOC_X86_64_JUMP_SLOT: bfd_reloc_code_real = 385;
pub const BFD_RELOC_X86_64_GLOB_DAT: bfd_reloc_code_real = 384;
pub const BFD_RELOC_X86_64_COPY: bfd_reloc_code_real = 383;
pub const BFD_RELOC_X86_64_PLT32: bfd_reloc_code_real = 382;
pub const BFD_RELOC_X86_64_GOT32: bfd_reloc_code_real = 381;
pub const BFD_RELOC_386_GOT32X: bfd_reloc_code_real = 380;
pub const BFD_RELOC_386_IRELATIVE: bfd_reloc_code_real = 379;
pub const BFD_RELOC_386_TLS_DESC: bfd_reloc_code_real = 378;
pub const BFD_RELOC_386_TLS_DESC_CALL: bfd_reloc_code_real = 377;
pub const BFD_RELOC_386_TLS_GOTDESC: bfd_reloc_code_real = 376;
pub const BFD_RELOC_386_TLS_TPOFF32: bfd_reloc_code_real = 375;
pub const BFD_RELOC_386_TLS_DTPOFF32: bfd_reloc_code_real = 374;
pub const BFD_RELOC_386_TLS_DTPMOD32: bfd_reloc_code_real = 373;
pub const BFD_RELOC_386_TLS_LE_32: bfd_reloc_code_real = 372;
pub const BFD_RELOC_386_TLS_IE_32: bfd_reloc_code_real = 371;
pub const BFD_RELOC_386_TLS_LDO_32: bfd_reloc_code_real = 370;
pub const BFD_RELOC_386_TLS_LDM: bfd_reloc_code_real = 369;
pub const BFD_RELOC_386_TLS_GD: bfd_reloc_code_real = 368;
pub const BFD_RELOC_386_TLS_LE: bfd_reloc_code_real = 367;
pub const BFD_RELOC_386_TLS_GOTIE: bfd_reloc_code_real = 366;
pub const BFD_RELOC_386_TLS_IE: bfd_reloc_code_real = 365;
pub const BFD_RELOC_386_TLS_TPOFF: bfd_reloc_code_real = 364;
pub const BFD_RELOC_386_GOTPC: bfd_reloc_code_real = 363;
pub const BFD_RELOC_386_GOTOFF: bfd_reloc_code_real = 362;
pub const BFD_RELOC_386_RELATIVE: bfd_reloc_code_real = 361;
pub const BFD_RELOC_386_JUMP_SLOT: bfd_reloc_code_real = 360;
pub const BFD_RELOC_386_GLOB_DAT: bfd_reloc_code_real = 359;
pub const BFD_RELOC_386_COPY: bfd_reloc_code_real = 358;
pub const BFD_RELOC_386_PLT32: bfd_reloc_code_real = 357;
pub const BFD_RELOC_386_GOT32: bfd_reloc_code_real = 356;
pub const BFD_RELOC_MN10300_16_PCREL: bfd_reloc_code_real = 355;
pub const BFD_RELOC_MN10300_32_PCREL: bfd_reloc_code_real = 354;
pub const BFD_RELOC_MN10300_TLS_TPOFF: bfd_reloc_code_real = 353;
pub const BFD_RELOC_MN10300_TLS_DTPOFF: bfd_reloc_code_real = 352;
pub const BFD_RELOC_MN10300_TLS_DTPMOD: bfd_reloc_code_real = 351;
pub const BFD_RELOC_MN10300_TLS_LE: bfd_reloc_code_real = 350;
pub const BFD_RELOC_MN10300_TLS_IE: bfd_reloc_code_real = 349;
pub const BFD_RELOC_MN10300_TLS_GOTIE: bfd_reloc_code_real = 348;
pub const BFD_RELOC_MN10300_TLS_LDO: bfd_reloc_code_real = 347;
pub const BFD_RELOC_MN10300_TLS_LD: bfd_reloc_code_real = 346;
pub const BFD_RELOC_MN10300_TLS_GD: bfd_reloc_code_real = 345;
pub const BFD_RELOC_MN10300_ALIGN: bfd_reloc_code_real = 344;
pub const BFD_RELOC_MN10300_SYM_DIFF: bfd_reloc_code_real = 343;
pub const BFD_RELOC_MN10300_RELATIVE: bfd_reloc_code_real = 342;
pub const BFD_RELOC_MN10300_JMP_SLOT: bfd_reloc_code_real = 341;
pub const BFD_RELOC_MN10300_GLOB_DAT: bfd_reloc_code_real = 340;
pub const BFD_RELOC_MN10300_COPY: bfd_reloc_code_real = 339;
pub const BFD_RELOC_MN10300_GOT16: bfd_reloc_code_real = 338;
pub const BFD_RELOC_MN10300_GOT24: bfd_reloc_code_real = 337;
pub const BFD_RELOC_MN10300_GOT32: bfd_reloc_code_real = 336;
pub const BFD_RELOC_MN10300_GOTOFF24: bfd_reloc_code_real = 335;
pub const BFD_RELOC_FRV_TLSMOFF: bfd_reloc_code_real = 334;
pub const BFD_RELOC_FRV_TLSOFF_RELAX: bfd_reloc_code_real = 333;
pub const BFD_RELOC_FRV_GETTLSOFF_RELAX: bfd_reloc_code_real = 332;
pub const BFD_RELOC_FRV_TLSDESC_RELAX: bfd_reloc_code_real = 331;
pub const BFD_RELOC_FRV_TLSOFF: bfd_reloc_code_real = 330;
pub const BFD_RELOC_FRV_GOTTLSOFFLO: bfd_reloc_code_real = 329;
pub const BFD_RELOC_FRV_GOTTLSOFFHI: bfd_reloc_code_real = 328;
pub const BFD_RELOC_FRV_GOTTLSOFF12: bfd_reloc_code_real = 327;
pub const BFD_RELOC_FRV_TLSMOFFLO: bfd_reloc_code_real = 326;
pub const BFD_RELOC_FRV_TLSMOFFHI: bfd_reloc_code_real = 325;
pub const BFD_RELOC_FRV_TLSMOFF12: bfd_reloc_code_real = 324;
pub const BFD_RELOC_FRV_GOTTLSDESCLO: bfd_reloc_code_real = 323;
pub const BFD_RELOC_FRV_GOTTLSDESCHI: bfd_reloc_code_real = 322;
pub const BFD_RELOC_FRV_GOTTLSDESC12: bfd_reloc_code_real = 321;
pub const BFD_RELOC_FRV_TLSDESC_VALUE: bfd_reloc_code_real = 320;
pub const BFD_RELOC_FRV_GETTLSOFF: bfd_reloc_code_real = 319;
pub const BFD_RELOC_FRV_GOTOFFLO: bfd_reloc_code_real = 318;
pub const BFD_RELOC_FRV_GOTOFFHI: bfd_reloc_code_real = 317;
pub const BFD_RELOC_FRV_GOTOFF12: bfd_reloc_code_real = 316;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFFLO: bfd_reloc_code_real = 315;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFFHI: bfd_reloc_code_real = 314;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFF12: bfd_reloc_code_real = 313;
pub const BFD_RELOC_FRV_FUNCDESC_VALUE: bfd_reloc_code_real = 312;
pub const BFD_RELOC_FRV_FUNCDESC_GOTLO: bfd_reloc_code_real = 311;
pub const BFD_RELOC_FRV_FUNCDESC_GOTHI: bfd_reloc_code_real = 310;
pub const BFD_RELOC_FRV_FUNCDESC_GOT12: bfd_reloc_code_real = 309;
pub const BFD_RELOC_FRV_FUNCDESC: bfd_reloc_code_real = 308;
pub const BFD_RELOC_FRV_GOTLO: bfd_reloc_code_real = 307;
pub const BFD_RELOC_FRV_GOTHI: bfd_reloc_code_real = 306;
pub const BFD_RELOC_FRV_GOT12: bfd_reloc_code_real = 305;
pub const BFD_RELOC_FRV_GPRELLO: bfd_reloc_code_real = 304;
pub const BFD_RELOC_FRV_GPRELHI: bfd_reloc_code_real = 303;
pub const BFD_RELOC_FRV_GPREL32: bfd_reloc_code_real = 302;
pub const BFD_RELOC_FRV_GPRELU12: bfd_reloc_code_real = 301;
pub const BFD_RELOC_FRV_GPREL12: bfd_reloc_code_real = 300;
pub const BFD_RELOC_FRV_HI16: bfd_reloc_code_real = 299;
pub const BFD_RELOC_FRV_LO16: bfd_reloc_code_real = 298;
pub const BFD_RELOC_FRV_LABEL24: bfd_reloc_code_real = 297;
pub const BFD_RELOC_FRV_LABEL16: bfd_reloc_code_real = 296;
pub const BFD_RELOC_FT32_DIFF32: bfd_reloc_code_real = 295;
pub const BFD_RELOC_FT32_15: bfd_reloc_code_real = 294;
pub const BFD_RELOC_FT32_SC1: bfd_reloc_code_real = 293;
pub const BFD_RELOC_FT32_SC0: bfd_reloc_code_real = 292;
pub const BFD_RELOC_FT32_RELAX: bfd_reloc_code_real = 291;
pub const BFD_RELOC_FT32_18: bfd_reloc_code_real = 290;
pub const BFD_RELOC_FT32_17: bfd_reloc_code_real = 289;
pub const BFD_RELOC_FT32_20: bfd_reloc_code_real = 288;
pub const BFD_RELOC_FT32_10: bfd_reloc_code_real = 287;
pub const BFD_RELOC_MOXIE_10_PCREL: bfd_reloc_code_real = 286;
pub const BFD_RELOC_MIPS_JUMP_SLOT: bfd_reloc_code_real = 285;
pub const BFD_RELOC_MIPS_COPY: bfd_reloc_code_real = 284;
pub const BFD_RELOC_MIPS_EH: bfd_reloc_code_real = 283;
pub const BFD_RELOC_MICROMIPS_TLS_TPREL_LO16: bfd_reloc_code_real = 282;
pub const BFD_RELOC_MIPS_TLS_TPREL_LO16: bfd_reloc_code_real = 281;
pub const BFD_RELOC_MICROMIPS_TLS_TPREL_HI16: bfd_reloc_code_real = 280;
pub const BFD_RELOC_MIPS_TLS_TPREL_HI16: bfd_reloc_code_real = 279;
pub const BFD_RELOC_MIPS_TLS_TPREL64: bfd_reloc_code_real = 278;
pub const BFD_RELOC_MIPS_TLS_TPREL32: bfd_reloc_code_real = 277;
pub const BFD_RELOC_MICROMIPS_TLS_GOTTPREL: bfd_reloc_code_real = 276;
pub const BFD_RELOC_MIPS_TLS_GOTTPREL: bfd_reloc_code_real = 275;
pub const BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16: bfd_reloc_code_real = 274;
pub const BFD_RELOC_MIPS_TLS_DTPREL_LO16: bfd_reloc_code_real = 273;
pub const BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16: bfd_reloc_code_real = 272;
pub const BFD_RELOC_MIPS_TLS_DTPREL_HI16: bfd_reloc_code_real = 271;
pub const BFD_RELOC_MICROMIPS_TLS_LDM: bfd_reloc_code_real = 270;
pub const BFD_RELOC_MIPS_TLS_LDM: bfd_reloc_code_real = 269;
pub const BFD_RELOC_MICROMIPS_TLS_GD: bfd_reloc_code_real = 268;
pub const BFD_RELOC_MIPS_TLS_GD: bfd_reloc_code_real = 267;
pub const BFD_RELOC_MIPS_TLS_DTPREL64: bfd_reloc_code_real = 266;
pub const BFD_RELOC_MIPS_TLS_DTPMOD64: bfd_reloc_code_real = 265;
pub const BFD_RELOC_MIPS_TLS_DTPREL32: bfd_reloc_code_real = 264;
pub const BFD_RELOC_MIPS_TLS_DTPMOD32: bfd_reloc_code_real = 263;
pub const BFD_RELOC_MICROMIPS_JALR: bfd_reloc_code_real = 262;
pub const BFD_RELOC_MIPS_JALR: bfd_reloc_code_real = 261;
pub const BFD_RELOC_MIPS_RELGOT: bfd_reloc_code_real = 260;
pub const BFD_RELOC_MIPS_REL16: bfd_reloc_code_real = 259;
pub const BFD_RELOC_MICROMIPS_SCN_DISP: bfd_reloc_code_real = 258;
pub const BFD_RELOC_MIPS_SCN_DISP: bfd_reloc_code_real = 257;
pub const BFD_RELOC_MICROMIPS_HIGHER: bfd_reloc_code_real = 256;
pub const BFD_RELOC_MIPS_HIGHER: bfd_reloc_code_real = 255;
pub const BFD_RELOC_MICROMIPS_HIGHEST: bfd_reloc_code_real = 254;
pub const BFD_RELOC_MIPS_HIGHEST: bfd_reloc_code_real = 253;
pub const BFD_RELOC_MIPS_DELETE: bfd_reloc_code_real = 252;
pub const BFD_RELOC_MIPS_INSERT_B: bfd_reloc_code_real = 251;
pub const BFD_RELOC_MIPS_INSERT_A: bfd_reloc_code_real = 250;
pub const BFD_RELOC_MIPS_SHIFT6: bfd_reloc_code_real = 249;
pub const BFD_RELOC_MIPS_SHIFT5: bfd_reloc_code_real = 248;
pub const BFD_RELOC_MICROMIPS_GOT_DISP: bfd_reloc_code_real = 247;
pub const BFD_RELOC_MIPS_GOT_DISP: bfd_reloc_code_real = 246;
pub const BFD_RELOC_MICROMIPS_GOT_OFST: bfd_reloc_code_real = 245;
pub const BFD_RELOC_MIPS_GOT_OFST: bfd_reloc_code_real = 244;
pub const BFD_RELOC_MICROMIPS_GOT_PAGE: bfd_reloc_code_real = 243;
pub const BFD_RELOC_MIPS_GOT_PAGE: bfd_reloc_code_real = 242;
pub const BFD_RELOC_MICROMIPS_SUB: bfd_reloc_code_real = 241;
pub const BFD_RELOC_MIPS_SUB: bfd_reloc_code_real = 240;
pub const BFD_RELOC_MICROMIPS_CALL_LO16: bfd_reloc_code_real = 239;
pub const BFD_RELOC_MIPS_CALL_LO16: bfd_reloc_code_real = 238;
pub const BFD_RELOC_MICROMIPS_CALL_HI16: bfd_reloc_code_real = 237;
pub const BFD_RELOC_MIPS_CALL_HI16: bfd_reloc_code_real = 236;
pub const BFD_RELOC_MICROMIPS_GOT_LO16: bfd_reloc_code_real = 235;
pub const BFD_RELOC_MIPS_GOT_LO16: bfd_reloc_code_real = 234;
pub const BFD_RELOC_MICROMIPS_GOT_HI16: bfd_reloc_code_real = 233;
pub const BFD_RELOC_MIPS_GOT_HI16: bfd_reloc_code_real = 232;
pub const BFD_RELOC_MICROMIPS_CALL16: bfd_reloc_code_real = 231;
pub const BFD_RELOC_MIPS_CALL16: bfd_reloc_code_real = 230;
pub const BFD_RELOC_MICROMIPS_GOT16: bfd_reloc_code_real = 229;
pub const BFD_RELOC_MIPS_GOT16: bfd_reloc_code_real = 228;
pub const BFD_RELOC_MICROMIPS_LO16: bfd_reloc_code_real = 227;
pub const BFD_RELOC_MICROMIPS_HI16_S: bfd_reloc_code_real = 226;
pub const BFD_RELOC_MICROMIPS_HI16: bfd_reloc_code_real = 225;
pub const BFD_RELOC_MICROMIPS_GPREL16: bfd_reloc_code_real = 224;
pub const BFD_RELOC_MIPS_19_PCREL_S2: bfd_reloc_code_real = 223;
pub const BFD_RELOC_MIPS_18_PCREL_S3: bfd_reloc_code_real = 222;
pub const BFD_RELOC_MIPS_26_PCREL_S2: bfd_reloc_code_real = 221;
pub const BFD_RELOC_MIPS_21_PCREL_S2: bfd_reloc_code_real = 220;
pub const BFD_RELOC_MIPS16_16_PCREL_S1: bfd_reloc_code_real = 219;
pub const BFD_RELOC_MICROMIPS_16_PCREL_S1: bfd_reloc_code_real = 218;
pub const BFD_RELOC_MICROMIPS_10_PCREL_S1: bfd_reloc_code_real = 217;
pub const BFD_RELOC_MICROMIPS_7_PCREL_S1: bfd_reloc_code_real = 216;
pub const BFD_RELOC_MICROMIPS_LITERAL: bfd_reloc_code_real = 215;
pub const BFD_RELOC_MIPS_LITERAL: bfd_reloc_code_real = 214;
pub const BFD_RELOC_MIPS16_TLS_TPREL_LO16: bfd_reloc_code_real = 213;
pub const BFD_RELOC_MIPS16_TLS_TPREL_HI16: bfd_reloc_code_real = 212;
pub const BFD_RELOC_MIPS16_TLS_GOTTPREL: bfd_reloc_code_real = 211;
pub const BFD_RELOC_MIPS16_TLS_DTPREL_LO16: bfd_reloc_code_real = 210;
pub const BFD_RELOC_MIPS16_TLS_DTPREL_HI16: bfd_reloc_code_real = 209;
pub const BFD_RELOC_MIPS16_TLS_LDM: bfd_reloc_code_real = 208;
pub const BFD_RELOC_MIPS16_TLS_GD: bfd_reloc_code_real = 207;
pub const BFD_RELOC_MIPS16_LO16: bfd_reloc_code_real = 206;
pub const BFD_RELOC_MIPS16_HI16_S: bfd_reloc_code_real = 205;
pub const BFD_RELOC_MIPS16_HI16: bfd_reloc_code_real = 204;
pub const BFD_RELOC_MIPS16_CALL16: bfd_reloc_code_real = 203;
pub const BFD_RELOC_MIPS16_GOT16: bfd_reloc_code_real = 202;
pub const BFD_RELOC_LO16_PCREL: bfd_reloc_code_real = 201;
pub const BFD_RELOC_HI16_S_PCREL: bfd_reloc_code_real = 200;
pub const BFD_RELOC_HI16_PCREL: bfd_reloc_code_real = 199;
pub const BFD_RELOC_LO16: bfd_reloc_code_real = 198;
pub const BFD_RELOC_HI16_S: bfd_reloc_code_real = 197;
pub const BFD_RELOC_HI16: bfd_reloc_code_real = 196;
pub const BFD_RELOC_MIPS16_GPREL: bfd_reloc_code_real = 195;
pub const BFD_RELOC_MIPS16_JMP: bfd_reloc_code_real = 194;
pub const BFD_RELOC_MICROMIPS_JMP: bfd_reloc_code_real = 193;
pub const BFD_RELOC_MIPS_JMP: bfd_reloc_code_real = 192;
pub const BFD_RELOC_ALPHA_TPREL16: bfd_reloc_code_real = 191;
pub const BFD_RELOC_ALPHA_TPREL_LO16: bfd_reloc_code_real = 190;
pub const BFD_RELOC_ALPHA_TPREL_HI16: bfd_reloc_code_real = 189;
pub const BFD_RELOC_ALPHA_TPREL64: bfd_reloc_code_real = 188;
pub const BFD_RELOC_ALPHA_GOTTPREL16: bfd_reloc_code_real = 187;
pub const BFD_RELOC_ALPHA_DTPREL16: bfd_reloc_code_real = 186;
pub const BFD_RELOC_ALPHA_DTPREL_LO16: bfd_reloc_code_real = 185;
pub const BFD_RELOC_ALPHA_DTPREL_HI16: bfd_reloc_code_real = 184;
pub const BFD_RELOC_ALPHA_DTPREL64: bfd_reloc_code_real = 183;
pub const BFD_RELOC_ALPHA_GOTDTPREL16: bfd_reloc_code_real = 182;
pub const BFD_RELOC_ALPHA_DTPMOD64: bfd_reloc_code_real = 181;
pub const BFD_RELOC_ALPHA_TLSLDM: bfd_reloc_code_real = 180;
pub const BFD_RELOC_ALPHA_TLSGD: bfd_reloc_code_real = 179;
pub const BFD_RELOC_ALPHA_BOH: bfd_reloc_code_real = 178;
pub const BFD_RELOC_ALPHA_LDA: bfd_reloc_code_real = 177;
pub const BFD_RELOC_ALPHA_BSR: bfd_reloc_code_real = 176;
pub const BFD_RELOC_ALPHA_NOP: bfd_reloc_code_real = 175;
pub const BFD_RELOC_ALPHA_BRSGP: bfd_reloc_code_real = 174;
pub const BFD_RELOC_ALPHA_GPREL_LO16: bfd_reloc_code_real = 173;
pub const BFD_RELOC_ALPHA_GPREL_HI16: bfd_reloc_code_real = 172;
pub const BFD_RELOC_ALPHA_CODEADDR: bfd_reloc_code_real = 171;
pub const BFD_RELOC_ALPHA_LINKAGE: bfd_reloc_code_real = 170;
pub const BFD_RELOC_ALPHA_HINT: bfd_reloc_code_real = 169;
pub const BFD_RELOC_ALPHA_LITUSE: bfd_reloc_code_real = 168;
pub const BFD_RELOC_ALPHA_ELF_LITERAL: bfd_reloc_code_real = 167;
pub const BFD_RELOC_ALPHA_LITERAL: bfd_reloc_code_real = 166;
pub const BFD_RELOC_ALPHA_GPDISP: bfd_reloc_code_real = 165;
pub const BFD_RELOC_ALPHA_GPDISP_LO16: bfd_reloc_code_real = 164;
pub const BFD_RELOC_ALPHA_GPDISP_HI16: bfd_reloc_code_real = 163;
pub const BFD_RELOC_SPU_ADD_PIC: bfd_reloc_code_real = 162;
pub const BFD_RELOC_SPU_PPU64: bfd_reloc_code_real = 161;
pub const BFD_RELOC_SPU_PPU32: bfd_reloc_code_real = 160;
pub const BFD_RELOC_SPU_HI16: bfd_reloc_code_real = 159;
pub const BFD_RELOC_SPU_LO16: bfd_reloc_code_real = 158;
pub const BFD_RELOC_SPU_PCREL16: bfd_reloc_code_real = 157;
pub const BFD_RELOC_SPU_PCREL9b: bfd_reloc_code_real = 156;
pub const BFD_RELOC_SPU_PCREL9a: bfd_reloc_code_real = 155;
pub const BFD_RELOC_SPU_IMM18: bfd_reloc_code_real = 154;
pub const BFD_RELOC_SPU_IMM16W: bfd_reloc_code_real = 153;
pub const BFD_RELOC_SPU_IMM16: bfd_reloc_code_real = 152;
pub const BFD_RELOC_SPU_IMM10W: bfd_reloc_code_real = 151;
pub const BFD_RELOC_SPU_IMM10: bfd_reloc_code_real = 150;
pub const BFD_RELOC_SPU_IMM8: bfd_reloc_code_real = 149;
pub const BFD_RELOC_SPU_IMM7: bfd_reloc_code_real = 148;
pub const BFD_RELOC_SPARC_TLS_TPOFF64: bfd_reloc_code_real = 147;
pub const BFD_RELOC_SPARC_TLS_TPOFF32: bfd_reloc_code_real = 146;
pub const BFD_RELOC_SPARC_TLS_DTPOFF64: bfd_reloc_code_real = 145;
pub const BFD_RELOC_SPARC_TLS_DTPOFF32: bfd_reloc_code_real = 144;
pub const BFD_RELOC_SPARC_TLS_DTPMOD64: bfd_reloc_code_real = 143;
pub const BFD_RELOC_SPARC_TLS_DTPMOD32: bfd_reloc_code_real = 142;
pub const BFD_RELOC_SPARC_TLS_LE_LOX10: bfd_reloc_code_real = 141;
pub const BFD_RELOC_SPARC_TLS_LE_HIX22: bfd_reloc_code_real = 140;
pub const BFD_RELOC_SPARC_TLS_IE_ADD: bfd_reloc_code_real = 139;
pub const BFD_RELOC_SPARC_TLS_IE_LDX: bfd_reloc_code_real = 138;
pub const BFD_RELOC_SPARC_TLS_IE_LD: bfd_reloc_code_real = 137;
pub const BFD_RELOC_SPARC_TLS_IE_LO10: bfd_reloc_code_real = 136;
pub const BFD_RELOC_SPARC_TLS_IE_HI22: bfd_reloc_code_real = 135;
pub const BFD_RELOC_SPARC_TLS_LDO_ADD: bfd_reloc_code_real = 134;
pub const BFD_RELOC_SPARC_TLS_LDO_LOX10: bfd_reloc_code_real = 133;
pub const BFD_RELOC_SPARC_TLS_LDO_HIX22: bfd_reloc_code_real = 132;
pub const BFD_RELOC_SPARC_TLS_LDM_CALL: bfd_reloc_code_real = 131;
pub const BFD_RELOC_SPARC_TLS_LDM_ADD: bfd_reloc_code_real = 130;
pub const BFD_RELOC_SPARC_TLS_LDM_LO10: bfd_reloc_code_real = 129;
pub const BFD_RELOC_SPARC_TLS_LDM_HI22: bfd_reloc_code_real = 128;
pub const BFD_RELOC_SPARC_TLS_GD_CALL: bfd_reloc_code_real = 127;
pub const BFD_RELOC_SPARC_TLS_GD_ADD: bfd_reloc_code_real = 126;
pub const BFD_RELOC_SPARC_TLS_GD_LO10: bfd_reloc_code_real = 125;
pub const BFD_RELOC_SPARC_TLS_GD_HI22: bfd_reloc_code_real = 124;
pub const BFD_RELOC_SPARC_REV32: bfd_reloc_code_real = 123;
pub const BFD_RELOC_SPARC_WDISP10: bfd_reloc_code_real = 122;
pub const BFD_RELOC_SPARC_SIZE64: bfd_reloc_code_real = 121;
pub const BFD_RELOC_SPARC_SIZE32: bfd_reloc_code_real = 120;
pub const BFD_RELOC_SPARC_H34: bfd_reloc_code_real = 119;
pub const BFD_RELOC_SPARC_REGISTER: bfd_reloc_code_real = 118;
pub const BFD_RELOC_SPARC_L44: bfd_reloc_code_real = 117;
pub const BFD_RELOC_SPARC_M44: bfd_reloc_code_real = 116;
pub const BFD_RELOC_SPARC_H44: bfd_reloc_code_real = 115;
pub const BFD_RELOC_SPARC_LOX10: bfd_reloc_code_real = 114;
pub const BFD_RELOC_SPARC_HIX22: bfd_reloc_code_real = 113;
pub const BFD_RELOC_SPARC_PLT64: bfd_reloc_code_real = 112;
pub const BFD_RELOC_SPARC_PLT32: bfd_reloc_code_real = 111;
pub const BFD_RELOC_SPARC_5: bfd_reloc_code_real = 110;
pub const BFD_RELOC_SPARC_6: bfd_reloc_code_real = 109;
pub const BFD_RELOC_SPARC_7: bfd_reloc_code_real = 108;
pub const BFD_RELOC_SPARC_WDISP19: bfd_reloc_code_real = 107;
pub const BFD_RELOC_SPARC_WDISP16: bfd_reloc_code_real = 106;
pub const BFD_RELOC_SPARC_PC_LM22: bfd_reloc_code_real = 105;
pub const BFD_RELOC_SPARC_PC_HM10: bfd_reloc_code_real = 104;
pub const BFD_RELOC_SPARC_PC_HH22: bfd_reloc_code_real = 103;
pub const BFD_RELOC_SPARC_LM22: bfd_reloc_code_real = 102;
pub const BFD_RELOC_SPARC_HM10: bfd_reloc_code_real = 101;
pub const BFD_RELOC_SPARC_HH22: bfd_reloc_code_real = 100;
pub const BFD_RELOC_SPARC_OLO10: bfd_reloc_code_real = 99;
pub const BFD_RELOC_SPARC_11: bfd_reloc_code_real = 98;
pub const BFD_RELOC_SPARC_10: bfd_reloc_code_real = 97;
pub const BFD_RELOC_SPARC_BASE22: bfd_reloc_code_real = 96;
pub const BFD_RELOC_SPARC_BASE13: bfd_reloc_code_real = 95;
pub const BFD_RELOC_SPARC_IRELATIVE: bfd_reloc_code_real = 94;
pub const BFD_RELOC_SPARC_JMP_IREL: bfd_reloc_code_real = 93;
pub const BFD_RELOC_SPARC_GOTDATA_OP: bfd_reloc_code_real = 92;
pub const BFD_RELOC_SPARC_GOTDATA_OP_LOX10: bfd_reloc_code_real = 91;
pub const BFD_RELOC_SPARC_GOTDATA_OP_HIX22: bfd_reloc_code_real = 90;
pub const BFD_RELOC_SPARC_GOTDATA_LOX10: bfd_reloc_code_real = 89;
pub const BFD_RELOC_SPARC_GOTDATA_HIX22: bfd_reloc_code_real = 88;
pub const BFD_RELOC_SPARC_UA64: bfd_reloc_code_real = 87;
pub const BFD_RELOC_SPARC_UA32: bfd_reloc_code_real = 86;
pub const BFD_RELOC_SPARC_UA16: bfd_reloc_code_real = 85;
pub const BFD_RELOC_SPARC_RELATIVE: bfd_reloc_code_real = 84;
pub const BFD_RELOC_SPARC_JMP_SLOT: bfd_reloc_code_real = 83;
pub const BFD_RELOC_SPARC_GLOB_DAT: bfd_reloc_code_real = 82;
pub const BFD_RELOC_SPARC_COPY: bfd_reloc_code_real = 81;
pub const BFD_RELOC_SPARC_WPLT30: bfd_reloc_code_real = 80;
pub const BFD_RELOC_SPARC_PC22: bfd_reloc_code_real = 79;
pub const BFD_RELOC_SPARC_PC10: bfd_reloc_code_real = 78;
pub const BFD_RELOC_SPARC_GOT22: bfd_reloc_code_real = 77;
pub const BFD_RELOC_SPARC_GOT13: bfd_reloc_code_real = 76;
pub const BFD_RELOC_SPARC_GOT10: bfd_reloc_code_real = 75;
pub const BFD_RELOC_SPARC13: bfd_reloc_code_real = 74;
pub const BFD_RELOC_SPARC22: bfd_reloc_code_real = 73;
pub const BFD_RELOC_SPARC_WDISP22: bfd_reloc_code_real = 72;
pub const BFD_RELOC_NONE: bfd_reloc_code_real = 71;
pub const BFD_RELOC_GPREL32: bfd_reloc_code_real = 70;
pub const BFD_RELOC_GPREL16: bfd_reloc_code_real = 69;
pub const BFD_RELOC_LO10: bfd_reloc_code_real = 68;
pub const BFD_RELOC_HI22: bfd_reloc_code_real = 67;
pub const BFD_RELOC_23_PCREL_S2: bfd_reloc_code_real = 66;
pub const BFD_RELOC_16_PCREL_S2: bfd_reloc_code_real = 65;
pub const BFD_RELOC_32_PCREL_S2: bfd_reloc_code_real = 64;
pub const BFD_RELOC_8_FFnn: bfd_reloc_code_real = 63;
pub const BFD_RELOC_RVA: bfd_reloc_code_real = 62;
pub const BFD_RELOC_8_BASEREL: bfd_reloc_code_real = 61;
pub const BFD_RELOC_HI16_S_BASEREL: bfd_reloc_code_real = 60;
pub const BFD_RELOC_HI16_BASEREL: bfd_reloc_code_real = 59;
pub const BFD_RELOC_LO16_BASEREL: bfd_reloc_code_real = 58;
pub const BFD_RELOC_16_BASEREL: bfd_reloc_code_real = 57;
pub const BFD_RELOC_32_BASEREL: bfd_reloc_code_real = 56;
pub const BFD_RELOC_68K_TLS_LE8: bfd_reloc_code_real = 55;
pub const BFD_RELOC_68K_TLS_LE16: bfd_reloc_code_real = 54;
pub const BFD_RELOC_68K_TLS_LE32: bfd_reloc_code_real = 53;
pub const BFD_RELOC_68K_TLS_IE8: bfd_reloc_code_real = 52;
pub const BFD_RELOC_68K_TLS_IE16: bfd_reloc_code_real = 51;
pub const BFD_RELOC_68K_TLS_IE32: bfd_reloc_code_real = 50;
pub const BFD_RELOC_68K_TLS_LDO8: bfd_reloc_code_real = 49;
pub const BFD_RELOC_68K_TLS_LDO16: bfd_reloc_code_real = 48;
pub const BFD_RELOC_68K_TLS_LDO32: bfd_reloc_code_real = 47;
pub const BFD_RELOC_68K_TLS_LDM8: bfd_reloc_code_real = 46;
pub const BFD_RELOC_68K_TLS_LDM16: bfd_reloc_code_real = 45;
pub const BFD_RELOC_68K_TLS_LDM32: bfd_reloc_code_real = 44;
pub const BFD_RELOC_68K_TLS_GD8: bfd_reloc_code_real = 43;
pub const BFD_RELOC_68K_TLS_GD16: bfd_reloc_code_real = 42;
pub const BFD_RELOC_68K_TLS_GD32: bfd_reloc_code_real = 41;
pub const BFD_RELOC_68K_RELATIVE: bfd_reloc_code_real = 40;
pub const BFD_RELOC_68K_JMP_SLOT: bfd_reloc_code_real = 39;
pub const BFD_RELOC_68K_GLOB_DAT: bfd_reloc_code_real = 38;
pub const BFD_RELOC_SIZE64: bfd_reloc_code_real = 37;
pub const BFD_RELOC_SIZE32: bfd_reloc_code_real = 36;
pub const BFD_RELOC_8_PLTOFF: bfd_reloc_code_real = 35;
pub const BFD_RELOC_HI16_S_PLTOFF: bfd_reloc_code_real = 34;
pub const BFD_RELOC_HI16_PLTOFF: bfd_reloc_code_real = 33;
pub const BFD_RELOC_LO16_PLTOFF: bfd_reloc_code_real = 32;
pub const BFD_RELOC_16_PLTOFF: bfd_reloc_code_real = 31;
pub const BFD_RELOC_32_PLTOFF: bfd_reloc_code_real = 30;
pub const BFD_RELOC_64_PLTOFF: bfd_reloc_code_real = 29;
pub const BFD_RELOC_8_PLT_PCREL: bfd_reloc_code_real = 28;
pub const BFD_RELOC_16_PLT_PCREL: bfd_reloc_code_real = 27;
pub const BFD_RELOC_24_PLT_PCREL: bfd_reloc_code_real = 26;
pub const BFD_RELOC_32_PLT_PCREL: bfd_reloc_code_real = 25;
pub const BFD_RELOC_64_PLT_PCREL: bfd_reloc_code_real = 24;
pub const BFD_RELOC_8_GOTOFF: bfd_reloc_code_real = 23;
pub const BFD_RELOC_HI16_S_GOTOFF: bfd_reloc_code_real = 22;
pub const BFD_RELOC_HI16_GOTOFF: bfd_reloc_code_real = 21;
pub const BFD_RELOC_LO16_GOTOFF: bfd_reloc_code_real = 20;
pub const BFD_RELOC_16_GOTOFF: bfd_reloc_code_real = 19;
pub const BFD_RELOC_32_GOTOFF: bfd_reloc_code_real = 18;
pub const BFD_RELOC_8_GOT_PCREL: bfd_reloc_code_real = 17;
pub const BFD_RELOC_16_GOT_PCREL: bfd_reloc_code_real = 16;
pub const BFD_RELOC_32_GOT_PCREL: bfd_reloc_code_real = 15;
pub const BFD_RELOC_32_SECREL: bfd_reloc_code_real = 14;
pub const BFD_RELOC_8_PCREL: bfd_reloc_code_real = 13;
pub const BFD_RELOC_12_PCREL: bfd_reloc_code_real = 12;
pub const BFD_RELOC_16_PCREL: bfd_reloc_code_real = 11;
pub const BFD_RELOC_24_PCREL: bfd_reloc_code_real = 10;
pub const BFD_RELOC_32_PCREL: bfd_reloc_code_real = 9;
pub const BFD_RELOC_64_PCREL: bfd_reloc_code_real = 8;
pub const BFD_RELOC_8: bfd_reloc_code_real = 7;
pub const BFD_RELOC_14: bfd_reloc_code_real = 6;
pub const BFD_RELOC_16: bfd_reloc_code_real = 5;
pub const BFD_RELOC_24: bfd_reloc_code_real = 4;
pub const BFD_RELOC_26: bfd_reloc_code_real = 3;
pub const BFD_RELOC_32: bfd_reloc_code_real = 2;
pub const BFD_RELOC_64: bfd_reloc_code_real = 1;
pub const _dummy_first_bfd_reloc_code_real: bfd_reloc_code_real = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub size: libc::c_uint,
    pub contents: *mut bfd_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub section: *mut asection,
}
pub type bfd_link_order_type = libc::c_uint;
pub const bfd_symbol_reloc_link_order: bfd_link_order_type = 4;
pub const bfd_section_reloc_link_order: bfd_link_order_type = 3;
pub const bfd_data_link_order: bfd_link_order_type = 2;
pub const bfd_indirect_link_order: bfd_link_order_type = 1;
pub const bfd_undefined_link_order: bfd_link_order_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_symbol {
    pub the_bfd: *mut bfd,
    pub name: *const libc::c_char,
    pub value: symvalue,
    pub flags: flagword,
    pub section: *mut bfd_section,
    pub udata: C2RustUnnamed_6,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub p: *mut libc::c_void,
    pub i: bfd_vma,
}
pub type flagword = libc::c_uint;
pub type symvalue = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct relent_chain {
    pub relent: arelent,
    pub next: *mut relent_chain,
}
pub type arelent = reloc_cache_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct reloc_cache_entry {
    pub sym_ptr_ptr: *mut *mut bfd_symbol,
    pub address: bfd_size_type,
    pub addend: bfd_vma,
    pub howto: *const reloc_howto_type,
}
pub type reloc_howto_type = reloc_howto_struct;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct reloc_howto_struct {
    pub type_0: libc::c_uint,
    #[bitfield(name = "size", ty = "libc::c_uint", bits = "0..=2")]
    #[bitfield(name = "bitsize", ty = "libc::c_uint", bits = "3..=9")]
    #[bitfield(name = "rightshift", ty = "libc::c_uint", bits = "10..=15")]
    #[bitfield(name = "bitpos", ty = "libc::c_uint", bits = "16..=21")]
    #[bitfield(name = "complain_on_overflow", ty = "complain_overflow", bits = "22..=23")]
    #[bitfield(name = "negate", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "pc_relative", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "partial_inplace", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "pcrel_offset", ty = "libc::c_uint", bits = "27..=27")]
    pub size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [u8; 4],
    pub src_mask: bfd_vma,
    pub dst_mask: bfd_vma,
    pub special_function: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut arelent,
            *mut bfd_symbol,
            *mut libc::c_void,
            *mut asection,
            *mut bfd,
            *mut *mut libc::c_char,
        ) -> bfd_reloc_status_type,
    >,
    pub name: *const libc::c_char,
}
pub type bfd_reloc_status_type = bfd_reloc_status;
pub type bfd_reloc_status = libc::c_uint;
pub const bfd_reloc_dangerous: bfd_reloc_status = 9;
pub const bfd_reloc_undefined: bfd_reloc_status = 8;
pub const bfd_reloc_other: bfd_reloc_status = 7;
pub const bfd_reloc_notsupported: bfd_reloc_status = 6;
pub const bfd_reloc_continue: bfd_reloc_status = 5;
pub const bfd_reloc_outofrange: bfd_reloc_status = 4;
pub const bfd_reloc_overflow: bfd_reloc_status = 3;
pub const bfd_reloc_ok: bfd_reloc_status = 2;
pub type complain_overflow = libc::c_uint;
pub const complain_overflow_unsigned: complain_overflow = 3;
pub const complain_overflow_signed: complain_overflow = 2;
pub const complain_overflow_bitfield: complain_overflow = 1;
pub const complain_overflow_dont: complain_overflow = 0;
pub type file_ptr = libc::c_long;
pub type alent = lineno_cache_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lineno_cache_entry {
    pub line_number: libc::c_uint,
    pub u: C2RustUnnamed_7,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub sym: *mut bfd_symbol,
    pub offset: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct relax_table {
    pub addr: bfd_vma,
    pub size: libc::c_int,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_hash_table {
    pub table: *mut *mut bfd_hash_entry,
    pub newfunc: Option::<
        unsafe extern "C" fn(
            *mut bfd_hash_entry,
            *mut bfd_hash_table,
            *const libc::c_char,
        ) -> *mut bfd_hash_entry,
    >,
    pub memory: *mut libc::c_void,
    pub size: libc::c_uint,
    pub count: libc::c_uint,
    pub entsize: libc::c_uint,
    #[bitfield(name = "frozen", ty = "libc::c_uint", bits = "0..=0")]
    pub frozen: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_hash_entry {
    pub next: *mut bfd_hash_entry,
    pub string: *const libc::c_char,
    pub hash: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_hash_table {
    pub table: bfd_hash_table,
    pub undefs: *mut bfd_link_hash_entry,
    pub undefs_tail: *mut bfd_link_hash_entry,
    pub hash_table_free: Option::<unsafe extern "C" fn(*mut bfd) -> ()>,
    pub type_0: bfd_link_hash_table_type,
}
pub type bfd_link_hash_table_type = libc::c_uint;
pub const bfd_link_elf_hash_table: bfd_link_hash_table_type = 1;
pub const bfd_link_generic_hash_table: bfd_link_hash_table_type = 0;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_link_hash_entry {
    pub root: bfd_hash_entry,
    #[bitfield(name = "type_0", ty = "bfd_link_hash_type", bits = "0..=7")]
    #[bitfield(name = "non_ir_ref_regular", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "non_ir_ref_dynamic", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "linker_def", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "ldscript_def", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "rel_from_abs", ty = "libc::c_uint", bits = "12..=12")]
    pub type_0_non_ir_ref_regular_non_ir_ref_dynamic_linker_def_ldscript_def_rel_from_abs: [u8; 2],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 6],
    pub u: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub undef: C2RustUnnamed_12,
    pub def: C2RustUnnamed_11,
    pub i: C2RustUnnamed_10,
    pub c: C2RustUnnamed_9,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub next: *mut bfd_link_hash_entry,
    pub p: *mut bfd_link_hash_common_entry,
    pub size: bfd_size_type,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_hash_common_entry {
    pub alignment_power: libc::c_uint,
    pub section: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub next: *mut bfd_link_hash_entry,
    pub link: *mut bfd_link_hash_entry,
    pub warning: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub next: *mut bfd_link_hash_entry,
    pub section: *mut asection,
    pub value: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub next: *mut bfd_link_hash_entry,
    pub abfd: *mut bfd,
}
pub type bfd_link_hash_type = libc::c_uint;
pub const bfd_link_hash_warning: bfd_link_hash_type = 7;
pub const bfd_link_hash_indirect: bfd_link_hash_type = 6;
pub const bfd_link_hash_common: bfd_link_hash_type = 5;
pub const bfd_link_hash_defweak: bfd_link_hash_type = 4;
pub const bfd_link_hash_defined: bfd_link_hash_type = 3;
pub const bfd_link_hash_undefweak: bfd_link_hash_type = 2;
pub const bfd_link_hash_undefined: bfd_link_hash_type = 1;
pub const bfd_link_hash_new: bfd_link_hash_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_callbacks {
    pub add_archive_element: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *const libc::c_char,
            *mut *mut bfd,
        ) -> bool,
    >,
    pub multiple_definition: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub multiple_common: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd,
            bfd_link_hash_type,
            bfd_vma,
        ) -> (),
    >,
    pub add_to_set: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            bfd_reloc_code_real_type,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub constructor: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            bool,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub warning: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub undefined_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
            bool,
        ) -> (),
    >,
    pub reloc_overflow: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *const libc::c_char,
            *const libc::c_char,
            bfd_vma,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub reloc_dangerous: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub unattached_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub notice: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd_link_hash_entry,
            *mut bfd,
            *mut asection,
            bfd_vma,
            flagword,
        ) -> bool,
    >,
    pub einfo: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub info: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub minfo: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub override_segment_assignment: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *mut asection,
            *mut asection,
            bool,
        ) -> bool,
    >,
    pub examine_strtab: Option::<unsafe extern "C" fn(*mut elf_strtab_hash) -> ()>,
    pub ctf_new_symbol: Option::<
        unsafe extern "C" fn(libc::c_int, *mut elf_internal_sym) -> (),
    >,
    pub ctf_new_dynsym: Option::<
        unsafe extern "C" fn(libc::c_int, *mut elf_internal_sym) -> (),
    >,
    pub emit_ctf: Option::<unsafe extern "C" fn() -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_sym {
    pub st_value: bfd_vma,
    pub st_size: bfd_vma,
    pub st_name: libc::c_ulong,
    pub st_info: libc::c_uchar,
    pub st_other: libc::c_uchar,
    pub st_target_internal: libc::c_uchar,
    pub st_shndx: libc::c_uint,
}
pub type bfd_signed_vma = libc::c_long;
pub type compressed_debug_section_type = libc::c_uint;
pub const COMPRESS_DEBUG_GABI_ZLIB: compressed_debug_section_type = 5;
pub const COMPRESS_DEBUG_GNU_ZLIB: compressed_debug_section_type = 3;
pub const COMPRESS_DEBUG: compressed_debug_section_type = 1;
pub const COMPRESS_DEBUG_NONE: compressed_debug_section_type = 0;
pub type textrel_check_method = libc::c_uint;
pub const textrel_check_error: textrel_check_method = 2;
pub const textrel_check_warning: textrel_check_method = 1;
pub const textrel_check_none: textrel_check_method = 0;
pub type report_method = libc::c_uint;
pub const RM_DIAGNOSE: report_method = 2;
pub const RM_IGNORE: report_method = 1;
pub const RM_NOT_YET_SET: report_method = 0;
pub type bfd_link_common_skip_ar_symbols = libc::c_uint;
pub const bfd_link_common_skip_all: bfd_link_common_skip_ar_symbols = 3;
pub const bfd_link_common_skip_data: bfd_link_common_skip_ar_symbols = 2;
pub const bfd_link_common_skip_text: bfd_link_common_skip_ar_symbols = 1;
pub const bfd_link_common_skip_none: bfd_link_common_skip_ar_symbols = 0;
pub type bfd_link_elf_stt_common = libc::c_uint;
pub const no_elf_stt_common: bfd_link_elf_stt_common = 2;
pub const elf_stt_common: bfd_link_elf_stt_common = 1;
pub const unchanged: bfd_link_elf_stt_common = 0;
pub type bfd_link_discard = libc::c_uint;
pub const discard_all: bfd_link_discard = 3;
pub const discard_l: bfd_link_discard = 2;
pub const discard_none: bfd_link_discard = 1;
pub const discard_sec_merge: bfd_link_discard = 0;
pub type bfd_link_strip = libc::c_uint;
pub const strip_all: bfd_link_strip = 3;
pub const strip_some: bfd_link_strip = 2;
pub const strip_debugger: bfd_link_strip = 1;
pub const strip_none: bfd_link_strip = 0;
pub type output_type = libc::c_uint;
pub const type_dll: output_type = 3;
pub const type_relocatable: output_type = 2;
pub const type_pie: output_type = 1;
pub const type_pde: output_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub after_write_object_contents: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub style: *const libc::c_char,
    pub sec: *mut asection,
}
pub type asymbol = bfd_symbol;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_segment_map {
    pub next: *mut elf_segment_map,
    pub p_type: libc::c_ulong,
    pub p_flags: libc::c_ulong,
    pub p_paddr: bfd_vma,
    pub p_vaddr_offset: bfd_vma,
    pub p_align: bfd_vma,
    pub p_size: bfd_vma,
    #[bitfield(name = "p_flags_valid", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "p_paddr_valid", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "p_align_valid", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "p_size_valid", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "includes_filehdr", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "includes_phdrs", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "no_sort_lma", ty = "libc::c_uint", bits = "6..=6")]
    pub p_flags_valid_p_paddr_valid_p_align_valid_p_size_valid_includes_filehdr_includes_phdrs_no_sort_lma: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
    pub idx: libc::c_uint,
    pub count: libc::c_uint,
    pub sections: [*mut asection; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct core_elf_obj_tdata {
    pub signal: libc::c_int,
    pub pid: libc::c_int,
    pub lwpid: libc::c_int,
    pub program: *mut libc::c_char,
    pub command: *mut libc::c_char,
}
pub type elf_gnu_osabi = libc::c_uint;
pub const elf_gnu_osabi_retain: elf_gnu_osabi = 8;
pub const elf_gnu_osabi_unique: elf_gnu_osabi = 4;
pub const elf_gnu_osabi_ifunc: elf_gnu_osabi = 2;
pub const elf_gnu_osabi_mbind: elf_gnu_osabi = 1;
pub type dynamic_lib_link_class = libc::c_uint;
pub const DYN_NO_NEEDED: dynamic_lib_link_class = 8;
pub const DYN_NO_ADD_NEEDED: dynamic_lib_link_class = 4;
pub const DYN_DT_NEEDED: dynamic_lib_link_class = 2;
pub const DYN_AS_NEEDED: dynamic_lib_link_class = 1;
pub const DYN_NORMAL: dynamic_lib_link_class = 0;
pub type elf_target_id = libc::c_uint;
pub const GENERIC_ELF_DATA: elf_target_id = 38;
pub const RISCV_ELF_DATA: elf_target_id = 37;
pub const TILEPRO_ELF_DATA: elf_target_id = 36;
pub const TILEGX_ELF_DATA: elf_target_id = 35;
pub const XTENSA_ELF_DATA: elf_target_id = 34;
pub const X86_64_ELF_DATA: elf_target_id = 33;
pub const TIC6X_ELF_DATA: elf_target_id = 32;
pub const SPU_ELF_DATA: elf_target_id = 31;
pub const SPARC_ELF_DATA: elf_target_id = 30;
pub const SH_ELF_DATA: elf_target_id = 29;
pub const S390_ELF_DATA: elf_target_id = 28;
pub const PRU_ELF_DATA: elf_target_id = 27;
pub const PPC64_ELF_DATA: elf_target_id = 26;
pub const PPC32_ELF_DATA: elf_target_id = 25;
pub const OR1K_ELF_DATA: elf_target_id = 24;
pub const NIOS2_ELF_DATA: elf_target_id = 23;
pub const NDS32_ELF_DATA: elf_target_id = 22;
pub const MN10300_ELF_DATA: elf_target_id = 21;
pub const MIPS_ELF_DATA: elf_target_id = 20;
pub const MICROBLAZE_ELF_DATA: elf_target_id = 19;
pub const METAG_ELF_DATA: elf_target_id = 18;
pub const M68K_ELF_DATA: elf_target_id = 17;
pub const M68HC11_ELF_DATA: elf_target_id = 16;
pub const M32R_ELF_DATA: elf_target_id = 15;
pub const LM32_ELF_DATA: elf_target_id = 14;
pub const IA64_ELF_DATA: elf_target_id = 13;
pub const I386_ELF_DATA: elf_target_id = 12;
pub const HPPA64_ELF_DATA: elf_target_id = 11;
pub const HPPA32_ELF_DATA: elf_target_id = 10;
pub const FRV_ELF_DATA: elf_target_id = 9;
pub const CSKY_ELF_DATA: elf_target_id = 8;
pub const CRIS_ELF_DATA: elf_target_id = 7;
pub const BFIN_ELF_DATA: elf_target_id = 6;
pub const AVR_ELF_DATA: elf_target_id = 5;
pub const ARM_ELF_DATA: elf_target_id = 4;
pub const ARC_ELF_DATA: elf_target_id = 3;
pub const ALPHA_ELF_DATA: elf_target_id = 2;
pub const AARCH64_ELF_DATA: elf_target_id = 1;
pub type Elf_Internal_Shdr = elf_internal_shdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_shdr {
    pub sh_name: libc::c_uint,
    pub sh_type: libc::c_uint,
    pub sh_flags: bfd_vma,
    pub sh_addr: bfd_vma,
    pub sh_offset: file_ptr,
    pub sh_size: bfd_size_type,
    pub sh_link: libc::c_uint,
    pub sh_info: libc::c_uint,
    pub sh_addralign: bfd_vma,
    pub sh_entsize: bfd_size_type,
    pub bfd_section: *mut asection,
    pub contents: *mut libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sdt_note {
    pub next: *mut sdt_note,
    pub size: bfd_size_type,
    pub data: [bfd_byte; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct obj_attribute_list {
    pub next: *mut obj_attribute_list,
    pub tag: libc::c_uint,
    pub attr: obj_attribute,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct obj_attribute {
    pub type_0: libc::c_int,
    pub i: libc::c_uint,
    pub s: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_property_list {
    pub next: *mut elf_property_list,
    pub property: elf_property,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_property {
    pub pr_type: libc::c_uint,
    pub pr_datasz: libc::c_uint,
    pub u: C2RustUnnamed_14,
    pub pr_kind: elf_property_kind,
}
pub type elf_property_kind = libc::c_uint;
pub const property_number: elf_property_kind = 4;
pub const property_remove: elf_property_kind = 3;
pub const property_corrupt: elf_property_kind = 2;
pub const property_ignored: elf_property_kind = 1;
pub const property_unknown: elf_property_kind = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_14 {
    pub number: bfd_vma,
}
pub type Elf_Internal_Verneed = elf_internal_verneed;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verneed {
    pub vn_version: libc::c_ushort,
    pub vn_cnt: libc::c_ushort,
    pub vn_file: libc::c_ulong,
    pub vn_aux: libc::c_ulong,
    pub vn_next: libc::c_ulong,
    pub vn_bfd: *mut bfd,
    pub vn_filename: *const libc::c_char,
    pub vn_auxptr: *mut elf_internal_vernaux,
    pub vn_nextref: *mut elf_internal_verneed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_vernaux {
    pub vna_hash: libc::c_ulong,
    pub vna_flags: libc::c_ushort,
    pub vna_other: libc::c_ushort,
    pub vna_name: libc::c_ulong,
    pub vna_next: libc::c_ulong,
    pub vna_nodename: *const libc::c_char,
    pub vna_nextptr: *mut elf_internal_vernaux,
}
pub type Elf_Internal_Verdef = elf_internal_verdef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verdef {
    pub vd_version: libc::c_ushort,
    pub vd_flags: libc::c_ushort,
    pub vd_ndx: libc::c_ushort,
    pub vd_cnt: libc::c_ushort,
    pub vd_hash: libc::c_ulong,
    pub vd_aux: libc::c_ulong,
    pub vd_next: libc::c_ulong,
    pub vd_bfd: *mut bfd,
    pub vd_nodename: *const libc::c_char,
    pub vd_nextdef: *mut elf_internal_verdef,
    pub vd_auxptr: *mut elf_internal_verdaux,
    pub vd_exp_refno: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verdaux {
    pub vda_name: libc::c_ulong,
    pub vda_next: libc::c_ulong,
    pub vda_nodename: *const libc::c_char,
    pub vda_nextptr: *mut elf_internal_verdaux,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub refcounts: *mut bfd_signed_vma,
    pub offsets: *mut bfd_vma,
    pub ents: *mut *mut got_entry,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_link_hash_entry {
    pub root: bfd_link_hash_entry,
    pub indx: libc::c_long,
    pub dynindx: libc::c_long,
    pub got: gotplt_union,
    pub plt: gotplt_union,
    pub size: bfd_size_type,
    pub dyn_relocs: *mut elf_dyn_relocs,
    #[bitfield(name = "type_0", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "other", ty = "libc::c_uint", bits = "8..=15")]
    #[bitfield(name = "target_internal", ty = "libc::c_uint", bits = "16..=23")]
    #[bitfield(name = "ref_regular", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "def_regular", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "ref_dynamic", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "def_dynamic", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "ref_regular_nonweak", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "ref_ir_nonweak", ty = "libc::c_uint", bits = "29..=29")]
    #[bitfield(name = "dynamic_adjusted", ty = "libc::c_uint", bits = "30..=30")]
    #[bitfield(name = "needs_copy", ty = "libc::c_uint", bits = "31..=31")]
    #[bitfield(name = "needs_plt", ty = "libc::c_uint", bits = "32..=32")]
    #[bitfield(name = "non_elf", ty = "libc::c_uint", bits = "33..=33")]
    #[bitfield(name = "versioned", ty = "elf_symbol_version", bits = "34..=35")]
    #[bitfield(name = "forced_local", ty = "libc::c_uint", bits = "36..=36")]
    #[bitfield(name = "dynamic", ty = "libc::c_uint", bits = "37..=37")]
    #[bitfield(name = "mark", ty = "libc::c_uint", bits = "38..=38")]
    #[bitfield(name = "non_got_ref", ty = "libc::c_uint", bits = "39..=39")]
    #[bitfield(name = "dynamic_def", ty = "libc::c_uint", bits = "40..=40")]
    #[bitfield(name = "ref_dynamic_nonweak", ty = "libc::c_uint", bits = "41..=41")]
    #[bitfield(name = "pointer_equality_needed", ty = "libc::c_uint", bits = "42..=42")]
    #[bitfield(name = "unique_global", ty = "libc::c_uint", bits = "43..=43")]
    #[bitfield(name = "protected_def", ty = "libc::c_uint", bits = "44..=44")]
    #[bitfield(name = "start_stop", ty = "libc::c_uint", bits = "45..=45")]
    #[bitfield(name = "is_weakalias", ty = "libc::c_uint", bits = "46..=46")]
    pub type_0_other_target_internal_ref_regular_def_regular_ref_dynamic_def_dynamic_ref_regular_nonweak_ref_ir_nonweak_dynamic_adjusted_needs_copy_needs_plt_non_elf_versioned_forced_local_dynamic_mark_non_got_ref_dynamic_def_ref_dynamic_nonweak_pointer_equality_needed_unique_global_protected_def_start_stop_is_weakalias: [u8; 6],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 2],
    pub dynstr_index: libc::c_ulong,
    pub u: C2RustUnnamed_18,
    pub verinfo: C2RustUnnamed_17,
    pub u2: C2RustUnnamed_16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_16 {
    pub start_stop_section: *mut asection,
    pub vtable: *mut elf_link_virtual_table_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_virtual_table_entry {
    pub size: size_t,
    pub used: *mut bool,
    pub parent: *mut elf_link_hash_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_17 {
    pub verdef: *mut Elf_Internal_Verdef,
    pub vertree: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_18 {
    pub alias: *mut elf_link_hash_entry,
    pub elf_hash_value: libc::c_ulong,
}
pub type elf_symbol_version = libc::c_uint;
pub const versioned_hidden: elf_symbol_version = 3;
pub const versioned: elf_symbol_version = 2;
pub const unversioned: elf_symbol_version = 1;
pub const unknown: elf_symbol_version = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_dyn_relocs {
    pub next: *mut elf_dyn_relocs,
    pub sec: *mut asection,
    pub count: bfd_size_type,
    pub pc_count: bfd_size_type,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union gotplt_union {
    pub refcount: bfd_signed_vma,
    pub offset: bfd_vma,
    pub glist: *mut got_entry,
    pub plist: *mut plt_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_section_list {
    pub hdr: Elf_Internal_Shdr,
    pub ndx: libc::c_uint,
    pub next: *mut elf_section_list,
}
pub type Elf_Internal_Phdr = elf_internal_phdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_phdr {
    pub p_type: libc::c_ulong,
    pub p_flags: libc::c_ulong,
    pub p_offset: bfd_vma,
    pub p_vaddr: bfd_vma,
    pub p_paddr: bfd_vma,
    pub p_filesz: bfd_vma,
    pub p_memsz: bfd_vma,
    pub p_align: bfd_vma,
}
pub type Elf_Internal_Ehdr = elf_internal_ehdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_ehdr {
    pub e_ident: [libc::c_uchar; 16],
    pub e_entry: bfd_vma,
    pub e_phoff: bfd_size_type,
    pub e_shoff: bfd_size_type,
    pub e_version: libc::c_ulong,
    pub e_flags: libc::c_ulong,
    pub e_type: libc::c_ushort,
    pub e_machine: libc::c_ushort,
    pub e_ehsize: libc::c_uint,
    pub e_phentsize: libc::c_uint,
    pub e_phnum: libc::c_uint,
    pub e_shentsize: libc::c_uint,
    pub e_shnum: libc::c_uint,
    pub e_shstrndx: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct artdata {
    pub first_file_filepos: file_ptr,
    pub cache: htab_t,
    pub archive_head: *mut bfd,
    pub symdefs: *mut carsym,
    pub symdef_count: symindex,
    pub extended_names: *mut libc::c_char,
    pub extended_names_size: bfd_size_type,
    pub armap_timestamp: libc::c_long,
    pub armap_datepos: file_ptr,
    pub tdata: *mut libc::c_void,
}
pub type symindex = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct carsym {
    pub name: *const libc::c_char,
    pub file_offset: file_ptr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_19 {
    pub next: *mut bfd,
    pub hash: *mut bfd_link_hash_table,
}
pub type ufile_ptr = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_arch_info {
    pub bits_per_word: libc::c_int,
    pub bits_per_address: libc::c_int,
    pub bits_per_byte: libc::c_int,
    pub arch: bfd_architecture,
    pub mach: libc::c_ulong,
    pub arch_name: *const libc::c_char,
    pub printable_name: *const libc::c_char,
    pub section_align_power: libc::c_uint,
    pub the_default: bool,
    pub compatible: Option::<
        unsafe extern "C" fn(
            *const bfd_arch_info,
            *const bfd_arch_info,
        ) -> *const bfd_arch_info,
    >,
    pub scan: Option::<
        unsafe extern "C" fn(*const bfd_arch_info, *const libc::c_char) -> bool,
    >,
    pub fill: Option::<
        unsafe extern "C" fn(bfd_size_type, bool, bool) -> *mut libc::c_void,
    >,
    pub next: *const bfd_arch_info,
    pub max_reloc_offset_into_insn: libc::c_int,
}
pub type bfd_architecture = libc::c_uint;
pub const bfd_arch_last: bfd_architecture = 88;
pub const bfd_arch_csky: bfd_architecture = 87;
pub const bfd_arch_nfp: bfd_architecture = 86;
pub const bfd_arch_pru: bfd_architecture = 85;
pub const bfd_arch_wasm32: bfd_architecture = 84;
pub const bfd_arch_visium: bfd_architecture = 83;
pub const bfd_arch_nios2: bfd_architecture = 82;
pub const bfd_arch_aarch64: bfd_architecture = 81;
pub const bfd_arch_tilegx: bfd_architecture = 80;
pub const bfd_arch_tilepro: bfd_architecture = 79;
pub const bfd_arch_microblaze: bfd_architecture = 78;
pub const bfd_arch_lm32: bfd_architecture = 77;
pub const bfd_arch_z80: bfd_architecture = 76;
pub const bfd_arch_xtensa: bfd_architecture = 75;
pub const bfd_arch_xgate: bfd_architecture = 74;
pub const bfd_arch_xc16x: bfd_architecture = 73;
pub const bfd_arch_msp430: bfd_architecture = 72;
pub const bfd_arch_xstormy16: bfd_architecture = 71;
pub const bfd_arch_mmix: bfd_architecture = 70;
pub const bfd_arch_score: bfd_architecture = 69;
pub const bfd_arch_s390: bfd_architecture = 68;
pub const bfd_arch_rx: bfd_architecture = 67;
pub const bfd_arch_rl78: bfd_architecture = 66;
pub const bfd_arch_riscv: bfd_architecture = 65;
pub const bfd_arch_cris: bfd_architecture = 64;
pub const bfd_arch_crx: bfd_architecture = 63;
pub const bfd_arch_cr16: bfd_architecture = 62;
pub const bfd_arch_bfin: bfd_architecture = 61;
pub const bfd_arch_avr: bfd_architecture = 60;
pub const bfd_arch_pj: bfd_architecture = 59;
pub const bfd_arch_mt: bfd_architecture = 58;
pub const bfd_arch_epiphany: bfd_architecture = 57;
pub const bfd_arch_bpf: bfd_architecture = 56;
pub const bfd_arch_iq2000: bfd_architecture = 55;
pub const bfd_arch_ip2k: bfd_architecture = 54;
pub const bfd_arch_ia64: bfd_architecture = 53;
pub const bfd_arch_metag: bfd_architecture = 52;
pub const bfd_arch_mep: bfd_architecture = 51;
pub const bfd_arch_mcore: bfd_architecture = 50;
pub const bfd_arch_ft32: bfd_architecture = 49;
pub const bfd_arch_moxie: bfd_architecture = 48;
pub const bfd_arch_frv: bfd_architecture = 47;
pub const bfd_arch_fr30: bfd_architecture = 46;
pub const bfd_arch_mn10300: bfd_architecture = 45;
pub const bfd_arch_mn10200: bfd_architecture = 44;
pub const bfd_arch_m32r: bfd_architecture = 43;
pub const bfd_arch_m32c: bfd_architecture = 42;
pub const bfd_arch_arc: bfd_architecture = 41;
pub const bfd_arch_v850_rh850: bfd_architecture = 40;
pub const bfd_arch_v850: bfd_architecture = 39;
pub const bfd_arch_tic6x: bfd_architecture = 38;
pub const bfd_arch_tic54x: bfd_architecture = 37;
pub const bfd_arch_tic4x: bfd_architecture = 36;
pub const bfd_arch_tic30: bfd_architecture = 35;
pub const bfd_arch_ns32k: bfd_architecture = 34;
pub const bfd_arch_nds32: bfd_architecture = 33;
pub const bfd_arch_arm: bfd_architecture = 32;
pub const bfd_arch_alpha: bfd_architecture = 31;
pub const bfd_arch_sh: bfd_architecture = 30;
pub const bfd_arch_z8k: bfd_architecture = 29;
pub const bfd_arch_s12z: bfd_architecture = 28;
pub const bfd_arch_m9s12xg: bfd_architecture = 27;
pub const bfd_arch_m9s12x: bfd_architecture = 26;
pub const bfd_arch_m68hc12: bfd_architecture = 25;
pub const bfd_arch_m68hc11: bfd_architecture = 24;
pub const bfd_arch_dlx: bfd_architecture = 23;
pub const bfd_arch_d30v: bfd_architecture = 22;
pub const bfd_arch_d10v: bfd_architecture = 21;
pub const bfd_arch_hppa: bfd_architecture = 20;
pub const bfd_arch_rs6000: bfd_architecture = 19;
pub const bfd_arch_powerpc: bfd_architecture = 18;
pub const bfd_arch_pdp11: bfd_architecture = 17;
pub const bfd_arch_h8300: bfd_architecture = 16;
pub const bfd_arch_pyramid: bfd_architecture = 15;
pub const bfd_arch_m98k: bfd_architecture = 14;
pub const bfd_arch_convex: bfd_architecture = 13;
pub const bfd_arch_romp: bfd_architecture = 12;
pub const bfd_arch_iamcu: bfd_architecture = 11;
pub const bfd_arch_k1om: bfd_architecture = 10;
pub const bfd_arch_l1om: bfd_architecture = 9;
pub const bfd_arch_i386: bfd_architecture = 8;
pub const bfd_arch_mips: bfd_architecture = 7;
pub const bfd_arch_spu: bfd_architecture = 6;
pub const bfd_arch_sparc: bfd_architecture = 5;
pub const bfd_arch_or1k: bfd_architecture = 4;
pub const bfd_arch_vax: bfd_architecture = 3;
pub const bfd_arch_m68k: bfd_architecture = 2;
pub const bfd_arch_obscure: bfd_architecture = 1;
pub const bfd_arch_unknown: bfd_architecture = 0;
pub type bfd_plugin_format = libc::c_uint;
pub const bfd_plugin_no: bfd_plugin_format = 2;
pub const bfd_plugin_yes: bfd_plugin_format = 1;
pub const bfd_plugin_unknown: bfd_plugin_format = 0;
pub type bfd_direction = libc::c_uint;
pub const both_direction: bfd_direction = 3;
pub const write_direction: bfd_direction = 2;
pub const read_direction: bfd_direction = 1;
pub const no_direction: bfd_direction = 0;
pub type bfd_format = libc::c_uint;
pub const bfd_type_end: bfd_format = 4;
pub const bfd_core: bfd_format = 3;
pub const bfd_archive: bfd_format = 2;
pub const bfd_object: bfd_format = 1;
pub const bfd_unknown: bfd_format = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_iovec {
    pub bread: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void, file_ptr) -> file_ptr,
    >,
    pub bwrite: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_void, file_ptr) -> file_ptr,
    >,
    pub btell: Option::<unsafe extern "C" fn(*mut bfd) -> file_ptr>,
    pub bseek: Option::<
        unsafe extern "C" fn(*mut bfd, file_ptr, libc::c_int) -> libc::c_int,
    >,
    pub bclose: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub bflush: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub bstat: Option::<unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int>,
    pub bmmap: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            bfd_size_type,
            libc::c_int,
            libc::c_int,
            file_ptr,
            *mut *mut libc::c_void,
            *mut bfd_size_type,
        ) -> *mut libc::c_void,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_target {
    pub name: *const libc::c_char,
    pub flavour: bfd_flavour,
    pub byteorder: bfd_endian,
    pub header_byteorder: bfd_endian,
    pub object_flags: flagword,
    pub section_flags: flagword,
    pub symbol_leading_char: libc::c_char,
    pub ar_pad_char: libc::c_char,
    pub ar_max_namelen: libc::c_uchar,
    pub match_priority: libc::c_uchar,
    pub keep_unused_section_symbols: bool,
    pub bfd_getx64: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t>,
    pub bfd_getx_signed_64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
    >,
    pub bfd_putx64: Option::<
        unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
    >,
    pub bfd_getx32: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_getx_signed_32: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_putx32: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_getx16: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_getx_signed_16: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_putx16: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_h_getx64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
    >,
    pub bfd_h_getx_signed_64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
    >,
    pub bfd_h_putx64: Option::<
        unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
    >,
    pub bfd_h_getx32: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_h_getx_signed_32: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_h_putx32: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_h_getx16: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_h_getx_signed_16: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_h_putx16: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub _bfd_check_format: [Option::<unsafe extern "C" fn(*mut bfd) -> bfd_cleanup>; 4],
    pub _bfd_set_format: [Option::<unsafe extern "C" fn(*mut bfd) -> bool>; 4],
    pub _bfd_write_contents: [Option::<unsafe extern "C" fn(*mut bfd) -> bool>; 4],
    pub _close_and_cleanup: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_free_cached_info: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _new_section_hook: Option::<unsafe extern "C" fn(*mut bfd, sec_ptr) -> bool>,
    pub _bfd_get_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut libc::c_void,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_get_section_contents_in_window: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut bfd_window,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_copy_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _bfd_merge_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_init_private_section_data: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut bfd,
            sec_ptr,
            *mut bfd_link_info,
        ) -> bool,
    >,
    pub _bfd_copy_private_section_data: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr, *mut bfd, sec_ptr) -> bool,
    >,
    pub _bfd_copy_private_symbol_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol, *mut bfd, *mut asymbol) -> bool,
    >,
    pub _bfd_copy_private_header_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _bfd_set_private_flags: Option::<
        unsafe extern "C" fn(*mut bfd, flagword) -> bool,
    >,
    pub _bfd_print_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
    >,
    pub _core_file_failing_command: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
    >,
    pub _core_file_failing_signal: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_int,
    >,
    pub _core_file_matches_executable_p: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _core_file_pid: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub _bfd_slurp_armap: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_slurp_extended_name_table: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_construct_extended_name_table: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut libc::c_char,
            *mut bfd_size_type,
            *mut *const libc::c_char,
        ) -> bool,
    >,
    pub _bfd_truncate_arname: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char, *mut libc::c_char) -> (),
    >,
    pub write_armap: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_uint,
            *mut orl,
            libc::c_uint,
            libc::c_int,
        ) -> bool,
    >,
    pub _bfd_read_ar_hdr_fn: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
    >,
    pub _bfd_write_ar_hdr_fn: Option::<unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool>,
    pub openr_next_archived_file: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
    >,
    pub _bfd_get_elt_at_index: Option::<
        unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
    >,
    pub _bfd_stat_arch_elt: Option::<
        unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
    >,
    pub _bfd_update_armap_timestamp: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_get_symtab_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_symtab: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut bfd_symbol) -> libc::c_long,
    >,
    pub _bfd_make_empty_symbol: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut bfd_symbol,
    >,
    pub _bfd_print_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            *mut bfd_symbol,
            bfd_print_symbol_type,
        ) -> (),
    >,
    pub _bfd_get_symbol_info: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_symbol, *mut symbol_info) -> (),
    >,
    pub _bfd_get_symbol_version_string: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_symbol,
            bool,
            *mut bool,
        ) -> *const libc::c_char,
    >,
    pub _bfd_is_local_label_name: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
    >,
    pub _bfd_is_target_special_symbol: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
    >,
    pub _get_lineno: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_symbol) -> *mut alent,
    >,
    pub _bfd_find_nearest_line: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut bfd_symbol,
            *mut bfd_section,
            bfd_vma,
            *mut *const libc::c_char,
            *mut *const libc::c_char,
            *mut libc::c_uint,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_find_line: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut bfd_symbol,
            *mut bfd_symbol,
            *mut *const libc::c_char,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_find_inliner_info: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *const libc::c_char,
            *mut *const libc::c_char,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_make_debug_symbol: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void, libc::c_ulong) -> *mut asymbol,
    >,
    pub _read_minisymbols: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bool,
            *mut *mut libc::c_void,
            *mut libc::c_uint,
        ) -> libc::c_long,
    >,
    pub _minisymbol_to_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bool,
            *const libc::c_void,
            *mut asymbol,
        ) -> *mut asymbol,
    >,
    pub _get_reloc_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
    >,
    pub _bfd_canonicalize_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut *mut arelent,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub _bfd_set_reloc: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr, *mut *mut arelent, libc::c_uint) -> (),
    >,
    pub reloc_type_lookup: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bfd_reloc_code_real_type,
        ) -> *const reloc_howto_type,
    >,
    pub reloc_name_lookup: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> *const reloc_howto_type,
    >,
    pub _bfd_set_arch_mach: Option::<
        unsafe extern "C" fn(*mut bfd, bfd_architecture, libc::c_ulong) -> bool,
    >,
    pub _bfd_set_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *const libc::c_void,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_sizeof_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
    >,
    pub _bfd_get_relocated_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_order,
            *mut bfd_byte,
            bool,
            *mut *mut bfd_symbol,
        ) -> *mut bfd_byte,
    >,
    pub _bfd_relax_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_section,
            *mut bfd_link_info,
            *mut bool,
        ) -> bool,
    >,
    pub _bfd_link_hash_table_create: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
    >,
    pub _bfd_link_add_symbols: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_link_just_syms: Option::<
        unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
    >,
    pub _bfd_copy_link_hash_symbol_type: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_hash_entry,
            *mut bfd_link_hash_entry,
        ) -> (),
    >,
    pub _bfd_final_link: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_link_split_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
    >,
    pub _bfd_link_check_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_gc_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_lookup_section_flags: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut flag_info, *mut asection) -> bool,
    >,
    pub _bfd_merge_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_is_group_section: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
    >,
    pub _bfd_group_name: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_section) -> *const libc::c_char,
    >,
    pub _bfd_discard_group: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
    >,
    pub _section_already_linked: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_define_common_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
        ) -> bool,
    >,
    pub _bfd_link_hide_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
        ) -> (),
    >,
    pub _bfd_define_start_stop: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut asection,
        ) -> *mut bfd_link_hash_entry,
    >,
    pub _bfd_get_dynamic_symtab_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_dynamic_symtab: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut bfd_symbol) -> libc::c_long,
    >,
    pub _bfd_get_synthetic_symtab: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_long,
            *mut *mut bfd_symbol,
            libc::c_long,
            *mut *mut bfd_symbol,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub _bfd_get_dynamic_reloc_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_dynamic_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut arelent,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub alternative_target: *const bfd_target,
    pub backend_data: *const libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct flag_info {
    pub only_with_flags: flagword,
    pub not_with_flags: flagword,
    pub flag_list: *mut flag_info_list,
    pub flags_initialized: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct flag_info_list {
    pub with: flag_type,
    pub name: *const libc::c_char,
    pub valid: bool,
    pub next: *mut flag_info_list,
}
pub type flag_type = libc::c_uint;
pub const without_flags: flag_type = 1;
pub const with_flags: flag_type = 0;
pub type sec_ptr = *mut bfd_section;
pub type symbol_info = _symbol_info;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _symbol_info {
    pub value: symvalue,
    pub type_0: libc::c_char,
    pub name: *const libc::c_char,
    pub stab_type: libc::c_uchar,
    pub stab_other: libc::c_char,
    pub stab_desc: libc::c_short,
    pub stab_name: *const libc::c_char,
}
pub type bfd_print_symbol_type = bfd_print_symbol;
pub type bfd_print_symbol = libc::c_uint;
pub const bfd_print_symbol_all: bfd_print_symbol = 2;
pub const bfd_print_symbol_more: bfd_print_symbol = 1;
pub const bfd_print_symbol_name: bfd_print_symbol = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct orl {
    pub name: *mut *mut libc::c_char,
    pub u: C2RustUnnamed_20,
    pub namidx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_20 {
    pub pos: file_ptr,
    pub abfd: *mut bfd,
}
pub type bfd_window = _bfd_window;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _bfd_window {
    pub data: *mut libc::c_void,
    pub size: bfd_size_type,
    pub i: *mut _bfd_window_internal,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct _bfd_window_internal {
    pub next: *mut _bfd_window_internal,
    pub data: *mut libc::c_void,
    pub size: bfd_size_type,
    #[bitfield(name = "refcount", ty = "libc::c_int", bits = "0..=30")]
    #[bitfield(name = "mapped", ty = "libc::c_uint", bits = "31..=31")]
    pub refcount_mapped: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
pub type bfd_cleanup = Option::<unsafe extern "C" fn(*mut bfd) -> ()>;
pub type bfd_endian = libc::c_uint;
pub const BFD_ENDIAN_UNKNOWN: bfd_endian = 2;
pub const BFD_ENDIAN_LITTLE: bfd_endian = 1;
pub const BFD_ENDIAN_BIG: bfd_endian = 0;
pub type bfd_flavour = libc::c_uint;
pub const bfd_target_sym_flavour: bfd_flavour = 20;
pub const bfd_target_pef_xlib_flavour: bfd_flavour = 19;
pub const bfd_target_pef_flavour: bfd_flavour = 18;
pub const bfd_target_mach_o_flavour: bfd_flavour = 17;
pub const bfd_target_mmo_flavour: bfd_flavour = 16;
pub const bfd_target_evax_flavour: bfd_flavour = 15;
pub const bfd_target_ovax_flavour: bfd_flavour = 14;
pub const bfd_target_msdos_flavour: bfd_flavour = 13;
pub const bfd_target_versados_flavour: bfd_flavour = 12;
pub const bfd_target_os9k_flavour: bfd_flavour = 11;
pub const bfd_target_som_flavour: bfd_flavour = 10;
pub const bfd_target_ihex_flavour: bfd_flavour = 9;
pub const bfd_target_verilog_flavour: bfd_flavour = 8;
pub const bfd_target_srec_flavour: bfd_flavour = 7;
pub const bfd_target_tekhex_flavour: bfd_flavour = 6;
pub const bfd_target_elf_flavour: bfd_flavour = 5;
pub const bfd_target_xcoff_flavour: bfd_flavour = 4;
pub const bfd_target_ecoff_flavour: bfd_flavour = 3;
pub const bfd_target_coff_flavour: bfd_flavour = 2;
pub const bfd_target_aout_flavour: bfd_flavour = 1;
pub const bfd_target_unknown_flavour: bfd_flavour = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stab_info {
    pub strings: *mut bfd_strtab_hash,
    pub includes: bfd_hash_table,
    pub stabstr: *mut bfd_section,
}
pub type bfd_error = libc::c_uint;
pub const bfd_error_invalid_error_code: bfd_error = 22;
pub const bfd_error_on_input: bfd_error = 21;
pub const bfd_error_sorry: bfd_error = 20;
pub const bfd_error_file_too_big: bfd_error = 19;
pub const bfd_error_file_truncated: bfd_error = 18;
pub const bfd_error_bad_value: bfd_error = 17;
pub const bfd_error_no_debug_section: bfd_error = 16;
pub const bfd_error_nonrepresentable_section: bfd_error = 15;
pub const bfd_error_no_contents: bfd_error = 14;
pub const bfd_error_file_ambiguously_recognized: bfd_error = 13;
pub const bfd_error_file_not_recognized: bfd_error = 12;
pub const bfd_error_missing_dso: bfd_error = 11;
pub const bfd_error_malformed_archive: bfd_error = 10;
pub const bfd_error_no_more_archived_files: bfd_error = 9;
pub const bfd_error_no_armap: bfd_error = 8;
pub const bfd_error_no_symbols: bfd_error = 7;
pub const bfd_error_no_memory: bfd_error = 6;
pub const bfd_error_invalid_operation: bfd_error = 5;
pub const bfd_error_wrong_object_format: bfd_error = 4;
pub const bfd_error_wrong_format: bfd_error = 3;
pub const bfd_error_invalid_target: bfd_error = 2;
pub const bfd_error_system_call: bfd_error = 1;
pub const bfd_error_no_error: bfd_error = 0;
pub type bfd_error_type = bfd_error;
pub type notice_asneeded_action = libc::c_uint;
pub const notice_needed: notice_asneeded_action = 2;
pub const notice_not_needed: notice_asneeded_action = 1;
pub const notice_as_needed: notice_asneeded_action = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_section_already_linked {
    pub next: *mut bfd_section_already_linked,
    pub sec: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_section_already_linked_hash_entry {
    pub root: bfd_hash_entry,
    pub entry: *mut bfd_section_already_linked,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Sym_Shndx {
    pub est_shndx: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf32_External_Rel {
    pub r_offset: [libc::c_uchar; 4],
    pub r_info: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Rel {
    pub r_offset: [libc::c_uchar; 8],
    pub r_info: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_External_Rela {
    pub r_offset: [libc::c_uchar; 8],
    pub r_info: [libc::c_uchar; 8],
    pub r_addend: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verdef {
    pub vd_version: [libc::c_uchar; 2],
    pub vd_flags: [libc::c_uchar; 2],
    pub vd_ndx: [libc::c_uchar; 2],
    pub vd_cnt: [libc::c_uchar; 2],
    pub vd_hash: [libc::c_uchar; 4],
    pub vd_aux: [libc::c_uchar; 4],
    pub vd_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verdaux {
    pub vda_name: [libc::c_uchar; 4],
    pub vda_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verneed {
    pub vn_version: [libc::c_uchar; 2],
    pub vn_cnt: [libc::c_uchar; 2],
    pub vn_file: [libc::c_uchar; 4],
    pub vn_aux: [libc::c_uchar; 4],
    pub vn_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Vernaux {
    pub vna_hash: [libc::c_uchar; 4],
    pub vna_flags: [libc::c_uchar; 2],
    pub vna_other: [libc::c_uchar; 2],
    pub vna_name: [libc::c_uchar; 4],
    pub vna_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct Elf_External_Versym {
    pub vs_vers: [libc::c_uchar; 2],
}
pub type Elf_Internal_Sym = elf_internal_sym;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_note {
    pub namesz: libc::c_ulong,
    pub descsz: libc::c_ulong,
    pub type_0: libc::c_ulong,
    pub namedata: *mut libc::c_char,
    pub descdata: *mut libc::c_char,
    pub descpos: bfd_vma,
}
pub type Elf_Internal_Note = elf_internal_note;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_rela {
    pub r_offset: bfd_vma,
    pub r_info: bfd_vma,
    pub r_addend: bfd_vma,
}
pub type Elf_Internal_Rela = elf_internal_rela;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_dyn {
    pub d_tag: bfd_vma,
    pub d_un: C2RustUnnamed_21,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_21 {
    pub d_val: bfd_vma,
    pub d_ptr: bfd_vma,
}
pub type Elf_Internal_Dyn = elf_internal_dyn;
pub type Elf_Internal_Verdaux = elf_internal_verdaux;
pub type Elf_Internal_Vernaux = elf_internal_vernaux;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_versym {
    pub vs_vers: libc::c_ushort,
}
pub type Elf_Internal_Versym = elf_internal_versym;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_symbol_type {
    pub symbol: asymbol,
    pub internal_elf_sym: Elf_Internal_Sym,
    pub tc_data: C2RustUnnamed_22,
    pub version: libc::c_ushort,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_22 {
    pub hppa_arg_reloc: libc::c_uint,
    pub mips_extr: *mut libc::c_void,
    pub any: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_local_dynamic_entry {
    pub next: *mut elf_link_local_dynamic_entry,
    pub input_bfd: *mut bfd,
    pub input_indx: libc::c_long,
    pub dynindx: libc::c_long,
    pub isym: Elf_Internal_Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_loaded_list {
    pub next: *mut elf_link_loaded_list,
    pub abfd: *mut bfd,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct eh_cie_fde {
    pub u: C2RustUnnamed_23,
    pub reloc_index: libc::c_uint,
    pub size: libc::c_uint,
    pub offset: libc::c_uint,
    pub new_offset: libc::c_uint,
    #[bitfield(name = "fde_encoding", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "lsda_encoding", ty = "libc::c_uint", bits = "8..=15")]
    #[bitfield(name = "lsda_offset", ty = "libc::c_uint", bits = "16..=23")]
    #[bitfield(name = "cie", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "removed", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "add_augmentation_size", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "make_relative", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "pad1", ty = "libc::c_uint", bits = "28..=31")]
    pub fde_encoding_lsda_encoding_lsda_offset_cie_removed_add_augmentation_size_make_relative_pad1: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
    pub set_loc: *mut libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_23 {
    pub fde: C2RustUnnamed_26,
    pub cie: C2RustUnnamed_24,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_24 {
    pub u: C2RustUnnamed_25,
    #[bitfield(name = "personality_offset", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "aug_str_len", ty = "libc::c_uint", bits = "8..=10")]
    #[bitfield(name = "aug_data_len", ty = "libc::c_uint", bits = "11..=15")]
    #[bitfield(name = "gc_mark", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "make_lsda_relative", ty = "libc::c_uint", bits = "17..=17")]
    #[bitfield(name = "make_per_encoding_relative", ty = "libc::c_uint", bits = "18..=18")]
    #[bitfield(name = "per_encoding_relative", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "per_encoding_aligned8", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "add_fde_encoding", ty = "libc::c_uint", bits = "21..=21")]
    #[bitfield(name = "merged", ty = "libc::c_uint", bits = "22..=22")]
    #[bitfield(name = "pad1", ty = "libc::c_uint", bits = "23..=31")]
    pub personality_offset_aug_str_len_aug_data_len_gc_mark_make_lsda_relative_make_per_encoding_relative_per_encoding_relative_per_encoding_aligned8_add_fde_encoding_merged_pad1: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_25 {
    pub full_cie: *mut cie,
    pub merged_with: *mut eh_cie_fde,
    pub sec: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_26 {
    pub cie_inf: *mut eh_cie_fde,
    pub next_for_section: *mut eh_cie_fde,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct eh_frame_array_ent {
    pub initial_loc: bfd_vma,
    pub range: bfd_size_type,
    pub fde: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_eh_frame_hdr_info {
    pub cies: *mut htab,
    pub fde_count: libc::c_uint,
    pub table: bool,
    pub array: *mut eh_frame_array_ent,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct compact_eh_frame_hdr_info {
    pub allocated_entries: libc::c_uint,
    pub entries: *mut *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct eh_frame_hdr_info {
    pub hdr_sec: *mut asection,
    pub array_count: libc::c_uint,
    pub frame_hdr_is_compact: bool,
    pub u: C2RustUnnamed_27,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_27 {
    pub dwarf: dwarf_eh_frame_hdr_info,
    pub compact: compact_eh_frame_hdr_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_sym_strtab {
    pub sym: Elf_Internal_Sym,
    pub dest_index: libc::c_ulong,
    pub destshndx_index: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_needed_list {
    pub next: *mut bfd_link_needed_list,
    pub by: *mut bfd,
    pub name: *const libc::c_char,
}
pub type elf_target_os = libc::c_uint;
pub const is_nacl: elf_target_os = 3;
pub const is_vxworks: elf_target_os = 2;
pub const is_solaris: elf_target_os = 1;
pub const is_normal: elf_target_os = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sym_cache {
    pub abfd: *mut bfd,
    pub indx: [libc::c_ulong; 32],
    pub sym: [Elf_Internal_Sym; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_hash_table {
    pub root: bfd_link_hash_table,
    pub hash_table_id: elf_target_id,
    pub dynamic_sections_created: bool,
    pub dynamic_relocs: bool,
    pub is_relocatable_executable: bool,
    pub ifunc_resolvers: bool,
    pub dt_pltgot_required: bool,
    pub dt_jmprel_required: bool,
    pub dynobj: *mut bfd,
    pub init_got_refcount: gotplt_union,
    pub init_plt_refcount: gotplt_union,
    pub init_got_offset: gotplt_union,
    pub init_plt_offset: gotplt_union,
    pub dynsymcount: bfd_size_type,
    pub local_dynsymcount: bfd_size_type,
    pub dynstr: *mut elf_strtab_hash,
    pub strtabcount: bfd_size_type,
    pub strtabsize: bfd_size_type,
    pub strtab: *mut elf_sym_strtab,
    pub bucketcount: bfd_size_type,
    pub needed: *mut bfd_link_needed_list,
    pub text_index_section: *mut asection,
    pub data_index_section: *mut asection,
    pub hgot: *mut elf_link_hash_entry,
    pub hplt: *mut elf_link_hash_entry,
    pub hdynamic: *mut elf_link_hash_entry,
    pub merge_info: *mut libc::c_void,
    pub stab_info: stab_info,
    pub eh_info: eh_frame_hdr_info,
    pub dynlocal: *mut elf_link_local_dynamic_entry,
    pub runpath: *mut bfd_link_needed_list,
    pub tls_sec: *mut asection,
    pub tls_size: bfd_size_type,
    pub tlsdesc_plt: bfd_vma,
    pub tlsdesc_got: bfd_vma,
    pub target_os: elf_target_os,
    pub dyn_loaded: *mut elf_link_loaded_list,
    pub sym_cache: sym_cache,
    pub sgot: *mut asection,
    pub sgotplt: *mut asection,
    pub srelgot: *mut asection,
    pub splt: *mut asection,
    pub srelplt: *mut asection,
    pub sdynbss: *mut asection,
    pub srelbss: *mut asection,
    pub sdynrelro: *mut asection,
    pub sreldynrelro: *mut asection,
    pub igotplt: *mut asection,
    pub iplt: *mut asection,
    pub irelplt: *mut asection,
    pub irelifunc: *mut asection,
    pub dynsym: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_size_info {
    pub sizeof_ehdr: libc::c_uchar,
    pub sizeof_phdr: libc::c_uchar,
    pub sizeof_shdr: libc::c_uchar,
    pub sizeof_rel: libc::c_uchar,
    pub sizeof_rela: libc::c_uchar,
    pub sizeof_sym: libc::c_uchar,
    pub sizeof_dyn: libc::c_uchar,
    pub sizeof_note: libc::c_uchar,
    pub sizeof_hash_entry: libc::c_uchar,
    pub int_rels_per_ext_rel: libc::c_uchar,
    pub arch_size: libc::c_uchar,
    pub log_file_align: libc::c_uchar,
    pub elfclass: libc::c_uchar,
    pub ev_current: libc::c_uchar,
    pub write_out_phdrs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const Elf_Internal_Phdr,
            libc::c_uint,
        ) -> libc::c_int,
    >,
    pub write_shdrs_and_ehdr: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub checksum_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    size_t,
                    *mut libc::c_void,
                ) -> (),
            >,
            *mut libc::c_void,
        ) -> bool,
    >,
    pub write_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_void) -> (),
    >,
    pub swap_symbol_in: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const libc::c_void,
            *const libc::c_void,
            *mut Elf_Internal_Sym,
        ) -> bool,
    >,
    pub swap_symbol_out: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const Elf_Internal_Sym,
            *mut libc::c_void,
            *mut libc::c_void,
        ) -> (),
    >,
    pub slurp_reloc_table: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut *mut asymbol, bool) -> bool,
    >,
    pub slurp_symbol_table: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut asymbol, bool) -> libc::c_long,
    >,
    pub swap_dyn_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_void, *mut Elf_Internal_Dyn) -> (),
    >,
    pub swap_dyn_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Dyn, *mut libc::c_void) -> (),
    >,
    pub swap_reloc_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    >,
    pub swap_reloc_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    >,
    pub swap_reloca_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    >,
    pub swap_reloca_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    >,
}
pub type elf_reloc_type_class = libc::c_uint;
pub const reloc_class_plt: elf_reloc_type_class = 4;
pub const reloc_class_ifunc: elf_reloc_type_class = 3;
pub const reloc_class_copy: elf_reloc_type_class = 2;
pub const reloc_class_relative: elf_reloc_type_class = 1;
pub const reloc_class_normal: elf_reloc_type_class = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_reloc_cookie {
    pub rels: *mut Elf_Internal_Rela,
    pub rel: *mut Elf_Internal_Rela,
    pub relend: *mut Elf_Internal_Rela,
    pub locsyms: *mut Elf_Internal_Sym,
    pub abfd: *mut bfd,
    pub locsymcount: size_t,
    pub extsymoff: size_t,
    pub sym_hashes: *mut *mut elf_link_hash_entry,
    pub r_sym_shift: libc::c_int,
    pub bad_symtab: bool,
}
pub type irix_compat_t = libc::c_uint;
pub const ict_irix6: irix_compat_t = 2;
pub const ict_irix5: irix_compat_t = 1;
pub const ict_none: irix_compat_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_special_section {
    pub prefix: *const libc::c_char,
    pub prefix_length: libc::c_uint,
    pub suffix_length: libc::c_int,
    pub type_0: libc::c_uint,
    pub attr: bfd_vma,
}
pub type action_discarded = libc::c_uint;
pub const PRETEND: action_discarded = 2;
pub const COMPLAIN: action_discarded = 1;
pub type elf_gc_mark_hook_fn = Option::<
    unsafe extern "C" fn(
        *mut asection,
        *mut bfd_link_info,
        *mut Elf_Internal_Rela,
        *mut elf_link_hash_entry,
        *mut Elf_Internal_Sym,
    ) -> *mut asection,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_section_reloc_data {
    pub hdr: *mut Elf_Internal_Shdr,
    pub count: libc::c_uint,
    pub idx: libc::c_int,
    pub hashes: *mut *mut elf_link_hash_entry,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_backend_data {
    pub arch: bfd_architecture,
    pub target_id: elf_target_id,
    pub target_os: elf_target_os,
    pub elf_machine_code: libc::c_int,
    pub elf_osabi: libc::c_int,
    pub maxpagesize: bfd_vma,
    pub minpagesize: bfd_vma,
    pub commonpagesize: bfd_vma,
    pub relropagesize: bfd_vma,
    pub dynamic_sec_flags: flagword,
    pub arch_data: *const libc::c_void,
    pub elf_info_to_howto: Option::<
        unsafe extern "C" fn(*mut bfd, *mut arelent, *mut Elf_Internal_Rela) -> bool,
    >,
    pub elf_info_to_howto_rel: Option::<
        unsafe extern "C" fn(*mut bfd, *mut arelent, *mut Elf_Internal_Rela) -> bool,
    >,
    pub elf_backend_sym_is_global: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
    >,
    pub elf_backend_object_p: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub elf_backend_symbol_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> (),
    >,
    pub elf_backend_symbol_table_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_symbol_type, libc::c_uint) -> bool,
    >,
    pub elf_backend_get_symbol_type: Option::<
        unsafe extern "C" fn(*mut Elf_Internal_Sym, libc::c_int) -> libc::c_int,
    >,
    pub elf_backend_archive_symbol_lookup: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *const libc::c_char,
        ) -> *mut bfd_link_hash_entry,
    >,
    pub elf_backend_name_local_section_symbols: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_section_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Shdr) -> bool,
    >,
    pub elf_backend_section_from_shdr: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Shdr,
            *const libc::c_char,
            libc::c_int,
        ) -> bool,
    >,
    pub elf_backend_section_flags: Option::<
        unsafe extern "C" fn(*const Elf_Internal_Shdr) -> bool,
    >,
    pub get_sec_type_attr: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection) -> *const bfd_elf_special_section,
    >,
    pub elf_backend_section_from_phdr: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Phdr,
            libc::c_int,
            *const libc::c_char,
        ) -> bool,
    >,
    pub elf_backend_fake_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Shdr, *mut asection) -> bool,
    >,
    pub elf_backend_section_from_bfd_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_int) -> bool,
    >,
    pub elf_add_symbol_hook: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut Elf_Internal_Sym,
            *mut *const libc::c_char,
            *mut flagword,
            *mut *mut asection,
            *mut bfd_vma,
        ) -> bool,
    >,
    pub elf_backend_link_output_symbol_hook: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut Elf_Internal_Sym,
            *mut asection,
            *mut elf_link_hash_entry,
        ) -> libc::c_int,
    >,
    pub elf_backend_create_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_omit_section_dynsym: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub relocs_compatible: Option::<
        unsafe extern "C" fn(*const bfd_target, *const bfd_target) -> bool,
    >,
    pub check_relocs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            *const Elf_Internal_Rela,
        ) -> bool,
    >,
    pub check_directives: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub notice_as_needed: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            notice_asneeded_action,
        ) -> bool,
    >,
    pub elf_backend_adjust_dynamic_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_always_size_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_size_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_strip_zero_sized_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> bool,
    >,
    pub elf_backend_init_index_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
    >,
    pub elf_backend_relocate_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd,
            *mut asection,
            *mut bfd_byte,
            *mut Elf_Internal_Rela,
            *mut Elf_Internal_Sym,
            *mut *mut asection,
        ) -> libc::c_int,
    >,
    pub elf_backend_finish_dynamic_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut Elf_Internal_Sym,
        ) -> bool,
    >,
    pub elf_backend_finish_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_begin_write_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
    >,
    pub elf_backend_final_write_processing: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_additional_program_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
    >,
    pub elf_backend_modify_segment_map: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_modify_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_allow_non_load_phdr: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Phdr, libc::c_uint) -> bool,
    >,
    pub gc_keep: Option::<unsafe extern "C" fn(*mut bfd_link_info) -> ()>,
    pub gc_mark_dynamic_ref: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, *mut libc::c_void) -> bool,
    >,
    pub gc_mark_hook: elf_gc_mark_hook_fn,
    pub gc_mark_extra_sections: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, elf_gc_mark_hook_fn) -> bool,
    >,
    pub elf_backend_init_file_header: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_print_symbol_all: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            *mut asymbol,
        ) -> *const libc::c_char,
    >,
    pub elf_backend_output_arch_local_syms: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const libc::c_char,
                    *mut Elf_Internal_Sym,
                    *mut asection,
                    *mut elf_link_hash_entry,
                ) -> libc::c_int,
            >,
        ) -> bool,
    >,
    pub elf_backend_output_arch_syms: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const libc::c_char,
                    *mut Elf_Internal_Sym,
                    *mut asection,
                    *mut elf_link_hash_entry,
                ) -> libc::c_int,
            >,
        ) -> bool,
    >,
    pub elf_backend_filter_implib_symbols: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut *mut asymbol,
            libc::c_long,
        ) -> libc::c_uint,
    >,
    pub elf_backend_copy_indirect_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut elf_link_hash_entry,
        ) -> (),
    >,
    pub elf_backend_hide_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry, bool) -> (),
    >,
    pub elf_backend_fixup_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_merge_symbol_attribute: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, libc::c_uint, bool, bool) -> (),
    >,
    pub elf_backend_get_target_dtag: Option::<
        unsafe extern "C" fn(bfd_vma) -> *mut libc::c_char,
    >,
    pub elf_backend_ignore_undef_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_emit_relocs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut asection,
            *mut Elf_Internal_Shdr,
            *mut Elf_Internal_Rela,
            *mut *mut elf_link_hash_entry,
        ) -> bool,
    >,
    pub elf_backend_update_relocs: Option::<
        unsafe extern "C" fn(*mut asection, *mut bfd_elf_section_reloc_data) -> (),
    >,
    pub elf_backend_count_relocs: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut asection) -> libc::c_uint,
    >,
    pub elf_backend_count_additional_relocs: Option::<
        unsafe extern "C" fn(*mut asection) -> libc::c_uint,
    >,
    pub sort_relocs_p: Option::<unsafe extern "C" fn(*mut asection) -> bool>,
    pub elf_backend_grok_prstatus: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_grok_psinfo: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_grok_freebsd_prstatus: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_write_core_note: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_char,
            *mut libc::c_int,
            libc::c_int,
            ...
        ) -> *mut libc::c_char,
    >,
    pub elf_backend_lookup_section_flags_hook: Option::<
        unsafe extern "C" fn(*mut libc::c_char) -> flagword,
    >,
    pub elf_backend_reloc_type_class: Option::<
        unsafe extern "C" fn(
            *const bfd_link_info,
            *const asection,
            *const Elf_Internal_Rela,
        ) -> elf_reloc_type_class,
    >,
    pub elf_backend_discard_info: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_reloc_cookie, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_ignore_discarded_relocs: Option::<
        unsafe extern "C" fn(*mut asection) -> bool,
    >,
    pub action_discarded: Option::<unsafe extern "C" fn(*mut asection) -> libc::c_uint>,
    pub elf_backend_eh_frame_address_size: Option::<
        unsafe extern "C" fn(*mut bfd, *const asection) -> libc::c_uint,
    >,
    pub elf_backend_can_make_relative_eh_frame: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub elf_backend_can_make_lsda_relative_eh_frame: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub elf_backend_encode_eh_address: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            bfd_vma,
            *mut asection,
            bfd_vma,
            *mut bfd_vma,
        ) -> bfd_byte,
    >,
    pub elf_backend_write_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            *mut bfd_byte,
        ) -> bool,
    >,
    pub elf_backend_elfsym_local_is_section: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_mips_irix_compat: Option::<
        unsafe extern "C" fn(*mut bfd) -> irix_compat_t,
    >,
    pub elf_backend_mips_rtype_to_howto: Option::<
        unsafe extern "C" fn(*mut bfd, libc::c_uint, bool) -> *const reloc_howto_type,
    >,
    pub elf_backend_ecoff_debug_swap: *const ecoff_debug_swap,
    pub elf_backend_bfd_from_remote_memory: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bfd_vma,
            bfd_size_type,
            *mut bfd_vma,
            Option::<
                unsafe extern "C" fn(
                    bfd_vma,
                    *mut bfd_byte,
                    bfd_size_type,
                ) -> libc::c_int,
            >,
        ) -> *mut bfd,
    >,
    pub elf_backend_core_find_build_id: Option::<
        unsafe extern "C" fn(*mut bfd, bfd_vma) -> bool,
    >,
    pub plt_sym_val: Option::<
        unsafe extern "C" fn(bfd_vma, *const asection, *const arelent) -> bfd_vma,
    >,
    pub common_definition: Option::<unsafe extern "C" fn(*mut Elf_Internal_Sym) -> bool>,
    pub common_section_index: Option::<
        unsafe extern "C" fn(*mut asection) -> libc::c_uint,
    >,
    pub common_section: Option::<unsafe extern "C" fn(*mut asection) -> *mut asection>,
    pub merge_symbol: Option::<
        unsafe extern "C" fn(
            *mut elf_link_hash_entry,
            *const Elf_Internal_Sym,
            *mut *mut asection,
            bool,
            bool,
            *mut bfd,
            *const asection,
        ) -> bool,
    >,
    pub elf_hash_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
    >,
    pub record_xhash_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, bfd_vma) -> (),
    >,
    pub is_function_type: Option::<unsafe extern "C" fn(libc::c_uint) -> bool>,
    pub maybe_function_sym: Option::<
        unsafe extern "C" fn(
            *const asymbol,
            *mut asection,
            *mut bfd_vma,
        ) -> bfd_size_type,
    >,
    pub get_reloc_section: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> *mut asection,
    >,
    pub elf_backend_copy_special_section_fields: Option::<
        unsafe extern "C" fn(
            *const bfd,
            *mut bfd,
            *const Elf_Internal_Shdr,
            *mut Elf_Internal_Shdr,
        ) -> bool,
    >,
    pub link_order_error_handler: Option::<
        unsafe extern "C" fn(*const libc::c_char, ...) -> (),
    >,
    pub relplt_name: *const libc::c_char,
    pub elf_machine_alt1: libc::c_int,
    pub elf_machine_alt2: libc::c_int,
    pub s: *const elf_size_info,
    pub special_sections: *const bfd_elf_special_section,
    pub got_header_size: bfd_vma,
    pub got_elt_size: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut bfd,
            libc::c_ulong,
        ) -> bfd_vma,
    >,
    pub obj_attrs_vendor: *const libc::c_char,
    pub obj_attrs_section: *const libc::c_char,
    pub obj_attrs_arg_type: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub obj_attrs_section_type: libc::c_uint,
    pub obj_attrs_order: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub obj_attrs_handle_unknown: Option::<
        unsafe extern "C" fn(*mut bfd, libc::c_int) -> bool,
    >,
    pub parse_gnu_properties: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_uint,
            *mut bfd_byte,
            libc::c_uint,
        ) -> elf_property_kind,
    >,
    pub merge_gnu_properties: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *mut bfd,
            *mut elf_property,
            *mut elf_property,
        ) -> bool,
    >,
    pub setup_gnu_properties: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> *mut bfd,
    >,
    pub fixup_gnu_properties: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut *mut elf_property_list) -> (),
    >,
    pub compact_eh_encoding: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> libc::c_int,
    >,
    pub cant_unwind_opcode: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> libc::c_int,
    >,
    pub symbol_section_index: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_symbol_type) -> libc::c_uint,
    >,
    pub init_secondary_reloc_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Shdr,
            *const libc::c_char,
            libc::c_uint,
        ) -> bool,
    >,
    pub slurp_secondary_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut *mut asymbol, bool) -> bool,
    >,
    pub write_secondary_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
    >,
    pub static_tls_alignment: libc::c_uint,
    pub stack_align: libc::c_uint,
    pub elf_strtab_flags: libc::c_ulong,
    #[bitfield(name = "collect", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "type_change_ok", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "may_use_rel_p", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "may_use_rela_p", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "default_use_rela_p", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "rela_plts_and_copies_p", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "rela_normal", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "dtrel_excludes_plt", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "sign_extend_vma", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "want_got_plt", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "plt_readonly", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "want_plt_sym", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "plt_not_loaded", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "plt_alignment", ty = "libc::c_uint", bits = "13..=16")]
    #[bitfield(name = "can_gc_sections", ty = "libc::c_uint", bits = "17..=17")]
    #[bitfield(name = "can_refcount", ty = "libc::c_uint", bits = "18..=18")]
    #[bitfield(name = "want_got_sym", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "want_dynbss", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "want_dynrelro", ty = "libc::c_uint", bits = "21..=21")]
    #[bitfield(name = "want_p_paddr_set_to_zero", ty = "libc::c_uint", bits = "22..=22")]
    #[bitfield(name = "no_page_alias", ty = "libc::c_uint", bits = "23..=23")]
    #[bitfield(name = "default_execstack", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "caches_rawsize", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "extern_protected_data", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "always_renumber_dynsyms", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "linux_prpsinfo32_ugid16", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "linux_prpsinfo64_ugid16", ty = "libc::c_uint", bits = "29..=29")]
    pub collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_section_data {
    pub this_hdr: Elf_Internal_Shdr,
    pub section_flag_info: *mut flag_info,
    pub rel: bfd_elf_section_reloc_data,
    pub rela: bfd_elf_section_reloc_data,
    pub this_idx: libc::c_int,
    pub dynindx: libc::c_int,
    pub linked_to: *mut asection,
    pub relocs: *mut Elf_Internal_Rela,
    pub local_dynrel: *mut libc::c_void,
    pub sreloc: *mut asection,
    pub group: C2RustUnnamed_28,
    pub sec_group: *mut asection,
    pub next_in_group: *mut asection,
    pub fde_list: *mut eh_cie_fde,
    pub eh_frame_entry: *mut asection,
    pub has_secondary_relocs: bool,
    pub sec_info: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_28 {
    pub name: *const libc::c_char,
    pub id: *mut bfd_symbol,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_symbol {
    pub u: C2RustUnnamed_29,
    pub name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_29 {
    pub isym: *mut Elf_Internal_Sym,
    pub ssym: *mut elf_symbuf_symbol,
    pub p: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_symbuf_symbol {
    pub st_name: libc::c_ulong,
    pub st_info: libc::c_uchar,
    pub st_other: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_symbuf_head {
    pub ssym: *mut elf_symbuf_symbol,
    pub count: size_t,
    pub st_shndx: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_info_failed {
    pub info: *mut bfd_link_info,
    pub failed: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_find_verdep_info {
    pub info: *mut bfd_link_info,
    pub vers: libc::c_uint,
    pub failed: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_gc_sweep_symbol_info {
    pub info: *mut bfd_link_info,
    pub hide_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry, bool) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct collect_gnu_hash_codes {
    pub output_bfd: *mut bfd,
    pub bed: *const elf_backend_data,
    pub nsyms: libc::c_ulong,
    pub maskbits: libc::c_ulong,
    pub hashcodes: *mut libc::c_ulong,
    pub hashval: *mut libc::c_ulong,
    pub indx: *mut libc::c_ulong,
    pub counts: *mut libc::c_ulong,
    pub bitmask: *mut bfd_vma,
    pub contents: *mut bfd_byte,
    pub xlat: bfd_size_type,
    pub min_dynindx: libc::c_long,
    pub bucketcount: libc::c_ulong,
    pub symindx: libc::c_ulong,
    pub local_indx: libc::c_long,
    pub shift1: libc::c_long,
    pub shift2: libc::c_long,
    pub mask: libc::c_ulong,
    pub error: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct hash_codes_info {
    pub hashcodes: *mut libc::c_ulong,
    pub error: bool,
}
pub const _sch_isdigit: C2RustUnnamed_31 = 4;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct objalloc {
    pub current_ptr: *mut libc::c_char,
    pub current_space: libc::c_uint,
    pub chunks: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_final_link_info {
    pub info: *mut bfd_link_info,
    pub output_bfd: *mut bfd,
    pub symstrtab: *mut elf_strtab_hash,
    pub hash_sec: *mut asection,
    pub symver_sec: *mut asection,
    pub contents: *mut bfd_byte,
    pub external_relocs: *mut libc::c_void,
    pub internal_relocs: *mut Elf_Internal_Rela,
    pub external_syms: *mut bfd_byte,
    pub locsym_shndx: *mut Elf_External_Sym_Shndx,
    pub internal_syms: *mut Elf_Internal_Sym,
    pub indices: *mut libc::c_long,
    pub sections: *mut *mut asection,
    pub symshndxbuf: *mut Elf_External_Sym_Shndx,
    pub filesym_count: size_t,
    pub local_hash_table: bfd_hash_table,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_sort_rela {
    pub u: C2RustUnnamed_30,
    pub type_0: elf_reloc_type_class,
    pub rela: [Elf_Internal_Rela; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_30 {
    pub offset: bfd_vma,
    pub sym_mask: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union aligned64 {
    pub v: uint64_t,
    pub c: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union aligned64_0 {
    pub v: uint64_t,
    pub c: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union aligned32 {
    pub v: uint32_t,
    pub c: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union aligned32_0 {
    pub v: uint32_t,
    pub c: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct local_hash_entry {
    pub root: bfd_hash_entry,
    pub size: size_t,
    pub count: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_outext_info {
    pub failed: bool,
    pub localsyms: bool,
    pub file_sym_done: bool,
    pub flinfo: *mut elf_final_link_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct alloc_got_off_arg {
    pub gotoff: bfd_vma,
    pub info: *mut bfd_link_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_flags_to_name_table {
    pub flag_name: *mut libc::c_char,
    pub flag_value: flagword,
}
pub type C2RustUnnamed_31 = libc::c_uint;
pub const _sch_isbasic: C2RustUnnamed_31 = 3088;
pub const _sch_iscppsp: C2RustUnnamed_31 = 3072;
pub const _sch_isgraph: C2RustUnnamed_31 = 172;
pub const _sch_isidnum: C2RustUnnamed_31 = 516;
pub const _sch_isalnum: C2RustUnnamed_31 = 140;
pub const _sch_isalpha: C2RustUnnamed_31 = 136;
pub const _sch_isnvsp: C2RustUnnamed_31 = 2048;
pub const _sch_isvsp: C2RustUnnamed_31 = 1024;
pub const _sch_isidst: C2RustUnnamed_31 = 512;
pub const _sch_isxdigit: C2RustUnnamed_31 = 256;
pub const _sch_isupper: C2RustUnnamed_31 = 128;
pub const _sch_isspace: C2RustUnnamed_31 = 64;
pub const _sch_ispunct: C2RustUnnamed_31 = 32;
pub const _sch_isprint: C2RustUnnamed_31 = 16;
pub const _sch_islower: C2RustUnnamed_31 = 8;
pub const _sch_iscntrl: C2RustUnnamed_31 = 2;
pub const _sch_isblank: C2RustUnnamed_31 = 1;
#[inline]
unsafe extern "C" fn startswith(
    mut str: *const libc::c_char,
    mut prefix: *const libc::c_char,
) -> bool {
    return strncmp(str, prefix, strlen(prefix)) == 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn bfd_section_name(mut sec: *const asection) -> *const libc::c_char {
    return (*sec).name;
}
#[inline]
unsafe extern "C" fn bfd_section_alignment(mut sec: *const asection) -> libc::c_uint {
    return (*sec).alignment_power;
}
#[inline]
unsafe extern "C" fn bfd_is_com_section(mut sec: *const asection) -> bool {
    return (*sec).flags & 0x1000 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint;
}
#[inline]
unsafe extern "C" fn bfd_set_section_alignment(
    mut sec: *mut asection,
    mut val: libc::c_uint,
) -> bool {
    (*sec).alignment_power = val;
    return 1 as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn bfd_is_und_section(mut sec: *const asection) -> bool {
    return sec
        == &mut *_bfd_std_section.as_mut_ptr().offset(1 as libc::c_int as isize)
            as *mut asection as *const asection;
}
#[inline]
unsafe extern "C" fn bfd_is_abs_section(mut sec: *const asection) -> bool {
    return sec
        == &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
            as *mut asection as *const asection;
}
#[inline]
unsafe extern "C" fn bfd_is_const_section(mut sec: *const asection) -> bool {
    return sec >= _bfd_std_section.as_mut_ptr() as *const asection
        && sec
            < _bfd_std_section
                .as_mut_ptr()
                .offset(
                    (::core::mem::size_of::<[asection; 4]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<asection>() as libc::c_ulong,
                        ) as isize,
                ) as *const asection;
}
#[inline]
unsafe extern "C" fn discarded_section(mut sec: *const asection) -> bool {
    return !bfd_is_abs_section(sec)
        && bfd_is_abs_section((*sec).output_section) as libc::c_int != 0
        && (*sec).sec_info_type() as libc::c_int != 2 as libc::c_int
        && (*sec).sec_info_type() as libc::c_int != 4 as libc::c_int;
}
#[inline]
unsafe extern "C" fn bfd_get_filename(mut abfd: *const bfd) -> *const libc::c_char {
    return (*abfd).filename;
}
#[inline]
unsafe extern "C" fn bfd_get_format(mut abfd: *const bfd) -> bfd_format {
    return (*abfd).format();
}
#[inline]
unsafe extern "C" fn bfd_get_file_flags(mut abfd: *const bfd) -> flagword {
    return (*abfd).flags;
}
#[inline]
unsafe extern "C" fn bfd_get_symcount(mut abfd: *const bfd) -> libc::c_uint {
    return (*abfd).symcount;
}
#[inline]
unsafe extern "C" fn bfd_count_sections(mut abfd: *const bfd) -> libc::c_uint {
    return (*abfd).section_count;
}
#[inline]
unsafe extern "C" fn bfd_has_map(mut abfd: *const bfd) -> bool {
    return (*abfd).has_armap() != 0;
}
#[inline]
unsafe extern "C" fn bfd_section_list_remove(mut abfd: *mut bfd, mut s: *mut asection) {
    let mut next: *mut asection = (*s).next;
    let mut prev: *mut asection = (*s).prev;
    if !prev.is_null() {
        (*prev).next = next;
    } else {
        (*abfd).sections = next;
    }
    if !next.is_null() {
        (*next).prev = prev;
    } else {
        (*abfd).section_last = prev;
    };
}
#[inline]
unsafe extern "C" fn bfd_section_removed_from_list(
    mut abfd: *const bfd,
    mut s: *const asection,
) -> bool {
    return if !((*s).next).is_null() {
        ((*(*s).next).prev != s as *mut bfd_section) as libc::c_int
    } else {
        ((*abfd).section_last != s as *mut bfd_section) as libc::c_int
    } != 0;
}
#[inline]
unsafe extern "C" fn bfd_get_flavour(mut abfd: *const bfd) -> bfd_flavour {
    return (*(*abfd).xvec).flavour;
}
#[inline]
unsafe extern "C" fn bfd_get_symbol_leading_char(mut abfd: *const bfd) -> libc::c_char {
    return (*(*abfd).xvec).symbol_leading_char;
}
#[inline]
unsafe extern "C" fn bfd_keep_unused_section_symbols(mut abfd: *const bfd) -> bool {
    return (*(*abfd).xvec).keep_unused_section_symbols;
}
#[inline]
unsafe extern "C" fn _bfd_malloc_and_read(
    mut abfd: *mut bfd,
    mut asize: bfd_size_type,
    mut rsize: bfd_size_type,
) -> *mut bfd_byte {
    let mut mem: *mut bfd_byte = 0 as *mut bfd_byte;
    if 0 == 0 {
        let mut filesize: ufile_ptr = bfd_get_file_size(abfd);
        if filesize != 0 as libc::c_int as libc::c_ulong && rsize > filesize {
            bfd_set_error(bfd_error_file_truncated);
            return 0 as *mut bfd_byte;
        }
    }
    mem = bfd_malloc(asize) as *mut bfd_byte;
    if !mem.is_null() {
        if bfd_bread(mem as *mut libc::c_void, rsize, abfd) == rsize {
            return mem;
        }
        free(mem as *mut libc::c_void);
    }
    return 0 as *mut bfd_byte;
}
#[inline]
unsafe extern "C" fn weakdef(
    mut h: *mut elf_link_hash_entry,
) -> *mut elf_link_hash_entry {
    while (*h).is_weakalias() != 0 {
        h = (*h).u.alias;
    }
    return h;
}
#[inline]
unsafe extern "C" fn is_elf_hash_table(mut htab: *const bfd_link_hash_table) -> bool {
    return (*htab).type_0 as libc::c_uint
        == bfd_link_elf_hash_table as libc::c_int as libc::c_uint;
}
#[inline]
unsafe extern "C" fn elf_link_hash_lookup(
    mut table: *mut elf_link_hash_table,
    mut string: *const libc::c_char,
    mut create: bool,
    mut copy: bool,
    mut follow: bool,
) -> *mut elf_link_hash_entry {
    if 0 as libc::c_int != 0 && !is_elf_hash_table(&mut (*table).root) {
        _bfd_abort(
            b"./elf-bfd.h\0" as *const u8 as *const libc::c_char,
            731 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 114],
                &[libc::c_char; 114],
            >(
                b"struct elf_link_hash_entry *elf_link_hash_lookup(struct elf_link_hash_table *, const char *, _Bool, _Bool, _Bool)\0",
            ))
                .as_ptr(),
        );
    }
    return bfd_link_hash_lookup(&mut (*table).root, string, create, copy, follow)
        as *mut elf_link_hash_entry;
}
#[inline]
unsafe extern "C" fn elf_link_hash_traverse(
    mut table: *mut elf_link_hash_table,
    mut f: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, *mut libc::c_void) -> bool,
    >,
    mut info: *mut libc::c_void,
) {
    if 0 as libc::c_int != 0 && !is_elf_hash_table(&mut (*table).root) {
        _bfd_abort(
            b"./elf-bfd.h\0" as *const u8 as *const libc::c_char,
            744 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 115],
                &[libc::c_char; 115],
            >(
                b"void elf_link_hash_traverse(struct elf_link_hash_table *, _Bool (*)(struct elf_link_hash_entry *, void *), void *)\0",
            ))
                .as_ptr(),
        );
    }
    bfd_link_hash_traverse(
        &mut (*table).root,
        ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(*mut elf_link_hash_entry, *mut libc::c_void) -> bool,
            >,
            Option::<
                unsafe extern "C" fn(*mut bfd_link_hash_entry, *mut libc::c_void) -> bool,
            >,
        >(f),
        info,
    );
}
#[inline]
unsafe extern "C" fn elf_hash_table(
    mut info: *const bfd_link_info,
) -> *mut elf_link_hash_table {
    return (*info).hash as *mut elf_link_hash_table;
}
#[inline]
unsafe extern "C" fn elf_hash_table_id(
    mut table: *const elf_link_hash_table,
) -> elf_target_id {
    return (*table).hash_table_id;
}
#[inline]
unsafe extern "C" fn bfd_section_is_ctf(mut sec: *const asection) -> bool {
    let mut name: *const libc::c_char = bfd_section_name(sec);
    return startswith(name, b".ctf\0" as *const u8 as *const libc::c_char) as libc::c_int
        != 0
        && (*name.offset(4 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
            || *name.offset(4 as libc::c_int as isize) as libc::c_int == '.' as i32);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_section_for_symbol(
    mut cookie: *mut elf_reloc_cookie,
    mut r_symndx: libc::c_ulong,
    mut discard: bool,
) -> *mut asection {
    if r_symndx >= (*cookie).locsymcount
        || (*((*cookie).locsyms).offset(r_symndx as isize)).st_info as libc::c_uint
            >> 4 as libc::c_int != 0 as libc::c_int as libc::c_uint
    {
        let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
        h = *((*cookie).sym_hashes)
            .offset(r_symndx.wrapping_sub((*cookie).extsymoff) as isize);
        while ((*h).root).type_0() as libc::c_int
            == bfd_link_hash_indirect as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_warning as libc::c_int
        {
            h = (*h).root.u.i.link as *mut elf_link_hash_entry;
        }
        if (((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int)
            && discarded_section((*h).root.u.def.section) as libc::c_int != 0
        {
            return (*h).root.u.def.section
        } else {
            return 0 as *mut asection
        }
    } else {
        let mut isec: *mut asection = 0 as *mut asection;
        let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        isym = &mut *((*cookie).locsyms).offset(r_symndx as isize)
            as *mut Elf_Internal_Sym;
        isec = bfd_section_from_elf_index((*cookie).abfd, (*isym).st_shndx);
        if if !isec.is_null() && discard as libc::c_int != 0 {
            discarded_section(isec) as libc::c_int
        } else {
            1 as libc::c_int
        } != 0
        {
            return isec;
        }
    }
    return 0 as *mut asection;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_define_linkage_sym(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut sec: *mut asection,
    mut name: *const libc::c_char,
) -> *mut elf_link_hash_entry {
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut bh: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    h = elf_link_hash_lookup(
        elf_hash_table(info),
        name,
        0 as libc::c_int != 0,
        0 as libc::c_int != 0,
        0 as libc::c_int != 0,
    );
    if !h.is_null() {
        ((*h).root).set_type_0(bfd_link_hash_new);
        bh = &mut (*h).root;
    } else {
        bh = 0 as *mut bfd_link_hash_entry;
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if !_bfd_generic_link_add_one_symbol(
        info,
        abfd,
        name,
        ((1 as libc::c_int) << 1 as libc::c_int) as flagword,
        sec,
        0 as libc::c_int as bfd_vma,
        0 as *const libc::c_char,
        0 as libc::c_int != 0,
        (*bed).collect() != 0,
        &mut bh,
    ) {
        return 0 as *mut elf_link_hash_entry;
    }
    h = bh as *mut elf_link_hash_entry;
    if h.is_null() {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            137 as libc::c_int,
        );
    }
    (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
    (*h).set_non_elf(0 as libc::c_int as libc::c_uint);
    ((*h).root).set_linker_def(1 as libc::c_int as libc::c_uint);
    (*h).set_type_0(1 as libc::c_int as libc::c_uint);
    if (*h).other() as libc::c_int & 0x3 as libc::c_int != 1 as libc::c_int {
        (*h)
            .set_other(
                ((*h).other() as libc::c_int
                    & !(-(1 as libc::c_int) & 0x3 as libc::c_int) | 2 as libc::c_int)
                    as libc::c_uint,
            );
    }
    (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
        .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
    return h;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_create_got_section(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut flags: flagword = 0;
    let mut s: *mut asection = 0 as *mut asection;
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut htab: *mut elf_link_hash_table = elf_hash_table(info);
    if !((*htab).sgot).is_null() {
        return 1 as libc::c_int != 0;
    }
    flags = (*bed).dynamic_sec_flags;
    s = bfd_make_section_anyway_with_flags(
        abfd,
        if (*bed).rela_plts_and_copies_p() as libc::c_int != 0 {
            b".rela.got\0" as *const u8 as *const libc::c_char
        } else {
            b".rel.got\0" as *const u8 as *const libc::c_char
        },
        (*bed).dynamic_sec_flags | 0x8 as libc::c_int as libc::c_uint,
    );
    if s.is_null()
        || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    (*htab).srelgot = s;
    s = bfd_make_section_anyway_with_flags(
        abfd,
        b".got\0" as *const u8 as *const libc::c_char,
        flags,
    );
    if s.is_null()
        || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    (*htab).sgot = s;
    if (*bed).want_got_plt() != 0 {
        s = bfd_make_section_anyway_with_flags(
            abfd,
            b".got.plt\0" as *const u8 as *const libc::c_char,
            flags,
        );
        if s.is_null()
            || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
        {
            return 0 as libc::c_int != 0;
        }
        (*htab).sgotplt = s;
    }
    (*s)
        .size = ((*s).size as libc::c_ulong).wrapping_add((*bed).got_header_size)
        as bfd_size_type as bfd_size_type;
    if (*bed).want_got_sym() != 0 {
        h = _bfd_elf_define_linkage_sym(
            abfd,
            info,
            s,
            b"_GLOBAL_OFFSET_TABLE_\0" as *const u8 as *const libc::c_char,
        );
        let ref mut fresh0 = (*elf_hash_table(info)).hgot;
        *fresh0 = h;
        if h.is_null() {
            return 0 as libc::c_int != 0;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_link_create_dynstrtab(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut hash_table: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    hash_table = elf_hash_table(info);
    if ((*hash_table).dynobj).is_null() {
        if (*abfd).flags & (0x40 as libc::c_int | 0x10000 as libc::c_int) as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        {
            let mut ibfd: *mut bfd = 0 as *mut bfd;
            let mut s: *mut asection = 0 as *mut asection;
            ibfd = (*info).input_bfds;
            while !ibfd.is_null() {
                if (*ibfd).flags
                    & (0x40 as libc::c_int | 0x1000 as libc::c_int
                        | 0x10000 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                    && bfd_get_flavour(ibfd) as libc::c_uint
                        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
                    && (*(*ibfd).tdata.elf_obj_data).object_id() as libc::c_uint
                        == elf_hash_table_id(hash_table) as libc::c_uint
                    && {
                        s = (*ibfd).sections;
                        !(!s.is_null()
                            && (*s).sec_info_type() as libc::c_int == 4 as libc::c_int)
                    }
                {
                    abfd = ibfd;
                    break;
                } else {
                    ibfd = (*ibfd).link.next;
                }
            }
        }
        (*hash_table).dynobj = abfd;
    }
    if ((*hash_table).dynstr).is_null() {
        (*hash_table).dynstr = _bfd_elf_strtab_init();
        if ((*hash_table).dynstr).is_null() {
            return 0 as libc::c_int != 0;
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_create_dynamic_sections(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut flags: flagword = 0;
    let mut s: *mut asection = 0 as *mut asection;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    if !is_elf_hash_table((*info).hash) {
        return 0 as libc::c_int != 0;
    }
    if (*elf_hash_table(info)).dynamic_sections_created {
        return 1 as libc::c_int != 0;
    }
    if !_bfd_elf_link_create_dynstrtab(abfd, info) {
        return 0 as libc::c_int != 0;
    }
    abfd = (*elf_hash_table(info)).dynobj;
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    flags = (*bed).dynamic_sec_flags;
    if ((*info).type_0() as libc::c_int == type_pde as libc::c_int
        || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
        && (*info).nointerp() == 0
    {
        s = bfd_make_section_anyway_with_flags(
            abfd,
            b".interp\0" as *const u8 as *const libc::c_char,
            flags | 0x8 as libc::c_int as libc::c_uint,
        );
        if s.is_null() {
            return 0 as libc::c_int != 0;
        }
    }
    s = bfd_make_section_anyway_with_flags(
        abfd,
        b".gnu.version_d\0" as *const u8 as *const libc::c_char,
        flags | 0x8 as libc::c_int as libc::c_uint,
    );
    if s.is_null()
        || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    s = bfd_make_section_anyway_with_flags(
        abfd,
        b".gnu.version\0" as *const u8 as *const libc::c_char,
        flags | 0x8 as libc::c_int as libc::c_uint,
    );
    if s.is_null() || !bfd_set_section_alignment(s, 1 as libc::c_int as libc::c_uint) {
        return 0 as libc::c_int != 0;
    }
    s = bfd_make_section_anyway_with_flags(
        abfd,
        b".gnu.version_r\0" as *const u8 as *const libc::c_char,
        flags | 0x8 as libc::c_int as libc::c_uint,
    );
    if s.is_null()
        || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    s = bfd_make_section_anyway_with_flags(
        abfd,
        b".dynsym\0" as *const u8 as *const libc::c_char,
        flags | 0x8 as libc::c_int as libc::c_uint,
    );
    if s.is_null()
        || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    let ref mut fresh1 = (*elf_hash_table(info)).dynsym;
    *fresh1 = s;
    s = bfd_make_section_anyway_with_flags(
        abfd,
        b".dynstr\0" as *const u8 as *const libc::c_char,
        flags | 0x8 as libc::c_int as libc::c_uint,
    );
    if s.is_null() {
        return 0 as libc::c_int != 0;
    }
    s = bfd_make_section_anyway_with_flags(
        abfd,
        b".dynamic\0" as *const u8 as *const libc::c_char,
        flags,
    );
    if s.is_null()
        || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    h = _bfd_elf_define_linkage_sym(
        abfd,
        info,
        s,
        b"_DYNAMIC\0" as *const u8 as *const libc::c_char,
    );
    let ref mut fresh2 = (*elf_hash_table(info)).hdynamic;
    *fresh2 = h;
    if h.is_null() {
        return 0 as libc::c_int != 0;
    }
    if (*info).emit_hash() != 0 {
        s = bfd_make_section_anyway_with_flags(
            abfd,
            b".hash\0" as *const u8 as *const libc::c_char,
            flags | 0x8 as libc::c_int as libc::c_uint,
        );
        if s.is_null()
            || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
        {
            return 0 as libc::c_int != 0;
        }
        (*((*s).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_entsize = (*(*bed).s).sizeof_hash_entry as bfd_size_type;
    }
    if (*info).emit_gnu_hash() as libc::c_int != 0
        && ((*bed).record_xhash_symbol).is_none()
    {
        s = bfd_make_section_anyway_with_flags(
            abfd,
            b".gnu.hash\0" as *const u8 as *const libc::c_char,
            flags | 0x8 as libc::c_int as libc::c_uint,
        );
        if s.is_null()
            || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
        {
            return 0 as libc::c_int != 0;
        }
        if (*(*bed).s).arch_size as libc::c_int == 64 as libc::c_int {
            (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                .this_hdr
                .sh_entsize = 0 as libc::c_int as bfd_size_type;
        } else {
            (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                .this_hdr
                .sh_entsize = 4 as libc::c_int as bfd_size_type;
        }
    }
    if ((*bed).elf_backend_create_dynamic_sections).is_none()
        || !(Some(
            ((*bed).elf_backend_create_dynamic_sections)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd, info)
    {
        return 0 as libc::c_int != 0;
    }
    (*elf_hash_table(info)).dynamic_sections_created = 1 as libc::c_int != 0;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_create_dynamic_sections(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut flags: flagword = 0;
    let mut pltflags: flagword = 0;
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut s: *mut asection = 0 as *mut asection;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut htab: *mut elf_link_hash_table = elf_hash_table(info);
    flags = (*bed).dynamic_sec_flags;
    pltflags = flags;
    if (*bed).plt_not_loaded() != 0 {
        pltflags
            &= !(0x10 as libc::c_int | 0x2 as libc::c_int | 0x100 as libc::c_int)
                as libc::c_uint;
    } else {
        pltflags
            |= (0x1 as libc::c_int | 0x10 as libc::c_int | 0x2 as libc::c_int)
                as libc::c_uint;
    }
    if (*bed).plt_readonly() != 0 {
        pltflags |= 0x8 as libc::c_int as libc::c_uint;
    }
    s = bfd_make_section_anyway_with_flags(
        abfd,
        b".plt\0" as *const u8 as *const libc::c_char,
        pltflags,
    );
    if s.is_null() || !bfd_set_section_alignment(s, (*bed).plt_alignment()) {
        return 0 as libc::c_int != 0;
    }
    (*htab).splt = s;
    if (*bed).want_plt_sym() != 0 {
        h = _bfd_elf_define_linkage_sym(
            abfd,
            info,
            s,
            b"_PROCEDURE_LINKAGE_TABLE_\0" as *const u8 as *const libc::c_char,
        );
        let ref mut fresh3 = (*elf_hash_table(info)).hplt;
        *fresh3 = h;
        if h.is_null() {
            return 0 as libc::c_int != 0;
        }
    }
    s = bfd_make_section_anyway_with_flags(
        abfd,
        if (*bed).rela_plts_and_copies_p() as libc::c_int != 0 {
            b".rela.plt\0" as *const u8 as *const libc::c_char
        } else {
            b".rel.plt\0" as *const u8 as *const libc::c_char
        },
        flags | 0x8 as libc::c_int as libc::c_uint,
    );
    if s.is_null()
        || !bfd_set_section_alignment(s, (*(*bed).s).log_file_align as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    (*htab).srelplt = s;
    if !_bfd_elf_create_got_section(abfd, info) {
        return 0 as libc::c_int != 0;
    }
    if (*bed).want_dynbss() != 0 {
        s = bfd_make_section_anyway_with_flags(
            abfd,
            b".dynbss\0" as *const u8 as *const libc::c_char,
            (0x1 as libc::c_int | 0x100000 as libc::c_int) as flagword,
        );
        if s.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*htab).sdynbss = s;
        if (*bed).want_dynrelro() != 0 {
            s = bfd_make_section_anyway_with_flags(
                abfd,
                b".data.rel.ro\0" as *const u8 as *const libc::c_char,
                flags,
            );
            if s.is_null() {
                return 0 as libc::c_int != 0;
            }
            (*htab).sdynrelro = s;
        }
        if (*info).type_0() as libc::c_int == type_pde as libc::c_int
            || (*info).type_0() as libc::c_int == type_pie as libc::c_int
        {
            s = bfd_make_section_anyway_with_flags(
                abfd,
                if (*bed).rela_plts_and_copies_p() as libc::c_int != 0 {
                    b".rela.bss\0" as *const u8 as *const libc::c_char
                } else {
                    b".rel.bss\0" as *const u8 as *const libc::c_char
                },
                flags | 0x8 as libc::c_int as libc::c_uint,
            );
            if s.is_null()
                || !bfd_set_section_alignment(
                    s,
                    (*(*bed).s).log_file_align as libc::c_uint,
                )
            {
                return 0 as libc::c_int != 0;
            }
            (*htab).srelbss = s;
            if (*bed).want_dynrelro() != 0 {
                s = bfd_make_section_anyway_with_flags(
                    abfd,
                    if (*bed).rela_plts_and_copies_p() as libc::c_int != 0 {
                        b".rela.data.rel.ro\0" as *const u8 as *const libc::c_char
                    } else {
                        b".rel.data.rel.ro\0" as *const u8 as *const libc::c_char
                    },
                    flags | 0x8 as libc::c_int as libc::c_uint,
                );
                if s.is_null()
                    || !bfd_set_section_alignment(
                        s,
                        (*(*bed).s).log_file_align as libc::c_uint,
                    )
                {
                    return 0 as libc::c_int != 0;
                }
                (*htab).sreldynrelro = s;
            }
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_link_record_dynamic_symbol(
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
) -> bool {
    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long {
        let mut dynstr: *mut elf_strtab_hash = 0 as *mut elf_strtab_hash;
        let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        let mut indx: size_t = 0;
        if ((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int
        {
            if !((*h).root.u.def.section).is_null()
                && !((*(*h).root.u.def.section).owner).is_null()
                && (*(*(*h).root.u.def.section).owner).flags
                    & 0x10000 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
            {
                return 1 as libc::c_int != 0;
            }
        }
        match (*h).other() as libc::c_int & 0x3 as libc::c_int {
            1 | 2 => {
                if ((*h).root).type_0() as libc::c_int
                    != bfd_link_hash_undefined as libc::c_int
                    && ((*h).root).type_0() as libc::c_int
                        != bfd_link_hash_undefweak as libc::c_int
                {
                    (*h).set_forced_local(1 as libc::c_int as libc::c_uint);
                    if !(*elf_hash_table(info)).is_relocatable_executable
                        || (((*h).root).type_0() as libc::c_int
                            == bfd_link_hash_defined as libc::c_int
                            || ((*h).root).type_0() as libc::c_int
                                == bfd_link_hash_defweak as libc::c_int)
                            && !((*(*h).root.u.def.section).owner).is_null()
                            && (*(*(*h).root.u.def.section).owner).no_export()
                                as libc::c_int != 0
                        || ((*h).root).type_0() as libc::c_int
                            == bfd_link_hash_common as libc::c_int
                            && !((*(*(*h).root.u.c.p).section).owner).is_null()
                            && (*(*(*(*h).root.u.c.p).section).owner).no_export()
                                as libc::c_int != 0
                    {
                        return 1 as libc::c_int != 0;
                    }
                }
            }
            _ => {}
        }
        (*h).dynindx = (*elf_hash_table(info)).dynsymcount as libc::c_long;
        let ref mut fresh4 = (*elf_hash_table(info)).dynsymcount;
        *fresh4 = (*fresh4).wrapping_add(1);
        let _ = *fresh4;
        dynstr = (*elf_hash_table(info)).dynstr;
        if dynstr.is_null() {
            dynstr = _bfd_elf_strtab_init();
            let ref mut fresh5 = (*elf_hash_table(info)).dynstr;
            *fresh5 = dynstr;
            if dynstr.is_null() {
                return 0 as libc::c_int != 0;
            }
        }
        name = (*h).root.root.string;
        p = strchr(name, '@' as i32);
        if !p.is_null() {
            *p = 0 as libc::c_int as libc::c_char;
        }
        indx = _bfd_elf_strtab_add(dynstr, name, !p.is_null());
        if !p.is_null() {
            *p = '@' as i32 as libc::c_char;
        }
        if indx == -(1 as libc::c_int) as size_t {
            return 0 as libc::c_int != 0;
        }
        (*h).dynstr_index = indx;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn bfd_elf_link_mark_dynamic_symbol(
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
    mut sym: *mut Elf_Internal_Sym,
) {
    let mut d: *mut bfd_elf_dynamic_list = (*info).dynamic_list;
    if (*h).dynamic() as libc::c_int != 0
        || (*info).type_0() as libc::c_int == type_relocatable as libc::c_int
    {
        return;
    }
    if (*info).dynamic_data() as libc::c_int != 0
        && ((*h).type_0() as libc::c_int == 1 as libc::c_int
            || (*h).type_0() as libc::c_int == 5 as libc::c_int
            || !sym.is_null()
                && ((*sym).st_info as libc::c_int & 0xf as libc::c_int
                    == 1 as libc::c_int
                    || (*sym).st_info as libc::c_int & 0xf as libc::c_int
                        == 5 as libc::c_int))
        || !d.is_null() && (*h).non_elf() as libc::c_int != 0
            && !((Some(((*d).match_0).expect("non-null function pointer")))
                .expect(
                    "non-null function pointer",
                )(&mut (*d).head, 0 as *mut bfd_elf_version_expr, (*h).root.root.string))
                .is_null()
    {
        (*h).set_dynamic(1 as libc::c_int as libc::c_uint);
        ((*h).root).set_non_ir_ref_dynamic(1 as libc::c_int as libc::c_uint);
    }
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_record_link_assignment(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut name: *const libc::c_char,
    mut provide: bool,
    mut hidden: bool,
) -> bool {
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut hv: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut htab: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    if !is_elf_hash_table((*info).hash) {
        return 1 as libc::c_int != 0;
    }
    htab = elf_hash_table(info);
    h = elf_link_hash_lookup(
        htab,
        name,
        !provide,
        1 as libc::c_int != 0,
        0 as libc::c_int != 0,
    );
    if h.is_null() {
        return provide;
    }
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_warning as libc::c_int {
        h = (*h).root.u.i.link as *mut elf_link_hash_entry;
    }
    if (*h).versioned() as libc::c_int == unknown as libc::c_int {
        let mut version: *mut libc::c_char = strrchr(name, '@' as i32);
        if !version.is_null() {
            if version > name as *mut libc::c_char
                && *version.offset(-(1 as libc::c_int) as isize) as libc::c_int
                    != '@' as i32
            {
                (*h).set_versioned(versioned_hidden);
            } else {
                (*h).set_versioned(versioned);
            }
        }
    }
    if (*h).non_elf() != 0 {
        bfd_elf_link_mark_dynamic_symbol(info, h, 0 as *mut Elf_Internal_Sym);
        (*h).set_non_elf(0 as libc::c_int as libc::c_uint);
    }
    match ((*h).root).type_0() as libc::c_int {
        2 | 1 => {
            ((*h).root).set_type_0(bfd_link_hash_new);
            if !((*h).root.u.undef.next).is_null()
                || (*htab).root.undefs_tail == &mut (*h).root as *mut bfd_link_hash_entry
            {
                bfd_link_repair_undef_list(&mut (*htab).root);
            }
        }
        3 | 4 | 5 | 0 => {}
        6 => {
            bed = (*(*output_bfd).xvec).backend_data as *const elf_backend_data;
            hv = h;
            while ((*hv).root).type_0() as libc::c_int
                == bfd_link_hash_indirect as libc::c_int
                || ((*hv).root).type_0() as libc::c_int
                    == bfd_link_hash_warning as libc::c_int
            {
                hv = (*hv).root.u.i.link as *mut elf_link_hash_entry;
            }
            ((*h).root).set_type_0(bfd_link_hash_undefined);
            ((*hv).root).set_type_0(bfd_link_hash_indirect);
            (*hv).root.u.i.link = h as *mut bfd_link_hash_entry;
            (Some(
                ((*bed).elf_backend_copy_indirect_symbol)
                    .expect("non-null function pointer"),
            ))
                .expect("non-null function pointer")(info, h, hv);
        }
        _ => {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                696 as libc::c_int,
            );
            return 0 as libc::c_int != 0;
        }
    }
    if provide as libc::c_int != 0 && (*h).def_dynamic() as libc::c_int != 0
        && (*h).def_regular() == 0
    {
        ((*h).root).set_type_0(bfd_link_hash_undefined);
    }
    if (*h).def_dynamic() as libc::c_int != 0 && (*h).def_regular() == 0 {
        (*h).verinfo.verdef = 0 as *mut Elf_Internal_Verdef;
    }
    (*h).set_mark(1 as libc::c_int as libc::c_uint);
    (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
    if hidden {
        bed = (*(*output_bfd).xvec).backend_data as *const elf_backend_data;
        if (*h).other() as libc::c_int & 0x3 as libc::c_int != 1 as libc::c_int {
            (*h)
                .set_other(
                    ((*h).other() as libc::c_int
                        & !(-(1 as libc::c_int) & 0x3 as libc::c_int) | 2 as libc::c_int)
                        as libc::c_uint,
                );
        }
        (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
            .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
    }
    if !((*info).type_0() as libc::c_int == type_relocatable as libc::c_int)
        && (*h).dynindx != -(1 as libc::c_int) as libc::c_long
        && ((*h).other() as libc::c_int & 0x3 as libc::c_int == 2 as libc::c_int
            || (*h).other() as libc::c_int & 0x3 as libc::c_int == 1 as libc::c_int)
    {
        (*h).set_forced_local(1 as libc::c_int as libc::c_uint);
    }
    if ((*h).def_dynamic() as libc::c_int != 0 || (*h).ref_dynamic() as libc::c_int != 0
        || (*info).type_0() as libc::c_int == type_dll as libc::c_int
        || (*elf_hash_table(info)).is_relocatable_executable as libc::c_int != 0)
        && (*h).forced_local() == 0
        && (*h).dynindx == -(1 as libc::c_int) as libc::c_long
    {
        if !bfd_elf_link_record_dynamic_symbol(info, h) {
            return 0 as libc::c_int != 0;
        }
        if (*h).is_weakalias() != 0 {
            let mut def: *mut elf_link_hash_entry = weakdef(h);
            if (*def).dynindx == -(1 as libc::c_int) as libc::c_long
                && !bfd_elf_link_record_dynamic_symbol(info, def)
            {
                return 0 as libc::c_int != 0;
            }
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_link_record_local_dynamic_symbol(
    mut info: *mut bfd_link_info,
    mut input_bfd: *mut bfd,
    mut input_indx: libc::c_long,
) -> libc::c_int {
    let mut amt: size_t = 0;
    let mut entry: *mut elf_link_local_dynamic_entry = 0
        as *mut elf_link_local_dynamic_entry;
    let mut eht: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut dynstr: *mut elf_strtab_hash = 0 as *mut elf_strtab_hash;
    let mut dynstr_index: size_t = 0;
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut eshndx: Elf_External_Sym_Shndx = Elf_External_Sym_Shndx {
        est_shndx: [0; 4],
    };
    let mut esym: [libc::c_char; 24] = [0; 24];
    if !is_elf_hash_table((*info).hash) {
        return 0 as libc::c_int;
    }
    entry = (*elf_hash_table(info)).dynlocal;
    while !entry.is_null() {
        if (*entry).input_bfd == input_bfd && (*entry).input_indx == input_indx {
            return 1 as libc::c_int;
        }
        entry = (*entry).next;
    }
    amt = ::core::mem::size_of::<elf_link_local_dynamic_entry>() as libc::c_ulong;
    entry = bfd_alloc(input_bfd, amt) as *mut elf_link_local_dynamic_entry;
    if entry.is_null() {
        return 0 as libc::c_int;
    }
    if (bfd_elf_get_elf_syms(
        input_bfd,
        &mut (*(*input_bfd).tdata.elf_obj_data).symtab_hdr,
        1 as libc::c_int as size_t,
        input_indx as size_t,
        &mut (*entry).isym,
        esym.as_mut_ptr() as *mut libc::c_void,
        &mut eshndx,
    ))
        .is_null()
    {
        bfd_release(input_bfd, entry as *mut libc::c_void);
        return 0 as libc::c_int;
    }
    if (*entry).isym.st_shndx != 0 as libc::c_int as libc::c_uint
        && (*entry).isym.st_shndx < (0x100 as libc::c_uint).wrapping_neg()
    {
        let mut s: *mut asection = 0 as *mut asection;
        s = bfd_section_from_elf_index(input_bfd, (*entry).isym.st_shndx);
        if s.is_null() || bfd_is_abs_section((*s).output_section) as libc::c_int != 0 {
            bfd_release(input_bfd, entry as *mut libc::c_void);
            return 2 as libc::c_int;
        }
    }
    name = bfd_elf_string_from_elf_section(
        input_bfd,
        (*(*input_bfd).tdata.elf_obj_data).symtab_hdr.sh_link,
        (*entry).isym.st_name as libc::c_uint,
    );
    dynstr = (*elf_hash_table(info)).dynstr;
    if dynstr.is_null() {
        dynstr = _bfd_elf_strtab_init();
        let ref mut fresh6 = (*elf_hash_table(info)).dynstr;
        *fresh6 = dynstr;
        if dynstr.is_null() {
            return 0 as libc::c_int;
        }
    }
    dynstr_index = _bfd_elf_strtab_add(dynstr, name, 0 as libc::c_int != 0);
    if dynstr_index == -(1 as libc::c_int) as size_t {
        return 0 as libc::c_int;
    }
    (*entry).isym.st_name = dynstr_index;
    eht = elf_hash_table(info);
    (*entry).next = (*eht).dynlocal;
    (*eht).dynlocal = entry;
    (*entry).input_bfd = input_bfd;
    (*entry).input_indx = input_indx;
    (*eht).dynsymcount = ((*eht).dynsymcount).wrapping_add(1);
    (*eht).dynsymcount;
    (*entry)
        .isym
        .st_info = (((0 as libc::c_int) << 4 as libc::c_int)
        + ((*entry).isym.st_info as libc::c_int & 0xf as libc::c_int
            & 0xf as libc::c_int)) as libc::c_uchar;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_lookup_local_dynindx(
    mut info: *mut bfd_link_info,
    mut input_bfd: *mut bfd,
    mut input_indx: libc::c_long,
) -> libc::c_long {
    let mut e: *mut elf_link_local_dynamic_entry = 0
        as *mut elf_link_local_dynamic_entry;
    e = (*elf_hash_table(info)).dynlocal;
    while !e.is_null() {
        if (*e).input_bfd == input_bfd && (*e).input_indx == input_indx {
            return (*e).dynindx;
        }
        e = (*e).next;
    }
    return -(1 as libc::c_int) as libc::c_long;
}
unsafe extern "C" fn elf_link_renumber_hash_table_dynsyms(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut count: *mut size_t = data as *mut size_t;
    if (*h).forced_local() != 0 {
        return 1 as libc::c_int != 0;
    }
    if (*h).dynindx != -(1 as libc::c_int) as libc::c_long {
        *count = (*count).wrapping_add(1);
        (*h).dynindx = *count as libc::c_long;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_link_renumber_local_hash_table_dynsyms(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut count: *mut size_t = data as *mut size_t;
    if (*h).forced_local() == 0 {
        return 1 as libc::c_int != 0;
    }
    if (*h).dynindx != -(1 as libc::c_int) as libc::c_long {
        *count = (*count).wrapping_add(1);
        (*h).dynindx = *count as libc::c_long;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_omit_section_dynsym_default(
    mut _output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut p: *mut asection,
) -> bool {
    let mut htab: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut ip: *mut asection = 0 as *mut asection;
    match (*((*p).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type {
        1 | 8 | 0 => {
            htab = elf_hash_table(info);
            if !((*htab).text_index_section).is_null() {
                return p != (*htab).text_index_section
                    && p != (*htab).data_index_section;
            }
            return !((*htab).dynobj).is_null()
                && {
                    ip = bfd_get_linker_section((*htab).dynobj, (*p).name);
                    !ip.is_null()
                } && (*ip).output_section == p;
        }
        _ => return 1 as libc::c_int != 0,
    };
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_omit_section_dynsym_all(
    mut _output_bfd: *mut bfd,
    mut _info: *mut bfd_link_info,
    mut _p: *mut asection,
) -> bool {
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_link_renumber_dynsyms(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut section_sym_count: *mut libc::c_ulong,
) -> libc::c_ulong {
    let mut dynsymcount: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut do_sec: bool = !section_sym_count.is_null();
    if (*info).type_0() as libc::c_int == type_dll as libc::c_int
        || (*info).type_0() as libc::c_int == type_pie as libc::c_int
        || (*elf_hash_table(info)).is_relocatable_executable as libc::c_int != 0
    {
        let mut bed: *const elf_backend_data = (*(*output_bfd).xvec).backend_data
            as *const elf_backend_data;
        let mut p: *mut asection = 0 as *mut asection;
        p = (*output_bfd).sections;
        while !p.is_null() {
            if (*p).flags & 0x8000 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
                && (*p).flags & 0x1 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                && (*elf_hash_table(info)).dynamic_relocs as libc::c_int != 0
                && !(Some(
                    ((*bed).elf_backend_omit_section_dynsym)
                        .expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(output_bfd, info, p)
            {
                dynsymcount = dynsymcount.wrapping_add(1);
                dynsymcount;
                if do_sec {
                    (*((*p).used_by_bfd as *mut bfd_elf_section_data))
                        .dynindx = dynsymcount as libc::c_int;
                }
            } else if do_sec {
                (*((*p).used_by_bfd as *mut bfd_elf_section_data))
                    .dynindx = 0 as libc::c_int;
            }
            p = (*p).next;
        }
    }
    if do_sec {
        *section_sym_count = dynsymcount;
    }
    elf_link_hash_traverse(
        elf_hash_table(info),
        Some(
            elf_link_renumber_local_hash_table_dynsyms
                as unsafe extern "C" fn(
                    *mut elf_link_hash_entry,
                    *mut libc::c_void,
                ) -> bool,
        ),
        &mut dynsymcount as *mut libc::c_ulong as *mut libc::c_void,
    );
    if !((*elf_hash_table(info)).dynlocal).is_null() {
        let mut p_0: *mut elf_link_local_dynamic_entry = 0
            as *mut elf_link_local_dynamic_entry;
        p_0 = (*elf_hash_table(info)).dynlocal;
        while !p_0.is_null() {
            dynsymcount = dynsymcount.wrapping_add(1);
            (*p_0).dynindx = dynsymcount as libc::c_long;
            p_0 = (*p_0).next;
        }
    }
    (*elf_hash_table(info)).local_dynsymcount = dynsymcount;
    elf_link_hash_traverse(
        elf_hash_table(info),
        Some(
            elf_link_renumber_hash_table_dynsyms
                as unsafe extern "C" fn(
                    *mut elf_link_hash_entry,
                    *mut libc::c_void,
                ) -> bool,
        ),
        &mut dynsymcount as *mut libc::c_ulong as *mut libc::c_void,
    );
    dynsymcount = dynsymcount.wrapping_add(1);
    dynsymcount;
    (*elf_hash_table(info)).dynsymcount = dynsymcount;
    return dynsymcount;
}
unsafe extern "C" fn elf_merge_st_other(
    mut abfd: *mut bfd,
    mut h: *mut elf_link_hash_entry,
    mut st_other: libc::c_uint,
    mut sec: *mut asection,
    mut definition: bool,
    mut dynamic: bool,
) {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    if ((*bed).elf_backend_merge_symbol_attribute).is_some() {
        (Some(
            ((*bed).elf_backend_merge_symbol_attribute)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(h, st_other, definition, dynamic);
    }
    if !dynamic {
        let mut symvis: libc::c_uint = st_other & 0x3 as libc::c_int as libc::c_uint;
        let mut hvis: libc::c_uint = ((*h).other() as libc::c_int & 0x3 as libc::c_int)
            as libc::c_uint;
        if symvis.wrapping_sub(1 as libc::c_int as libc::c_uint)
            < hvis.wrapping_sub(1 as libc::c_int as libc::c_uint)
        {
            (*h)
                .set_other(
                    symvis
                        | ((*h).other() as libc::c_int
                            & !(-(1 as libc::c_int) & 0x3 as libc::c_int))
                            as libc::c_uint,
                );
        }
    } else if definition as libc::c_int != 0
        && st_other & 0x3 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        && (*sec).flags & 0x8 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
    {
        (*h).set_protected_def(1 as libc::c_int as libc::c_uint);
    }
}
unsafe extern "C" fn _bfd_elf_merge_symbol(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut name: *const libc::c_char,
    mut sym: *mut Elf_Internal_Sym,
    mut psec: *mut *mut asection,
    mut pvalue: *mut bfd_vma,
    mut sym_hash: *mut *mut elf_link_hash_entry,
    mut poldbfd: *mut *mut bfd,
    mut pold_weak: *mut bool,
    mut pold_alignment: *mut libc::c_uint,
    mut skip: *mut bool,
    mut override_0: *mut *mut bfd,
    mut type_change_ok: *mut bool,
    mut size_change_ok: *mut bool,
    mut matched: *mut bool,
) -> bool {
    let mut sec: *mut asection = 0 as *mut asection;
    let mut oldsec: *mut asection = 0 as *mut asection;
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut hi: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut flip: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut bind: libc::c_int = 0;
    let mut oldbfd: *mut bfd = 0 as *mut bfd;
    let mut newdyn: bool = false;
    let mut olddyn: bool = false;
    let mut olddef: bool = false;
    let mut newdef: bool = false;
    let mut newdyncommon: bool = false;
    let mut olddyncommon: bool = false;
    let mut newweak: bool = false;
    let mut oldweak: bool = false;
    let mut newfunc: bool = false;
    let mut oldfunc: bool = false;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut new_version: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut default_sym: bool = *matched;
    *skip = 0 as libc::c_int != 0;
    *override_0 = 0 as *mut bfd;
    sec = *psec;
    bind = ((*sym).st_info as libc::c_uint >> 4 as libc::c_int) as libc::c_int;
    if !bfd_is_und_section(sec) {
        h = elf_link_hash_lookup(
            elf_hash_table(info),
            name,
            1 as libc::c_int != 0,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
        );
    } else {
        h = bfd_wrapped_link_hash_lookup(
            abfd,
            info,
            name,
            1 as libc::c_int != 0,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
        ) as *mut elf_link_hash_entry;
    }
    if h.is_null() {
        return 0 as libc::c_int != 0;
    }
    *sym_hash = h;
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if (*h).versioned() as libc::c_int != unversioned as libc::c_int {
        new_version = strrchr(name, '@' as i32);
        if !new_version.is_null() {
            if (*h).versioned() as libc::c_int == unknown as libc::c_int {
                if new_version > name as *mut libc::c_char
                    && *new_version.offset(-(1 as libc::c_int) as isize) as libc::c_int
                        != '@' as i32
                {
                    (*h).set_versioned(versioned_hidden);
                } else {
                    (*h).set_versioned(versioned);
                }
            }
            new_version = new_version.offset(1 as libc::c_int as isize);
            if *new_version.offset(0 as libc::c_int as isize) as libc::c_int
                == '\0' as i32
            {
                new_version = 0 as *mut libc::c_char;
            }
        } else {
            (*h).set_versioned(unversioned);
        }
    } else {
        new_version = 0 as *mut libc::c_char;
    }
    hi = h;
    while ((*h).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_warning as libc::c_int
    {
        h = (*h).root.u.i.link as *mut elf_link_hash_entry;
    }
    if !*matched {
        if hi == h
            || ((*h).root).type_0() as libc::c_int == bfd_link_hash_new as libc::c_int
        {
            *matched = 1 as libc::c_int != 0;
        } else {
            let mut old_hidden: bool = (*h).versioned() as libc::c_int
                == versioned_hidden as libc::c_int;
            let mut new_hidden: bool = (*hi).versioned() as libc::c_int
                == versioned_hidden as libc::c_int;
            if !old_hidden && !new_hidden {
                *matched = 1 as libc::c_int != 0;
            } else {
                let mut old_version: *mut libc::c_char = 0 as *mut libc::c_char;
                if (*h).versioned() as libc::c_int >= versioned as libc::c_int {
                    old_version = (strrchr((*h).root.root.string, '@' as i32))
                        .offset(1 as libc::c_int as isize);
                } else {
                    old_version = 0 as *mut libc::c_char;
                }
                *matched = old_version == new_version
                    || !old_version.is_null() && !new_version.is_null()
                        && strcmp(old_version, new_version) == 0 as libc::c_int;
            }
        }
    }
    oldbfd = 0 as *mut bfd;
    oldsec = 0 as *mut asection;
    match ((*h).root).type_0() as libc::c_int {
        1 | 2 => {
            oldbfd = (*h).root.u.undef.abfd;
        }
        3 | 4 => {
            oldbfd = (*(*h).root.u.def.section).owner;
            oldsec = (*h).root.u.def.section;
        }
        5 => {
            oldbfd = (*(*(*h).root.u.c.p).section).owner;
            oldsec = (*(*h).root.u.c.p).section;
            if !pold_alignment.is_null() {
                *pold_alignment = (*(*h).root.u.c.p).alignment_power;
            }
        }
        _ => {}
    }
    if !poldbfd.is_null() && (*poldbfd).is_null() {
        *poldbfd = oldbfd;
    }
    newweak = bind == 2 as libc::c_int;
    oldweak = ((*h).root).type_0() as libc::c_int == bfd_link_hash_defweak as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefweak as libc::c_int;
    if !pold_weak.is_null() {
        *pold_weak = oldweak;
    }
    bfd_elf_link_mark_dynamic_symbol(info, h, sym);
    newdyn = (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint;
    if newdyn {
        if bfd_is_und_section(sec) {
            if bind != 2 as libc::c_int {
                (*h).set_ref_dynamic_nonweak(1 as libc::c_int as libc::c_uint);
                (*hi).set_ref_dynamic_nonweak(1 as libc::c_int as libc::c_uint);
            }
        } else {
            if *matched {
                (*h).set_dynamic_def(1 as libc::c_int as libc::c_uint);
            }
            (*hi).set_dynamic_def(1 as libc::c_int as libc::c_uint);
        }
    }
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_new as libc::c_int {
        (*h).set_non_elf(0 as libc::c_int as libc::c_uint);
        return 1 as libc::c_int != 0;
    }
    if abfd == oldbfd && (newweak as libc::c_int != 0 || oldweak as libc::c_int != 0)
        && ((*abfd).flags & 0x40 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint || (*h).def_regular() == 0)
    {
        return 1 as libc::c_int != 0;
    }
    olddyn = 0 as libc::c_int != 0;
    if !oldbfd.is_null() {
        olddyn = (*oldbfd).flags & 0x40 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint;
    } else if !oldsec.is_null() {
        olddyn = (*(*oldsec).symbol).flags
            & ((1 as libc::c_int) << 15 as libc::c_int) as libc::c_uint
            != 0 as libc::c_int as libc::c_uint;
    }
    if !oldbfd.is_null()
        && (*oldbfd).flags & 0x10000 as libc::c_int as libc::c_uint
            != (*abfd).flags & 0x10000 as libc::c_int as libc::c_uint
        && newdyn as libc::c_int != olddyn as libc::c_int
    {
        ((*h).root).set_non_ir_ref_dynamic(1 as libc::c_int as libc::c_uint);
        ((*hi).root).set_non_ir_ref_dynamic(1 as libc::c_int as libc::c_uint);
    }
    newdef = !bfd_is_und_section(sec) && !bfd_is_com_section(sec);
    olddef = ((*h).root).type_0() as libc::c_int
        != bfd_link_hash_undefined as libc::c_int
        && ((*h).root).type_0() as libc::c_int != bfd_link_hash_undefweak as libc::c_int
        && ((*h).root).type_0() as libc::c_int != bfd_link_hash_common as libc::c_int;
    newfunc = (*sym).st_info as libc::c_int & 0xf as libc::c_int != 0 as libc::c_int
        && ((*bed).is_function_type)
            .expect(
                "non-null function pointer",
            )(((*sym).st_info as libc::c_int & 0xf as libc::c_int) as libc::c_uint)
            as libc::c_int != 0;
    oldfunc = (*h).type_0() as libc::c_int != 0 as libc::c_int
        && ((*bed).is_function_type).expect("non-null function pointer")((*h).type_0())
            as libc::c_int != 0;
    if !(newfunc as libc::c_int != 0 && oldfunc as libc::c_int != 0)
        && (*sym).st_info as libc::c_int & 0xf as libc::c_int
            != (*h).type_0() as libc::c_int
        && (*sym).st_info as libc::c_int & 0xf as libc::c_int != 0 as libc::c_int
        && (*h).type_0() as libc::c_int != 0 as libc::c_int
        && (newdef as libc::c_int != 0 || bfd_is_com_section(sec) as libc::c_int != 0)
        && (olddef as libc::c_int != 0
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_common as libc::c_int)
    {
        if newdyn as libc::c_int != 0 && !olddyn {
            *skip = 1 as libc::c_int != 0;
            return 1 as libc::c_int != 0;
        }
        if hi != h && !newdyn && olddyn as libc::c_int != 0 {
            h = hi;
            (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
                .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
            (*h).set_forced_local(0 as libc::c_int as libc::c_uint);
            (*h).set_ref_dynamic(0 as libc::c_int as libc::c_uint);
            (*h).set_def_dynamic(0 as libc::c_int as libc::c_uint);
            (*h).set_dynamic_def(0 as libc::c_int as libc::c_uint);
            if !((*h).root.u.undef.next).is_null()
                || (*(*info).hash).undefs_tail
                    == &mut (*h).root as *mut bfd_link_hash_entry
            {
                ((*h).root).set_type_0(bfd_link_hash_undefined);
                (*h).root.u.undef.abfd = abfd;
            } else {
                ((*h).root).set_type_0(bfd_link_hash_new);
                (*h).root.u.undef.abfd = 0 as *mut bfd;
            }
            return 1 as libc::c_int != 0;
        }
    }
    if !oldbfd.is_null()
        && (*oldbfd).flags & 0x10000 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        && (*abfd).flags & 0x10000 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        && (*sym).st_info as libc::c_int & 0xf as libc::c_int
            != (*h).type_0() as libc::c_int
        && ((*sym).st_info as libc::c_int & 0xf as libc::c_int == 6 as libc::c_int
            || (*h).type_0() as libc::c_int == 6 as libc::c_int)
    {
        let mut ntbfd: *mut bfd = 0 as *mut bfd;
        let mut tbfd: *mut bfd = 0 as *mut bfd;
        let mut ntdef: bool = false;
        let mut tdef: bool = false;
        let mut ntsec: *mut asection = 0 as *mut asection;
        let mut tsec: *mut asection = 0 as *mut asection;
        if (*h).type_0() as libc::c_int == 6 as libc::c_int {
            ntbfd = abfd;
            ntsec = sec;
            ntdef = newdef;
            tbfd = oldbfd;
            tsec = oldsec;
            tdef = olddef;
        } else {
            ntbfd = oldbfd;
            ntsec = oldsec;
            ntdef = olddef;
            tbfd = abfd;
            tsec = sec;
            tdef = newdef;
        }
        if tdef as libc::c_int != 0 && ntdef as libc::c_int != 0 {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%s: TLS definition in %pB section %pA mismatches non-TLS definition in %pB section %pA\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*h).root.root.string,
                tbfd,
                tsec,
                ntbfd,
                ntsec,
            );
        } else if !tdef && !ntdef {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%s: TLS reference in %pB mismatches non-TLS reference in %pB\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*h).root.root.string,
                tbfd,
                ntbfd,
            );
        } else if tdef {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%s: TLS definition in %pB section %pA mismatches non-TLS reference in %pB\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*h).root.root.string,
                tbfd,
                tsec,
                ntbfd,
            );
        } else {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%s: TLS reference in %pB mismatches non-TLS definition in %pB section %pA\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*h).root.root.string,
                tbfd,
                ntbfd,
                ntsec,
            );
        }
        bfd_set_error(bfd_error_bad_value);
        return 0 as libc::c_int != 0;
    }
    if newdyn as libc::c_int != 0
        && (*h).other() as libc::c_int & 0x3 as libc::c_int != 0 as libc::c_int
        && !bfd_is_und_section(sec)
    {
        *skip = 1 as libc::c_int != 0;
        (*h).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
        (*hi).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
        if (*h).other() as libc::c_int & 0x3 as libc::c_int == 3 as libc::c_int {
            return bfd_elf_link_record_dynamic_symbol(info, h)
        } else {
            return 1 as libc::c_int != 0
        }
    } else if !newdyn
        && (*sym).st_other as libc::c_int & 0x3 as libc::c_int != 0 as libc::c_int
        && (*h).def_dynamic() as libc::c_int != 0
    {
        if ((*hi).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int
        {
            if (*h).ref_regular() != 0 {
                ((*hi).root).set_type_0(((*h).root).type_0());
                ((*h).root).set_type_0(bfd_link_hash_indirect);
                (Some(
                    ((*bed).elf_backend_copy_indirect_symbol)
                        .expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(info, hi, h);
                (*h).root.u.i.link = hi as *mut bfd_link_hash_entry;
                if (*sym).st_other as libc::c_int & 0x3 as libc::c_int
                    != 3 as libc::c_int
                {
                    (Some(
                        ((*bed).elf_backend_hide_symbol)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(info, h, 1 as libc::c_int != 0);
                    (*h).set_forced_local(0 as libc::c_int as libc::c_uint);
                    (*h).set_ref_dynamic(0 as libc::c_int as libc::c_uint);
                } else {
                    (*h).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
                }
                (*h).set_def_dynamic(0 as libc::c_int as libc::c_uint);
                (*h).size = 0 as libc::c_int as bfd_size_type;
                (*h).set_type_0(0 as libc::c_int as libc::c_uint);
                h = hi;
            } else {
                h = hi;
            }
        }
        if !((*h).root.u.undef.next).is_null()
            || (*(*info).hash).undefs_tail == &mut (*h).root as *mut bfd_link_hash_entry
        {
            ((*h).root).set_type_0(bfd_link_hash_undefined);
            (*h).root.u.undef.abfd = abfd;
        } else {
            ((*h).root).set_type_0(bfd_link_hash_new);
            (*h).root.u.undef.abfd = 0 as *mut bfd;
        }
        if (*sym).st_other as libc::c_int & 0x3 as libc::c_int != 3 as libc::c_int {
            (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
                .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
            (*h).set_forced_local(0 as libc::c_int as libc::c_uint);
            (*h).set_ref_dynamic(0 as libc::c_int as libc::c_uint);
        } else {
            (*h).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
        }
        (*h).set_def_dynamic(0 as libc::c_int as libc::c_uint);
        (*h).size = 0 as libc::c_int as bfd_size_type;
        (*h).set_type_0(0 as libc::c_int as libc::c_uint);
        return 1 as libc::c_int != 0;
    }
    if newdef as libc::c_int != 0 && !newdyn
        && (olddyn as libc::c_int != 0 || ((*h).root).ldscript_def() as libc::c_int != 0)
    {
        newweak = 0 as libc::c_int != 0;
    }
    if olddef as libc::c_int != 0 && newdyn as libc::c_int != 0 {
        oldweak = 0 as libc::c_int != 0;
    }
    if newfunc as libc::c_int != 0 && oldfunc as libc::c_int != 0 {
        *type_change_ok = 1 as libc::c_int != 0;
    }
    if oldweak as libc::c_int != 0 || newweak as libc::c_int != 0
        || newdef as libc::c_int != 0
            && ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_undefined as libc::c_int
    {
        *type_change_ok = 1 as libc::c_int != 0;
    }
    if *type_change_ok as libc::c_int != 0
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefined as libc::c_int
    {
        *size_change_ok = 1 as libc::c_int != 0;
    }
    if newdyn as libc::c_int != 0 && newdef as libc::c_int != 0 && !newweak
        && (*sec).flags & 0x1 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        && (*sec).flags & 0x2 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        && (*sym).st_size > 0 as libc::c_int as libc::c_ulong && !newfunc
    {
        newdyncommon = 1 as libc::c_int != 0;
    } else {
        newdyncommon = 0 as libc::c_int != 0;
    }
    if olddyn as libc::c_int != 0 && olddef as libc::c_int != 0
        && ((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
        && (*h).def_dynamic() as libc::c_int != 0
        && (*(*h).root.u.def.section).flags & 0x1 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        && (*(*h).root.u.def.section).flags & 0x2 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        && (*h).size > 0 as libc::c_int as libc::c_ulong && !oldfunc
    {
        olddyncommon = 1 as libc::c_int != 0;
    } else {
        olddyncommon = 0 as libc::c_int != 0;
    }
    if ((*bed).merge_symbol).is_some() {
        if !((*bed).merge_symbol)
            .expect(
                "non-null function pointer",
            )(h, sym, psec, newdef, olddef, oldbfd, oldsec)
        {
            return 0 as libc::c_int != 0;
        }
        sec = *psec;
    }
    if olddef as libc::c_int != 0 && !olddyn && !oldweak && newdef as libc::c_int != 0
        && !newdyn && !newweak && !default_sym && (*h).def_regular() as libc::c_int != 0
        && !(!oldbfd.is_null()
            && (*oldbfd).flags & 0x10000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
            && (*abfd).flags & 0x10000 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint)
    {
        (Some(
            ((*(*info).callbacks).multiple_definition)
                .expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(info, &mut (*h).root, abfd, sec, *pvalue);
        *skip = 1 as libc::c_int != 0;
        return 1 as libc::c_int != 0;
    }
    if olddyncommon as libc::c_int != 0 && newdyncommon as libc::c_int != 0
        && (*sym).st_size != (*h).size
    {
        (Some(
            ((*(*info).callbacks).multiple_common).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(info, &mut (*h).root, abfd, bfd_link_hash_common, (*sym).st_size);
        if (*sym).st_size > (*h).size {
            (*h).size = (*sym).st_size;
        }
        *size_change_ok = 1 as libc::c_int != 0;
    }
    if newdyn as libc::c_int != 0 && newdef as libc::c_int != 0
        && (olddef as libc::c_int != 0
            || ((*h).root).type_0() as libc::c_int == bfd_link_hash_common as libc::c_int
                && (newweak as libc::c_int != 0 || newfunc as libc::c_int != 0))
    {
        *override_0 = abfd;
        newdef = 0 as libc::c_int != 0;
        newdyncommon = 0 as libc::c_int != 0;
        sec = &mut *_bfd_std_section.as_mut_ptr().offset(1 as libc::c_int as isize)
            as *mut asection;
        *psec = sec;
        *size_change_ok = 1 as libc::c_int != 0;
        if ((*h).root).type_0() as libc::c_int == bfd_link_hash_common as libc::c_int {
            *type_change_ok = 1 as libc::c_int != 0;
        }
    }
    if newdyncommon as libc::c_int != 0
        && ((*h).root).type_0() as libc::c_int == bfd_link_hash_common as libc::c_int
    {
        *override_0 = oldbfd;
        newdef = 0 as libc::c_int != 0;
        newdyncommon = 0 as libc::c_int != 0;
        *pvalue = (*sym).st_size;
        sec = ((*bed).common_section).expect("non-null function pointer")(oldsec);
        *psec = sec;
        *size_change_ok = 1 as libc::c_int != 0;
    }
    if newdef as libc::c_int != 0 && olddef as libc::c_int != 0
        && newweak as libc::c_int != 0
    {
        if !(!oldbfd.is_null()
            && (*oldbfd).flags & 0x10000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
            && (*abfd).flags & 0x10000 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint)
        {
            newdef = 0 as libc::c_int != 0;
            *skip = 1 as libc::c_int != 0;
        }
        elf_merge_st_other(
            abfd,
            h,
            (*sym).st_other as libc::c_uint,
            sec,
            newdef,
            newdyn,
        );
        if (*h).dynindx != -(1 as libc::c_int) as libc::c_long {
            match (*h).other() as libc::c_int & 0x3 as libc::c_int {
                1 | 2 => {
                    (Some(
                        ((*bed).elf_backend_hide_symbol)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(info, h, 1 as libc::c_int != 0);
                }
                _ => {}
            }
        }
    }
    flip = 0 as *mut elf_link_hash_entry;
    if !newdyn
        && (newdef as libc::c_int != 0
            || bfd_is_com_section(sec) as libc::c_int != 0
                && (oldweak as libc::c_int != 0 || oldfunc as libc::c_int != 0))
        && olddyn as libc::c_int != 0 && olddef as libc::c_int != 0
        && (*h).def_dynamic() as libc::c_int != 0
    {
        ((*h).root).set_type_0(bfd_link_hash_undefined);
        (*h).root.u.undef.abfd = (*(*h).root.u.def.section).owner;
        *size_change_ok = 1 as libc::c_int != 0;
        olddef = 0 as libc::c_int != 0;
        olddyncommon = 0 as libc::c_int != 0;
        if bfd_is_com_section(sec) {
            if oldfunc {
                (*h).set_def_dynamic(0 as libc::c_int as libc::c_uint);
                (*h).set_type_0(0 as libc::c_int as libc::c_uint);
            }
            *type_change_ok = 1 as libc::c_int != 0;
        }
        if ((*hi).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int
        {
            flip = hi;
        } else {
            (*h).verinfo.vertree = 0 as *mut bfd_elf_version_tree;
        }
    }
    if !newdyn && bfd_is_com_section(sec) as libc::c_int != 0
        && olddyncommon as libc::c_int != 0
    {
        (Some(
            ((*(*info).callbacks).multiple_common).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(info, &mut (*h).root, abfd, bfd_link_hash_common, (*sym).st_size);
        if (*h).size > *pvalue {
            *pvalue = (*h).size;
        }
        if pold_alignment.is_null() {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                1799 as libc::c_int,
            );
        }
        *pold_alignment = (*(*h).root.u.def.section).alignment_power;
        olddef = 0 as libc::c_int != 0;
        olddyncommon = 0 as libc::c_int != 0;
        ((*h).root).set_type_0(bfd_link_hash_undefined);
        (*h).root.u.undef.abfd = (*(*h).root.u.def.section).owner;
        *size_change_ok = 1 as libc::c_int != 0;
        *type_change_ok = 1 as libc::c_int != 0;
        if ((*hi).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int
        {
            flip = hi;
        } else {
            (*h).verinfo.vertree = 0 as *mut bfd_elf_version_tree;
        }
    }
    if !flip.is_null() {
        ((*flip).root).set_type_0(((*h).root).type_0());
        (*flip).root.u.undef.abfd = (*h).root.u.undef.abfd;
        ((*h).root).set_type_0(bfd_link_hash_indirect);
        (*h).root.u.i.link = flip as *mut bfd_link_hash_entry;
        (Some(
            ((*bed).elf_backend_copy_indirect_symbol).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(info, flip, h);
        if (*h).def_dynamic() != 0 {
            (*h).set_def_dynamic(0 as libc::c_int as libc::c_uint);
            (*flip).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_add_default_symbol(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
    mut name: *const libc::c_char,
    mut sym: *mut Elf_Internal_Sym,
    mut sec: *mut asection,
    mut value: bfd_vma,
    mut poldbfd: *mut *mut bfd,
    mut dynsym: *mut bool,
) -> bool {
    let mut current_block: u64;
    let mut type_change_ok: bool = false;
    let mut size_change_ok: bool = false;
    let mut skip: bool = false;
    let mut shortname: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut hi: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut bh: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut collect: bool = false;
    let mut dynamic: bool = false;
    let mut override_0: *mut bfd = 0 as *mut bfd;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut shortlen: size_t = 0;
    let mut tmp_sec: *mut asection = 0 as *mut asection;
    let mut matched: bool = false;
    if (*h).versioned() as libc::c_int == unversioned as libc::c_int
        || (*h).versioned() as libc::c_int == versioned_hidden as libc::c_int
    {
        return 1 as libc::c_int != 0;
    }
    p = strchr(name, '@' as i32);
    if (*h).versioned() as libc::c_int == unknown as libc::c_int {
        if p.is_null() {
            (*h).set_versioned(unversioned);
            return 1 as libc::c_int != 0;
        } else if *p.offset(1 as libc::c_int as isize) as libc::c_int != '@' as i32 {
            (*h).set_versioned(versioned_hidden);
            return 1 as libc::c_int != 0;
        } else {
            (*h).set_versioned(versioned);
        }
    } else if p.is_null() {
        return 1 as libc::c_int != 0
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    collect = (*bed).collect() != 0;
    dynamic = (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint;
    shortlen = p.offset_from(name) as libc::c_long as size_t;
    shortname = bfd_hash_allocate(
        &mut (*(*info).hash).table,
        shortlen.wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
    ) as *mut libc::c_char;
    if shortname.is_null() {
        return 0 as libc::c_int != 0;
    }
    memcpy(shortname as *mut libc::c_void, name as *const libc::c_void, shortlen);
    *shortname.offset(shortlen as isize) = '\0' as i32 as libc::c_char;
    type_change_ok = 0 as libc::c_int != 0;
    size_change_ok = 0 as libc::c_int != 0;
    matched = 1 as libc::c_int != 0;
    tmp_sec = sec;
    if !_bfd_elf_merge_symbol(
        abfd,
        info,
        shortname,
        sym,
        &mut tmp_sec,
        &mut value,
        &mut hi,
        poldbfd,
        0 as *mut bool,
        0 as *mut libc::c_uint,
        &mut skip,
        &mut override_0,
        &mut type_change_ok,
        &mut size_change_ok,
        &mut matched,
    ) {
        return 0 as libc::c_int != 0;
    }
    if !skip {
        if (*hi).def_regular() as libc::c_int != 0
            || (*hi).def_regular() == 0 && (*hi).def_dynamic() == 0
                && ((*hi).root).type_0() as libc::c_int
                    == bfd_link_hash_defined as libc::c_int
        {
            if ((*hi).verinfo.vertree).is_null() && !((*info).version_info).is_null() {
                let mut hide: bool = false;
                (*hi)
                    .verinfo
                    .vertree = bfd_find_version_for_sym(
                    (*info).version_info,
                    (*hi).root.root.string,
                    &mut hide,
                );
                if !((*hi).verinfo.vertree).is_null() && hide as libc::c_int != 0 {
                    (Some(
                        ((*bed).elf_backend_hide_symbol)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(info, hi, 1 as libc::c_int != 0);
                    current_block = 3708512942293497990;
                } else {
                    current_block = 14434620278749266018;
                }
            } else {
                current_block = 14434620278749266018;
            }
            match current_block {
                3708512942293497990 => {}
                _ => {
                    if !((*hi).verinfo.vertree).is_null()
                        && strcmp(
                            p
                                .offset(1 as libc::c_int as isize)
                                .offset(
                                    (*p.offset(1 as libc::c_int as isize) as libc::c_int
                                        == '@' as i32) as libc::c_int as isize,
                                ),
                            (*(*hi).verinfo.vertree).name,
                        ) != 0 as libc::c_int
                    {
                        current_block = 3708512942293497990;
                    } else {
                        current_block = 17184638872671510253;
                    }
                }
            }
        } else {
            current_block = 17184638872671510253;
        }
        match current_block {
            3708512942293497990 => {}
            _ => {
                if override_0.is_null() {
                    if !((*info).type_0() as libc::c_int
                        == type_relocatable as libc::c_int)
                    {
                        bh = &mut (*hi).root;
                        if (*bh).type_0() as libc::c_int
                            == bfd_link_hash_defined as libc::c_int
                            && !((*(*bh).u.def.section).owner).is_null()
                            && (*(*(*bh).u.def.section).owner).flags
                                & 0x10000 as libc::c_int as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                        {
                            (*bh).set_type_0(bfd_link_hash_undefined);
                            (*bh).u.undef.abfd = (*(*bh).u.def.section).owner;
                        }
                        if !_bfd_generic_link_add_one_symbol(
                            info,
                            abfd,
                            shortname,
                            ((1 as libc::c_int) << 13 as libc::c_int) as flagword,
                            &mut *_bfd_std_section
                                .as_mut_ptr()
                                .offset(3 as libc::c_int as isize),
                            0 as libc::c_int as bfd_vma,
                            name,
                            0 as libc::c_int != 0,
                            collect,
                            &mut bh,
                        ) {
                            return 0 as libc::c_int != 0;
                        }
                        hi = bh as *mut elf_link_hash_entry;
                    }
                } else {
                    while ((*hi).root).type_0() as libc::c_int
                        == bfd_link_hash_indirect as libc::c_int
                        || ((*hi).root).type_0() as libc::c_int
                            == bfd_link_hash_warning as libc::c_int
                    {
                        hi = (*hi).root.u.i.link as *mut elf_link_hash_entry;
                    }
                    ((*h).root).set_type_0(bfd_link_hash_indirect);
                    (*h).root.u.i.link = hi as *mut bfd_link_hash_entry;
                    if (*h).def_dynamic() != 0 {
                        (*h).set_def_dynamic(0 as libc::c_int as libc::c_uint);
                        (*hi).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
                        if (*hi).ref_regular() as libc::c_int != 0
                            || (*hi).def_regular() as libc::c_int != 0
                        {
                            if !bfd_elf_link_record_dynamic_symbol(info, hi) {
                                return 0 as libc::c_int != 0;
                            }
                        }
                    }
                    hi = h;
                }
                if ((*hi).root).type_0() as libc::c_int
                    == bfd_link_hash_warning as libc::c_int
                {
                    hi = (*hi).root.u.i.link as *mut elf_link_hash_entry;
                }
                if ((*hi).root).type_0() as libc::c_int
                    == bfd_link_hash_indirect as libc::c_int
                {
                    let mut ht: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
                    ht = (*hi).root.u.i.link as *mut elf_link_hash_entry;
                    (Some(
                        ((*bed).elf_backend_copy_indirect_symbol)
                            .expect("non-null function pointer"),
                    ))
                        .expect("non-null function pointer")(info, ht, hi);
                    elf_merge_st_other(
                        abfd,
                        ht,
                        (*hi).other(),
                        sec,
                        1 as libc::c_int != 0,
                        dynamic,
                    );
                    (*ht)
                        .set_ref_dynamic_nonweak(
                            (*ht).ref_dynamic_nonweak()
                                | (*hi).ref_dynamic_nonweak() as libc::c_int as libc::c_uint,
                        );
                    (*hi)
                        .set_dynamic_def(
                            (*hi).dynamic_def()
                                | (*ht).dynamic_def() as libc::c_int as libc::c_uint,
                        );
                    if !*dynsym {
                        if !dynamic {
                            if !((*info).type_0() as libc::c_int
                                == type_pde as libc::c_int
                                || (*info).type_0() as libc::c_int
                                    == type_pie as libc::c_int)
                                || (*hi).def_dynamic() as libc::c_int != 0
                                || (*hi).ref_dynamic() as libc::c_int != 0
                            {
                                *dynsym = 1 as libc::c_int != 0;
                            }
                        } else if (*hi).ref_regular() != 0 {
                            *dynsym = 1 as libc::c_int != 0;
                        }
                    }
                }
            }
        }
    }
    len = strlen(name);
    shortname = bfd_hash_allocate(&mut (*(*info).hash).table, len as libc::c_uint)
        as *mut libc::c_char;
    if shortname.is_null() {
        return 0 as libc::c_int != 0;
    }
    memcpy(shortname as *mut libc::c_void, name as *const libc::c_void, shortlen);
    memcpy(
        shortname.offset(shortlen as isize) as *mut libc::c_void,
        p.offset(1 as libc::c_int as isize) as *const libc::c_void,
        len.wrapping_sub(shortlen),
    );
    type_change_ok = 0 as libc::c_int != 0;
    size_change_ok = 0 as libc::c_int != 0;
    tmp_sec = sec;
    if !_bfd_elf_merge_symbol(
        abfd,
        info,
        shortname,
        sym,
        &mut tmp_sec,
        &mut value,
        &mut hi,
        poldbfd,
        0 as *mut bool,
        0 as *mut libc::c_uint,
        &mut skip,
        &mut override_0,
        &mut type_change_ok,
        &mut size_change_ok,
        &mut matched,
    ) {
        return 0 as libc::c_int != 0;
    }
    if skip {
        if !dynamic
            && ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int
            && ((*hi).root).type_0() as libc::c_int
                == bfd_link_hash_defined as libc::c_int
        {
            ((*h).root).set_type_0(bfd_link_hash_defined);
            (*h).root.u.def.section = (*hi).root.u.def.section;
            (*h).root.u.def.value = (*hi).root.u.def.value;
            ((*hi).root).set_type_0(bfd_link_hash_indirect);
            (*hi).root.u.i.link = &mut (*h).root;
        } else {
            return 1 as libc::c_int != 0
        }
    } else if !override_0.is_null() {
        if ((*hi).root).type_0() as libc::c_int != bfd_link_hash_defined as libc::c_int
            && ((*hi).root).type_0() as libc::c_int
                != bfd_link_hash_defweak as libc::c_int
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: unexpected redefinition of indirect versioned symbol `%s'\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                shortname,
            );
        }
        return 1 as libc::c_int != 0;
    } else {
        bh = &mut (*hi).root;
        if !_bfd_generic_link_add_one_symbol(
            info,
            abfd,
            shortname,
            ((1 as libc::c_int) << 13 as libc::c_int) as flagword,
            &mut *_bfd_std_section.as_mut_ptr().offset(3 as libc::c_int as isize),
            0 as libc::c_int as bfd_vma,
            name,
            0 as libc::c_int != 0,
            collect,
            &mut bh,
        ) {
            return 0 as libc::c_int != 0;
        }
        hi = bh as *mut elf_link_hash_entry;
    }
    if ((*hi).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int {
        (Some(
            ((*bed).elf_backend_copy_indirect_symbol).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(info, h, hi);
        (*h)
            .set_ref_dynamic_nonweak(
                (*h).ref_dynamic_nonweak()
                    | (*hi).ref_dynamic_nonweak() as libc::c_int as libc::c_uint,
            );
        (*hi)
            .set_dynamic_def(
                (*hi).dynamic_def() | (*h).dynamic_def() as libc::c_int as libc::c_uint,
            );
        elf_merge_st_other(abfd, h, (*hi).other(), sec, 1 as libc::c_int != 0, dynamic);
        if !*dynsym {
            if !dynamic {
                if !((*info).type_0() as libc::c_int == type_pde as libc::c_int
                    || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
                    || (*hi).ref_dynamic() as libc::c_int != 0
                {
                    *dynsym = 1 as libc::c_int != 0;
                }
            } else if (*hi).ref_regular() != 0 {
                *dynsym = 1 as libc::c_int != 0;
            }
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_export_symbol(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut eif: *mut elf_info_failed = data as *mut elf_info_failed;
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int {
        return 1 as libc::c_int != 0;
    }
    if (*(*eif).info).export_dynamic() == 0 && (*h).dynamic() == 0 {
        return 1 as libc::c_int != 0;
    }
    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long
        && ((*h).def_regular() as libc::c_int != 0
            || (*h).ref_regular() as libc::c_int != 0)
        && !bfd_hide_sym_by_version((*(*eif).info).version_info, (*h).root.root.string)
    {
        if !bfd_elf_link_record_dynamic_symbol((*eif).info, h) {
            (*eif).failed = 1 as libc::c_int != 0;
            return 0 as libc::c_int != 0;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_link_find_version_dependencies(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut rinfo: *mut elf_find_verdep_info = data as *mut elf_find_verdep_info;
    let mut t: *mut Elf_Internal_Verneed = 0 as *mut Elf_Internal_Verneed;
    let mut a: *mut Elf_Internal_Vernaux = 0 as *mut Elf_Internal_Vernaux;
    let mut amt: size_t = 0;
    if (*h).def_dynamic() == 0 || (*h).def_regular() as libc::c_int != 0
        || (*h).dynindx == -(1 as libc::c_int) as libc::c_long
        || ((*h).verinfo.verdef).is_null()
        || (*(*(*(*h).verinfo.verdef).vd_bfd).tdata.elf_obj_data).dyn_lib_class()
            as libc::c_int
            & (DYN_AS_NEEDED as libc::c_int | DYN_DT_NEEDED as libc::c_int
                | DYN_NO_NEEDED as libc::c_int) != 0
    {
        return 1 as libc::c_int != 0;
    }
    t = (*(*(*(*rinfo).info).output_bfd).tdata.elf_obj_data).verref;
    while !t.is_null() {
        if (*t).vn_bfd != (*(*h).verinfo.verdef).vd_bfd {
            t = (*t).vn_nextref;
        } else {
            a = (*t).vn_auxptr;
            while !a.is_null() {
                if (*a).vna_nodename == (*(*h).verinfo.verdef).vd_nodename {
                    return 1 as libc::c_int != 0;
                }
                a = (*a).vna_nextptr;
            }
            break;
        }
    }
    if t.is_null() {
        amt = ::core::mem::size_of::<Elf_Internal_Verneed>() as libc::c_ulong;
        t = bfd_zalloc((*(*rinfo).info).output_bfd, amt) as *mut Elf_Internal_Verneed;
        if t.is_null() {
            (*rinfo).failed = 1 as libc::c_int != 0;
            return 0 as libc::c_int != 0;
        }
        (*t).vn_bfd = (*(*h).verinfo.verdef).vd_bfd;
        (*t).vn_nextref = (*(*(*(*rinfo).info).output_bfd).tdata.elf_obj_data).verref;
        (*(*(*(*rinfo).info).output_bfd).tdata.elf_obj_data).verref = t;
    }
    amt = ::core::mem::size_of::<Elf_Internal_Vernaux>() as libc::c_ulong;
    a = bfd_zalloc((*(*rinfo).info).output_bfd, amt) as *mut Elf_Internal_Vernaux;
    if a.is_null() {
        (*rinfo).failed = 1 as libc::c_int != 0;
        return 0 as libc::c_int != 0;
    }
    (*a).vna_nodename = (*(*h).verinfo.verdef).vd_nodename;
    (*a).vna_flags = (*(*h).verinfo.verdef).vd_flags;
    (*a).vna_nextptr = (*t).vn_auxptr;
    (*(*h).verinfo.verdef).vd_exp_refno = (*rinfo).vers;
    (*rinfo).vers = ((*rinfo).vers).wrapping_add(1);
    (*rinfo).vers;
    (*a)
        .vna_other = ((*(*h).verinfo.verdef).vd_exp_refno)
        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ushort;
    (*t).vn_auxptr = a;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_link_hide_versioned_symbol(
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
    mut version_p: *const libc::c_char,
    mut t_p: *mut *mut bfd_elf_version_tree,
    mut hide: *mut bool,
) -> bool {
    let mut t: *mut bfd_elf_version_tree = 0 as *mut bfd_elf_version_tree;
    t = (*info).version_info;
    while !t.is_null() {
        if strcmp((*t).name, version_p) == 0 as libc::c_int {
            let mut len: size_t = 0;
            let mut alc: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut d: *mut bfd_elf_version_expr = 0 as *mut bfd_elf_version_expr;
            len = version_p.offset_from((*h).root.root.string) as libc::c_long as size_t;
            alc = bfd_malloc(len) as *mut libc::c_char;
            if alc.is_null() {
                return 0 as libc::c_int != 0;
            }
            memcpy(
                alc as *mut libc::c_void,
                (*h).root.root.string as *const libc::c_void,
                len.wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            *alc
                .offset(
                    len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                ) = '\0' as i32 as libc::c_char;
            if *alc.offset(len.wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize)
                as libc::c_int == '@' as i32
            {
                *alc
                    .offset(
                        len.wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize,
                    ) = '\0' as i32 as libc::c_char;
            }
            (*h).verinfo.vertree = t;
            (*t).used = 1 as libc::c_int;
            d = 0 as *mut bfd_elf_version_expr;
            if !((*t).globals.list).is_null() {
                d = (Some(((*t).match_0).expect("non-null function pointer")))
                    .expect(
                        "non-null function pointer",
                    )(&mut (*t).globals, 0 as *mut bfd_elf_version_expr, alc);
            }
            if d.is_null() && !((*t).locals.list).is_null() {
                d = (Some(((*t).match_0).expect("non-null function pointer")))
                    .expect(
                        "non-null function pointer",
                    )(&mut (*t).locals, 0 as *mut bfd_elf_version_expr, alc);
                if !d.is_null() && (*h).dynindx != -(1 as libc::c_int) as libc::c_long
                    && (*info).export_dynamic() == 0
                {
                    *hide = 1 as libc::c_int != 0;
                }
            }
            free(alc as *mut libc::c_void);
            break;
        } else {
            t = (*t).next;
        }
    }
    *t_p = t;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hide_sym_by_version(
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
) -> bool {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut hide: bool = 0 as libc::c_int != 0;
    let mut bed: *const elf_backend_data = (*(*(*info).output_bfd).xvec).backend_data
        as *const elf_backend_data;
    if (*h).def_regular() == 0
        && !((*h).def_regular() == 0 && (*h).def_dynamic() == 0
            && ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defined as libc::c_int)
    {
        return 1 as libc::c_int != 0;
    }
    p = strchr((*h).root.root.string, '@' as i32);
    if !p.is_null() && ((*h).verinfo.vertree).is_null() {
        let mut t: *mut bfd_elf_version_tree = 0 as *mut bfd_elf_version_tree;
        p = p.offset(1);
        p;
        if *p as libc::c_int == '@' as i32 {
            p = p.offset(1);
            p;
        }
        if *p as libc::c_int != '\0' as i32
            && _bfd_elf_link_hide_versioned_symbol(info, h, p, &mut t, &mut hide)
                as libc::c_int != 0 && hide as libc::c_int != 0
        {
            if hide {
                (Some(
                    ((*bed).elf_backend_hide_symbol).expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
            }
            return 1 as libc::c_int != 0;
        }
    }
    if ((*h).verinfo.vertree).is_null() && !((*info).version_info).is_null() {
        (*h)
            .verinfo
            .vertree = bfd_find_version_for_sym(
            (*info).version_info,
            (*h).root.root.string,
            &mut hide,
        );
        if !((*h).verinfo.vertree).is_null() && hide as libc::c_int != 0 {
            (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
                .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
            return 1 as libc::c_int != 0;
        }
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_link_assign_sym_version(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut sinfo: *mut elf_info_failed = 0 as *mut elf_info_failed;
    let mut info: *mut bfd_link_info = 0 as *mut bfd_link_info;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut eif: elf_info_failed = elf_info_failed {
        info: 0 as *mut bfd_link_info,
        failed: false,
    };
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut hide: bool = false;
    sinfo = data as *mut elf_info_failed;
    info = (*sinfo).info;
    eif.failed = 0 as libc::c_int != 0;
    eif.info = info;
    if !_bfd_elf_fix_symbol_flags(h, &mut eif) {
        if eif.failed {
            (*sinfo).failed = 1 as libc::c_int != 0;
        }
        return 0 as libc::c_int != 0;
    }
    bed = (*(*(*info).output_bfd).xvec).backend_data as *const elf_backend_data;
    if (*h).def_regular() == 0
        && !((*h).def_regular() == 0 && (*h).def_dynamic() == 0
            && ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defined as libc::c_int)
    {
        if (((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int)
            && discarded_section((*h).root.u.def.section) as libc::c_int != 0
        {
            (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
                .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
        }
        return 1 as libc::c_int != 0;
    }
    hide = 0 as libc::c_int != 0;
    p = strchr((*h).root.root.string, '@' as i32);
    if !p.is_null() && ((*h).verinfo.vertree).is_null() {
        let mut t: *mut bfd_elf_version_tree = 0 as *mut bfd_elf_version_tree;
        p = p.offset(1);
        p;
        if *p as libc::c_int == '@' as i32 {
            p = p.offset(1);
            p;
        }
        if *p as libc::c_int == '\0' as i32 {
            return 1 as libc::c_int != 0;
        }
        if !_bfd_elf_link_hide_versioned_symbol(info, h, p, &mut t, &mut hide) {
            (*sinfo).failed = 1 as libc::c_int != 0;
            return 0 as libc::c_int != 0;
        }
        if hide {
            (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
                .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
        }
        if t.is_null()
            && ((*info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
        {
            let mut pp: *mut *mut bfd_elf_version_tree = 0
                as *mut *mut bfd_elf_version_tree;
            let mut version_index: libc::c_int = 0;
            if (*h).dynindx == -(1 as libc::c_int) as libc::c_long {
                return 1 as libc::c_int != 0;
            }
            t = bfd_zalloc(
                (*info).output_bfd,
                ::core::mem::size_of::<bfd_elf_version_tree>() as libc::c_ulong,
            ) as *mut bfd_elf_version_tree;
            if t.is_null() {
                (*sinfo).failed = 1 as libc::c_int != 0;
                return 0 as libc::c_int != 0;
            }
            (*t).name = p;
            (*t).name_indx = -(1 as libc::c_int) as libc::c_uint;
            (*t).used = 1 as libc::c_int;
            version_index = 1 as libc::c_int;
            if !((*(*sinfo).info).version_info).is_null()
                && (*(*(*sinfo).info).version_info).vernum
                    == 0 as libc::c_int as libc::c_uint
            {
                version_index = 0 as libc::c_int;
            }
            pp = &mut (*(*sinfo).info).version_info;
            while !(*pp).is_null() {
                version_index += 1;
                version_index;
                pp = &mut (**pp).next;
            }
            (*t).vernum = version_index as libc::c_uint;
            *pp = t;
            (*h).verinfo.vertree = t;
        } else if t.is_null() {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: version node not found for symbol %s\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*info).output_bfd,
                (*h).root.root.string,
            );
            bfd_set_error(bfd_error_bad_value);
            (*sinfo).failed = 1 as libc::c_int != 0;
            return 0 as libc::c_int != 0;
        }
    }
    if !hide && ((*h).verinfo.vertree).is_null()
        && !((*(*sinfo).info).version_info).is_null()
    {
        (*h)
            .verinfo
            .vertree = bfd_find_version_for_sym(
            (*(*sinfo).info).version_info,
            (*h).root.root.string,
            &mut hide,
        );
        if !((*h).verinfo.vertree).is_null() && hide as libc::c_int != 0 {
            (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
                .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_link_read_relocs_from_section(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut shdr: *mut Elf_Internal_Shdr,
    mut external_relocs: *mut libc::c_void,
    mut internal_relocs: *mut Elf_Internal_Rela,
) -> bool {
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut swap_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    > = None;
    let mut erela: *const bfd_byte = 0 as *const bfd_byte;
    let mut erelaend: *const bfd_byte = 0 as *const bfd_byte;
    let mut irela: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut nsyms: size_t = 0;
    if bfd_seek(abfd, (*shdr).sh_offset, 0 as libc::c_int) != 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    if bfd_bread(external_relocs, (*shdr).sh_size, abfd) != (*shdr).sh_size {
        return 0 as libc::c_int != 0;
    }
    symtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    nsyms = if (*symtab_hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
        ((*symtab_hdr).sh_size).wrapping_div((*symtab_hdr).sh_entsize)
    } else {
        0 as libc::c_int as libc::c_ulong
    };
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if (*shdr).sh_entsize == (*(*bed).s).sizeof_rel as libc::c_ulong {
        swap_in = (*(*bed).s).swap_reloc_in;
    } else if (*shdr).sh_entsize == (*(*bed).s).sizeof_rela as libc::c_ulong {
        swap_in = (*(*bed).s).swap_reloca_in;
    } else {
        bfd_set_error(bfd_error_wrong_format);
        return 0 as libc::c_int != 0;
    }
    erela = external_relocs as *const bfd_byte;
    erelaend = erela
        .offset((*shdr).sh_size as isize)
        .offset(-((*shdr).sh_entsize as isize));
    irela = internal_relocs;
    while erela <= erelaend {
        let mut r_symndx: bfd_vma = 0;
        (Some(swap_in.expect("non-null function pointer")))
            .expect("non-null function pointer")(abfd, erela, irela);
        r_symndx = (*irela).r_info >> 8 as libc::c_int;
        if (*(*bed).s).arch_size as libc::c_int == 64 as libc::c_int {
            r_symndx >>= 24 as libc::c_int;
        }
        if nsyms > 0 as libc::c_int as libc::c_ulong {
            if r_symndx >= nsyms {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB: bad reloc symbol index (%#lx >= %#lx) for offset %#lx in section `%pA'\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abfd,
                    r_symndx,
                    nsyms,
                    (*irela).r_offset,
                    sec,
                );
                bfd_set_error(bfd_error_bad_value);
                return 0 as libc::c_int != 0;
            }
        } else if r_symndx != 0 as libc::c_int as libc::c_ulong {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: non-zero symbol index (%#lx) for offset %#lx in section `%pA' when the object file has no symbol table\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                r_symndx,
                (*irela).r_offset,
                sec,
            );
            bfd_set_error(bfd_error_bad_value);
            return 0 as libc::c_int != 0;
        }
        irela = irela.offset((*(*bed).s).int_rels_per_ext_rel as libc::c_int as isize);
        erela = erela.offset((*shdr).sh_entsize as isize);
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_read_relocs(
    mut abfd: *mut bfd,
    mut o: *mut asection,
    mut external_relocs: *mut libc::c_void,
    mut internal_relocs: *mut Elf_Internal_Rela,
    mut keep_memory: bool,
) -> *mut Elf_Internal_Rela {
    let mut current_block: u64;
    let mut alloc1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut alloc2: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut esdo: *mut bfd_elf_section_data = (*o).used_by_bfd
        as *mut bfd_elf_section_data;
    let mut internal_rela_relocs: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    if !((*esdo).relocs).is_null() {
        return (*esdo).relocs;
    }
    if (*o).reloc_count == 0 as libc::c_int as libc::c_uint {
        return 0 as *mut Elf_Internal_Rela;
    }
    if internal_relocs.is_null() {
        let mut size: bfd_size_type = 0;
        size = ((*o).reloc_count as bfd_size_type)
            .wrapping_mul(::core::mem::size_of::<Elf_Internal_Rela>() as libc::c_ulong);
        if keep_memory {
            alloc2 = bfd_alloc(abfd, size) as *mut Elf_Internal_Rela;
            internal_relocs = alloc2;
        } else {
            alloc2 = bfd_malloc(size) as *mut Elf_Internal_Rela;
            internal_relocs = alloc2;
        }
        if internal_relocs.is_null() {
            current_block = 6339520365281250770;
        } else {
            current_block = 13109137661213826276;
        }
    } else {
        current_block = 13109137661213826276;
    }
    match current_block {
        13109137661213826276 => {
            if external_relocs.is_null() {
                let mut size_0: bfd_size_type = 0 as libc::c_int as bfd_size_type;
                if !((*esdo).rel.hdr).is_null() {
                    size_0 = (size_0 as libc::c_ulong)
                        .wrapping_add((*(*esdo).rel.hdr).sh_size) as bfd_size_type
                        as bfd_size_type;
                }
                if !((*esdo).rela.hdr).is_null() {
                    size_0 = (size_0 as libc::c_ulong)
                        .wrapping_add((*(*esdo).rela.hdr).sh_size) as bfd_size_type
                        as bfd_size_type;
                }
                alloc1 = bfd_malloc(size_0);
                if alloc1.is_null() {
                    current_block = 6339520365281250770;
                } else {
                    external_relocs = alloc1;
                    current_block = 17833034027772472439;
                }
            } else {
                current_block = 17833034027772472439;
            }
            match current_block {
                6339520365281250770 => {}
                _ => {
                    internal_rela_relocs = internal_relocs;
                    if !((*esdo).rel.hdr).is_null() {
                        if !elf_link_read_relocs_from_section(
                            abfd,
                            o,
                            (*esdo).rel.hdr,
                            external_relocs,
                            internal_relocs,
                        ) {
                            current_block = 6339520365281250770;
                        } else {
                            external_relocs = (external_relocs as *mut bfd_byte)
                                .offset((*(*esdo).rel.hdr).sh_size as isize)
                                as *mut libc::c_void;
                            internal_rela_relocs = internal_rela_relocs
                                .offset(
                                    (if (*(*esdo).rel.hdr).sh_entsize
                                        > 0 as libc::c_int as libc::c_ulong
                                    {
                                        ((*(*esdo).rel.hdr).sh_size)
                                            .wrapping_div((*(*esdo).rel.hdr).sh_entsize)
                                    } else {
                                        0 as libc::c_int as libc::c_ulong
                                    })
                                        .wrapping_mul(
                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                        ) as isize,
                                );
                            current_block = 5783071609795492627;
                        }
                    } else {
                        current_block = 5783071609795492627;
                    }
                    match current_block {
                        6339520365281250770 => {}
                        _ => {
                            if !(!((*esdo).rela.hdr).is_null()
                                && !elf_link_read_relocs_from_section(
                                    abfd,
                                    o,
                                    (*esdo).rela.hdr,
                                    external_relocs,
                                    internal_rela_relocs,
                                ))
                            {
                                if keep_memory {
                                    (*esdo).relocs = internal_relocs;
                                }
                                free(alloc1);
                                return internal_relocs;
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    free(alloc1);
    if !alloc2.is_null() {
        if keep_memory {
            bfd_release(abfd, alloc2 as *mut libc::c_void);
        } else {
            free(alloc2 as *mut libc::c_void);
        }
    }
    return 0 as *mut Elf_Internal_Rela;
}
unsafe extern "C" fn _bfd_elf_link_size_reloc_section(
    mut abfd: *mut bfd,
    mut reldata: *mut bfd_elf_section_reloc_data,
) -> bool {
    let mut rel_hdr: *mut Elf_Internal_Shdr = (*reldata).hdr;
    (*rel_hdr)
        .sh_size = ((*rel_hdr).sh_entsize)
        .wrapping_mul((*reldata).count as libc::c_ulong);
    (*rel_hdr).contents = bfd_zalloc(abfd, (*rel_hdr).sh_size) as *mut libc::c_uchar;
    if ((*rel_hdr).contents).is_null()
        && (*rel_hdr).sh_size != 0 as libc::c_int as libc::c_ulong
    {
        return 0 as libc::c_int != 0;
    }
    if ((*reldata).hashes).is_null() && (*reldata).count != 0 {
        let mut p: *mut *mut elf_link_hash_entry = 0 as *mut *mut elf_link_hash_entry;
        p = bfd_zmalloc(
            ((*reldata).count as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut elf_link_hash_entry>() as libc::c_ulong,
                ),
        ) as *mut *mut elf_link_hash_entry;
        if p.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*reldata).hashes = p;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_output_relocs(
    mut output_bfd: *mut bfd,
    mut input_section: *mut asection,
    mut input_rel_hdr: *mut Elf_Internal_Shdr,
    mut internal_relocs: *mut Elf_Internal_Rela,
    mut _rel_hash: *mut *mut elf_link_hash_entry,
) -> bool {
    let mut irela: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut irelaend: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut erel: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut output_reldata: *mut bfd_elf_section_reloc_data = 0
        as *mut bfd_elf_section_reloc_data;
    let mut output_section: *mut asection = 0 as *mut asection;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut swap_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    > = None;
    let mut esdo: *mut bfd_elf_section_data = 0 as *mut bfd_elf_section_data;
    output_section = (*input_section).output_section;
    bed = (*(*output_bfd).xvec).backend_data as *const elf_backend_data;
    esdo = (*output_section).used_by_bfd as *mut bfd_elf_section_data;
    if !((*esdo).rel.hdr).is_null()
        && (*(*esdo).rel.hdr).sh_entsize == (*input_rel_hdr).sh_entsize
    {
        output_reldata = &mut (*esdo).rel;
        swap_out = (*(*bed).s).swap_reloc_out;
    } else if !((*esdo).rela.hdr).is_null()
        && (*(*esdo).rela.hdr).sh_entsize == (*input_rel_hdr).sh_entsize
    {
        output_reldata = &mut (*esdo).rela;
        swap_out = (*(*bed).s).swap_reloca_out;
    } else {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: relocation size mismatch in %pB section %pA\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            output_bfd,
            (*input_section).owner,
            input_section,
        );
        bfd_set_error(bfd_error_wrong_format);
        return 0 as libc::c_int != 0;
    }
    erel = (*(*output_reldata).hdr).contents;
    erel = erel
        .offset(
            ((*output_reldata).count as libc::c_ulong)
                .wrapping_mul((*input_rel_hdr).sh_entsize) as isize,
        );
    irela = internal_relocs;
    irelaend = irela
        .offset(
            (if (*input_rel_hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                ((*input_rel_hdr).sh_size).wrapping_div((*input_rel_hdr).sh_entsize)
            } else {
                0 as libc::c_int as libc::c_ulong
            })
                .wrapping_mul((*(*bed).s).int_rels_per_ext_rel as libc::c_ulong) as isize,
        );
    while irela < irelaend {
        (Some(swap_out.expect("non-null function pointer")))
            .expect("non-null function pointer")(output_bfd, irela, erel);
        irela = irela.offset((*(*bed).s).int_rels_per_ext_rel as libc::c_int as isize);
        erel = erel.offset((*input_rel_hdr).sh_entsize as isize);
    }
    (*output_reldata)
        .count = ((*output_reldata).count as libc::c_ulong)
        .wrapping_add(
            if (*input_rel_hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                ((*input_rel_hdr).sh_size).wrapping_div((*input_rel_hdr).sh_entsize)
            } else {
                0 as libc::c_int as libc::c_ulong
            },
        ) as libc::c_uint as libc::c_uint;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hash_fixup_symbol(
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
) -> bool {
    if (*info).type_0() as libc::c_int == type_pie as libc::c_int
        && (*h).dynindx == -(1 as libc::c_int) as libc::c_long
        && ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefweak as libc::c_int
    {
        return bfd_elf_link_record_dynamic_symbol(info, h);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_fix_symbol_flags(
    mut h: *mut elf_link_hash_entry,
    mut eif: *mut elf_info_failed,
) -> bool {
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    if (*h).non_elf() != 0 {
        while ((*h).root).type_0() as libc::c_int
            == bfd_link_hash_indirect as libc::c_int
        {
            h = (*h).root.u.i.link as *mut elf_link_hash_entry;
        }
        if ((*h).root).type_0() as libc::c_int != bfd_link_hash_defined as libc::c_int
            && ((*h).root).type_0() as libc::c_int
                != bfd_link_hash_defweak as libc::c_int
        {
            (*h).set_ref_regular(1 as libc::c_int as libc::c_uint);
            (*h).set_ref_regular_nonweak(1 as libc::c_int as libc::c_uint);
        } else if !((*(*h).root.u.def.section).owner).is_null()
            && bfd_get_flavour((*(*h).root.u.def.section).owner) as libc::c_uint
                == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        {
            (*h).set_ref_regular(1 as libc::c_int as libc::c_uint);
            (*h).set_ref_regular_nonweak(1 as libc::c_int as libc::c_uint);
        } else {
            (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
        }
        if (*h).dynindx == -(1 as libc::c_int) as libc::c_long
            && ((*h).def_dynamic() as libc::c_int != 0
                || (*h).ref_dynamic() as libc::c_int != 0)
        {
            if !bfd_elf_link_record_dynamic_symbol((*eif).info, h) {
                (*eif).failed = 1 as libc::c_int != 0;
                return 0 as libc::c_int != 0;
            }
        }
    } else if (((*h).root).type_0() as libc::c_int
        == bfd_link_hash_defined as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_defweak as libc::c_int)
        && (*h).def_regular() == 0
        && (if !((*(*h).root.u.def.section).owner).is_null() {
            (bfd_get_flavour((*(*h).root.u.def.section).owner) as libc::c_uint
                != bfd_target_elf_flavour as libc::c_int as libc::c_uint) as libc::c_int
        } else {
            (bfd_is_abs_section((*h).root.u.def.section) as libc::c_int != 0
                && (*h).def_dynamic() == 0) as libc::c_int
        }) != 0
    {
        (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
    }
    bed = (*(*(*elf_hash_table((*eif).info)).dynobj).xvec).backend_data
        as *const elf_backend_data;
    if ((*bed).elf_backend_fixup_symbol).is_some()
        && !(Some(((*bed).elf_backend_fixup_symbol).expect("non-null function pointer")))
            .expect("non-null function pointer")((*eif).info, h)
    {
        return 0 as libc::c_int != 0;
    }
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
        && (*h).def_regular() == 0 && (*h).ref_regular() as libc::c_int != 0
        && (*h).def_dynamic() == 0
        && (*(*(*h).root.u.def.section).owner).flags
            & (0x40 as libc::c_int | 0x10000 as libc::c_int) as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
    {
        (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
    }
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefined as libc::c_int
        && (*h).indx == -(3 as libc::c_int) as libc::c_long
    {
        (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
            .expect("non-null function pointer")((*eif).info, h, 1 as libc::c_int != 0);
    } else if (*h).other() as libc::c_int & 0x3 as libc::c_int != 0 as libc::c_int
        && ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefweak as libc::c_int
    {
        (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
            .expect("non-null function pointer")((*eif).info, h, 1 as libc::c_int != 0);
    } else if ((*(*eif).info).type_0() as libc::c_int == type_pde as libc::c_int
        || (*(*eif).info).type_0() as libc::c_int == type_pie as libc::c_int)
        && (*h).versioned() as libc::c_int == versioned_hidden as libc::c_int
        && (*(*eif).info).export_dynamic() == 0 && (*h).dynamic() == 0
        && (*h).ref_dynamic() == 0 && (*h).def_regular() as libc::c_int != 0
    {
        (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
            .expect("non-null function pointer")((*eif).info, h, 1 as libc::c_int != 0);
    } else if (*h).needs_plt() as libc::c_int != 0
        && ((*(*eif).info).type_0() as libc::c_int == type_dll as libc::c_int
            || (*(*eif).info).type_0() as libc::c_int == type_pie as libc::c_int)
        && is_elf_hash_table((*(*eif).info).hash) as libc::c_int != 0
        && ((*h).unique_global() == 0
            && ((*(*eif).info).symbolic() as libc::c_int != 0
                || (*h).start_stop() as libc::c_int != 0
                || (*(*eif).info).dynamic() as libc::c_int != 0 && (*h).dynamic() == 0)
            || (*h).other() as libc::c_int & 0x3 as libc::c_int != 0 as libc::c_int)
        && (*h).def_regular() as libc::c_int != 0
    {
        let mut force_local: bool = false;
        force_local = (*h).other() as libc::c_int & 0x3 as libc::c_int
            == 1 as libc::c_int
            || (*h).other() as libc::c_int & 0x3 as libc::c_int == 2 as libc::c_int;
        (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
            .expect("non-null function pointer")((*eif).info, h, force_local);
    }
    if (*h).is_weakalias() != 0 {
        let mut def: *mut elf_link_hash_entry = weakdef(h);
        if (*def).def_regular() as libc::c_int != 0
            || ((*def).root).type_0() as libc::c_int
                != bfd_link_hash_defined as libc::c_int
        {
            h = def;
            loop {
                h = (*h).u.alias;
                if !(h != def) {
                    break;
                }
                (*h).set_is_weakalias(0 as libc::c_int as libc::c_uint);
            }
        } else {
            while ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_indirect as libc::c_int
            {
                h = (*h).root.u.i.link as *mut elf_link_hash_entry;
            }
            if !(((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defined as libc::c_int
                || ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_defweak as libc::c_int)
            {
                bfd_assert(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    2985 as libc::c_int,
                );
            }
            if (*def).def_dynamic() == 0 {
                bfd_assert(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    2986 as libc::c_int,
                );
            }
            (Some(
                ((*bed).elf_backend_copy_indirect_symbol)
                    .expect("non-null function pointer"),
            ))
                .expect("non-null function pointer")((*eif).info, def, h);
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_adjust_dynamic_symbol(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut eif: *mut elf_info_failed = data as *mut elf_info_failed;
    let mut htab: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    if !is_elf_hash_table((*(*eif).info).hash) {
        return 0 as libc::c_int != 0;
    }
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int {
        return 1 as libc::c_int != 0;
    }
    if !_bfd_elf_fix_symbol_flags(h, eif) {
        return 0 as libc::c_int != 0;
    }
    htab = elf_hash_table((*eif).info);
    bed = (*(*(*htab).dynobj).xvec).backend_data as *const elf_backend_data;
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefweak as libc::c_int {
        if (*(*eif).info).dynamic_undefined_weak == 0 as libc::c_int {
            (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
                .expect(
                    "non-null function pointer",
                )((*eif).info, h, 1 as libc::c_int != 0);
        } else if (*(*eif).info).dynamic_undefined_weak > 0 as libc::c_int
            && (*h).ref_regular() as libc::c_int != 0
            && (*h).other() as libc::c_int & 0x3 as libc::c_int == 0 as libc::c_int
            && !bfd_hide_sym_by_version(
                (*(*eif).info).version_info,
                (*h).root.root.string,
            )
        {
            if !bfd_elf_link_record_dynamic_symbol((*eif).info, h) {
                (*eif).failed = 1 as libc::c_int != 0;
                return 0 as libc::c_int != 0;
            }
        }
    }
    if (*h).needs_plt() == 0 && (*h).type_0() as libc::c_int != 10 as libc::c_int
        && ((*h).def_regular() as libc::c_int != 0 || (*h).def_dynamic() == 0
            || (*h).ref_regular() == 0
                && ((*h).is_weakalias() == 0
                    || (*weakdef(h)).dynindx == -(1 as libc::c_int) as libc::c_long))
    {
        (*h).plt = (*elf_hash_table((*eif).info)).init_plt_offset;
        return 1 as libc::c_int != 0;
    }
    if (*h).dynamic_adjusted() != 0 {
        return 1 as libc::c_int != 0;
    }
    (*h).set_dynamic_adjusted(1 as libc::c_int as libc::c_uint);
    if (*h).is_weakalias() != 0 {
        let mut def: *mut elf_link_hash_entry = weakdef(h);
        (*def).set_ref_regular(1 as libc::c_int as libc::c_uint);
        if !_bfd_elf_adjust_dynamic_symbol(def, eif as *mut libc::c_void) {
            return 0 as libc::c_int != 0;
        }
    }
    if (*h).size == 0 as libc::c_int as libc::c_ulong
        && (*h).type_0() as libc::c_int == 0 as libc::c_int && (*h).needs_plt() == 0
    {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"warning: type and size of dynamic symbol `%s' are not defined\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*h).root.root.string,
        );
    }
    if !(Some(
        ((*bed).elf_backend_adjust_dynamic_symbol).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")((*eif).info, h)
    {
        (*eif).failed = 1 as libc::c_int != 0;
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_adjust_dynamic_copy(
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
    mut dynbss: *mut asection,
) -> bool {
    let mut power_of_two: libc::c_uint = 0;
    let mut mask: bfd_vma = 0;
    let mut sec: *mut asection = (*h).root.u.def.section;
    power_of_two = bfd_section_alignment(sec);
    mask = ((1 as libc::c_int as bfd_vma) << power_of_two)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong);
    while (*h).root.u.def.value & mask != 0 as libc::c_int as libc::c_ulong {
        mask >>= 1 as libc::c_int;
        power_of_two = power_of_two.wrapping_sub(1);
        power_of_two;
    }
    if power_of_two > bfd_section_alignment(dynbss) {
        if !bfd_set_section_alignment(dynbss, power_of_two) {
            return 0 as libc::c_int != 0;
        }
    }
    (*dynbss)
        .size = if ((*dynbss).size)
        .wrapping_add(mask.wrapping_add(1 as libc::c_int as libc::c_ulong))
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) >= (*dynbss).size
    {
        ((*dynbss).size)
            .wrapping_add(
                mask
                    .wrapping_add(1 as libc::c_int as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            )
            & !mask
                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
    } else {
        !(0 as libc::c_int as bfd_vma)
    };
    (*h).root.u.def.section = dynbss;
    (*h).root.u.def.value = (*dynbss).size;
    (*dynbss)
        .size = ((*dynbss).size as libc::c_ulong).wrapping_add((*h).size)
        as bfd_size_type as bfd_size_type;
    if (*h).protected_def() as libc::c_int != 0
        && ((*info).extern_protected_data == 0
            || (*info).extern_protected_data < 0 as libc::c_int
                && (*((*(*(*dynbss).owner).xvec).backend_data
                    as *const elf_backend_data))
                    .extern_protected_data() == 0)
    {
        ((*(*info).callbacks).einfo)
            .expect(
                "non-null function pointer",
            )(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%P: copy reloc against protected `%pT' is dangerous\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*h).root.root.string,
        );
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_link_sec_merge_syms(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut sec: *mut asection = 0 as *mut asection;
    if (((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_defweak as libc::c_int)
        && {
            sec = (*h).root.u.def.section;
            (*sec).flags & 0x800000 as libc::c_int as libc::c_uint != 0
        } && (*sec).sec_info_type() as libc::c_int == 2 as libc::c_int
    {
        let mut output_bfd: *mut bfd = data as *mut bfd;
        (*h)
            .root
            .u
            .def
            .value = _bfd_merged_section_offset(
            output_bfd,
            &mut (*h).root.u.def.section,
            (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).sec_info,
            (*h).root.u.def.value,
        );
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_dynamic_symbol_p(
    mut h: *mut elf_link_hash_entry,
    mut info: *mut bfd_link_info,
    mut not_local_protected: bool,
) -> bool {
    let mut binding_stays_local_p: bool = false;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut hash_table: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    if h.is_null() {
        return 0 as libc::c_int != 0;
    }
    while ((*h).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_warning as libc::c_int
    {
        h = (*h).root.u.i.link as *mut elf_link_hash_entry;
    }
    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long {
        return 0 as libc::c_int != 0;
    }
    if (*h).forced_local() != 0 {
        return 0 as libc::c_int != 0;
    }
    binding_stays_local_p = (*info).type_0() as libc::c_int == type_pde as libc::c_int
        || (*info).type_0() as libc::c_int == type_pie as libc::c_int
        || (*h).unique_global() == 0
            && ((*info).symbolic() as libc::c_int != 0
                || (*h).start_stop() as libc::c_int != 0
                || (*info).dynamic() as libc::c_int != 0 && (*h).dynamic() == 0);
    match (*h).other() as libc::c_int & 0x3 as libc::c_int {
        1 | 2 => return 0 as libc::c_int != 0,
        3 => {
            hash_table = elf_hash_table(info);
            if !is_elf_hash_table(&mut (*hash_table).root) {
                return 0 as libc::c_int != 0;
            }
            bed = (*(*(*hash_table).dynobj).xvec).backend_data
                as *const elf_backend_data;
            if !not_local_protected
                || !((*bed).is_function_type)
                    .expect("non-null function pointer")((*h).type_0())
            {
                binding_stays_local_p = 1 as libc::c_int != 0;
            }
        }
        _ => {}
    }
    if (*h).def_regular() == 0
        && !((*h).def_regular() == 0 && (*h).def_dynamic() == 0
            && ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defined as libc::c_int)
    {
        return 1 as libc::c_int != 0;
    }
    return !binding_stays_local_p;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_symbol_refs_local_p(
    mut h: *mut elf_link_hash_entry,
    mut info: *mut bfd_link_info,
    mut local_protected: bool,
) -> bool {
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut hash_table: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    if h.is_null() {
        return 1 as libc::c_int != 0;
    }
    if (*h).other() as libc::c_int & 0x3 as libc::c_int == 2 as libc::c_int
        || (*h).other() as libc::c_int & 0x3 as libc::c_int == 1 as libc::c_int
    {
        return 1 as libc::c_int != 0;
    }
    if (*h).forced_local() != 0 {
        return 1 as libc::c_int != 0;
    }
    if !((*h).def_regular() == 0 && (*h).def_dynamic() == 0
        && ((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int)
    {
        if (*h).def_regular() == 0 {
            return 0 as libc::c_int != 0;
        }
    }
    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long {
        return 1 as libc::c_int != 0;
    }
    if (*info).type_0() as libc::c_int == type_pde as libc::c_int
        || (*info).type_0() as libc::c_int == type_pie as libc::c_int
        || (*h).unique_global() == 0
            && ((*info).symbolic() as libc::c_int != 0
                || (*h).start_stop() as libc::c_int != 0
                || (*info).dynamic() as libc::c_int != 0 && (*h).dynamic() == 0)
    {
        return 1 as libc::c_int != 0;
    }
    if (*h).other() as libc::c_int & 0x3 as libc::c_int == 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    hash_table = elf_hash_table(info);
    if !is_elf_hash_table(&mut (*hash_table).root) {
        return 1 as libc::c_int != 0;
    }
    bed = (*(*(*hash_table).dynobj).xvec).backend_data as *const elf_backend_data;
    if ((*info).extern_protected_data == 0
        || (*info).extern_protected_data < 0 as libc::c_int
            && (*bed).extern_protected_data() == 0)
        && !((*bed).is_function_type).expect("non-null function pointer")((*h).type_0())
    {
        return 1 as libc::c_int != 0;
    }
    return local_protected;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_tls_setup(
    mut obfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> *mut bfd_section {
    let mut sec: *mut bfd_section = 0 as *mut bfd_section;
    let mut tls: *mut bfd_section = 0 as *mut bfd_section;
    let mut align: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    sec = (*obfd).sections;
    while !sec.is_null() {
        if (*sec).flags & 0x400 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        {
            break;
        }
        sec = (*sec).next;
    }
    tls = sec;
    while !sec.is_null()
        && (*sec).flags & 0x400 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
    {
        if (*sec).alignment_power > align {
            align = (*sec).alignment_power;
        }
        sec = (*sec).next;
    }
    let ref mut fresh7 = (*elf_hash_table(info)).tls_sec;
    *fresh7 = tls;
    if !tls.is_null() {
        (*tls).alignment_power = align;
    }
    return tls;
}
unsafe extern "C" fn is_global_data_symbol_definition(
    mut abfd: *mut bfd,
    mut sym: *mut Elf_Internal_Sym,
) -> bool {
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    if (*sym).st_info as libc::c_uint >> 4 as libc::c_int
        != 1 as libc::c_int as libc::c_uint
        && ((*sym).st_info as libc::c_uint >> 4 as libc::c_int)
            < 10 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if ((*bed).is_function_type)
        .expect(
            "non-null function pointer",
        )(((*sym).st_info as libc::c_int & 0xf as libc::c_int) as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    if (*sym).st_shndx == 0 as libc::c_int as libc::c_uint {
        return 0 as libc::c_int != 0;
    }
    if ((*bed).common_definition).expect("non-null function pointer")(sym) {
        return 0 as libc::c_int != 0;
    }
    if (*sym).st_shndx >= (0x100 as libc::c_uint).wrapping_neg()
        && (*sym).st_shndx < (0xf as libc::c_uint).wrapping_neg()
    {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_link_is_defined_archive_symbol(
    mut abfd: *mut bfd,
    mut symdef: *mut carsym,
) -> bool {
    let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symcount: size_t = 0;
    let mut extsymcount: size_t = 0;
    let mut extsymoff: size_t = 0;
    let mut isymbuf: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isymend: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut result: bool = false;
    abfd = _bfd_get_elt_at_filepos(abfd, (*symdef).file_offset);
    if abfd.is_null() {
        return 0 as libc::c_int != 0;
    }
    if !bfd_check_format(abfd, bfd_object) {
        return 0 as libc::c_int != 0;
    }
    if (*abfd).plugin_format() as libc::c_int == bfd_plugin_yes as libc::c_int
        || (*abfd).plugin_format() as libc::c_int == bfd_plugin_unknown as libc::c_int
            && bfd_link_plugin_object_p(abfd) as libc::c_int != 0
    {
        abfd = (*abfd).plugin_dummy_bfd;
        hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    } else if (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
            == 0 as libc::c_int as libc::c_uint
    {
        hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    } else {
        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
    }
    symcount = ((*hdr).sh_size)
        .wrapping_div(
            (*(*((*(*abfd).xvec).backend_data as *const elf_backend_data)).s).sizeof_sym
                as libc::c_ulong,
        );
    if (*(*abfd).tdata.elf_obj_data).bad_symtab() != 0 {
        extsymcount = symcount;
        extsymoff = 0 as libc::c_int as size_t;
    } else {
        extsymcount = symcount.wrapping_sub((*hdr).sh_info as libc::c_ulong);
        extsymoff = (*hdr).sh_info as size_t;
    }
    if extsymcount == 0 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    isymbuf = bfd_elf_get_elf_syms(
        abfd,
        hdr,
        extsymcount,
        extsymoff,
        0 as *mut Elf_Internal_Sym,
        0 as *mut libc::c_void,
        0 as *mut Elf_External_Sym_Shndx,
    );
    if isymbuf.is_null() {
        return 0 as libc::c_int != 0;
    }
    result = 0 as libc::c_int != 0;
    isym = isymbuf;
    isymend = isymbuf.offset(extsymcount as isize);
    while isym < isymend {
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        name = bfd_elf_string_from_elf_section(
            abfd,
            (*hdr).sh_link,
            (*isym).st_name as libc::c_uint,
        );
        if name.is_null() {
            break;
        }
        if strcmp(name, (*symdef).name) == 0 as libc::c_int {
            result = is_global_data_symbol_definition(abfd, isym);
            break;
        } else {
            isym = isym.offset(1);
            isym;
        }
    }
    free(isymbuf as *mut libc::c_void);
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_add_dynamic_entry(
    mut info: *mut bfd_link_info,
    mut tag: bfd_vma,
    mut val: bfd_vma,
) -> bool {
    let mut hash_table: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut s: *mut asection = 0 as *mut asection;
    let mut newsize: bfd_size_type = 0;
    let mut newcontents: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut dyn_0: Elf_Internal_Dyn = Elf_Internal_Dyn {
        d_tag: 0,
        d_un: C2RustUnnamed_21 { d_val: 0 },
    };
    hash_table = elf_hash_table(info);
    if !is_elf_hash_table(&mut (*hash_table).root) {
        return 0 as libc::c_int != 0;
    }
    if tag == 7 as libc::c_int as libc::c_ulong
        || tag == 17 as libc::c_int as libc::c_ulong
    {
        (*hash_table).dynamic_relocs = 1 as libc::c_int != 0;
    }
    bed = (*(*(*hash_table).dynobj).xvec).backend_data as *const elf_backend_data;
    s = bfd_get_linker_section(
        (*hash_table).dynobj,
        b".dynamic\0" as *const u8 as *const libc::c_char,
    );
    if s.is_null() {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            3533 as libc::c_int,
        );
    }
    newsize = ((*s).size).wrapping_add((*(*bed).s).sizeof_dyn as libc::c_ulong);
    newcontents = bfd_realloc((*s).contents as *mut libc::c_void, newsize)
        as *mut bfd_byte;
    if newcontents.is_null() {
        return 0 as libc::c_int != 0;
    }
    dyn_0.d_tag = tag;
    dyn_0.d_un.d_val = val;
    ((*(*bed).s).swap_dyn_out)
        .expect(
            "non-null function pointer",
        )(
        (*hash_table).dynobj,
        &mut dyn_0,
        newcontents.offset((*s).size as isize) as *mut libc::c_void,
    );
    (*s).size = newsize;
    (*s).contents = newcontents;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_strip_zero_sized_dynamic_sections(
    mut info: *mut bfd_link_info,
) -> bool {
    let mut hash_table: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut s: *mut asection = 0 as *mut asection;
    let mut sdynamic: *mut asection = 0 as *mut asection;
    let mut pp: *mut *mut asection = 0 as *mut *mut asection;
    let mut rela_dyn: *mut asection = 0 as *mut asection;
    let mut rel_dyn: *mut asection = 0 as *mut asection;
    let mut dyn_0: Elf_Internal_Dyn = Elf_Internal_Dyn {
        d_tag: 0,
        d_un: C2RustUnnamed_21 { d_val: 0 },
    };
    let mut extdyn: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut next: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut swap_dyn_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_void, *mut Elf_Internal_Dyn) -> (),
    > = None;
    let mut strip_zero_sized: bool = false;
    let mut strip_zero_sized_plt: bool = false;
    if (*info).type_0() as libc::c_int == type_relocatable as libc::c_int {
        return 1 as libc::c_int != 0;
    }
    hash_table = elf_hash_table(info);
    if !is_elf_hash_table(&mut (*hash_table).root) {
        return 0 as libc::c_int != 0;
    }
    if ((*hash_table).dynobj).is_null() {
        return 1 as libc::c_int != 0;
    }
    sdynamic = bfd_get_linker_section(
        (*hash_table).dynobj,
        b".dynamic\0" as *const u8 as *const libc::c_char,
    );
    if sdynamic.is_null() {
        return 1 as libc::c_int != 0;
    }
    bed = (*(*(*hash_table).dynobj).xvec).backend_data as *const elf_backend_data;
    swap_dyn_in = (*(*bed).s).swap_dyn_in;
    strip_zero_sized = 0 as libc::c_int != 0;
    strip_zero_sized_plt = 0 as libc::c_int != 0;
    rela_dyn = bfd_get_section_by_name(
        (*info).output_bfd,
        b".rela.dyn\0" as *const u8 as *const libc::c_char,
    );
    rel_dyn = bfd_get_section_by_name(
        (*info).output_bfd,
        b".rel.dyn\0" as *const u8 as *const libc::c_char,
    );
    pp = &mut (*(*info).output_bfd).sections;
    loop {
        s = *pp;
        if s.is_null() {
            break;
        }
        if (*s).size == 0 as libc::c_int as libc::c_ulong
            && (s == rela_dyn || s == rel_dyn
                || s == (*(*hash_table).srelplt).output_section
                || s == (*(*hash_table).splt).output_section)
        {
            *pp = (*s).next;
            (*(*info).output_bfd)
                .section_count = ((*(*info).output_bfd).section_count).wrapping_sub(1);
            (*(*info).output_bfd).section_count;
            strip_zero_sized = 1 as libc::c_int != 0;
            if s == rela_dyn {
                s = rela_dyn;
            }
            if s == rel_dyn {
                s = rel_dyn;
            } else if s == (*(*hash_table).splt).output_section {
                s = (*hash_table).splt;
                strip_zero_sized_plt = 1 as libc::c_int != 0;
            } else {
                s = (*hash_table).srelplt;
            }
            (*s).flags |= 0x8000 as libc::c_int as libc::c_uint;
            (*s)
                .output_section = &mut *_bfd_std_section
                .as_mut_ptr()
                .offset(2 as libc::c_int as isize) as *mut asection;
        } else {
            pp = &mut (*s).next;
        }
    }
    if strip_zero_sized_plt {
        extdyn = (*sdynamic).contents;
        while extdyn < ((*sdynamic).contents).offset((*sdynamic).size as isize) {
            next = extdyn.offset((*(*bed).s).sizeof_dyn as libc::c_int as isize);
            swap_dyn_in
                .expect(
                    "non-null function pointer",
                )((*hash_table).dynobj, extdyn as *const libc::c_void, &mut dyn_0);
            match dyn_0.d_tag {
                23 | 2 | 20 => {
                    memmove(
                        extdyn as *mut libc::c_void,
                        next as *const libc::c_void,
                        ((*sdynamic).size)
                            .wrapping_sub(
                                next.offset_from((*sdynamic).contents) as libc::c_long
                                    as libc::c_ulong,
                            ),
                    );
                    next = extdyn;
                }
                _ => {}
            }
            extdyn = next;
        }
    }
    if strip_zero_sized {
        (*(*(*(*info).output_bfd).tdata.elf_obj_data).o)
            .seg_map = 0 as *mut elf_segment_map;
        return _bfd_elf_map_sections_to_segments((*info).output_bfd, info);
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_add_dt_needed_tag(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> libc::c_int {
    let mut hash_table: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut strindex: size_t = 0;
    let mut soname: *const libc::c_char = 0 as *const libc::c_char;
    if !_bfd_elf_link_create_dynstrtab(abfd, info) {
        return -(1 as libc::c_int);
    }
    hash_table = elf_hash_table(info);
    soname = (*(*abfd).tdata.elf_obj_data).dt_name;
    strindex = _bfd_elf_strtab_add((*hash_table).dynstr, soname, 0 as libc::c_int != 0);
    if strindex == -(1 as libc::c_int) as size_t {
        return -(1 as libc::c_int);
    }
    if _bfd_elf_strtab_refcount((*hash_table).dynstr, strindex)
        != 1 as libc::c_int as libc::c_uint
    {
        let mut sdyn: *mut asection = 0 as *mut asection;
        let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
        let mut extdyn: *mut bfd_byte = 0 as *mut bfd_byte;
        bed = (*(*(*hash_table).dynobj).xvec).backend_data as *const elf_backend_data;
        sdyn = bfd_get_linker_section(
            (*hash_table).dynobj,
            b".dynamic\0" as *const u8 as *const libc::c_char,
        );
        if !sdyn.is_null() {
            extdyn = (*sdyn).contents;
            while extdyn < ((*sdyn).contents).offset((*sdyn).size as isize) {
                let mut dyn_0: Elf_Internal_Dyn = Elf_Internal_Dyn {
                    d_tag: 0,
                    d_un: C2RustUnnamed_21 { d_val: 0 },
                };
                ((*(*bed).s).swap_dyn_in)
                    .expect(
                        "non-null function pointer",
                    )((*hash_table).dynobj, extdyn as *const libc::c_void, &mut dyn_0);
                if dyn_0.d_tag == 1 as libc::c_int as libc::c_ulong
                    && dyn_0.d_un.d_val == strindex
                {
                    _bfd_elf_strtab_delref((*hash_table).dynstr, strindex);
                    return 1 as libc::c_int;
                }
                extdyn = extdyn.offset((*(*bed).s).sizeof_dyn as libc::c_int as isize);
            }
        }
    }
    if !_bfd_elf_link_create_dynamic_sections((*hash_table).dynobj, info) {
        return -(1 as libc::c_int);
    }
    if !_bfd_elf_add_dynamic_entry(info, 1 as libc::c_int as bfd_vma, strindex) {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn on_needed_list(
    mut soname: *const libc::c_char,
    mut needed: *mut bfd_link_needed_list,
    mut stop: *mut bfd_link_needed_list,
) -> bool {
    let mut look: *mut bfd_link_needed_list = 0 as *mut bfd_link_needed_list;
    look = needed;
    while look != stop {
        if strcmp(soname, (*look).name) == 0 as libc::c_int
            && ((*(*(*look).by).tdata.elf_obj_data).dyn_lib_class() as libc::c_int
                & DYN_AS_NEEDED as libc::c_int == 0 as libc::c_int
                || on_needed_list(
                    (*(*(*look).by).tdata.elf_obj_data).dt_name,
                    needed,
                    look,
                ) as libc::c_int != 0)
        {
            return 1 as libc::c_int != 0;
        }
        look = (*look).next;
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn elf_sort_symbol(
    mut arg1: *const libc::c_void,
    mut arg2: *const libc::c_void,
) -> libc::c_int {
    let mut h1: *const elf_link_hash_entry = 0 as *const elf_link_hash_entry;
    let mut h2: *const elf_link_hash_entry = 0 as *const elf_link_hash_entry;
    let mut vdiff: bfd_signed_vma = 0;
    let mut sdiff: libc::c_int = 0;
    let mut n1: *const libc::c_char = 0 as *const libc::c_char;
    let mut n2: *const libc::c_char = 0 as *const libc::c_char;
    h1 = *(arg1 as *mut *const elf_link_hash_entry);
    h2 = *(arg2 as *mut *const elf_link_hash_entry);
    vdiff = ((*h1).root.u.def.value).wrapping_sub((*h2).root.u.def.value)
        as bfd_signed_vma;
    if vdiff != 0 as libc::c_int as libc::c_long {
        return if vdiff > 0 as libc::c_int as libc::c_long {
            1 as libc::c_int
        } else {
            -(1 as libc::c_int)
        };
    }
    sdiff = ((*(*h1).root.u.def.section).id).wrapping_sub((*(*h2).root.u.def.section).id)
        as libc::c_int;
    if sdiff != 0 as libc::c_int {
        return sdiff;
    }
    vdiff = ((*h1).size).wrapping_sub((*h2).size) as bfd_signed_vma;
    if vdiff != 0 as libc::c_int as libc::c_long {
        return if vdiff > 0 as libc::c_int as libc::c_long {
            1 as libc::c_int
        } else {
            -(1 as libc::c_int)
        };
    }
    if (*h1).type_0() as libc::c_int != (*h2).type_0() as libc::c_int {
        return (*h1).type_0() as libc::c_int - (*h2).type_0() as libc::c_int;
    }
    n1 = (*h1).root.root.string;
    n2 = (*h2).root.root.string;
    while *n1 as libc::c_int == *n2 as libc::c_int {
        if *n1 as libc::c_int == 0 as libc::c_int {
            break;
        }
        n1 = n1.offset(1);
        n1;
        n2 = n2.offset(1);
        n2;
    }
    if *n1 as libc::c_int == '_' as i32 {
        return -(1 as libc::c_int);
    }
    if *n2 as libc::c_int == '_' as i32 {
        return 1 as libc::c_int;
    }
    return *n1 as libc::c_int - *n2 as libc::c_int;
}
unsafe extern "C" fn elf_adjust_dynstr_offsets(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut dynstr: *mut elf_strtab_hash = data as *mut elf_strtab_hash;
    if (*h).dynindx != -(1 as libc::c_int) as libc::c_long {
        (*h).dynstr_index = _bfd_elf_strtab_offset(dynstr, (*h).dynstr_index);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_finalize_dynstr(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut hash_table: *mut elf_link_hash_table = elf_hash_table(info);
    let mut entry: *mut elf_link_local_dynamic_entry = 0
        as *mut elf_link_local_dynamic_entry;
    let mut dynstr: *mut elf_strtab_hash = (*hash_table).dynstr;
    let mut dynobj: *mut bfd = (*hash_table).dynobj;
    let mut sdyn: *mut asection = 0 as *mut asection;
    let mut size: bfd_size_type = 0;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut extdyn: *mut bfd_byte = 0 as *mut bfd_byte;
    _bfd_elf_strtab_finalize(dynstr);
    size = _bfd_elf_strtab_size(dynstr);
    if ((*(*info).callbacks).examine_strtab).is_some() {
        ((*(*info).callbacks).examine_strtab)
            .expect("non-null function pointer")(dynstr);
    }
    bed = (*(*dynobj).xvec).backend_data as *const elf_backend_data;
    sdyn = bfd_get_linker_section(
        dynobj,
        b".dynamic\0" as *const u8 as *const libc::c_char,
    );
    if sdyn.is_null() {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            3820 as libc::c_int,
        );
    }
    let mut current_block_14: u64;
    extdyn = (*sdyn).contents;
    while extdyn < ((*sdyn).contents).offset((*sdyn).size as isize) {
        let mut dyn_0: Elf_Internal_Dyn = Elf_Internal_Dyn {
            d_tag: 0,
            d_un: C2RustUnnamed_21 { d_val: 0 },
        };
        ((*(*bed).s).swap_dyn_in)
            .expect(
                "non-null function pointer",
            )(dynobj, extdyn as *const libc::c_void, &mut dyn_0);
        match dyn_0.d_tag {
            10 => {
                dyn_0.d_un.d_val = size;
                current_block_14 = 11584701595673473500;
            }
            1 | 14 | 15 | 29 | 2147483647 | 2147483645 | 1879047932 | 1879047931 => {
                dyn_0.d_un.d_val = _bfd_elf_strtab_offset(dynstr, dyn_0.d_un.d_val);
                current_block_14 = 11584701595673473500;
            }
            _ => {
                current_block_14 = 7746791466490516765;
            }
        }
        match current_block_14 {
            11584701595673473500 => {
                ((*(*bed).s).swap_dyn_out)
                    .expect(
                        "non-null function pointer",
                    )(dynobj, &mut dyn_0, extdyn as *mut libc::c_void);
            }
            _ => {}
        }
        extdyn = extdyn.offset((*(*bed).s).sizeof_dyn as libc::c_int as isize);
    }
    entry = (*hash_table).dynlocal;
    while !entry.is_null() {
        (*entry).isym.st_name = _bfd_elf_strtab_offset(dynstr, (*entry).isym.st_name);
        entry = (*entry).next;
    }
    elf_link_hash_traverse(
        hash_table,
        Some(
            elf_adjust_dynstr_offsets
                as unsafe extern "C" fn(
                    *mut elf_link_hash_entry,
                    *mut libc::c_void,
                ) -> bool,
        ),
        dynstr as *mut libc::c_void,
    );
    if (*(*output_bfd).tdata.elf_obj_data).cverdefs != 0 {
        let mut s: *mut asection = 0 as *mut asection;
        let mut p: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut i: size_t = 0;
        let mut def: Elf_Internal_Verdef = Elf_Internal_Verdef {
            vd_version: 0,
            vd_flags: 0,
            vd_ndx: 0,
            vd_cnt: 0,
            vd_hash: 0,
            vd_aux: 0,
            vd_next: 0,
            vd_bfd: 0 as *mut bfd,
            vd_nodename: 0 as *const libc::c_char,
            vd_nextdef: 0 as *mut elf_internal_verdef,
            vd_auxptr: 0 as *mut elf_internal_verdaux,
            vd_exp_refno: 0,
        };
        let mut defaux: Elf_Internal_Verdaux = Elf_Internal_Verdaux {
            vda_name: 0,
            vda_next: 0,
            vda_nodename: 0 as *const libc::c_char,
            vda_nextptr: 0 as *mut elf_internal_verdaux,
        };
        s = bfd_get_linker_section(
            dynobj,
            b".gnu.version_d\0" as *const u8 as *const libc::c_char,
        );
        p = (*s).contents;
        loop {
            _bfd_elf_swap_verdef_in(output_bfd, p as *mut Elf_External_Verdef, &mut def);
            p = p
                .offset(
                    ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong
                        as isize,
                );
            if !(def.vd_aux
                != ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong)
            {
                i = 0 as libc::c_int as size_t;
                while i < def.vd_cnt as libc::c_ulong {
                    _bfd_elf_swap_verdaux_in(
                        output_bfd,
                        p as *mut Elf_External_Verdaux,
                        &mut defaux,
                    );
                    defaux.vda_name = _bfd_elf_strtab_offset(dynstr, defaux.vda_name);
                    _bfd_elf_swap_verdaux_out(
                        output_bfd,
                        &mut defaux,
                        p as *mut Elf_External_Verdaux,
                    );
                    p = p
                        .offset(
                            ::core::mem::size_of::<Elf_External_Verdaux>()
                                as libc::c_ulong as isize,
                        );
                    i = i.wrapping_add(1);
                    i;
                }
            }
            if !(def.vd_next != 0) {
                break;
            }
        }
    }
    if !((*(*output_bfd).tdata.elf_obj_data).verref).is_null() {
        let mut s_0: *mut asection = 0 as *mut asection;
        let mut p_0: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut i_0: size_t = 0;
        let mut need: Elf_Internal_Verneed = Elf_Internal_Verneed {
            vn_version: 0,
            vn_cnt: 0,
            vn_file: 0,
            vn_aux: 0,
            vn_next: 0,
            vn_bfd: 0 as *mut bfd,
            vn_filename: 0 as *const libc::c_char,
            vn_auxptr: 0 as *mut elf_internal_vernaux,
            vn_nextref: 0 as *mut elf_internal_verneed,
        };
        let mut needaux: Elf_Internal_Vernaux = Elf_Internal_Vernaux {
            vna_hash: 0,
            vna_flags: 0,
            vna_other: 0,
            vna_name: 0,
            vna_next: 0,
            vna_nodename: 0 as *const libc::c_char,
            vna_nextptr: 0 as *mut elf_internal_vernaux,
        };
        s_0 = bfd_get_linker_section(
            dynobj,
            b".gnu.version_r\0" as *const u8 as *const libc::c_char,
        );
        p_0 = (*s_0).contents;
        loop {
            _bfd_elf_swap_verneed_in(
                output_bfd,
                p_0 as *mut Elf_External_Verneed,
                &mut need,
            );
            need.vn_file = _bfd_elf_strtab_offset(dynstr, need.vn_file);
            _bfd_elf_swap_verneed_out(
                output_bfd,
                &mut need,
                p_0 as *mut Elf_External_Verneed,
            );
            p_0 = p_0
                .offset(
                    ::core::mem::size_of::<Elf_External_Verneed>() as libc::c_ulong
                        as isize,
                );
            i_0 = 0 as libc::c_int as size_t;
            while i_0 < need.vn_cnt as libc::c_ulong {
                _bfd_elf_swap_vernaux_in(
                    output_bfd,
                    p_0 as *mut Elf_External_Vernaux,
                    &mut needaux,
                );
                needaux.vna_name = _bfd_elf_strtab_offset(dynstr, needaux.vna_name);
                _bfd_elf_swap_vernaux_out(
                    output_bfd,
                    &mut needaux,
                    p_0 as *mut Elf_External_Vernaux,
                );
                p_0 = p_0
                    .offset(
                        ::core::mem::size_of::<Elf_External_Vernaux>() as libc::c_ulong
                            as isize,
                    );
                i_0 = i_0.wrapping_add(1);
                i_0;
            }
            if !(need.vn_next != 0) {
                break;
            }
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_default_relocs_compatible(
    mut input: *const bfd_target,
    mut output: *const bfd_target,
) -> bool {
    return input == output;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_relocs_compatible(
    mut input: *const bfd_target,
    mut output: *const bfd_target,
) -> bool {
    let mut obed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut ibed: *const elf_backend_data = 0 as *const elf_backend_data;
    if input == output {
        return 1 as libc::c_int != 0;
    }
    ibed = (*input).backend_data as *const elf_backend_data;
    obed = (*output).backend_data as *const elf_backend_data;
    if (*ibed).arch as libc::c_uint != (*obed).arch as libc::c_uint {
        return 0 as libc::c_int != 0;
    }
    return (*ibed).relocs_compatible == (*obed).relocs_compatible;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_notice_as_needed(
    mut ibfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut act: notice_asneeded_action,
) -> bool {
    return (Some(((*(*info).callbacks).notice).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        info,
        0 as *mut bfd_link_hash_entry,
        0 as *mut bfd_link_hash_entry,
        ibfd,
        0 as *mut asection,
        act as bfd_vma,
        0 as libc::c_int as flagword,
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_check_relocs(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut htab: *mut elf_link_hash_table = elf_hash_table(info);
    if (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
        && is_elf_hash_table(&mut (*htab).root) as libc::c_int != 0
        && ((*bed).check_relocs).is_some()
        && (*(*abfd).tdata.elf_obj_data).object_id() as libc::c_uint
            == elf_hash_table_id(htab) as libc::c_uint
        && (Some(((*bed).relocs_compatible).expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )((*abfd).xvec, (*(*info).output_bfd).xvec) as libc::c_int != 0
    {
        let mut o: *mut asection = 0 as *mut asection;
        o = (*abfd).sections;
        while !o.is_null() {
            let mut internal_relocs: *mut Elf_Internal_Rela = 0
                as *mut Elf_Internal_Rela;
            let mut ok: bool = false;
            if !((*o).flags & 0x1 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
                || (*o).flags & 0x4 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                || (*o).flags & 0x8000 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                || (*o).reloc_count == 0 as libc::c_int as libc::c_uint
                || ((*info).strip() as libc::c_int == strip_all as libc::c_int
                    || (*info).strip() as libc::c_int == strip_debugger as libc::c_int)
                    && (*o).flags & 0x2000 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                || bfd_is_abs_section((*o).output_section) as libc::c_int != 0)
            {
                internal_relocs = _bfd_elf_link_read_relocs(
                    abfd,
                    o,
                    0 as *mut libc::c_void,
                    0 as *mut Elf_Internal_Rela,
                    (*info).keep_memory() != 0,
                );
                if internal_relocs.is_null() {
                    return 0 as libc::c_int != 0;
                }
                ok = (Some(((*bed).check_relocs).expect("non-null function pointer")))
                    .expect("non-null function pointer")(abfd, info, o, internal_relocs);
                if (*((*o).used_by_bfd as *mut bfd_elf_section_data)).relocs
                    != internal_relocs
                {
                    free(internal_relocs as *mut libc::c_void);
                }
                if !ok {
                    return 0 as libc::c_int != 0;
                }
            }
            o = (*o).next;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_link_add_object_symbols(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut current_block: u64;
    let mut ehdr: *mut Elf_Internal_Ehdr = 0 as *mut Elf_Internal_Ehdr;
    let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symcount: size_t = 0;
    let mut extsymcount: size_t = 0;
    let mut extsymoff: size_t = 0;
    let mut sym_hash: *mut *mut elf_link_hash_entry = 0 as *mut *mut elf_link_hash_entry;
    let mut dynamic: bool = false;
    let mut extversym: *mut Elf_External_Versym = 0 as *mut Elf_External_Versym;
    let mut extversym_end: *mut Elf_External_Versym = 0 as *mut Elf_External_Versym;
    let mut ever: *mut Elf_External_Versym = 0 as *mut Elf_External_Versym;
    let mut weaks: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut nondeflt_vers: *mut *mut elf_link_hash_entry = 0
        as *mut *mut elf_link_hash_entry;
    let mut nondeflt_vers_cnt: size_t = 0 as libc::c_int as size_t;
    let mut isymbuf: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isymend: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut add_needed: bool = false;
    let mut htab: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut alloc_mark: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut old_table: *mut *mut bfd_hash_entry = 0 as *mut *mut bfd_hash_entry;
    let mut old_size: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut old_count: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut old_tab: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut old_ent: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut old_undefs: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
    let mut old_undefs_tail: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
    let mut old_strtab: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tabsize: size_t = 0 as libc::c_int as size_t;
    let mut s: *mut asection = 0 as *mut asection;
    let mut just_syms: bool = false;
    htab = elf_hash_table(info);
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        dynamic = 0 as libc::c_int != 0;
        current_block = 13797916685926291137;
    } else {
        dynamic = 1 as libc::c_int != 0;
        if (*info).type_0() as libc::c_int == type_relocatable as libc::c_int
            || !is_elf_hash_table(&mut (*htab).root)
            || (*(*info).output_bfd).xvec != (*abfd).xvec
        {
            if (*info).type_0() as libc::c_int == type_relocatable as libc::c_int {
                bfd_set_error(bfd_error_invalid_operation);
            } else {
                bfd_set_error(bfd_error_wrong_format);
            }
            current_block = 4312853273767610164;
        } else {
            current_block = 13797916685926291137;
        }
    }
    match current_block {
        13797916685926291137 => {
            ehdr = ((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr();
            if (*info).warn_alternate_em() as libc::c_int != 0
                && (*bed).elf_machine_code != (*ehdr).e_machine as libc::c_int
                && ((*bed).elf_machine_alt1 != 0 as libc::c_int
                    && (*ehdr).e_machine as libc::c_int == (*bed).elf_machine_alt1
                    || (*bed).elf_machine_alt2 != 0 as libc::c_int
                        && (*ehdr).e_machine as libc::c_int == (*bed).elf_machine_alt2)
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"alternate ELF machine code found (%d) in %pB, expecting %d\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*ehdr).e_machine as libc::c_int,
                    abfd,
                    (*bed).elf_machine_code,
                );
            }
            s = (*abfd).sections;
            loop {
                if s.is_null() {
                    current_block = 11743904203796629665;
                    break;
                }
                let mut name: *const libc::c_char = 0 as *const libc::c_char;
                name = bfd_section_name(s);
                if startswith(
                    name,
                    b".gnu.warning.\0" as *const u8 as *const libc::c_char,
                ) {
                    let mut msg: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut sz: bfd_size_type = 0;
                    name = name
                        .offset(
                            (::core::mem::size_of::<[libc::c_char; 14]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                        );
                    if dynamic {
                        let mut h: *mut elf_link_hash_entry = 0
                            as *mut elf_link_hash_entry;
                        h = elf_link_hash_lookup(
                            htab,
                            name,
                            0 as libc::c_int != 0,
                            0 as libc::c_int != 0,
                            1 as libc::c_int != 0,
                        );
                        if !h.is_null()
                            && (((*h).root).type_0() as libc::c_int
                                == bfd_link_hash_defined as libc::c_int
                                || ((*h).root).type_0() as libc::c_int
                                    == bfd_link_hash_defweak as libc::c_int)
                        {
                            current_block = 14401909646449704462;
                        } else {
                            current_block = 17788412896529399552;
                        }
                    } else {
                        current_block = 17788412896529399552;
                    }
                    match current_block {
                        14401909646449704462 => {}
                        _ => {
                            sz = (*s).size;
                            msg = bfd_alloc(
                                abfd,
                                sz.wrapping_add(1 as libc::c_int as libc::c_ulong),
                            ) as *mut libc::c_char;
                            if msg.is_null() {
                                current_block = 4312853273767610164;
                                break;
                            }
                            if !bfd_get_section_contents(
                                abfd,
                                s,
                                msg as *mut libc::c_void,
                                0 as libc::c_int as file_ptr,
                                sz,
                            ) {
                                current_block = 4312853273767610164;
                                break;
                            }
                            *msg.offset(sz as isize) = '\0' as i32 as libc::c_char;
                            if !_bfd_generic_link_add_one_symbol(
                                info,
                                abfd,
                                name,
                                ((1 as libc::c_int) << 12 as libc::c_int) as flagword,
                                s,
                                0 as libc::c_int as bfd_vma,
                                msg,
                                0 as libc::c_int != 0,
                                (*bed).collect() != 0,
                                0 as *mut *mut bfd_link_hash_entry,
                            ) {
                                current_block = 4312853273767610164;
                                break;
                            }
                            if (*info).type_0() as libc::c_int == type_pde as libc::c_int
                                || (*info).type_0() as libc::c_int
                                    == type_pie as libc::c_int
                            {
                                (*s).size = 0 as libc::c_int as bfd_size_type;
                                (*s).flags |= 0x8000 as libc::c_int as libc::c_uint;
                            }
                        }
                    }
                }
                s = (*s).next;
            }
            match current_block {
                4312853273767610164 => {}
                _ => {
                    s = (*abfd).sections;
                    just_syms = !s.is_null()
                        && (*s).sec_info_type() as libc::c_int == 4 as libc::c_int;
                    add_needed = 1 as libc::c_int != 0;
                    if !dynamic {
                        if !just_syms
                            && ((*info).type_0() as libc::c_int
                                == type_dll as libc::c_int
                                || (*info).type_0() as libc::c_int
                                    == type_pie as libc::c_int
                                || !((*info).type_0() as libc::c_int
                                    == type_relocatable as libc::c_int)
                                    && (*info).nointerp() as libc::c_int != 0
                                    && ((*info).export_dynamic() as libc::c_int != 0
                                        || (*info).dynamic() as libc::c_int != 0))
                            && is_elf_hash_table(&mut (*htab).root) as libc::c_int != 0
                            && (*(*info).output_bfd).xvec == (*abfd).xvec
                            && !(*htab).dynamic_sections_created
                        {
                            if !_bfd_elf_link_create_dynamic_sections(abfd, info) {
                                current_block = 4312853273767610164;
                            } else {
                                current_block = 7157669805658135323;
                            }
                        } else {
                            current_block = 7157669805658135323;
                        }
                    } else if !is_elf_hash_table(&mut (*htab).root) {
                        current_block = 4312853273767610164;
                    } else {
                        let mut soname: *const libc::c_char = 0 as *const libc::c_char;
                        let mut audit: *mut libc::c_char = 0 as *mut libc::c_char;
                        let mut rpath: *mut bfd_link_needed_list = 0
                            as *mut bfd_link_needed_list;
                        let mut runpath: *mut bfd_link_needed_list = 0
                            as *mut bfd_link_needed_list;
                        let mut phdr: *const Elf_Internal_Phdr = 0
                            as *const Elf_Internal_Phdr;
                        let mut loaded_lib: *mut elf_link_loaded_list = 0
                            as *mut elf_link_loaded_list;
                        if just_syms {
                            _bfd_abort(
                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                4226 as libc::c_int,
                                (*::core::mem::transmute::<
                                    &[u8; 65],
                                    &[libc::c_char; 65],
                                >(
                                    b"_Bool elf_link_add_object_symbols(bfd *, struct bfd_link_info *)\0",
                                ))
                                    .as_ptr(),
                            );
                        }
                        add_needed = (*(*abfd).tdata.elf_obj_data).dyn_lib_class()
                            as libc::c_int
                            & (DYN_AS_NEEDED as libc::c_int
                                | DYN_DT_NEEDED as libc::c_int
                                | DYN_NO_NEEDED as libc::c_int) == 0 as libc::c_int;
                        s = bfd_get_section_by_name(
                            abfd,
                            b".dynamic\0" as *const u8 as *const libc::c_char,
                        );
                        if !s.is_null() {
                            let mut dynbuf: *mut bfd_byte = 0 as *mut bfd_byte;
                            let mut extdyn: *mut bfd_byte = 0 as *mut bfd_byte;
                            let mut elfsec: libc::c_uint = 0;
                            let mut shlink: libc::c_ulong = 0;
                            if !bfd_malloc_and_get_section(abfd, s, &mut dynbuf) {
                                current_block = 15336366966548609553;
                            } else {
                                elfsec = _bfd_elf_section_from_bfd_section(abfd, s);
                                if elfsec == (0x101 as libc::c_uint).wrapping_neg() {
                                    current_block = 15336366966548609553;
                                } else {
                                    shlink = (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(elfsec as isize))
                                        .sh_link as libc::c_ulong;
                                    extdyn = dynbuf;
                                    loop {
                                        if !(extdyn
                                            <= dynbuf
                                                .offset((*s).size as isize)
                                                .offset(-((*(*bed).s).sizeof_dyn as libc::c_int as isize)))
                                        {
                                            current_block = 5697748000427295508;
                                            break;
                                        }
                                        let mut dyn_0: Elf_Internal_Dyn = Elf_Internal_Dyn {
                                            d_tag: 0,
                                            d_un: C2RustUnnamed_21 { d_val: 0 },
                                        };
                                        ((*(*bed).s).swap_dyn_in)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, extdyn as *const libc::c_void, &mut dyn_0);
                                        if dyn_0.d_tag == 14 as libc::c_int as libc::c_ulong {
                                            let mut tagv: libc::c_uint = dyn_0.d_un.d_val
                                                as libc::c_uint;
                                            soname = bfd_elf_string_from_elf_section(
                                                abfd,
                                                shlink as libc::c_uint,
                                                tagv,
                                            );
                                            if soname.is_null() {
                                                current_block = 15336366966548609553;
                                                break;
                                            }
                                        }
                                        if dyn_0.d_tag == 1 as libc::c_int as libc::c_ulong {
                                            let mut n: *mut bfd_link_needed_list = 0
                                                as *mut bfd_link_needed_list;
                                            let mut pn: *mut *mut bfd_link_needed_list = 0
                                                as *mut *mut bfd_link_needed_list;
                                            let mut fnm: *mut libc::c_char = 0 as *mut libc::c_char;
                                            let mut anm: *mut libc::c_char = 0 as *mut libc::c_char;
                                            let mut tagv_0: libc::c_uint = dyn_0.d_un.d_val
                                                as libc::c_uint;
                                            let mut amt: size_t = ::core::mem::size_of::<
                                                bfd_link_needed_list,
                                            >() as libc::c_ulong;
                                            n = bfd_alloc(abfd, amt) as *mut bfd_link_needed_list;
                                            fnm = bfd_elf_string_from_elf_section(
                                                abfd,
                                                shlink as libc::c_uint,
                                                tagv_0,
                                            );
                                            if n.is_null() || fnm.is_null() {
                                                current_block = 15336366966548609553;
                                                break;
                                            }
                                            amt = (strlen(fnm))
                                                .wrapping_add(1 as libc::c_int as libc::c_ulong);
                                            anm = bfd_alloc(abfd, amt) as *mut libc::c_char;
                                            if anm.is_null() {
                                                current_block = 15336366966548609553;
                                                break;
                                            }
                                            memcpy(
                                                anm as *mut libc::c_void,
                                                fnm as *const libc::c_void,
                                                amt,
                                            );
                                            (*n).name = anm;
                                            (*n).by = abfd;
                                            (*n).next = 0 as *mut bfd_link_needed_list;
                                            pn = &mut (*htab).needed;
                                            while !(*pn).is_null() {
                                                pn = &mut (**pn).next;
                                            }
                                            *pn = n;
                                        }
                                        if dyn_0.d_tag == 29 as libc::c_int as libc::c_ulong {
                                            let mut n_0: *mut bfd_link_needed_list = 0
                                                as *mut bfd_link_needed_list;
                                            let mut pn_0: *mut *mut bfd_link_needed_list = 0
                                                as *mut *mut bfd_link_needed_list;
                                            let mut fnm_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                            let mut anm_0: *mut libc::c_char = 0 as *mut libc::c_char;
                                            let mut tagv_1: libc::c_uint = dyn_0.d_un.d_val
                                                as libc::c_uint;
                                            let mut amt_0: size_t = ::core::mem::size_of::<
                                                bfd_link_needed_list,
                                            >() as libc::c_ulong;
                                            n_0 = bfd_alloc(abfd, amt_0) as *mut bfd_link_needed_list;
                                            fnm_0 = bfd_elf_string_from_elf_section(
                                                abfd,
                                                shlink as libc::c_uint,
                                                tagv_1,
                                            );
                                            if n_0.is_null() || fnm_0.is_null() {
                                                current_block = 15336366966548609553;
                                                break;
                                            }
                                            amt_0 = (strlen(fnm_0))
                                                .wrapping_add(1 as libc::c_int as libc::c_ulong);
                                            anm_0 = bfd_alloc(abfd, amt_0) as *mut libc::c_char;
                                            if anm_0.is_null() {
                                                current_block = 15336366966548609553;
                                                break;
                                            }
                                            memcpy(
                                                anm_0 as *mut libc::c_void,
                                                fnm_0 as *const libc::c_void,
                                                amt_0,
                                            );
                                            (*n_0).name = anm_0;
                                            (*n_0).by = abfd;
                                            (*n_0).next = 0 as *mut bfd_link_needed_list;
                                            pn_0 = &mut runpath;
                                            while !(*pn_0).is_null() {
                                                pn_0 = &mut (**pn_0).next;
                                            }
                                            *pn_0 = n_0;
                                        }
                                        if runpath.is_null()
                                            && dyn_0.d_tag == 15 as libc::c_int as libc::c_ulong
                                        {
                                            let mut n_1: *mut bfd_link_needed_list = 0
                                                as *mut bfd_link_needed_list;
                                            let mut pn_1: *mut *mut bfd_link_needed_list = 0
                                                as *mut *mut bfd_link_needed_list;
                                            let mut fnm_1: *mut libc::c_char = 0 as *mut libc::c_char;
                                            let mut anm_1: *mut libc::c_char = 0 as *mut libc::c_char;
                                            let mut tagv_2: libc::c_uint = dyn_0.d_un.d_val
                                                as libc::c_uint;
                                            let mut amt_1: size_t = ::core::mem::size_of::<
                                                bfd_link_needed_list,
                                            >() as libc::c_ulong;
                                            n_1 = bfd_alloc(abfd, amt_1) as *mut bfd_link_needed_list;
                                            fnm_1 = bfd_elf_string_from_elf_section(
                                                abfd,
                                                shlink as libc::c_uint,
                                                tagv_2,
                                            );
                                            if n_1.is_null() || fnm_1.is_null() {
                                                current_block = 15336366966548609553;
                                                break;
                                            }
                                            amt_1 = (strlen(fnm_1))
                                                .wrapping_add(1 as libc::c_int as libc::c_ulong);
                                            anm_1 = bfd_alloc(abfd, amt_1) as *mut libc::c_char;
                                            if anm_1.is_null() {
                                                current_block = 15336366966548609553;
                                                break;
                                            }
                                            memcpy(
                                                anm_1 as *mut libc::c_void,
                                                fnm_1 as *const libc::c_void,
                                                amt_1,
                                            );
                                            (*n_1).name = anm_1;
                                            (*n_1).by = abfd;
                                            (*n_1).next = 0 as *mut bfd_link_needed_list;
                                            pn_1 = &mut rpath;
                                            while !(*pn_1).is_null() {
                                                pn_1 = &mut (**pn_1).next;
                                            }
                                            *pn_1 = n_1;
                                        }
                                        if dyn_0.d_tag == 0x6ffffefc as libc::c_int as libc::c_ulong
                                        {
                                            let mut tagv_3: libc::c_uint = dyn_0.d_un.d_val
                                                as libc::c_uint;
                                            audit = bfd_elf_string_from_elf_section(
                                                abfd,
                                                shlink as libc::c_uint,
                                                tagv_3,
                                            );
                                        }
                                        if dyn_0.d_tag == 0x6ffffffb as libc::c_int as libc::c_ulong
                                        {
                                            (*(*abfd).tdata.elf_obj_data)
                                                .set_is_pie(
                                                    (dyn_0.d_un.d_val
                                                        & 0x8000000 as libc::c_int as libc::c_ulong
                                                        != 0 as libc::c_int as libc::c_ulong) as libc::c_int
                                                        as libc::c_uint,
                                                );
                                        }
                                        extdyn = extdyn
                                            .offset((*(*bed).s).sizeof_dyn as libc::c_int as isize);
                                    }
                                    match current_block {
                                        15336366966548609553 => {}
                                        _ => {
                                            free(dynbuf as *mut libc::c_void);
                                            current_block = 12065775993741208975;
                                        }
                                    }
                                }
                            }
                            match current_block {
                                12065775993741208975 => {}
                                _ => {
                                    free(dynbuf as *mut libc::c_void);
                                    current_block = 4312853273767610164;
                                }
                            }
                        } else {
                            current_block = 12065775993741208975;
                        }
                        match current_block {
                            4312853273767610164 => {}
                            _ => {
                                if !runpath.is_null() {
                                    rpath = runpath;
                                }
                                if !rpath.is_null() {
                                    let mut pn_2: *mut *mut bfd_link_needed_list = 0
                                        as *mut *mut bfd_link_needed_list;
                                    pn_2 = &mut (*htab).runpath;
                                    while !(*pn_2).is_null() {
                                        pn_2 = &mut (**pn_2).next;
                                    }
                                    *pn_2 = rpath;
                                }
                                phdr = ((*(*abfd).tdata.elf_obj_data).phdr)
                                    .offset(
                                        (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
                                            .e_phnum as isize,
                                    );
                                loop {
                                    let fresh8 = phdr;
                                    phdr = phdr.offset(-1);
                                    if !(fresh8
                                        > (*(*abfd).tdata.elf_obj_data).phdr
                                            as *const Elf_Internal_Phdr)
                                    {
                                        break;
                                    }
                                    if !((*phdr).p_type
                                        == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                            as libc::c_ulong)
                                    {
                                        continue;
                                    }
                                    s = (*abfd).sections;
                                    while !s.is_null() {
                                        let mut opb: libc::c_uint = bfd_octets_per_byte(abfd, s);
                                        if (*s).flags & 0x1 as libc::c_int as libc::c_uint
                                            != 0 as libc::c_int as libc::c_uint
                                            && ((*s).vma).wrapping_mul(opb as libc::c_ulong)
                                                >= (*phdr).p_vaddr
                                            && ((*s).vma)
                                                .wrapping_mul(opb as libc::c_ulong)
                                                .wrapping_add((*s).size)
                                                <= ((*phdr).p_vaddr).wrapping_add((*phdr).p_memsz)
                                        {
                                            (*s).flags |= 0x8 as libc::c_int as libc::c_uint;
                                        }
                                        s = (*s).next;
                                    }
                                    break;
                                }
                                bfd_section_list_clear(abfd);
                                if soname.is_null() || *soname as libc::c_int == '\0' as i32
                                {
                                    soname = (*(*abfd).tdata.elf_obj_data).dt_name;
                                    if soname.is_null() || *soname as libc::c_int == '\0' as i32
                                    {
                                        soname = bfd_get_filename(abfd);
                                    }
                                }
                                (*(*abfd).tdata.elf_obj_data).dt_name = soname;
                                loaded_lib = (*htab).dyn_loaded;
                                while !loaded_lib.is_null() {
                                    if strcmp(
                                        (*(*(*loaded_lib).abfd).tdata.elf_obj_data).dt_name,
                                        soname,
                                    ) == 0 as libc::c_int
                                    {
                                        return 1 as libc::c_int != 0;
                                    }
                                    loaded_lib = (*loaded_lib).next;
                                }
                                if add_needed as libc::c_int != 0
                                    && !_bfd_elf_link_create_dynamic_sections(abfd, info)
                                {
                                    return 0 as libc::c_int != 0;
                                }
                                (*(*abfd).tdata.elf_obj_data).dt_audit = audit;
                                current_block = 7157669805658135323;
                            }
                        }
                    }
                    match current_block {
                        4312853273767610164 => {}
                        _ => {
                            if !dynamic
                                || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    == 0 as libc::c_int as libc::c_uint
                            {
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            } else {
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                            }
                            symcount = ((*hdr).sh_size)
                                .wrapping_div((*(*bed).s).sizeof_sym as libc::c_ulong);
                            if (*(*abfd).tdata.elf_obj_data).bad_symtab() != 0 {
                                extsymcount = symcount;
                                extsymoff = 0 as libc::c_int as size_t;
                            } else {
                                extsymcount = symcount
                                    .wrapping_sub((*hdr).sh_info as libc::c_ulong);
                                extsymoff = (*hdr).sh_info as size_t;
                            }
                            sym_hash = (*(*abfd).tdata.elf_obj_data).sym_hashes;
                            if extsymcount != 0 as libc::c_int as libc::c_ulong {
                                isymbuf = bfd_elf_get_elf_syms(
                                    abfd,
                                    hdr,
                                    extsymcount,
                                    extsymoff,
                                    0 as *mut Elf_Internal_Sym,
                                    0 as *mut libc::c_void,
                                    0 as *mut Elf_External_Sym_Shndx,
                                );
                                if isymbuf.is_null() {
                                    current_block = 4312853273767610164;
                                } else if sym_hash.is_null() {
                                    let mut amt_2: size_t = extsymcount
                                        .wrapping_mul(
                                            ::core::mem::size_of::<*mut elf_link_hash_entry>()
                                                as libc::c_ulong,
                                        );
                                    sym_hash = bfd_zalloc(abfd, amt_2)
                                        as *mut *mut elf_link_hash_entry;
                                    if sym_hash.is_null() {
                                        current_block = 13529282842555969672;
                                    } else {
                                        (*(*abfd).tdata.elf_obj_data).sym_hashes = sym_hash;
                                        current_block = 2838755337219234678;
                                    }
                                } else {
                                    current_block = 2838755337219234678;
                                }
                            } else {
                                current_block = 2838755337219234678;
                            }
                            match current_block {
                                4312853273767610164 => {}
                                _ => {
                                    match current_block {
                                        2838755337219234678 => {
                                            if dynamic {
                                                if !_bfd_elf_slurp_version_tables(
                                                    abfd,
                                                    (*info).default_imported_symver() != 0,
                                                ) {
                                                    current_block = 13529282842555969672;
                                                } else if (*(*abfd).tdata.elf_obj_data).dynversym_section
                                                    != 0 as libc::c_int as libc::c_uint
                                                {
                                                    let mut versymhdr: *mut Elf_Internal_Shdr = &mut (*(*abfd)
                                                        .tdata
                                                        .elf_obj_data)
                                                        .dynversym_hdr;
                                                    let mut amt_3: bfd_size_type = (*versymhdr).sh_size;
                                                    if bfd_seek(abfd, (*versymhdr).sh_offset, 0 as libc::c_int)
                                                        != 0 as libc::c_int
                                                    {
                                                        current_block = 13529282842555969672;
                                                    } else {
                                                        extversym = _bfd_malloc_and_read(abfd, amt_3, amt_3)
                                                            as *mut Elf_External_Versym;
                                                        if extversym.is_null() {
                                                            current_block = 13529282842555969672;
                                                        } else {
                                                            extversym_end = extversym
                                                                .offset(
                                                                    amt_3
                                                                        .wrapping_div(
                                                                            ::core::mem::size_of::<Elf_External_Versym>()
                                                                                as libc::c_ulong,
                                                                        ) as isize,
                                                                );
                                                            current_block = 7198204517578597543;
                                                        }
                                                    }
                                                } else {
                                                    current_block = 7198204517578597543;
                                                }
                                            } else {
                                                current_block = 7198204517578597543;
                                            }
                                            match current_block {
                                                13529282842555969672 => {}
                                                _ => {
                                                    if (*(*abfd).tdata.elf_obj_data).dyn_lib_class()
                                                        as libc::c_int & DYN_AS_NEEDED as libc::c_int
                                                        != 0 as libc::c_int
                                                    {
                                                        let mut i: libc::c_uint = 0;
                                                        let mut entsize: size_t = 0;
                                                        entsize = 0 as libc::c_int as size_t;
                                                        i = 0 as libc::c_int as libc::c_uint;
                                                        while i < (*htab).root.table.size {
                                                            let mut p: *mut bfd_hash_entry = 0 as *mut bfd_hash_entry;
                                                            let mut h_0: *mut elf_link_hash_entry = 0
                                                                as *mut elf_link_hash_entry;
                                                            p = *((*htab).root.table.table).offset(i as isize);
                                                            while !p.is_null() {
                                                                h_0 = p as *mut elf_link_hash_entry;
                                                                entsize = (entsize as libc::c_ulong)
                                                                    .wrapping_add((*htab).root.table.entsize as libc::c_ulong)
                                                                    as size_t as size_t;
                                                                if ((*h_0).root).type_0() as libc::c_int
                                                                    == bfd_link_hash_warning as libc::c_int
                                                                {
                                                                    entsize = (entsize as libc::c_ulong)
                                                                        .wrapping_add((*htab).root.table.entsize as libc::c_ulong)
                                                                        as size_t as size_t;
                                                                    h_0 = (*h_0).root.u.i.link as *mut elf_link_hash_entry;
                                                                }
                                                                if ((*h_0).root).type_0() as libc::c_int
                                                                    == bfd_link_hash_common as libc::c_int
                                                                {
                                                                    entsize = (entsize as libc::c_ulong)
                                                                        .wrapping_add(
                                                                            ::core::mem::size_of::<bfd_link_hash_common_entry>()
                                                                                as libc::c_ulong,
                                                                        ) as size_t as size_t;
                                                                }
                                                                p = (*p).next;
                                                            }
                                                            i = i.wrapping_add(1);
                                                            i;
                                                        }
                                                        tabsize = ((*htab).root.table.size as libc::c_ulong)
                                                            .wrapping_mul(
                                                                ::core::mem::size_of::<*mut bfd_hash_entry>()
                                                                    as libc::c_ulong,
                                                            );
                                                        old_tab = bfd_malloc(tabsize.wrapping_add(entsize));
                                                        if old_tab.is_null() {
                                                            current_block = 12388102377924243912;
                                                        } else {
                                                            alloc_mark = bfd_hash_allocate(
                                                                &mut (*htab).root.table,
                                                                1 as libc::c_int as libc::c_uint,
                                                            );
                                                            if alloc_mark.is_null() {
                                                                current_block = 12388102377924243912;
                                                            } else if !(Some(
                                                                ((*bed).notice_as_needed)
                                                                    .expect("non-null function pointer"),
                                                            ))
                                                                .expect(
                                                                    "non-null function pointer",
                                                                )(abfd, info, notice_as_needed)
                                                            {
                                                                current_block = 12388102377924243912;
                                                            } else {
                                                                old_ent = (old_tab as *mut libc::c_char)
                                                                    .offset(tabsize as isize) as *mut libc::c_void;
                                                                memcpy(
                                                                    old_tab,
                                                                    (*htab).root.table.table as *const libc::c_void,
                                                                    tabsize,
                                                                );
                                                                old_undefs = (*htab).root.undefs;
                                                                old_undefs_tail = (*htab).root.undefs_tail;
                                                                old_table = (*htab).root.table.table;
                                                                old_size = (*htab).root.table.size;
                                                                old_count = (*htab).root.table.count;
                                                                old_strtab = 0 as *mut libc::c_void;
                                                                if !((*htab).dynstr).is_null() {
                                                                    old_strtab = _bfd_elf_strtab_save((*htab).dynstr);
                                                                    if old_strtab.is_null() {
                                                                        current_block = 12388102377924243912;
                                                                    } else {
                                                                        current_block = 12299212226970775842;
                                                                    }
                                                                } else {
                                                                    current_block = 12299212226970775842;
                                                                }
                                                                match current_block {
                                                                    12388102377924243912 => {}
                                                                    _ => {
                                                                        i = 0 as libc::c_int as libc::c_uint;
                                                                        while i < (*htab).root.table.size {
                                                                            let mut p_0: *mut bfd_hash_entry = 0 as *mut bfd_hash_entry;
                                                                            let mut h_1: *mut elf_link_hash_entry = 0
                                                                                as *mut elf_link_hash_entry;
                                                                            p_0 = *((*htab).root.table.table).offset(i as isize);
                                                                            while !p_0.is_null() {
                                                                                h_1 = p_0 as *mut elf_link_hash_entry;
                                                                                memcpy(
                                                                                    old_ent,
                                                                                    h_1 as *const libc::c_void,
                                                                                    (*htab).root.table.entsize as libc::c_ulong,
                                                                                );
                                                                                old_ent = (old_ent as *mut libc::c_char)
                                                                                    .offset((*htab).root.table.entsize as isize)
                                                                                    as *mut libc::c_void;
                                                                                if ((*h_1).root).type_0() as libc::c_int
                                                                                    == bfd_link_hash_warning as libc::c_int
                                                                                {
                                                                                    h_1 = (*h_1).root.u.i.link as *mut elf_link_hash_entry;
                                                                                    memcpy(
                                                                                        old_ent,
                                                                                        h_1 as *const libc::c_void,
                                                                                        (*htab).root.table.entsize as libc::c_ulong,
                                                                                    );
                                                                                    old_ent = (old_ent as *mut libc::c_char)
                                                                                        .offset((*htab).root.table.entsize as isize)
                                                                                        as *mut libc::c_void;
                                                                                }
                                                                                if ((*h_1).root).type_0() as libc::c_int
                                                                                    == bfd_link_hash_common as libc::c_int
                                                                                {
                                                                                    memcpy(
                                                                                        old_ent,
                                                                                        (*h_1).root.u.c.p as *const libc::c_void,
                                                                                        ::core::mem::size_of::<bfd_link_hash_common_entry>()
                                                                                            as libc::c_ulong,
                                                                                    );
                                                                                    old_ent = (old_ent as *mut libc::c_char)
                                                                                        .offset(
                                                                                            ::core::mem::size_of::<bfd_link_hash_common_entry>()
                                                                                                as libc::c_ulong as isize,
                                                                                        ) as *mut libc::c_void;
                                                                                }
                                                                                p_0 = (*p_0).next;
                                                                            }
                                                                            i = i.wrapping_add(1);
                                                                            i;
                                                                        }
                                                                        current_block = 16979802930995685524;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        current_block = 16979802930995685524;
                                                    }
                                                    match current_block {
                                                        16979802930995685524 => {
                                                            weaks = 0 as *mut elf_link_hash_entry;
                                                            if extversym.is_null() {
                                                                ever = 0 as *mut Elf_External_Versym;
                                                                current_block = 11611889268825773381;
                                                            } else if extversym.offset(extsymoff as isize)
                                                                < extversym_end
                                                            {
                                                                ever = extversym.offset(extsymoff as isize);
                                                                current_block = 11611889268825773381;
                                                            } else {
                                                                _bfd_error_handler(
                                                                    dcgettext(
                                                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                                                        b"%pB: invalid version offset %lx (max %lx)\0" as *const u8
                                                                            as *const libc::c_char,
                                                                        5 as libc::c_int,
                                                                    ),
                                                                    abfd,
                                                                    extsymoff as libc::c_long,
                                                                    (extversym_end.offset_from(extversym) as libc::c_long
                                                                        as libc::c_ulong)
                                                                        .wrapping_div(
                                                                            ::core::mem::size_of::<Elf_External_Versym>()
                                                                                as libc::c_ulong,
                                                                        ),
                                                                );
                                                                bfd_set_error(bfd_error_bad_value);
                                                                current_block = 12388102377924243912;
                                                            }
                                                            match current_block {
                                                                12388102377924243912 => {}
                                                                _ => {
                                                                    if !((*info).type_0() as libc::c_int
                                                                        == type_relocatable as libc::c_int)
                                                                        && (*abfd).lto_slim_object() as libc::c_int != 0
                                                                    {
                                                                        _bfd_error_handler(
                                                                            dcgettext(
                                                                                b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                b"%pB: plugin needed to handle lto object\0" as *const u8
                                                                                    as *const libc::c_char,
                                                                                5 as libc::c_int,
                                                                            ),
                                                                            abfd,
                                                                        );
                                                                    }
                                                                    isym = isymbuf;
                                                                    isymend = isymbuf.offset(extsymcount as isize);
                                                                    loop {
                                                                        if !(isym < isymend) {
                                                                            current_block = 1122595689570067714;
                                                                            break;
                                                                        }
                                                                        let mut bind: libc::c_int = 0;
                                                                        let mut value: bfd_vma = 0;
                                                                        let mut sec: *mut asection = 0 as *mut asection;
                                                                        let mut new_sec: *mut asection = 0 as *mut asection;
                                                                        let mut flags: flagword = 0;
                                                                        let mut name_0: *const libc::c_char = 0
                                                                            as *const libc::c_char;
                                                                        let mut h_2: *mut elf_link_hash_entry = 0
                                                                            as *mut elf_link_hash_entry;
                                                                        let mut hi: *mut elf_link_hash_entry = 0
                                                                            as *mut elf_link_hash_entry;
                                                                        let mut definition: bool = false;
                                                                        let mut size_change_ok: bool = false;
                                                                        let mut type_change_ok: bool = false;
                                                                        let mut new_weak: bool = false;
                                                                        let mut old_weak: bool = false;
                                                                        let mut override_0: *mut bfd = 0 as *mut bfd;
                                                                        let mut common: bool = false;
                                                                        let mut discarded: bool = false;
                                                                        let mut old_alignment: libc::c_uint = 0;
                                                                        let mut shindex: libc::c_uint = 0;
                                                                        let mut old_bfd: *mut bfd = 0 as *mut bfd;
                                                                        let mut matched: bool = false;
                                                                        override_0 = 0 as *mut bfd;
                                                                        flags = 0 as libc::c_int as flagword;
                                                                        sec = 0 as *mut asection;
                                                                        value = (*isym).st_value;
                                                                        common = ((*bed).common_definition)
                                                                            .expect("non-null function pointer")(isym);
                                                                        if common as libc::c_int != 0
                                                                            && (*info).inhibit_common_definition() as libc::c_int != 0
                                                                        {
                                                                            (*isym).st_shndx = 0 as libc::c_int as libc::c_uint;
                                                                            common = 0 as libc::c_int != 0;
                                                                        }
                                                                        discarded = 0 as libc::c_int != 0;
                                                                        bind = ((*isym).st_info as libc::c_uint >> 4 as libc::c_int)
                                                                            as libc::c_int;
                                                                        match bind {
                                                                            0 => {
                                                                                if (*(*abfd).tdata.elf_obj_data).bad_symtab() != 0 {
                                                                                    current_block = 5083741289379115417;
                                                                                } else {
                                                                                    shindex = (*((*(*abfd).tdata.elf_obj_data).elf_header)
                                                                                        .as_mut_ptr())
                                                                                        .e_shstrndx;
                                                                                    name_0 = bfd_elf_string_from_elf_section(
                                                                                        abfd,
                                                                                        shindex,
                                                                                        (*hdr).sh_name,
                                                                                    );
                                                                                    _bfd_error_handler(
                                                                                        dcgettext(
                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                            b"%pB: %s local symbol at index %lu (>= sh_info of %lu)\0"
                                                                                                as *const u8 as *const libc::c_char,
                                                                                            5 as libc::c_int,
                                                                                        ),
                                                                                        abfd,
                                                                                        name_0,
                                                                                        (isym.offset_from(isymbuf) as libc::c_long as libc::c_ulong)
                                                                                            .wrapping_add(extsymoff) as libc::c_long,
                                                                                        extsymoff as libc::c_long,
                                                                                    );
                                                                                    if dynamic {
                                                                                        current_block = 5083741289379115417;
                                                                                    } else {
                                                                                        bfd_set_error(bfd_error_bad_value);
                                                                                        current_block = 12388102377924243912;
                                                                                        break;
                                                                                    }
                                                                                }
                                                                            }
                                                                            1 => {
                                                                                if (*isym).st_shndx != 0 as libc::c_int as libc::c_uint
                                                                                    && !common
                                                                                {
                                                                                    flags = ((1 as libc::c_int) << 1 as libc::c_int)
                                                                                        as flagword;
                                                                                }
                                                                                current_block = 16225421537987648902;
                                                                            }
                                                                            2 => {
                                                                                flags = ((1 as libc::c_int) << 7 as libc::c_int)
                                                                                    as flagword;
                                                                                current_block = 16225421537987648902;
                                                                            }
                                                                            10 => {
                                                                                flags = ((1 as libc::c_int) << 23 as libc::c_int)
                                                                                    as flagword;
                                                                                current_block = 16225421537987648902;
                                                                            }
                                                                            _ => {
                                                                                current_block = 16225421537987648902;
                                                                            }
                                                                        }
                                                                        match current_block {
                                                                            16225421537987648902 => {
                                                                                if (*isym).st_shndx == 0 as libc::c_int as libc::c_uint {
                                                                                    sec = &mut *_bfd_std_section
                                                                                        .as_mut_ptr()
                                                                                        .offset(1 as libc::c_int as isize) as *mut asection;
                                                                                } else if (*isym).st_shndx
                                                                                    == (0xf as libc::c_uint).wrapping_neg()
                                                                                {
                                                                                    sec = &mut *_bfd_std_section
                                                                                        .as_mut_ptr()
                                                                                        .offset(2 as libc::c_int as isize) as *mut asection;
                                                                                } else if (*isym).st_shndx
                                                                                    == (0xe as libc::c_uint).wrapping_neg()
                                                                                {
                                                                                    sec = &mut *_bfd_std_section
                                                                                        .as_mut_ptr()
                                                                                        .offset(0 as libc::c_int as isize) as *mut asection;
                                                                                    value = (*isym).st_size;
                                                                                } else {
                                                                                    sec = bfd_section_from_elf_index(abfd, (*isym).st_shndx);
                                                                                    if sec.is_null() {
                                                                                        sec = &mut *_bfd_std_section
                                                                                            .as_mut_ptr()
                                                                                            .offset(2 as libc::c_int as isize) as *mut asection;
                                                                                    } else if discarded_section(sec) {
                                                                                        sec = &mut *_bfd_std_section
                                                                                            .as_mut_ptr()
                                                                                            .offset(1 as libc::c_int as isize) as *mut asection;
                                                                                        discarded = 1 as libc::c_int != 0;
                                                                                        (*isym).st_shndx = 0 as libc::c_int as libc::c_uint;
                                                                                    } else if (*abfd).flags
                                                                                        & (0x2 as libc::c_int | 0x40 as libc::c_int) as libc::c_uint
                                                                                        != 0 as libc::c_int as libc::c_uint
                                                                                    {
                                                                                        value = (value as libc::c_ulong).wrapping_sub((*sec).vma)
                                                                                            as bfd_vma as bfd_vma;
                                                                                    }
                                                                                }
                                                                                name_0 = bfd_elf_string_from_elf_section(
                                                                                    abfd,
                                                                                    (*hdr).sh_link,
                                                                                    (*isym).st_name as libc::c_uint,
                                                                                );
                                                                                if name_0.is_null() {
                                                                                    current_block = 12388102377924243912;
                                                                                    break;
                                                                                }
                                                                                if (*isym).st_shndx == (0xe as libc::c_uint).wrapping_neg()
                                                                                    && (*abfd).flags & 0x10000 as libc::c_int as libc::c_uint
                                                                                        != 0 as libc::c_int as libc::c_uint
                                                                                {
                                                                                    let mut xc: *mut asection = bfd_get_section_by_name(
                                                                                        abfd,
                                                                                        b"COMMON\0" as *const u8 as *const libc::c_char,
                                                                                    );
                                                                                    if xc.is_null() {
                                                                                        let mut sflags: flagword = (0x1 as libc::c_int
                                                                                            | 0x1000 as libc::c_int | 0x200000 as libc::c_int
                                                                                            | 0x8000 as libc::c_int) as flagword;
                                                                                        xc = bfd_make_section_with_flags(
                                                                                            abfd,
                                                                                            b"COMMON\0" as *const u8 as *const libc::c_char,
                                                                                            sflags,
                                                                                        );
                                                                                        if xc.is_null() {
                                                                                            current_block = 12388102377924243912;
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                    sec = xc;
                                                                                    current_block = 15605369199999130895;
                                                                                } else if (*isym).st_shndx
                                                                                    == (0xe as libc::c_uint).wrapping_neg()
                                                                                    && (*isym).st_info as libc::c_int & 0xf as libc::c_int
                                                                                        == 6 as libc::c_int
                                                                                    && !((*info).type_0() as libc::c_int
                                                                                        == type_relocatable as libc::c_int)
                                                                                {
                                                                                    let mut tcomm: *mut asection = bfd_get_section_by_name(
                                                                                        abfd,
                                                                                        b".tcommon\0" as *const u8 as *const libc::c_char,
                                                                                    );
                                                                                    if tcomm.is_null() {
                                                                                        let mut sflags_0: flagword = (0x1 as libc::c_int
                                                                                            | 0x400 as libc::c_int | 0x1000 as libc::c_int
                                                                                            | 0x100000 as libc::c_int) as flagword;
                                                                                        tcomm = bfd_make_section_with_flags(
                                                                                            abfd,
                                                                                            b".tcommon\0" as *const u8 as *const libc::c_char,
                                                                                            sflags_0,
                                                                                        );
                                                                                        if tcomm.is_null() {
                                                                                            current_block = 12388102377924243912;
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                    sec = tcomm;
                                                                                    current_block = 15605369199999130895;
                                                                                } else if ((*bed).elf_add_symbol_hook).is_some() {
                                                                                    if !(Some(
                                                                                        ((*bed).elf_add_symbol_hook)
                                                                                            .expect("non-null function pointer"),
                                                                                    ))
                                                                                        .expect(
                                                                                            "non-null function pointer",
                                                                                        )(
                                                                                        abfd,
                                                                                        info,
                                                                                        isym,
                                                                                        &mut name_0,
                                                                                        &mut flags,
                                                                                        &mut sec,
                                                                                        &mut value,
                                                                                    )
                                                                                    {
                                                                                        current_block = 12388102377924243912;
                                                                                        break;
                                                                                    }
                                                                                    if name_0.is_null() {
                                                                                        current_block = 5083741289379115417;
                                                                                    } else {
                                                                                        current_block = 15605369199999130895;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 15605369199999130895;
                                                                                }
                                                                                match current_block {
                                                                                    5083741289379115417 => {}
                                                                                    _ => {
                                                                                        if sec.is_null() {
                                                                                            _bfd_abort(
                                                                                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                                                                4776 as libc::c_int,
                                                                                                (*::core::mem::transmute::<
                                                                                                    &[u8; 65],
                                                                                                    &[libc::c_char; 65],
                                                                                                >(
                                                                                                    b"_Bool elf_link_add_object_symbols(bfd *, struct bfd_link_info *)\0",
                                                                                                ))
                                                                                                    .as_ptr(),
                                                                                            );
                                                                                        }
                                                                                        if !((*isym).st_info as libc::c_int & 0xf as libc::c_int
                                                                                            == 6 as libc::c_int
                                                                                            && (*sec).sec_info_type() as libc::c_int
                                                                                                == 4 as libc::c_int)
                                                                                        {
                                                                                            if bfd_is_und_section(sec) as libc::c_int != 0
                                                                                                || bfd_is_com_section(sec) as libc::c_int != 0
                                                                                            {
                                                                                                definition = 0 as libc::c_int != 0;
                                                                                            } else {
                                                                                                definition = 1 as libc::c_int != 0;
                                                                                            }
                                                                                            size_change_ok = 0 as libc::c_int != 0;
                                                                                            type_change_ok = (*bed).type_change_ok() != 0;
                                                                                            old_weak = 0 as libc::c_int != 0;
                                                                                            matched = 0 as libc::c_int != 0;
                                                                                            old_alignment = 0 as libc::c_int as libc::c_uint;
                                                                                            old_bfd = 0 as *mut bfd;
                                                                                            new_sec = sec;
                                                                                            if is_elf_hash_table(&mut (*htab).root) {
                                                                                                let mut iver: Elf_Internal_Versym = Elf_Internal_Versym {
                                                                                                    vs_vers: 0,
                                                                                                };
                                                                                                let mut vernum: libc::c_uint = 0 as libc::c_int
                                                                                                    as libc::c_uint;
                                                                                                let mut skip: bool = false;
                                                                                                if ever.is_null() {
                                                                                                    if (*info).default_imported_symver() != 0 {
                                                                                                        iver
                                                                                                            .vs_vers = (*(*abfd).tdata.elf_obj_data).cverdefs
                                                                                                            as libc::c_ushort;
                                                                                                    } else {
                                                                                                        iver.vs_vers = 0 as libc::c_int as libc::c_ushort;
                                                                                                    }
                                                                                                } else if ever >= extversym_end {
                                                                                                    _bfd_error_handler(
                                                                                                        dcgettext(
                                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                            b"%pB: not enough version information\0" as *const u8
                                                                                                                as *const libc::c_char,
                                                                                                            5 as libc::c_int,
                                                                                                        ),
                                                                                                        abfd,
                                                                                                    );
                                                                                                    bfd_set_error(bfd_error_bad_value);
                                                                                                    current_block = 12388102377924243912;
                                                                                                    break;
                                                                                                } else {
                                                                                                    _bfd_elf_swap_versym_in(abfd, ever, &mut iver);
                                                                                                }
                                                                                                vernum = (iver.vs_vers as libc::c_int
                                                                                                    & 0x7fff as libc::c_int) as libc::c_uint;
                                                                                                if iver.vs_vers as libc::c_int & 0x8000 as libc::c_int
                                                                                                    != 0 as libc::c_int
                                                                                                    || vernum > 1 as libc::c_int as libc::c_uint
                                                                                                        && (!bfd_is_abs_section(sec)
                                                                                                            || ((*bed).is_function_type)
                                                                                                                .expect(
                                                                                                                    "non-null function pointer",
                                                                                                                )(
                                                                                                                ((*isym).st_info as libc::c_int & 0xf as libc::c_int)
                                                                                                                    as libc::c_uint,
                                                                                                            ) as libc::c_int != 0)
                                                                                                {
                                                                                                    let mut verstr: *const libc::c_char = 0
                                                                                                        as *const libc::c_char;
                                                                                                    let mut namelen: size_t = 0;
                                                                                                    let mut verlen: size_t = 0;
                                                                                                    let mut newlen: size_t = 0;
                                                                                                    let mut newname: *mut libc::c_char = 0 as *mut libc::c_char;
                                                                                                    let mut p_1: *mut libc::c_char = 0 as *mut libc::c_char;
                                                                                                    if (*isym).st_shndx != 0 as libc::c_int as libc::c_uint {
                                                                                                        if vernum > (*(*abfd).tdata.elf_obj_data).cverdefs {
                                                                                                            verstr = 0 as *const libc::c_char;
                                                                                                        } else if vernum > 1 as libc::c_int as libc::c_uint {
                                                                                                            verstr = (*((*(*abfd).tdata.elf_obj_data).verdef)
                                                                                                                .offset(
                                                                                                                    vernum.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                                                                                        as isize,
                                                                                                                ))
                                                                                                                .vd_nodename;
                                                                                                        } else {
                                                                                                            verstr = b"\0" as *const u8 as *const libc::c_char;
                                                                                                        }
                                                                                                        if verstr.is_null() {
                                                                                                            _bfd_error_handler(
                                                                                                                dcgettext(
                                                                                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                    b"%pB: %s: invalid version %u (max %d)\0" as *const u8
                                                                                                                        as *const libc::c_char,
                                                                                                                    5 as libc::c_int,
                                                                                                                ),
                                                                                                                abfd,
                                                                                                                name_0,
                                                                                                                vernum,
                                                                                                                (*(*abfd).tdata.elf_obj_data).cverdefs,
                                                                                                            );
                                                                                                            bfd_set_error(bfd_error_bad_value);
                                                                                                            current_block = 12388102377924243912;
                                                                                                            break;
                                                                                                        }
                                                                                                    } else {
                                                                                                        let mut t: *mut Elf_Internal_Verneed = 0
                                                                                                            as *mut Elf_Internal_Verneed;
                                                                                                        verstr = 0 as *const libc::c_char;
                                                                                                        t = (*(*abfd).tdata.elf_obj_data).verref;
                                                                                                        while !t.is_null() {
                                                                                                            let mut a: *mut Elf_Internal_Vernaux = 0
                                                                                                                as *mut Elf_Internal_Vernaux;
                                                                                                            a = (*t).vn_auxptr;
                                                                                                            while !a.is_null() {
                                                                                                                if (*a).vna_other as libc::c_uint == vernum {
                                                                                                                    verstr = (*a).vna_nodename;
                                                                                                                    break;
                                                                                                                } else {
                                                                                                                    a = (*a).vna_nextptr;
                                                                                                                }
                                                                                                            }
                                                                                                            if !a.is_null() {
                                                                                                                break;
                                                                                                            }
                                                                                                            t = (*t).vn_nextref;
                                                                                                        }
                                                                                                        if verstr.is_null() {
                                                                                                            _bfd_error_handler(
                                                                                                                dcgettext(
                                                                                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                    b"%pB: %s: invalid needed version %d\0" as *const u8
                                                                                                                        as *const libc::c_char,
                                                                                                                    5 as libc::c_int,
                                                                                                                ),
                                                                                                                abfd,
                                                                                                                name_0,
                                                                                                                vernum,
                                                                                                            );
                                                                                                            bfd_set_error(bfd_error_bad_value);
                                                                                                            current_block = 12388102377924243912;
                                                                                                            break;
                                                                                                        }
                                                                                                    }
                                                                                                    namelen = strlen(name_0);
                                                                                                    verlen = strlen(verstr);
                                                                                                    newlen = namelen
                                                                                                        .wrapping_add(verlen)
                                                                                                        .wrapping_add(2 as libc::c_int as libc::c_ulong);
                                                                                                    if iver.vs_vers as libc::c_int & 0x8000 as libc::c_int
                                                                                                        == 0 as libc::c_int
                                                                                                        && (*isym).st_shndx != 0 as libc::c_int as libc::c_uint
                                                                                                    {
                                                                                                        newlen = newlen.wrapping_add(1);
                                                                                                        newlen;
                                                                                                    }
                                                                                                    newname = bfd_hash_allocate(
                                                                                                        &mut (*htab).root.table,
                                                                                                        newlen as libc::c_uint,
                                                                                                    ) as *mut libc::c_char;
                                                                                                    if newname.is_null() {
                                                                                                        current_block = 12388102377924243912;
                                                                                                        break;
                                                                                                    }
                                                                                                    memcpy(
                                                                                                        newname as *mut libc::c_void,
                                                                                                        name_0 as *const libc::c_void,
                                                                                                        namelen,
                                                                                                    );
                                                                                                    p_1 = newname.offset(namelen as isize);
                                                                                                    let fresh9 = p_1;
                                                                                                    p_1 = p_1.offset(1);
                                                                                                    *fresh9 = '@' as i32 as libc::c_char;
                                                                                                    if iver.vs_vers as libc::c_int & 0x8000 as libc::c_int
                                                                                                        == 0 as libc::c_int
                                                                                                        && (*isym).st_shndx != 0 as libc::c_int as libc::c_uint
                                                                                                    {
                                                                                                        let fresh10 = p_1;
                                                                                                        p_1 = p_1.offset(1);
                                                                                                        *fresh10 = '@' as i32 as libc::c_char;
                                                                                                    }
                                                                                                    memcpy(
                                                                                                        p_1 as *mut libc::c_void,
                                                                                                        verstr as *const libc::c_void,
                                                                                                        verlen.wrapping_add(1 as libc::c_int as libc::c_ulong),
                                                                                                    );
                                                                                                    name_0 = newname;
                                                                                                }
                                                                                                if !bfd_is_und_section(sec) && !dynamic
                                                                                                    && (*abfd).no_export() as libc::c_int != 0
                                                                                                    && (*isym).st_other as libc::c_int & 0x3 as libc::c_int
                                                                                                        != 1 as libc::c_int
                                                                                                {
                                                                                                    (*isym)
                                                                                                        .st_other = (2 as libc::c_int
                                                                                                        | (*isym).st_other as libc::c_int
                                                                                                            & !(-(1 as libc::c_int) & 0x3 as libc::c_int))
                                                                                                        as libc::c_uchar;
                                                                                                }
                                                                                                if !_bfd_elf_merge_symbol(
                                                                                                    abfd,
                                                                                                    info,
                                                                                                    name_0,
                                                                                                    isym,
                                                                                                    &mut sec,
                                                                                                    &mut value,
                                                                                                    sym_hash,
                                                                                                    &mut old_bfd,
                                                                                                    &mut old_weak,
                                                                                                    &mut old_alignment,
                                                                                                    &mut skip,
                                                                                                    &mut override_0,
                                                                                                    &mut type_change_ok,
                                                                                                    &mut size_change_ok,
                                                                                                    &mut matched,
                                                                                                ) {
                                                                                                    current_block = 12388102377924243912;
                                                                                                    break;
                                                                                                }
                                                                                                if skip {
                                                                                                    current_block = 5083741289379115417;
                                                                                                } else {
                                                                                                    if !override_0.is_null() && matched as libc::c_int != 0 {
                                                                                                        definition = 0 as libc::c_int != 0;
                                                                                                    }
                                                                                                    h_2 = *sym_hash;
                                                                                                    while ((*h_2).root).type_0() as libc::c_int
                                                                                                        == bfd_link_hash_indirect as libc::c_int
                                                                                                        || ((*h_2).root).type_0() as libc::c_int
                                                                                                            == bfd_link_hash_warning as libc::c_int
                                                                                                    {
                                                                                                        h_2 = (*h_2).root.u.i.link as *mut elf_link_hash_entry;
                                                                                                    }
                                                                                                    if !((*(*abfd).tdata.elf_obj_data).verdef).is_null()
                                                                                                        && vernum > 1 as libc::c_int as libc::c_uint
                                                                                                        && definition as libc::c_int != 0
                                                                                                    {
                                                                                                        (*h_2)
                                                                                                            .verinfo
                                                                                                            .verdef = &mut *((*(*abfd).tdata.elf_obj_data).verdef)
                                                                                                            .offset(
                                                                                                                vernum.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                                                                                    as isize,
                                                                                                            ) as *mut Elf_Internal_Verdef;
                                                                                                    }
                                                                                                    current_block = 12639565642609815763;
                                                                                                }
                                                                                            } else {
                                                                                                current_block = 12639565642609815763;
                                                                                            }
                                                                                            match current_block {
                                                                                                5083741289379115417 => {}
                                                                                                _ => {
                                                                                                    if !_bfd_generic_link_add_one_symbol(
                                                                                                        info,
                                                                                                        if !override_0.is_null() { override_0 } else { abfd },
                                                                                                        name_0,
                                                                                                        flags,
                                                                                                        sec,
                                                                                                        value,
                                                                                                        0 as *const libc::c_char,
                                                                                                        0 as libc::c_int != 0,
                                                                                                        (*bed).collect() != 0,
                                                                                                        sym_hash as *mut *mut bfd_link_hash_entry,
                                                                                                    ) {
                                                                                                        current_block = 12388102377924243912;
                                                                                                        break;
                                                                                                    }
                                                                                                    h_2 = *sym_hash;
                                                                                                    hi = h_2;
                                                                                                    while ((*h_2).root).type_0() as libc::c_int
                                                                                                        == bfd_link_hash_indirect as libc::c_int
                                                                                                        || ((*h_2).root).type_0() as libc::c_int
                                                                                                            == bfd_link_hash_warning as libc::c_int
                                                                                                    {
                                                                                                        h_2 = (*h_2).root.u.i.link as *mut elf_link_hash_entry;
                                                                                                    }
                                                                                                    *sym_hash = h_2;
                                                                                                    if discarded as libc::c_int != 0
                                                                                                        && is_elf_hash_table(&mut (*htab).root) as libc::c_int != 0
                                                                                                    {
                                                                                                        (*h_2).indx = -(3 as libc::c_int) as libc::c_long;
                                                                                                    }
                                                                                                    new_weak = flags
                                                                                                        & ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint
                                                                                                        != 0 as libc::c_int as libc::c_uint;
                                                                                                    if dynamic as libc::c_int != 0
                                                                                                        && definition as libc::c_int != 0
                                                                                                        && new_weak as libc::c_int != 0
                                                                                                        && !((*bed).is_function_type)
                                                                                                            .expect(
                                                                                                                "non-null function pointer",
                                                                                                            )(
                                                                                                            ((*isym).st_info as libc::c_int & 0xf as libc::c_int)
                                                                                                                as libc::c_uint,
                                                                                                        )
                                                                                                        && is_elf_hash_table(&mut (*htab).root) as libc::c_int != 0
                                                                                                        && ((*h_2).u.alias).is_null()
                                                                                                    {
                                                                                                        (*h_2).u.alias = weaks;
                                                                                                        weaks = h_2;
                                                                                                    }
                                                                                                    if (common as libc::c_int != 0
                                                                                                        || bfd_is_com_section(sec) as libc::c_int != 0)
                                                                                                        && ((*h_2).root).type_0() as libc::c_int
                                                                                                            == bfd_link_hash_common as libc::c_int
                                                                                                    {
                                                                                                        let mut align: libc::c_uint = 0;
                                                                                                        if common {
                                                                                                            align = bfd_log2((*isym).st_value);
                                                                                                        } else {
                                                                                                            align = (*new_sec).alignment_power;
                                                                                                        }
                                                                                                        if align > old_alignment {
                                                                                                            (*(*h_2).root.u.c.p).alignment_power = align;
                                                                                                        } else {
                                                                                                            (*(*h_2).root.u.c.p).alignment_power = old_alignment;
                                                                                                        }
                                                                                                    }
                                                                                                    if is_elf_hash_table(&mut (*htab).root) {
                                                                                                        let mut dynsym: bool = 0 as libc::c_int != 0;
                                                                                                        if (*abfd).flags & 0x10000 as libc::c_int as libc::c_uint
                                                                                                            != 0 as libc::c_int as libc::c_uint
                                                                                                        {
                                                                                                            if !definition && bind != 2 as libc::c_int {
                                                                                                                (*h_2).set_ref_ir_nonweak(1 as libc::c_int as libc::c_uint);
                                                                                                            }
                                                                                                        } else if !dynamic {
                                                                                                            if !definition {
                                                                                                                (*h_2).set_ref_regular(1 as libc::c_int as libc::c_uint);
                                                                                                                if bind != 2 as libc::c_int {
                                                                                                                    (*h_2)
                                                                                                                        .set_ref_regular_nonweak(1 as libc::c_int as libc::c_uint);
                                                                                                                }
                                                                                                            } else {
                                                                                                                (*h_2).set_def_regular(1 as libc::c_int as libc::c_uint);
                                                                                                                if (*h_2).def_dynamic() != 0 {
                                                                                                                    (*h_2).set_def_dynamic(0 as libc::c_int as libc::c_uint);
                                                                                                                    (*h_2).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
                                                                                                                }
                                                                                                            }
                                                                                                        } else if !definition {
                                                                                                            (*h_2).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
                                                                                                            (*hi).set_ref_dynamic(1 as libc::c_int as libc::c_uint);
                                                                                                        } else {
                                                                                                            (*h_2).set_def_dynamic(1 as libc::c_int as libc::c_uint);
                                                                                                            (*hi).set_def_dynamic(1 as libc::c_int as libc::c_uint);
                                                                                                        }
                                                                                                        if !(h_2 != hi && (*hi).forced_local() as libc::c_int != 0)
                                                                                                        {
                                                                                                            if !dynamic {
                                                                                                                if (*info).type_0() as libc::c_int
                                                                                                                    == type_dll as libc::c_int
                                                                                                                    || (*h_2).def_dynamic() as libc::c_int != 0
                                                                                                                    || (*h_2).ref_dynamic() as libc::c_int != 0
                                                                                                                {
                                                                                                                    dynsym = 1 as libc::c_int != 0;
                                                                                                                }
                                                                                                            } else if (*h_2).def_regular() as libc::c_int != 0
                                                                                                                || (*h_2).ref_regular() as libc::c_int != 0
                                                                                                                || (*h_2).is_weakalias() as libc::c_int != 0
                                                                                                                    && (*weakdef(h_2)).dynindx
                                                                                                                        != -(1 as libc::c_int) as libc::c_long
                                                                                                            {
                                                                                                                dynsym = 1 as libc::c_int != 0;
                                                                                                            }
                                                                                                        }
                                                                                                        if (definition as libc::c_int != 0
                                                                                                            || override_0.is_null()
                                                                                                                && ((*h_2).root).type_0() as libc::c_int
                                                                                                                    == bfd_link_hash_common as libc::c_int)
                                                                                                            && !(hi != h_2
                                                                                                                && (*hi).versioned() as libc::c_int
                                                                                                                    == versioned_hidden as libc::c_int)
                                                                                                        {
                                                                                                            if !_bfd_elf_add_default_symbol(
                                                                                                                abfd,
                                                                                                                info,
                                                                                                                h_2,
                                                                                                                name_0,
                                                                                                                isym,
                                                                                                                sec,
                                                                                                                value,
                                                                                                                &mut old_bfd,
                                                                                                                &mut dynsym,
                                                                                                            ) {
                                                                                                                current_block = 12388102377924243912;
                                                                                                                break;
                                                                                                            }
                                                                                                        }
                                                                                                        if (old_alignment != 0 || common as libc::c_int != 0)
                                                                                                            && ((*h_2).root).type_0() as libc::c_int
                                                                                                                != bfd_link_hash_common as libc::c_int
                                                                                                        {
                                                                                                            let mut common_align: libc::c_uint = 0;
                                                                                                            let mut normal_align: libc::c_uint = 0;
                                                                                                            let mut symbol_align: libc::c_uint = 0;
                                                                                                            let mut normal_bfd: *mut bfd = 0 as *mut bfd;
                                                                                                            let mut common_bfd: *mut bfd = 0 as *mut bfd;
                                                                                                            if !(((*h_2).root).type_0() as libc::c_int
                                                                                                                == bfd_link_hash_defined as libc::c_int
                                                                                                                || ((*h_2).root).type_0() as libc::c_int
                                                                                                                    == bfd_link_hash_defweak as libc::c_int)
                                                                                                            {
                                                                                                                bfd_assert(
                                                                                                                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                                                                                    5115 as libc::c_int,
                                                                                                                );
                                                                                                            }
                                                                                                            symbol_align = (ffs((*h_2).root.u.def.value as libc::c_int)
                                                                                                                - 1 as libc::c_int) as libc::c_uint;
                                                                                                            if !((*(*h_2).root.u.def.section).owner).is_null()
                                                                                                                && (*(*(*h_2).root.u.def.section).owner).flags
                                                                                                                    & (0x40 as libc::c_int | 0x10000 as libc::c_int)
                                                                                                                        as libc::c_uint == 0 as libc::c_int as libc::c_uint
                                                                                                            {
                                                                                                                normal_align = (*(*h_2).root.u.def.section).alignment_power;
                                                                                                                if normal_align > symbol_align {
                                                                                                                    normal_align = symbol_align;
                                                                                                                }
                                                                                                            } else {
                                                                                                                normal_align = symbol_align;
                                                                                                            }
                                                                                                            if old_alignment != 0 {
                                                                                                                common_align = old_alignment;
                                                                                                                common_bfd = old_bfd;
                                                                                                                normal_bfd = abfd;
                                                                                                            } else {
                                                                                                                common_align = bfd_log2((*isym).st_value);
                                                                                                                common_bfd = abfd;
                                                                                                                normal_bfd = old_bfd;
                                                                                                            }
                                                                                                            if normal_align < common_align {
                                                                                                                if normal_bfd.is_null() {
                                                                                                                    _bfd_error_handler(
                                                                                                                        dcgettext(
                                                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                            b"warning: alignment %u of common symbol `%s' in %pB is greater than the alignment (%u) of its section %pA\0"
                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                            5 as libc::c_int,
                                                                                                                        ),
                                                                                                                        (1 as libc::c_int) << common_align,
                                                                                                                        name_0,
                                                                                                                        common_bfd,
                                                                                                                        (1 as libc::c_int) << normal_align,
                                                                                                                        (*h_2).root.u.def.section,
                                                                                                                    );
                                                                                                                } else {
                                                                                                                    _bfd_error_handler(
                                                                                                                        dcgettext(
                                                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                            b"warning: alignment %u of symbol `%s' in %pB is smaller than %u in %pB\0"
                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                            5 as libc::c_int,
                                                                                                                        ),
                                                                                                                        (1 as libc::c_int) << normal_align,
                                                                                                                        name_0,
                                                                                                                        normal_bfd,
                                                                                                                        (1 as libc::c_int) << common_align,
                                                                                                                        common_bfd,
                                                                                                                    );
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        if (*isym).st_size != 0 as libc::c_int as libc::c_ulong
                                                                                                            && (*isym).st_shndx != 0 as libc::c_int as libc::c_uint
                                                                                                            && (definition as libc::c_int != 0
                                                                                                                || (*h_2).size == 0 as libc::c_int as libc::c_ulong)
                                                                                                        {
                                                                                                            if (*h_2).size != 0 as libc::c_int as libc::c_ulong
                                                                                                                && (*h_2).size != (*isym).st_size && !size_change_ok
                                                                                                            {
                                                                                                                _bfd_error_handler(
                                                                                                                    dcgettext(
                                                                                                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                        b"warning: size of symbol `%s' changed from %lu in %pB to %lu in %pB\0"
                                                                                                                            as *const u8 as *const libc::c_char,
                                                                                                                        5 as libc::c_int,
                                                                                                                    ),
                                                                                                                    name_0,
                                                                                                                    (*h_2).size,
                                                                                                                    old_bfd,
                                                                                                                    (*isym).st_size,
                                                                                                                    abfd,
                                                                                                                );
                                                                                                            }
                                                                                                            (*h_2).size = (*isym).st_size;
                                                                                                        }
                                                                                                        if ((*h_2).root).type_0() as libc::c_int
                                                                                                            == bfd_link_hash_common as libc::c_int
                                                                                                        {
                                                                                                            (*h_2).size = (*h_2).root.u.c.size;
                                                                                                        }
                                                                                                        if (*isym).st_info as libc::c_int & 0xf as libc::c_int
                                                                                                            != 0 as libc::c_int
                                                                                                            && (definition as libc::c_int != 0 && !new_weak
                                                                                                                || old_weak as libc::c_int != 0
                                                                                                                    && ((*h_2).root).type_0() as libc::c_int
                                                                                                                        == bfd_link_hash_common as libc::c_int
                                                                                                                || (*h_2).type_0() as libc::c_int == 0 as libc::c_int)
                                                                                                        {
                                                                                                            let mut type_0: libc::c_uint = ((*isym).st_info
                                                                                                                as libc::c_int & 0xf as libc::c_int) as libc::c_uint;
                                                                                                            if type_0 == 10 as libc::c_int as libc::c_uint
                                                                                                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                                                                                                    != 0 as libc::c_int as libc::c_uint
                                                                                                            {
                                                                                                                type_0 = 2 as libc::c_int as libc::c_uint;
                                                                                                            }
                                                                                                            if (*h_2).type_0() != type_0 {
                                                                                                                if (*h_2).type_0() as libc::c_int != 0 as libc::c_int
                                                                                                                    && !type_change_ok
                                                                                                                {
                                                                                                                    _bfd_error_handler(
                                                                                                                        dcgettext(
                                                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                            b"warning: type of symbol `%s' changed from %d to %d in %pB\0"
                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                            5 as libc::c_int,
                                                                                                                        ),
                                                                                                                        name_0,
                                                                                                                        (*h_2).type_0() as libc::c_int,
                                                                                                                        type_0,
                                                                                                                        abfd,
                                                                                                                    );
                                                                                                                }
                                                                                                                (*h_2).set_type_0(type_0);
                                                                                                            }
                                                                                                        }
                                                                                                        elf_merge_st_other(
                                                                                                            abfd,
                                                                                                            h_2,
                                                                                                            (*isym).st_other as libc::c_uint,
                                                                                                            sec,
                                                                                                            definition,
                                                                                                            dynamic,
                                                                                                        );
                                                                                                        if definition as libc::c_int != 0
                                                                                                            && (*sec).flags & 0x2000 as libc::c_int as libc::c_uint != 0
                                                                                                            && !((*info).type_0() as libc::c_int
                                                                                                                == type_relocatable as libc::c_int)
                                                                                                        {
                                                                                                            dynsym = 0 as libc::c_int != 0;
                                                                                                        }
                                                                                                        if (*abfd).flags & 0x10000 as libc::c_int as libc::c_uint
                                                                                                            != 0 as libc::c_int as libc::c_uint
                                                                                                        {
                                                                                                            dynsym = 0 as libc::c_int != 0;
                                                                                                        }
                                                                                                        if definition {
                                                                                                            (*h_2)
                                                                                                                .set_target_internal(
                                                                                                                    (*isym).st_target_internal as libc::c_uint,
                                                                                                                );
                                                                                                            (*h_2)
                                                                                                                .set_unique_global(
                                                                                                                    (flags
                                                                                                                        & ((1 as libc::c_int) << 23 as libc::c_int) as libc::c_uint
                                                                                                                        != 0 as libc::c_int as libc::c_uint) as libc::c_int
                                                                                                                        as libc::c_uint,
                                                                                                                );
                                                                                                        }
                                                                                                        if definition as libc::c_int != 0 && !dynamic {
                                                                                                            let mut p_2: *mut libc::c_char = strchr(name_0, '@' as i32);
                                                                                                            if !p_2.is_null()
                                                                                                                && *p_2.offset(1 as libc::c_int as isize) as libc::c_int
                                                                                                                    != '@' as i32
                                                                                                            {
                                                                                                                if nondeflt_vers.is_null() {
                                                                                                                    let mut amt_4: size_t = ((isymend.offset_from(isym)
                                                                                                                        as libc::c_long + 1 as libc::c_int as libc::c_long)
                                                                                                                        as libc::c_ulong)
                                                                                                                        .wrapping_mul(
                                                                                                                            ::core::mem::size_of::<*mut elf_link_hash_entry>()
                                                                                                                                as libc::c_ulong,
                                                                                                                        );
                                                                                                                    nondeflt_vers = bfd_malloc(amt_4)
                                                                                                                        as *mut *mut elf_link_hash_entry;
                                                                                                                    if nondeflt_vers.is_null() {
                                                                                                                        current_block = 12388102377924243912;
                                                                                                                        break;
                                                                                                                    }
                                                                                                                }
                                                                                                                let fresh11 = nondeflt_vers_cnt;
                                                                                                                nondeflt_vers_cnt = nondeflt_vers_cnt.wrapping_add(1);
                                                                                                                let ref mut fresh12 = *nondeflt_vers
                                                                                                                    .offset(fresh11 as isize);
                                                                                                                *fresh12 = h_2;
                                                                                                            }
                                                                                                        }
                                                                                                        if dynsym as libc::c_int != 0
                                                                                                            && (*h_2).dynindx == -(1 as libc::c_int) as libc::c_long
                                                                                                        {
                                                                                                            if !bfd_elf_link_record_dynamic_symbol(info, h_2) {
                                                                                                                current_block = 12388102377924243912;
                                                                                                                break;
                                                                                                            }
                                                                                                            if (*h_2).is_weakalias() as libc::c_int != 0
                                                                                                                && (*weakdef(h_2)).dynindx
                                                                                                                    == -(1 as libc::c_int) as libc::c_long
                                                                                                            {
                                                                                                                if !bfd_elf_link_record_dynamic_symbol(info, weakdef(h_2)) {
                                                                                                                    current_block = 12388102377924243912;
                                                                                                                    break;
                                                                                                                }
                                                                                                            }
                                                                                                        } else if (*h_2).dynindx
                                                                                                            != -(1 as libc::c_int) as libc::c_long
                                                                                                        {
                                                                                                            match (*h_2).other() as libc::c_int & 0x3 as libc::c_int {
                                                                                                                1 | 2 => {
                                                                                                                    (Some(
                                                                                                                        ((*bed).elf_backend_hide_symbol)
                                                                                                                            .expect("non-null function pointer"),
                                                                                                                    ))
                                                                                                                        .expect(
                                                                                                                            "non-null function pointer",
                                                                                                                        )(info, h_2, 1 as libc::c_int != 0);
                                                                                                                    dynsym = 0 as libc::c_int != 0;
                                                                                                                }
                                                                                                                _ => {}
                                                                                                            }
                                                                                                        }
                                                                                                        if !add_needed && matched as libc::c_int != 0
                                                                                                            && definition as libc::c_int != 0
                                                                                                            && ((*h_2).root).type_0() as libc::c_int
                                                                                                                != bfd_link_hash_indirect as libc::c_int
                                                                                                            && (dynsym as libc::c_int != 0
                                                                                                                && (*h_2).ref_regular_nonweak() as libc::c_int != 0
                                                                                                                || !old_bfd.is_null()
                                                                                                                    && (*old_bfd).flags & 0x10000 as libc::c_int as libc::c_uint
                                                                                                                        != 0 as libc::c_int as libc::c_uint
                                                                                                                    && (*h_2).ref_ir_nonweak() as libc::c_int != 0
                                                                                                                    && (*info).lto_all_symbols_read() == 0
                                                                                                                || (*h_2).ref_dynamic_nonweak() as libc::c_int != 0
                                                                                                                    && (*(*abfd).tdata.elf_obj_data).dyn_lib_class()
                                                                                                                        as libc::c_int & DYN_AS_NEEDED as libc::c_int
                                                                                                                        != 0 as libc::c_int
                                                                                                                    && !on_needed_list(
                                                                                                                        (*(*abfd).tdata.elf_obj_data).dt_name,
                                                                                                                        (*htab).needed,
                                                                                                                        0 as *mut bfd_link_needed_list,
                                                                                                                    ))
                                                                                                        {
                                                                                                            let mut soname_0: *const libc::c_char = (*(*abfd)
                                                                                                                .tdata
                                                                                                                .elf_obj_data)
                                                                                                                .dt_name;
                                                                                                            ((*(*info).callbacks).minfo)
                                                                                                                .expect(
                                                                                                                    "non-null function pointer",
                                                                                                                )(
                                                                                                                b"%!\0" as *const u8 as *const libc::c_char,
                                                                                                                soname_0,
                                                                                                                old_bfd,
                                                                                                                (*h_2).root.root.string,
                                                                                                            );
                                                                                                            if !old_bfd.is_null()
                                                                                                                && (*(*abfd).tdata.elf_obj_data).dyn_lib_class()
                                                                                                                    as libc::c_int & DYN_NO_NEEDED as libc::c_int
                                                                                                                    != 0 as libc::c_int
                                                                                                            {
                                                                                                                _bfd_error_handler(
                                                                                                                    dcgettext(
                                                                                                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                        b"%pB: undefined reference to symbol '%s'\0" as *const u8
                                                                                                                            as *const libc::c_char,
                                                                                                                        5 as libc::c_int,
                                                                                                                    ),
                                                                                                                    old_bfd,
                                                                                                                    name_0,
                                                                                                                );
                                                                                                                bfd_set_error(bfd_error_missing_dso);
                                                                                                                current_block = 12388102377924243912;
                                                                                                                break;
                                                                                                            } else {
                                                                                                                (*(*abfd).tdata.elf_obj_data)
                                                                                                                    .set_dyn_lib_class(
                                                                                                                        ((*(*abfd).tdata.elf_obj_data).dyn_lib_class()
                                                                                                                            as libc::c_int & !(DYN_AS_NEEDED as libc::c_int))
                                                                                                                            as dynamic_lib_link_class,
                                                                                                                    );
                                                                                                                if !_bfd_elf_link_create_dynamic_sections(abfd, info) {
                                                                                                                    return 0 as libc::c_int != 0;
                                                                                                                }
                                                                                                                add_needed = 1 as libc::c_int != 0;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            _ => {}
                                                                        }
                                                                        isym = isym.offset(1);
                                                                        isym;
                                                                        sym_hash = sym_hash.offset(1);
                                                                        sym_hash;
                                                                        ever = if !ever.is_null() {
                                                                            ever.offset(1 as libc::c_int as isize)
                                                                        } else {
                                                                            0 as *mut Elf_External_Versym
                                                                        };
                                                                    }
                                                                    match current_block {
                                                                        12388102377924243912 => {}
                                                                        _ => {
                                                                            if (*info).lto_plugin_active() as libc::c_int != 0
                                                                                && !((*info).type_0() as libc::c_int
                                                                                    == type_relocatable as libc::c_int)
                                                                                && (*abfd).flags & 0x10000 as libc::c_int as libc::c_uint
                                                                                    == 0 as libc::c_int as libc::c_uint && !just_syms
                                                                                && extsymcount != 0
                                                                            {
                                                                                let mut r_sym_shift: libc::c_int = 0;
                                                                                if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int
                                                                                {
                                                                                    r_sym_shift = 8 as libc::c_int;
                                                                                } else {
                                                                                    r_sym_shift = 32 as libc::c_int;
                                                                                }
                                                                                sym_hash = (*(*abfd).tdata.elf_obj_data).sym_hashes;
                                                                                s = (*abfd).sections;
                                                                                loop {
                                                                                    if s.is_null() {
                                                                                        current_block = 13318420046254773891;
                                                                                        break;
                                                                                    }
                                                                                    let mut internal_relocs: *mut Elf_Internal_Rela = 0
                                                                                        as *mut Elf_Internal_Rela;
                                                                                    let mut rel: *mut Elf_Internal_Rela = 0
                                                                                        as *mut Elf_Internal_Rela;
                                                                                    let mut relend: *mut Elf_Internal_Rela = 0
                                                                                        as *mut Elf_Internal_Rela;
                                                                                    if !((*s).flags & 0x4 as libc::c_int as libc::c_uint
                                                                                        == 0 as libc::c_int as libc::c_uint
                                                                                        || (*s).reloc_count == 0 as libc::c_int as libc::c_uint
                                                                                        || (*s).flags & 0x8000 as libc::c_int as libc::c_uint
                                                                                            != 0 as libc::c_int as libc::c_uint
                                                                                        || ((*info).strip() as libc::c_int
                                                                                            == strip_all as libc::c_int
                                                                                            || (*info).strip() as libc::c_int
                                                                                                == strip_debugger as libc::c_int)
                                                                                            && (*s).flags & 0x2000 as libc::c_int as libc::c_uint
                                                                                                != 0 as libc::c_int as libc::c_uint)
                                                                                    {
                                                                                        internal_relocs = _bfd_elf_link_read_relocs(
                                                                                            abfd,
                                                                                            s,
                                                                                            0 as *mut libc::c_void,
                                                                                            0 as *mut Elf_Internal_Rela,
                                                                                            (*info).keep_memory() != 0,
                                                                                        );
                                                                                        if internal_relocs.is_null() {
                                                                                            current_block = 12388102377924243912;
                                                                                            break;
                                                                                        }
                                                                                        rel = internal_relocs;
                                                                                        relend = rel.offset((*s).reloc_count as isize);
                                                                                        while rel < relend {
                                                                                            let mut r_symndx: libc::c_ulong = (*rel).r_info
                                                                                                >> r_sym_shift;
                                                                                            let mut h_3: *mut elf_link_hash_entry = 0
                                                                                                as *mut elf_link_hash_entry;
                                                                                            if !(r_symndx < extsymoff) {
                                                                                                h_3 = *sym_hash
                                                                                                    .offset(r_symndx.wrapping_sub(extsymoff) as isize);
                                                                                                if !h_3.is_null() {
                                                                                                    ((*h_3).root)
                                                                                                        .set_non_ir_ref_regular(1 as libc::c_int as libc::c_uint);
                                                                                                }
                                                                                            }
                                                                                            rel = rel.offset(1);
                                                                                            rel;
                                                                                        }
                                                                                        if (*((*s).used_by_bfd as *mut bfd_elf_section_data)).relocs
                                                                                            != internal_relocs
                                                                                        {
                                                                                            free(internal_relocs as *mut libc::c_void);
                                                                                        }
                                                                                    }
                                                                                    s = (*s).next;
                                                                                }
                                                                            } else {
                                                                                current_block = 13318420046254773891;
                                                                            }
                                                                            match current_block {
                                                                                12388102377924243912 => {}
                                                                                _ => {
                                                                                    free(extversym as *mut libc::c_void);
                                                                                    extversym = 0 as *mut Elf_External_Versym;
                                                                                    free(isymbuf as *mut libc::c_void);
                                                                                    isymbuf = 0 as *mut Elf_Internal_Sym;
                                                                                    if (*(*abfd).tdata.elf_obj_data).dyn_lib_class()
                                                                                        as libc::c_int & DYN_AS_NEEDED as libc::c_int
                                                                                        != 0 as libc::c_int
                                                                                    {
                                                                                        let mut i_0: libc::c_uint = 0;
                                                                                        old_ent = (old_tab as *mut libc::c_char)
                                                                                            .offset(tabsize as isize) as *mut libc::c_void;
                                                                                        memset(
                                                                                            (*(*abfd).tdata.elf_obj_data).sym_hashes
                                                                                                as *mut libc::c_void,
                                                                                            0 as libc::c_int,
                                                                                            extsymcount
                                                                                                .wrapping_mul(
                                                                                                    ::core::mem::size_of::<*mut elf_link_hash_entry>()
                                                                                                        as libc::c_ulong,
                                                                                                ),
                                                                                        );
                                                                                        (*htab).root.table.table = old_table;
                                                                                        (*htab).root.table.size = old_size;
                                                                                        (*htab).root.table.count = old_count;
                                                                                        memcpy(
                                                                                            (*htab).root.table.table as *mut libc::c_void,
                                                                                            old_tab,
                                                                                            tabsize,
                                                                                        );
                                                                                        (*htab).root.undefs = old_undefs;
                                                                                        (*htab).root.undefs_tail = old_undefs_tail;
                                                                                        if !((*htab).dynstr).is_null() {
                                                                                            _bfd_elf_strtab_restore((*htab).dynstr, old_strtab);
                                                                                        }
                                                                                        free(old_strtab);
                                                                                        old_strtab = 0 as *mut libc::c_void;
                                                                                        i_0 = 0 as libc::c_int as libc::c_uint;
                                                                                        while i_0 < (*htab).root.table.size {
                                                                                            let mut p_3: *mut bfd_hash_entry = 0 as *mut bfd_hash_entry;
                                                                                            let mut h_4: *mut elf_link_hash_entry = 0
                                                                                                as *mut elf_link_hash_entry;
                                                                                            let mut non_ir_ref_dynamic: libc::c_uint = 0;
                                                                                            p_3 = *((*htab).root.table.table).offset(i_0 as isize);
                                                                                            while !p_3.is_null() {
                                                                                                h_4 = p_3 as *mut elf_link_hash_entry;
                                                                                                if ((*h_4).root).type_0() as libc::c_int
                                                                                                    == bfd_link_hash_warning as libc::c_int
                                                                                                {
                                                                                                    h_4 = (*h_4).root.u.i.link as *mut elf_link_hash_entry;
                                                                                                }
                                                                                                non_ir_ref_dynamic = ((*h_4).root).non_ir_ref_dynamic();
                                                                                                h_4 = p_3 as *mut elf_link_hash_entry;
                                                                                                memcpy(
                                                                                                    h_4 as *mut libc::c_void,
                                                                                                    old_ent,
                                                                                                    (*htab).root.table.entsize as libc::c_ulong,
                                                                                                );
                                                                                                old_ent = (old_ent as *mut libc::c_char)
                                                                                                    .offset((*htab).root.table.entsize as isize)
                                                                                                    as *mut libc::c_void;
                                                                                                if ((*h_4).root).type_0() as libc::c_int
                                                                                                    == bfd_link_hash_warning as libc::c_int
                                                                                                {
                                                                                                    h_4 = (*h_4).root.u.i.link as *mut elf_link_hash_entry;
                                                                                                    memcpy(
                                                                                                        h_4 as *mut libc::c_void,
                                                                                                        old_ent,
                                                                                                        (*htab).root.table.entsize as libc::c_ulong,
                                                                                                    );
                                                                                                    old_ent = (old_ent as *mut libc::c_char)
                                                                                                        .offset((*htab).root.table.entsize as isize)
                                                                                                        as *mut libc::c_void;
                                                                                                }
                                                                                                if ((*h_4).root).type_0() as libc::c_int
                                                                                                    == bfd_link_hash_common as libc::c_int
                                                                                                {
                                                                                                    memcpy(
                                                                                                        (*h_4).root.u.c.p as *mut libc::c_void,
                                                                                                        old_ent,
                                                                                                        ::core::mem::size_of::<bfd_link_hash_common_entry>()
                                                                                                            as libc::c_ulong,
                                                                                                    );
                                                                                                    old_ent = (old_ent as *mut libc::c_char)
                                                                                                        .offset(
                                                                                                            ::core::mem::size_of::<bfd_link_hash_common_entry>()
                                                                                                                as libc::c_ulong as isize,
                                                                                                        ) as *mut libc::c_void;
                                                                                                }
                                                                                                ((*h_4).root).set_non_ir_ref_dynamic(non_ir_ref_dynamic);
                                                                                                p_3 = (*p_3).next;
                                                                                            }
                                                                                            i_0 = i_0.wrapping_add(1);
                                                                                            i_0;
                                                                                        }
                                                                                        if !(Some(
                                                                                            ((*bed).notice_as_needed)
                                                                                                .expect("non-null function pointer"),
                                                                                        ))
                                                                                            .expect(
                                                                                                "non-null function pointer",
                                                                                            )(abfd, info, notice_not_needed)
                                                                                        {
                                                                                            current_block = 12388102377924243912;
                                                                                        } else {
                                                                                            free(old_tab);
                                                                                            objalloc_free_block(
                                                                                                (*htab).root.table.memory as *mut objalloc,
                                                                                                alloc_mark,
                                                                                            );
                                                                                            free(nondeflt_vers as *mut libc::c_void);
                                                                                            return 1 as libc::c_int != 0;
                                                                                        }
                                                                                    } else {
                                                                                        if !old_tab.is_null() {
                                                                                            if !(Some(
                                                                                                ((*bed).notice_as_needed)
                                                                                                    .expect("non-null function pointer"),
                                                                                            ))
                                                                                                .expect(
                                                                                                    "non-null function pointer",
                                                                                                )(abfd, info, notice_needed)
                                                                                            {
                                                                                                current_block = 12388102377924243912;
                                                                                            } else {
                                                                                                free(old_tab);
                                                                                                old_tab = 0 as *mut libc::c_void;
                                                                                                current_block = 15123573589838836496;
                                                                                            }
                                                                                        } else {
                                                                                            current_block = 15123573589838836496;
                                                                                        }
                                                                                        match current_block {
                                                                                            12388102377924243912 => {}
                                                                                            _ => {
                                                                                                if !((*info).type_0() as libc::c_int
                                                                                                    == type_relocatable as libc::c_int)
                                                                                                    && !nondeflt_vers.is_null()
                                                                                                {
                                                                                                    let mut cnt: size_t = 0;
                                                                                                    let mut symidx: size_t = 0;
                                                                                                    cnt = 0 as libc::c_int as size_t;
                                                                                                    loop {
                                                                                                        if !(cnt < nondeflt_vers_cnt) {
                                                                                                            current_block = 14465346043397729206;
                                                                                                            break;
                                                                                                        }
                                                                                                        let mut h_5: *mut elf_link_hash_entry = *nondeflt_vers
                                                                                                            .offset(cnt as isize);
                                                                                                        let mut hi_0: *mut elf_link_hash_entry = 0
                                                                                                            as *mut elf_link_hash_entry;
                                                                                                        let mut shortname: *mut libc::c_char = 0
                                                                                                            as *mut libc::c_char;
                                                                                                        let mut p_4: *mut libc::c_char = 0 as *mut libc::c_char;
                                                                                                        let mut amt_5: size_t = 0;
                                                                                                        p_4 = strchr((*h_5).root.root.string, '@' as i32);
                                                                                                        if !(p_4.is_null()
                                                                                                            || ((*h_5).root).type_0() as libc::c_int
                                                                                                                != bfd_link_hash_defined as libc::c_int
                                                                                                                && ((*h_5).root).type_0() as libc::c_int
                                                                                                                    != bfd_link_hash_defweak as libc::c_int)
                                                                                                        {
                                                                                                            amt_5 = p_4.offset_from((*h_5).root.root.string)
                                                                                                                as libc::c_long as size_t;
                                                                                                            shortname = bfd_malloc(
                                                                                                                amt_5.wrapping_add(1 as libc::c_int as libc::c_ulong),
                                                                                                            ) as *mut libc::c_char;
                                                                                                            if shortname.is_null() {
                                                                                                                current_block = 12388102377924243912;
                                                                                                                break;
                                                                                                            }
                                                                                                            memcpy(
                                                                                                                shortname as *mut libc::c_void,
                                                                                                                (*h_5).root.root.string as *const libc::c_void,
                                                                                                                amt_5,
                                                                                                            );
                                                                                                            *shortname
                                                                                                                .offset(amt_5 as isize) = '\0' as i32 as libc::c_char;
                                                                                                            hi_0 = bfd_link_hash_lookup(
                                                                                                                &mut (*htab).root,
                                                                                                                shortname,
                                                                                                                0 as libc::c_int != 0,
                                                                                                                0 as libc::c_int != 0,
                                                                                                                0 as libc::c_int != 0,
                                                                                                            ) as *mut elf_link_hash_entry;
                                                                                                            if !hi_0.is_null()
                                                                                                                && ((*hi_0).root).type_0() as libc::c_int
                                                                                                                    == ((*h_5).root).type_0() as libc::c_int
                                                                                                                && (*hi_0).root.u.def.value == (*h_5).root.u.def.value
                                                                                                                && (*hi_0).root.u.def.section == (*h_5).root.u.def.section
                                                                                                            {
                                                                                                                (Some(
                                                                                                                    ((*bed).elf_backend_hide_symbol)
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(info, hi_0, 1 as libc::c_int != 0);
                                                                                                                ((*hi_0).root).set_type_0(bfd_link_hash_indirect);
                                                                                                                (*hi_0).root.u.i.link = h_5 as *mut bfd_link_hash_entry;
                                                                                                                (Some(
                                                                                                                    ((*bed).elf_backend_copy_indirect_symbol)
                                                                                                                        .expect("non-null function pointer"),
                                                                                                                ))
                                                                                                                    .expect("non-null function pointer")(info, h_5, hi_0);
                                                                                                                sym_hash = (*(*abfd).tdata.elf_obj_data).sym_hashes;
                                                                                                                if !sym_hash.is_null() {
                                                                                                                    symidx = 0 as libc::c_int as size_t;
                                                                                                                    while symidx < extsymcount {
                                                                                                                        if *sym_hash.offset(symidx as isize) == hi_0 {
                                                                                                                            let ref mut fresh13 = *sym_hash.offset(symidx as isize);
                                                                                                                            *fresh13 = h_5;
                                                                                                                            break;
                                                                                                                        } else {
                                                                                                                            symidx = symidx.wrapping_add(1);
                                                                                                                            symidx;
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            free(shortname as *mut libc::c_void);
                                                                                                        }
                                                                                                        cnt = cnt.wrapping_add(1);
                                                                                                        cnt;
                                                                                                    }
                                                                                                    match current_block {
                                                                                                        12388102377924243912 => {}
                                                                                                        _ => {
                                                                                                            free(nondeflt_vers as *mut libc::c_void);
                                                                                                            nondeflt_vers = 0 as *mut *mut elf_link_hash_entry;
                                                                                                            current_block = 18076970406079194302;
                                                                                                        }
                                                                                                    }
                                                                                                } else {
                                                                                                    current_block = 18076970406079194302;
                                                                                                }
                                                                                                match current_block {
                                                                                                    12388102377924243912 => {}
                                                                                                    _ => {
                                                                                                        if !weaks.is_null() {
                                                                                                            let mut hpp: *mut *mut elf_link_hash_entry = 0
                                                                                                                as *mut *mut elf_link_hash_entry;
                                                                                                            let mut hppend: *mut *mut elf_link_hash_entry = 0
                                                                                                                as *mut *mut elf_link_hash_entry;
                                                                                                            let mut sorted_sym_hash: *mut *mut elf_link_hash_entry = 0
                                                                                                                as *mut *mut elf_link_hash_entry;
                                                                                                            let mut h_6: *mut elf_link_hash_entry = 0
                                                                                                                as *mut elf_link_hash_entry;
                                                                                                            let mut sym_count: size_t = 0;
                                                                                                            let mut amt_6: size_t = 0;
                                                                                                            amt_6 = extsymcount
                                                                                                                .wrapping_mul(
                                                                                                                    ::core::mem::size_of::<*mut elf_link_hash_entry>()
                                                                                                                        as libc::c_ulong,
                                                                                                                );
                                                                                                            sorted_sym_hash = bfd_malloc(amt_6)
                                                                                                                as *mut *mut elf_link_hash_entry;
                                                                                                            if sorted_sym_hash.is_null() {
                                                                                                                current_block = 4312853273767610164;
                                                                                                            } else {
                                                                                                                sym_hash = sorted_sym_hash;
                                                                                                                hpp = (*(*abfd).tdata.elf_obj_data).sym_hashes;
                                                                                                                hppend = hpp.offset(extsymcount as isize);
                                                                                                                sym_count = 0 as libc::c_int as size_t;
                                                                                                                while hpp < hppend {
                                                                                                                    h_6 = *hpp;
                                                                                                                    if !h_6.is_null()
                                                                                                                        && ((*h_6).root).type_0() as libc::c_int
                                                                                                                            == bfd_link_hash_defined as libc::c_int
                                                                                                                        && !((*bed).is_function_type)
                                                                                                                            .expect("non-null function pointer")((*h_6).type_0())
                                                                                                                    {
                                                                                                                        *sym_hash = h_6;
                                                                                                                        sym_hash = sym_hash.offset(1);
                                                                                                                        sym_hash;
                                                                                                                        sym_count = sym_count.wrapping_add(1);
                                                                                                                        sym_count;
                                                                                                                    }
                                                                                                                    hpp = hpp.offset(1);
                                                                                                                    hpp;
                                                                                                                }
                                                                                                                qsort(
                                                                                                                    sorted_sym_hash as *mut libc::c_void,
                                                                                                                    sym_count,
                                                                                                                    ::core::mem::size_of::<*mut elf_link_hash_entry>()
                                                                                                                        as libc::c_ulong,
                                                                                                                    Some(
                                                                                                                        elf_sort_symbol
                                                                                                                            as unsafe extern "C" fn(
                                                                                                                                *const libc::c_void,
                                                                                                                                *const libc::c_void,
                                                                                                                            ) -> libc::c_int,
                                                                                                                    ),
                                                                                                                );
                                                                                                                's_2743: loop {
                                                                                                                    if weaks.is_null() {
                                                                                                                        current_block = 18347705837794011157;
                                                                                                                        break;
                                                                                                                    }
                                                                                                                    let mut hlook: *mut elf_link_hash_entry = 0
                                                                                                                        as *mut elf_link_hash_entry;
                                                                                                                    let mut slook: *mut asection = 0 as *mut asection;
                                                                                                                    let mut vlook: bfd_vma = 0;
                                                                                                                    let mut i_1: size_t = 0;
                                                                                                                    let mut j: size_t = 0;
                                                                                                                    let mut idx: size_t = 0 as libc::c_int as size_t;
                                                                                                                    hlook = weaks;
                                                                                                                    weaks = (*hlook).u.alias;
                                                                                                                    (*hlook).u.alias = 0 as *mut elf_link_hash_entry;
                                                                                                                    if ((*hlook).root).type_0() as libc::c_int
                                                                                                                        != bfd_link_hash_defined as libc::c_int
                                                                                                                        && ((*hlook).root).type_0() as libc::c_int
                                                                                                                            != bfd_link_hash_defweak as libc::c_int
                                                                                                                    {
                                                                                                                        continue;
                                                                                                                    }
                                                                                                                    slook = (*hlook).root.u.def.section;
                                                                                                                    vlook = (*hlook).root.u.def.value;
                                                                                                                    i_1 = 0 as libc::c_int as size_t;
                                                                                                                    j = sym_count;
                                                                                                                    while i_1 != j {
                                                                                                                        let mut vdiff: bfd_signed_vma = 0;
                                                                                                                        idx = i_1
                                                                                                                            .wrapping_add(j)
                                                                                                                            .wrapping_div(2 as libc::c_int as libc::c_ulong);
                                                                                                                        h_6 = *sorted_sym_hash.offset(idx as isize);
                                                                                                                        vdiff = vlook.wrapping_sub((*h_6).root.u.def.value)
                                                                                                                            as bfd_signed_vma;
                                                                                                                        if vdiff < 0 as libc::c_int as libc::c_long {
                                                                                                                            j = idx;
                                                                                                                        } else if vdiff > 0 as libc::c_int as libc::c_long {
                                                                                                                            i_1 = idx.wrapping_add(1 as libc::c_int as libc::c_ulong);
                                                                                                                        } else {
                                                                                                                            let mut sdiff: libc::c_int = ((*slook).id)
                                                                                                                                .wrapping_sub((*(*h_6).root.u.def.section).id)
                                                                                                                                as libc::c_int;
                                                                                                                            if sdiff < 0 as libc::c_int {
                                                                                                                                j = idx;
                                                                                                                            } else {
                                                                                                                                if !(sdiff > 0 as libc::c_int) {
                                                                                                                                    break;
                                                                                                                                }
                                                                                                                                i_1 = idx.wrapping_add(1 as libc::c_int as libc::c_ulong);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    if i_1 == j {
                                                                                                                        continue;
                                                                                                                    }
                                                                                                                    loop {
                                                                                                                        idx = idx.wrapping_add(1);
                                                                                                                        if !(idx != j) {
                                                                                                                            break;
                                                                                                                        }
                                                                                                                        h_6 = *sorted_sym_hash.offset(idx as isize);
                                                                                                                        if (*h_6).root.u.def.section != slook
                                                                                                                            || (*h_6).root.u.def.value != vlook
                                                                                                                        {
                                                                                                                            break;
                                                                                                                        }
                                                                                                                    }
                                                                                                                    loop {
                                                                                                                        let fresh14 = idx;
                                                                                                                        idx = idx.wrapping_sub(1);
                                                                                                                        if !(fresh14 != i_1) {
                                                                                                                            break;
                                                                                                                        }
                                                                                                                        h_6 = *sorted_sym_hash.offset(idx as isize);
                                                                                                                        if (*h_6).root.u.def.section != slook
                                                                                                                            || (*h_6).root.u.def.value != vlook
                                                                                                                        {
                                                                                                                            break;
                                                                                                                        }
                                                                                                                        if !(h_6 != hlook) {
                                                                                                                            continue;
                                                                                                                        }
                                                                                                                        let mut t_0: *mut elf_link_hash_entry = 0
                                                                                                                            as *mut elf_link_hash_entry;
                                                                                                                        (*hlook).u.alias = h_6;
                                                                                                                        (*hlook).set_is_weakalias(1 as libc::c_int as libc::c_uint);
                                                                                                                        t_0 = h_6;
                                                                                                                        if !((*t_0).u.alias).is_null() {
                                                                                                                            while (*t_0).u.alias != h_6 {
                                                                                                                                t_0 = (*t_0).u.alias;
                                                                                                                            }
                                                                                                                        }
                                                                                                                        (*t_0).u.alias = hlook;
                                                                                                                        if (*hlook).dynindx != -(1 as libc::c_int) as libc::c_long
                                                                                                                            && (*h_6).dynindx == -(1 as libc::c_int) as libc::c_long
                                                                                                                        {
                                                                                                                            if !bfd_elf_link_record_dynamic_symbol(info, h_6) {
                                                                                                                                current_block = 1891504891073064456;
                                                                                                                            } else {
                                                                                                                                current_block = 10233577486631131637;
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            current_block = 10233577486631131637;
                                                                                                                        }
                                                                                                                        match current_block {
                                                                                                                            10233577486631131637 => {
                                                                                                                                if !((*h_6).dynindx != -(1 as libc::c_int) as libc::c_long
                                                                                                                                    && (*hlook).dynindx == -(1 as libc::c_int) as libc::c_long)
                                                                                                                                {
                                                                                                                                    break;
                                                                                                                                }
                                                                                                                                if bfd_elf_link_record_dynamic_symbol(info, hlook) {
                                                                                                                                    break;
                                                                                                                                }
                                                                                                                            }
                                                                                                                            _ => {}
                                                                                                                        }
                                                                                                                        free(sorted_sym_hash as *mut libc::c_void);
                                                                                                                        current_block = 4312853273767610164;
                                                                                                                        break 's_2743;
                                                                                                                    }
                                                                                                                }
                                                                                                                match current_block {
                                                                                                                    4312853273767610164 => {}
                                                                                                                    _ => {
                                                                                                                        free(sorted_sym_hash as *mut libc::c_void);
                                                                                                                        current_block = 1572327880045091034;
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        } else {
                                                                                                            current_block = 1572327880045091034;
                                                                                                        }
                                                                                                        match current_block {
                                                                                                            4312853273767610164 => {}
                                                                                                            _ => {
                                                                                                                if ((*bed).check_directives).is_some()
                                                                                                                    && !(Some(
                                                                                                                        ((*bed).check_directives)
                                                                                                                            .expect("non-null function pointer"),
                                                                                                                    ))
                                                                                                                        .expect("non-null function pointer")(abfd, info)
                                                                                                                {
                                                                                                                    return 0 as libc::c_int != 0;
                                                                                                                }
                                                                                                                if !dynamic && (*info).traditional_format() == 0
                                                                                                                    && is_elf_hash_table(&mut (*htab).root) as libc::c_int != 0
                                                                                                                    && ((*info).strip() as libc::c_int
                                                                                                                        != strip_all as libc::c_int
                                                                                                                        && (*info).strip() as libc::c_int
                                                                                                                            != strip_debugger as libc::c_int)
                                                                                                                {
                                                                                                                    let mut stabstr: *mut asection = 0 as *mut asection;
                                                                                                                    stabstr = bfd_get_section_by_name(
                                                                                                                        abfd,
                                                                                                                        b".stabstr\0" as *const u8 as *const libc::c_char,
                                                                                                                    );
                                                                                                                    if !stabstr.is_null() {
                                                                                                                        let mut string_offset: bfd_size_type = 0 as libc::c_int
                                                                                                                            as bfd_size_type;
                                                                                                                        let mut stab: *mut asection = 0 as *mut asection;
                                                                                                                        stab = (*abfd).sections;
                                                                                                                        loop {
                                                                                                                            if stab.is_null() {
                                                                                                                                current_block = 14462084696244767426;
                                                                                                                                break;
                                                                                                                            }
                                                                                                                            if startswith(
                                                                                                                                (*stab).name,
                                                                                                                                b".stab\0" as *const u8 as *const libc::c_char,
                                                                                                                            ) as libc::c_int != 0
                                                                                                                                && (*((*stab).name).offset(5 as libc::c_int as isize) == 0
                                                                                                                                    || *((*stab).name).offset(5 as libc::c_int as isize)
                                                                                                                                        as libc::c_int == '.' as i32
                                                                                                                                        && _sch_istable[(*((*stab).name)
                                                                                                                                            .offset(6 as libc::c_int as isize) as libc::c_int
                                                                                                                                            & 0xff as libc::c_int) as usize] as libc::c_int
                                                                                                                                            & _sch_isdigit as libc::c_int as libc::c_ushort
                                                                                                                                                as libc::c_int != 0)
                                                                                                                                && (*stab).flags & 0x800000 as libc::c_int as libc::c_uint
                                                                                                                                    == 0 as libc::c_int as libc::c_uint
                                                                                                                                && !bfd_is_abs_section((*stab).output_section)
                                                                                                                            {
                                                                                                                                let mut secdata: *mut bfd_elf_section_data = 0
                                                                                                                                    as *mut bfd_elf_section_data;
                                                                                                                                secdata = (*stab).used_by_bfd as *mut bfd_elf_section_data;
                                                                                                                                if !_bfd_link_section_stabs(
                                                                                                                                    abfd,
                                                                                                                                    &mut (*htab).stab_info,
                                                                                                                                    stab,
                                                                                                                                    stabstr,
                                                                                                                                    &mut (*secdata).sec_info,
                                                                                                                                    &mut string_offset,
                                                                                                                                ) {
                                                                                                                                    current_block = 4312853273767610164;
                                                                                                                                    break;
                                                                                                                                }
                                                                                                                                if !((*secdata).sec_info).is_null() {
                                                                                                                                    (*stab).set_sec_info_type(1 as libc::c_int as libc::c_uint);
                                                                                                                                }
                                                                                                                            }
                                                                                                                            stab = (*stab).next;
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        current_block = 14462084696244767426;
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    current_block = 14462084696244767426;
                                                                                                                }
                                                                                                                match current_block {
                                                                                                                    4312853273767610164 => {}
                                                                                                                    _ => {
                                                                                                                        if dynamic as libc::c_int != 0
                                                                                                                            && add_needed as libc::c_int != 0
                                                                                                                        {
                                                                                                                            let mut n_2: *mut elf_link_loaded_list = 0
                                                                                                                                as *mut elf_link_loaded_list;
                                                                                                                            n_2 = bfd_alloc(
                                                                                                                                abfd,
                                                                                                                                ::core::mem::size_of::<elf_link_loaded_list>()
                                                                                                                                    as libc::c_ulong,
                                                                                                                            ) as *mut elf_link_loaded_list;
                                                                                                                            if n_2.is_null() {
                                                                                                                                current_block = 4312853273767610164;
                                                                                                                            } else {
                                                                                                                                (*n_2).abfd = abfd;
                                                                                                                                (*n_2).next = (*htab).dyn_loaded;
                                                                                                                                (*htab).dyn_loaded = n_2;
                                                                                                                                current_block = 14173478506816971609;
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            current_block = 14173478506816971609;
                                                                                                                        }
                                                                                                                        match current_block {
                                                                                                                            4312853273767610164 => {}
                                                                                                                            _ => {
                                                                                                                                if dynamic as libc::c_int != 0 && !add_needed
                                                                                                                                    && (*(*abfd).tdata.elf_obj_data).dyn_lib_class()
                                                                                                                                        as libc::c_int & DYN_DT_NEEDED as libc::c_int
                                                                                                                                        != 0 as libc::c_int
                                                                                                                                {
                                                                                                                                    (*(*abfd).tdata.elf_obj_data)
                                                                                                                                        .set_dyn_lib_class(
                                                                                                                                            (*(*abfd).tdata.elf_obj_data).dyn_lib_class()
                                                                                                                                                | DYN_NO_NEEDED as libc::c_int as dynamic_lib_link_class,
                                                                                                                                        );
                                                                                                                                }
                                                                                                                                return 1 as libc::c_int != 0;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                    match current_block {
                                                        4312853273767610164 => {}
                                                        _ => {
                                                            free(old_tab);
                                                            free(old_strtab);
                                                            free(nondeflt_vers as *mut libc::c_void);
                                                            free(extversym as *mut libc::c_void);
                                                            current_block = 13529282842555969672;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                    match current_block {
                                        4312853273767610164 => {}
                                        _ => {
                                            free(isymbuf as *mut libc::c_void);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_archive_symbol_lookup(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut name: *const libc::c_char,
) -> *mut bfd_link_hash_entry {
    let mut h: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut copy: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut first: size_t = 0;
    h = bfd_link_hash_lookup(
        (*info).hash,
        name,
        0 as libc::c_int != 0,
        0 as libc::c_int != 0,
        1 as libc::c_int != 0,
    );
    if !h.is_null() {
        return h;
    }
    p = strchr(name, '@' as i32);
    if p.is_null() || *p.offset(1 as libc::c_int as isize) as libc::c_int != '@' as i32 {
        return h;
    }
    len = strlen(name);
    copy = bfd_alloc(abfd, len) as *mut libc::c_char;
    if copy.is_null() {
        return -(1 as libc::c_int) as *mut bfd_link_hash_entry;
    }
    first = (p.offset_from(name) as libc::c_long + 1 as libc::c_int as libc::c_long)
        as size_t;
    memcpy(copy as *mut libc::c_void, name as *const libc::c_void, first);
    memcpy(
        copy.offset(first as isize) as *mut libc::c_void,
        name.offset(first as isize).offset(1 as libc::c_int as isize)
            as *const libc::c_void,
        len.wrapping_sub(first),
    );
    h = bfd_link_hash_lookup(
        (*info).hash,
        copy,
        0 as libc::c_int != 0,
        0 as libc::c_int != 0,
        1 as libc::c_int != 0,
    );
    if h.is_null() {
        *copy
            .offset(
                first.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
            ) = '\0' as i32 as libc::c_char;
        h = bfd_link_hash_lookup(
            (*info).hash,
            copy,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
            1 as libc::c_int != 0,
        );
    }
    bfd_release(abfd, copy as *mut libc::c_void);
    return h;
}
unsafe extern "C" fn elf_link_add_archive_symbols(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut current_block: u64;
    let mut c: symindex = 0;
    let mut included: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut symdefs: *mut carsym = 0 as *mut carsym;
    let mut loop_0: bool = false;
    let mut amt: size_t = 0;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut archive_symbol_lookup: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *const libc::c_char,
        ) -> *mut bfd_link_hash_entry,
    > = None;
    if !bfd_has_map(abfd) {
        if (bfd_openr_next_archived_file(abfd, 0 as *mut bfd)).is_null() {
            return 1 as libc::c_int != 0;
        }
        bfd_set_error(bfd_error_no_armap);
        return 0 as libc::c_int != 0;
    }
    c = (*(*abfd).tdata.aout_ar_data).symdef_count;
    if c == 0 as libc::c_int as libc::c_ulong {
        return 1 as libc::c_int != 0;
    }
    amt = c.wrapping_mul(::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong);
    included = bfd_zmalloc(amt) as *mut libc::c_uchar;
    if included.is_null() {
        return 0 as libc::c_int != 0;
    }
    symdefs = (*(*abfd).tdata.aout_ar_data).symdefs;
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    archive_symbol_lookup = (*bed).elf_backend_archive_symbol_lookup;
    's_70: loop {
        let mut last: file_ptr = 0;
        let mut i: symindex = 0;
        let mut symdef: *mut carsym = 0 as *mut carsym;
        let mut symdefend: *mut carsym = 0 as *mut carsym;
        loop_0 = 0 as libc::c_int != 0;
        last = -(1 as libc::c_int) as file_ptr;
        symdef = symdefs;
        symdefend = symdef.offset(c as isize);
        i = 0 as libc::c_int as symindex;
        while symdef < symdefend {
            let mut h: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
            let mut element: *mut bfd = 0 as *mut bfd;
            let mut undefs_tail: *mut bfd_link_hash_entry = 0
                as *mut bfd_link_hash_entry;
            let mut mark: symindex = 0;
            if !(*included.offset(i as isize) != 0) {
                if (*symdef).file_offset == last {
                    *included.offset(i as isize) = 1 as libc::c_int as libc::c_uchar;
                } else {
                    h = archive_symbol_lookup
                        .expect("non-null function pointer")(abfd, info, (*symdef).name);
                    if h == -(1 as libc::c_int) as *mut bfd_link_hash_entry {
                        current_block = 9159919007451535119;
                        break 's_70;
                    }
                    if !h.is_null() {
                        if (*h).type_0() as libc::c_int
                            == bfd_link_hash_undefined as libc::c_int
                        {
                            if is_elf_hash_table((*info).hash) as libc::c_int != 0
                                && (*(h as *mut elf_link_hash_entry)).indx
                                    == -(3 as libc::c_int) as libc::c_long
                            {
                                current_block = 15904375183555213903;
                            } else {
                                current_block = 18153031941552419006;
                            }
                        } else if (*h).type_0() as libc::c_int
                            == bfd_link_hash_common as libc::c_int
                        {
                            if !elf_link_is_defined_archive_symbol(abfd, symdef) {
                                current_block = 15904375183555213903;
                            } else {
                                current_block = 18153031941552419006;
                            }
                        } else {
                            if (*h).type_0() as libc::c_int
                                != bfd_link_hash_undefweak as libc::c_int
                            {
                                *included
                                    .offset(i as isize) = 1 as libc::c_int as libc::c_uchar;
                            }
                            current_block = 15904375183555213903;
                        }
                        match current_block {
                            15904375183555213903 => {}
                            _ => {
                                element = _bfd_get_elt_at_filepos(
                                    abfd,
                                    (*symdef).file_offset,
                                );
                                if element.is_null() {
                                    current_block = 9159919007451535119;
                                    break 's_70;
                                }
                                if !bfd_check_format(element, bfd_object) {
                                    current_block = 9159919007451535119;
                                    break 's_70;
                                }
                                undefs_tail = (*(*info).hash).undefs_tail;
                                if (Some(
                                    ((*(*info).callbacks).add_archive_element)
                                        .expect("non-null function pointer"),
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(info, element, (*symdef).name, &mut element)
                                {
                                    if !(Some(
                                        ((*(*element).xvec)._bfd_link_add_symbols)
                                            .expect("non-null function pointer"),
                                    ))
                                        .expect("non-null function pointer")(element, info)
                                    {
                                        current_block = 9159919007451535119;
                                        break 's_70;
                                    }
                                    if undefs_tail != (*(*info).hash).undefs_tail {
                                        loop_0 = 1 as libc::c_int != 0;
                                    }
                                    mark = i;
                                    loop {
                                        *included
                                            .offset(mark as isize) = 1 as libc::c_int as libc::c_uchar;
                                        if mark == 0 as libc::c_int as libc::c_ulong {
                                            break;
                                        }
                                        mark = mark.wrapping_sub(1);
                                        mark;
                                        if !((*symdefs.offset(mark as isize)).file_offset
                                            == (*symdef).file_offset)
                                        {
                                            break;
                                        }
                                    }
                                    last = (*symdef).file_offset;
                                }
                            }
                        }
                    }
                }
            }
            symdef = symdef.offset(1);
            symdef;
            i = i.wrapping_add(1);
            i;
        }
        if !loop_0 {
            current_block = 313581471991351815;
            break;
        }
    }
    match current_block {
        9159919007451535119 => {
            free(included as *mut libc::c_void);
            return 0 as libc::c_int != 0;
        }
        _ => {
            free(included as *mut libc::c_void);
            return 1 as libc::c_int != 0;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_link_add_symbols(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    match bfd_get_format(abfd) as libc::c_uint {
        1 => return elf_link_add_object_symbols(abfd, info),
        2 => return elf_link_add_archive_symbols(abfd, info),
        _ => {
            bfd_set_error(bfd_error_wrong_format);
            return 0 as libc::c_int != 0;
        }
    };
}
unsafe extern "C" fn elf_collect_hash_codes(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut inf: *mut hash_codes_info = data as *mut hash_codes_info;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut ha: libc::c_ulong = 0;
    let mut alc: *mut libc::c_char = 0 as *mut libc::c_char;
    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long {
        return 1 as libc::c_int != 0;
    }
    name = (*h).root.root.string;
    if (*h).versioned() as libc::c_int >= versioned as libc::c_int {
        let mut p: *mut libc::c_char = strchr(name, '@' as i32);
        if !p.is_null() {
            alc = bfd_malloc(
                (p.offset_from(name) as libc::c_long + 1 as libc::c_int as libc::c_long)
                    as bfd_size_type,
            ) as *mut libc::c_char;
            if alc.is_null() {
                (*inf).error = 1 as libc::c_int != 0;
                return 0 as libc::c_int != 0;
            }
            memcpy(
                alc as *mut libc::c_void,
                name as *const libc::c_void,
                p.offset_from(name) as libc::c_long as libc::c_ulong,
            );
            *alc
                .offset(
                    p.offset_from(name) as libc::c_long as isize,
                ) = '\0' as i32 as libc::c_char;
            name = alc;
        }
    }
    ha = bfd_elf_hash(name);
    let fresh15 = (*inf).hashcodes;
    (*inf).hashcodes = ((*inf).hashcodes).offset(1);
    *fresh15 = ha;
    (*h).u.elf_hash_value = ha;
    free(alc as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_collect_gnu_hash_codes(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut s: *mut collect_gnu_hash_codes = data as *mut collect_gnu_hash_codes;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut ha: libc::c_ulong = 0;
    let mut alc: *mut libc::c_char = 0 as *mut libc::c_char;
    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long {
        return 1 as libc::c_int != 0;
    }
    if !(Some(((*(*s).bed).elf_hash_symbol).expect("non-null function pointer")))
        .expect("non-null function pointer")(h)
    {
        return 1 as libc::c_int != 0;
    }
    name = (*h).root.root.string;
    if (*h).versioned() as libc::c_int >= versioned as libc::c_int {
        let mut p: *mut libc::c_char = strchr(name, '@' as i32);
        if !p.is_null() {
            alc = bfd_malloc(
                (p.offset_from(name) as libc::c_long + 1 as libc::c_int as libc::c_long)
                    as bfd_size_type,
            ) as *mut libc::c_char;
            if alc.is_null() {
                (*s).error = 1 as libc::c_int != 0;
                return 0 as libc::c_int != 0;
            }
            memcpy(
                alc as *mut libc::c_void,
                name as *const libc::c_void,
                p.offset_from(name) as libc::c_long as libc::c_ulong,
            );
            *alc
                .offset(
                    p.offset_from(name) as libc::c_long as isize,
                ) = '\0' as i32 as libc::c_char;
            name = alc;
        }
    }
    ha = bfd_elf_gnu_hash(name);
    *((*s).hashcodes).offset((*s).nsyms as isize) = ha;
    *((*s).hashval).offset((*h).dynindx as isize) = ha;
    (*s).nsyms = ((*s).nsyms).wrapping_add(1);
    (*s).nsyms;
    if (*s).min_dynindx < 0 as libc::c_int as libc::c_long
        || (*s).min_dynindx > (*h).dynindx
    {
        (*s).min_dynindx = (*h).dynindx;
    }
    free(alc as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_gnu_hash_process_symidx(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut s: *mut collect_gnu_hash_codes = data as *mut collect_gnu_hash_codes;
    let mut bucket: libc::c_ulong = 0;
    let mut val: libc::c_ulong = 0;
    if (*h).dynindx == -(1 as libc::c_int) as libc::c_long {
        return 1 as libc::c_int != 0;
    }
    if !(Some(((*(*s).bed).elf_hash_symbol).expect("non-null function pointer")))
        .expect("non-null function pointer")(h)
    {
        if (*h).dynindx >= (*s).min_dynindx {
            if ((*(*s).bed).record_xhash_symbol).is_some() {
                (Some(
                    ((*(*s).bed).record_xhash_symbol).expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(h, 0 as libc::c_int as bfd_vma);
                (*s).local_indx += 1;
                (*s).local_indx;
            } else {
                let fresh16 = (*s).local_indx;
                (*s).local_indx = (*s).local_indx + 1;
                (*h).dynindx = fresh16;
            }
        }
        return 1 as libc::c_int != 0;
    }
    bucket = (*((*s).hashval).offset((*h).dynindx as isize))
        .wrapping_rem((*s).bucketcount);
    val = *((*s).hashval).offset((*h).dynindx as isize) >> (*s).shift1
        & ((*s).maskbits >> (*s).shift1).wrapping_sub(1 as libc::c_int as libc::c_ulong);
    let ref mut fresh17 = *((*s).bitmask).offset(val as isize);
    *fresh17
        |= (1 as libc::c_int as bfd_vma)
            << (*((*s).hashval).offset((*h).dynindx as isize) & (*s).mask);
    let ref mut fresh18 = *((*s).bitmask).offset(val as isize);
    *fresh18
        |= (1 as libc::c_int as bfd_vma)
            << (*((*s).hashval).offset((*h).dynindx as isize) >> (*s).shift2
                & (*s).mask);
    val = *((*s).hashval).offset((*h).dynindx as isize)
        & !(1 as libc::c_int as libc::c_ulong);
    if *((*s).counts).offset(bucket as isize) == 1 as libc::c_int as libc::c_ulong {
        val |= 1 as libc::c_int as libc::c_ulong;
    }
    (Some(((*(*(*s).output_bfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        val,
        ((*s).contents)
            .offset(
                (*((*s).indx).offset(bucket as isize))
                    .wrapping_sub((*s).symindx)
                    .wrapping_mul(4 as libc::c_int as libc::c_ulong) as isize,
            ) as *mut libc::c_void,
    );
    let ref mut fresh19 = *((*s).counts).offset(bucket as isize);
    *fresh19 = (*fresh19).wrapping_sub(1);
    let _ = *fresh19;
    if ((*(*s).bed).record_xhash_symbol).is_some() {
        let ref mut fresh20 = *((*s).indx).offset(bucket as isize);
        let fresh21 = *fresh20;
        *fresh20 = (*fresh20).wrapping_add(1);
        let mut xlat_loc: bfd_vma = ((*s).xlat)
            .wrapping_add(
                fresh21
                    .wrapping_sub((*s).symindx)
                    .wrapping_mul(4 as libc::c_int as libc::c_ulong),
            );
        (Some(((*(*s).bed).record_xhash_symbol).expect("non-null function pointer")))
            .expect("non-null function pointer")(h, xlat_loc);
    } else {
        let ref mut fresh22 = *((*s).indx).offset(bucket as isize);
        let fresh23 = *fresh22;
        *fresh22 = (*fresh22).wrapping_add(1);
        (*h).dynindx = fresh23 as libc::c_long;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_hash_symbol(mut h: *mut elf_link_hash_entry) -> bool {
    return !((*h).forced_local() as libc::c_int != 0
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefined as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefweak as libc::c_int
        || (((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int)
            && ((*(*h).root.u.def.section).output_section).is_null());
}
static mut elf_buckets: [size_t; 17] = [
    1 as libc::c_int as size_t,
    3 as libc::c_int as size_t,
    17 as libc::c_int as size_t,
    37 as libc::c_int as size_t,
    67 as libc::c_int as size_t,
    97 as libc::c_int as size_t,
    131 as libc::c_int as size_t,
    197 as libc::c_int as size_t,
    263 as libc::c_int as size_t,
    521 as libc::c_int as size_t,
    1031 as libc::c_int as size_t,
    2053 as libc::c_int as size_t,
    4099 as libc::c_int as size_t,
    8209 as libc::c_int as size_t,
    16411 as libc::c_int as size_t,
    32771 as libc::c_int as size_t,
    0 as libc::c_int as size_t,
];
unsafe extern "C" fn compute_bucket_count(
    mut info: *mut bfd_link_info,
    mut hashcodes: *mut libc::c_ulong,
    mut nsyms: libc::c_ulong,
    mut gnu_hash: libc::c_int,
) -> size_t {
    let mut best_size: size_t = 0 as libc::c_int as size_t;
    let mut i: libc::c_ulong = 0;
    if (*info).optimize() != 0 {
        let mut minsize: size_t = 0;
        let mut maxsize: size_t = 0;
        let mut best_chlen: libc::c_ulong = !(0 as libc::c_int as libc::c_ulong);
        let mut dynobj: *mut bfd = (*elf_hash_table(info)).dynobj;
        let mut dynsymcount: size_t = (*elf_hash_table(info)).dynsymcount;
        let mut bed: *const elf_backend_data = (*(*dynobj).xvec).backend_data
            as *const elf_backend_data;
        let mut counts: *mut libc::c_ulong = 0 as *mut libc::c_ulong;
        let mut amt: bfd_size_type = 0;
        let mut no_improvement_count: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        minsize = nsyms.wrapping_div(4 as libc::c_int as libc::c_ulong);
        if minsize == 0 as libc::c_int as libc::c_ulong {
            minsize = 1 as libc::c_int as size_t;
        }
        maxsize = nsyms.wrapping_mul(2 as libc::c_int as libc::c_ulong);
        best_size = maxsize;
        if gnu_hash != 0 {
            if minsize < 2 as libc::c_int as libc::c_ulong {
                minsize = 2 as libc::c_int as size_t;
            }
            if best_size & 31 as libc::c_int as libc::c_ulong
                == 0 as libc::c_int as libc::c_ulong
            {
                best_size = best_size.wrapping_add(1);
                best_size;
            }
        }
        amt = maxsize;
        amt = (amt as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)
            as bfd_size_type as bfd_size_type;
        counts = bfd_malloc(amt) as *mut libc::c_ulong;
        if counts.is_null() {
            return 0 as libc::c_int as size_t;
        }
        i = minsize;
        while i < maxsize {
            let mut max: libc::c_ulong = 0;
            let mut j: libc::c_ulong = 0;
            let mut fact: libc::c_ulong = 0;
            if !(gnu_hash != 0
                && i & 31 as libc::c_int as libc::c_ulong
                    == 0 as libc::c_int as libc::c_ulong)
            {
                memset(
                    counts as *mut libc::c_void,
                    '\0' as i32,
                    i
                        .wrapping_mul(
                            ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong,
                        ),
                );
                j = 0 as libc::c_int as libc::c_ulong;
                while j < nsyms {
                    let ref mut fresh24 = *counts
                        .offset(
                            (*hashcodes.offset(j as isize)).wrapping_rem(i) as isize,
                        );
                    *fresh24 = (*fresh24).wrapping_add(1);
                    let _ = *fresh24;
                    j = j.wrapping_add(1);
                    j;
                }
                max = (2 as libc::c_int as libc::c_ulong)
                    .wrapping_add(dynsymcount)
                    .wrapping_mul((*(*bed).s).sizeof_hash_entry as libc::c_ulong);
                j = 0 as libc::c_int as libc::c_ulong;
                while j < i {
                    max = max
                        .wrapping_add(
                            (*counts.offset(j as isize))
                                .wrapping_mul(*counts.offset(j as isize)),
                        );
                    j = j.wrapping_add(1);
                    j;
                }
                fact = i
                    .wrapping_div(
                        (4096 as libc::c_int
                            / (*(*bed).s).sizeof_hash_entry as libc::c_int)
                            as libc::c_ulong,
                    )
                    .wrapping_add(1 as libc::c_int as libc::c_ulong);
                max = max.wrapping_mul(fact.wrapping_mul(fact));
                if max < best_chlen {
                    best_chlen = max;
                    best_size = i;
                    no_improvement_count = 0 as libc::c_int as libc::c_uint;
                } else {
                    no_improvement_count = no_improvement_count.wrapping_add(1);
                    if no_improvement_count == 100 as libc::c_int as libc::c_uint {
                        break;
                    }
                }
            }
            i = i.wrapping_add(1);
            i;
        }
        free(counts as *mut libc::c_void);
    } else {
        i = 0 as libc::c_int as libc::c_ulong;
        while elf_buckets[i as usize] != 0 as libc::c_int as libc::c_ulong {
            best_size = elf_buckets[i as usize];
            if nsyms
                < elf_buckets[i.wrapping_add(1 as libc::c_int as libc::c_ulong) as usize]
            {
                break;
            }
            i = i.wrapping_add(1);
            i;
        }
        if gnu_hash != 0 && best_size < 2 as libc::c_int as libc::c_ulong {
            best_size = 2 as libc::c_int as size_t;
        }
    }
    return best_size;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_size_group_sections(
    mut info: *mut bfd_link_info,
) -> bool {
    let mut ibfd: *mut bfd = 0 as *mut bfd;
    let mut s: *mut asection = 0 as *mut asection;
    ibfd = (*info).input_bfds;
    while !ibfd.is_null() {
        if bfd_get_flavour(ibfd) as libc::c_uint
            == bfd_target_elf_flavour as libc::c_int as libc::c_uint
            && {
                s = (*ibfd).sections;
                !s.is_null()
            } && (*s).sec_info_type() as libc::c_int != 4 as libc::c_int
            && !_bfd_elf_fixup_group_sections(
                ibfd,
                &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize),
            )
        {
            return 0 as libc::c_int != 0;
        }
        ibfd = (*ibfd).link.next;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_stack_segment_size(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut legacy_symbol: *const libc::c_char,
    mut default_size: bfd_vma,
) -> bool {
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    if !legacy_symbol.is_null() {
        h = elf_link_hash_lookup(
            elf_hash_table(info),
            legacy_symbol,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
        );
    }
    if !h.is_null()
        && (((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int)
        && (*h).def_regular() as libc::c_int != 0
        && ((*h).type_0() as libc::c_int == 0 as libc::c_int
            || (*h).type_0() as libc::c_int == 1 as libc::c_int)
    {
        (*h).set_type_0(1 as libc::c_int as libc::c_uint);
        if (*info).stacksize != 0 {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: stack size specified and %s set\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                output_bfd,
                legacy_symbol,
            );
        } else if (*h).root.u.def.section
            != &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
                as *mut asection
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: %s not absolute\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                output_bfd,
                legacy_symbol,
            );
        } else {
            (*info).stacksize = (*h).root.u.def.value as bfd_signed_vma;
        }
    }
    if (*info).stacksize == 0 {
        (*info).stacksize = default_size as bfd_signed_vma;
    }
    if !h.is_null()
        && (((*h).root).type_0() as libc::c_int == bfd_link_hash_undefined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_undefweak as libc::c_int)
    {
        let mut bh: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
        if !_bfd_generic_link_add_one_symbol(
            info,
            output_bfd,
            legacy_symbol,
            ((1 as libc::c_int) << 1 as libc::c_int) as flagword,
            &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize),
            (if (*info).stacksize >= 0 as libc::c_int as libc::c_long {
                (*info).stacksize
            } else {
                0 as libc::c_int as libc::c_long
            }) as bfd_vma,
            0 as *const libc::c_char,
            0 as libc::c_int != 0,
            (*((*(*output_bfd).xvec).backend_data as *const elf_backend_data)).collect()
                != 0,
            &mut bh,
        ) {
            return 0 as libc::c_int != 0;
        }
        h = bh as *mut elf_link_hash_entry;
        (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
        (*h).set_type_0(1 as libc::c_int as libc::c_uint);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_gc_sweep_symbol(
    mut h: *mut elf_link_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    if (*h).mark() == 0
        && ((((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int)
            && !(((*h).def_regular() as libc::c_int != 0
                || (*h).def_regular() == 0 && (*h).def_dynamic() == 0
                    && ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_defined as libc::c_int)
                && (*(*h).root.u.def.section).gc_mark() as libc::c_int != 0)
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_undefined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_undefweak as libc::c_int)
    {
        let mut inf: *mut elf_gc_sweep_symbol_info = 0 as *mut elf_gc_sweep_symbol_info;
        inf = data as *mut elf_gc_sweep_symbol_info;
        (Some(((*inf).hide_symbol).expect("non-null function pointer")))
            .expect("non-null function pointer")((*inf).info, h, 1 as libc::c_int != 0);
        (*h).set_def_regular(0 as libc::c_int as libc::c_uint);
        (*h).set_ref_regular(0 as libc::c_int as libc::c_uint);
        (*h).set_ref_regular_nonweak(0 as libc::c_int as libc::c_uint);
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_size_dynamic_sections(
    mut output_bfd: *mut bfd,
    mut soname: *const libc::c_char,
    mut rpath: *const libc::c_char,
    mut filter_shlib: *const libc::c_char,
    mut audit: *const libc::c_char,
    mut depaudit: *const libc::c_char,
    mut auxiliary_filters: *const *const libc::c_char,
    mut info: *mut bfd_link_info,
    mut sinterpptr: *mut *mut asection,
) -> bool {
    let mut dynobj: *mut bfd = 0 as *mut bfd;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    *sinterpptr = 0 as *mut asection;
    if !is_elf_hash_table((*info).hash) {
        return 1 as libc::c_int != 0;
    }
    dynobj = (*elf_hash_table(info)).dynobj;
    if !dynobj.is_null()
        && (*elf_hash_table(info)).dynamic_sections_created as libc::c_int != 0
    {
        let mut verdefs: *mut bfd_elf_version_tree = 0 as *mut bfd_elf_version_tree;
        let mut asvinfo: elf_info_failed = elf_info_failed {
            info: 0 as *mut bfd_link_info,
            failed: false,
        };
        let mut t: *mut bfd_elf_version_tree = 0 as *mut bfd_elf_version_tree;
        let mut d: *mut bfd_elf_version_expr = 0 as *mut bfd_elf_version_expr;
        let mut s: *mut asection = 0 as *mut asection;
        let mut soname_indx: size_t = 0;
        if (*info).export_dynamic() as libc::c_int != 0
            || ((*info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
                && (*info).dynamic() as libc::c_int != 0
        {
            let mut eif: elf_info_failed = elf_info_failed {
                info: 0 as *mut bfd_link_info,
                failed: false,
            };
            eif.info = info;
            eif.failed = 0 as libc::c_int != 0;
            elf_link_hash_traverse(
                elf_hash_table(info),
                Some(
                    _bfd_elf_export_symbol
                        as unsafe extern "C" fn(
                            *mut elf_link_hash_entry,
                            *mut libc::c_void,
                        ) -> bool,
                ),
                &mut eif as *mut elf_info_failed as *mut libc::c_void,
            );
            if eif.failed {
                return 0 as libc::c_int != 0;
            }
        }
        if !soname.is_null() {
            soname_indx = _bfd_elf_strtab_add(
                (*elf_hash_table(info)).dynstr,
                soname,
                1 as libc::c_int != 0,
            );
            if soname_indx == -(1 as libc::c_int) as size_t
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    14 as libc::c_int as bfd_vma,
                    soname_indx,
                )
            {
                return 0 as libc::c_int != 0;
            }
        } else {
            soname_indx = -(1 as libc::c_int) as size_t;
        }
        t = (*info).version_info;
        while !t.is_null() {
            d = (*t).globals.list;
            while !d.is_null() {
                if (*d).symver() == 0 && (*d).literal() as libc::c_int != 0 {
                    let mut verstr: *const libc::c_char = 0 as *const libc::c_char;
                    let mut name: *const libc::c_char = 0 as *const libc::c_char;
                    let mut namelen: size_t = 0;
                    let mut verlen: size_t = 0;
                    let mut newlen: size_t = 0;
                    let mut newname: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut leading_char: libc::c_char = 0;
                    let mut newh: *mut elf_link_hash_entry = 0
                        as *mut elf_link_hash_entry;
                    leading_char = bfd_get_symbol_leading_char(output_bfd);
                    name = (*d).pattern;
                    namelen = (strlen(name))
                        .wrapping_add(
                            (leading_char as libc::c_int != '\0' as i32) as libc::c_int
                                as libc::c_ulong,
                        );
                    verstr = (*t).name;
                    verlen = strlen(verstr);
                    newlen = namelen
                        .wrapping_add(verlen)
                        .wrapping_add(3 as libc::c_int as libc::c_ulong);
                    newname = bfd_malloc(newlen) as *mut libc::c_char;
                    if newname.is_null() {
                        return 0 as libc::c_int != 0;
                    }
                    *newname.offset(0 as libc::c_int as isize) = leading_char;
                    memcpy(
                        newname
                            .offset(
                                (leading_char as libc::c_int != '\0' as i32) as libc::c_int
                                    as isize,
                            ) as *mut libc::c_void,
                        name as *const libc::c_void,
                        namelen,
                    );
                    p = newname.offset(namelen as isize);
                    let fresh25 = p;
                    p = p.offset(1);
                    *fresh25 = '@' as i32 as libc::c_char;
                    memcpy(
                        p as *mut libc::c_void,
                        verstr as *const libc::c_void,
                        verlen.wrapping_add(1 as libc::c_int as libc::c_ulong),
                    );
                    newh = elf_link_hash_lookup(
                        elf_hash_table(info),
                        newname,
                        0 as libc::c_int != 0,
                        0 as libc::c_int != 0,
                        0 as libc::c_int != 0,
                    );
                    if newh.is_null()
                        || ((*newh).root).type_0() as libc::c_int
                            != bfd_link_hash_defined as libc::c_int
                            && ((*newh).root).type_0() as libc::c_int
                                != bfd_link_hash_defweak as libc::c_int
                    {
                        let fresh26 = p;
                        p = p.offset(1);
                        *fresh26 = '@' as i32 as libc::c_char;
                        memcpy(
                            p as *mut libc::c_void,
                            verstr as *const libc::c_void,
                            verlen.wrapping_add(1 as libc::c_int as libc::c_ulong),
                        );
                        newh = elf_link_hash_lookup(
                            elf_hash_table(info),
                            newname,
                            0 as libc::c_int != 0,
                            0 as libc::c_int != 0,
                            0 as libc::c_int != 0,
                        );
                    }
                    free(newname as *mut libc::c_void);
                    if !newh.is_null() && (*newh).def_dynamic() == 0
                        && (((*newh).root).type_0() as libc::c_int
                            == bfd_link_hash_defined as libc::c_int
                            || ((*newh).root).type_0() as libc::c_int
                                == bfd_link_hash_defweak as libc::c_int)
                    {
                        (*d).set_symver(1 as libc::c_int as libc::c_uint);
                    }
                }
                d = (*d).next;
            }
            t = (*t).next;
        }
        asvinfo.info = info;
        asvinfo.failed = 0 as libc::c_int != 0;
        elf_link_hash_traverse(
            elf_hash_table(info),
            Some(
                _bfd_elf_link_assign_sym_version
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            &mut asvinfo as *mut elf_info_failed as *mut libc::c_void,
        );
        if asvinfo.failed {
            return 0 as libc::c_int != 0;
        }
        if (*info).allow_undefined_version() == 0 {
            let mut all_defined: bool = 1 as libc::c_int != 0;
            t = (*info).version_info;
            while !t.is_null() {
                d = (*t).globals.list;
                while !d.is_null() {
                    if (*d).literal() as libc::c_int != 0 && (*d).symver() == 0
                        && (*d).script() == 0
                    {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%s: undefined version: %s\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*d).pattern,
                            (*t).name,
                        );
                        all_defined = 0 as libc::c_int != 0;
                    }
                    d = (*d).next;
                }
                t = (*t).next;
            }
            if !all_defined {
                bfd_set_error(bfd_error_bad_value);
                return 0 as libc::c_int != 0;
            }
        }
        s = bfd_get_linker_section(
            dynobj,
            b".gnu.version_d\0" as *const u8 as *const libc::c_char,
        );
        if s.is_null() {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                6590 as libc::c_int,
            );
        }
        verdefs = (*info).version_info;
        if !verdefs.is_null() && (*verdefs).vernum == 0 as libc::c_int as libc::c_uint {
            verdefs = (*verdefs).next;
        }
        if verdefs.is_null() && (*info).create_default_symver() == 0 {
            (*s).flags |= 0x8000 as libc::c_int as libc::c_uint;
        } else {
            let mut cdefs: libc::c_uint = 0;
            let mut size: bfd_size_type = 0;
            let mut p_0: *mut bfd_byte = 0 as *mut bfd_byte;
            let mut def: Elf_Internal_Verdef = Elf_Internal_Verdef {
                vd_version: 0,
                vd_flags: 0,
                vd_ndx: 0,
                vd_cnt: 0,
                vd_hash: 0,
                vd_aux: 0,
                vd_next: 0,
                vd_bfd: 0 as *mut bfd,
                vd_nodename: 0 as *const libc::c_char,
                vd_nextdef: 0 as *mut elf_internal_verdef,
                vd_auxptr: 0 as *mut elf_internal_verdaux,
                vd_exp_refno: 0,
            };
            let mut defaux: Elf_Internal_Verdaux = Elf_Internal_Verdaux {
                vda_name: 0,
                vda_next: 0,
                vda_nodename: 0 as *const libc::c_char,
                vda_nextptr: 0 as *mut elf_internal_verdaux,
            };
            let mut bh: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
            let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
            let mut name_0: *const libc::c_char = 0 as *const libc::c_char;
            cdefs = 0 as libc::c_int as libc::c_uint;
            size = 0 as libc::c_int as bfd_size_type;
            size = (size as libc::c_ulong)
                .wrapping_add(
                    ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong,
                ) as bfd_size_type as bfd_size_type;
            size = (size as libc::c_ulong)
                .wrapping_add(
                    ::core::mem::size_of::<Elf_External_Verdaux>() as libc::c_ulong,
                ) as bfd_size_type as bfd_size_type;
            cdefs = cdefs.wrapping_add(1);
            cdefs;
            if (*info).create_default_symver() != 0 {
                size = (size as libc::c_ulong)
                    .wrapping_add(
                        ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong,
                    ) as bfd_size_type as bfd_size_type;
                cdefs = cdefs.wrapping_add(1);
                cdefs;
            }
            t = verdefs;
            while !t.is_null() {
                let mut n: *mut bfd_elf_version_deps = 0 as *mut bfd_elf_version_deps;
                if !((*t).vernum == 0 as libc::c_int as libc::c_uint) {
                    size = (size as libc::c_ulong)
                        .wrapping_add(
                            ::core::mem::size_of::<Elf_External_Verdef>()
                                as libc::c_ulong,
                        ) as bfd_size_type as bfd_size_type;
                    size = (size as libc::c_ulong)
                        .wrapping_add(
                            ::core::mem::size_of::<Elf_External_Verdaux>()
                                as libc::c_ulong,
                        ) as bfd_size_type as bfd_size_type;
                    cdefs = cdefs.wrapping_add(1);
                    cdefs;
                    n = (*t).deps;
                    while !n.is_null() {
                        size = (size as libc::c_ulong)
                            .wrapping_add(
                                ::core::mem::size_of::<Elf_External_Verdaux>()
                                    as libc::c_ulong,
                            ) as bfd_size_type as bfd_size_type;
                        n = (*n).next;
                    }
                }
                t = (*t).next;
            }
            (*s).size = size;
            (*s).contents = bfd_alloc(output_bfd, (*s).size) as *mut libc::c_uchar;
            if ((*s).contents).is_null()
                && (*s).size != 0 as libc::c_int as libc::c_ulong
            {
                return 0 as libc::c_int != 0;
            }
            p_0 = (*s).contents;
            def.vd_version = 1 as libc::c_int as libc::c_ushort;
            def.vd_flags = 0x1 as libc::c_int as libc::c_ushort;
            def.vd_ndx = 1 as libc::c_int as libc::c_ushort;
            def.vd_cnt = 1 as libc::c_int as libc::c_ushort;
            if (*info).create_default_symver() != 0 {
                def
                    .vd_aux = (2 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong,
                    );
                def
                    .vd_next = ::core::mem::size_of::<Elf_External_Verdef>()
                    as libc::c_ulong;
            } else {
                def
                    .vd_aux = ::core::mem::size_of::<Elf_External_Verdef>()
                    as libc::c_ulong;
                def
                    .vd_next = (::core::mem::size_of::<Elf_External_Verdef>()
                    as libc::c_ulong)
                    .wrapping_add(
                        ::core::mem::size_of::<Elf_External_Verdaux>() as libc::c_ulong,
                    );
            }
            if soname_indx != -(1 as libc::c_int) as size_t {
                _bfd_elf_strtab_addref((*elf_hash_table(info)).dynstr, soname_indx);
                def.vd_hash = bfd_elf_hash(soname);
                defaux.vda_name = soname_indx;
                name_0 = soname;
            } else {
                let mut indx: size_t = 0;
                name_0 = lbasename(bfd_get_filename(output_bfd));
                def.vd_hash = bfd_elf_hash(name_0);
                indx = _bfd_elf_strtab_add(
                    (*elf_hash_table(info)).dynstr,
                    name_0,
                    0 as libc::c_int != 0,
                );
                if indx == -(1 as libc::c_int) as size_t {
                    return 0 as libc::c_int != 0;
                }
                defaux.vda_name = indx;
            }
            defaux.vda_next = 0 as libc::c_int as libc::c_ulong;
            _bfd_elf_swap_verdef_out(
                output_bfd,
                &mut def,
                p_0 as *mut Elf_External_Verdef,
            );
            p_0 = p_0
                .offset(
                    ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong
                        as isize,
                );
            if (*info).create_default_symver() != 0 {
                bh = 0 as *mut bfd_link_hash_entry;
                if !_bfd_generic_link_add_one_symbol(
                    info,
                    dynobj,
                    name_0,
                    ((1 as libc::c_int) << 1 as libc::c_int) as flagword,
                    &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize),
                    0 as libc::c_int as bfd_vma,
                    0 as *const libc::c_char,
                    0 as libc::c_int != 0,
                    (*((*(*dynobj).xvec).backend_data as *const elf_backend_data))
                        .collect() != 0,
                    &mut bh,
                ) {
                    return 0 as libc::c_int != 0;
                }
                h = bh as *mut elf_link_hash_entry;
                (*h).set_non_elf(0 as libc::c_int as libc::c_uint);
                (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
                (*h).set_type_0(1 as libc::c_int as libc::c_uint);
                (*h).verinfo.vertree = 0 as *mut bfd_elf_version_tree;
                if !bfd_elf_link_record_dynamic_symbol(info, h) {
                    return 0 as libc::c_int != 0;
                }
                def.vd_flags = 0 as libc::c_int as libc::c_ushort;
                def.vd_ndx = 2 as libc::c_int as libc::c_ushort;
                def
                    .vd_aux = ::core::mem::size_of::<Elf_External_Verdef>()
                    as libc::c_ulong;
                if !verdefs.is_null() {
                    def
                        .vd_next = (::core::mem::size_of::<Elf_External_Verdef>()
                        as libc::c_ulong)
                        .wrapping_add(
                            ::core::mem::size_of::<Elf_External_Verdaux>()
                                as libc::c_ulong,
                        );
                } else {
                    def.vd_next = 0 as libc::c_int as libc::c_ulong;
                }
                _bfd_elf_swap_verdef_out(
                    output_bfd,
                    &mut def,
                    p_0 as *mut Elf_External_Verdef,
                );
                p_0 = p_0
                    .offset(
                        ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong
                            as isize,
                    );
            }
            _bfd_elf_swap_verdaux_out(
                output_bfd,
                &mut defaux,
                p_0 as *mut Elf_External_Verdaux,
            );
            p_0 = p_0
                .offset(
                    ::core::mem::size_of::<Elf_External_Verdaux>() as libc::c_ulong
                        as isize,
                );
            t = verdefs;
            while !t.is_null() {
                let mut cdeps: libc::c_uint = 0;
                let mut n_0: *mut bfd_elf_version_deps = 0 as *mut bfd_elf_version_deps;
                if !((*t).vernum == 0 as libc::c_int as libc::c_uint) {
                    cdeps = 0 as libc::c_int as libc::c_uint;
                    n_0 = (*t).deps;
                    while !n_0.is_null() {
                        cdeps = cdeps.wrapping_add(1);
                        cdeps;
                        n_0 = (*n_0).next;
                    }
                    bh = 0 as *mut bfd_link_hash_entry;
                    if !_bfd_generic_link_add_one_symbol(
                        info,
                        dynobj,
                        (*t).name,
                        ((1 as libc::c_int) << 1 as libc::c_int) as flagword,
                        &mut *_bfd_std_section
                            .as_mut_ptr()
                            .offset(2 as libc::c_int as isize),
                        0 as libc::c_int as bfd_vma,
                        0 as *const libc::c_char,
                        0 as libc::c_int != 0,
                        (*((*(*dynobj).xvec).backend_data as *const elf_backend_data))
                            .collect() != 0,
                        &mut bh,
                    ) {
                        return 0 as libc::c_int != 0;
                    }
                    h = bh as *mut elf_link_hash_entry;
                    (*h).set_non_elf(0 as libc::c_int as libc::c_uint);
                    (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
                    (*h).set_type_0(1 as libc::c_int as libc::c_uint);
                    (*h).verinfo.vertree = t;
                    if !bfd_elf_link_record_dynamic_symbol(info, h) {
                        return 0 as libc::c_int != 0;
                    }
                    def.vd_version = 1 as libc::c_int as libc::c_ushort;
                    def.vd_flags = 0 as libc::c_int as libc::c_ushort;
                    if ((*t).globals.list).is_null() && ((*t).locals.list).is_null()
                        && (*t).used == 0
                    {
                        def
                            .vd_flags = (def.vd_flags as libc::c_int
                            | 0x2 as libc::c_int) as libc::c_ushort;
                    }
                    def
                        .vd_ndx = ((*t).vernum)
                        .wrapping_add(
                            (if (*info).create_default_symver() as libc::c_int != 0 {
                                2 as libc::c_int
                            } else {
                                1 as libc::c_int
                            }) as libc::c_uint,
                        ) as libc::c_ushort;
                    def
                        .vd_cnt = cdeps.wrapping_add(1 as libc::c_int as libc::c_uint)
                        as libc::c_ushort;
                    def.vd_hash = bfd_elf_hash((*t).name);
                    def
                        .vd_aux = ::core::mem::size_of::<Elf_External_Verdef>()
                        as libc::c_ulong;
                    def.vd_next = 0 as libc::c_int as libc::c_ulong;
                    if !((*t).next).is_null()
                        && (*(*t).next).vernum == 0 as libc::c_int as libc::c_uint
                    {
                        if !((*(*t).next).next).is_null() {
                            bfd_assert(
                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                6774 as libc::c_int,
                            );
                        }
                    }
                    if !((*t).next).is_null()
                        && (*(*t).next).vernum != 0 as libc::c_int as libc::c_uint
                    {
                        def
                            .vd_next = (::core::mem::size_of::<Elf_External_Verdef>()
                            as libc::c_ulong)
                            .wrapping_add(
                                (cdeps.wrapping_add(1 as libc::c_int as libc::c_uint)
                                    as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<Elf_External_Verdaux>()
                                            as libc::c_ulong,
                                    ),
                            );
                    }
                    _bfd_elf_swap_verdef_out(
                        output_bfd,
                        &mut def,
                        p_0 as *mut Elf_External_Verdef,
                    );
                    p_0 = p_0
                        .offset(
                            ::core::mem::size_of::<Elf_External_Verdef>()
                                as libc::c_ulong as isize,
                        );
                    defaux.vda_name = (*h).dynstr_index;
                    _bfd_elf_strtab_addref(
                        (*elf_hash_table(info)).dynstr,
                        (*h).dynstr_index,
                    );
                    defaux.vda_next = 0 as libc::c_int as libc::c_ulong;
                    if !((*t).deps).is_null() {
                        defaux
                            .vda_next = ::core::mem::size_of::<Elf_External_Verdaux>()
                            as libc::c_ulong;
                    }
                    (*t).name_indx = defaux.vda_name as libc::c_uint;
                    _bfd_elf_swap_verdaux_out(
                        output_bfd,
                        &mut defaux,
                        p_0 as *mut Elf_External_Verdaux,
                    );
                    p_0 = p_0
                        .offset(
                            ::core::mem::size_of::<Elf_External_Verdaux>()
                                as libc::c_ulong as isize,
                        );
                    n_0 = (*t).deps;
                    while !n_0.is_null() {
                        if ((*n_0).version_needed).is_null() {
                            defaux.vda_name = 0 as libc::c_int as libc::c_ulong;
                        } else {
                            defaux
                                .vda_name = (*(*n_0).version_needed).name_indx
                                as libc::c_ulong;
                            _bfd_elf_strtab_addref(
                                (*elf_hash_table(info)).dynstr,
                                defaux.vda_name,
                            );
                        }
                        if ((*n_0).next).is_null() {
                            defaux.vda_next = 0 as libc::c_int as libc::c_ulong;
                        } else {
                            defaux
                                .vda_next = ::core::mem::size_of::<Elf_External_Verdaux>()
                                as libc::c_ulong;
                        }
                        _bfd_elf_swap_verdaux_out(
                            output_bfd,
                            &mut defaux,
                            p_0 as *mut Elf_External_Verdaux,
                        );
                        p_0 = p_0
                            .offset(
                                ::core::mem::size_of::<Elf_External_Verdaux>()
                                    as libc::c_ulong as isize,
                            );
                        n_0 = (*n_0).next;
                    }
                }
                t = (*t).next;
            }
            (*(*output_bfd).tdata.elf_obj_data).cverdefs = cdefs;
        }
    }
    bed = (*(*output_bfd).xvec).backend_data as *const elf_backend_data;
    if (*info).gc_sections() as libc::c_int != 0
        && (*bed).can_gc_sections() as libc::c_int != 0
    {
        let mut sweep_info: elf_gc_sweep_symbol_info = elf_gc_sweep_symbol_info {
            info: 0 as *mut bfd_link_info,
            hide_symbol: None,
        };
        sweep_info.info = info;
        sweep_info.hide_symbol = (*bed).elf_backend_hide_symbol;
        elf_link_hash_traverse(
            elf_hash_table(info),
            Some(
                elf_gc_sweep_symbol
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            &mut sweep_info as *mut elf_gc_sweep_symbol_info as *mut libc::c_void,
        );
    }
    if !dynobj.is_null()
        && (*elf_hash_table(info)).dynamic_sections_created as libc::c_int != 0
    {
        let mut s_0: *mut asection = 0 as *mut asection;
        let mut sinfo: elf_find_verdep_info = elf_find_verdep_info {
            info: 0 as *mut bfd_link_info,
            vers: 0,
            failed: false,
        };
        s_0 = bfd_get_linker_section(
            dynobj,
            b".gnu.version_r\0" as *const u8 as *const libc::c_char,
        );
        if s_0.is_null() {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                6847 as libc::c_int,
            );
        }
        sinfo.info = info;
        sinfo.vers = (*(*output_bfd).tdata.elf_obj_data).cverdefs;
        if sinfo.vers == 0 as libc::c_int as libc::c_uint {
            sinfo.vers = 1 as libc::c_int as libc::c_uint;
        }
        sinfo.failed = 0 as libc::c_int != 0;
        elf_link_hash_traverse(
            elf_hash_table(info),
            Some(
                _bfd_elf_link_find_version_dependencies
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            &mut sinfo as *mut elf_find_verdep_info as *mut libc::c_void,
        );
        if sinfo.failed {
            return 0 as libc::c_int != 0;
        }
        if ((*(*output_bfd).tdata.elf_obj_data).verref).is_null() {
            (*s_0).flags |= 0x8000 as libc::c_int as libc::c_uint;
        } else {
            let mut vn: *mut Elf_Internal_Verneed = 0 as *mut Elf_Internal_Verneed;
            let mut size_0: libc::c_uint = 0;
            let mut crefs: libc::c_uint = 0;
            let mut p_1: *mut bfd_byte = 0 as *mut bfd_byte;
            size_0 = 0 as libc::c_int as libc::c_uint;
            crefs = 0 as libc::c_int as libc::c_uint;
            vn = (*(*output_bfd).tdata.elf_obj_data).verref;
            while !vn.is_null() {
                let mut a: *mut Elf_Internal_Vernaux = 0 as *mut Elf_Internal_Vernaux;
                size_0 = (size_0 as libc::c_ulong)
                    .wrapping_add(
                        ::core::mem::size_of::<Elf_External_Verneed>() as libc::c_ulong,
                    ) as libc::c_uint as libc::c_uint;
                crefs = crefs.wrapping_add(1);
                crefs;
                a = (*vn).vn_auxptr;
                while !a.is_null() {
                    size_0 = (size_0 as libc::c_ulong)
                        .wrapping_add(
                            ::core::mem::size_of::<Elf_External_Vernaux>()
                                as libc::c_ulong,
                        ) as libc::c_uint as libc::c_uint;
                    a = (*a).vna_nextptr;
                }
                vn = (*vn).vn_nextref;
            }
            (*s_0).size = size_0 as bfd_size_type;
            (*s_0).contents = bfd_alloc(output_bfd, (*s_0).size) as *mut libc::c_uchar;
            if ((*s_0).contents).is_null() {
                return 0 as libc::c_int != 0;
            }
            p_1 = (*s_0).contents;
            vn = (*(*output_bfd).tdata.elf_obj_data).verref;
            while !vn.is_null() {
                let mut caux: libc::c_uint = 0;
                let mut a_0: *mut Elf_Internal_Vernaux = 0 as *mut Elf_Internal_Vernaux;
                let mut indx_0: size_t = 0;
                caux = 0 as libc::c_int as libc::c_uint;
                a_0 = (*vn).vn_auxptr;
                while !a_0.is_null() {
                    caux = caux.wrapping_add(1);
                    caux;
                    a_0 = (*a_0).vna_nextptr;
                }
                (*vn).vn_version = 1 as libc::c_int as libc::c_ushort;
                (*vn).vn_cnt = caux as libc::c_ushort;
                indx_0 = _bfd_elf_strtab_add(
                    (*elf_hash_table(info)).dynstr,
                    if !((*(*(*vn).vn_bfd).tdata.elf_obj_data).dt_name).is_null() {
                        (*(*(*vn).vn_bfd).tdata.elf_obj_data).dt_name
                    } else {
                        lbasename(bfd_get_filename((*vn).vn_bfd))
                    },
                    0 as libc::c_int != 0,
                );
                if indx_0 == -(1 as libc::c_int) as size_t {
                    return 0 as libc::c_int != 0;
                }
                (*vn).vn_file = indx_0;
                (*vn)
                    .vn_aux = ::core::mem::size_of::<Elf_External_Verneed>()
                    as libc::c_ulong;
                if ((*vn).vn_nextref).is_null() {
                    (*vn).vn_next = 0 as libc::c_int as libc::c_ulong;
                } else {
                    (*vn)
                        .vn_next = (::core::mem::size_of::<Elf_External_Verneed>()
                        as libc::c_ulong)
                        .wrapping_add(
                            (caux as libc::c_ulong)
                                .wrapping_mul(
                                    ::core::mem::size_of::<Elf_External_Vernaux>()
                                        as libc::c_ulong,
                                ),
                        );
                }
                _bfd_elf_swap_verneed_out(
                    output_bfd,
                    vn,
                    p_1 as *mut Elf_External_Verneed,
                );
                p_1 = p_1
                    .offset(
                        ::core::mem::size_of::<Elf_External_Verneed>() as libc::c_ulong
                            as isize,
                    );
                a_0 = (*vn).vn_auxptr;
                while !a_0.is_null() {
                    (*a_0).vna_hash = bfd_elf_hash((*a_0).vna_nodename);
                    indx_0 = _bfd_elf_strtab_add(
                        (*elf_hash_table(info)).dynstr,
                        (*a_0).vna_nodename,
                        0 as libc::c_int != 0,
                    );
                    if indx_0 == -(1 as libc::c_int) as size_t {
                        return 0 as libc::c_int != 0;
                    }
                    (*a_0).vna_name = indx_0;
                    if ((*a_0).vna_nextptr).is_null() {
                        (*a_0).vna_next = 0 as libc::c_int as libc::c_ulong;
                    } else {
                        (*a_0)
                            .vna_next = ::core::mem::size_of::<Elf_External_Vernaux>()
                            as libc::c_ulong;
                    }
                    _bfd_elf_swap_vernaux_out(
                        output_bfd,
                        a_0,
                        p_1 as *mut Elf_External_Vernaux,
                    );
                    p_1 = p_1
                        .offset(
                            ::core::mem::size_of::<Elf_External_Vernaux>()
                                as libc::c_ulong as isize,
                        );
                    a_0 = (*a_0).vna_nextptr;
                }
                vn = (*vn).vn_nextref;
            }
            (*(*output_bfd).tdata.elf_obj_data).cverrefs = crefs;
        }
    }
    (*elf_hash_table(info)).init_got_refcount = (*elf_hash_table(info)).init_got_offset;
    (*elf_hash_table(info)).init_plt_refcount = (*elf_hash_table(info)).init_plt_offset;
    if (*info).type_0() as libc::c_int == type_relocatable as libc::c_int
        && !_bfd_elf_size_group_sections(info)
    {
        return 0 as libc::c_int != 0;
    }
    if ((*bed).elf_backend_always_size_sections).is_some()
        && !(Some(
            ((*bed).elf_backend_always_size_sections).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(output_bfd, info)
    {
        return 0 as libc::c_int != 0;
    }
    if (*info).execstack() != 0 {
        (*(*(*output_bfd).tdata.elf_obj_data).o)
            .stack_flags = ((1 as libc::c_int) << 2 as libc::c_int
            | (1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint;
    } else if (*info).noexecstack() != 0 {
        (*(*(*output_bfd).tdata.elf_obj_data).o)
            .stack_flags = ((1 as libc::c_int) << 2 as libc::c_int
            | (1 as libc::c_int) << 1 as libc::c_int) as libc::c_uint;
    } else {
        let mut inputobj: *mut bfd = 0 as *mut bfd;
        let mut notesec: *mut asection = 0 as *mut asection;
        let mut exec: libc::c_int = 0 as libc::c_int;
        inputobj = (*info).input_bfds;
        while !inputobj.is_null() {
            let mut s_1: *mut asection = 0 as *mut asection;
            if !((*inputobj).flags
                & (0x40 as libc::c_int | 0x2 as libc::c_int | 0x10000 as libc::c_int
                    | 0x1000 as libc::c_int) as libc::c_uint != 0)
            {
                s_1 = (*inputobj).sections;
                if !(s_1.is_null()
                    || (*s_1).sec_info_type() as libc::c_int == 4 as libc::c_int)
                {
                    s_1 = bfd_get_section_by_name(
                        inputobj,
                        b".note.GNU-stack\0" as *const u8 as *const libc::c_char,
                    );
                    if !s_1.is_null() {
                        if (*s_1).flags & 0x10 as libc::c_int as libc::c_uint != 0 {
                            exec = (1 as libc::c_int) << 0 as libc::c_int;
                        }
                        notesec = s_1;
                    } else if (*bed).default_execstack() != 0 {
                        exec = (1 as libc::c_int) << 0 as libc::c_int;
                    }
                }
            }
            inputobj = (*inputobj).link.next;
        }
        if !notesec.is_null() || (*info).stacksize > 0 as libc::c_int as libc::c_long {
            (*(*(*output_bfd).tdata.elf_obj_data).o)
                .stack_flags = ((1 as libc::c_int) << 2 as libc::c_int
                | (1 as libc::c_int) << 1 as libc::c_int | exec) as libc::c_uint;
        }
        if !notesec.is_null() && exec != 0
            && (*info).type_0() as libc::c_int == type_relocatable as libc::c_int
            && (*notesec).output_section
                != &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
                    as *mut asection
        {
            (*(*notesec).output_section).flags |= 0x10 as libc::c_int as libc::c_uint;
        }
    }
    if !dynobj.is_null()
        && (*elf_hash_table(info)).dynamic_sections_created as libc::c_int != 0
    {
        let mut eif_0: elf_info_failed = elf_info_failed {
            info: 0 as *mut bfd_link_info,
            failed: false,
        };
        let mut h_0: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
        let mut dynstr: *mut asection = 0 as *mut asection;
        let mut s_2: *mut asection = 0 as *mut asection;
        *sinterpptr = bfd_get_linker_section(
            dynobj,
            b".interp\0" as *const u8 as *const libc::c_char,
        );
        if !(!(*sinterpptr).is_null()
            || !((*info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
            || (*info).nointerp() as libc::c_int != 0)
        {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                7015 as libc::c_int,
            );
        }
        if (*info).symbolic() != 0 {
            if !_bfd_elf_add_dynamic_entry(
                info,
                16 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
            (*info).flags |= ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong;
        }
        if !rpath.is_null() {
            let mut indx_1: size_t = 0;
            let mut tag: bfd_vma = 0;
            indx_1 = _bfd_elf_strtab_add(
                (*elf_hash_table(info)).dynstr,
                rpath,
                1 as libc::c_int != 0,
            );
            if indx_1 == -(1 as libc::c_int) as size_t {
                return 0 as libc::c_int != 0;
            }
            tag = (if (*info).new_dtags() as libc::c_int != 0 {
                29 as libc::c_int
            } else {
                15 as libc::c_int
            }) as bfd_vma;
            if !_bfd_elf_add_dynamic_entry(info, tag, indx_1) {
                return 0 as libc::c_int != 0;
            }
        }
        if !filter_shlib.is_null() {
            let mut indx_2: size_t = 0;
            indx_2 = _bfd_elf_strtab_add(
                (*elf_hash_table(info)).dynstr,
                filter_shlib,
                1 as libc::c_int != 0,
            );
            if indx_2 == -(1 as libc::c_int) as size_t
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    0x7fffffff as libc::c_int as bfd_vma,
                    indx_2,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        if !auxiliary_filters.is_null() {
            let mut p_2: *const *const libc::c_char = 0 as *const *const libc::c_char;
            p_2 = auxiliary_filters;
            while !(*p_2).is_null() {
                let mut indx_3: size_t = 0;
                indx_3 = _bfd_elf_strtab_add(
                    (*elf_hash_table(info)).dynstr,
                    *p_2,
                    1 as libc::c_int != 0,
                );
                if indx_3 == -(1 as libc::c_int) as size_t
                    || !_bfd_elf_add_dynamic_entry(
                        info,
                        0x7ffffffd as libc::c_int as bfd_vma,
                        indx_3,
                    )
                {
                    return 0 as libc::c_int != 0;
                }
                p_2 = p_2.offset(1);
                p_2;
            }
        }
        if !audit.is_null() {
            let mut indx_4: size_t = 0;
            indx_4 = _bfd_elf_strtab_add(
                (*elf_hash_table(info)).dynstr,
                audit,
                1 as libc::c_int != 0,
            );
            if indx_4 == -(1 as libc::c_int) as size_t
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    0x6ffffefc as libc::c_int as bfd_vma,
                    indx_4,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        if !depaudit.is_null() {
            let mut indx_5: size_t = 0;
            indx_5 = _bfd_elf_strtab_add(
                (*elf_hash_table(info)).dynstr,
                depaudit,
                1 as libc::c_int != 0,
            );
            if indx_5 == -(1 as libc::c_int) as size_t
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    0x6ffffefb as libc::c_int as bfd_vma,
                    indx_5,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        eif_0.info = info;
        eif_0.failed = 0 as libc::c_int != 0;
        elf_link_hash_traverse(
            elf_hash_table(info),
            Some(
                _bfd_elf_adjust_dynamic_symbol
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            &mut eif_0 as *mut elf_info_failed as *mut libc::c_void,
        );
        if eif_0.failed {
            return 0 as libc::c_int != 0;
        }
        h_0 = if !((*info).init_function).is_null() {
            elf_link_hash_lookup(
                elf_hash_table(info),
                (*info).init_function,
                0 as libc::c_int != 0,
                0 as libc::c_int != 0,
                0 as libc::c_int != 0,
            )
        } else {
            0 as *mut elf_link_hash_entry
        };
        if !h_0.is_null()
            && ((*h_0).ref_regular() as libc::c_int != 0
                || (*h_0).def_regular() as libc::c_int != 0)
        {
            if !_bfd_elf_add_dynamic_entry(
                info,
                12 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
        }
        h_0 = if !((*info).fini_function).is_null() {
            elf_link_hash_lookup(
                elf_hash_table(info),
                (*info).fini_function,
                0 as libc::c_int != 0,
                0 as libc::c_int != 0,
                0 as libc::c_int != 0,
            )
        } else {
            0 as *mut elf_link_hash_entry
        };
        if !h_0.is_null()
            && ((*h_0).ref_regular() as libc::c_int != 0
                || (*h_0).def_regular() as libc::c_int != 0)
        {
            if !_bfd_elf_add_dynamic_entry(
                info,
                13 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
        }
        s_2 = bfd_get_section_by_name(
            output_bfd,
            b".preinit_array\0" as *const u8 as *const libc::c_char,
        );
        if !s_2.is_null() && (*s_2).linker_has_input() as libc::c_int != 0 {
            if !((*info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
            {
                let mut sub: *mut bfd = 0 as *mut bfd;
                let mut o: *mut asection = 0 as *mut asection;
                sub = (*info).input_bfds;
                while !sub.is_null() {
                    if bfd_get_flavour(sub) as libc::c_uint
                        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
                        && {
                            o = (*sub).sections;
                            !o.is_null()
                        } && (*o).sec_info_type() as libc::c_int != 4 as libc::c_int
                    {
                        o = (*sub).sections;
                        while !o.is_null() {
                            if (*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                .this_hdr
                                .sh_type == 16 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: .preinit_array section is not allowed in DSO\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    sub,
                                );
                                break;
                            } else {
                                o = (*o).next;
                            }
                        }
                    }
                    sub = (*sub).link.next;
                }
                bfd_set_error(bfd_error_nonrepresentable_section);
                return 0 as libc::c_int != 0;
            }
            if !_bfd_elf_add_dynamic_entry(
                info,
                32 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    33 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        s_2 = bfd_get_section_by_name(
            output_bfd,
            b".init_array\0" as *const u8 as *const libc::c_char,
        );
        if !s_2.is_null() && (*s_2).linker_has_input() as libc::c_int != 0 {
            if !_bfd_elf_add_dynamic_entry(
                info,
                25 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    27 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        s_2 = bfd_get_section_by_name(
            output_bfd,
            b".fini_array\0" as *const u8 as *const libc::c_char,
        );
        if !s_2.is_null() && (*s_2).linker_has_input() as libc::c_int != 0 {
            if !_bfd_elf_add_dynamic_entry(
                info,
                26 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    28 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        dynstr = bfd_get_linker_section(
            dynobj,
            b".dynstr\0" as *const u8 as *const libc::c_char,
        );
        if !dynstr.is_null()
            && (*dynstr).output_section
                != &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
                    as *mut asection
        {
            let mut strsize: bfd_size_type = 0;
            strsize = _bfd_elf_strtab_size((*elf_hash_table(info)).dynstr);
            if (*info).emit_hash() as libc::c_int != 0
                && !_bfd_elf_add_dynamic_entry(
                    info,
                    4 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
                || (*info).emit_gnu_hash() as libc::c_int != 0
                    && (((*bed).record_xhash_symbol).is_none()
                        && !_bfd_elf_add_dynamic_entry(
                            info,
                            0x6ffffef5 as libc::c_int as bfd_vma,
                            0 as libc::c_int as bfd_vma,
                        ))
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    5 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    6 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    10 as libc::c_int as bfd_vma,
                    strsize,
                )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    11 as libc::c_int as bfd_vma,
                    (*(*bed).s).sizeof_sym as bfd_vma,
                )
                || (*info).gnu_flags_1 != 0
                    && !_bfd_elf_add_dynamic_entry(
                        info,
                        0x6ffffdf4 as libc::c_int as bfd_vma,
                        (*info).gnu_flags_1,
                    )
            {
                return 0 as libc::c_int != 0;
            }
        }
    }
    if !_bfd_elf_maybe_strip_eh_frame_hdr(info) {
        return 0 as libc::c_int != 0;
    }
    if !dynobj.is_null() && ((*bed).elf_backend_size_dynamic_sections).is_some()
        && !(Some(
            ((*bed).elf_backend_size_dynamic_sections)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(output_bfd, info)
    {
        return 0 as libc::c_int != 0;
    }
    if !dynobj.is_null()
        && (*elf_hash_table(info)).dynamic_sections_created as libc::c_int != 0
    {
        if (*(*output_bfd).tdata.elf_obj_data).cverdefs != 0 {
            let mut crefs_0: libc::c_uint = (*(*output_bfd).tdata.elf_obj_data).cverdefs;
            if !_bfd_elf_add_dynamic_entry(
                info,
                0x6ffffffc as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    0x6ffffffd as libc::c_int as bfd_vma,
                    crefs_0 as bfd_vma,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        if (*info).new_dtags() as libc::c_int != 0 && (*info).flags != 0
            || (*info).flags & ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_ulong
                != 0
        {
            if !_bfd_elf_add_dynamic_entry(
                info,
                30 as libc::c_int as bfd_vma,
                (*info).flags,
            ) {
                return 0 as libc::c_int != 0;
            }
        } else if (*info).flags
            & ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_ulong != 0
        {
            if !_bfd_elf_add_dynamic_entry(
                info,
                24 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
        }
        if (*info).flags_1 != 0 {
            if (*info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*info).type_0() as libc::c_int == type_pie as libc::c_int
            {
                (*info).flags_1
                    &= !(0x20 as libc::c_int | 0x8 as libc::c_int | 0x40 as libc::c_int)
                        as libc::c_ulong;
            }
            if !_bfd_elf_add_dynamic_entry(
                info,
                0x6ffffffb as libc::c_int as bfd_vma,
                (*info).flags_1,
            ) {
                return 0 as libc::c_int != 0;
            }
        }
        if (*(*output_bfd).tdata.elf_obj_data).cverrefs != 0 {
            let mut crefs_1: libc::c_uint = (*(*output_bfd).tdata.elf_obj_data).cverrefs;
            if !_bfd_elf_add_dynamic_entry(
                info,
                0x6ffffffe as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    0x6fffffff as libc::c_int as bfd_vma,
                    crefs_1 as bfd_vma,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        if (*(*output_bfd).tdata.elf_obj_data).cverrefs
            == 0 as libc::c_int as libc::c_uint
            && (*(*output_bfd).tdata.elf_obj_data).cverdefs
                == 0 as libc::c_int as libc::c_uint
            || _bfd_elf_link_renumber_dynsyms(output_bfd, info, 0 as *mut libc::c_ulong)
                <= 1 as libc::c_int as libc::c_ulong
        {
            let mut s_3: *mut asection = 0 as *mut asection;
            s_3 = bfd_get_linker_section(
                dynobj,
                b".gnu.version\0" as *const u8 as *const libc::c_char,
            );
            (*s_3).flags |= 0x8000 as libc::c_int as libc::c_uint;
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_init_1_index_section(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
) {
    let mut s: *mut asection = 0 as *mut asection;
    let mut found: *mut asection = 0 as *mut asection;
    s = (*output_bfd).sections;
    while !s.is_null() {
        if (*s).flags & (0x8000 as libc::c_int | 0x1 as libc::c_int) as libc::c_uint
            == 0x1 as libc::c_int as libc::c_uint
            && !_bfd_elf_omit_section_dynsym_default(output_bfd, info, s)
        {
            found = s;
            if (*s).flags & 0x400 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
            {
                break;
            }
        }
        s = (*s).next;
    }
    let ref mut fresh27 = (*elf_hash_table(info)).text_index_section;
    *fresh27 = found;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_init_2_index_sections(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
) {
    let mut s: *mut asection = 0 as *mut asection;
    let mut found: *mut asection = 0 as *mut asection;
    s = (*output_bfd).sections;
    while !s.is_null() {
        if (*s).flags & (0x8000 as libc::c_int | 0x1 as libc::c_int) as libc::c_uint
            == 0x1 as libc::c_int as libc::c_uint
            && (*s).flags & 0x8 as libc::c_int as libc::c_uint == 0
            && !_bfd_elf_omit_section_dynsym_default(output_bfd, info, s)
        {
            found = s;
            if (*s).flags & 0x400 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
            {
                break;
            }
        }
        s = (*s).next;
    }
    let ref mut fresh28 = (*elf_hash_table(info)).data_index_section;
    *fresh28 = found;
    s = (*output_bfd).sections;
    while !s.is_null() {
        if (*s).flags & (0x8000 as libc::c_int | 0x1 as libc::c_int) as libc::c_uint
            == 0x1 as libc::c_int as libc::c_uint
            && (*s).flags & 0x8 as libc::c_int as libc::c_uint != 0
            && !_bfd_elf_omit_section_dynsym_default(output_bfd, info, s)
        {
            found = s;
            break;
        } else {
            s = (*s).next;
        }
    }
    let ref mut fresh29 = (*elf_hash_table(info)).text_index_section;
    *fresh29 = found;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_size_dynsym_hash_dynstr(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut section_sym_count: libc::c_ulong = 0;
    let mut dynsymcount: bfd_size_type = 0 as libc::c_int as bfd_size_type;
    if !is_elf_hash_table((*info).hash) {
        return 1 as libc::c_int != 0;
    }
    bed = (*(*output_bfd).xvec).backend_data as *const elf_backend_data;
    (Some(((*bed).elf_backend_init_index_section).expect("non-null function pointer")))
        .expect("non-null function pointer")(output_bfd, info);
    if (*elf_hash_table(info)).dynamic_sections_created as libc::c_int != 0
        || (*bed).always_renumber_dynsyms() as libc::c_int != 0
    {
        dynsymcount = _bfd_elf_link_renumber_dynsyms(
            output_bfd,
            info,
            &mut section_sym_count,
        );
    }
    if (*elf_hash_table(info)).dynamic_sections_created {
        let mut dynobj: *mut bfd = 0 as *mut bfd;
        let mut s: *mut asection = 0 as *mut asection;
        let mut dtagcount: libc::c_uint = 0;
        dynobj = (*elf_hash_table(info)).dynobj;
        s = bfd_get_linker_section(
            dynobj,
            b".gnu.version\0" as *const u8 as *const libc::c_char,
        );
        if s.is_null() {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                7360 as libc::c_int,
            );
        }
        if (*s).flags & 0x8000 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        {
            (*s)
                .size = dynsymcount
                .wrapping_mul(
                    ::core::mem::size_of::<Elf_External_Versym>() as libc::c_ulong,
                );
            (*s).contents = bfd_zalloc(output_bfd, (*s).size) as *mut libc::c_uchar;
            if ((*s).contents).is_null() {
                return 0 as libc::c_int != 0;
            }
            if !_bfd_elf_add_dynamic_entry(
                info,
                0x6ffffff0 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
        }
        s = (*elf_hash_table(info)).dynsym;
        if s.is_null() {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                7379 as libc::c_int,
            );
        }
        (*s).size = dynsymcount.wrapping_mul((*(*bed).s).sizeof_sym as libc::c_ulong);
        (*s).contents = bfd_alloc(output_bfd, (*s).size) as *mut libc::c_uchar;
        if ((*s).contents).is_null() {
            return 0 as libc::c_int != 0;
        }
        section_sym_count = section_sym_count.wrapping_add(1);
        section_sym_count;
        memset(
            (*s).contents as *mut libc::c_void,
            0 as libc::c_int,
            section_sym_count.wrapping_mul((*(*bed).s).sizeof_sym as libc::c_ulong),
        );
        (*elf_hash_table(info)).bucketcount = 0 as libc::c_int as bfd_size_type;
        if (*info).emit_hash() != 0 {
            let mut hashcodes: *mut libc::c_ulong = 0 as *mut libc::c_ulong;
            let mut hashinf: hash_codes_info = hash_codes_info {
                hashcodes: 0 as *mut libc::c_ulong,
                error: false,
            };
            let mut amt: bfd_size_type = 0;
            let mut nsyms: libc::c_ulong = 0;
            let mut bucketcount: size_t = 0;
            let mut hash_entry_size: size_t = 0;
            amt = dynsymcount
                .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong);
            hashcodes = bfd_malloc(amt) as *mut libc::c_ulong;
            if hashcodes.is_null() {
                return 0 as libc::c_int != 0;
            }
            hashinf.hashcodes = hashcodes;
            hashinf.error = 0 as libc::c_int != 0;
            elf_link_hash_traverse(
                elf_hash_table(info),
                Some(
                    elf_collect_hash_codes
                        as unsafe extern "C" fn(
                            *mut elf_link_hash_entry,
                            *mut libc::c_void,
                        ) -> bool,
                ),
                &mut hashinf as *mut hash_codes_info as *mut libc::c_void,
            );
            if hashinf.error {
                free(hashcodes as *mut libc::c_void);
                return 0 as libc::c_int != 0;
            }
            nsyms = (hashinf.hashcodes).offset_from(hashcodes) as libc::c_long
                as libc::c_ulong;
            bucketcount = compute_bucket_count(info, hashcodes, nsyms, 0 as libc::c_int);
            free(hashcodes as *mut libc::c_void);
            if bucketcount == 0 as libc::c_int as libc::c_ulong
                && nsyms > 0 as libc::c_int as libc::c_ulong
            {
                return 0 as libc::c_int != 0;
            }
            (*elf_hash_table(info)).bucketcount = bucketcount;
            s = bfd_get_linker_section(
                dynobj,
                b".hash\0" as *const u8 as *const libc::c_char,
            );
            if s.is_null() {
                bfd_assert(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    7434 as libc::c_int,
                );
            }
            hash_entry_size = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                .this_hdr
                .sh_entsize;
            (*s)
                .size = (2 as libc::c_int as libc::c_ulong)
                .wrapping_add(bucketcount)
                .wrapping_add(dynsymcount)
                .wrapping_mul(hash_entry_size);
            (*s).contents = bfd_zalloc(output_bfd, (*s).size) as *mut libc::c_uchar;
            if ((*s).contents).is_null() {
                return 0 as libc::c_int != 0;
            }
            if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                == 8 as libc::c_int as libc::c_ulong
            {
                *(*s)
                    .contents = (bucketcount & 0xff as libc::c_int as libc::c_ulong)
                    as libc::c_uchar;
            } else {
                if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                    == 16 as libc::c_int as libc::c_ulong
                {
                    (Some(
                        ((*(*output_bfd).xvec).bfd_putx16)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(bucketcount, (*s).contents as *mut libc::c_void);
                } else {
                    if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                        == 32 as libc::c_int as libc::c_ulong
                    {
                        (Some(
                            ((*(*output_bfd).xvec).bfd_putx32)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(bucketcount, (*s).contents as *mut libc::c_void);
                    } else {
                        if (8 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(hash_entry_size)
                            == 64 as libc::c_int as libc::c_ulong
                        {
                            (Some(
                                ((*(*output_bfd).xvec).bfd_putx64)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(bucketcount, (*s).contents as *mut libc::c_void);
                        } else {
                            _bfd_abort(
                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                7441 as libc::c_int,
                                (*::core::mem::transmute::<
                                    &[u8; 69],
                                    &[libc::c_char; 69],
                                >(
                                    b"_Bool bfd_elf_size_dynsym_hash_dynstr(bfd *, struct bfd_link_info *)\0",
                                ))
                                    .as_ptr(),
                            );
                        };
                    };
                };
            };
            if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                == 8 as libc::c_int as libc::c_ulong
            {
                *((*s).contents)
                    .offset(
                        hash_entry_size as isize,
                    ) = (dynsymcount & 0xff as libc::c_int as libc::c_ulong)
                    as libc::c_uchar;
            } else {
                if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                    == 16 as libc::c_int as libc::c_ulong
                {
                    (Some(
                        ((*(*output_bfd).xvec).bfd_putx16)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        dynsymcount,
                        ((*s).contents).offset(hash_entry_size as isize)
                            as *mut libc::c_void,
                    );
                } else {
                    if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                        == 32 as libc::c_int as libc::c_ulong
                    {
                        (Some(
                            ((*(*output_bfd).xvec).bfd_putx32)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            dynsymcount,
                            ((*s).contents).offset(hash_entry_size as isize)
                                as *mut libc::c_void,
                        );
                    } else {
                        if (8 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(hash_entry_size)
                            == 64 as libc::c_int as libc::c_ulong
                        {
                            (Some(
                                ((*(*output_bfd).xvec).bfd_putx64)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                dynsymcount,
                                ((*s).contents).offset(hash_entry_size as isize)
                                    as *mut libc::c_void,
                            );
                        } else {
                            _bfd_abort(
                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                7443 as libc::c_int,
                                (*::core::mem::transmute::<
                                    &[u8; 69],
                                    &[libc::c_char; 69],
                                >(
                                    b"_Bool bfd_elf_size_dynsym_hash_dynstr(bfd *, struct bfd_link_info *)\0",
                                ))
                                    .as_ptr(),
                            );
                        };
                    };
                };
            };
        }
        if (*info).emit_gnu_hash() != 0 {
            let mut i: size_t = 0;
            let mut cnt: size_t = 0;
            let mut contents: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut cinfo: collect_gnu_hash_codes = collect_gnu_hash_codes {
                output_bfd: 0 as *mut bfd,
                bed: 0 as *const elf_backend_data,
                nsyms: 0,
                maskbits: 0,
                hashcodes: 0 as *mut libc::c_ulong,
                hashval: 0 as *mut libc::c_ulong,
                indx: 0 as *mut libc::c_ulong,
                counts: 0 as *mut libc::c_ulong,
                bitmask: 0 as *mut bfd_vma,
                contents: 0 as *mut bfd_byte,
                xlat: 0,
                min_dynindx: 0,
                bucketcount: 0,
                symindx: 0,
                local_indx: 0,
                shift1: 0,
                shift2: 0,
                mask: 0,
                error: false,
            };
            let mut amt_0: bfd_size_type = 0;
            let mut bucketcount_0: size_t = 0;
            memset(
                &mut cinfo as *mut collect_gnu_hash_codes as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<collect_gnu_hash_codes>() as libc::c_ulong,
            );
            amt_0 = dynsymcount
                .wrapping_mul(2 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong);
            cinfo.hashcodes = bfd_malloc(amt_0) as *mut libc::c_ulong;
            if (cinfo.hashcodes).is_null() {
                return 0 as libc::c_int != 0;
            }
            cinfo.hashval = (cinfo.hashcodes).offset(dynsymcount as isize);
            cinfo.min_dynindx = -(1 as libc::c_int) as libc::c_long;
            cinfo.output_bfd = output_bfd;
            cinfo.bed = bed;
            elf_link_hash_traverse(
                elf_hash_table(info),
                Some(
                    elf_collect_gnu_hash_codes
                        as unsafe extern "C" fn(
                            *mut elf_link_hash_entry,
                            *mut libc::c_void,
                        ) -> bool,
                ),
                &mut cinfo as *mut collect_gnu_hash_codes as *mut libc::c_void,
            );
            if cinfo.error {
                free(cinfo.hashcodes as *mut libc::c_void);
                return 0 as libc::c_int != 0;
            }
            bucketcount_0 = compute_bucket_count(
                info,
                cinfo.hashcodes,
                cinfo.nsyms,
                1 as libc::c_int,
            );
            if bucketcount_0 == 0 as libc::c_int as libc::c_ulong {
                free(cinfo.hashcodes as *mut libc::c_void);
                return 0 as libc::c_int != 0;
            }
            s = bfd_get_linker_section(
                dynobj,
                if ((*bed).record_xhash_symbol).is_some() {
                    b".MIPS.xhash\0" as *const u8 as *const libc::c_char
                } else {
                    b".gnu.hash\0" as *const u8 as *const libc::c_char
                },
            );
            if s.is_null() {
                bfd_assert(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    7488 as libc::c_int,
                );
            }
            if cinfo.nsyms == 0 as libc::c_int as libc::c_ulong {
                if !(cinfo.min_dynindx == -(1 as libc::c_int) as libc::c_long) {
                    bfd_assert(
                        b"elflink.c\0" as *const u8 as *const libc::c_char,
                        7493 as libc::c_int,
                    );
                }
                free(cinfo.hashcodes as *mut libc::c_void);
                (*s)
                    .size = (5 as libc::c_int * 4 as libc::c_int
                    + (*(*bed).s).arch_size as libc::c_int / 8 as libc::c_int)
                    as bfd_size_type;
                contents = bfd_zalloc(output_bfd, (*s).size) as *mut libc::c_uchar;
                if contents.is_null() {
                    return 0 as libc::c_int != 0;
                }
                (*s).contents = contents;
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(1 as libc::c_int as bfd_vma, contents as *mut libc::c_void);
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    1 as libc::c_int as bfd_vma,
                    contents.offset(4 as libc::c_int as isize) as *mut libc::c_void,
                );
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    1 as libc::c_int as bfd_vma,
                    contents.offset(8 as libc::c_int as isize) as *mut libc::c_void,
                );
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    0 as libc::c_int as bfd_vma,
                    contents.offset(12 as libc::c_int as isize) as *mut libc::c_void,
                );
                if (*(*bed).s).arch_size as libc::c_int == 8 as libc::c_int {
                    *contents
                        .offset(
                            16 as libc::c_int as isize,
                        ) = (0 as libc::c_int & 0xff as libc::c_int) as libc::c_uchar;
                } else {
                    if (*(*bed).s).arch_size as libc::c_int == 16 as libc::c_int {
                        (Some(
                            ((*(*output_bfd).xvec).bfd_putx16)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            0 as libc::c_int as bfd_vma,
                            contents.offset(16 as libc::c_int as isize)
                                as *mut libc::c_void,
                        );
                    } else {
                        if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int {
                            (Some(
                                ((*(*output_bfd).xvec).bfd_putx32)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                0 as libc::c_int as bfd_vma,
                                contents.offset(16 as libc::c_int as isize)
                                    as *mut libc::c_void,
                            );
                        } else {
                            if (*(*bed).s).arch_size as libc::c_int == 64 as libc::c_int
                            {
                                (Some(
                                    ((*(*output_bfd).xvec).bfd_putx64)
                                        .expect("non-null function pointer"),
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    0 as libc::c_int as bfd_uint64_t,
                                    contents.offset(16 as libc::c_int as isize)
                                        as *mut libc::c_void,
                                );
                            } else {
                                _bfd_abort(
                                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                                    7509 as libc::c_int,
                                    (*::core::mem::transmute::<
                                        &[u8; 69],
                                        &[libc::c_char; 69],
                                    >(
                                        b"_Bool bfd_elf_size_dynsym_hash_dynstr(bfd *, struct bfd_link_info *)\0",
                                    ))
                                        .as_ptr(),
                                );
                            };
                        };
                    };
                };
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    0 as libc::c_int as bfd_vma,
                    contents
                        .offset(16 as libc::c_int as isize)
                        .offset(
                            ((*(*bed).s).arch_size as libc::c_int / 8 as libc::c_int)
                                as isize,
                        ) as *mut libc::c_void,
                );
            } else {
                let mut maskwords: libc::c_ulong = 0;
                let mut maskbitslog2: libc::c_ulong = 0;
                let mut x: libc::c_ulong = 0;
                if !(cinfo.min_dynindx != -(1 as libc::c_int) as libc::c_long) {
                    bfd_assert(
                        b"elflink.c\0" as *const u8 as *const libc::c_char,
                        7517 as libc::c_int,
                    );
                }
                x = cinfo.nsyms;
                maskbitslog2 = 1 as libc::c_int as libc::c_ulong;
                loop {
                    x >>= 1 as libc::c_int;
                    if !(x != 0 as libc::c_int as libc::c_ulong) {
                        break;
                    }
                    maskbitslog2 = maskbitslog2.wrapping_add(1);
                    maskbitslog2;
                }
                if maskbitslog2 < 3 as libc::c_int as libc::c_ulong {
                    maskbitslog2 = 5 as libc::c_int as libc::c_ulong;
                } else if ((1 as libc::c_int)
                    << maskbitslog2.wrapping_sub(2 as libc::c_int as libc::c_ulong))
                    as libc::c_ulong & cinfo.nsyms != 0
                {
                    maskbitslog2 = maskbitslog2
                        .wrapping_add(3 as libc::c_int as libc::c_ulong);
                } else {
                    maskbitslog2 = maskbitslog2
                        .wrapping_add(2 as libc::c_int as libc::c_ulong);
                }
                if (*(*bed).s).arch_size as libc::c_int == 64 as libc::c_int {
                    if maskbitslog2 == 5 as libc::c_int as libc::c_ulong {
                        maskbitslog2 = 6 as libc::c_int as libc::c_ulong;
                    }
                    cinfo.shift1 = 6 as libc::c_int as libc::c_long;
                } else {
                    cinfo.shift1 = 5 as libc::c_int as libc::c_long;
                }
                cinfo
                    .mask = (((1 as libc::c_int) << cinfo.shift1) - 1 as libc::c_int)
                    as libc::c_ulong;
                cinfo.shift2 = maskbitslog2 as libc::c_long;
                cinfo.maskbits = ((1 as libc::c_int) << maskbitslog2) as libc::c_ulong;
                maskwords = ((1 as libc::c_int)
                    << maskbitslog2.wrapping_sub(cinfo.shift1 as libc::c_ulong))
                    as libc::c_ulong;
                amt_0 = bucketcount_0
                    .wrapping_mul(
                        ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong,
                    )
                    .wrapping_mul(2 as libc::c_int as libc::c_ulong);
                amt_0 = (amt_0 as libc::c_ulong)
                    .wrapping_add(
                        maskwords
                            .wrapping_mul(
                                ::core::mem::size_of::<bfd_vma>() as libc::c_ulong,
                            ),
                    ) as bfd_size_type as bfd_size_type;
                cinfo.bitmask = bfd_malloc(amt_0) as *mut bfd_vma;
                if (cinfo.bitmask).is_null() {
                    free(cinfo.hashcodes as *mut libc::c_void);
                    return 0 as libc::c_int != 0;
                }
                cinfo
                    .counts = (cinfo.bitmask).offset(maskwords as isize)
                    as *mut libc::c_ulong;
                cinfo.indx = (cinfo.counts).offset(bucketcount_0 as isize);
                cinfo.symindx = dynsymcount.wrapping_sub(cinfo.nsyms);
                memset(
                    cinfo.bitmask as *mut libc::c_void,
                    0 as libc::c_int,
                    maskwords
                        .wrapping_mul(::core::mem::size_of::<bfd_vma>() as libc::c_ulong),
                );
                memset(
                    cinfo.counts as *mut libc::c_void,
                    0 as libc::c_int,
                    bucketcount_0
                        .wrapping_mul(
                            ::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong,
                        ),
                );
                i = 0 as libc::c_int as size_t;
                while i < cinfo.nsyms {
                    let ref mut fresh30 = *(cinfo.counts)
                        .offset(
                            (*(cinfo.hashcodes).offset(i as isize))
                                .wrapping_rem(bucketcount_0) as isize,
                        );
                    *fresh30 = (*fresh30).wrapping_add(1);
                    let _ = *fresh30;
                    i = i.wrapping_add(1);
                    i;
                }
                i = 0 as libc::c_int as size_t;
                cnt = cinfo.symindx;
                while i < bucketcount_0 {
                    if *(cinfo.counts).offset(i as isize)
                        != 0 as libc::c_int as libc::c_ulong
                    {
                        *(cinfo.indx).offset(i as isize) = cnt;
                        cnt = (cnt as libc::c_ulong)
                            .wrapping_add(*(cinfo.counts).offset(i as isize)) as size_t
                            as size_t;
                    }
                    i = i.wrapping_add(1);
                    i;
                }
                if !(cnt == dynsymcount) {
                    bfd_assert(
                        b"elflink.c\0" as *const u8 as *const libc::c_char,
                        7566 as libc::c_int,
                    );
                }
                cinfo.bucketcount = bucketcount_0;
                cinfo.local_indx = cinfo.min_dynindx;
                (*s)
                    .size = (4 as libc::c_int as libc::c_ulong)
                    .wrapping_add(bucketcount_0)
                    .wrapping_add(cinfo.nsyms)
                    .wrapping_mul(4 as libc::c_int as libc::c_ulong);
                (*s)
                    .size = ((*s).size as libc::c_ulong)
                    .wrapping_add(
                        (cinfo.maskbits).wrapping_div(8 as libc::c_int as libc::c_ulong),
                    ) as bfd_size_type as bfd_size_type;
                if ((*bed).record_xhash_symbol).is_some() {
                    (*s)
                        .size = ((*s).size as libc::c_ulong)
                        .wrapping_add(
                            (cinfo.nsyms).wrapping_mul(4 as libc::c_int as libc::c_ulong),
                        ) as bfd_size_type as bfd_size_type;
                }
                contents = bfd_zalloc(output_bfd, (*s).size) as *mut libc::c_uchar;
                if contents.is_null() {
                    free(cinfo.bitmask as *mut libc::c_void);
                    free(cinfo.hashcodes as *mut libc::c_void);
                    return 0 as libc::c_int != 0;
                }
                (*s).contents = contents;
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(bucketcount_0, contents as *mut libc::c_void);
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    cinfo.symindx,
                    contents.offset(4 as libc::c_int as isize) as *mut libc::c_void,
                );
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    maskwords,
                    contents.offset(8 as libc::c_int as isize) as *mut libc::c_void,
                );
                (Some(
                    ((*(*output_bfd).xvec).bfd_putx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    cinfo.shift2 as bfd_vma,
                    contents.offset(12 as libc::c_int as isize) as *mut libc::c_void,
                );
                contents = contents
                    .offset(
                        (16 as libc::c_int as libc::c_ulong)
                            .wrapping_add(
                                (cinfo.maskbits)
                                    .wrapping_div(8 as libc::c_int as libc::c_ulong),
                            ) as isize,
                    );
                i = 0 as libc::c_int as size_t;
                while i < bucketcount_0 {
                    if *(cinfo.counts).offset(i as isize)
                        == 0 as libc::c_int as libc::c_ulong
                    {
                        (Some(
                            ((*(*output_bfd).xvec).bfd_putx32)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            0 as libc::c_int as bfd_vma,
                            contents as *mut libc::c_void,
                        );
                    } else {
                        (Some(
                            ((*(*output_bfd).xvec).bfd_putx32)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            *(cinfo.indx).offset(i as isize),
                            contents as *mut libc::c_void,
                        );
                    }
                    contents = contents.offset(4 as libc::c_int as isize);
                    i = i.wrapping_add(1);
                    i;
                }
                cinfo.contents = contents;
                cinfo
                    .xlat = contents
                    .offset(
                        (cinfo.nsyms).wrapping_mul(4 as libc::c_int as libc::c_ulong)
                            as isize,
                    )
                    .offset_from((*s).contents) as libc::c_long as bfd_size_type;
                elf_link_hash_traverse(
                    elf_hash_table(info),
                    Some(
                        elf_gnu_hash_process_symidx
                            as unsafe extern "C" fn(
                                *mut elf_link_hash_entry,
                                *mut libc::c_void,
                            ) -> bool,
                    ),
                    &mut cinfo as *mut collect_gnu_hash_codes as *mut libc::c_void,
                );
                contents = ((*s).contents).offset(16 as libc::c_int as isize);
                i = 0 as libc::c_int as size_t;
                while i < maskwords {
                    if (*(*bed).s).arch_size as libc::c_int == 8 as libc::c_int {
                        *contents = (*(cinfo.bitmask).offset(i as isize)
                            & 0xff as libc::c_int as libc::c_ulong) as libc::c_uchar;
                    } else {
                        if (*(*bed).s).arch_size as libc::c_int == 16 as libc::c_int {
                            (Some(
                                ((*(*output_bfd).xvec).bfd_putx16)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                *(cinfo.bitmask).offset(i as isize),
                                contents as *mut libc::c_void,
                            );
                        } else {
                            if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int
                            {
                                (Some(
                                    ((*(*output_bfd).xvec).bfd_putx32)
                                        .expect("non-null function pointer"),
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    *(cinfo.bitmask).offset(i as isize),
                                    contents as *mut libc::c_void,
                                );
                            } else {
                                if (*(*bed).s).arch_size as libc::c_int == 64 as libc::c_int
                                {
                                    (Some(
                                        ((*(*output_bfd).xvec).bfd_putx64)
                                            .expect("non-null function pointer"),
                                    ))
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        *(cinfo.bitmask).offset(i as isize),
                                        contents as *mut libc::c_void,
                                    );
                                } else {
                                    _bfd_abort(
                                        b"elflink.c\0" as *const u8 as *const libc::c_char,
                                        7610 as libc::c_int,
                                        (*::core::mem::transmute::<
                                            &[u8; 69],
                                            &[libc::c_char; 69],
                                        >(
                                            b"_Bool bfd_elf_size_dynsym_hash_dynstr(bfd *, struct bfd_link_info *)\0",
                                        ))
                                            .as_ptr(),
                                    );
                                };
                            };
                        };
                    };
                    contents = contents
                        .offset(
                            ((*(*bed).s).arch_size as libc::c_int / 8 as libc::c_int)
                                as isize,
                        );
                    i = i.wrapping_add(1);
                    i;
                }
                free(cinfo.bitmask as *mut libc::c_void);
                free(cinfo.hashcodes as *mut libc::c_void);
            }
        }
        s = bfd_get_linker_section(
            dynobj,
            b".dynstr\0" as *const u8 as *const libc::c_char,
        );
        if s.is_null() {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                7620 as libc::c_int,
            );
        }
        elf_finalize_dynstr(output_bfd, info);
        (*s).size = _bfd_elf_strtab_size((*elf_hash_table(info)).dynstr);
        dtagcount = 0 as libc::c_int as libc::c_uint;
        while dtagcount <= (*info).spare_dynamic_tags {
            if !_bfd_elf_add_dynamic_entry(
                info,
                0 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
            dtagcount = dtagcount.wrapping_add(1);
            dtagcount;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn merge_sections_remove_hook(
    mut _abfd: *mut bfd,
    mut sec: *mut asection,
) {
    if !((*sec).sec_info_type() as libc::c_int == 2 as libc::c_int) {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            7640 as libc::c_int,
        );
    }
    (*sec).set_sec_info_type(0 as libc::c_int as libc::c_uint);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_merge_sections(
    mut obfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut ibfd: *mut bfd = 0 as *mut bfd;
    let mut sec: *mut asection = 0 as *mut asection;
    if !is_elf_hash_table((*info).hash) {
        return 0 as libc::c_int != 0;
    }
    ibfd = (*info).input_bfds;
    while !ibfd.is_null() {
        if (*ibfd).flags & 0x40 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
            && bfd_get_flavour(ibfd) as libc::c_uint
                == bfd_target_elf_flavour as libc::c_int as libc::c_uint
            && (*((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
                .e_ident[4 as libc::c_int as usize] as libc::c_int
                == (*(*((*(*obfd).xvec).backend_data as *const elf_backend_data)).s)
                    .elfclass as libc::c_int
        {
            sec = (*ibfd).sections;
            while !sec.is_null() {
                if (*sec).flags & 0x800000 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                    && !bfd_is_abs_section((*sec).output_section)
                {
                    let mut secdata: *mut bfd_elf_section_data = 0
                        as *mut bfd_elf_section_data;
                    secdata = (*sec).used_by_bfd as *mut bfd_elf_section_data;
                    if !_bfd_add_merge_section(
                        obfd,
                        &mut (*(elf_hash_table
                            as unsafe extern "C" fn(
                                *const bfd_link_info,
                            ) -> *mut elf_link_hash_table)(info))
                            .merge_info,
                        sec,
                        &mut (*secdata).sec_info,
                    ) {
                        return 0 as libc::c_int != 0
                    } else if !((*secdata).sec_info).is_null() {
                        (*sec).set_sec_info_type(2 as libc::c_int as libc::c_uint);
                    }
                }
                sec = (*sec).next;
            }
        }
        ibfd = (*ibfd).link.next;
    }
    if !((*elf_hash_table(info)).merge_info).is_null() {
        _bfd_merge_sections(
            obfd,
            info,
            (*elf_hash_table(info)).merge_info,
            Some(
                merge_sections_remove_hook
                    as unsafe extern "C" fn(*mut bfd, *mut asection) -> (),
            ),
        );
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hash_newfunc(
    mut entry: *mut bfd_hash_entry,
    mut table: *mut bfd_hash_table,
    mut string: *const libc::c_char,
) -> *mut bfd_hash_entry {
    if entry.is_null() {
        entry = bfd_hash_allocate(
            table,
            ::core::mem::size_of::<elf_link_hash_entry>() as libc::c_ulong
                as libc::c_uint,
        ) as *mut bfd_hash_entry;
        if entry.is_null() {
            return entry;
        }
    }
    entry = _bfd_link_hash_newfunc(entry, table, string);
    if !entry.is_null() {
        let mut ret: *mut elf_link_hash_entry = entry as *mut elf_link_hash_entry;
        let mut htab: *mut elf_link_hash_table = table as *mut elf_link_hash_table;
        (*ret).indx = -(1 as libc::c_int) as libc::c_long;
        (*ret).dynindx = -(1 as libc::c_int) as libc::c_long;
        (*ret).got = (*htab).init_got_refcount;
        (*ret).plt = (*htab).init_plt_refcount;
        memset(
            &mut (*ret).size as *mut bfd_size_type as *mut libc::c_void,
            0 as libc::c_int,
            (::core::mem::size_of::<elf_link_hash_entry>() as libc::c_ulong)
                .wrapping_sub(88 as libc::c_ulong),
        );
        (*ret).set_non_elf(1 as libc::c_int as libc::c_uint);
    }
    return entry;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hash_copy_indirect(
    mut info: *mut bfd_link_info,
    mut dir: *mut elf_link_hash_entry,
    mut ind: *mut elf_link_hash_entry,
) {
    let mut htab: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    if !((*ind).dyn_relocs).is_null() {
        if !((*dir).dyn_relocs).is_null() {
            let mut pp: *mut *mut elf_dyn_relocs = 0 as *mut *mut elf_dyn_relocs;
            let mut p: *mut elf_dyn_relocs = 0 as *mut elf_dyn_relocs;
            pp = &mut (*ind).dyn_relocs;
            loop {
                p = *pp;
                if p.is_null() {
                    break;
                }
                let mut q: *mut elf_dyn_relocs = 0 as *mut elf_dyn_relocs;
                q = (*dir).dyn_relocs;
                while !q.is_null() {
                    if (*q).sec == (*p).sec {
                        (*q)
                            .pc_count = ((*q).pc_count as libc::c_ulong)
                            .wrapping_add((*p).pc_count) as bfd_size_type
                            as bfd_size_type;
                        (*q)
                            .count = ((*q).count as libc::c_ulong)
                            .wrapping_add((*p).count) as bfd_size_type as bfd_size_type;
                        *pp = (*p).next;
                        break;
                    } else {
                        q = (*q).next;
                    }
                }
                if q.is_null() {
                    pp = &mut (*p).next;
                }
            }
            *pp = (*dir).dyn_relocs;
        }
        (*dir).dyn_relocs = (*ind).dyn_relocs;
        (*ind).dyn_relocs = 0 as *mut elf_dyn_relocs;
    }
    if (*dir).versioned() as libc::c_int != versioned_hidden as libc::c_int {
        (*dir)
            .set_ref_dynamic(
                (*dir).ref_dynamic()
                    | (*ind).ref_dynamic() as libc::c_int as libc::c_uint,
            );
    }
    (*dir)
        .set_ref_regular(
            (*dir).ref_regular() | (*ind).ref_regular() as libc::c_int as libc::c_uint,
        );
    (*dir)
        .set_ref_regular_nonweak(
            (*dir).ref_regular_nonweak()
                | (*ind).ref_regular_nonweak() as libc::c_int as libc::c_uint,
        );
    (*dir)
        .set_non_got_ref(
            (*dir).non_got_ref() | (*ind).non_got_ref() as libc::c_int as libc::c_uint,
        );
    (*dir)
        .set_needs_plt(
            (*dir).needs_plt() | (*ind).needs_plt() as libc::c_int as libc::c_uint,
        );
    (*dir)
        .set_pointer_equality_needed(
            (*dir).pointer_equality_needed()
                | (*ind).pointer_equality_needed() as libc::c_int as libc::c_uint,
        );
    if ((*ind).root).type_0() as libc::c_int != bfd_link_hash_indirect as libc::c_int {
        return;
    }
    htab = elf_hash_table(info);
    if (*ind).got.refcount > (*htab).init_got_refcount.refcount {
        if (*dir).got.refcount < 0 as libc::c_int as libc::c_long {
            (*dir).got.refcount = 0 as libc::c_int as bfd_signed_vma;
        }
        (*dir).got.refcount += (*ind).got.refcount;
        (*ind).got.refcount = (*htab).init_got_refcount.refcount;
    }
    if (*ind).plt.refcount > (*htab).init_plt_refcount.refcount {
        if (*dir).plt.refcount < 0 as libc::c_int as libc::c_long {
            (*dir).plt.refcount = 0 as libc::c_int as bfd_signed_vma;
        }
        (*dir).plt.refcount += (*ind).plt.refcount;
        (*ind).plt.refcount = (*htab).init_plt_refcount.refcount;
    }
    if (*ind).dynindx != -(1 as libc::c_int) as libc::c_long {
        if (*dir).dynindx != -(1 as libc::c_int) as libc::c_long {
            _bfd_elf_strtab_delref((*htab).dynstr, (*dir).dynstr_index);
        }
        (*dir).dynindx = (*ind).dynindx;
        (*dir).dynstr_index = (*ind).dynstr_index;
        (*ind).dynindx = -(1 as libc::c_int) as libc::c_long;
        (*ind).dynstr_index = 0 as libc::c_int as libc::c_ulong;
    }
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hash_hide_symbol(
    mut info: *mut bfd_link_info,
    mut h: *mut elf_link_hash_entry,
    mut force_local: bool,
) {
    if (*h).type_0() as libc::c_int != 10 as libc::c_int {
        (*h).plt = (*elf_hash_table(info)).init_plt_offset;
        (*h).set_needs_plt(0 as libc::c_int as libc::c_uint);
    }
    if force_local {
        (*h).set_forced_local(1 as libc::c_int as libc::c_uint);
        if (*h).dynindx != -(1 as libc::c_int) as libc::c_long {
            _bfd_elf_strtab_delref((*elf_hash_table(info)).dynstr, (*h).dynstr_index);
            (*h).dynindx = -(1 as libc::c_int) as libc::c_long;
            (*h).dynstr_index = 0 as libc::c_int as libc::c_ulong;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hide_symbol(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut h: *mut bfd_link_hash_entry,
) {
    if is_elf_hash_table((*info).hash) {
        let mut bed: *const elf_backend_data = (*(*output_bfd).xvec).backend_data
            as *const elf_backend_data;
        let mut eh: *mut elf_link_hash_entry = h as *mut elf_link_hash_entry;
        ((*bed).elf_backend_hide_symbol)
            .expect("non-null function pointer")(info, eh, 1 as libc::c_int != 0);
        (*eh).set_def_dynamic(0 as libc::c_int as libc::c_uint);
        (*eh).set_ref_dynamic(0 as libc::c_int as libc::c_uint);
        (*eh).set_dynamic_def(0 as libc::c_int as libc::c_uint);
    }
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hash_table_init(
    mut table: *mut elf_link_hash_table,
    mut abfd: *mut bfd,
    mut newfunc: Option::<
        unsafe extern "C" fn(
            *mut bfd_hash_entry,
            *mut bfd_hash_table,
            *const libc::c_char,
        ) -> *mut bfd_hash_entry,
    >,
    mut entsize: libc::c_uint,
    mut target_id: elf_target_id,
) -> bool {
    let mut ret: bool = false;
    let mut can_refcount: libc::c_int = (*((*(*abfd).xvec).backend_data
        as *const elf_backend_data))
        .can_refcount() as libc::c_int;
    (*table)
        .init_got_refcount
        .refcount = (can_refcount - 1 as libc::c_int) as bfd_signed_vma;
    (*table)
        .init_plt_refcount
        .refcount = (can_refcount - 1 as libc::c_int) as bfd_signed_vma;
    (*table).init_got_offset.offset = (1 as libc::c_int as bfd_vma).wrapping_neg();
    (*table).init_plt_offset.offset = (1 as libc::c_int as bfd_vma).wrapping_neg();
    (*table).dynsymcount = 1 as libc::c_int as bfd_size_type;
    ret = _bfd_link_hash_table_init(&mut (*table).root, abfd, newfunc, entsize);
    (*table).root.type_0 = bfd_link_elf_hash_table;
    (*table).hash_table_id = target_id;
    (*table)
        .target_os = (*((*(*abfd).xvec).backend_data as *const elf_backend_data))
        .target_os;
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hash_table_create(
    mut abfd: *mut bfd,
) -> *mut bfd_link_hash_table {
    let mut ret: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut amt: size_t = ::core::mem::size_of::<elf_link_hash_table>() as libc::c_ulong;
    ret = bfd_zmalloc(amt) as *mut elf_link_hash_table;
    if ret.is_null() {
        return 0 as *mut bfd_link_hash_table;
    }
    if !_bfd_elf_link_hash_table_init(
        ret,
        abfd,
        Some(
            _bfd_elf_link_hash_newfunc
                as unsafe extern "C" fn(
                    *mut bfd_hash_entry,
                    *mut bfd_hash_table,
                    *const libc::c_char,
                ) -> *mut bfd_hash_entry,
        ),
        ::core::mem::size_of::<elf_link_hash_entry>() as libc::c_ulong as libc::c_uint,
        GENERIC_ELF_DATA,
    ) {
        free(ret as *mut libc::c_void);
        return 0 as *mut bfd_link_hash_table;
    }
    (*ret)
        .root
        .hash_table_free = Some(
        _bfd_elf_link_hash_table_free as unsafe extern "C" fn(*mut bfd) -> (),
    );
    return &mut (*ret).root;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_link_hash_table_free(mut obfd: *mut bfd) {
    let mut htab: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    htab = (*obfd).link.hash as *mut elf_link_hash_table;
    if !((*htab).dynstr).is_null() {
        _bfd_elf_strtab_free((*htab).dynstr);
    }
    _bfd_merge_sections_free((*htab).merge_info);
    _bfd_generic_link_hash_table_free(obfd);
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_set_dt_needed_name(
    mut abfd: *mut bfd,
    mut name: *const libc::c_char,
) {
    if bfd_get_flavour(abfd) as libc::c_uint
        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && bfd_get_format(abfd) as libc::c_uint
            == bfd_object as libc::c_int as libc::c_uint
    {
        (*(*abfd).tdata.elf_obj_data).dt_name = name;
    }
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_get_dyn_lib_class(mut abfd: *mut bfd) -> libc::c_int {
    let mut lib_class: libc::c_int = 0;
    if bfd_get_flavour(abfd) as libc::c_uint
        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && bfd_get_format(abfd) as libc::c_uint
            == bfd_object as libc::c_int as libc::c_uint
    {
        lib_class = (*(*abfd).tdata.elf_obj_data).dyn_lib_class() as libc::c_int;
    } else {
        lib_class = 0 as libc::c_int;
    }
    return lib_class;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_set_dyn_lib_class(
    mut abfd: *mut bfd,
    mut lib_class: dynamic_lib_link_class,
) {
    if bfd_get_flavour(abfd) as libc::c_uint
        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && bfd_get_format(abfd) as libc::c_uint
            == bfd_object as libc::c_int as libc::c_uint
    {
        (*(*abfd).tdata.elf_obj_data).set_dyn_lib_class(lib_class);
    }
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_get_needed_list(
    mut _abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> *mut bfd_link_needed_list {
    if !is_elf_hash_table((*info).hash) {
        return 0 as *mut bfd_link_needed_list;
    }
    return (*elf_hash_table(info)).needed;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_get_runpath_list(
    mut _abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> *mut bfd_link_needed_list {
    if !is_elf_hash_table((*info).hash) {
        return 0 as *mut bfd_link_needed_list;
    }
    return (*elf_hash_table(info)).runpath;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_get_dt_soname(
    mut abfd: *mut bfd,
) -> *const libc::c_char {
    if bfd_get_flavour(abfd) as libc::c_uint
        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && bfd_get_format(abfd) as libc::c_uint
            == bfd_object as libc::c_int as libc::c_uint
    {
        return (*(*abfd).tdata.elf_obj_data).dt_name;
    }
    return 0 as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_get_bfd_needed_list(
    mut abfd: *mut bfd,
    mut pneeded: *mut *mut bfd_link_needed_list,
) -> bool {
    let mut current_block: u64;
    let mut s: *mut asection = 0 as *mut asection;
    let mut dynbuf: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut elfsec: libc::c_uint = 0;
    let mut shlink: libc::c_ulong = 0;
    let mut extdyn: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut extdynend: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut extdynsize: size_t = 0;
    let mut swap_dyn_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_void, *mut Elf_Internal_Dyn) -> (),
    > = None;
    *pneeded = 0 as *mut bfd_link_needed_list;
    if bfd_get_flavour(abfd) as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || bfd_get_format(abfd) as libc::c_uint
            != bfd_object as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    s = bfd_get_section_by_name(abfd, b".dynamic\0" as *const u8 as *const libc::c_char);
    if s.is_null() || (*s).size == 0 as libc::c_int as libc::c_ulong {
        return 1 as libc::c_int != 0;
    }
    if bfd_malloc_and_get_section(abfd, s, &mut dynbuf) {
        elfsec = _bfd_elf_section_from_bfd_section(abfd, s);
        if !(elfsec == (0x101 as libc::c_uint).wrapping_neg()) {
            shlink = (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                .offset(elfsec as isize))
                .sh_link as libc::c_ulong;
            extdynsize = (*(*((*(*abfd).xvec).backend_data as *const elf_backend_data))
                .s)
                .sizeof_dyn as size_t;
            swap_dyn_in = (*(*((*(*abfd).xvec).backend_data as *const elf_backend_data))
                .s)
                .swap_dyn_in;
            extdyn = dynbuf;
            extdynend = extdyn.offset((*s).size as isize);
            loop {
                if !(extdyn < extdynend) {
                    current_block = 16203760046146113240;
                    break;
                }
                let mut dyn_0: Elf_Internal_Dyn = Elf_Internal_Dyn {
                    d_tag: 0,
                    d_un: C2RustUnnamed_21 { d_val: 0 },
                };
                (Some(swap_dyn_in.expect("non-null function pointer")))
                    .expect(
                        "non-null function pointer",
                    )(abfd, extdyn as *const libc::c_void, &mut dyn_0);
                if dyn_0.d_tag == 0 as libc::c_int as libc::c_ulong {
                    current_block = 16203760046146113240;
                    break;
                }
                if dyn_0.d_tag == 1 as libc::c_int as libc::c_ulong {
                    let mut string: *const libc::c_char = 0 as *const libc::c_char;
                    let mut l: *mut bfd_link_needed_list = 0
                        as *mut bfd_link_needed_list;
                    let mut tagv: libc::c_uint = dyn_0.d_un.d_val as libc::c_uint;
                    let mut amt: size_t = 0;
                    string = bfd_elf_string_from_elf_section(
                        abfd,
                        shlink as libc::c_uint,
                        tagv,
                    );
                    if string.is_null() {
                        current_block = 14085438723958216153;
                        break;
                    }
                    amt = ::core::mem::size_of::<bfd_link_needed_list>()
                        as libc::c_ulong;
                    l = bfd_alloc(abfd, amt) as *mut bfd_link_needed_list;
                    if l.is_null() {
                        current_block = 14085438723958216153;
                        break;
                    }
                    (*l).by = abfd;
                    (*l).name = string;
                    (*l).next = *pneeded;
                    *pneeded = l;
                }
                extdyn = extdyn.offset(extdynsize as isize);
            }
            match current_block {
                14085438723958216153 => {}
                _ => {
                    free(dynbuf as *mut libc::c_void);
                    return 1 as libc::c_int != 0;
                }
            }
        }
    }
    free(dynbuf as *mut libc::c_void);
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn elf_sort_elf_symbol(
    mut arg1: *const libc::c_void,
    mut arg2: *const libc::c_void,
) -> libc::c_int {
    let mut s1: *const Elf_Internal_Sym = *(arg1 as *mut *const Elf_Internal_Sym);
    let mut s2: *const Elf_Internal_Sym = *(arg2 as *mut *const Elf_Internal_Sym);
    if (*s1).st_shndx != (*s2).st_shndx {
        return if (*s1).st_shndx > (*s2).st_shndx {
            1 as libc::c_int
        } else {
            -(1 as libc::c_int)
        };
    }
    if s1 != s2 {
        return if s1 > s2 { 1 as libc::c_int } else { -(1 as libc::c_int) };
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn elf_sym_name_compare(
    mut arg1: *const libc::c_void,
    mut arg2: *const libc::c_void,
) -> libc::c_int {
    let mut s1: *const elf_symbol = arg1 as *const elf_symbol;
    let mut s2: *const elf_symbol = arg2 as *const elf_symbol;
    let mut ret: libc::c_int = strcmp((*s1).name, (*s2).name);
    if ret != 0 as libc::c_int {
        return ret;
    }
    if (*s1).u.p != (*s2).u.p {
        return if (*s1).u.p > (*s2).u.p {
            1 as libc::c_int
        } else {
            -(1 as libc::c_int)
        };
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn elf_create_symbuf(
    mut symcount: size_t,
    mut isymbuf: *mut Elf_Internal_Sym,
) -> *mut elf_symbuf_head {
    let mut ind: *mut *mut Elf_Internal_Sym = 0 as *mut *mut Elf_Internal_Sym;
    let mut indbufend: *mut *mut Elf_Internal_Sym = 0 as *mut *mut Elf_Internal_Sym;
    let mut indbuf: *mut *mut Elf_Internal_Sym = 0 as *mut *mut Elf_Internal_Sym;
    let mut ssym: *mut elf_symbuf_symbol = 0 as *mut elf_symbuf_symbol;
    let mut ssymbuf: *mut elf_symbuf_head = 0 as *mut elf_symbuf_head;
    let mut ssymhead: *mut elf_symbuf_head = 0 as *mut elf_symbuf_head;
    let mut i: size_t = 0;
    let mut shndx_count: size_t = 0;
    let mut total_size: size_t = 0;
    let mut amt: size_t = 0;
    amt = symcount
        .wrapping_mul(::core::mem::size_of::<*mut Elf_Internal_Sym>() as libc::c_ulong);
    indbuf = bfd_malloc(amt) as *mut *mut Elf_Internal_Sym;
    if indbuf.is_null() {
        return 0 as *mut elf_symbuf_head;
    }
    ind = indbuf;
    i = 0 as libc::c_int as size_t;
    while i < symcount {
        if (*isymbuf.offset(i as isize)).st_shndx != 0 as libc::c_int as libc::c_uint {
            let fresh31 = ind;
            ind = ind.offset(1);
            *fresh31 = &mut *isymbuf.offset(i as isize) as *mut Elf_Internal_Sym;
        }
        i = i.wrapping_add(1);
        i;
    }
    indbufend = ind;
    qsort(
        indbuf as *mut libc::c_void,
        indbufend.offset_from(indbuf) as libc::c_long as size_t,
        ::core::mem::size_of::<*mut Elf_Internal_Sym>() as libc::c_ulong,
        Some(
            elf_sort_elf_symbol
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    shndx_count = 0 as libc::c_int as size_t;
    if indbufend > indbuf {
        ind = indbuf;
        shndx_count = shndx_count.wrapping_add(1);
        shndx_count;
        while ind < indbufend.offset(-(1 as libc::c_int as isize)) {
            if (**ind.offset(0 as libc::c_int as isize)).st_shndx
                != (**ind.offset(1 as libc::c_int as isize)).st_shndx
            {
                shndx_count = shndx_count.wrapping_add(1);
                shndx_count;
            }
            ind = ind.offset(1);
            ind;
        }
    }
    total_size = shndx_count
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_mul(::core::mem::size_of::<elf_symbuf_head>() as libc::c_ulong)
        .wrapping_add(
            (indbufend.offset_from(indbuf) as libc::c_long as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<elf_symbuf_symbol>() as libc::c_ulong,
                ),
        );
    ssymbuf = bfd_malloc(total_size) as *mut elf_symbuf_head;
    if ssymbuf.is_null() {
        free(indbuf as *mut libc::c_void);
        return 0 as *mut elf_symbuf_head;
    }
    ssym = ssymbuf.offset(shndx_count as isize).offset(1 as libc::c_int as isize)
        as *mut elf_symbuf_symbol;
    (*ssymbuf).ssym = 0 as *mut elf_symbuf_symbol;
    (*ssymbuf).count = shndx_count;
    (*ssymbuf).st_shndx = 0 as libc::c_int as libc::c_uint;
    ssymhead = ssymbuf;
    ind = indbuf;
    while ind < indbufend {
        if ind == indbuf || (*ssymhead).st_shndx != (**ind).st_shndx {
            ssymhead = ssymhead.offset(1);
            ssymhead;
            (*ssymhead).ssym = ssym;
            (*ssymhead).count = 0 as libc::c_int as size_t;
            (*ssymhead).st_shndx = (**ind).st_shndx;
        }
        (*ssym).st_name = (**ind).st_name;
        (*ssym).st_info = (**ind).st_info;
        (*ssym).st_other = (**ind).st_other;
        (*ssymhead).count = ((*ssymhead).count).wrapping_add(1);
        (*ssymhead).count;
        ssym = ssym.offset(1);
        ssym;
        ind = ind.offset(1);
        ind;
    }
    if !(ssymhead.offset_from(ssymbuf) as libc::c_long as size_t == shndx_count
        && (ssym as bfd_hostptr_t).wrapping_sub(ssymbuf as bfd_hostptr_t) == total_size)
    {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            8181 as libc::c_int,
        );
    }
    free(indbuf as *mut libc::c_void);
    return ssymbuf;
}
unsafe extern "C" fn bfd_elf_match_symbols_in_sections(
    mut sec1: *mut asection,
    mut sec2: *mut asection,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut current_block: u64;
    let mut bfd1: *mut bfd = 0 as *mut bfd;
    let mut bfd2: *mut bfd = 0 as *mut bfd;
    let mut bed1: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut bed2: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut hdr1: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut hdr2: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symcount1: size_t = 0;
    let mut symcount2: size_t = 0;
    let mut isymbuf1: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isymbuf2: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut ssymbuf1: *mut elf_symbuf_head = 0 as *mut elf_symbuf_head;
    let mut ssymbuf2: *mut elf_symbuf_head = 0 as *mut elf_symbuf_head;
    let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isymend: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut symtable1: *mut elf_symbol = 0 as *mut elf_symbol;
    let mut symtable2: *mut elf_symbol = 0 as *mut elf_symbol;
    let mut count1: size_t = 0;
    let mut count2: size_t = 0;
    let mut sec_count1: size_t = 0;
    let mut sec_count2: size_t = 0;
    let mut i: size_t = 0;
    let mut shndx1: libc::c_uint = 0;
    let mut shndx2: libc::c_uint = 0;
    let mut result: bool = false;
    let mut ignore_section_symbol_p: bool = false;
    bfd1 = (*sec1).owner;
    bfd2 = (*sec2).owner;
    if bfd_get_flavour(bfd1) as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || bfd_get_flavour(bfd2) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    if (*((*sec1).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
        != (*((*sec2).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
    {
        return 0 as libc::c_int != 0;
    }
    shndx1 = _bfd_elf_section_from_bfd_section(bfd1, sec1);
    shndx2 = _bfd_elf_section_from_bfd_section(bfd2, sec2);
    if shndx1 == (0x101 as libc::c_uint).wrapping_neg()
        || shndx2 == (0x101 as libc::c_uint).wrapping_neg()
    {
        return 0 as libc::c_int != 0;
    }
    bed1 = (*(*bfd1).xvec).backend_data as *const elf_backend_data;
    bed2 = (*(*bfd2).xvec).backend_data as *const elf_backend_data;
    hdr1 = &mut (*(*bfd1).tdata.elf_obj_data).symtab_hdr;
    symcount1 = ((*hdr1).sh_size).wrapping_div((*(*bed1).s).sizeof_sym as libc::c_ulong);
    hdr2 = &mut (*(*bfd2).tdata.elf_obj_data).symtab_hdr;
    symcount2 = ((*hdr2).sh_size).wrapping_div((*(*bed2).s).sizeof_sym as libc::c_ulong);
    if symcount1 == 0 as libc::c_int as libc::c_ulong
        || symcount2 == 0 as libc::c_int as libc::c_ulong
    {
        return 0 as libc::c_int != 0;
    }
    result = 0 as libc::c_int != 0;
    isymbuf1 = 0 as *mut Elf_Internal_Sym;
    isymbuf2 = 0 as *mut Elf_Internal_Sym;
    ssymbuf1 = (*(*bfd1).tdata.elf_obj_data).symbuf as *mut elf_symbuf_head;
    ssymbuf2 = (*(*bfd2).tdata.elf_obj_data).symbuf as *mut elf_symbuf_head;
    ignore_section_symbol_p = (*sec1).flags & 0x2000 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
        || (*((*sec1).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_flags
            & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong
            != (*((*sec2).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_flags
                & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong;
    if ssymbuf1.is_null() {
        isymbuf1 = bfd_elf_get_elf_syms(
            bfd1,
            hdr1,
            symcount1,
            0 as libc::c_int as size_t,
            0 as *mut Elf_Internal_Sym,
            0 as *mut libc::c_void,
            0 as *mut Elf_External_Sym_Shndx,
        );
        if isymbuf1.is_null() {
            current_block = 10221030044040033300;
        } else {
            if !info.is_null() && (*info).reduce_memory_overheads() == 0 {
                ssymbuf1 = elf_create_symbuf(symcount1, isymbuf1);
                (*(*bfd1).tdata.elf_obj_data).symbuf = ssymbuf1 as *mut libc::c_void;
            }
            current_block = 18386322304582297246;
        }
    } else {
        current_block = 18386322304582297246;
    }
    match current_block {
        18386322304582297246 => {
            if ssymbuf1.is_null() || ssymbuf2.is_null() {
                isymbuf2 = bfd_elf_get_elf_syms(
                    bfd2,
                    hdr2,
                    symcount2,
                    0 as libc::c_int as size_t,
                    0 as *mut Elf_Internal_Sym,
                    0 as *mut libc::c_void,
                    0 as *mut Elf_External_Sym_Shndx,
                );
                if isymbuf2.is_null() {
                    current_block = 10221030044040033300;
                } else {
                    if !ssymbuf1.is_null() && !info.is_null()
                        && (*info).reduce_memory_overheads() == 0
                    {
                        ssymbuf2 = elf_create_symbuf(symcount2, isymbuf2);
                        (*(*bfd2).tdata.elf_obj_data)
                            .symbuf = ssymbuf2 as *mut libc::c_void;
                    }
                    current_block = 5494826135382683477;
                }
            } else {
                current_block = 5494826135382683477;
            }
            match current_block {
                10221030044040033300 => {}
                _ => {
                    if !ssymbuf1.is_null() && !ssymbuf2.is_null() {
                        let mut lo: size_t = 0;
                        let mut hi: size_t = 0;
                        let mut mid: size_t = 0;
                        let mut symp: *mut elf_symbol = 0 as *mut elf_symbol;
                        let mut ssym: *mut elf_symbuf_symbol = 0
                            as *mut elf_symbuf_symbol;
                        let mut ssymend: *mut elf_symbuf_symbol = 0
                            as *mut elf_symbuf_symbol;
                        lo = 0 as libc::c_int as size_t;
                        hi = (*ssymbuf1).count;
                        ssymbuf1 = ssymbuf1.offset(1);
                        ssymbuf1;
                        count1 = 0 as libc::c_int as size_t;
                        sec_count1 = 0 as libc::c_int as size_t;
                        while lo < hi {
                            mid = lo
                                .wrapping_add(hi)
                                .wrapping_div(2 as libc::c_int as libc::c_ulong);
                            if shndx1 < (*ssymbuf1.offset(mid as isize)).st_shndx {
                                hi = mid;
                            } else if shndx1 > (*ssymbuf1.offset(mid as isize)).st_shndx
                            {
                                lo = mid.wrapping_add(1 as libc::c_int as libc::c_ulong);
                            } else {
                                count1 = (*ssymbuf1.offset(mid as isize)).count;
                                ssymbuf1 = ssymbuf1.offset(mid as isize);
                                break;
                            }
                        }
                        if ignore_section_symbol_p {
                            i = 0 as libc::c_int as size_t;
                            while i < count1 {
                                if (*((*ssymbuf1).ssym).offset(i as isize)).st_info
                                    as libc::c_int & 0xf as libc::c_int == 3 as libc::c_int
                                {
                                    sec_count1 = sec_count1.wrapping_add(1);
                                    sec_count1;
                                }
                                i = i.wrapping_add(1);
                                i;
                            }
                            count1 = (count1 as libc::c_ulong).wrapping_sub(sec_count1)
                                as size_t as size_t;
                        }
                        lo = 0 as libc::c_int as size_t;
                        hi = (*ssymbuf2).count;
                        ssymbuf2 = ssymbuf2.offset(1);
                        ssymbuf2;
                        count2 = 0 as libc::c_int as size_t;
                        sec_count2 = 0 as libc::c_int as size_t;
                        while lo < hi {
                            mid = lo
                                .wrapping_add(hi)
                                .wrapping_div(2 as libc::c_int as libc::c_ulong);
                            if shndx2 < (*ssymbuf2.offset(mid as isize)).st_shndx {
                                hi = mid;
                            } else if shndx2 > (*ssymbuf2.offset(mid as isize)).st_shndx
                            {
                                lo = mid.wrapping_add(1 as libc::c_int as libc::c_ulong);
                            } else {
                                count2 = (*ssymbuf2.offset(mid as isize)).count;
                                ssymbuf2 = ssymbuf2.offset(mid as isize);
                                break;
                            }
                        }
                        if ignore_section_symbol_p {
                            i = 0 as libc::c_int as size_t;
                            while i < count2 {
                                if (*((*ssymbuf2).ssym).offset(i as isize)).st_info
                                    as libc::c_int & 0xf as libc::c_int == 3 as libc::c_int
                                {
                                    sec_count2 = sec_count2.wrapping_add(1);
                                    sec_count2;
                                }
                                i = i.wrapping_add(1);
                                i;
                            }
                            count2 = (count2 as libc::c_ulong).wrapping_sub(sec_count2)
                                as size_t as size_t;
                        }
                        if !(count1 == 0 as libc::c_int as libc::c_ulong
                            || count2 == 0 as libc::c_int as libc::c_ulong
                            || count1 != count2)
                        {
                            symtable1 = bfd_malloc(
                                count1
                                    .wrapping_mul(
                                        ::core::mem::size_of::<elf_symbol>() as libc::c_ulong,
                                    ),
                            ) as *mut elf_symbol;
                            symtable2 = bfd_malloc(
                                count2
                                    .wrapping_mul(
                                        ::core::mem::size_of::<elf_symbol>() as libc::c_ulong,
                                    ),
                            ) as *mut elf_symbol;
                            if !(symtable1.is_null() || symtable2.is_null()) {
                                symp = symtable1;
                                ssym = (*ssymbuf1).ssym;
                                ssymend = ssym
                                    .offset(count1 as isize)
                                    .offset(sec_count1 as isize);
                                while ssym < ssymend {
                                    if sec_count1 == 0 as libc::c_int as libc::c_ulong
                                        || (*ssym).st_info as libc::c_int & 0xf as libc::c_int
                                            != 3 as libc::c_int
                                    {
                                        (*symp).u.ssym = ssym;
                                        (*symp)
                                            .name = bfd_elf_string_from_elf_section(
                                            bfd1,
                                            (*hdr1).sh_link,
                                            (*ssym).st_name as libc::c_uint,
                                        );
                                        symp = symp.offset(1);
                                        symp;
                                    }
                                    ssym = ssym.offset(1);
                                    ssym;
                                }
                                symp = symtable2;
                                ssym = (*ssymbuf2).ssym;
                                ssymend = ssym
                                    .offset(count2 as isize)
                                    .offset(sec_count2 as isize);
                                while ssym < ssymend {
                                    if sec_count2 == 0 as libc::c_int as libc::c_ulong
                                        || (*ssym).st_info as libc::c_int & 0xf as libc::c_int
                                            != 3 as libc::c_int
                                    {
                                        (*symp).u.ssym = ssym;
                                        (*symp)
                                            .name = bfd_elf_string_from_elf_section(
                                            bfd2,
                                            (*hdr2).sh_link,
                                            (*ssym).st_name as libc::c_uint,
                                        );
                                        symp = symp.offset(1);
                                        symp;
                                    }
                                    ssym = ssym.offset(1);
                                    ssym;
                                }
                                qsort(
                                    symtable1 as *mut libc::c_void,
                                    count1,
                                    ::core::mem::size_of::<elf_symbol>() as libc::c_ulong,
                                    Some(
                                        elf_sym_name_compare
                                            as unsafe extern "C" fn(
                                                *const libc::c_void,
                                                *const libc::c_void,
                                            ) -> libc::c_int,
                                    ),
                                );
                                qsort(
                                    symtable2 as *mut libc::c_void,
                                    count1,
                                    ::core::mem::size_of::<elf_symbol>() as libc::c_ulong,
                                    Some(
                                        elf_sym_name_compare
                                            as unsafe extern "C" fn(
                                                *const libc::c_void,
                                                *const libc::c_void,
                                            ) -> libc::c_int,
                                    ),
                                );
                                i = 0 as libc::c_int as size_t;
                                loop {
                                    if !(i < count1) {
                                        current_block = 10393716428851982524;
                                        break;
                                    }
                                    if (*(*symtable1.offset(i as isize)).u.ssym).st_info
                                        as libc::c_int
                                        != (*(*symtable2.offset(i as isize)).u.ssym).st_info
                                            as libc::c_int
                                        || (*(*symtable1.offset(i as isize)).u.ssym).st_other
                                            as libc::c_int
                                            != (*(*symtable2.offset(i as isize)).u.ssym).st_other
                                                as libc::c_int
                                        || strcmp(
                                            (*symtable1.offset(i as isize)).name,
                                            (*symtable2.offset(i as isize)).name,
                                        ) != 0 as libc::c_int
                                    {
                                        current_block = 10221030044040033300;
                                        break;
                                    }
                                    i = i.wrapping_add(1);
                                    i;
                                }
                                match current_block {
                                    10221030044040033300 => {}
                                    _ => {
                                        result = 1 as libc::c_int != 0;
                                    }
                                }
                            }
                        }
                    } else {
                        symtable1 = bfd_malloc(
                            symcount1
                                .wrapping_mul(
                                    ::core::mem::size_of::<elf_symbol>() as libc::c_ulong,
                                ),
                        ) as *mut elf_symbol;
                        symtable2 = bfd_malloc(
                            symcount2
                                .wrapping_mul(
                                    ::core::mem::size_of::<elf_symbol>() as libc::c_ulong,
                                ),
                        ) as *mut elf_symbol;
                        if !(symtable1.is_null() || symtable2.is_null()) {
                            count1 = 0 as libc::c_int as size_t;
                            isym = isymbuf1;
                            isymend = isym.offset(symcount1 as isize);
                            while isym < isymend {
                                if (*isym).st_shndx == shndx1
                                    && (!ignore_section_symbol_p
                                        || (*isym).st_info as libc::c_int & 0xf as libc::c_int
                                            != 3 as libc::c_int)
                                {
                                    let fresh32 = count1;
                                    count1 = count1.wrapping_add(1);
                                    let ref mut fresh33 = (*symtable1.offset(fresh32 as isize))
                                        .u
                                        .isym;
                                    *fresh33 = isym;
                                }
                                isym = isym.offset(1);
                                isym;
                            }
                            count2 = 0 as libc::c_int as size_t;
                            isym = isymbuf2;
                            isymend = isym.offset(symcount2 as isize);
                            while isym < isymend {
                                if (*isym).st_shndx == shndx2
                                    && (!ignore_section_symbol_p
                                        || (*isym).st_info as libc::c_int & 0xf as libc::c_int
                                            != 3 as libc::c_int)
                                {
                                    let fresh34 = count2;
                                    count2 = count2.wrapping_add(1);
                                    let ref mut fresh35 = (*symtable2.offset(fresh34 as isize))
                                        .u
                                        .isym;
                                    *fresh35 = isym;
                                }
                                isym = isym.offset(1);
                                isym;
                            }
                            if !(count1 == 0 as libc::c_int as libc::c_ulong
                                || count2 == 0 as libc::c_int as libc::c_ulong
                                || count1 != count2)
                            {
                                i = 0 as libc::c_int as size_t;
                                while i < count1 {
                                    let ref mut fresh36 = (*symtable1.offset(i as isize)).name;
                                    *fresh36 = bfd_elf_string_from_elf_section(
                                        bfd1,
                                        (*hdr1).sh_link,
                                        (*(*symtable1.offset(i as isize)).u.isym).st_name
                                            as libc::c_uint,
                                    );
                                    i = i.wrapping_add(1);
                                    i;
                                }
                                i = 0 as libc::c_int as size_t;
                                while i < count2 {
                                    let ref mut fresh37 = (*symtable2.offset(i as isize)).name;
                                    *fresh37 = bfd_elf_string_from_elf_section(
                                        bfd2,
                                        (*hdr2).sh_link,
                                        (*(*symtable2.offset(i as isize)).u.isym).st_name
                                            as libc::c_uint,
                                    );
                                    i = i.wrapping_add(1);
                                    i;
                                }
                                qsort(
                                    symtable1 as *mut libc::c_void,
                                    count1,
                                    ::core::mem::size_of::<elf_symbol>() as libc::c_ulong,
                                    Some(
                                        elf_sym_name_compare
                                            as unsafe extern "C" fn(
                                                *const libc::c_void,
                                                *const libc::c_void,
                                            ) -> libc::c_int,
                                    ),
                                );
                                qsort(
                                    symtable2 as *mut libc::c_void,
                                    count1,
                                    ::core::mem::size_of::<elf_symbol>() as libc::c_ulong,
                                    Some(
                                        elf_sym_name_compare
                                            as unsafe extern "C" fn(
                                                *const libc::c_void,
                                                *const libc::c_void,
                                            ) -> libc::c_int,
                                    ),
                                );
                                i = 0 as libc::c_int as size_t;
                                loop {
                                    if !(i < count1) {
                                        current_block = 2463987395154258233;
                                        break;
                                    }
                                    if (*(*symtable1.offset(i as isize)).u.isym).st_info
                                        as libc::c_int
                                        != (*(*symtable2.offset(i as isize)).u.isym).st_info
                                            as libc::c_int
                                        || (*(*symtable1.offset(i as isize)).u.isym).st_other
                                            as libc::c_int
                                            != (*(*symtable2.offset(i as isize)).u.isym).st_other
                                                as libc::c_int
                                        || strcmp(
                                            (*symtable1.offset(i as isize)).name,
                                            (*symtable2.offset(i as isize)).name,
                                        ) != 0 as libc::c_int
                                    {
                                        current_block = 10221030044040033300;
                                        break;
                                    }
                                    i = i.wrapping_add(1);
                                    i;
                                }
                                match current_block {
                                    10221030044040033300 => {}
                                    _ => {
                                        result = 1 as libc::c_int != 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    free(symtable1 as *mut libc::c_void);
    free(symtable2 as *mut libc::c_void);
    free(isymbuf1 as *mut libc::c_void);
    free(isymbuf2 as *mut libc::c_void);
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_match_sections_by_type(
    mut abfd: *mut bfd,
    mut asec: *const asection,
    mut bbfd: *mut bfd,
    mut bsec: *const asection,
) -> bool {
    if asec.is_null() || bsec.is_null()
        || (*(*abfd).xvec).flavour as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || (*(*bbfd).xvec).flavour as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    return (*((*asec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
        == (*((*bsec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type;
}
unsafe extern "C" fn local_hash_newfunc(
    mut entry: *mut bfd_hash_entry,
    mut table: *mut bfd_hash_table,
    mut string: *const libc::c_char,
) -> *mut bfd_hash_entry {
    if entry.is_null() {
        entry = bfd_hash_allocate(
            table,
            ::core::mem::size_of::<local_hash_entry>() as libc::c_ulong as libc::c_uint,
        ) as *mut bfd_hash_entry;
        if entry.is_null() {
            return entry;
        }
    }
    entry = bfd_hash_newfunc(entry, table, string);
    if !entry.is_null() {
        (*(entry as *mut local_hash_entry)).count = 0 as libc::c_int as libc::c_long;
        (*(entry as *mut local_hash_entry)).size = 0 as libc::c_int as size_t;
    }
    return entry;
}
unsafe extern "C" fn set_symbol_value(
    mut bfd_with_globals: *mut bfd,
    mut isymbuf: *mut Elf_Internal_Sym,
    mut locsymcount: size_t,
    mut symidx: size_t,
    mut val: bfd_vma,
) {
    let mut sym_hashes: *mut *mut elf_link_hash_entry = 0
        as *mut *mut elf_link_hash_entry;
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut extsymoff: size_t = locsymcount;
    if symidx < locsymcount {
        let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        sym = isymbuf.offset(symidx as isize);
        if (*sym).st_info as libc::c_uint >> 4 as libc::c_int
            == 0 as libc::c_int as libc::c_uint
        {
            (*sym).st_shndx = (0xf as libc::c_uint).wrapping_neg();
            (*sym).st_value = val;
            return;
        }
        if (*(*bfd_with_globals).tdata.elf_obj_data).bad_symtab() == 0 {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                8609 as libc::c_int,
            );
        }
        extsymoff = 0 as libc::c_int as size_t;
    }
    sym_hashes = (*(*bfd_with_globals).tdata.elf_obj_data).sym_hashes;
    h = *sym_hashes.offset(symidx.wrapping_sub(extsymoff) as isize);
    while ((*h).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_warning as libc::c_int
    {
        h = (*h).root.u.i.link as *mut elf_link_hash_entry;
    }
    ((*h).root).set_type_0(bfd_link_hash_defined);
    (*h).root.u.def.value = val;
    (*h)
        .root
        .u
        .def
        .section = &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
        as *mut asection;
}
unsafe extern "C" fn resolve_symbol(
    mut name: *const libc::c_char,
    mut input_bfd: *mut bfd,
    mut flinfo: *mut elf_final_link_info,
    mut result: *mut bfd_vma,
    mut isymbuf: *mut Elf_Internal_Sym,
    mut locsymcount: size_t,
) -> bool {
    let mut sym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut global_entry: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
    let mut candidate: *const libc::c_char = 0 as *const libc::c_char;
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i: size_t = 0;
    symtab_hdr = &mut (*(*input_bfd).tdata.elf_obj_data).symtab_hdr;
    i = 0 as libc::c_int as size_t;
    while i < locsymcount {
        sym = isymbuf.offset(i as isize);
        if !((*sym).st_info as libc::c_uint >> 4 as libc::c_int
            != 0 as libc::c_int as libc::c_uint)
        {
            candidate = bfd_elf_string_from_elf_section(
                input_bfd,
                (*symtab_hdr).sh_link,
                (*sym).st_name as libc::c_uint,
            );
            if !candidate.is_null() && strcmp(candidate, name) == 0 as libc::c_int {
                let mut sec: *mut asection = *((*flinfo).sections).offset(i as isize);
                *result = _bfd_elf_rel_local_sym(
                    input_bfd,
                    sym,
                    &mut sec,
                    0 as libc::c_int as bfd_vma,
                );
                *result = (*result as libc::c_ulong)
                    .wrapping_add(
                        ((*sec).output_offset).wrapping_add((*(*sec).output_section).vma),
                    ) as bfd_vma as bfd_vma;
                return 1 as libc::c_int != 0;
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    global_entry = bfd_link_hash_lookup(
        (*(*flinfo).info).hash,
        name,
        0 as libc::c_int != 0,
        0 as libc::c_int != 0,
        1 as libc::c_int != 0,
    );
    if global_entry.is_null() {
        return 0 as libc::c_int != 0;
    }
    if (*global_entry).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
        || (*global_entry).type_0() as libc::c_int
            == bfd_link_hash_defweak as libc::c_int
    {
        *result = ((*global_entry).u.def.value)
            .wrapping_add((*(*(*global_entry).u.def.section).output_section).vma)
            .wrapping_add((*(*global_entry).u.def.section).output_offset);
        return 1 as libc::c_int != 0;
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn resolve_section(
    mut name: *const libc::c_char,
    mut sections: *mut asection,
    mut result: *mut bfd_vma,
    mut abfd: *mut bfd,
) -> bool {
    let mut curr: *mut asection = 0 as *mut asection;
    let mut len: libc::c_uint = 0;
    curr = sections;
    while !curr.is_null() {
        if strcmp((*curr).name, name) == 0 as libc::c_int {
            *result = (*curr).vma;
            return 1 as libc::c_int != 0;
        }
        curr = (*curr).next;
    }
    curr = sections;
    while !curr.is_null() {
        len = strlen((*curr).name) as libc::c_uint;
        if !(len as libc::c_ulong > strlen(name)) {
            if strncmp((*curr).name, name, len as libc::c_ulong) == 0 as libc::c_int {
                if startswith(
                    name.offset(len as isize),
                    b".end\0" as *const u8 as *const libc::c_char,
                ) {
                    *result = ((*curr).vma)
                        .wrapping_add(
                            ((*curr).size)
                                .wrapping_div(
                                    bfd_octets_per_byte(abfd, curr) as libc::c_ulong,
                                ),
                        );
                    return 1 as libc::c_int != 0;
                }
            }
        }
        curr = (*curr).next;
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn undefined_reference(
    mut reftype: *const libc::c_char,
    mut name: *const libc::c_char,
) {
    _bfd_error_handler(
        dcgettext(
            b"bfd\0" as *const u8 as *const libc::c_char,
            b"undefined %s reference in complex symbol: %s\0" as *const u8
                as *const libc::c_char,
            5 as libc::c_int,
        ),
        reftype,
        name,
    );
    bfd_set_error(bfd_error_bad_value);
}
unsafe extern "C" fn eval_symbol(
    mut result: *mut bfd_vma,
    mut symp: *mut *const libc::c_char,
    mut input_bfd: *mut bfd,
    mut flinfo: *mut elf_final_link_info,
    mut dot: bfd_vma,
    mut isymbuf: *mut Elf_Internal_Sym,
    mut locsymcount: size_t,
    mut signed_p: libc::c_int,
) -> bool {
    let mut len: size_t = 0;
    let mut symlen: size_t = 0;
    let mut a: bfd_vma = 0;
    let mut b: bfd_vma = 0;
    let mut symbuf: [libc::c_char; 4096] = [0; 4096];
    let mut sym: *const libc::c_char = *symp;
    let mut symend: *const libc::c_char = 0 as *const libc::c_char;
    let mut symbol_is_section: bool = 0 as libc::c_int != 0;
    len = strlen(sym);
    symend = sym.offset(len as isize);
    if len < 1 as libc::c_int as libc::c_ulong
        || len > ::core::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
    {
        bfd_set_error(bfd_error_invalid_operation);
        return 0 as libc::c_int != 0;
    }
    match *sym as libc::c_int {
        46 => {
            *result = dot;
            *symp = sym.offset(1 as libc::c_int as isize);
            return 1 as libc::c_int != 0;
        }
        35 => {
            sym = sym.offset(1);
            sym;
            *result = strtoul(sym, symp as *mut *mut libc::c_char, 16 as libc::c_int);
            return 1 as libc::c_int != 0;
        }
        83 => {
            symbol_is_section = 1 as libc::c_int != 0;
        }
        115 => {}
        _ => {
            if startswith(sym, b"0-\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b"0-\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (0 as libc::c_int as libc::c_long - a as bfd_signed_vma)
                        as bfd_vma;
                } else {
                    *result = (0 as libc::c_int as libc::c_ulong).wrapping_sub(a);
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"<<\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b"<<\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if b
                    >= (::core::mem::size_of::<bfd_vma>() as libc::c_ulong)
                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                {
                    *result = 0 as libc::c_int as bfd_vma;
                    return 1 as libc::c_int != 0;
                }
                signed_p = 0 as libc::c_int;
                if signed_p != 0 {
                    *result = ((a as bfd_signed_vma) << b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a << b;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b">>\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b">>\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if b
                    >= (::core::mem::size_of::<bfd_vma>() as libc::c_ulong)
                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                {
                    *result = (if signed_p != 0
                        && (a as bfd_signed_vma) < 0 as libc::c_int as libc::c_long
                    {
                        -(1 as libc::c_int)
                    } else {
                        0 as libc::c_int
                    }) as bfd_vma;
                    return 1 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma >> b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a >> b;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"==\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b"==\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma == b as bfd_signed_vma) as libc::c_int
                        as bfd_vma;
                } else {
                    *result = (a == b) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"!=\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b"!=\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma != b as bfd_signed_vma) as libc::c_int
                        as bfd_vma;
                } else {
                    *result = (a != b) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"<=\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b"<=\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma <= b as bfd_signed_vma) as libc::c_int
                        as bfd_vma;
                } else {
                    *result = (a <= b) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b">=\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b">=\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma >= b as bfd_signed_vma) as libc::c_int
                        as bfd_vma;
                } else {
                    *result = (a >= b) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"&&\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b"&&\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma != 0 && b as bfd_signed_vma != 0)
                        as libc::c_int as bfd_vma;
                } else {
                    *result = (a != 0 && b != 0) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"||\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(
                        strlen(b"||\0" as *const u8 as *const libc::c_char) as isize,
                    );
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma != 0 || b as bfd_signed_vma != 0)
                        as libc::c_int as bfd_vma;
                } else {
                    *result = (a != 0 || b != 0) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"~\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"~\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = !(a as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = !a;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"!\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"!\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma == 0) as libc::c_int as bfd_vma;
                } else {
                    *result = (a == 0) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"*\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"*\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma * b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a.wrapping_mul(b);
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"/\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"/\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if b == 0 as libc::c_int as libc::c_ulong {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"division by zero\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    bfd_set_error(bfd_error_bad_value);
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma / b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a.wrapping_div(b);
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"%\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"%\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if b == 0 as libc::c_int as libc::c_ulong {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"division by zero\0" as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                    );
                    bfd_set_error(bfd_error_bad_value);
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma % b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a.wrapping_rem(b);
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"^\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"^\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma ^ b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a ^ b;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"|\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"|\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma | b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a | b;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"&\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"&\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma & b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a & b;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"+\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"+\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma + b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a.wrapping_add(b);
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"-\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"-\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma - b as bfd_signed_vma) as bfd_vma;
                } else {
                    *result = a.wrapping_sub(b);
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b"<\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b"<\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = ((a as bfd_signed_vma) < b as bfd_signed_vma)
                        as libc::c_int as bfd_vma;
                } else {
                    *result = (a < b) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            if startswith(sym, b">\0" as *const u8 as *const libc::c_char) {
                sym = sym
                    .offset(strlen(b">\0" as *const u8 as *const libc::c_char) as isize);
                if *sym as libc::c_int == ':' as i32 {
                    sym = sym.offset(1);
                    sym;
                }
                *symp = sym;
                if !eval_symbol(
                    &mut a,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                *symp = (*symp).offset(1);
                let _ = *symp;
                if !eval_symbol(
                    &mut b,
                    symp,
                    input_bfd,
                    flinfo,
                    dot,
                    isymbuf,
                    locsymcount,
                    signed_p,
                ) {
                    return 0 as libc::c_int != 0;
                }
                if signed_p != 0 {
                    *result = (a as bfd_signed_vma > b as bfd_signed_vma) as libc::c_int
                        as bfd_vma;
                } else {
                    *result = (a > b) as libc::c_int as bfd_vma;
                }
                return 1 as libc::c_int != 0;
            }
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"unknown operator '%c' in complex symbol\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                *sym as libc::c_int,
            );
            bfd_set_error(bfd_error_invalid_operation);
            return 0 as libc::c_int != 0;
        }
    }
    sym = sym.offset(1);
    sym;
    symlen = strtol(sym, symp as *mut *mut libc::c_char, 10 as libc::c_int) as size_t;
    sym = (*symp).offset(1 as libc::c_int as isize);
    if symend < sym
        || symlen.wrapping_add(1 as libc::c_int as libc::c_ulong)
            > ::core::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
    {
        bfd_set_error(bfd_error_invalid_operation);
        return 0 as libc::c_int != 0;
    }
    memcpy(symbuf.as_mut_ptr() as *mut libc::c_void, sym as *const libc::c_void, symlen);
    symbuf[symlen as usize] = '\0' as i32 as libc::c_char;
    *symp = sym.offset(symlen as isize);
    if symbol_is_section {
        if !resolve_section(
            symbuf.as_mut_ptr(),
            (*(*flinfo).output_bfd).sections,
            result,
            input_bfd,
        )
            && !resolve_symbol(
                symbuf.as_mut_ptr(),
                input_bfd,
                flinfo,
                result,
                isymbuf,
                locsymcount,
            )
        {
            undefined_reference(
                b"section\0" as *const u8 as *const libc::c_char,
                symbuf.as_mut_ptr(),
            );
            return 0 as libc::c_int != 0;
        }
    } else if !resolve_symbol(
        symbuf.as_mut_ptr(),
        input_bfd,
        flinfo,
        result,
        isymbuf,
        locsymcount,
    )
        && !resolve_section(
            symbuf.as_mut_ptr(),
            (*(*flinfo).output_bfd).sections,
            result,
            input_bfd,
        )
    {
        undefined_reference(
            b"symbol\0" as *const u8 as *const libc::c_char,
            symbuf.as_mut_ptr(),
        );
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn put_value(
    mut size: bfd_vma,
    mut chunksz: libc::c_ulong,
    mut input_bfd: *mut bfd,
    mut x: bfd_vma,
    mut location: *mut bfd_byte,
) {
    location = location.offset(size.wrapping_sub(chunksz) as isize);
    while size != 0 {
        match chunksz {
            1 => {
                *(location
                    as *mut libc::c_uchar) = (x & 0xff as libc::c_int as libc::c_ulong)
                    as libc::c_uchar;
                x >>= 8 as libc::c_int;
            }
            2 => {
                (Some(
                    ((*(*input_bfd).xvec).bfd_putx16).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(x, location as *mut libc::c_void);
                x >>= 16 as libc::c_int;
            }
            4 => {
                (Some(
                    ((*(*input_bfd).xvec).bfd_putx32).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(x, location as *mut libc::c_void);
                x >>= 16 as libc::c_int;
                x >>= 16 as libc::c_int;
            }
            8 => {
                (Some(
                    ((*(*input_bfd).xvec).bfd_putx64).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(x, location as *mut libc::c_void);
                x >>= 32 as libc::c_int;
                x >>= 32 as libc::c_int;
            }
            _ => {
                _bfd_abort(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    8967 as libc::c_int,
                    (*::core::mem::transmute::<
                        &[u8; 67],
                        &[libc::c_char; 67],
                    >(
                        b"void put_value(bfd_vma, unsigned long, bfd *, bfd_vma, bfd_byte *)\0",
                    ))
                        .as_ptr(),
                );
            }
        }
        size = (size as libc::c_ulong).wrapping_sub(chunksz) as bfd_vma as bfd_vma;
        location = location.offset(-(chunksz as isize));
    }
}
unsafe extern "C" fn get_value(
    mut size: bfd_vma,
    mut chunksz: libc::c_ulong,
    mut input_bfd: *mut bfd,
    mut location: *mut bfd_byte,
) -> bfd_vma {
    let mut shift: libc::c_int = 0;
    let mut x: bfd_vma = 0 as libc::c_int as bfd_vma;
    if !(chunksz <= ::core::mem::size_of::<bfd_vma>() as libc::c_ulong && size >= chunksz
        && chunksz != 0 as libc::c_int as libc::c_ulong
        && size.wrapping_rem(chunksz) == 0 as libc::c_int as libc::c_ulong
        && !input_bfd.is_null() && !location.is_null())
    {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            8988 as libc::c_int,
        );
    }
    if chunksz == ::core::mem::size_of::<bfd_vma>() as libc::c_ulong {
        if !(size == chunksz) {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                8992 as libc::c_int,
            );
        }
        shift = 0 as libc::c_int;
    } else {
        shift = (8 as libc::c_int as libc::c_ulong).wrapping_mul(chunksz) as libc::c_int;
    }
    while size != 0 {
        match chunksz {
            1 => {
                x = x << shift
                    | *(location as *const libc::c_uchar) as bfd_vma
                        & 0xff as libc::c_int as libc::c_ulong;
            }
            2 => {
                x = x << shift
                    | (Some(
                        ((*(*input_bfd).xvec).bfd_getx16)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(location as *const libc::c_void);
            }
            4 => {
                x = x << shift
                    | (Some(
                        ((*(*input_bfd).xvec).bfd_getx32)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(location as *const libc::c_void);
            }
            8 => {
                x = x << shift
                    | (Some(
                        ((*(*input_bfd).xvec).bfd_getx64)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(location as *const libc::c_void);
            }
            _ => {
                _bfd_abort(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    9021 as libc::c_int,
                    (*::core::mem::transmute::<
                        &[u8; 61],
                        &[libc::c_char; 61],
                    >(b"bfd_vma get_value(bfd_vma, unsigned long, bfd *, bfd_byte *)\0"))
                        .as_ptr(),
                );
            }
        }
        size = (size as libc::c_ulong).wrapping_sub(chunksz) as bfd_vma as bfd_vma;
        location = location.offset(chunksz as isize);
    }
    return x;
}
unsafe extern "C" fn decode_complex_addend(
    mut start: *mut libc::c_ulong,
    mut oplen: *mut libc::c_ulong,
    mut len: *mut libc::c_ulong,
    mut wordsz: *mut libc::c_ulong,
    mut chunksz: *mut libc::c_ulong,
    mut lsb0_p: *mut libc::c_ulong,
    mut signed_p: *mut libc::c_ulong,
    mut trunc_p: *mut libc::c_ulong,
    mut encoded: libc::c_ulong,
) {
    *start = encoded & 0x3f as libc::c_int as libc::c_ulong;
    *len = encoded >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_ulong;
    *oplen = encoded >> 12 as libc::c_int & 0x3f as libc::c_int as libc::c_ulong;
    *wordsz = encoded >> 18 as libc::c_int & 0xf as libc::c_int as libc::c_ulong;
    *chunksz = encoded >> 22 as libc::c_int & 0xf as libc::c_int as libc::c_ulong;
    *lsb0_p = encoded >> 27 as libc::c_int & 1 as libc::c_int as libc::c_ulong;
    *signed_p = encoded >> 28 as libc::c_int & 1 as libc::c_int as libc::c_ulong;
    *trunc_p = encoded >> 29 as libc::c_int & 1 as libc::c_int as libc::c_ulong;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_perform_complex_relocation(
    mut input_bfd: *mut bfd,
    mut input_section: *mut asection,
    mut contents: *mut bfd_byte,
    mut rel: *mut Elf_Internal_Rela,
    mut relocation: bfd_vma,
) -> bfd_reloc_status_type {
    let mut shift: bfd_vma = 0;
    let mut x: bfd_vma = 0;
    let mut mask: bfd_vma = 0;
    let mut start: libc::c_ulong = 0;
    let mut oplen: libc::c_ulong = 0;
    let mut len: libc::c_ulong = 0;
    let mut wordsz: libc::c_ulong = 0;
    let mut chunksz: libc::c_ulong = 0;
    let mut lsb0_p: libc::c_ulong = 0;
    let mut signed_p: libc::c_ulong = 0;
    let mut trunc_p: libc::c_ulong = 0;
    let mut r: bfd_reloc_status_type = 0 as bfd_reloc_status_type;
    let mut octets: bfd_size_type = 0;
    decode_complex_addend(
        &mut start,
        &mut oplen,
        &mut len,
        &mut wordsz,
        &mut chunksz,
        &mut lsb0_p,
        &mut signed_p,
        &mut trunc_p,
        (*rel).r_addend,
    );
    mask = ((((1 as libc::c_long) << len.wrapping_sub(1 as libc::c_int as libc::c_ulong))
        - 1 as libc::c_int as libc::c_long) << 1 as libc::c_int
        | 1 as libc::c_int as libc::c_long) as bfd_vma;
    if lsb0_p != 0 {
        shift = start.wrapping_add(1 as libc::c_int as libc::c_ulong).wrapping_sub(len);
    } else {
        shift = (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(wordsz)
            .wrapping_sub(start.wrapping_add(len));
    }
    octets = ((*rel).r_offset)
        .wrapping_mul(bfd_octets_per_byte(input_bfd, input_section) as libc::c_ulong);
    x = get_value(wordsz, chunksz, input_bfd, contents.offset(octets as isize));
    r = bfd_reloc_ok;
    if trunc_p == 0 {
        r = bfd_check_overflow(
            (if signed_p != 0 {
                complain_overflow_signed as libc::c_int
            } else {
                complain_overflow_unsigned as libc::c_int
            }) as complain_overflow,
            len as libc::c_uint,
            0 as libc::c_int as libc::c_uint,
            (8 as libc::c_int as libc::c_ulong).wrapping_mul(wordsz) as libc::c_uint,
            relocation,
        );
    }
    x = x & !(mask << shift) | (relocation & mask) << shift;
    put_value(wordsz, chunksz, input_bfd, x, contents.offset(octets as isize));
    return r;
}
unsafe extern "C" fn ext32l_r_offset(mut p: *const libc::c_void) -> bfd_vma {
    let mut a: *const aligned32_0 = &(*(p as *const Elf32_External_Rel)).r_offset
        as *const [libc::c_uchar; 4] as *const aligned32_0;
    let mut aval: uint32_t = (*a).c[0 as libc::c_int as usize] as uint32_t
        | ((*a).c[1 as libc::c_int as usize] as uint32_t) << 8 as libc::c_int
        | ((*a).c[2 as libc::c_int as usize] as uint32_t) << 16 as libc::c_int
        | ((*a).c[3 as libc::c_int as usize] as uint32_t) << 24 as libc::c_int;
    return aval as bfd_vma;
}
unsafe extern "C" fn ext32b_r_offset(mut p: *const libc::c_void) -> bfd_vma {
    let mut a: *const aligned32 = &(*(p as *const Elf32_External_Rel)).r_offset
        as *const [libc::c_uchar; 4] as *const aligned32;
    let mut aval: uint32_t = ((*a).c[0 as libc::c_int as usize] as uint32_t)
        << 24 as libc::c_int
        | ((*a).c[1 as libc::c_int as usize] as uint32_t) << 16 as libc::c_int
        | ((*a).c[2 as libc::c_int as usize] as uint32_t) << 8 as libc::c_int
        | (*a).c[3 as libc::c_int as usize] as uint32_t;
    return aval as bfd_vma;
}
unsafe extern "C" fn ext64l_r_offset(mut p: *const libc::c_void) -> bfd_vma {
    let mut a: *const aligned64_0 = &(*(p as *const Elf64_External_Rel)).r_offset
        as *const [libc::c_uchar; 8] as *const aligned64_0;
    let mut aval: uint64_t = (*a).c[0 as libc::c_int as usize] as uint64_t
        | ((*a).c[1 as libc::c_int as usize] as uint64_t) << 8 as libc::c_int
        | ((*a).c[2 as libc::c_int as usize] as uint64_t) << 16 as libc::c_int
        | ((*a).c[3 as libc::c_int as usize] as uint64_t) << 24 as libc::c_int
        | ((*a).c[4 as libc::c_int as usize] as uint64_t) << 32 as libc::c_int
        | ((*a).c[5 as libc::c_int as usize] as uint64_t) << 40 as libc::c_int
        | ((*a).c[6 as libc::c_int as usize] as uint64_t) << 48 as libc::c_int
        | ((*a).c[7 as libc::c_int as usize] as uint64_t) << 56 as libc::c_int;
    return aval;
}
unsafe extern "C" fn ext64b_r_offset(mut p: *const libc::c_void) -> bfd_vma {
    let mut a: *const aligned64 = &(*(p as *const Elf64_External_Rel)).r_offset
        as *const [libc::c_uchar; 8] as *const aligned64;
    let mut aval: uint64_t = ((*a).c[0 as libc::c_int as usize] as uint64_t)
        << 56 as libc::c_int
        | ((*a).c[1 as libc::c_int as usize] as uint64_t) << 48 as libc::c_int
        | ((*a).c[2 as libc::c_int as usize] as uint64_t) << 40 as libc::c_int
        | ((*a).c[3 as libc::c_int as usize] as uint64_t) << 32 as libc::c_int
        | ((*a).c[4 as libc::c_int as usize] as uint64_t) << 24 as libc::c_int
        | ((*a).c[5 as libc::c_int as usize] as uint64_t) << 16 as libc::c_int
        | ((*a).c[6 as libc::c_int as usize] as uint64_t) << 8 as libc::c_int
        | (*a).c[7 as libc::c_int as usize] as uint64_t;
    return aval;
}
unsafe extern "C" fn elf_link_adjust_relocs(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut reldata: *mut bfd_elf_section_reloc_data,
    mut sort: bool,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut i: libc::c_uint = 0;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut erela: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut swap_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    > = None;
    let mut swap_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    > = None;
    let mut r_type_mask: bfd_vma = 0;
    let mut r_sym_shift: libc::c_int = 0;
    let mut count: libc::c_uint = (*reldata).count;
    let mut rel_hash: *mut *mut elf_link_hash_entry = (*reldata).hashes;
    if (*(*reldata).hdr).sh_entsize == (*(*bed).s).sizeof_rel as libc::c_ulong {
        swap_in = (*(*bed).s).swap_reloc_in;
        swap_out = (*(*bed).s).swap_reloc_out;
    } else if (*(*reldata).hdr).sh_entsize == (*(*bed).s).sizeof_rela as libc::c_ulong {
        swap_in = (*(*bed).s).swap_reloca_in;
        swap_out = (*(*bed).s).swap_reloca_out;
    } else {
        _bfd_abort(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            9233 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 116],
                &[libc::c_char; 116],
            >(
                b"_Bool elf_link_adjust_relocs(bfd *, asection *, struct bfd_elf_section_reloc_data *, _Bool, struct bfd_link_info *)\0",
            ))
                .as_ptr(),
        );
    }
    if (*(*bed).s).int_rels_per_ext_rel as libc::c_int > 3 as libc::c_int {
        _bfd_abort(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            9236 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 116],
                &[libc::c_char; 116],
            >(
                b"_Bool elf_link_adjust_relocs(bfd *, asection *, struct bfd_elf_section_reloc_data *, _Bool, struct bfd_link_info *)\0",
            ))
                .as_ptr(),
        );
    }
    if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int {
        r_type_mask = 0xff as libc::c_int as bfd_vma;
        r_sym_shift = 8 as libc::c_int;
    } else {
        r_type_mask = 0xffffffff as libc::c_uint as bfd_vma;
        r_sym_shift = 32 as libc::c_int;
    }
    erela = (*(*reldata).hdr).contents;
    i = 0 as libc::c_int as libc::c_uint;
    while i < count {
        let mut irela: [Elf_Internal_Rela; 3] = [Elf_Internal_Rela {
            r_offset: 0,
            r_info: 0,
            r_addend: 0,
        }; 3];
        let mut j: libc::c_uint = 0;
        if !(*rel_hash).is_null() {
            if (**rel_hash).indx == -(2 as libc::c_int) as libc::c_long
                && (*info).gc_sections() as libc::c_int != 0
                && (*info).gc_keep_exported() == 0
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB:%pA: error: relocation references symbol %s which was removed by garbage collection\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abfd,
                    sec,
                    (**rel_hash).root.root.string,
                );
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB:%pA: error: try relinking with --gc-keep-exported enabled\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abfd,
                    sec,
                );
                bfd_set_error(bfd_error_invalid_operation);
                return 0 as libc::c_int != 0;
            }
            if !((**rel_hash).indx >= 0 as libc::c_int as libc::c_long) {
                bfd_assert(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    9271 as libc::c_int,
                );
            }
            (Some(swap_in.expect("non-null function pointer")))
                .expect("non-null function pointer")(abfd, erela, irela.as_mut_ptr());
            j = 0 as libc::c_int as libc::c_uint;
            while j < (*(*bed).s).int_rels_per_ext_rel as libc::c_uint {
                irela[j as usize]
                    .r_info = ((**rel_hash).indx as bfd_vma) << r_sym_shift
                    | irela[j as usize].r_info & r_type_mask;
                j = j.wrapping_add(1);
                j;
            }
            (Some(swap_out.expect("non-null function pointer")))
                .expect("non-null function pointer")(abfd, irela.as_mut_ptr(), erela);
        }
        i = i.wrapping_add(1);
        i;
        rel_hash = rel_hash.offset(1);
        rel_hash;
        erela = erela.offset((*(*reldata).hdr).sh_entsize as isize);
    }
    if ((*bed).elf_backend_update_relocs).is_some() {
        (Some(((*bed).elf_backend_update_relocs).expect("non-null function pointer")))
            .expect("non-null function pointer")(sec, reldata);
    }
    if sort as libc::c_int != 0 && count != 0 as libc::c_int as libc::c_uint {
        let mut ext_r_off: Option::<
            unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
        > = None;
        let mut r_off: bfd_vma = 0;
        let mut elt_size: size_t = 0;
        let mut base: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut end: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut p: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut loc: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut buf: *mut bfd_byte = 0 as *mut bfd_byte;
        if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int {
            if (*(*abfd).xvec).header_byteorder as libc::c_uint
                == BFD_ENDIAN_LITTLE as libc::c_int as libc::c_uint
            {
                ext_r_off = Some(
                    ext32l_r_offset
                        as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
                );
            } else if (*(*abfd).xvec).header_byteorder as libc::c_uint
                == BFD_ENDIAN_BIG as libc::c_int as libc::c_uint
            {
                ext_r_off = Some(
                    ext32b_r_offset
                        as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
                );
            } else {
                _bfd_abort(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    9298 as libc::c_int,
                    (*::core::mem::transmute::<
                        &[u8; 116],
                        &[libc::c_char; 116],
                    >(
                        b"_Bool elf_link_adjust_relocs(bfd *, asection *, struct bfd_elf_section_reloc_data *, _Bool, struct bfd_link_info *)\0",
                    ))
                        .as_ptr(),
                );
            }
        } else if (*(*abfd).xvec).header_byteorder as libc::c_uint
            == BFD_ENDIAN_LITTLE as libc::c_int as libc::c_uint
        {
            ext_r_off = Some(
                ext64l_r_offset as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            );
        } else if (*(*abfd).xvec).header_byteorder as libc::c_uint
            == BFD_ENDIAN_BIG as libc::c_int as libc::c_uint
        {
            ext_r_off = Some(
                ext64b_r_offset as unsafe extern "C" fn(*const libc::c_void) -> bfd_vma,
            );
        } else {
            _bfd_abort(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                9309 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 116],
                    &[libc::c_char; 116],
                >(
                    b"_Bool elf_link_adjust_relocs(bfd *, asection *, struct bfd_elf_section_reloc_data *, _Bool, struct bfd_link_info *)\0",
                ))
                    .as_ptr(),
            );
        }
        elt_size = (*(*reldata).hdr).sh_entsize;
        base = (*(*reldata).hdr).contents;
        end = base.offset((count as libc::c_ulong).wrapping_mul(elt_size) as isize);
        if elt_size > ::core::mem::size_of::<Elf64_External_Rela>() as libc::c_ulong {
            _bfd_abort(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                9318 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 116],
                    &[libc::c_char; 116],
                >(
                    b"_Bool elf_link_adjust_relocs(bfd *, asection *, struct bfd_elf_section_reloc_data *, _Bool, struct bfd_link_info *)\0",
                ))
                    .as_ptr(),
            );
        }
        r_off = (Some(ext_r_off.expect("non-null function pointer")))
            .expect("non-null function pointer")(base as *const libc::c_void);
        loc = base;
        p = loc;
        loop {
            p = p.offset(elt_size as isize);
            if !(p < end) {
                break;
            }
            let mut r_off2: bfd_vma = (Some(
                ext_r_off.expect("non-null function pointer"),
            ))
                .expect("non-null function pointer")(p as *const libc::c_void);
            if r_off > r_off2 {
                r_off = r_off2;
                loc = p;
            }
        }
        if loc != base {
            let mut onebuf: [bfd_byte; 24] = [0; 24];
            memcpy(
                onebuf.as_mut_ptr() as *mut libc::c_void,
                loc as *const libc::c_void,
                elt_size,
            );
            memmove(
                base.offset(elt_size as isize) as *mut libc::c_void,
                base as *const libc::c_void,
                loc.offset_from(base) as libc::c_long as libc::c_ulong,
            );
            memcpy(
                base as *mut libc::c_void,
                onebuf.as_mut_ptr() as *const libc::c_void,
                elt_size,
            );
        }
        p = base.offset(elt_size as isize);
        loop {
            p = p.offset(elt_size as isize);
            if !(p < end) {
                break;
            }
            r_off = (Some(ext_r_off.expect("non-null function pointer")))
                .expect("non-null function pointer")(p as *const libc::c_void);
            loc = p.offset(-(elt_size as isize));
            while r_off
                < (Some(ext_r_off.expect("non-null function pointer")))
                    .expect("non-null function pointer")(loc as *const libc::c_void)
            {
                loc = loc.offset(-(elt_size as isize));
            }
            loc = loc.offset(elt_size as isize);
            if loc != p {
                let mut sortlen: size_t = p.offset_from(loc) as libc::c_long as size_t;
                let mut r_off2_0: bfd_vma = (Some(
                    ext_r_off.expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(loc as *const libc::c_void);
                let mut runlen: size_t = elt_size;
                let mut buf_size: size_t = (96 as libc::c_int * 1024 as libc::c_int)
                    as size_t;
                while p.offset(runlen as isize) < end
                    && (sortlen <= buf_size || runlen.wrapping_add(elt_size) <= buf_size)
                    && r_off2_0
                        > (Some(ext_r_off.expect("non-null function pointer")))
                            .expect(
                                "non-null function pointer",
                            )(p.offset(runlen as isize) as *const libc::c_void)
                {
                    runlen = (runlen as libc::c_ulong).wrapping_add(elt_size) as size_t
                        as size_t;
                }
                if buf.is_null() {
                    buf = bfd_malloc(buf_size) as *mut bfd_byte;
                    if buf.is_null() {
                        return 0 as libc::c_int != 0;
                    }
                }
                if runlen < sortlen {
                    memcpy(buf as *mut libc::c_void, p as *const libc::c_void, runlen);
                    memmove(
                        loc.offset(runlen as isize) as *mut libc::c_void,
                        loc as *const libc::c_void,
                        sortlen,
                    );
                    memcpy(loc as *mut libc::c_void, buf as *const libc::c_void, runlen);
                } else {
                    memcpy(
                        buf as *mut libc::c_void,
                        loc as *const libc::c_void,
                        sortlen,
                    );
                    memmove(loc as *mut libc::c_void, p as *const libc::c_void, runlen);
                    memcpy(
                        loc.offset(runlen as isize) as *mut libc::c_void,
                        buf as *const libc::c_void,
                        sortlen,
                    );
                }
                p = p.offset(runlen.wrapping_sub(elt_size) as isize);
            }
        }
        free((*reldata).hashes as *mut libc::c_void);
        (*reldata).hashes = 0 as *mut *mut elf_link_hash_entry;
        free(buf as *mut libc::c_void);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_link_sort_cmp1(
    mut A: *const libc::c_void,
    mut B: *const libc::c_void,
) -> libc::c_int {
    let mut a: *const elf_link_sort_rela = A as *const elf_link_sort_rela;
    let mut b: *const elf_link_sort_rela = B as *const elf_link_sort_rela;
    let mut relativea: libc::c_int = 0;
    let mut relativeb: libc::c_int = 0;
    relativea = ((*a).type_0 as libc::c_uint
        == reloc_class_relative as libc::c_int as libc::c_uint) as libc::c_int;
    relativeb = ((*b).type_0 as libc::c_uint
        == reloc_class_relative as libc::c_int as libc::c_uint) as libc::c_int;
    if relativea < relativeb {
        return 1 as libc::c_int;
    }
    if relativea > relativeb {
        return -(1 as libc::c_int);
    }
    if (*((*a).rela).as_ptr()).r_info & (*a).u.sym_mask
        < (*((*b).rela).as_ptr()).r_info & (*b).u.sym_mask
    {
        return -(1 as libc::c_int);
    }
    if (*((*a).rela).as_ptr()).r_info & (*a).u.sym_mask
        > (*((*b).rela).as_ptr()).r_info & (*b).u.sym_mask
    {
        return 1 as libc::c_int;
    }
    if (*((*a).rela).as_ptr()).r_offset < (*((*b).rela).as_ptr()).r_offset {
        return -(1 as libc::c_int);
    }
    if (*((*a).rela).as_ptr()).r_offset > (*((*b).rela).as_ptr()).r_offset {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn elf_link_sort_cmp2(
    mut A: *const libc::c_void,
    mut B: *const libc::c_void,
) -> libc::c_int {
    let mut a: *const elf_link_sort_rela = A as *const elf_link_sort_rela;
    let mut b: *const elf_link_sort_rela = B as *const elf_link_sort_rela;
    if ((*a).type_0 as libc::c_uint) < (*b).type_0 as libc::c_uint {
        return -(1 as libc::c_int);
    }
    if (*a).type_0 as libc::c_uint > (*b).type_0 as libc::c_uint {
        return 1 as libc::c_int;
    }
    if (*a).u.offset < (*b).u.offset {
        return -(1 as libc::c_int);
    }
    if (*a).u.offset > (*b).u.offset {
        return 1 as libc::c_int;
    }
    if (*((*a).rela).as_ptr()).r_offset < (*((*b).rela).as_ptr()).r_offset {
        return -(1 as libc::c_int);
    }
    if (*((*a).rela).as_ptr()).r_offset > (*((*b).rela).as_ptr()).r_offset {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn elf_link_sort_relocs(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut psec: *mut *mut asection,
) -> size_t {
    let mut dynamic_relocs: *mut asection = 0 as *mut asection;
    let mut rela_dyn: *mut asection = 0 as *mut asection;
    let mut rel_dyn: *mut asection = 0 as *mut asection;
    let mut count: bfd_size_type = 0;
    let mut size: bfd_size_type = 0;
    let mut i: size_t = 0;
    let mut ret: size_t = 0;
    let mut sort_elt: size_t = 0;
    let mut ext_size: size_t = 0;
    let mut sort: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut s_non_relative: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut p: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut sq: *mut elf_link_sort_rela = 0 as *mut elf_link_sort_rela;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut i2e: libc::c_int = (*(*bed).s).int_rels_per_ext_rel as libc::c_int;
    let mut opb: libc::c_uint = bfd_octets_per_byte(abfd, 0 as *const asection);
    let mut swap_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    > = None;
    let mut swap_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    > = None;
    let mut lo: *mut bfd_link_order = 0 as *mut bfd_link_order;
    let mut r_sym_mask: bfd_vma = 0;
    let mut use_rela: bool = false;
    rela_dyn = bfd_get_section_by_name(
        abfd,
        b".rela.dyn\0" as *const u8 as *const libc::c_char,
    );
    rel_dyn = bfd_get_section_by_name(
        abfd,
        b".rel.dyn\0" as *const u8 as *const libc::c_char,
    );
    if !rela_dyn.is_null() && (*rela_dyn).size > 0 as libc::c_int as libc::c_ulong
        && !rel_dyn.is_null() && (*rel_dyn).size > 0 as libc::c_int as libc::c_ulong
    {
        let mut use_rela_initialised: bool = 0 as libc::c_int != 0;
        use_rela = 1 as libc::c_int != 0;
        lo = (*rela_dyn).map_head.link_order;
        while !lo.is_null() {
            if (*lo).type_0 as libc::c_uint
                == bfd_indirect_link_order as libc::c_int as libc::c_uint
            {
                let mut o: *mut asection = (*lo).u.indirect.section;
                if ((*o).size).wrapping_rem((*(*bed).s).sizeof_rela as libc::c_ulong)
                    == 0 as libc::c_int as libc::c_ulong
                {
                    if !(((*o).size)
                        .wrapping_rem((*(*bed).s).sizeof_rel as libc::c_ulong)
                        == 0 as libc::c_int as libc::c_ulong)
                    {
                        if use_rela_initialised as libc::c_int != 0 && !use_rela {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unable to sort relocs - they are in more than one size\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                            );
                            bfd_set_error(bfd_error_invalid_operation);
                            return 0 as libc::c_int as size_t;
                        } else {
                            use_rela = 1 as libc::c_int != 0;
                            use_rela_initialised = 1 as libc::c_int != 0;
                        }
                    }
                } else if ((*o).size)
                    .wrapping_rem((*(*bed).s).sizeof_rel as libc::c_ulong)
                    == 0 as libc::c_int as libc::c_ulong
                {
                    if use_rela_initialised as libc::c_int != 0
                        && use_rela as libc::c_int != 0
                    {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%pB: unable to sort relocs - they are in more than one size\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            abfd,
                        );
                        bfd_set_error(bfd_error_invalid_operation);
                        return 0 as libc::c_int as size_t;
                    } else {
                        use_rela = 0 as libc::c_int != 0;
                        use_rela_initialised = 1 as libc::c_int != 0;
                    }
                } else {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: unable to sort relocs - they are of an unknown size\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                    );
                    bfd_set_error(bfd_error_invalid_operation);
                    return 0 as libc::c_int as size_t;
                }
            }
            lo = (*lo).next;
        }
        lo = (*rel_dyn).map_head.link_order;
        while !lo.is_null() {
            if (*lo).type_0 as libc::c_uint
                == bfd_indirect_link_order as libc::c_int as libc::c_uint
            {
                let mut o_0: *mut asection = (*lo).u.indirect.section;
                if ((*o_0).size).wrapping_rem((*(*bed).s).sizeof_rela as libc::c_ulong)
                    == 0 as libc::c_int as libc::c_ulong
                {
                    if !(((*o_0).size)
                        .wrapping_rem((*(*bed).s).sizeof_rel as libc::c_ulong)
                        == 0 as libc::c_int as libc::c_ulong)
                    {
                        if use_rela_initialised as libc::c_int != 0 && !use_rela {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unable to sort relocs - they are in more than one size\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                            );
                            bfd_set_error(bfd_error_invalid_operation);
                            return 0 as libc::c_int as size_t;
                        } else {
                            use_rela = 1 as libc::c_int != 0;
                            use_rela_initialised = 1 as libc::c_int != 0;
                        }
                    }
                } else if ((*o_0).size)
                    .wrapping_rem((*(*bed).s).sizeof_rel as libc::c_ulong)
                    == 0 as libc::c_int as libc::c_ulong
                {
                    if use_rela_initialised as libc::c_int != 0
                        && use_rela as libc::c_int != 0
                    {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%pB: unable to sort relocs - they are in more than one size\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            abfd,
                        );
                        bfd_set_error(bfd_error_invalid_operation);
                        return 0 as libc::c_int as size_t;
                    } else {
                        use_rela = 0 as libc::c_int != 0;
                        use_rela_initialised = 1 as libc::c_int != 0;
                    }
                } else {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: unable to sort relocs - they are of an unknown size\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                    );
                    bfd_set_error(bfd_error_invalid_operation);
                    return 0 as libc::c_int as size_t;
                }
            }
            lo = (*lo).next;
        }
        if !use_rela_initialised {
            use_rela = 1 as libc::c_int != 0;
        }
    } else if !rela_dyn.is_null() && (*rela_dyn).size > 0 as libc::c_int as libc::c_ulong
    {
        use_rela = 1 as libc::c_int != 0;
    } else if !rel_dyn.is_null() && (*rel_dyn).size > 0 as libc::c_int as libc::c_ulong {
        use_rela = 0 as libc::c_int != 0;
    } else {
        return 0 as libc::c_int as size_t
    }
    if use_rela {
        dynamic_relocs = rela_dyn;
        ext_size = (*(*bed).s).sizeof_rela as size_t;
        swap_in = (*(*bed).s).swap_reloca_in;
        swap_out = (*(*bed).s).swap_reloca_out;
    } else {
        dynamic_relocs = rel_dyn;
        ext_size = (*(*bed).s).sizeof_rel as size_t;
        swap_in = (*(*bed).s).swap_reloc_in;
        swap_out = (*(*bed).s).swap_reloc_out;
    }
    size = 0 as libc::c_int as bfd_size_type;
    lo = (*dynamic_relocs).map_head.link_order;
    while !lo.is_null() {
        if (*lo).type_0 as libc::c_uint
            == bfd_indirect_link_order as libc::c_int as libc::c_uint
        {
            size = (size as libc::c_ulong).wrapping_add((*(*lo).u.indirect.section).size)
                as bfd_size_type as bfd_size_type;
        }
        lo = (*lo).next;
    }
    if size != (*dynamic_relocs).size {
        return 0 as libc::c_int as size_t;
    }
    sort_elt = (::core::mem::size_of::<elf_link_sort_rela>() as libc::c_ulong)
        .wrapping_add(
            ((i2e - 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<Elf_Internal_Rela>() as libc::c_ulong,
                ),
        );
    count = ((*dynamic_relocs).size).wrapping_div(ext_size);
    if count == 0 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int as size_t;
    }
    sort = bfd_zmalloc(sort_elt.wrapping_mul(count)) as *mut bfd_byte;
    if sort.is_null() {
        (Some(((*(*info).callbacks).warning).expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(
            info,
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"not enough memory to sort relocations\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            0 as *const libc::c_char,
            abfd,
            0 as *mut asection,
            0 as libc::c_int as bfd_vma,
        );
        return 0 as libc::c_int as size_t;
    }
    if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int {
        r_sym_mask = !(0xff as libc::c_int as bfd_vma);
    } else {
        r_sym_mask = !(0xffffffff as libc::c_uint as bfd_vma);
    }
    lo = (*dynamic_relocs).map_head.link_order;
    while !lo.is_null() {
        if (*lo).type_0 as libc::c_uint
            == bfd_indirect_link_order as libc::c_int as libc::c_uint
        {
            let mut erel: *mut bfd_byte = 0 as *mut bfd_byte;
            let mut erelend: *mut bfd_byte = 0 as *mut bfd_byte;
            let mut o_1: *mut asection = (*lo).u.indirect.section;
            if ((*o_1).contents).is_null()
                && (*o_1).size != 0 as libc::c_int as libc::c_ulong
            {
                free(sort as *mut libc::c_void);
                return 0 as libc::c_int as size_t;
            }
            erel = (*o_1).contents;
            erelend = ((*o_1).contents).offset((*o_1).size as isize);
            p = sort
                .offset(
                    ((*o_1).output_offset)
                        .wrapping_mul(opb as libc::c_ulong)
                        .wrapping_div(ext_size)
                        .wrapping_mul(sort_elt) as isize,
                );
            while erel < erelend {
                let mut s: *mut elf_link_sort_rela = p as *mut elf_link_sort_rela;
                (Some(swap_in.expect("non-null function pointer")))
                    .expect(
                        "non-null function pointer",
                    )(abfd, erel, ((*s).rela).as_mut_ptr());
                (*s)
                    .type_0 = (Some(
                    ((*bed).elf_backend_reloc_type_class)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(info, o_1, ((*s).rela).as_mut_ptr());
                (*s).u.sym_mask = r_sym_mask;
                p = p.offset(sort_elt as isize);
                erel = erel.offset(ext_size as isize);
            }
        }
        lo = (*lo).next;
    }
    qsort(
        sort as *mut libc::c_void,
        count,
        sort_elt,
        Some(
            elf_link_sort_cmp1
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    i = 0 as libc::c_int as size_t;
    p = sort;
    while i < count {
        let mut s_0: *mut elf_link_sort_rela = p as *mut elf_link_sort_rela;
        if (*s_0).type_0 as libc::c_uint
            != reloc_class_relative as libc::c_int as libc::c_uint
        {
            break;
        }
        i = i.wrapping_add(1);
        i;
        p = p.offset(sort_elt as isize);
    }
    ret = i;
    s_non_relative = p;
    sq = s_non_relative as *mut elf_link_sort_rela;
    while i < count {
        let mut sp: *mut elf_link_sort_rela = p as *mut elf_link_sort_rela;
        if ((*((*sp).rela).as_mut_ptr()).r_info ^ (*((*sq).rela).as_mut_ptr()).r_info)
            & r_sym_mask != 0 as libc::c_int as libc::c_ulong
        {
            sq = sp;
        }
        (*sp).u.offset = (*((*sq).rela).as_mut_ptr()).r_offset;
        i = i.wrapping_add(1);
        i;
        p = p.offset(sort_elt as isize);
    }
    qsort(
        s_non_relative as *mut libc::c_void,
        count.wrapping_sub(ret),
        sort_elt,
        Some(
            elf_link_sort_cmp2
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    let mut htab: *mut elf_link_hash_table = elf_hash_table(info);
    if !((*htab).srelplt).is_null()
        && (*(*htab).srelplt).output_section == dynamic_relocs
    {
        sq = sort as *mut elf_link_sort_rela;
        i = 0 as libc::c_int as size_t;
        while i < count {
            if (*sq
                .offset(
                    count.wrapping_sub(i).wrapping_sub(1 as libc::c_int as libc::c_ulong)
                        as isize,
                ))
                .type_0 as libc::c_uint != reloc_class_plt as libc::c_int as libc::c_uint
            {
                break;
            }
            i = i.wrapping_add(1);
            i;
        }
        if i != 0 as libc::c_int as libc::c_ulong
            && (*(*htab).srelplt).size == i.wrapping_mul(ext_size)
        {
            let mut plo: *mut *mut bfd_link_order = 0 as *mut *mut bfd_link_order;
            plo = &mut (*dynamic_relocs).map_head.link_order;
            while !(*plo).is_null() {
                if (**plo).type_0 as libc::c_uint
                    == bfd_indirect_link_order as libc::c_int as libc::c_uint
                    && (**plo).u.indirect.section == (*htab).srelplt
                {
                    lo = *plo;
                    *plo = (*lo).next;
                } else {
                    plo = &mut (**plo).next;
                }
            }
            *plo = lo;
            (*lo).next = 0 as *mut bfd_link_order;
            (*dynamic_relocs).map_tail.link_order = lo;
        }
    }
    p = sort;
    lo = (*dynamic_relocs).map_head.link_order;
    while !lo.is_null() {
        if (*lo).type_0 as libc::c_uint
            == bfd_indirect_link_order as libc::c_int as libc::c_uint
        {
            let mut erel_0: *mut bfd_byte = 0 as *mut bfd_byte;
            let mut erelend_0: *mut bfd_byte = 0 as *mut bfd_byte;
            let mut o_2: *mut asection = (*lo).u.indirect.section;
            erel_0 = (*o_2).contents;
            erelend_0 = ((*o_2).contents).offset((*o_2).size as isize);
            (*o_2)
                .output_offset = (p.offset_from(sort) as libc::c_long as libc::c_ulong)
                .wrapping_div(sort_elt)
                .wrapping_mul(ext_size)
                .wrapping_div(opb as libc::c_ulong);
            while erel_0 < erelend_0 {
                let mut s_1: *mut elf_link_sort_rela = p as *mut elf_link_sort_rela;
                (Some(swap_out.expect("non-null function pointer")))
                    .expect(
                        "non-null function pointer",
                    )(abfd, ((*s_1).rela).as_mut_ptr(), erel_0);
                p = p.offset(sort_elt as isize);
                erel_0 = erel_0.offset(ext_size as isize);
            }
        }
        lo = (*lo).next;
    }
    free(sort as *mut libc::c_void);
    *psec = dynamic_relocs;
    return ret;
}
unsafe extern "C" fn elf_link_output_symstrtab(
    mut finf: *mut libc::c_void,
    mut name: *const libc::c_char,
    mut elfsym: *mut Elf_Internal_Sym,
    mut input_sec: *mut asection,
    mut h: *mut elf_link_hash_entry,
) -> libc::c_int {
    let mut flinfo: *mut elf_final_link_info = finf as *mut elf_final_link_info;
    let mut output_symbol_hook: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut Elf_Internal_Sym,
            *mut asection,
            *mut elf_link_hash_entry,
        ) -> libc::c_int,
    > = None;
    let mut hash_table: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut strtabsize: bfd_size_type = 0;
    if (*(*(*flinfo).output_bfd).tdata.elf_obj_data).symtab_section == 0 {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            9784 as libc::c_int,
        );
    }
    bed = (*(*(*flinfo).output_bfd).xvec).backend_data as *const elf_backend_data;
    output_symbol_hook = (*bed).elf_backend_link_output_symbol_hook;
    if output_symbol_hook.is_some() {
        let mut ret: libc::c_int = (Some(
            output_symbol_hook.expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )((*flinfo).info, name, elfsym, input_sec, h);
        if ret != 1 as libc::c_int {
            return ret;
        }
    }
    if (*elfsym).st_info as libc::c_int & 0xf as libc::c_int == 10 as libc::c_int {
        (*(*(*flinfo).output_bfd).tdata.elf_obj_data)
            .set_has_gnu_osabi(
                (*(*(*flinfo).output_bfd).tdata.elf_obj_data).has_gnu_osabi()
                    | elf_gnu_osabi_ifunc as libc::c_int as elf_gnu_osabi,
            );
    }
    if (*elfsym).st_info as libc::c_uint >> 4 as libc::c_int
        == 10 as libc::c_int as libc::c_uint
    {
        (*(*(*flinfo).output_bfd).tdata.elf_obj_data)
            .set_has_gnu_osabi(
                (*(*(*flinfo).output_bfd).tdata.elf_obj_data).has_gnu_osabi()
                    | elf_gnu_osabi_unique as libc::c_int as elf_gnu_osabi,
            );
    }
    if name.is_null() || *name as libc::c_int == '\0' as i32
        || (*input_sec).flags & 0x8000 as libc::c_int as libc::c_uint != 0
    {
        (*elfsym).st_name = -(1 as libc::c_int) as libc::c_ulong;
    } else {
        let mut versioned_name: *mut libc::c_char = name as *mut libc::c_char;
        if !h.is_null() {
            if (*h).versioned() as libc::c_int == versioned as libc::c_int
                && (*h).def_dynamic() as libc::c_int != 0
            {
                let mut version: *mut libc::c_char = strrchr(name, '@' as i32);
                let mut base_end: *mut libc::c_char = strchr(name, '@' as i32);
                if version != base_end {
                    let mut base_len: size_t = 0;
                    let mut len: size_t = strlen(name);
                    versioned_name = bfd_alloc((*flinfo).output_bfd, len)
                        as *mut libc::c_char;
                    if versioned_name.is_null() {
                        return 0 as libc::c_int;
                    }
                    base_len = base_end.offset_from(name) as libc::c_long as size_t;
                    memcpy(
                        versioned_name as *mut libc::c_void,
                        name as *const libc::c_void,
                        base_len,
                    );
                    memcpy(
                        versioned_name.offset(base_len as isize) as *mut libc::c_void,
                        version as *const libc::c_void,
                        len.wrapping_sub(base_len),
                    );
                }
            }
        } else if (*(*flinfo).info).unique_symbol() as libc::c_int != 0
            && (*elfsym).st_info as libc::c_uint >> 4 as libc::c_int
                == 0 as libc::c_int as libc::c_uint
        {
            let mut lh: *mut local_hash_entry = 0 as *mut local_hash_entry;
            let mut count_len: size_t = 0;
            let mut base_len_0: size_t = 0;
            let mut buf: [libc::c_char; 30] = [0; 30];
            match (*elfsym).st_info as libc::c_int & 0xf as libc::c_int {
                4 | 3 => {}
                _ => {
                    lh = bfd_hash_lookup(
                        &mut (*flinfo).local_hash_table,
                        name,
                        1 as libc::c_int != 0,
                        0 as libc::c_int != 0,
                    ) as *mut local_hash_entry;
                    if lh.is_null() {
                        return 0 as libc::c_int;
                    }
                    sprintf(
                        buf.as_mut_ptr(),
                        b"%lx\0" as *const u8 as *const libc::c_char,
                        (*lh).count,
                    );
                    base_len_0 = (*lh).size;
                    if base_len_0 == 0 {
                        base_len_0 = strlen(name);
                        (*lh).size = base_len_0;
                    }
                    count_len = strlen(buf.as_mut_ptr());
                    versioned_name = bfd_alloc(
                        (*flinfo).output_bfd,
                        base_len_0
                            .wrapping_add(count_len)
                            .wrapping_add(2 as libc::c_int as libc::c_ulong),
                    ) as *mut libc::c_char;
                    if versioned_name.is_null() {
                        return 0 as libc::c_int;
                    }
                    memcpy(
                        versioned_name as *mut libc::c_void,
                        name as *const libc::c_void,
                        base_len_0,
                    );
                    *versioned_name
                        .offset(base_len_0 as isize) = '.' as i32 as libc::c_char;
                    memcpy(
                        versioned_name
                            .offset(base_len_0 as isize)
                            .offset(1 as libc::c_int as isize) as *mut libc::c_void,
                        buf.as_mut_ptr() as *const libc::c_void,
                        count_len.wrapping_add(1 as libc::c_int as libc::c_ulong),
                    );
                    (*lh).count += 1;
                    (*lh).count;
                }
            }
        }
        (*elfsym)
            .st_name = _bfd_elf_strtab_add(
            (*flinfo).symstrtab,
            versioned_name,
            0 as libc::c_int != 0,
        );
        if (*elfsym).st_name == -(1 as libc::c_int) as libc::c_ulong {
            return 0 as libc::c_int;
        }
    }
    hash_table = elf_hash_table((*flinfo).info);
    strtabsize = (*hash_table).strtabsize;
    if strtabsize <= (*hash_table).strtabcount {
        strtabsize = (strtabsize as libc::c_ulong).wrapping_add(strtabsize)
            as bfd_size_type as bfd_size_type;
        (*hash_table).strtabsize = strtabsize;
        strtabsize = (strtabsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<elf_sym_strtab>() as libc::c_ulong)
            as bfd_size_type as bfd_size_type;
        (*hash_table)
            .strtab = bfd_realloc((*hash_table).strtab as *mut libc::c_void, strtabsize)
            as *mut elf_sym_strtab;
        if ((*hash_table).strtab).is_null() {
            return 0 as libc::c_int;
        }
    }
    (*((*hash_table).strtab).offset((*hash_table).strtabcount as isize)).sym = *elfsym;
    (*((*hash_table).strtab).offset((*hash_table).strtabcount as isize))
        .dest_index = (*hash_table).strtabcount;
    (*((*hash_table).strtab).offset((*hash_table).strtabcount as isize))
        .destshndx_index = (if !((*flinfo).symshndxbuf).is_null() {
        bfd_get_symcount((*flinfo).output_bfd)
    } else {
        0 as libc::c_int as libc::c_uint
    }) as libc::c_ulong;
    (*(*flinfo).output_bfd)
        .symcount = ((*(*flinfo).output_bfd).symcount)
        .wrapping_add(1 as libc::c_int as libc::c_uint);
    (*hash_table)
        .strtabcount = ((*hash_table).strtabcount as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong) as bfd_size_type
        as bfd_size_type;
    return 1 as libc::c_int;
}
unsafe extern "C" fn elf_link_swap_symbols_out(
    mut flinfo: *mut elf_final_link_info,
) -> bool {
    let mut hash_table: *mut elf_link_hash_table = elf_hash_table((*flinfo).info);
    let mut amt: size_t = 0;
    let mut i: size_t = 0;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut symbuf: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut pos: file_ptr = 0;
    let mut ret: bool = false;
    if (*hash_table).strtabcount == 0 {
        return 1 as libc::c_int != 0;
    }
    if (*(*(*flinfo).output_bfd).tdata.elf_obj_data).symtab_section == 0 {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            9920 as libc::c_int,
        );
    }
    bed = (*(*(*flinfo).output_bfd).xvec).backend_data as *const elf_backend_data;
    amt = ((*(*bed).s).sizeof_sym as libc::c_ulong)
        .wrapping_mul((*hash_table).strtabcount);
    symbuf = bfd_malloc(amt) as *mut bfd_byte;
    if symbuf.is_null() {
        return 0 as libc::c_int != 0;
    }
    if !((*flinfo).symshndxbuf).is_null() {
        amt = ::core::mem::size_of::<Elf_External_Sym_Shndx>() as libc::c_ulong;
        amt = (amt as libc::c_ulong)
            .wrapping_mul(bfd_get_symcount((*flinfo).output_bfd) as libc::c_ulong)
            as size_t as size_t;
        (*flinfo).symshndxbuf = bfd_zmalloc(amt) as *mut Elf_External_Sym_Shndx;
        if ((*flinfo).symshndxbuf).is_null() {
            free(symbuf as *mut libc::c_void);
            return 0 as libc::c_int != 0;
        }
    }
    i = 0 as libc::c_int as size_t;
    while i < (*hash_table).strtabcount {
        let mut elfsym: *mut elf_sym_strtab = &mut *((*hash_table).strtab)
            .offset(i as isize) as *mut elf_sym_strtab;
        if (*elfsym).sym.st_name == -(1 as libc::c_int) as libc::c_ulong {
            (*elfsym).sym.st_name = 0 as libc::c_int as libc::c_ulong;
        } else {
            (*elfsym)
                .sym
                .st_name = _bfd_elf_strtab_offset(
                (*flinfo).symstrtab,
                (*elfsym).sym.st_name,
            );
        }
        if ((*(*(*flinfo).info).callbacks).ctf_new_symbol).is_some() {
            ((*(*(*flinfo).info).callbacks).ctf_new_symbol)
                .expect(
                    "non-null function pointer",
                )((*elfsym).dest_index as libc::c_int, &mut (*elfsym).sym);
        }
        ((*(*bed).s).swap_symbol_out)
            .expect(
                "non-null function pointer",
            )(
            (*flinfo).output_bfd,
            &mut (*elfsym).sym,
            symbuf
                .offset(
                    ((*elfsym).dest_index)
                        .wrapping_mul((*(*bed).s).sizeof_sym as libc::c_ulong) as isize,
                ) as *mut libc::c_void,
            ((*flinfo).symshndxbuf).offset((*elfsym).destshndx_index as isize)
                as *mut libc::c_void,
        );
        i = i.wrapping_add(1);
        i;
    }
    hdr = &mut (*(*(*flinfo).output_bfd).tdata.elf_obj_data).symtab_hdr;
    pos = ((*hdr).sh_offset as libc::c_ulong).wrapping_add((*hdr).sh_size) as file_ptr;
    amt = ((*hash_table).strtabcount)
        .wrapping_mul((*(*bed).s).sizeof_sym as libc::c_ulong);
    if bfd_seek((*flinfo).output_bfd, pos, 0 as libc::c_int) == 0 as libc::c_int
        && bfd_bwrite(symbuf as *const libc::c_void, amt, (*flinfo).output_bfd) == amt
    {
        (*hdr)
            .sh_size = ((*hdr).sh_size as libc::c_ulong).wrapping_add(amt)
            as bfd_size_type as bfd_size_type;
        ret = 1 as libc::c_int != 0;
    } else {
        ret = 0 as libc::c_int != 0;
    }
    free(symbuf as *mut libc::c_void);
    free((*hash_table).strtab as *mut libc::c_void);
    (*hash_table).strtab = 0 as *mut elf_sym_strtab;
    return ret;
}
unsafe extern "C" fn check_dynsym(
    mut abfd: *mut bfd,
    mut sym: *mut Elf_Internal_Sym,
) -> bool {
    if (*sym).st_shndx
        >= (0x100 as libc::c_uint).wrapping_neg() & 0xffff as libc::c_int as libc::c_uint
        && (*sym).st_shndx < (0x100 as libc::c_uint).wrapping_neg()
    {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: too many sections: %d (>= %d)\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            bfd_count_sections(abfd),
            (0x100 as libc::c_uint).wrapping_neg()
                & 0xffff as libc::c_int as libc::c_uint,
        );
        bfd_set_error(bfd_error_nonrepresentable_section);
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_link_check_versioned_symbol(
    mut info: *mut bfd_link_info,
    mut bed: *const elf_backend_data,
    mut h: *mut elf_link_hash_entry,
) -> bool {
    let mut abfd: *mut bfd = 0 as *mut bfd;
    let mut loaded: *mut elf_link_loaded_list = 0 as *mut elf_link_loaded_list;
    if !is_elf_hash_table((*info).hash) {
        return 0 as libc::c_int != 0;
    }
    while ((*h).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int {
        h = (*h).root.u.i.link as *mut elf_link_hash_entry;
    }
    match ((*h).root).type_0() as libc::c_int {
        1 | 2 => {
            abfd = (*h).root.u.undef.abfd;
            if abfd.is_null()
                || (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                || (*(*abfd).tdata.elf_obj_data).dyn_lib_class() as libc::c_int
                    & DYN_DT_NEEDED as libc::c_int == 0 as libc::c_int
            {
                return 0 as libc::c_int != 0;
            }
        }
        3 | 4 => {
            abfd = (*(*h).root.u.def.section).owner;
        }
        5 => {
            abfd = (*(*(*h).root.u.c.p).section).owner;
        }
        _ => {
            abfd = 0 as *mut bfd;
        }
    }
    if abfd.is_null() {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            10051 as libc::c_int,
        );
    }
    loaded = (*elf_hash_table(info)).dyn_loaded;
    while !loaded.is_null() {
        let mut input: *mut bfd = 0 as *mut bfd;
        let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut symcount: size_t = 0;
        let mut extsymcount: size_t = 0;
        let mut extsymoff: size_t = 0;
        let mut versymhdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        let mut isymend: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        let mut isymbuf: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
        let mut ever: *mut Elf_External_Versym = 0 as *mut Elf_External_Versym;
        let mut extversym: *mut Elf_External_Versym = 0 as *mut Elf_External_Versym;
        input = (*loaded).abfd;
        if !(input == abfd
            || (*(*input).tdata.elf_obj_data).dynversym_section
                == 0 as libc::c_int as libc::c_uint)
        {
            hdr = &mut (*(*input).tdata.elf_obj_data).dynsymtab_hdr;
            symcount = ((*hdr).sh_size)
                .wrapping_div((*(*bed).s).sizeof_sym as libc::c_ulong);
            if (*(*input).tdata.elf_obj_data).bad_symtab() != 0 {
                extsymcount = symcount;
                extsymoff = 0 as libc::c_int as size_t;
            } else {
                extsymcount = symcount.wrapping_sub((*hdr).sh_info as libc::c_ulong);
                extsymoff = (*hdr).sh_info as size_t;
            }
            if !(extsymcount == 0 as libc::c_int as libc::c_ulong) {
                isymbuf = bfd_elf_get_elf_syms(
                    input,
                    hdr,
                    extsymcount,
                    extsymoff,
                    0 as *mut Elf_Internal_Sym,
                    0 as *mut libc::c_void,
                    0 as *mut Elf_External_Sym_Shndx,
                );
                if isymbuf.is_null() {
                    return 0 as libc::c_int != 0;
                }
                versymhdr = &mut (*(*input).tdata.elf_obj_data).dynversym_hdr;
                if bfd_seek(input, (*versymhdr).sh_offset, 0 as libc::c_int)
                    != 0 as libc::c_int
                    || {
                        extversym = _bfd_malloc_and_read(
                            input,
                            (*versymhdr).sh_size,
                            (*versymhdr).sh_size,
                        ) as *mut Elf_External_Versym;
                        extversym.is_null()
                    }
                {
                    free(isymbuf as *mut libc::c_void);
                    return 0 as libc::c_int != 0;
                }
                ever = extversym.offset(extsymoff as isize);
                isymend = isymbuf.offset(extsymcount as isize);
                isym = isymbuf;
                while isym < isymend {
                    let mut name: *const libc::c_char = 0 as *const libc::c_char;
                    let mut iver: Elf_Internal_Versym = Elf_Internal_Versym {
                        vs_vers: 0,
                    };
                    let mut version_index: libc::c_ushort = 0;
                    if !((*isym).st_info as libc::c_uint >> 4 as libc::c_int
                        == 0 as libc::c_int as libc::c_uint
                        || (*isym).st_shndx == 0 as libc::c_int as libc::c_uint)
                    {
                        name = bfd_elf_string_from_elf_section(
                            input,
                            (*hdr).sh_link,
                            (*isym).st_name as libc::c_uint,
                        );
                        if !(strcmp(name, (*h).root.root.string) != 0 as libc::c_int) {
                            _bfd_elf_swap_versym_in(input, ever, &mut iver);
                            if iver.vs_vers as libc::c_int & 0x8000 as libc::c_int
                                == 0 as libc::c_int
                                && !((*h).def_regular() as libc::c_int != 0
                                    && (*h).forced_local() as libc::c_int != 0)
                            {
                                _bfd_abort(
                                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                                    10137 as libc::c_int,
                                    (*::core::mem::transmute::<
                                        &[u8; 125],
                                        &[libc::c_char; 125],
                                    >(
                                        b"_Bool elf_link_check_versioned_symbol(struct bfd_link_info *, const struct elf_backend_data *, struct elf_link_hash_entry *)\0",
                                    ))
                                        .as_ptr(),
                                );
                            }
                            version_index = (iver.vs_vers as libc::c_int
                                & 0x7fff as libc::c_int) as libc::c_ushort;
                            if version_index as libc::c_int == 1 as libc::c_int
                                || version_index as libc::c_int == 2 as libc::c_int
                            {
                                free(extversym as *mut libc::c_void);
                                free(isymbuf as *mut libc::c_void);
                                return 1 as libc::c_int != 0;
                            }
                        }
                    }
                    isym = isym.offset(1);
                    isym;
                    ever = ever.offset(1);
                    ever;
                }
                free(extversym as *mut libc::c_void);
                free(isymbuf as *mut libc::c_void);
            }
        }
        loaded = (*loaded).next;
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn elf_link_convert_common_type(
    mut info: *mut bfd_link_info,
    mut type_0: libc::c_int,
) -> libc::c_int {
    if !((*info).type_0() as libc::c_int == type_relocatable as libc::c_int) {
        _bfd_abort(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            10164 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 62],
                &[libc::c_char; 62],
            >(b"int elf_link_convert_common_type(struct bfd_link_info *, int)\0"))
                .as_ptr(),
        );
    }
    match (*info).elf_stt_common() as libc::c_int {
        1 => {
            type_0 = 5 as libc::c_int;
        }
        2 => {
            type_0 = 1 as libc::c_int;
        }
        0 | _ => {}
    }
    return type_0;
}
unsafe extern "C" fn elf_link_output_extsym(
    mut bh: *mut bfd_hash_entry,
    mut data: *mut libc::c_void,
) -> bool {
    let mut h: *mut elf_link_hash_entry = bh as *mut elf_link_hash_entry;
    let mut eoinfo: *mut elf_outext_info = data as *mut elf_outext_info;
    let mut flinfo: *mut elf_final_link_info = (*eoinfo).flinfo;
    let mut strip: bool = false;
    let mut sym: Elf_Internal_Sym = Elf_Internal_Sym {
        st_value: 0,
        st_size: 0,
        st_name: 0,
        st_info: 0,
        st_other: 0,
        st_target_internal: 0,
        st_shndx: 0,
    };
    let mut input_sec: *mut asection = 0 as *mut asection;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut indx: libc::c_long = 0;
    let mut ret: libc::c_int = 0;
    let mut type_0: libc::c_uint = 0;
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_warning as libc::c_int {
        h = (*h).root.u.i.link as *mut elf_link_hash_entry;
        if ((*h).root).type_0() as libc::c_int == bfd_link_hash_new as libc::c_int {
            return 1 as libc::c_int != 0;
        }
    }
    if (*eoinfo).localsyms {
        if (*h).forced_local() == 0 {
            return 1 as libc::c_int != 0;
        }
    } else if (*h).forced_local() != 0 {
        return 1 as libc::c_int != 0
    }
    bed = (*(*(*flinfo).output_bfd).xvec).backend_data as *const elf_backend_data;
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefined as libc::c_int {
        let mut ignore_undef: bool = 0 as libc::c_int != 0;
        if ((*bed).elf_backend_ignore_undef_symbol).is_some() {
            ignore_undef = ((*bed).elf_backend_ignore_undef_symbol)
                .expect("non-null function pointer")(h);
        }
        if !ignore_undef && (*h).ref_dynamic_nonweak() as libc::c_int != 0
            && ((*h).ref_regular() == 0
                || (*(*flinfo).info).gc_sections() as libc::c_int != 0)
            && !elf_link_check_versioned_symbol((*flinfo).info, bed, h)
            && (*(*flinfo).info).unresolved_syms_in_shared_libs() as libc::c_int
                != RM_IGNORE as libc::c_int
        {
            ((*(*(*flinfo).info).callbacks).undefined_symbol)
                .expect(
                    "non-null function pointer",
                )(
                (*flinfo).info,
                (*h).root.root.string,
                if (*h).ref_regular() as libc::c_int != 0 {
                    0 as *mut bfd
                } else {
                    (*h).root.u.undef.abfd
                },
                0 as *mut asection,
                0 as libc::c_int as bfd_vma,
                (*(*flinfo).info).unresolved_syms_in_shared_libs() as libc::c_int
                    == RM_DIAGNOSE as libc::c_int
                    && (*(*flinfo).info).warn_unresolved_syms() == 0,
            );
        }
        if (*h).indx == -(3 as libc::c_int) as libc::c_long {
            return 1 as libc::c_int != 0;
        }
    }
    if ((*(*flinfo).info).type_0() as libc::c_int == type_pde as libc::c_int
        || (*(*flinfo).info).type_0() as libc::c_int == type_pie as libc::c_int)
        && (*h).forced_local() as libc::c_int != 0
        && (*h).ref_dynamic() as libc::c_int != 0
        && (*h).def_regular() as libc::c_int != 0 && (*h).dynamic_def() == 0
        && (*h).ref_dynamic_nonweak() as libc::c_int != 0
        && !elf_link_check_versioned_symbol((*flinfo).info, bed, h)
    {
        let mut def_bfd: *mut bfd = 0 as *mut bfd;
        let mut msg: *const libc::c_char = 0 as *const libc::c_char;
        let mut hi: *mut elf_link_hash_entry = h;
        while ((*hi).root).type_0() as libc::c_int
            == bfd_link_hash_indirect as libc::c_int
        {
            hi = (*hi).root.u.i.link as *mut elf_link_hash_entry;
        }
        if (*h).other() as libc::c_int & 0x3 as libc::c_int == 1 as libc::c_int {
            msg = dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: internal symbol `%s' in %pB is referenced by DSO\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        } else if (*h).other() as libc::c_int & 0x3 as libc::c_int == 2 as libc::c_int {
            msg = dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: hidden symbol `%s' in %pB is referenced by DSO\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        } else {
            msg = dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: local symbol `%s' in %pB is referenced by DSO\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        def_bfd = (*flinfo).output_bfd;
        if (*hi).root.u.def.section
            != &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
                as *mut asection
        {
            def_bfd = (*(*hi).root.u.def.section).owner;
        }
        _bfd_error_handler(msg, (*flinfo).output_bfd, (*h).root.root.string, def_bfd);
        bfd_set_error(bfd_error_bad_value);
        (*eoinfo).failed = 1 as libc::c_int != 0;
        return 0 as libc::c_int != 0;
    }
    strip = 0 as libc::c_int != 0;
    if !((*h).indx == -(2 as libc::c_int) as libc::c_long) {
        if ((*h).def_dynamic() as libc::c_int != 0
            || (*h).ref_dynamic() as libc::c_int != 0
            || ((*h).root).type_0() as libc::c_int == bfd_link_hash_new as libc::c_int)
            && (*h).def_regular() == 0 && (*h).ref_regular() == 0
        {
            strip = 1 as libc::c_int != 0;
        } else if (*(*flinfo).info).strip() as libc::c_int == strip_all as libc::c_int {
            strip = 1 as libc::c_int != 0;
        } else if (*(*flinfo).info).strip() as libc::c_int == strip_some as libc::c_int
            && (bfd_hash_lookup(
                (*(*flinfo).info).keep_hash,
                (*h).root.root.string,
                0 as libc::c_int != 0,
                0 as libc::c_int != 0,
            ))
                .is_null()
        {
            strip = 1 as libc::c_int != 0;
        } else if (((*h).root).type_0() as libc::c_int
            == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int)
            && ((*(*flinfo).info).strip_discarded() as libc::c_int != 0
                && discarded_section((*h).root.u.def.section) as libc::c_int != 0
                || (*(*h).root.u.def.section).flags
                    & 0x100000 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                    && !((*(*h).root.u.def.section).owner).is_null()
                    && (*(*(*h).root.u.def.section).owner).flags
                        & 0x10000 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint)
        {
            strip = 1 as libc::c_int != 0;
        } else if (((*h).root).type_0() as libc::c_int
            == bfd_link_hash_undefined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_undefweak as libc::c_int)
            && !((*h).root.u.undef.abfd).is_null()
            && (*(*h).root.u.undef.abfd).flags & 0x10000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
        {
            strip = 1 as libc::c_int != 0;
        }
    }
    type_0 = (*h).type_0();
    if strip as libc::c_int != 0 && (*h).dynindx == -(1 as libc::c_int) as libc::c_long
        && type_0 != 10 as libc::c_int as libc::c_uint && (*h).forced_local() == 0
    {
        return 1 as libc::c_int != 0;
    }
    sym.st_value = 0 as libc::c_int as bfd_vma;
    sym.st_size = (*h).size;
    sym.st_other = (*h).other() as libc::c_uchar;
    match ((*h).root).type_0() as libc::c_int {
        1 | 2 => {
            input_sec = &mut *_bfd_std_section
                .as_mut_ptr()
                .offset(1 as libc::c_int as isize) as *mut asection;
            sym.st_shndx = 0 as libc::c_int as libc::c_uint;
        }
        3 | 4 => {
            input_sec = (*h).root.u.def.section;
            if !((*input_sec).output_section).is_null() {
                sym
                    .st_shndx = _bfd_elf_section_from_bfd_section(
                    (*flinfo).output_bfd,
                    (*input_sec).output_section,
                );
                if sym.st_shndx == (0x101 as libc::c_uint).wrapping_neg() {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: could not find output section %pA for input section %pA\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*flinfo).output_bfd,
                        (*input_sec).output_section,
                        input_sec,
                    );
                    bfd_set_error(bfd_error_nonrepresentable_section);
                    (*eoinfo).failed = 1 as libc::c_int != 0;
                    return 0 as libc::c_int != 0;
                }
                sym
                    .st_value = ((*h).root.u.def.value)
                    .wrapping_add((*input_sec).output_offset);
                if !((*(*flinfo).info).type_0() as libc::c_int
                    == type_relocatable as libc::c_int)
                {
                    sym
                        .st_value = (sym.st_value as libc::c_ulong)
                        .wrapping_add((*(*input_sec).output_section).vma) as bfd_vma
                        as bfd_vma;
                    if (*h).type_0() as libc::c_int == 6 as libc::c_int {
                        let mut tls_sec: *mut asection = (*elf_hash_table(
                            (*flinfo).info,
                        ))
                            .tls_sec;
                        if !tls_sec.is_null() {
                            sym
                                .st_value = (sym.st_value as libc::c_ulong)
                                .wrapping_sub((*tls_sec).vma) as bfd_vma as bfd_vma;
                        }
                    }
                }
            } else {
                if !(((*input_sec).owner).is_null()
                    || (*(*input_sec).owner).flags & 0x40 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint)
                {
                    bfd_assert(
                        b"elflink.c\0" as *const u8 as *const libc::c_char,
                        10391 as libc::c_int,
                    );
                }
                sym.st_shndx = 0 as libc::c_int as libc::c_uint;
                input_sec = &mut *_bfd_std_section
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut asection;
            }
        }
        5 => {
            input_sec = (*(*h).root.u.c.p).section;
            sym
                .st_shndx = ((*bed).common_section_index)
                .expect("non-null function pointer")(input_sec);
            sym
                .st_value = ((1 as libc::c_int) << (*(*h).root.u.c.p).alignment_power)
                as bfd_vma;
        }
        6 => return 1 as libc::c_int != 0,
        0 | 7 | _ => {
            _bfd_abort(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                10344 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 62],
                    &[libc::c_char; 62],
                >(b"_Bool elf_link_output_extsym(struct bfd_hash_entry *, void *)\0"))
                    .as_ptr(),
            );
        }
    }
    if type_0 == 5 as libc::c_int as libc::c_uint
        || type_0 == 1 as libc::c_int as libc::c_uint
    {
        match ((*h).root).type_0() as libc::c_int {
            5 => {
                type_0 = elf_link_convert_common_type(
                    (*flinfo).info,
                    type_0 as libc::c_int,
                ) as libc::c_uint;
            }
            3 | 4 => {
                if ((*bed).common_definition)
                    .expect("non-null function pointer")(&mut sym)
                {
                    type_0 = elf_link_convert_common_type(
                        (*flinfo).info,
                        type_0 as libc::c_int,
                    ) as libc::c_uint;
                } else {
                    type_0 = 1 as libc::c_int as libc::c_uint;
                }
            }
            1 | 2 => {}
            _ => {
                _bfd_abort(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    10431 as libc::c_int,
                    (*::core::mem::transmute::<
                        &[u8; 62],
                        &[libc::c_char; 62],
                    >(
                        b"_Bool elf_link_output_extsym(struct bfd_hash_entry *, void *)\0",
                    ))
                        .as_ptr(),
                );
            }
        }
    }
    if (*h).forced_local() != 0 {
        sym
            .st_info = (((0 as libc::c_int) << 4 as libc::c_int) as libc::c_uint)
            .wrapping_add(type_0 & 0xf as libc::c_int as libc::c_uint) as libc::c_uchar;
        sym
            .st_other = (sym.st_other as libc::c_int
            & !(-(1 as libc::c_int) & 0x3 as libc::c_int)) as libc::c_uchar;
    } else if (*h).unique_global() as libc::c_int != 0
        && (*h).def_regular() as libc::c_int != 0
    {
        sym
            .st_info = (((10 as libc::c_int) << 4 as libc::c_int) as libc::c_uint)
            .wrapping_add(type_0 & 0xf as libc::c_int as libc::c_uint) as libc::c_uchar;
    } else if ((*h).root).type_0() as libc::c_int
        == bfd_link_hash_undefweak as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_defweak as libc::c_int
    {
        sym
            .st_info = (((2 as libc::c_int) << 4 as libc::c_int) as libc::c_uint)
            .wrapping_add(type_0 & 0xf as libc::c_int as libc::c_uint) as libc::c_uchar;
    } else {
        sym
            .st_info = (((1 as libc::c_int) << 4 as libc::c_int) as libc::c_uint)
            .wrapping_add(type_0 & 0xf as libc::c_int as libc::c_uint) as libc::c_uchar;
    }
    sym.st_target_internal = (*h).target_internal() as libc::c_uchar;
    if (*h).type_0() as libc::c_int == 10 as libc::c_int
        && (*h).def_regular() as libc::c_int != 0
        && !((*(*flinfo).info).type_0() as libc::c_int
            == type_relocatable as libc::c_int)
        || ((*h).dynindx != -(1 as libc::c_int) as libc::c_long
            || (*h).forced_local() as libc::c_int != 0)
            && (((*(*flinfo).info).type_0() as libc::c_int == type_dll as libc::c_int
                || (*(*flinfo).info).type_0() as libc::c_int == type_pie as libc::c_int)
                && ((*h).other() as libc::c_int & 0x3 as libc::c_int == 0 as libc::c_int
                    || ((*h).root).type_0() as libc::c_int
                        != bfd_link_hash_undefweak as libc::c_int)
                || (*h).forced_local() == 0)
            && (*elf_hash_table((*flinfo).info)).dynamic_sections_created as libc::c_int
                != 0
    {
        if !(Some(
            ((*bed).elf_backend_finish_dynamic_symbol)
                .expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )((*flinfo).output_bfd, (*flinfo).info, h, &mut sym)
        {
            (*eoinfo).failed = 1 as libc::c_int != 0;
            return 0 as libc::c_int != 0;
        }
    }
    if sym.st_shndx == 0 as libc::c_int as libc::c_uint
        && (*h).ref_regular() as libc::c_int != 0
        && (sym.st_info as libc::c_uint >> 4 as libc::c_int
            == 1 as libc::c_int as libc::c_uint
            || sym.st_info as libc::c_uint >> 4 as libc::c_int
                == 2 as libc::c_int as libc::c_uint)
    {
        let mut bindtype: libc::c_int = 0;
        type_0 = (sym.st_info as libc::c_int & 0xf as libc::c_int) as libc::c_uint;
        if type_0 == 10 as libc::c_int as libc::c_uint {
            type_0 = 2 as libc::c_int as libc::c_uint;
        }
        if (*h).ref_regular_nonweak() != 0 {
            bindtype = 1 as libc::c_int;
        } else {
            bindtype = 2 as libc::c_int;
        }
        sym
            .st_info = ((bindtype << 4 as libc::c_int) as libc::c_uint)
            .wrapping_add(type_0 & 0xf as libc::c_int as libc::c_uint) as libc::c_uchar;
    }
    if sym.st_shndx == 0 as libc::c_int as libc::c_uint && (*h).def_regular() == 0
        && (*h).def_dynamic() as libc::c_int != 0
    {
        sym.st_size = 0 as libc::c_int as bfd_vma;
    }
    if !((*(*flinfo).info).type_0() as libc::c_int == type_relocatable as libc::c_int)
        && sym.st_other as libc::c_int & 0x3 as libc::c_int != 0 as libc::c_int
        && sym.st_info as libc::c_uint >> 4 as libc::c_int
            != 2 as libc::c_int as libc::c_uint
        && ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefined as libc::c_int
        && (*h).def_regular() == 0
    {
        let mut msg_0: *const libc::c_char = 0 as *const libc::c_char;
        if sym.st_other as libc::c_int & 0x3 as libc::c_int == 3 as libc::c_int {
            msg_0 = dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: protected symbol `%s' isn't defined\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        } else if sym.st_other as libc::c_int & 0x3 as libc::c_int == 1 as libc::c_int {
            msg_0 = dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: internal symbol `%s' isn't defined\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        } else {
            msg_0 = dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: hidden symbol `%s' isn't defined\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            );
        }
        _bfd_error_handler(msg_0, (*flinfo).output_bfd, (*h).root.root.string);
        bfd_set_error(bfd_error_bad_value);
        (*eoinfo).failed = 1 as libc::c_int != 0;
        return 0 as libc::c_int != 0;
    }
    if (*h).dynindx != -(1 as libc::c_int) as libc::c_long
        && (*elf_hash_table((*flinfo).info)).dynamic_sections_created as libc::c_int != 0
        && !((*elf_hash_table((*flinfo).info)).dynsym).is_null()
        && !discarded_section((*elf_hash_table((*flinfo).info)).dynsym)
    {
        let mut esym: *mut bfd_byte = 0 as *mut bfd_byte;
        if ((*h).verinfo.verdef).is_null()
            && (!((*(*flinfo).info).type_0() as libc::c_int == type_pde as libc::c_int
                || (*(*flinfo).info).type_0() as libc::c_int == type_pie as libc::c_int)
                || (*h).ref_dynamic() as libc::c_int != 0 || (*h).def_regular() == 0)
        {
            let mut p: *mut libc::c_char = strrchr((*h).root.root.string, '@' as i32);
            if !p.is_null()
                && *p.offset(1 as libc::c_int as isize) as libc::c_int != '\0' as i32
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB: no symbol version section for versioned symbol `%s'\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    (*flinfo).output_bfd,
                    (*h).root.root.string,
                );
                (*eoinfo).failed = 1 as libc::c_int != 0;
                return 0 as libc::c_int != 0;
            }
        }
        sym.st_name = (*h).dynstr_index;
        esym = ((*(*elf_hash_table((*flinfo).info)).dynsym).contents)
            .offset(((*h).dynindx * (*(*bed).s).sizeof_sym as libc::c_long) as isize);
        if !check_dynsym((*flinfo).output_bfd, &mut sym) {
            (*eoinfo).failed = 1 as libc::c_int != 0;
            return 0 as libc::c_int != 0;
        }
        if ((*(*(*flinfo).info).callbacks).ctf_new_dynsym).is_some() {
            ((*(*(*flinfo).info).callbacks).ctf_new_dynsym)
                .expect(
                    "non-null function pointer",
                )((*h).dynindx as libc::c_int, &mut sym);
        }
        ((*(*bed).s).swap_symbol_out)
            .expect(
                "non-null function pointer",
            )(
            (*flinfo).output_bfd,
            &mut sym,
            esym as *mut libc::c_void,
            0 as *mut libc::c_void,
        );
        if !((*flinfo).hash_sec).is_null() {
            let mut hash_entry_size: size_t = 0;
            let mut bucketpos: *mut bfd_byte = 0 as *mut bfd_byte;
            let mut chain: bfd_vma = 0;
            let mut bucketcount: size_t = 0;
            let mut bucket: size_t = 0;
            bucketcount = (*elf_hash_table((*flinfo).info)).bucketcount;
            bucket = ((*h).u.elf_hash_value).wrapping_rem(bucketcount);
            hash_entry_size = (*((*(*flinfo).hash_sec).used_by_bfd
                as *mut bfd_elf_section_data))
                .this_hdr
                .sh_entsize;
            bucketpos = ((*(*flinfo).hash_sec).contents as *mut bfd_byte)
                .offset(
                    bucket
                        .wrapping_add(2 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(hash_entry_size) as isize,
                );
            chain = if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                == 8 as libc::c_int as libc::c_ulong
            {
                *(bucketpos as *const libc::c_uchar) as bfd_vma
                    & 0xff as libc::c_int as libc::c_ulong
            } else if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                == 16 as libc::c_int as libc::c_ulong
            {
                (Some(
                    ((*(*(*flinfo).output_bfd).xvec).bfd_getx16)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(bucketpos as *const libc::c_void)
            } else if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                == 32 as libc::c_int as libc::c_ulong
            {
                (Some(
                    ((*(*(*flinfo).output_bfd).xvec).bfd_getx32)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(bucketpos as *const libc::c_void)
            } else if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                == 64 as libc::c_int as libc::c_ulong
            {
                (Some(
                    ((*(*(*flinfo).output_bfd).xvec).bfd_getx64)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(bucketpos as *const libc::c_void)
            } else {
                _bfd_abort(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    10596 as libc::c_int,
                    (*::core::mem::transmute::<
                        &[u8; 62],
                        &[libc::c_char; 62],
                    >(
                        b"_Bool elf_link_output_extsym(struct bfd_hash_entry *, void *)\0",
                    ))
                        .as_ptr(),
                );
                -(1 as libc::c_int) as bfd_vma
            };
            if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                == 8 as libc::c_int as libc::c_ulong
            {
                *(bucketpos
                    as *mut libc::c_uchar) = ((*h).dynindx
                    & 0xff as libc::c_int as libc::c_long) as libc::c_uchar;
            } else {
                if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                    == 16 as libc::c_int as libc::c_ulong
                {
                    (Some(
                        ((*(*(*flinfo).output_bfd).xvec).bfd_putx16)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )((*h).dynindx as bfd_vma, bucketpos as *mut libc::c_void);
                } else {
                    if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                        == 32 as libc::c_int as libc::c_ulong
                    {
                        (Some(
                            ((*(*(*flinfo).output_bfd).xvec).bfd_putx32)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )((*h).dynindx as bfd_vma, bucketpos as *mut libc::c_void);
                    } else {
                        if (8 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(hash_entry_size)
                            == 64 as libc::c_int as libc::c_ulong
                        {
                            (Some(
                                ((*(*(*flinfo).output_bfd).xvec).bfd_putx64)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*h).dynindx as bfd_uint64_t,
                                bucketpos as *mut libc::c_void,
                            );
                        } else {
                            _bfd_abort(
                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                10598 as libc::c_int,
                                (*::core::mem::transmute::<
                                    &[u8; 62],
                                    &[libc::c_char; 62],
                                >(
                                    b"_Bool elf_link_output_extsym(struct bfd_hash_entry *, void *)\0",
                                ))
                                    .as_ptr(),
                            );
                        };
                    };
                };
            };
            if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                == 8 as libc::c_int as libc::c_ulong
            {
                *(((*(*flinfo).hash_sec).contents as *mut bfd_byte)
                    .offset(
                        bucketcount
                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                            .wrapping_add((*h).dynindx as libc::c_ulong)
                            .wrapping_mul(hash_entry_size) as isize,
                    )
                    as *mut libc::c_uchar) = (chain
                    & 0xff as libc::c_int as libc::c_ulong) as libc::c_uchar;
            } else {
                if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                    == 16 as libc::c_int as libc::c_ulong
                {
                    (Some(
                        ((*(*(*flinfo).output_bfd).xvec).bfd_putx16)
                            .expect("non-null function pointer"),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        chain,
                        ((*(*flinfo).hash_sec).contents as *mut bfd_byte)
                            .offset(
                                bucketcount
                                    .wrapping_add(2 as libc::c_int as libc::c_ulong)
                                    .wrapping_add((*h).dynindx as libc::c_ulong)
                                    .wrapping_mul(hash_entry_size) as isize,
                            ) as *mut libc::c_void,
                    );
                } else {
                    if (8 as libc::c_int as libc::c_ulong).wrapping_mul(hash_entry_size)
                        == 32 as libc::c_int as libc::c_ulong
                    {
                        (Some(
                            ((*(*(*flinfo).output_bfd).xvec).bfd_putx32)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            chain,
                            ((*(*flinfo).hash_sec).contents as *mut bfd_byte)
                                .offset(
                                    bucketcount
                                        .wrapping_add(2 as libc::c_int as libc::c_ulong)
                                        .wrapping_add((*h).dynindx as libc::c_ulong)
                                        .wrapping_mul(hash_entry_size) as isize,
                                ) as *mut libc::c_void,
                        );
                    } else {
                        if (8 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(hash_entry_size)
                            == 64 as libc::c_int as libc::c_ulong
                        {
                            (Some(
                                ((*(*(*flinfo).output_bfd).xvec).bfd_putx64)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                chain,
                                ((*(*flinfo).hash_sec).contents as *mut bfd_byte)
                                    .offset(
                                        bucketcount
                                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                                            .wrapping_add((*h).dynindx as libc::c_ulong)
                                            .wrapping_mul(hash_entry_size) as isize,
                                    ) as *mut libc::c_void,
                            );
                        } else {
                            _bfd_abort(
                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                10601 as libc::c_int,
                                (*::core::mem::transmute::<
                                    &[u8; 62],
                                    &[libc::c_char; 62],
                                >(
                                    b"_Bool elf_link_output_extsym(struct bfd_hash_entry *, void *)\0",
                                ))
                                    .as_ptr(),
                            );
                        };
                    };
                };
            };
        }
        if !((*flinfo).symver_sec).is_null()
            && !((*(*flinfo).symver_sec).contents).is_null()
        {
            let mut iversym: Elf_Internal_Versym = Elf_Internal_Versym { vs_vers: 0 };
            let mut eversym: *mut Elf_External_Versym = 0 as *mut Elf_External_Versym;
            if (*h).def_regular() == 0
                && !((*h).def_regular() == 0 && (*h).def_dynamic() == 0
                    && ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_defined as libc::c_int)
            {
                if ((*h).verinfo.verdef).is_null()
                    || (*(*(*(*h).verinfo.verdef).vd_bfd).tdata.elf_obj_data)
                        .dyn_lib_class() as libc::c_int
                        & (DYN_AS_NEEDED as libc::c_int | DYN_DT_NEEDED as libc::c_int
                            | DYN_NO_NEEDED as libc::c_int) != 0
                {
                    iversym.vs_vers = 1 as libc::c_int as libc::c_ushort;
                } else {
                    iversym
                        .vs_vers = ((*(*h).verinfo.verdef).vd_exp_refno)
                        .wrapping_add(1 as libc::c_int as libc::c_uint)
                        as libc::c_ushort;
                }
            } else {
                if ((*h).verinfo.vertree).is_null() {
                    iversym.vs_vers = 1 as libc::c_int as libc::c_ushort;
                } else {
                    iversym
                        .vs_vers = ((*(*h).verinfo.vertree).vernum)
                        .wrapping_add(1 as libc::c_int as libc::c_uint)
                        as libc::c_ushort;
                }
                if (*(*flinfo).info).create_default_symver() != 0 {
                    iversym.vs_vers = (iversym.vs_vers).wrapping_add(1);
                    iversym.vs_vers;
                }
            }
            if (*h).versioned() as libc::c_int == versioned_hidden as libc::c_int
                && (*h).def_regular() as libc::c_int != 0
            {
                iversym
                    .vs_vers = (iversym.vs_vers as libc::c_int | 0x8000 as libc::c_int)
                    as libc::c_ushort;
            }
            eversym = (*(*flinfo).symver_sec).contents as *mut Elf_External_Versym;
            eversym = eversym.offset((*h).dynindx as isize);
            _bfd_elf_swap_versym_out((*flinfo).output_bfd, &mut iversym, eversym);
        }
    } else if input_sec
        == &mut *_bfd_std_section.as_mut_ptr().offset(1 as libc::c_int as isize)
            as *mut asection && (*h).indx != -(2 as libc::c_int) as libc::c_long
        && ((*h).mark() as libc::c_int != 1 as libc::c_int
            || sym.st_info as libc::c_uint >> 4 as libc::c_int
                != 1 as libc::c_int as libc::c_uint)
        && !((*(*flinfo).info).type_0() as libc::c_int
            == type_relocatable as libc::c_int)
    {
        return 1 as libc::c_int != 0
    }
    if strip {
        return 1 as libc::c_int != 0;
    }
    if (*input_sec).flags & 0x8000 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    if (*eoinfo).localsyms as libc::c_int != 0 && !(*eoinfo).file_sym_done
        && (*(*eoinfo).flinfo).filesym_count != 0 as libc::c_int as libc::c_ulong
    {
        let mut fsym: Elf_Internal_Sym = Elf_Internal_Sym {
            st_value: 0,
            st_size: 0,
            st_name: 0,
            st_info: 0,
            st_other: 0,
            st_target_internal: 0,
            st_shndx: 0,
        };
        memset(
            &mut fsym as *mut Elf_Internal_Sym as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
        );
        fsym
            .st_info = (((0 as libc::c_int) << 4 as libc::c_int)
            + (4 as libc::c_int & 0xf as libc::c_int)) as libc::c_uchar;
        fsym.st_shndx = (0xf as libc::c_uint).wrapping_neg();
        if elf_link_output_symstrtab(
            (*eoinfo).flinfo as *mut libc::c_void,
            0 as *const libc::c_char,
            &mut fsym,
            &mut *_bfd_std_section.as_mut_ptr().offset(1 as libc::c_int as isize),
            0 as *mut elf_link_hash_entry,
        ) == 0
        {
            return 0 as libc::c_int != 0;
        }
        (*eoinfo).file_sym_done = 1 as libc::c_int != 0;
    }
    indx = bfd_get_symcount((*flinfo).output_bfd) as libc::c_long;
    ret = elf_link_output_symstrtab(
        flinfo as *mut libc::c_void,
        (*h).root.root.string,
        &mut sym,
        input_sec,
        h,
    );
    if ret == 0 as libc::c_int {
        (*eoinfo).failed = 1 as libc::c_int != 0;
        return 0 as libc::c_int != 0;
    } else if ret == 1 as libc::c_int {
        (*h).indx = indx;
    } else if (*h).indx == -(2 as libc::c_int) as libc::c_long {
        _bfd_abort(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            10690 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 62],
                &[libc::c_char; 62],
            >(b"_Bool elf_link_output_extsym(struct bfd_hash_entry *, void *)\0"))
                .as_ptr(),
        );
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_section_ignore_discarded_relocs(
    mut sec: *mut asection,
) -> bool {
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    match (*sec).sec_info_type() as libc::c_int {
        1 | 3 | 6 => return 1 as libc::c_int != 0,
        _ => {}
    }
    bed = (*(*(*sec).owner).xvec).backend_data as *const elf_backend_data;
    if ((*bed).elf_backend_ignore_discarded_relocs).is_some()
        && (Some(
            ((*bed).elf_backend_ignore_discarded_relocs)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(sec) as libc::c_int != 0
    {
        return 1 as libc::c_int != 0;
    }
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_default_action_discarded(
    mut sec: *mut asection,
) -> libc::c_uint {
    if (*sec).flags & 0x2000 as libc::c_int as libc::c_uint != 0 {
        return PRETEND as libc::c_int as libc::c_uint;
    }
    if strcmp(b".eh_frame\0" as *const u8 as *const libc::c_char, (*sec).name)
        == 0 as libc::c_int
    {
        return 0 as libc::c_int as libc::c_uint;
    }
    if strcmp(b".gcc_except_table\0" as *const u8 as *const libc::c_char, (*sec).name)
        == 0 as libc::c_int
    {
        return 0 as libc::c_int as libc::c_uint;
    }
    return (COMPLAIN as libc::c_int | PRETEND as libc::c_int) as libc::c_uint;
}
unsafe extern "C" fn match_group_member(
    mut sec: *mut asection,
    mut group: *mut asection,
    mut info: *mut bfd_link_info,
) -> *mut asection {
    let mut first: *mut asection = (*((*group).used_by_bfd as *mut bfd_elf_section_data))
        .next_in_group;
    let mut s: *mut asection = first;
    while !s.is_null() {
        if bfd_elf_match_symbols_in_sections(s, sec, info) {
            return s;
        }
        s = (*((*s).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
        if s == first {
            break;
        }
    }
    return 0 as *mut asection;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_check_kept_section(
    mut sec: *mut asection,
    mut info: *mut bfd_link_info,
) -> *mut asection {
    let mut kept: *mut asection = 0 as *mut asection;
    kept = (*sec).kept_section;
    if !kept.is_null() {
        if (*kept).flags & 0x2000000 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        {
            kept = match_group_member(sec, kept, info);
        }
        if !kept.is_null() {
            if (if (*sec).rawsize != 0 as libc::c_int as libc::c_ulong {
                (*sec).rawsize
            } else {
                (*sec).size
            })
                != (if (*kept).rawsize != 0 as libc::c_int as libc::c_ulong {
                    (*kept).rawsize
                } else {
                    (*kept).size
                })
            {
                kept = 0 as *mut asection;
            } else {
                let mut next: *mut asection = 0 as *mut asection;
                next = (*kept).kept_section;
                while !next.is_null() {
                    kept = next;
                    next = (*next).kept_section;
                }
            }
        }
        (*sec).kept_section = kept;
    }
    return kept;
}
unsafe extern "C" fn elf_link_input_bfd(
    mut flinfo: *mut elf_final_link_info,
    mut input_bfd: *mut bfd,
) -> bool {
    let mut relocate_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd,
            *mut asection,
            *mut bfd_byte,
            *mut Elf_Internal_Rela,
            *mut Elf_Internal_Sym,
            *mut *mut asection,
        ) -> libc::c_int,
    > = None;
    let mut output_bfd: *mut bfd = 0 as *mut bfd;
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut locsymcount: size_t = 0;
    let mut extsymoff: size_t = 0;
    let mut isymbuf: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isymend: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut pindex: *mut libc::c_long = 0 as *mut libc::c_long;
    let mut ppsection: *mut *mut asection = 0 as *mut *mut asection;
    let mut o: *mut asection = 0 as *mut asection;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut sym_hashes: *mut *mut elf_link_hash_entry = 0
        as *mut *mut elf_link_hash_entry;
    let mut address_size: bfd_size_type = 0;
    let mut r_type_mask: bfd_vma = 0;
    let mut r_sym_shift: libc::c_int = 0;
    let mut have_file_sym: bool = 0 as libc::c_int != 0;
    output_bfd = (*flinfo).output_bfd;
    bed = (*(*output_bfd).xvec).backend_data as *const elf_backend_data;
    relocate_section = (*bed).elf_backend_relocate_section;
    if (*input_bfd).flags & 0x40 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    symtab_hdr = &mut (*(*input_bfd).tdata.elf_obj_data).symtab_hdr;
    if (*(*input_bfd).tdata.elf_obj_data).bad_symtab() != 0 {
        locsymcount = ((*symtab_hdr).sh_size)
            .wrapping_div((*(*bed).s).sizeof_sym as libc::c_ulong);
        extsymoff = 0 as libc::c_int as size_t;
    } else {
        locsymcount = (*symtab_hdr).sh_info as size_t;
        extsymoff = (*symtab_hdr).sh_info as size_t;
    }
    if (*bed).elf_osabi == 0 as libc::c_int || (*bed).elf_osabi == 3 as libc::c_int
        || (*bed).elf_osabi == 9 as libc::c_int
    {
        (*(*output_bfd).tdata.elf_obj_data)
            .set_has_gnu_osabi(
                (*(*output_bfd).tdata.elf_obj_data).has_gnu_osabi()
                    | ((*(*input_bfd).tdata.elf_obj_data).has_gnu_osabi() as libc::c_int
                        & (if (*(*flinfo).info).type_0() as libc::c_int
                            == type_relocatable as libc::c_int
                        {
                            -(1 as libc::c_int)
                        } else {
                            !(elf_gnu_osabi_retain as libc::c_int)
                        })) as elf_gnu_osabi,
            );
    }
    isymbuf = (*symtab_hdr).contents as *mut Elf_Internal_Sym;
    if isymbuf.is_null() && locsymcount != 0 as libc::c_int as libc::c_ulong {
        isymbuf = bfd_elf_get_elf_syms(
            input_bfd,
            symtab_hdr,
            locsymcount,
            0 as libc::c_int as size_t,
            (*flinfo).internal_syms,
            (*flinfo).external_syms as *mut libc::c_void,
            (*flinfo).locsym_shndx,
        );
        if isymbuf.is_null() {
            return 0 as libc::c_int != 0;
        }
    }
    isymend = isymbuf.offset(locsymcount as isize);
    let mut current_block_75: u64;
    isym = isymbuf;
    pindex = (*flinfo).indices;
    ppsection = (*flinfo).sections;
    while isym < isymend {
        let mut isec: *mut asection = 0 as *mut asection;
        let mut name: *const libc::c_char = 0 as *const libc::c_char;
        let mut osym: Elf_Internal_Sym = Elf_Internal_Sym {
            st_value: 0,
            st_size: 0,
            st_name: 0,
            st_info: 0,
            st_other: 0,
            st_target_internal: 0,
            st_shndx: 0,
        };
        let mut indx: libc::c_long = 0;
        let mut ret: libc::c_int = 0;
        *pindex = -(1 as libc::c_int) as libc::c_long;
        if (*(*input_bfd).tdata.elf_obj_data).bad_symtab() != 0 {
            if (*isym).st_info as libc::c_uint >> 4 as libc::c_int
                != 0 as libc::c_int as libc::c_uint
            {
                *ppsection = 0 as *mut asection;
                current_block_75 = 14401909646449704462;
            } else {
                current_block_75 = 7205609094909031804;
            }
        } else {
            current_block_75 = 7205609094909031804;
        }
        match current_block_75 {
            7205609094909031804 => {
                if (*isym).st_shndx == 0 as libc::c_int as libc::c_uint {
                    isec = &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize) as *mut asection;
                } else if (*isym).st_shndx == (0xf as libc::c_uint).wrapping_neg() {
                    isec = &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize) as *mut asection;
                } else if (*isym).st_shndx == (0xe as libc::c_uint).wrapping_neg() {
                    isec = &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize) as *mut asection;
                } else {
                    isec = bfd_section_from_elf_index(input_bfd, (*isym).st_shndx);
                    if isec.is_null() {
                        isec = &mut *_bfd_std_section
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize) as *mut asection;
                    } else if (*isec).sec_info_type() as libc::c_int == 2 as libc::c_int
                        && (*isym).st_info as libc::c_int & 0xf as libc::c_int
                            != 3 as libc::c_int
                    {
                        (*isym)
                            .st_value = _bfd_merged_section_offset(
                            output_bfd,
                            &mut isec,
                            (*((*isec).used_by_bfd as *mut bfd_elf_section_data))
                                .sec_info,
                            (*isym).st_value,
                        );
                    }
                }
                *ppsection = isec;
                if !(isec
                    == &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(1 as libc::c_int as isize) as *mut asection)
                {
                    if !((*isym).st_info as libc::c_int & 0xf as libc::c_int
                        == 3 as libc::c_int)
                    {
                        if !((*(*flinfo).info).strip() as libc::c_int
                            == strip_all as libc::c_int)
                        {
                            if !((*(*flinfo).info).discard() as libc::c_int
                                == discard_all as libc::c_int)
                            {
                                if (*isym).st_shndx != 0 as libc::c_int as libc::c_uint
                                    && (*isym).st_shndx < (0x100 as libc::c_uint).wrapping_neg()
                                    && ((*isec).output_section).is_null()
                                    && (*(*flinfo).info).non_contiguous_regions() as libc::c_int
                                        != 0
                                    && (*(*flinfo).info).non_contiguous_regions_warnings()
                                        as libc::c_int != 0
                                {
                                    _bfd_error_handler(
                                        dcgettext(
                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                            b"warning: --enable-non-contiguous-regions discards section `%s' from '%s'\n\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        (*isec).name,
                                        bfd_get_filename((*isec).owner),
                                    );
                                } else if !((*isym).st_shndx
                                    != 0 as libc::c_int as libc::c_uint
                                    && (*isym).st_shndx < (0x100 as libc::c_uint).wrapping_neg()
                                    && bfd_section_removed_from_list(
                                        output_bfd,
                                        (*isec).output_section,
                                    ) as libc::c_int != 0)
                                {
                                    name = bfd_elf_string_from_elf_section(
                                        input_bfd,
                                        (*symtab_hdr).sh_link,
                                        (*isym).st_name as libc::c_uint,
                                    );
                                    if name.is_null() {
                                        return 0 as libc::c_int != 0;
                                    }
                                    if !((*(*flinfo).info).strip() as libc::c_int
                                        == strip_some as libc::c_int
                                        && (bfd_hash_lookup(
                                            (*(*flinfo).info).keep_hash,
                                            name,
                                            0 as libc::c_int != 0,
                                            0 as libc::c_int != 0,
                                        ))
                                            .is_null()
                                        || ((*(*flinfo).info).discard() as libc::c_int
                                            == discard_sec_merge as libc::c_int
                                            && (*isec).flags & 0x800000 as libc::c_int as libc::c_uint
                                                != 0
                                            && !((*(*flinfo).info).type_0() as libc::c_int
                                                == type_relocatable as libc::c_int)
                                            || (*(*flinfo).info).discard() as libc::c_int
                                                == discard_l as libc::c_int)
                                            && (Some(
                                                ((*(*input_bfd).xvec)._bfd_is_local_label_name)
                                                    .expect("non-null function pointer"),
                                            ))
                                                .expect("non-null function pointer")(input_bfd, name)
                                                as libc::c_int != 0)
                                    {
                                        if (*isym).st_info as libc::c_int & 0xf as libc::c_int
                                            == 4 as libc::c_int
                                        {
                                            if (*input_bfd).lto_output() != 0 {
                                                current_block_75 = 14401909646449704462;
                                            } else {
                                                have_file_sym = 1 as libc::c_int != 0;
                                                (*flinfo)
                                                    .filesym_count = ((*flinfo).filesym_count as libc::c_ulong)
                                                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as size_t
                                                    as size_t;
                                                current_block_75 = 12829669402821218572;
                                            }
                                        } else {
                                            current_block_75 = 12829669402821218572;
                                        }
                                        match current_block_75 {
                                            14401909646449704462 => {}
                                            _ => {
                                                if !have_file_sym {
                                                    let mut filename: *const libc::c_char = 0
                                                        as *const libc::c_char;
                                                    have_file_sym = 1 as libc::c_int != 0;
                                                    (*flinfo)
                                                        .filesym_count = ((*flinfo).filesym_count as libc::c_ulong)
                                                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as size_t
                                                        as size_t;
                                                    memset(
                                                        &mut osym as *mut Elf_Internal_Sym as *mut libc::c_void,
                                                        0 as libc::c_int,
                                                        ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
                                                    );
                                                    osym
                                                        .st_info = (((0 as libc::c_int) << 4 as libc::c_int)
                                                        + (4 as libc::c_int & 0xf as libc::c_int)) as libc::c_uchar;
                                                    osym.st_shndx = (0xf as libc::c_uint).wrapping_neg();
                                                    if (*input_bfd).lto_output() != 0 {
                                                        filename = 0 as *const libc::c_char;
                                                    } else {
                                                        filename = lbasename(bfd_get_filename(input_bfd));
                                                    }
                                                    if elf_link_output_symstrtab(
                                                        flinfo as *mut libc::c_void,
                                                        filename,
                                                        &mut osym,
                                                        &mut *_bfd_std_section
                                                            .as_mut_ptr()
                                                            .offset(2 as libc::c_int as isize),
                                                        0 as *mut elf_link_hash_entry,
                                                    ) == 0
                                                    {
                                                        return 0 as libc::c_int != 0;
                                                    }
                                                }
                                                osym = *isym;
                                                osym
                                                    .st_shndx = _bfd_elf_section_from_bfd_section(
                                                    output_bfd,
                                                    (*isec).output_section,
                                                );
                                                if osym.st_shndx == (0x101 as libc::c_uint).wrapping_neg() {
                                                    return 0 as libc::c_int != 0;
                                                }
                                                osym
                                                    .st_value = (osym.st_value as libc::c_ulong)
                                                    .wrapping_add((*isec).output_offset) as bfd_vma as bfd_vma;
                                                if !((*(*flinfo).info).type_0() as libc::c_int
                                                    == type_relocatable as libc::c_int)
                                                {
                                                    osym
                                                        .st_value = (osym.st_value as libc::c_ulong)
                                                        .wrapping_add((*(*isec).output_section).vma) as bfd_vma
                                                        as bfd_vma;
                                                    if osym.st_info as libc::c_int & 0xf as libc::c_int
                                                        == 6 as libc::c_int
                                                    {
                                                        if !((*elf_hash_table((*flinfo).info)).tls_sec).is_null() {
                                                            osym
                                                                .st_value = (osym.st_value as libc::c_ulong)
                                                                .wrapping_sub(
                                                                    (*(*elf_hash_table((*flinfo).info)).tls_sec).vma,
                                                                ) as bfd_vma as bfd_vma;
                                                        } else {
                                                            osym
                                                                .st_info = ((osym.st_info as libc::c_uint
                                                                >> 4 as libc::c_int) << 4 as libc::c_int)
                                                                .wrapping_add(
                                                                    (0 as libc::c_int & 0xf as libc::c_int) as libc::c_uint,
                                                                ) as libc::c_uchar;
                                                        }
                                                    }
                                                }
                                                indx = bfd_get_symcount(output_bfd) as libc::c_long;
                                                ret = elf_link_output_symstrtab(
                                                    flinfo as *mut libc::c_void,
                                                    name,
                                                    &mut osym,
                                                    isec,
                                                    0 as *mut elf_link_hash_entry,
                                                );
                                                if ret == 0 as libc::c_int {
                                                    return 0 as libc::c_int != 0
                                                } else if ret == 1 as libc::c_int {
                                                    *pindex = indx;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
        isym = isym.offset(1);
        isym;
        pindex = pindex.offset(1);
        pindex;
        ppsection = ppsection.offset(1);
        ppsection;
    }
    if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int {
        r_type_mask = 0xff as libc::c_int as bfd_vma;
        r_sym_shift = 8 as libc::c_int;
        address_size = 4 as libc::c_int as bfd_size_type;
    } else {
        r_type_mask = 0xffffffff as libc::c_uint as bfd_vma;
        r_sym_shift = 32 as libc::c_int;
        address_size = 8 as libc::c_int as bfd_size_type;
    }
    sym_hashes = (*(*input_bfd).tdata.elf_obj_data).sym_hashes;
    o = (*input_bfd).sections;
    while !o.is_null() {
        let mut contents: *mut bfd_byte = 0 as *mut bfd_byte;
        if !((*o).linker_mark() == 0) {
            if (*(*flinfo).info).resolve_section_groups() == 0
                && (*o).flags
                    & (0x100000 as libc::c_int | 0x2000000 as libc::c_int)
                        as libc::c_uint == 0x2000000 as libc::c_int as libc::c_uint
            {
                let mut sec_data: *mut bfd_elf_section_data = (*o).used_by_bfd
                    as *mut bfd_elf_section_data;
                let mut symndx: libc::c_ulong = (*sec_data).this_hdr.sh_info
                    as libc::c_ulong;
                let mut osec: *mut asection = (*o).output_section;
                if !((*(*flinfo).info).type_0() as libc::c_int
                    == type_relocatable as libc::c_int)
                {
                    bfd_assert(
                        b"elflink.c\0" as *const u8 as *const libc::c_char,
                        11089 as libc::c_int,
                    );
                }
                if symndx >= locsymcount
                    || (*(*input_bfd).tdata.elf_obj_data).bad_symtab() as libc::c_int
                        != 0 && (*((*flinfo).sections).offset(symndx as isize)).is_null()
                {
                    let mut h: *mut elf_link_hash_entry = *sym_hashes
                        .offset(symndx.wrapping_sub(extsymoff) as isize);
                    while ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_indirect as libc::c_int
                        || ((*h).root).type_0() as libc::c_int
                            == bfd_link_hash_warning as libc::c_int
                    {
                        h = (*h).root.u.i.link as *mut elf_link_hash_entry;
                    }
                    (*h).indx = -(2 as libc::c_int) as libc::c_long;
                    (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
                        .this_hdr
                        .sh_info = -(2 as libc::c_int) as libc::c_uint;
                } else if (*isymbuf.offset(symndx as isize)).st_info as libc::c_int
                    & 0xf as libc::c_int == 3 as libc::c_int
                {
                    let mut sec: *mut asection = (**((*flinfo).sections)
                        .offset(symndx as isize))
                        .output_section;
                    (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
                        .this_hdr
                        .sh_info = (*sec).target_index as libc::c_uint;
                } else {
                    if *((*flinfo).indices).offset(symndx as isize)
                        == -(1 as libc::c_int) as libc::c_long
                    {
                        let mut sym: Elf_Internal_Sym = *isymbuf.offset(symndx as isize);
                        let mut sec_0: *mut asection = (**((*flinfo).sections)
                            .offset(symndx as isize))
                            .output_section;
                        let mut name_0: *const libc::c_char = 0 as *const libc::c_char;
                        let mut indx_0: libc::c_long = 0;
                        let mut ret_0: libc::c_int = 0;
                        name_0 = bfd_elf_string_from_elf_section(
                            input_bfd,
                            (*symtab_hdr).sh_link,
                            sym.st_name as libc::c_uint,
                        );
                        if name_0.is_null() {
                            return 0 as libc::c_int != 0;
                        }
                        sym
                            .st_shndx = _bfd_elf_section_from_bfd_section(
                            output_bfd,
                            sec_0,
                        );
                        if sym.st_shndx == (0x101 as libc::c_uint).wrapping_neg() {
                            return 0 as libc::c_int != 0;
                        }
                        sym
                            .st_value = (sym.st_value as libc::c_ulong)
                            .wrapping_add((*o).output_offset) as bfd_vma as bfd_vma;
                        indx_0 = bfd_get_symcount(output_bfd) as libc::c_long;
                        ret_0 = elf_link_output_symstrtab(
                            flinfo as *mut libc::c_void,
                            name_0,
                            &mut sym,
                            o,
                            0 as *mut elf_link_hash_entry,
                        );
                        if ret_0 == 0 as libc::c_int {
                            return 0 as libc::c_int != 0
                        } else if ret_0 == 1 as libc::c_int {
                            *((*flinfo).indices).offset(symndx as isize) = indx_0;
                        } else {
                            _bfd_abort(
                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                11140 as libc::c_int,
                                (*::core::mem::transmute::<
                                    &[u8; 62],
                                    &[libc::c_char; 62],
                                >(
                                    b"_Bool elf_link_input_bfd(struct elf_final_link_info *, bfd *)\0",
                                ))
                                    .as_ptr(),
                            );
                        }
                    }
                    (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
                        .this_hdr
                        .sh_info = *((*flinfo).indices).offset(symndx as isize)
                        as libc::c_uint;
                }
            }
            if !((*o).flags & 0x100 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
                || (*o).size == 0 as libc::c_int as libc::c_ulong
                    && (*o).flags & 0x4 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint)
            {
                if !((*o).flags & 0x100000 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint)
                {
                    if !((*((*o).used_by_bfd as *mut bfd_elf_section_data))
                        .this_hdr
                        .contents)
                        .is_null()
                    {
                        contents = (*((*o).used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .contents;
                        if (*bed).caches_rawsize() as libc::c_int != 0
                            && (*o).rawsize != 0 as libc::c_int as libc::c_ulong
                            && (*o).rawsize < (*o).size
                        {
                            memcpy(
                                (*flinfo).contents as *mut libc::c_void,
                                contents as *const libc::c_void,
                                (*o).rawsize,
                            );
                            contents = (*flinfo).contents;
                        }
                    } else {
                        contents = (*flinfo).contents;
                        if !bfd_get_full_section_contents(input_bfd, o, &mut contents) {
                            return 0 as libc::c_int != 0;
                        }
                    }
                    if (*o).flags & 0x4 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        let mut internal_relocs: *mut Elf_Internal_Rela = 0
                            as *mut Elf_Internal_Rela;
                        let mut rel: *mut Elf_Internal_Rela = 0
                            as *mut Elf_Internal_Rela;
                        let mut relend: *mut Elf_Internal_Rela = 0
                            as *mut Elf_Internal_Rela;
                        let mut action_discarded: libc::c_int = 0;
                        let mut ret_1: libc::c_int = 0;
                        internal_relocs = _bfd_elf_link_read_relocs(
                            input_bfd,
                            o,
                            (*flinfo).external_relocs,
                            (*flinfo).internal_relocs,
                            0 as libc::c_int != 0,
                        );
                        if internal_relocs.is_null()
                            && (*o).reloc_count > 0 as libc::c_int as libc::c_uint
                        {
                            return 0 as libc::c_int != 0;
                        }
                        if (*o).size > address_size
                            && (startswith(
                                (*o).name,
                                b".ctors\0" as *const u8 as *const libc::c_char,
                            ) as libc::c_int != 0
                                && strcmp(
                                    (*(*o).output_section).name,
                                    b".init_array\0" as *const u8 as *const libc::c_char,
                                ) == 0 as libc::c_int
                                || startswith(
                                    (*o).name,
                                    b".dtors\0" as *const u8 as *const libc::c_char,
                                ) as libc::c_int != 0
                                    && strcmp(
                                        (*(*o).output_section).name,
                                        b".fini_array\0" as *const u8 as *const libc::c_char,
                                    ) == 0 as libc::c_int)
                            && (*((*o).name).offset(6 as libc::c_int as isize)
                                as libc::c_int == 0 as libc::c_int
                                || *((*o).name).offset(6 as libc::c_int as isize)
                                    as libc::c_int == '.' as i32)
                        {
                            if ((*o).size)
                                .wrapping_mul(
                                    (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                )
                                != ((*o).reloc_count as libc::c_ulong)
                                    .wrapping_mul(address_size)
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"error: %pB: size of section %pA is not multiple of address size\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    input_bfd,
                                    o,
                                );
                                bfd_set_error(bfd_error_bad_value);
                                return 0 as libc::c_int != 0;
                            }
                            (*o).flags |= 0x4000000 as libc::c_int as libc::c_uint;
                        }
                        action_discarded = -(1 as libc::c_int);
                        if !elf_section_ignore_discarded_relocs(o) {
                            action_discarded = (Some(
                                ((*bed).action_discarded)
                                    .expect("non-null function pointer"),
                            ))
                                .expect("non-null function pointer")(o) as libc::c_int;
                        }
                        rel = internal_relocs;
                        relend = rel.offset((*o).reloc_count as isize);
                        while rel < relend {
                            let mut r_symndx: libc::c_ulong = (*rel).r_info
                                >> r_sym_shift;
                            let mut s_type: libc::c_uint = 0;
                            let mut ps: *mut *mut asection = 0 as *mut *mut asection;
                            let mut sec_1: *mut asection = 0 as *mut asection;
                            let mut h_0: *mut elf_link_hash_entry = 0
                                as *mut elf_link_hash_entry;
                            let mut sym_name: *const libc::c_char = 0
                                as *const libc::c_char;
                            if !(r_symndx == 0 as libc::c_int as libc::c_ulong) {
                                if r_symndx >= locsymcount
                                    || (*(*input_bfd).tdata.elf_obj_data).bad_symtab()
                                        as libc::c_int != 0
                                        && (*((*flinfo).sections).offset(r_symndx as isize))
                                            .is_null()
                                {
                                    h_0 = *sym_hashes
                                        .offset(r_symndx.wrapping_sub(extsymoff) as isize);
                                    if h_0.is_null() {
                                        _bfd_error_handler(
                                            dcgettext(
                                                b"bfd\0" as *const u8 as *const libc::c_char,
                                                b"error: %pB contains a reloc (%#lx) for section %pA that references a non-existent global symbol\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            input_bfd,
                                            (*rel).r_info,
                                            o,
                                        );
                                        bfd_set_error(bfd_error_bad_value);
                                        return 0 as libc::c_int != 0;
                                    }
                                    while ((*h_0).root).type_0() as libc::c_int
                                        == bfd_link_hash_indirect as libc::c_int
                                        || ((*h_0).root).type_0() as libc::c_int
                                            == bfd_link_hash_warning as libc::c_int
                                    {
                                        h_0 = (*h_0).root.u.i.link as *mut elf_link_hash_entry;
                                    }
                                    s_type = (*h_0).type_0();
                                    if (((*h_0).root).non_ir_ref_regular() as libc::c_int != 0
                                        || ((*h_0).root).non_ir_ref_dynamic() as libc::c_int != 0)
                                        && (((*h_0).root).type_0() as libc::c_int
                                            == bfd_link_hash_defined as libc::c_int
                                            || ((*h_0).root).type_0() as libc::c_int
                                                == bfd_link_hash_defweak as libc::c_int)
                                        && (*(*h_0).root.u.def.section).flags
                                            & 0x100000 as libc::c_int as libc::c_uint
                                            == 0 as libc::c_int as libc::c_uint
                                        && !((*(*h_0).root.u.def.section).owner).is_null()
                                        && (*(*(*h_0).root.u.def.section).owner).flags
                                            & 0x10000 as libc::c_int as libc::c_uint
                                            != 0 as libc::c_int as libc::c_uint
                                    {
                                        ((*h_0).root).set_type_0(bfd_link_hash_undefined);
                                        (*h_0)
                                            .root
                                            .u
                                            .undef
                                            .abfd = (*(*h_0).root.u.def.section).owner;
                                    }
                                    ps = 0 as *mut *mut asection;
                                    if ((*h_0).root).type_0() as libc::c_int
                                        == bfd_link_hash_defined as libc::c_int
                                        || ((*h_0).root).type_0() as libc::c_int
                                            == bfd_link_hash_defweak as libc::c_int
                                    {
                                        ps = &mut (*h_0).root.u.def.section;
                                    }
                                    sym_name = (*h_0).root.root.string;
                                } else {
                                    let mut sym_0: *mut Elf_Internal_Sym = isymbuf
                                        .offset(r_symndx as isize);
                                    s_type = ((*sym_0).st_info as libc::c_int
                                        & 0xf as libc::c_int) as libc::c_uint;
                                    ps = &mut *((*flinfo).sections).offset(r_symndx as isize)
                                        as *mut *mut asection;
                                    sym_name = bfd_elf_sym_name(
                                        input_bfd,
                                        symtab_hdr,
                                        sym_0,
                                        *ps,
                                    );
                                }
                                if (s_type == 8 as libc::c_int as libc::c_uint
                                    || s_type == 9 as libc::c_int as libc::c_uint)
                                    && !((*(*flinfo).info).type_0() as libc::c_int
                                        == type_relocatable as libc::c_int)
                                {
                                    let mut val: bfd_vma = 0;
                                    let mut dot: bfd_vma = ((*rel).r_offset)
                                        .wrapping_add((*o).output_offset)
                                        .wrapping_add((*(*o).output_section).vma);
                                    if !eval_symbol(
                                        &mut val,
                                        &mut sym_name,
                                        input_bfd,
                                        flinfo,
                                        dot,
                                        isymbuf,
                                        locsymcount,
                                        (s_type == 9 as libc::c_int as libc::c_uint) as libc::c_int,
                                    ) {
                                        return 0 as libc::c_int != 0;
                                    }
                                    set_symbol_value(
                                        input_bfd,
                                        isymbuf,
                                        locsymcount,
                                        r_symndx,
                                        val,
                                    );
                                } else if action_discarded != -(1 as libc::c_int)
                                    && !ps.is_null()
                                {
                                    sec_1 = *ps;
                                    if !sec_1.is_null()
                                        && discarded_section(sec_1) as libc::c_int != 0
                                    {
                                        if !(r_symndx != 0 as libc::c_int as libc::c_ulong) {
                                            bfd_assert(
                                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                11338 as libc::c_int,
                                            );
                                        }
                                        if action_discarded & COMPLAIN as libc::c_int != 0 {
                                            (Some(
                                                ((*(*(*flinfo).info).callbacks).einfo)
                                                    .expect("non-null function pointer"),
                                            ))
                                                .expect(
                                                    "non-null function pointer",
                                                )(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%X`%s' referenced in section `%pA' of %pB: defined in discarded section `%pA' of %pB\n\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                sym_name,
                                                o,
                                                input_bfd,
                                                sec_1,
                                                (*sec_1).owner,
                                            );
                                        }
                                        if action_discarded & PRETEND as libc::c_int != 0 {
                                            let mut kept: *mut asection = 0 as *mut asection;
                                            kept = _bfd_elf_check_kept_section(sec_1, (*flinfo).info);
                                            if !kept.is_null() {
                                                *ps = kept;
                                            }
                                        }
                                    }
                                }
                            }
                            rel = rel.offset(1);
                            rel;
                        }
                        ret_1 = (Some(
                            relocate_section.expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            output_bfd,
                            (*flinfo).info,
                            input_bfd,
                            o,
                            contents,
                            internal_relocs,
                            isymbuf,
                            (*flinfo).sections,
                        );
                        if ret_1 == 0 {
                            return 0 as libc::c_int != 0;
                        }
                        if ret_1 == 2 as libc::c_int
                            || (*(*flinfo).info).type_0() as libc::c_int
                                == type_relocatable as libc::c_int
                            || (*(*flinfo).info).emitrelocations() as libc::c_int != 0
                        {
                            let mut irela: *mut Elf_Internal_Rela = 0
                                as *mut Elf_Internal_Rela;
                            let mut irelaend: *mut Elf_Internal_Rela = 0
                                as *mut Elf_Internal_Rela;
                            let mut irelamid: *mut Elf_Internal_Rela = 0
                                as *mut Elf_Internal_Rela;
                            let mut last_offset: bfd_vma = 0;
                            let mut rel_hash: *mut *mut elf_link_hash_entry = 0
                                as *mut *mut elf_link_hash_entry;
                            let mut rel_hash_list: *mut *mut elf_link_hash_entry = 0
                                as *mut *mut elf_link_hash_entry;
                            let mut rela_hash_list: *mut *mut elf_link_hash_entry = 0
                                as *mut *mut elf_link_hash_entry;
                            let mut input_rel_hdr: *mut Elf_Internal_Shdr = 0
                                as *mut Elf_Internal_Shdr;
                            let mut input_rela_hdr: *mut Elf_Internal_Shdr = 0
                                as *mut Elf_Internal_Shdr;
                            let mut next_erel: libc::c_uint = 0;
                            let mut rela_normal: bool = false;
                            let mut esdi: *mut bfd_elf_section_data = 0
                                as *mut bfd_elf_section_data;
                            let mut esdo: *mut bfd_elf_section_data = 0
                                as *mut bfd_elf_section_data;
                            esdi = (*o).used_by_bfd as *mut bfd_elf_section_data;
                            esdo = (*(*o).output_section).used_by_bfd
                                as *mut bfd_elf_section_data;
                            rela_normal = 0 as libc::c_int != 0;
                            irela = internal_relocs;
                            irelaend = irela.offset((*o).reloc_count as isize);
                            rel_hash = ((*esdo).rel.hashes)
                                .offset((*esdo).rel.count as isize);
                            irelamid = irela;
                            if !((*esdi).rel.hdr).is_null() {
                                irelamid = irelamid
                                    .offset(
                                        (if (*(*esdi).rel.hdr).sh_entsize
                                            > 0 as libc::c_int as libc::c_ulong
                                        {
                                            ((*(*esdi).rel.hdr).sh_size)
                                                .wrapping_div((*(*esdi).rel.hdr).sh_entsize)
                                        } else {
                                            0 as libc::c_int as libc::c_ulong
                                        })
                                            .wrapping_mul(
                                                (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                            ) as isize,
                                    );
                            }
                            rel_hash_list = rel_hash;
                            rela_hash_list = 0 as *mut *mut elf_link_hash_entry;
                            last_offset = (*o).output_offset;
                            if !((*(*flinfo).info).type_0() as libc::c_int
                                == type_relocatable as libc::c_int)
                            {
                                last_offset = (last_offset as libc::c_ulong)
                                    .wrapping_add((*(*o).output_section).vma) as bfd_vma
                                    as bfd_vma;
                            }
                            next_erel = 0 as libc::c_int as libc::c_uint;
                            while irela < irelaend {
                                let mut r_symndx_0: libc::c_ulong = 0;
                                let mut sec_2: *mut asection = 0 as *mut asection;
                                let mut sym_1: Elf_Internal_Sym = Elf_Internal_Sym {
                                    st_value: 0,
                                    st_size: 0,
                                    st_name: 0,
                                    st_info: 0,
                                    st_other: 0,
                                    st_target_internal: 0,
                                    st_shndx: 0,
                                };
                                if next_erel
                                    == (*(*bed).s).int_rels_per_ext_rel as libc::c_uint
                                {
                                    rel_hash = rel_hash.offset(1);
                                    rel_hash;
                                    next_erel = 0 as libc::c_int as libc::c_uint;
                                }
                                if irela == irelamid {
                                    rel_hash = ((*esdo).rela.hashes)
                                        .offset((*esdo).rela.count as isize);
                                    rela_hash_list = rel_hash;
                                    rela_normal = (*bed).rela_normal() != 0;
                                }
                                (*irela)
                                    .r_offset = _bfd_elf_section_offset(
                                    output_bfd,
                                    (*flinfo).info,
                                    o,
                                    (*irela).r_offset,
                                );
                                if (*irela).r_offset >= -(2 as libc::c_int) as bfd_vma {
                                    (*irela).r_offset = last_offset;
                                    (*irela).r_info = 0 as libc::c_int as bfd_vma;
                                    (*irela).r_addend = 0 as libc::c_int as bfd_vma;
                                } else {
                                    (*irela)
                                        .r_offset = ((*irela).r_offset as libc::c_ulong)
                                        .wrapping_add((*o).output_offset) as bfd_vma as bfd_vma;
                                    if !((*(*flinfo).info).type_0() as libc::c_int
                                        == type_relocatable as libc::c_int)
                                    {
                                        (*irela)
                                            .r_offset = ((*irela).r_offset as libc::c_ulong)
                                            .wrapping_add((*(*o).output_section).vma) as bfd_vma
                                            as bfd_vma;
                                    }
                                    last_offset = (*irela).r_offset;
                                    r_symndx_0 = (*irela).r_info >> r_sym_shift;
                                    if !(r_symndx_0 == 0 as libc::c_int as libc::c_ulong) {
                                        if r_symndx_0 >= locsymcount
                                            || (*(*input_bfd).tdata.elf_obj_data).bad_symtab()
                                                as libc::c_int != 0
                                                && (*((*flinfo).sections).offset(r_symndx_0 as isize))
                                                    .is_null()
                                        {
                                            let mut rh: *mut elf_link_hash_entry = 0
                                                as *mut elf_link_hash_entry;
                                            let mut indx_1: libc::c_ulong = 0;
                                            indx_1 = r_symndx_0.wrapping_sub(extsymoff);
                                            rh = *((*(*input_bfd).tdata.elf_obj_data).sym_hashes)
                                                .offset(indx_1 as isize);
                                            while ((*rh).root).type_0() as libc::c_int
                                                == bfd_link_hash_indirect as libc::c_int
                                                || ((*rh).root).type_0() as libc::c_int
                                                    == bfd_link_hash_warning as libc::c_int
                                            {
                                                rh = (*rh).root.u.i.link as *mut elf_link_hash_entry;
                                            }
                                            if !((*rh).indx < 0 as libc::c_int as libc::c_long) {
                                                bfd_assert(
                                                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                    11500 as libc::c_int,
                                                );
                                            }
                                            (*rh).indx = -(2 as libc::c_int) as libc::c_long;
                                            *rel_hash = rh;
                                        } else {
                                            *rel_hash = 0 as *mut elf_link_hash_entry;
                                            sym_1 = *isymbuf.offset(r_symndx_0 as isize);
                                            sec_2 = *((*flinfo).sections).offset(r_symndx_0 as isize);
                                            if sym_1.st_info as libc::c_int & 0xf as libc::c_int
                                                == 3 as libc::c_int
                                            {
                                                r_symndx_0 = 0 as libc::c_int as libc::c_ulong;
                                                if !bfd_is_abs_section(sec_2) {
                                                    if sec_2.is_null() || ((*sec_2).owner).is_null() {
                                                        bfd_set_error(bfd_error_bad_value);
                                                        return 0 as libc::c_int != 0;
                                                    } else {
                                                        let mut osec_0: *mut asection = (*sec_2).output_section;
                                                        if bfd_is_abs_section(osec_0) as libc::c_int != 0
                                                            && !((*sec_2).kept_section).is_null()
                                                            && !((*(*sec_2).kept_section).output_section).is_null()
                                                        {
                                                            osec_0 = (*(*sec_2).kept_section).output_section;
                                                            (*irela)
                                                                .r_addend = ((*irela).r_addend as libc::c_ulong)
                                                                .wrapping_sub((*osec_0).vma) as bfd_vma as bfd_vma;
                                                        }
                                                        if !bfd_is_abs_section(osec_0) {
                                                            r_symndx_0 = (*osec_0).target_index as libc::c_ulong;
                                                            if r_symndx_0 == 0 as libc::c_int as libc::c_ulong {
                                                                (*irela)
                                                                    .r_addend = ((*irela).r_addend as libc::c_ulong)
                                                                    .wrapping_add((*osec_0).vma) as bfd_vma as bfd_vma;
                                                                osec_0 = _bfd_nearby_section(
                                                                    output_bfd,
                                                                    osec_0,
                                                                    (*osec_0).vma,
                                                                );
                                                                (*irela)
                                                                    .r_addend = ((*irela).r_addend as libc::c_ulong)
                                                                    .wrapping_sub((*osec_0).vma) as bfd_vma as bfd_vma;
                                                                r_symndx_0 = (*osec_0).target_index as libc::c_ulong;
                                                            }
                                                        }
                                                    }
                                                }
                                                if rela_normal {
                                                    (*irela)
                                                        .r_addend = ((*irela).r_addend as libc::c_ulong)
                                                        .wrapping_add((*sec_2).output_offset) as bfd_vma as bfd_vma;
                                                }
                                            } else {
                                                if *((*flinfo).indices).offset(r_symndx_0 as isize)
                                                    == -(1 as libc::c_int) as libc::c_long
                                                {
                                                    let mut shlink: libc::c_ulong = 0;
                                                    let mut name_1: *const libc::c_char = 0
                                                        as *const libc::c_char;
                                                    let mut osec_1: *mut asection = 0 as *mut asection;
                                                    let mut indx_2: libc::c_long = 0;
                                                    if (*(*flinfo).info).strip() as libc::c_int
                                                        == strip_all as libc::c_int
                                                    {
                                                        bfd_set_error(bfd_error_invalid_operation);
                                                        return 0 as libc::c_int != 0;
                                                    }
                                                    shlink = (*symtab_hdr).sh_link as libc::c_ulong;
                                                    name_1 = bfd_elf_string_from_elf_section(
                                                        input_bfd,
                                                        shlink as libc::c_uint,
                                                        sym_1.st_name as libc::c_uint,
                                                    );
                                                    if name_1.is_null() {
                                                        return 0 as libc::c_int != 0;
                                                    }
                                                    osec_1 = (*sec_2).output_section;
                                                    sym_1
                                                        .st_shndx = _bfd_elf_section_from_bfd_section(
                                                        output_bfd,
                                                        osec_1,
                                                    );
                                                    if sym_1.st_shndx == (0x101 as libc::c_uint).wrapping_neg()
                                                    {
                                                        return 0 as libc::c_int != 0;
                                                    }
                                                    sym_1
                                                        .st_value = (sym_1.st_value as libc::c_ulong)
                                                        .wrapping_add((*sec_2).output_offset) as bfd_vma as bfd_vma;
                                                    if !((*(*flinfo).info).type_0() as libc::c_int
                                                        == type_relocatable as libc::c_int)
                                                    {
                                                        sym_1
                                                            .st_value = (sym_1.st_value as libc::c_ulong)
                                                            .wrapping_add((*osec_1).vma) as bfd_vma as bfd_vma;
                                                        if sym_1.st_info as libc::c_int & 0xf as libc::c_int
                                                            == 6 as libc::c_int
                                                        {
                                                            let mut htab: *mut elf_link_hash_table = elf_hash_table(
                                                                (*flinfo).info,
                                                            );
                                                            if !((*htab).tls_sec).is_null() {
                                                                sym_1
                                                                    .st_value = (sym_1.st_value as libc::c_ulong)
                                                                    .wrapping_sub((*(*htab).tls_sec).vma) as bfd_vma as bfd_vma;
                                                            } else {
                                                                sym_1
                                                                    .st_info = ((sym_1.st_info as libc::c_uint
                                                                    >> 4 as libc::c_int) << 4 as libc::c_int)
                                                                    .wrapping_add(
                                                                        (0 as libc::c_int & 0xf as libc::c_int) as libc::c_uint,
                                                                    ) as libc::c_uchar;
                                                            }
                                                        }
                                                    }
                                                    indx_2 = bfd_get_symcount(output_bfd) as libc::c_long;
                                                    ret_1 = elf_link_output_symstrtab(
                                                        flinfo as *mut libc::c_void,
                                                        name_1,
                                                        &mut sym_1,
                                                        sec_2,
                                                        0 as *mut elf_link_hash_entry,
                                                    );
                                                    if ret_1 == 0 as libc::c_int {
                                                        return 0 as libc::c_int != 0
                                                    } else if ret_1 == 1 as libc::c_int {
                                                        *((*flinfo).indices).offset(r_symndx_0 as isize) = indx_2;
                                                    } else {
                                                        _bfd_abort(
                                                            b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                            11623 as libc::c_int,
                                                            (*::core::mem::transmute::<
                                                                &[u8; 62],
                                                                &[libc::c_char; 62],
                                                            >(
                                                                b"_Bool elf_link_input_bfd(struct elf_final_link_info *, bfd *)\0",
                                                            ))
                                                                .as_ptr(),
                                                        );
                                                    }
                                                }
                                                r_symndx_0 = *((*flinfo).indices)
                                                    .offset(r_symndx_0 as isize) as libc::c_ulong;
                                            }
                                            (*irela)
                                                .r_info = r_symndx_0 << r_sym_shift
                                                | (*irela).r_info & r_type_mask;
                                        }
                                    }
                                }
                                irela = irela.offset(1);
                                irela;
                                next_erel = next_erel.wrapping_add(1);
                                next_erel;
                            }
                            input_rel_hdr = (*esdi).rel.hdr;
                            if !input_rel_hdr.is_null()
                                && (*input_rel_hdr).sh_size
                                    != 0 as libc::c_int as libc::c_ulong
                            {
                                if !((*bed).elf_backend_emit_relocs)
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    output_bfd,
                                    o,
                                    input_rel_hdr,
                                    internal_relocs,
                                    rel_hash_list,
                                )
                                {
                                    return 0 as libc::c_int != 0;
                                }
                                internal_relocs = internal_relocs
                                    .offset(
                                        (if (*input_rel_hdr).sh_entsize
                                            > 0 as libc::c_int as libc::c_ulong
                                        {
                                            ((*input_rel_hdr).sh_size)
                                                .wrapping_div((*input_rel_hdr).sh_entsize)
                                        } else {
                                            0 as libc::c_int as libc::c_ulong
                                        })
                                            .wrapping_mul(
                                                (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                            ) as isize,
                                    );
                                rel_hash_list = rel_hash_list
                                    .offset(
                                        (if (*input_rel_hdr).sh_entsize
                                            > 0 as libc::c_int as libc::c_ulong
                                        {
                                            ((*input_rel_hdr).sh_size)
                                                .wrapping_div((*input_rel_hdr).sh_entsize)
                                        } else {
                                            0 as libc::c_int as libc::c_ulong
                                        }) as isize,
                                    );
                            }
                            input_rela_hdr = (*esdi).rela.hdr;
                            if !input_rela_hdr.is_null()
                                && (*input_rela_hdr).sh_size
                                    != 0 as libc::c_int as libc::c_ulong
                            {
                                if !((*bed).elf_backend_emit_relocs)
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    output_bfd,
                                    o,
                                    input_rela_hdr,
                                    internal_relocs,
                                    rela_hash_list,
                                )
                                {
                                    return 0 as libc::c_int != 0;
                                }
                            }
                        }
                    }
                    if !(((*bed).elf_backend_write_section).is_some()
                        && (Some(
                            ((*bed).elf_backend_write_section)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(output_bfd, (*flinfo).info, o, contents) as libc::c_int
                            != 0)
                    {
                        match (*o).sec_info_type() as libc::c_int {
                            1 => {
                                if !_bfd_write_section_stabs(
                                    output_bfd,
                                    &mut (*(elf_hash_table
                                        as unsafe extern "C" fn(
                                            *const bfd_link_info,
                                        ) -> *mut elf_link_hash_table)((*flinfo).info))
                                        .stab_info,
                                    o,
                                    &mut (*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                        .sec_info,
                                    contents,
                                ) {
                                    return 0 as libc::c_int != 0;
                                }
                            }
                            2 => {
                                if !_bfd_write_merged_section(
                                    output_bfd,
                                    o,
                                    (*((*o).used_by_bfd as *mut bfd_elf_section_data)).sec_info,
                                ) {
                                    return 0 as libc::c_int != 0;
                                }
                            }
                            3 => {
                                if !_bfd_elf_write_section_eh_frame(
                                    output_bfd,
                                    (*flinfo).info,
                                    o,
                                    contents,
                                ) {
                                    return 0 as libc::c_int != 0;
                                }
                            }
                            6 => {
                                if !_bfd_elf_write_section_eh_frame_entry(
                                    output_bfd,
                                    (*flinfo).info,
                                    o,
                                    contents,
                                ) {
                                    return 0 as libc::c_int != 0;
                                }
                            }
                            _ => {
                                if (*o).flags & 0x8000 as libc::c_int as libc::c_uint == 0 {
                                    let mut offset: file_ptr = (*o).output_offset as file_ptr;
                                    let mut todo: bfd_size_type = (*o).size;
                                    offset
                                        *= bfd_octets_per_byte(output_bfd, o) as libc::c_long;
                                    if (*o).flags & 0x4000000 as libc::c_int as libc::c_uint
                                        != 0
                                    {
                                        loop {
                                            todo = (todo as libc::c_ulong).wrapping_sub(address_size)
                                                as bfd_size_type as bfd_size_type;
                                            if !bfd_set_section_contents(
                                                output_bfd,
                                                (*o).output_section,
                                                contents.offset(todo as isize) as *const libc::c_void,
                                                offset,
                                                address_size,
                                            ) {
                                                return 0 as libc::c_int != 0;
                                            }
                                            if todo == 0 as libc::c_int as libc::c_ulong {
                                                break;
                                            }
                                            offset = (offset as libc::c_ulong)
                                                .wrapping_add(address_size) as file_ptr as file_ptr;
                                        }
                                    } else if !bfd_set_section_contents(
                                        output_bfd,
                                        (*o).output_section,
                                        contents as *const libc::c_void,
                                        offset,
                                        todo,
                                    ) {
                                        return 0 as libc::c_int != 0
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        o = (*o).next;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_reloc_link_order(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut output_section: *mut asection,
    mut link_order: *mut bfd_link_order,
) -> bool {
    let mut howto: *const reloc_howto_type = 0 as *const reloc_howto_type;
    let mut indx: libc::c_long = 0;
    let mut offset: bfd_vma = 0;
    let mut addend: bfd_vma = 0;
    let mut reldata: *mut bfd_elf_section_reloc_data = 0
        as *mut bfd_elf_section_reloc_data;
    let mut rel_hash_ptr: *mut *mut elf_link_hash_entry = 0
        as *mut *mut elf_link_hash_entry;
    let mut rel_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut bed: *const elf_backend_data = (*(*output_bfd).xvec).backend_data
        as *const elf_backend_data;
    let mut irel: [Elf_Internal_Rela; 3] = [Elf_Internal_Rela {
        r_offset: 0,
        r_info: 0,
        r_addend: 0,
    }; 3];
    let mut erel: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut i: libc::c_uint = 0;
    let mut esdo: *mut bfd_elf_section_data = (*output_section).used_by_bfd
        as *mut bfd_elf_section_data;
    howto = bfd_reloc_type_lookup(output_bfd, (*(*link_order).u.reloc.p).reloc);
    if howto.is_null() {
        bfd_set_error(bfd_error_bad_value);
        return 0 as libc::c_int != 0;
    }
    addend = (*(*link_order).u.reloc.p).addend;
    if !((*esdo).rel.hdr).is_null() {
        reldata = &mut (*esdo).rel;
    } else if !((*esdo).rela.hdr).is_null() {
        reldata = &mut (*esdo).rela;
    } else {
        reldata = 0 as *mut bfd_elf_section_reloc_data;
        if 0 as libc::c_int == 0 {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                11776 as libc::c_int,
            );
        }
    }
    rel_hash_ptr = ((*reldata).hashes).offset((*reldata).count as isize);
    if (*link_order).type_0 as libc::c_uint
        == bfd_section_reloc_link_order as libc::c_int as libc::c_uint
    {
        indx = (*(*(*link_order).u.reloc.p).u.section).target_index as libc::c_long;
        if !(indx != 0 as libc::c_int as libc::c_long) {
            bfd_assert(
                b"elflink.c\0" as *const u8 as *const libc::c_char,
                11784 as libc::c_int,
            );
        }
        *rel_hash_ptr = 0 as *mut elf_link_hash_entry;
    } else {
        let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
        h = bfd_wrapped_link_hash_lookup(
            output_bfd,
            info,
            (*(*link_order).u.reloc.p).u.name,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
            1 as libc::c_int != 0,
        ) as *mut elf_link_hash_entry;
        if !h.is_null()
            && (((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defined as libc::c_int
                || ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_defweak as libc::c_int)
        {
            let mut section: *mut asection = 0 as *mut asection;
            section = (*h).root.u.def.section;
            indx = (*(*section).output_section).target_index as libc::c_long;
            *rel_hash_ptr = 0 as *mut elf_link_hash_entry;
            addend = (addend as libc::c_ulong)
                .wrapping_add(
                    ((*(*section).output_section).vma)
                        .wrapping_add((*section).output_offset),
                ) as bfd_vma as bfd_vma;
        } else if !h.is_null() {
            (*h).indx = -(2 as libc::c_int) as libc::c_long;
            *rel_hash_ptr = h;
            indx = 0 as libc::c_int as libc::c_long;
        } else {
            (Some(
                ((*(*info).callbacks).unattached_reloc)
                    .expect("non-null function pointer"),
            ))
                .expect(
                    "non-null function pointer",
                )(
                info,
                (*(*link_order).u.reloc.p).u.name,
                0 as *mut bfd,
                0 as *mut asection,
                0 as libc::c_int as bfd_vma,
            );
            indx = 0 as libc::c_int as libc::c_long;
        }
    }
    if (*howto).partial_inplace() as libc::c_int != 0
        && addend != 0 as libc::c_int as libc::c_ulong
    {
        let mut size: bfd_size_type = 0;
        let mut rstat: bfd_reloc_status_type = 0 as bfd_reloc_status_type;
        let mut buf: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut ok: bool = false;
        let mut sym_name: *const libc::c_char = 0 as *const libc::c_char;
        let mut octets: bfd_size_type = 0;
        size = bfd_get_reloc_size(howto) as bfd_size_type;
        buf = bfd_zmalloc(size) as *mut bfd_byte;
        if buf.is_null() && size != 0 as libc::c_int as libc::c_ulong {
            return 0 as libc::c_int != 0;
        }
        rstat = _bfd_relocate_contents(howto, output_bfd, addend, buf);
        match rstat as libc::c_uint {
            2 => {}
            3 => {
                if (*link_order).type_0 as libc::c_uint
                    == bfd_section_reloc_link_order as libc::c_int as libc::c_uint
                {
                    sym_name = bfd_section_name((*(*link_order).u.reloc.p).u.section);
                } else {
                    sym_name = (*(*link_order).u.reloc.p).u.name;
                }
                (Some(
                    ((*(*info).callbacks).reloc_overflow)
                        .expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    info,
                    0 as *mut bfd_link_hash_entry,
                    sym_name,
                    (*howto).name,
                    addend,
                    0 as *mut bfd,
                    0 as *mut asection,
                    0 as libc::c_int as bfd_vma,
                );
            }
            4 | _ => {
                _bfd_abort(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    11850 as libc::c_int,
                    (*::core::mem::transmute::<
                        &[u8; 95],
                        &[libc::c_char; 95],
                    >(
                        b"_Bool elf_reloc_link_order(bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *)\0",
                    ))
                        .as_ptr(),
                );
            }
        }
        octets = ((*link_order).offset)
            .wrapping_mul(
                bfd_octets_per_byte(output_bfd, output_section) as libc::c_ulong,
            );
        ok = bfd_set_section_contents(
            output_bfd,
            output_section,
            buf as *const libc::c_void,
            octets as file_ptr,
            size,
        );
        free(buf as *mut libc::c_void);
        if !ok {
            return 0 as libc::c_int != 0;
        }
    }
    offset = (*link_order).offset;
    if !((*info).type_0() as libc::c_int == type_relocatable as libc::c_int) {
        offset = (offset as libc::c_ulong).wrapping_add((*output_section).vma) as bfd_vma
            as bfd_vma;
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*(*bed).s).int_rels_per_ext_rel as libc::c_uint {
        irel[i as usize].r_offset = offset;
        irel[i as usize].r_info = 0 as libc::c_int as bfd_vma;
        irel[i as usize].r_addend = 0 as libc::c_int as bfd_vma;
        i = i.wrapping_add(1);
        i;
    }
    if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int {
        irel[0 as libc::c_int as usize]
            .r_info = ((indx as libc::c_uint) << 8 as libc::c_int)
            .wrapping_add((*howto).type_0 & 0xff as libc::c_int as libc::c_uint)
            as bfd_vma;
    } else {
        irel[0 as libc::c_int as usize]
            .r_info = (((indx as bfd_vma) << 31 as libc::c_int) << 1 as libc::c_int)
            .wrapping_add((*howto).type_0 as bfd_vma);
    }
    rel_hdr = (*reldata).hdr;
    erel = (*rel_hdr).contents;
    if (*rel_hdr).sh_type == 9 as libc::c_int as libc::c_uint {
        erel = erel
            .offset(
                ((*reldata).count).wrapping_mul((*(*bed).s).sizeof_rel as libc::c_uint)
                    as isize,
            );
        (Some(((*(*bed).s).swap_reloc_out).expect("non-null function pointer")))
            .expect("non-null function pointer")(output_bfd, irel.as_mut_ptr(), erel);
    } else {
        irel[0 as libc::c_int as usize].r_addend = addend;
        erel = erel
            .offset(
                ((*reldata).count).wrapping_mul((*(*bed).s).sizeof_rela as libc::c_uint)
                    as isize,
            );
        (Some(((*(*bed).s).swap_reloca_out).expect("non-null function pointer")))
            .expect("non-null function pointer")(output_bfd, irel.as_mut_ptr(), erel);
    }
    (*reldata).count = ((*reldata).count).wrapping_add(1);
    (*reldata).count;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_output_implib(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut ret: bool = 0 as libc::c_int != 0;
    let mut implib_bfd: *mut bfd = 0 as *mut bfd;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut flags: flagword = 0;
    let mut arch: bfd_architecture = bfd_arch_unknown;
    let mut mach: libc::c_uint = 0;
    let mut sympp: *mut *mut asymbol = 0 as *mut *mut asymbol;
    let mut symsize: libc::c_long = 0;
    let mut symcount: libc::c_long = 0;
    let mut src_count: libc::c_long = 0;
    let mut osymbuf: *mut elf_symbol_type = 0 as *mut elf_symbol_type;
    let mut amt: size_t = 0;
    implib_bfd = (*info).out_implib_bfd;
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if !bfd_set_format(implib_bfd, bfd_object) {
        return 0 as libc::c_int != 0;
    }
    flags = bfd_get_file_flags(abfd);
    flags &= !(0x1 as libc::c_int) as libc::c_uint;
    if !bfd_set_start_address(implib_bfd, 0 as libc::c_int as bfd_vma)
        || !bfd_set_file_flags(implib_bfd, flags & !(0x2 as libc::c_int) as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    arch = bfd_get_arch(abfd);
    mach = bfd_get_mach(abfd) as libc::c_uint;
    if !(Some(
        ((*(*implib_bfd).xvec)._bfd_set_arch_mach).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(implib_bfd, arch, mach as libc::c_ulong)
        && ((*abfd).target_defaulted() as libc::c_int != 0
            || bfd_get_arch(abfd) as libc::c_uint
                != bfd_get_arch(implib_bfd) as libc::c_uint)
    {
        return 0 as libc::c_int != 0;
    }
    symsize = (Some(
        ((*(*abfd).xvec)._bfd_get_symtab_upper_bound).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(abfd);
    if symsize < 0 as libc::c_int as libc::c_long {
        return 0 as libc::c_int != 0;
    }
    sympp = bfd_malloc(symsize as bfd_size_type) as *mut *mut asymbol;
    if sympp.is_null() {
        return 0 as libc::c_int != 0;
    }
    symcount = (Some(
        ((*(*abfd).xvec)._bfd_canonicalize_symtab).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(abfd, sympp);
    if !(symcount < 0 as libc::c_int as libc::c_long) {
        if (Some(
            ((*(*implib_bfd).xvec)._bfd_copy_private_header_data)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd, implib_bfd)
        {
            if ((*bed).elf_backend_filter_implib_symbols).is_some() {
                symcount = ((*bed).elf_backend_filter_implib_symbols)
                    .expect("non-null function pointer")(abfd, info, sympp, symcount)
                    as libc::c_long;
            } else {
                symcount = _bfd_elf_filter_global_symbols(abfd, info, sympp, symcount)
                    as libc::c_long;
            }
            if symcount == 0 as libc::c_int as libc::c_long {
                bfd_set_error(bfd_error_no_symbols);
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB: no symbol found for import library\0" as *const u8
                            as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    implib_bfd,
                );
            } else {
                amt = (symcount as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<elf_symbol_type>() as libc::c_ulong,
                    );
                osymbuf = bfd_alloc(implib_bfd, amt) as *mut elf_symbol_type;
                if !osymbuf.is_null() {
                    src_count = 0 as libc::c_int as libc::c_long;
                    while src_count < symcount {
                        memcpy(
                            &mut *osymbuf.offset(src_count as isize)
                                as *mut elf_symbol_type as *mut libc::c_void,
                            *sympp.offset(src_count as isize) as *mut elf_symbol_type
                                as *const libc::c_void,
                            ::core::mem::size_of::<elf_symbol_type>() as libc::c_ulong,
                        );
                        let ref mut fresh38 = (*osymbuf.offset(src_count as isize))
                            .symbol
                            .section;
                        *fresh38 = &mut *_bfd_std_section
                            .as_mut_ptr()
                            .offset(2 as libc::c_int as isize) as *mut asection;
                        (*osymbuf.offset(src_count as isize))
                            .internal_elf_sym
                            .st_shndx = (0xf as libc::c_uint).wrapping_neg();
                        let ref mut fresh39 = (*osymbuf.offset(src_count as isize))
                            .symbol
                            .value;
                        *fresh39 = (*fresh39 as libc::c_ulong)
                            .wrapping_add(
                                (*(**sympp.offset(src_count as isize)).section).vma,
                            ) as symvalue as symvalue;
                        (*osymbuf.offset(src_count as isize))
                            .internal_elf_sym
                            .st_value = (*osymbuf.offset(src_count as isize))
                            .symbol
                            .value;
                        let ref mut fresh40 = *sympp.offset(src_count as isize);
                        *fresh40 = &mut (*osymbuf.offset(src_count as isize)).symbol;
                        src_count += 1;
                        src_count;
                    }
                    bfd_set_symtab(implib_bfd, sympp, symcount as libc::c_uint);
                    if (Some(
                        ((*(*implib_bfd).xvec)._bfd_copy_private_bfd_data)
                            .expect("non-null function pointer"),
                    ))
                        .expect("non-null function pointer")(abfd, implib_bfd)
                    {
                        if bfd_close(implib_bfd) {
                            ret = 1 as libc::c_int != 0;
                        }
                    }
                }
            }
        }
    }
    free(sympp as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn elf_final_link_free(
    mut obfd: *mut bfd,
    mut flinfo: *mut elf_final_link_info,
) {
    let mut o: *mut asection = 0 as *mut asection;
    if !((*flinfo).symstrtab).is_null() {
        _bfd_elf_strtab_free((*flinfo).symstrtab);
    }
    free((*flinfo).contents as *mut libc::c_void);
    free((*flinfo).external_relocs);
    free((*flinfo).internal_relocs as *mut libc::c_void);
    free((*flinfo).external_syms as *mut libc::c_void);
    free((*flinfo).locsym_shndx as *mut libc::c_void);
    free((*flinfo).internal_syms as *mut libc::c_void);
    free((*flinfo).indices as *mut libc::c_void);
    free((*flinfo).sections as *mut libc::c_void);
    if (*flinfo).symshndxbuf != -(1 as libc::c_int) as *mut Elf_External_Sym_Shndx {
        free((*flinfo).symshndxbuf as *mut libc::c_void);
    }
    o = (*obfd).sections;
    while !o.is_null() {
        let mut esdo: *mut bfd_elf_section_data = (*o).used_by_bfd
            as *mut bfd_elf_section_data;
        free((*esdo).rel.hashes as *mut libc::c_void);
        free((*esdo).rela.hashes as *mut libc::c_void);
        o = (*o).next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_final_link(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut current_block: u64;
    let mut dynamic: bool = false;
    let mut emit_relocs: bool = false;
    let mut dynobj: *mut bfd = 0 as *mut bfd;
    let mut flinfo: elf_final_link_info = elf_final_link_info {
        info: 0 as *mut bfd_link_info,
        output_bfd: 0 as *mut bfd,
        symstrtab: 0 as *mut elf_strtab_hash,
        hash_sec: 0 as *mut asection,
        symver_sec: 0 as *mut asection,
        contents: 0 as *mut bfd_byte,
        external_relocs: 0 as *mut libc::c_void,
        internal_relocs: 0 as *mut Elf_Internal_Rela,
        external_syms: 0 as *mut bfd_byte,
        locsym_shndx: 0 as *mut Elf_External_Sym_Shndx,
        internal_syms: 0 as *mut Elf_Internal_Sym,
        indices: 0 as *mut libc::c_long,
        sections: 0 as *mut *mut asection,
        symshndxbuf: 0 as *mut Elf_External_Sym_Shndx,
        filesym_count: 0,
        local_hash_table: bfd_hash_table {
            table: 0 as *mut *mut bfd_hash_entry,
            newfunc: None,
            memory: 0 as *mut libc::c_void,
            size: 0,
            count: 0,
            entsize: 0,
            frozen: [0; 1],
            c2rust_padding: [0; 3],
        },
    };
    let mut o: *mut asection = 0 as *mut asection;
    let mut p: *mut bfd_link_order = 0 as *mut bfd_link_order;
    let mut sub: *mut bfd = 0 as *mut bfd;
    let mut max_contents_size: bfd_size_type = 0;
    let mut max_external_reloc_size: bfd_size_type = 0;
    let mut max_internal_reloc_count: bfd_size_type = 0;
    let mut max_sym_count: bfd_size_type = 0;
    let mut max_sym_shndx_count: bfd_size_type = 0;
    let mut elfsym: Elf_Internal_Sym = Elf_Internal_Sym {
        st_value: 0,
        st_size: 0,
        st_name: 0,
        st_info: 0,
        st_other: 0,
        st_target_internal: 0,
        st_shndx: 0,
    };
    let mut i: libc::c_uint = 0;
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symtab_shndx_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut eoinfo: elf_outext_info = elf_outext_info {
        failed: false,
        localsyms: false,
        file_sym_done: false,
        flinfo: 0 as *mut elf_final_link_info,
    };
    let mut merged: bool = false;
    let mut relativecount: size_t = 0 as libc::c_int as size_t;
    let mut reldyn: *mut asection = 0 as *mut asection;
    let mut amt: bfd_size_type = 0;
    let mut attr_section: *mut asection = 0 as *mut asection;
    let mut attr_size: bfd_vma = 0 as libc::c_int as bfd_vma;
    let mut std_attrs_section: *const libc::c_char = 0 as *const libc::c_char;
    let mut htab: *mut elf_link_hash_table = elf_hash_table(info);
    let mut sections_removed: bool = false;
    let mut ret: bool = false;
    if !is_elf_hash_table(&mut (*htab).root) {
        return 0 as libc::c_int != 0;
    }
    if (*info).type_0() as libc::c_int == type_dll as libc::c_int
        || (*info).type_0() as libc::c_int == type_pie as libc::c_int
    {
        (*abfd).flags |= 0x40 as libc::c_int as libc::c_uint;
    }
    dynamic = (*htab).dynamic_sections_created;
    dynobj = (*htab).dynobj;
    emit_relocs = (*info).type_0() as libc::c_int == type_relocatable as libc::c_int
        || (*info).emitrelocations() as libc::c_int != 0;
    memset(
        &mut flinfo as *mut elf_final_link_info as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<elf_final_link_info>() as libc::c_ulong,
    );
    flinfo.info = info;
    flinfo.output_bfd = abfd;
    flinfo.symstrtab = _bfd_elf_strtab_init();
    if (flinfo.symstrtab).is_null() {
        return 0 as libc::c_int != 0;
    }
    if !dynamic {
        flinfo.hash_sec = 0 as *mut asection;
        flinfo.symver_sec = 0 as *mut asection;
    } else {
        flinfo
            .hash_sec = bfd_get_linker_section(
            dynobj,
            b".hash\0" as *const u8 as *const libc::c_char,
        );
        flinfo
            .symver_sec = bfd_get_linker_section(
            dynobj,
            b".gnu.version\0" as *const u8 as *const libc::c_char,
        );
    }
    if (*info).unique_symbol() as libc::c_int != 0
        && !bfd_hash_table_init(
            &mut flinfo.local_hash_table,
            Some(
                local_hash_newfunc
                    as unsafe extern "C" fn(
                        *mut bfd_hash_entry,
                        *mut bfd_hash_table,
                        *const libc::c_char,
                    ) -> *mut bfd_hash_entry,
            ),
            ::core::mem::size_of::<local_hash_entry>() as libc::c_ulong as libc::c_uint,
        )
    {
        return 0 as libc::c_int != 0;
    }
    sections_removed = 0 as libc::c_int != 0;
    std_attrs_section = (*((*(*abfd).xvec).backend_data as *const elf_backend_data))
        .obj_attrs_section;
    o = (*abfd).sections;
    while !o.is_null() {
        let mut remove_section: bool = 0 as libc::c_int != 0;
        if !std_attrs_section.is_null()
            && strcmp((*o).name, std_attrs_section) == 0 as libc::c_int
            || strcmp(
                (*o).name,
                b".gnu.attributes\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            p = (*o).map_head.link_order;
            while !p.is_null() {
                let mut input_section: *mut asection = 0 as *mut asection;
                if !((*p).type_0 as libc::c_uint
                    != bfd_indirect_link_order as libc::c_int as libc::c_uint)
                {
                    input_section = (*p).u.indirect.section;
                    (*input_section).flags &= !(0x100 as libc::c_int) as libc::c_uint;
                }
                p = (*p).next;
            }
            attr_size = bfd_elf_obj_attr_size(abfd);
            bfd_set_section_size(o, attr_size);
            (*o).map_head.link_order = 0 as *mut bfd_link_order;
            if attr_size != 0 {
                attr_section = o;
            } else {
                remove_section = 1 as libc::c_int != 0;
            }
        } else if (*o).flags & 0x2000000 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
            && (*o).size == 0 as libc::c_int as libc::c_ulong
        {
            remove_section = 1 as libc::c_int != 0;
        }
        if remove_section {
            (*o).flags |= 0x8000 as libc::c_int as libc::c_uint;
            bfd_section_list_remove(abfd, o);
            (*abfd).section_count = ((*abfd).section_count).wrapping_sub(1);
            (*abfd).section_count;
            sections_removed = 1 as libc::c_int != 0;
        }
        o = (*o).next;
    }
    if sections_removed {
        _bfd_fix_excluded_sec_syms(abfd, info);
    }
    max_contents_size = 0 as libc::c_int as bfd_size_type;
    max_external_reloc_size = 0 as libc::c_int as bfd_size_type;
    max_internal_reloc_count = 0 as libc::c_int as bfd_size_type;
    max_sym_count = 0 as libc::c_int as bfd_size_type;
    max_sym_shndx_count = 0 as libc::c_int as bfd_size_type;
    merged = 0 as libc::c_int != 0;
    o = (*abfd).sections;
    while !o.is_null() {
        let mut esdo: *mut bfd_elf_section_data = (*o).used_by_bfd
            as *mut bfd_elf_section_data;
        (*o).reloc_count = 0 as libc::c_int as libc::c_uint;
        p = (*o).map_head.link_order;
        while !p.is_null() {
            let mut reloc_count: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            let mut additional_reloc_count: libc::c_uint = 0 as libc::c_int
                as libc::c_uint;
            let mut esdi: *mut bfd_elf_section_data = 0 as *mut bfd_elf_section_data;
            if (*p).type_0 as libc::c_uint
                == bfd_section_reloc_link_order as libc::c_int as libc::c_uint
                || (*p).type_0 as libc::c_uint
                    == bfd_symbol_reloc_link_order as libc::c_int as libc::c_uint
            {
                reloc_count = 1 as libc::c_int as libc::c_uint;
            } else if (*p).type_0 as libc::c_uint
                == bfd_indirect_link_order as libc::c_int as libc::c_uint
            {
                let mut sec: *mut asection = 0 as *mut asection;
                sec = (*p).u.indirect.section;
                (*sec).set_linker_mark(1 as libc::c_int as libc::c_uint);
                if (*sec).flags & 0x800000 as libc::c_int as libc::c_uint != 0 {
                    merged = 1 as libc::c_int != 0;
                }
                if (*sec).rawsize > max_contents_size {
                    max_contents_size = (*sec).rawsize;
                }
                if (*sec).size > max_contents_size {
                    max_contents_size = (*sec).size;
                }
                if bfd_get_flavour((*sec).owner) as libc::c_uint
                    == bfd_target_elf_flavour as libc::c_int as libc::c_uint
                    && (*(*sec).owner).flags & 0x40 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                {
                    let mut sym_count: size_t = 0;
                    if (*(*(*sec).owner).tdata.elf_obj_data).bad_symtab() != 0 {
                        sym_count = ((*(*(*sec).owner).tdata.elf_obj_data)
                            .symtab_hdr
                            .sh_size)
                            .wrapping_div((*(*bed).s).sizeof_sym as libc::c_ulong);
                    } else {
                        sym_count = (*(*(*sec).owner).tdata.elf_obj_data)
                            .symtab_hdr
                            .sh_info as size_t;
                    }
                    if sym_count > max_sym_count {
                        max_sym_count = sym_count;
                    }
                    if sym_count > max_sym_shndx_count
                        && !((*(*(*sec).owner).tdata.elf_obj_data).symtab_shndx_list)
                            .is_null()
                    {
                        max_sym_shndx_count = sym_count;
                    }
                    if !((*esdo).this_hdr.sh_type == 9 as libc::c_int as libc::c_uint
                        || (*esdo).this_hdr.sh_type == 4 as libc::c_int as libc::c_uint)
                    {
                        if emit_relocs {
                            reloc_count = (*sec).reloc_count;
                            if ((*bed).elf_backend_count_additional_relocs).is_some() {
                                let mut c: libc::c_int = 0;
                                c = (Some(
                                    ((*bed).elf_backend_count_additional_relocs)
                                        .expect("non-null function pointer"),
                                ))
                                    .expect("non-null function pointer")(sec) as libc::c_int;
                                additional_reloc_count = additional_reloc_count
                                    .wrapping_add(c as libc::c_uint);
                            }
                        } else if ((*bed).elf_backend_count_relocs).is_some() {
                            reloc_count = (Some(
                                ((*bed).elf_backend_count_relocs)
                                    .expect("non-null function pointer"),
                            ))
                                .expect("non-null function pointer")(info, sec);
                        }
                    }
                    esdi = (*sec).used_by_bfd as *mut bfd_elf_section_data;
                    if (*sec).flags & 0x4 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        let mut ext_size: size_t = 0 as libc::c_int as size_t;
                        if !((*esdi).rel.hdr).is_null() {
                            ext_size = (*(*esdi).rel.hdr).sh_size;
                        }
                        if !((*esdi).rela.hdr).is_null() {
                            ext_size = (ext_size as libc::c_ulong)
                                .wrapping_add((*(*esdi).rela.hdr).sh_size) as size_t
                                as size_t;
                        }
                        if ext_size > max_external_reloc_size {
                            max_external_reloc_size = ext_size;
                        }
                        if (*sec).reloc_count as libc::c_ulong > max_internal_reloc_count
                        {
                            max_internal_reloc_count = (*sec).reloc_count
                                as bfd_size_type;
                        }
                    }
                }
            }
            if !(reloc_count == 0 as libc::c_int as libc::c_uint) {
                reloc_count = reloc_count.wrapping_add(additional_reloc_count);
                (*o).reloc_count = ((*o).reloc_count).wrapping_add(reloc_count);
                if (*p).type_0 as libc::c_uint
                    == bfd_indirect_link_order as libc::c_int as libc::c_uint
                    && emit_relocs as libc::c_int != 0
                {
                    if !((*esdi).rel.hdr).is_null() {
                        (*esdo)
                            .rel
                            .count = ((*esdo).rel.count as libc::c_ulong)
                            .wrapping_add(
                                if (*(*esdi).rel.hdr).sh_entsize
                                    > 0 as libc::c_int as libc::c_ulong
                                {
                                    ((*(*esdi).rel.hdr).sh_size)
                                        .wrapping_div((*(*esdi).rel.hdr).sh_entsize)
                                } else {
                                    0 as libc::c_int as libc::c_ulong
                                },
                            ) as libc::c_uint as libc::c_uint;
                        (*esdo)
                            .rel
                            .count = ((*esdo).rel.count)
                            .wrapping_add(additional_reloc_count);
                    }
                    if !((*esdi).rela.hdr).is_null() {
                        (*esdo)
                            .rela
                            .count = ((*esdo).rela.count as libc::c_ulong)
                            .wrapping_add(
                                if (*(*esdi).rela.hdr).sh_entsize
                                    > 0 as libc::c_int as libc::c_ulong
                                {
                                    ((*(*esdi).rela.hdr).sh_size)
                                        .wrapping_div((*(*esdi).rela.hdr).sh_entsize)
                                } else {
                                    0 as libc::c_int as libc::c_ulong
                                },
                            ) as libc::c_uint as libc::c_uint;
                        (*esdo)
                            .rela
                            .count = ((*esdo).rela.count)
                            .wrapping_add(additional_reloc_count);
                    }
                } else if (*o).use_rela_p() != 0 {
                    (*esdo).rela.count = ((*esdo).rela.count).wrapping_add(reloc_count);
                } else {
                    (*esdo).rel.count = ((*esdo).rel.count).wrapping_add(reloc_count);
                }
            }
            p = (*p).next;
        }
        if (*o).reloc_count > 0 as libc::c_int as libc::c_uint {
            (*o).flags |= 0x4 as libc::c_int as libc::c_uint;
        } else {
            (*o).flags &= !(0x4 as libc::c_int) as libc::c_uint;
        }
        if (*o).flags & 0x1 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint && (*o).user_set_vma() == 0
        {
            (*o).vma = 0 as libc::c_int as bfd_vma;
        }
        o = (*o).next;
    }
    if !((*info).type_0() as libc::c_int == type_relocatable as libc::c_int)
        && merged as libc::c_int != 0
    {
        elf_link_hash_traverse(
            htab,
            Some(
                _bfd_elf_link_sec_merge_syms
                    as unsafe extern "C" fn(
                        *mut elf_link_hash_entry,
                        *mut libc::c_void,
                    ) -> bool,
            ),
            abfd as *mut libc::c_void,
        );
    }
    (*abfd)
        .symcount = ((*info).strip() as libc::c_int != strip_all as libc::c_int
        || emit_relocs as libc::c_int != 0) as libc::c_int as libc::c_uint;
    if (*abfd).output_has_begun() != 0 {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            12320 as libc::c_int,
        );
    }
    if !_bfd_elf_compute_section_file_positions(abfd, info) {
        current_block = 10443503258980814984;
    } else {
        o = (*abfd).sections;
        loop {
            if o.is_null() {
                current_block = 14114759727632161892;
                break;
            }
            let mut esdo_0: *mut bfd_elf_section_data = (*o).used_by_bfd
                as *mut bfd_elf_section_data;
            if (*o).flags & 0x4 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
            {
                if !((*esdo_0).rel.hdr).is_null()
                    && !_bfd_elf_link_size_reloc_section(abfd, &mut (*esdo_0).rel)
                {
                    current_block = 10443503258980814984;
                    break;
                }
                if !((*esdo_0).rela.hdr).is_null()
                    && !_bfd_elf_link_size_reloc_section(abfd, &mut (*esdo_0).rela)
                {
                    current_block = 10443503258980814984;
                    break;
                }
            }
            (*o).target_index = 0 as libc::c_int;
            (*esdo_0).rel.count = 0 as libc::c_int as libc::c_uint;
            (*esdo_0).rela.count = 0 as libc::c_int as libc::c_uint;
            if (*esdo_0).this_hdr.sh_offset == -(1 as libc::c_int) as file_ptr
                && !bfd_section_is_ctf(o)
            {
                let mut contents: *mut libc::c_uchar = (*esdo_0).this_hdr.contents;
                if (*o).flags & 0x8000000 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint || !contents.is_null()
                {
                    _bfd_abort(
                        b"elflink.c\0" as *const u8 as *const libc::c_char,
                        12356 as libc::c_int,
                        (*::core::mem::transmute::<
                            &[u8; 56],
                            &[libc::c_char; 56],
                        >(b"_Bool bfd_elf_final_link(bfd *, struct bfd_link_info *)\0"))
                            .as_ptr(),
                    );
                }
                contents = bfd_malloc((*esdo_0).this_hdr.sh_size) as *mut libc::c_uchar;
                if contents.is_null() {
                    current_block = 10443503258980814984;
                    break;
                }
                (*esdo_0).this_hdr.contents = contents;
            }
            o = (*o).next;
        }
        match current_block {
            10443503258980814984 => {}
            _ => {
                (*abfd).symcount = 0 as libc::c_int as libc::c_uint;
                symtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                (*symtab_hdr).sh_type = 2 as libc::c_int as libc::c_uint;
                (*symtab_hdr).sh_entsize = (*(*bed).s).sizeof_sym as bfd_size_type;
                (*symtab_hdr)
                    .sh_addralign = (1 as libc::c_int as bfd_vma)
                    << (*(*bed).s).log_file_align as libc::c_int;
                if max_sym_count < 20 as libc::c_int as libc::c_ulong {
                    max_sym_count = 20 as libc::c_int as bfd_size_type;
                }
                (*htab).strtabsize = max_sym_count;
                amt = max_sym_count
                    .wrapping_mul(
                        ::core::mem::size_of::<elf_sym_strtab>() as libc::c_ulong,
                    );
                (*htab).strtab = bfd_malloc(amt) as *mut elf_sym_strtab;
                if ((*htab).strtab).is_null() {
                    current_block = 10443503258980814984;
                } else {
                    flinfo
                        .symshndxbuf = if (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        > (0x100 as libc::c_uint).wrapping_neg()
                            & 0xffff as libc::c_int as libc::c_uint
                    {
                        -(1 as libc::c_int) as *mut Elf_External_Sym_Shndx
                    } else {
                        0 as *mut Elf_External_Sym_Shndx
                    };
                    if (*info).strip() as libc::c_int != strip_all as libc::c_int
                        || emit_relocs as libc::c_int != 0
                    {
                        let mut off: file_ptr = (*(*(*abfd).tdata.elf_obj_data).o)
                            .next_file_pos;
                        _bfd_elf_assign_file_position_for_section(
                            symtab_hdr,
                            off,
                            1 as libc::c_int != 0,
                        );
                        elfsym.st_value = 0 as libc::c_int as bfd_vma;
                        elfsym.st_size = 0 as libc::c_int as bfd_vma;
                        elfsym.st_info = 0 as libc::c_int as libc::c_uchar;
                        elfsym.st_other = 0 as libc::c_int as libc::c_uchar;
                        elfsym.st_shndx = 0 as libc::c_int as libc::c_uint;
                        elfsym.st_target_internal = 0 as libc::c_int as libc::c_uchar;
                        if elf_link_output_symstrtab(
                            &mut flinfo as *mut elf_final_link_info as *mut libc::c_void,
                            0 as *const libc::c_char,
                            &mut elfsym,
                            &mut *_bfd_std_section
                                .as_mut_ptr()
                                .offset(1 as libc::c_int as isize),
                            0 as *mut elf_link_hash_entry,
                        ) != 1 as libc::c_int
                        {
                            current_block = 10443503258980814984;
                        } else if bfd_keep_unused_section_symbols(abfd) as libc::c_int
                            != 0 || emit_relocs as libc::c_int != 0
                        {
                            let mut name_local_sections: bool = ((*bed)
                                .elf_backend_name_local_section_symbols)
                                .is_some()
                                && ((*bed).elf_backend_name_local_section_symbols)
                                    .expect("non-null function pointer")(abfd) as libc::c_int
                                    != 0;
                            let mut name: *const libc::c_char = 0 as *const libc::c_char;
                            elfsym.st_size = 0 as libc::c_int as bfd_vma;
                            elfsym
                                .st_info = (((0 as libc::c_int) << 4 as libc::c_int)
                                + (3 as libc::c_int & 0xf as libc::c_int)) as libc::c_uchar;
                            elfsym.st_other = 0 as libc::c_int as libc::c_uchar;
                            elfsym.st_value = 0 as libc::c_int as bfd_vma;
                            elfsym
                                .st_target_internal = 0 as libc::c_int as libc::c_uchar;
                            i = 1 as libc::c_int as libc::c_uint;
                            loop {
                                if !(i < (*(*abfd).tdata.elf_obj_data).num_elf_sections) {
                                    current_block = 6328367678128271922;
                                    break;
                                }
                                o = bfd_section_from_elf_index(abfd, i);
                                if !o.is_null() {
                                    (*o).target_index = bfd_get_symcount(abfd) as libc::c_int;
                                    elfsym.st_shndx = i;
                                    if !((*info).type_0() as libc::c_int
                                        == type_relocatable as libc::c_int)
                                    {
                                        elfsym.st_value = (*o).vma;
                                    }
                                    if name_local_sections {
                                        name = (*o).name;
                                    }
                                    if elf_link_output_symstrtab(
                                        &mut flinfo as *mut elf_final_link_info
                                            as *mut libc::c_void,
                                        name,
                                        &mut elfsym,
                                        o,
                                        0 as *mut elf_link_hash_entry,
                                    ) != 1 as libc::c_int
                                    {
                                        current_block = 10443503258980814984;
                                        break;
                                    }
                                }
                                i = i.wrapping_add(1);
                                i;
                            }
                        } else {
                            current_block = 6328367678128271922;
                        }
                    } else {
                        current_block = 6328367678128271922;
                    }
                    match current_block {
                        10443503258980814984 => {}
                        _ => {
                            if ((*bed).elf_backend_elfsym_local_is_section).is_some()
                                && ((*bed).elf_backend_elfsym_local_is_section)
                                    .expect("non-null function pointer")(abfd) as libc::c_int
                                    != 0
                            {
                                (*symtab_hdr).sh_info = bfd_get_symcount(abfd);
                            }
                            if max_contents_size != 0 as libc::c_int as libc::c_ulong {
                                flinfo
                                    .contents = bfd_malloc(max_contents_size) as *mut bfd_byte;
                                if (flinfo.contents).is_null() {
                                    current_block = 10443503258980814984;
                                } else {
                                    current_block = 9702083122263515018;
                                }
                            } else {
                                current_block = 9702083122263515018;
                            }
                            match current_block {
                                10443503258980814984 => {}
                                _ => {
                                    if max_external_reloc_size
                                        != 0 as libc::c_int as libc::c_ulong
                                    {
                                        flinfo
                                            .external_relocs = bfd_malloc(max_external_reloc_size);
                                        if (flinfo.external_relocs).is_null() {
                                            current_block = 10443503258980814984;
                                        } else {
                                            current_block = 9235179519944561532;
                                        }
                                    } else {
                                        current_block = 9235179519944561532;
                                    }
                                    match current_block {
                                        10443503258980814984 => {}
                                        _ => {
                                            if max_internal_reloc_count
                                                != 0 as libc::c_int as libc::c_ulong
                                            {
                                                amt = max_internal_reloc_count
                                                    .wrapping_mul(
                                                        ::core::mem::size_of::<Elf_Internal_Rela>() as libc::c_ulong,
                                                    );
                                                flinfo
                                                    .internal_relocs = bfd_malloc(amt)
                                                    as *mut Elf_Internal_Rela;
                                                if (flinfo.internal_relocs).is_null() {
                                                    current_block = 10443503258980814984;
                                                } else {
                                                    current_block = 2925215368761540503;
                                                }
                                            } else {
                                                current_block = 2925215368761540503;
                                            }
                                            match current_block {
                                                10443503258980814984 => {}
                                                _ => {
                                                    if max_sym_count != 0 as libc::c_int as libc::c_ulong {
                                                        amt = max_sym_count
                                                            .wrapping_mul((*(*bed).s).sizeof_sym as libc::c_ulong);
                                                        flinfo.external_syms = bfd_malloc(amt) as *mut bfd_byte;
                                                        if (flinfo.external_syms).is_null() {
                                                            current_block = 10443503258980814984;
                                                        } else {
                                                            amt = max_sym_count
                                                                .wrapping_mul(
                                                                    ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
                                                                );
                                                            flinfo
                                                                .internal_syms = bfd_malloc(amt) as *mut Elf_Internal_Sym;
                                                            if (flinfo.internal_syms).is_null() {
                                                                current_block = 10443503258980814984;
                                                            } else {
                                                                amt = max_sym_count
                                                                    .wrapping_mul(
                                                                        ::core::mem::size_of::<libc::c_long>() as libc::c_ulong,
                                                                    );
                                                                flinfo.indices = bfd_malloc(amt) as *mut libc::c_long;
                                                                if (flinfo.indices).is_null() {
                                                                    current_block = 10443503258980814984;
                                                                } else {
                                                                    amt = max_sym_count
                                                                        .wrapping_mul(
                                                                            ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                                                        );
                                                                    flinfo.sections = bfd_malloc(amt) as *mut *mut asection;
                                                                    if (flinfo.sections).is_null() {
                                                                        current_block = 10443503258980814984;
                                                                    } else {
                                                                        current_block = 13391418783698890455;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        current_block = 13391418783698890455;
                                                    }
                                                    match current_block {
                                                        10443503258980814984 => {}
                                                        _ => {
                                                            if max_sym_shndx_count != 0 as libc::c_int as libc::c_ulong
                                                            {
                                                                amt = max_sym_shndx_count
                                                                    .wrapping_mul(
                                                                        ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                                                            as libc::c_ulong,
                                                                    );
                                                                flinfo
                                                                    .locsym_shndx = bfd_malloc(amt)
                                                                    as *mut Elf_External_Sym_Shndx;
                                                                if (flinfo.locsym_shndx).is_null() {
                                                                    current_block = 10443503258980814984;
                                                                } else {
                                                                    current_block = 4466262843398566590;
                                                                }
                                                            } else {
                                                                current_block = 4466262843398566590;
                                                            }
                                                            match current_block {
                                                                10443503258980814984 => {}
                                                                _ => {
                                                                    if !((*htab).tls_sec).is_null() {
                                                                        let mut base: bfd_vma = 0;
                                                                        let mut end: bfd_vma = 0 as libc::c_int as bfd_vma;
                                                                        let mut sec_0: *mut asection = 0 as *mut asection;
                                                                        sec_0 = (*htab).tls_sec;
                                                                        while !sec_0.is_null()
                                                                            && (*sec_0).flags & 0x400 as libc::c_int as libc::c_uint
                                                                                != 0
                                                                        {
                                                                            let mut size: bfd_size_type = (*sec_0).size;
                                                                            let mut opb: libc::c_uint = bfd_octets_per_byte(
                                                                                abfd,
                                                                                sec_0,
                                                                            );
                                                                            if size == 0 as libc::c_int as libc::c_ulong
                                                                                && (*sec_0).flags & 0x100 as libc::c_int as libc::c_uint
                                                                                    == 0 as libc::c_int as libc::c_uint
                                                                            {
                                                                                let mut ord: *mut bfd_link_order = (*sec_0)
                                                                                    .map_tail
                                                                                    .link_order;
                                                                                if !ord.is_null() {
                                                                                    size = ((*ord).offset)
                                                                                        .wrapping_mul(opb as libc::c_ulong)
                                                                                        .wrapping_add((*ord).size);
                                                                                }
                                                                            }
                                                                            end = ((*sec_0).vma)
                                                                                .wrapping_add(size.wrapping_div(opb as libc::c_ulong));
                                                                            sec_0 = (*sec_0).next;
                                                                        }
                                                                        base = (*(*htab).tls_sec).vma;
                                                                        if (*bed).static_tls_alignment
                                                                            == 1 as libc::c_int as libc::c_uint
                                                                        {
                                                                            end = end
                                                                                .wrapping_add(
                                                                                    (1 as libc::c_int as bfd_vma)
                                                                                        << (*(*htab).tls_sec).alignment_power,
                                                                                )
                                                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                                                                & ((1 as libc::c_int as bfd_vma)
                                                                                    << (*(*htab).tls_sec).alignment_power)
                                                                                    .wrapping_neg();
                                                                        }
                                                                        (*htab).tls_size = end.wrapping_sub(base);
                                                                    }
                                                                    if !_bfd_elf_fixup_eh_frame_hdr(info) {
                                                                        return 0 as libc::c_int != 0;
                                                                    }
                                                                    sub = (*info).input_bfds;
                                                                    while !sub.is_null() {
                                                                        (*sub)
                                                                            .set_output_has_begun(0 as libc::c_int as libc::c_uint);
                                                                        sub = (*sub).link.next;
                                                                    }
                                                                    o = (*abfd).sections;
                                                                    's_1054: loop {
                                                                        if o.is_null() {
                                                                            current_block = 16225421537987648902;
                                                                            break;
                                                                        }
                                                                        p = (*o).map_head.link_order;
                                                                        while !p.is_null() {
                                                                            if (*p).type_0 as libc::c_uint
                                                                                == bfd_indirect_link_order as libc::c_int as libc::c_uint
                                                                                && {
                                                                                    sub = (*(*p).u.indirect.section).owner;
                                                                                    bfd_get_flavour(sub) as libc::c_uint
                                                                                        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
                                                                                }
                                                                                && (*((*(*sub).tdata.elf_obj_data).elf_header).as_mut_ptr())
                                                                                    .e_ident[4 as libc::c_int as usize] as libc::c_int
                                                                                    == (*(*bed).s).elfclass as libc::c_int
                                                                            {
                                                                                if (*sub).output_has_begun() == 0 {
                                                                                    if !elf_link_input_bfd(&mut flinfo, sub) {
                                                                                        current_block = 10443503258980814984;
                                                                                        break 's_1054;
                                                                                    }
                                                                                    (*sub)
                                                                                        .set_output_has_begun(1 as libc::c_int as libc::c_uint);
                                                                                }
                                                                            } else if (*p).type_0 as libc::c_uint
                                                                                == bfd_section_reloc_link_order as libc::c_int
                                                                                    as libc::c_uint
                                                                                || (*p).type_0 as libc::c_uint
                                                                                    == bfd_symbol_reloc_link_order as libc::c_int
                                                                                        as libc::c_uint
                                                                            {
                                                                                if !elf_reloc_link_order(abfd, info, o, p) {
                                                                                    current_block = 10443503258980814984;
                                                                                    break 's_1054;
                                                                                }
                                                                            } else if !_bfd_default_link_order(abfd, info, o, p) {
                                                                                if (*p).type_0 as libc::c_uint
                                                                                    == bfd_indirect_link_order as libc::c_int as libc::c_uint
                                                                                    && bfd_get_flavour(sub) as libc::c_uint
                                                                                        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
                                                                                    && (*((*(*sub).tdata.elf_obj_data).elf_header).as_mut_ptr())
                                                                                        .e_ident[4 as libc::c_int as usize] as libc::c_int
                                                                                        != (*(*bed).s).elfclass as libc::c_int
                                                                                {
                                                                                    let mut iclass: *const libc::c_char = 0
                                                                                        as *const libc::c_char;
                                                                                    let mut oclass: *const libc::c_char = 0
                                                                                        as *const libc::c_char;
                                                                                    match (*(*bed).s).elfclass as libc::c_int {
                                                                                        2 => {
                                                                                            oclass = b"ELFCLASS64\0" as *const u8
                                                                                                as *const libc::c_char;
                                                                                        }
                                                                                        1 => {
                                                                                            oclass = b"ELFCLASS32\0" as *const u8
                                                                                                as *const libc::c_char;
                                                                                        }
                                                                                        0 => {
                                                                                            oclass = b"ELFCLASSNONE\0" as *const u8
                                                                                                as *const libc::c_char;
                                                                                        }
                                                                                        _ => {
                                                                                            _bfd_abort(
                                                                                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                                                                12606 as libc::c_int,
                                                                                                (*::core::mem::transmute::<
                                                                                                    &[u8; 56],
                                                                                                    &[libc::c_char; 56],
                                                                                                >(
                                                                                                    b"_Bool bfd_elf_final_link(bfd *, struct bfd_link_info *)\0",
                                                                                                ))
                                                                                                    .as_ptr(),
                                                                                            );
                                                                                        }
                                                                                    }
                                                                                    match (*((*(*sub).tdata.elf_obj_data).elf_header)
                                                                                        .as_mut_ptr())
                                                                                        .e_ident[4 as libc::c_int as usize] as libc::c_int
                                                                                    {
                                                                                        2 => {
                                                                                            iclass = b"ELFCLASS64\0" as *const u8
                                                                                                as *const libc::c_char;
                                                                                        }
                                                                                        1 => {
                                                                                            iclass = b"ELFCLASS32\0" as *const u8
                                                                                                as *const libc::c_char;
                                                                                        }
                                                                                        0 => {
                                                                                            iclass = b"ELFCLASSNONE\0" as *const u8
                                                                                                as *const libc::c_char;
                                                                                        }
                                                                                        _ => {
                                                                                            _bfd_abort(
                                                                                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                                                                12614 as libc::c_int,
                                                                                                (*::core::mem::transmute::<
                                                                                                    &[u8; 56],
                                                                                                    &[libc::c_char; 56],
                                                                                                >(
                                                                                                    b"_Bool bfd_elf_final_link(bfd *, struct bfd_link_info *)\0",
                                                                                                ))
                                                                                                    .as_ptr(),
                                                                                            );
                                                                                        }
                                                                                    }
                                                                                    bfd_set_error(bfd_error_wrong_format);
                                                                                    _bfd_error_handler(
                                                                                        dcgettext(
                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                            b"%pB: file class %s incompatible with %s\0" as *const u8
                                                                                                as *const libc::c_char,
                                                                                            5 as libc::c_int,
                                                                                        ),
                                                                                        sub,
                                                                                        iclass,
                                                                                        oclass,
                                                                                    );
                                                                                }
                                                                                current_block = 10443503258980814984;
                                                                                break 's_1054;
                                                                            }
                                                                            p = (*p).next;
                                                                        }
                                                                        o = (*o).next;
                                                                    }
                                                                    match current_block {
                                                                        10443503258980814984 => {}
                                                                        _ => {
                                                                            if (*info).reduce_memory_overheads() == 0 {
                                                                                sub = (*info).input_bfds;
                                                                                while !sub.is_null() {
                                                                                    if bfd_get_flavour(sub) as libc::c_uint
                                                                                        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
                                                                                    {
                                                                                        free((*(*sub).tdata.elf_obj_data).symbuf);
                                                                                        (*(*sub).tdata.elf_obj_data)
                                                                                            .symbuf = 0 as *mut libc::c_void;
                                                                                    }
                                                                                    sub = (*sub).link.next;
                                                                                }
                                                                            }
                                                                            ret = 1 as libc::c_int != 0;
                                                                            eoinfo.failed = 0 as libc::c_int != 0;
                                                                            eoinfo.flinfo = &mut flinfo;
                                                                            eoinfo.localsyms = 1 as libc::c_int != 0;
                                                                            eoinfo.file_sym_done = 0 as libc::c_int != 0;
                                                                            bfd_hash_traverse(
                                                                                &mut (*(*info).hash).table,
                                                                                Some(
                                                                                    elf_link_output_extsym
                                                                                        as unsafe extern "C" fn(
                                                                                            *mut bfd_hash_entry,
                                                                                            *mut libc::c_void,
                                                                                        ) -> bool,
                                                                                ),
                                                                                &mut eoinfo as *mut elf_outext_info as *mut libc::c_void,
                                                                            );
                                                                            if eoinfo.failed {
                                                                                ret = 0 as libc::c_int != 0;
                                                                                current_block = 6681060674233533360;
                                                                            } else {
                                                                                if ((*bed).elf_backend_output_arch_local_syms).is_some()
                                                                                    && ((*info).strip() as libc::c_int
                                                                                        != strip_all as libc::c_int
                                                                                        || emit_relocs as libc::c_int != 0)
                                                                                {
                                                                                    if !(Some(
                                                                                        ((*bed).elf_backend_output_arch_local_syms)
                                                                                            .expect("non-null function pointer"),
                                                                                    ))
                                                                                        .expect(
                                                                                            "non-null function pointer",
                                                                                        )(
                                                                                        abfd,
                                                                                        info,
                                                                                        &mut flinfo as *mut elf_final_link_info
                                                                                            as *mut libc::c_void,
                                                                                        Some(
                                                                                            elf_link_output_symstrtab
                                                                                                as unsafe extern "C" fn(
                                                                                                    *mut libc::c_void,
                                                                                                    *const libc::c_char,
                                                                                                    *mut Elf_Internal_Sym,
                                                                                                    *mut asection,
                                                                                                    *mut elf_link_hash_entry,
                                                                                                ) -> libc::c_int,
                                                                                        ),
                                                                                    )
                                                                                    {
                                                                                        ret = 0 as libc::c_int != 0;
                                                                                        current_block = 6681060674233533360;
                                                                                    } else {
                                                                                        current_block = 17478354070635831526;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 17478354070635831526;
                                                                                }
                                                                                match current_block {
                                                                                    6681060674233533360 => {}
                                                                                    _ => {
                                                                                        if (*symtab_hdr).sh_info == 0 {
                                                                                            (*symtab_hdr).sh_info = bfd_get_symcount(abfd);
                                                                                        }
                                                                                        if dynamic as libc::c_int != 0
                                                                                            && !((*htab).dynsym).is_null()
                                                                                            && (*(*htab).dynsym).output_section
                                                                                                != &mut *_bfd_std_section
                                                                                                    .as_mut_ptr()
                                                                                                    .offset(2 as libc::c_int as isize) as *mut asection
                                                                                        {
                                                                                            let mut sym: Elf_Internal_Sym = Elf_Internal_Sym {
                                                                                                st_value: 0,
                                                                                                st_size: 0,
                                                                                                st_name: 0,
                                                                                                st_info: 0,
                                                                                                st_other: 0,
                                                                                                st_target_internal: 0,
                                                                                                st_shndx: 0,
                                                                                            };
                                                                                            let mut dynsym: *mut bfd_byte = (*(*htab).dynsym).contents;
                                                                                            o = (*(*htab).dynsym).output_section;
                                                                                            (*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                                                                                .this_hdr
                                                                                                .sh_info = ((*htab).local_dynsymcount)
                                                                                                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                                                                                                as libc::c_uint;
                                                                                            if (*info).type_0() as libc::c_int
                                                                                                == type_dll as libc::c_int
                                                                                                || (*info).type_0() as libc::c_int
                                                                                                    == type_pie as libc::c_int
                                                                                                || (*htab).is_relocatable_executable as libc::c_int != 0
                                                                                            {
                                                                                                let mut s: *mut asection = 0 as *mut asection;
                                                                                                sym.st_size = 0 as libc::c_int as bfd_vma;
                                                                                                sym.st_name = 0 as libc::c_int as libc::c_ulong;
                                                                                                sym
                                                                                                    .st_info = (((0 as libc::c_int) << 4 as libc::c_int)
                                                                                                    + (3 as libc::c_int & 0xf as libc::c_int)) as libc::c_uchar;
                                                                                                sym.st_other = 0 as libc::c_int as libc::c_uchar;
                                                                                                sym.st_target_internal = 0 as libc::c_int as libc::c_uchar;
                                                                                                s = (*abfd).sections;
                                                                                                loop {
                                                                                                    if s.is_null() {
                                                                                                        current_block = 15174492983169363256;
                                                                                                        break;
                                                                                                    }
                                                                                                    let mut indx: libc::c_int = 0;
                                                                                                    let mut dest: *mut bfd_byte = 0 as *mut bfd_byte;
                                                                                                    let mut dynindx: libc::c_long = 0;
                                                                                                    dynindx = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                                                                                        .dynindx as libc::c_long;
                                                                                                    if !(dynindx <= 0 as libc::c_int as libc::c_long) {
                                                                                                        indx = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                                                                                            .this_idx;
                                                                                                        if !(indx > 0 as libc::c_int) {
                                                                                                            bfd_assert(
                                                                                                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                                                                                12714 as libc::c_int,
                                                                                                            );
                                                                                                        }
                                                                                                        sym.st_shndx = indx as libc::c_uint;
                                                                                                        if !check_dynsym(abfd, &mut sym) {
                                                                                                            ret = 0 as libc::c_int != 0;
                                                                                                            current_block = 6681060674233533360;
                                                                                                            break;
                                                                                                        } else {
                                                                                                            sym.st_value = (*s).vma;
                                                                                                            dest = dynsym
                                                                                                                .offset(
                                                                                                                    (dynindx * (*(*bed).s).sizeof_sym as libc::c_long) as isize,
                                                                                                                );
                                                                                                            if ((*(*info).callbacks).ctf_new_dynsym).is_some() {
                                                                                                                ((*(*info).callbacks).ctf_new_dynsym)
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )(dynindx as libc::c_int, &mut sym);
                                                                                                            }
                                                                                                            ((*(*bed).s).swap_symbol_out)
                                                                                                                .expect(
                                                                                                                    "non-null function pointer",
                                                                                                                )(
                                                                                                                abfd,
                                                                                                                &mut sym,
                                                                                                                dest as *mut libc::c_void,
                                                                                                                0 as *mut libc::c_void,
                                                                                                            );
                                                                                                        }
                                                                                                    }
                                                                                                    s = (*s).next;
                                                                                                }
                                                                                            } else {
                                                                                                current_block = 15174492983169363256;
                                                                                            }
                                                                                            match current_block {
                                                                                                6681060674233533360 => {}
                                                                                                _ => {
                                                                                                    if !((*htab).dynlocal).is_null() {
                                                                                                        let mut e: *mut elf_link_local_dynamic_entry = 0
                                                                                                            as *mut elf_link_local_dynamic_entry;
                                                                                                        e = (*htab).dynlocal;
                                                                                                        loop {
                                                                                                            if e.is_null() {
                                                                                                                current_block = 13976402388691103242;
                                                                                                                break;
                                                                                                            }
                                                                                                            let mut s_0: *mut asection = 0 as *mut asection;
                                                                                                            let mut dest_0: *mut bfd_byte = 0 as *mut bfd_byte;
                                                                                                            sym = (*e).isym;
                                                                                                            sym
                                                                                                                .st_other = (sym.st_other as libc::c_int
                                                                                                                & !(-(1 as libc::c_int) & 0x3 as libc::c_int))
                                                                                                                as libc::c_uchar;
                                                                                                            sym.st_shndx = 0 as libc::c_int as libc::c_uint;
                                                                                                            s_0 = bfd_section_from_elf_index(
                                                                                                                (*e).input_bfd,
                                                                                                                (*e).isym.st_shndx,
                                                                                                            );
                                                                                                            if !s_0.is_null() && !((*s_0).output_section).is_null()
                                                                                                                && !((*(*s_0).output_section).used_by_bfd
                                                                                                                    as *mut bfd_elf_section_data)
                                                                                                                    .is_null()
                                                                                                            {
                                                                                                                sym
                                                                                                                    .st_shndx = (*((*(*s_0).output_section).used_by_bfd
                                                                                                                    as *mut bfd_elf_section_data))
                                                                                                                    .this_idx as libc::c_uint;
                                                                                                                if !check_dynsym(abfd, &mut sym) {
                                                                                                                    ret = 0 as libc::c_int != 0;
                                                                                                                    current_block = 6681060674233533360;
                                                                                                                    break;
                                                                                                                } else {
                                                                                                                    sym
                                                                                                                        .st_value = ((*(*s_0).output_section).vma)
                                                                                                                        .wrapping_add((*s_0).output_offset)
                                                                                                                        .wrapping_add((*e).isym.st_value);
                                                                                                                }
                                                                                                            }
                                                                                                            if ((*(*info).callbacks).ctf_new_dynsym).is_some() {
                                                                                                                ((*(*info).callbacks).ctf_new_dynsym)
                                                                                                                    .expect(
                                                                                                                        "non-null function pointer",
                                                                                                                    )((*e).dynindx as libc::c_int, &mut sym);
                                                                                                            }
                                                                                                            dest_0 = dynsym
                                                                                                                .offset(
                                                                                                                    ((*e).dynindx * (*(*bed).s).sizeof_sym as libc::c_long)
                                                                                                                        as isize,
                                                                                                                );
                                                                                                            ((*(*bed).s).swap_symbol_out)
                                                                                                                .expect(
                                                                                                                    "non-null function pointer",
                                                                                                                )(
                                                                                                                abfd,
                                                                                                                &mut sym,
                                                                                                                dest_0 as *mut libc::c_void,
                                                                                                                0 as *mut libc::c_void,
                                                                                                            );
                                                                                                            e = (*e).next;
                                                                                                        }
                                                                                                    } else {
                                                                                                        current_block = 13976402388691103242;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        } else {
                                                                                            current_block = 13976402388691103242;
                                                                                        }
                                                                                        match current_block {
                                                                                            6681060674233533360 => {}
                                                                                            _ => {
                                                                                                eoinfo.failed = 0 as libc::c_int != 0;
                                                                                                eoinfo.localsyms = 0 as libc::c_int != 0;
                                                                                                eoinfo.flinfo = &mut flinfo;
                                                                                                bfd_hash_traverse(
                                                                                                    &mut (*(*info).hash).table,
                                                                                                    Some(
                                                                                                        elf_link_output_extsym
                                                                                                            as unsafe extern "C" fn(
                                                                                                                *mut bfd_hash_entry,
                                                                                                                *mut libc::c_void,
                                                                                                            ) -> bool,
                                                                                                    ),
                                                                                                    &mut eoinfo as *mut elf_outext_info as *mut libc::c_void,
                                                                                                );
                                                                                                if eoinfo.failed {
                                                                                                    ret = 0 as libc::c_int != 0;
                                                                                                    current_block = 6681060674233533360;
                                                                                                } else {
                                                                                                    if ((*bed).elf_backend_output_arch_syms).is_some()
                                                                                                        && ((*info).strip() as libc::c_int
                                                                                                            != strip_all as libc::c_int
                                                                                                            || emit_relocs as libc::c_int != 0)
                                                                                                    {
                                                                                                        if !(Some(
                                                                                                            ((*bed).elf_backend_output_arch_syms)
                                                                                                                .expect("non-null function pointer"),
                                                                                                        ))
                                                                                                            .expect(
                                                                                                                "non-null function pointer",
                                                                                                            )(
                                                                                                            abfd,
                                                                                                            info,
                                                                                                            &mut flinfo as *mut elf_final_link_info
                                                                                                                as *mut libc::c_void,
                                                                                                            Some(
                                                                                                                elf_link_output_symstrtab
                                                                                                                    as unsafe extern "C" fn(
                                                                                                                        *mut libc::c_void,
                                                                                                                        *const libc::c_char,
                                                                                                                        *mut Elf_Internal_Sym,
                                                                                                                        *mut asection,
                                                                                                                        *mut elf_link_hash_entry,
                                                                                                                    ) -> libc::c_int,
                                                                                                            ),
                                                                                                        )
                                                                                                        {
                                                                                                            ret = 0 as libc::c_int != 0;
                                                                                                            current_block = 6681060674233533360;
                                                                                                        } else {
                                                                                                            current_block = 14629184937156991734;
                                                                                                        }
                                                                                                    } else {
                                                                                                        current_block = 14629184937156991734;
                                                                                                    }
                                                                                                    match current_block {
                                                                                                        6681060674233533360 => {}
                                                                                                        _ => {
                                                                                                            _bfd_elf_strtab_finalize(flinfo.symstrtab);
                                                                                                            if !elf_link_swap_symbols_out(&mut flinfo) {
                                                                                                                ret = 0 as libc::c_int != 0;
                                                                                                                current_block = 6681060674233533360;
                                                                                                            } else {
                                                                                                                if bfd_get_symcount(abfd) > 0 as libc::c_int as libc::c_uint
                                                                                                                {
                                                                                                                    let mut symstrtab_hdr: *mut Elf_Internal_Shdr = 0
                                                                                                                        as *mut Elf_Internal_Shdr;
                                                                                                                    let mut off_0: file_ptr = ((*symtab_hdr).sh_offset
                                                                                                                        as libc::c_ulong)
                                                                                                                        .wrapping_add((*symtab_hdr).sh_size) as file_ptr;
                                                                                                                    if !((*(*abfd).tdata.elf_obj_data).symtab_shndx_list)
                                                                                                                        .is_null()
                                                                                                                    {
                                                                                                                        symtab_shndx_hdr = &mut (*(*(*abfd).tdata.elf_obj_data)
                                                                                                                            .symtab_shndx_list)
                                                                                                                            .hdr;
                                                                                                                        if !symtab_shndx_hdr.is_null()
                                                                                                                            && (*symtab_shndx_hdr).sh_name
                                                                                                                                != 0 as libc::c_int as libc::c_uint
                                                                                                                        {
                                                                                                                            (*symtab_shndx_hdr)
                                                                                                                                .sh_type = 18 as libc::c_int as libc::c_uint;
                                                                                                                            (*symtab_shndx_hdr)
                                                                                                                                .sh_entsize = ::core::mem::size_of::<
                                                                                                                                Elf_External_Sym_Shndx,
                                                                                                                            >() as libc::c_ulong;
                                                                                                                            (*symtab_shndx_hdr)
                                                                                                                                .sh_addralign = ::core::mem::size_of::<
                                                                                                                                Elf_External_Sym_Shndx,
                                                                                                                            >() as libc::c_ulong;
                                                                                                                            amt = (bfd_get_symcount(abfd) as libc::c_ulong)
                                                                                                                                .wrapping_mul(
                                                                                                                                    ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                                                                                                                        as libc::c_ulong,
                                                                                                                                );
                                                                                                                            (*symtab_shndx_hdr).sh_size = amt;
                                                                                                                            off_0 = _bfd_elf_assign_file_position_for_section(
                                                                                                                                symtab_shndx_hdr,
                                                                                                                                off_0,
                                                                                                                                1 as libc::c_int != 0,
                                                                                                                            );
                                                                                                                            if bfd_seek(
                                                                                                                                abfd,
                                                                                                                                (*symtab_shndx_hdr).sh_offset,
                                                                                                                                0 as libc::c_int,
                                                                                                                            ) != 0 as libc::c_int
                                                                                                                                || bfd_bwrite(
                                                                                                                                    flinfo.symshndxbuf as *const libc::c_void,
                                                                                                                                    amt,
                                                                                                                                    abfd,
                                                                                                                                ) != amt
                                                                                                                            {
                                                                                                                                ret = 0 as libc::c_int != 0;
                                                                                                                                current_block = 6681060674233533360;
                                                                                                                            } else {
                                                                                                                                current_block = 11366682102430008042;
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            current_block = 11366682102430008042;
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        current_block = 11366682102430008042;
                                                                                                                    }
                                                                                                                    match current_block {
                                                                                                                        6681060674233533360 => {}
                                                                                                                        _ => {
                                                                                                                            symstrtab_hdr = &mut (*(*abfd).tdata.elf_obj_data)
                                                                                                                                .strtab_hdr;
                                                                                                                            (*symstrtab_hdr).sh_type = 3 as libc::c_int as libc::c_uint;
                                                                                                                            (*symstrtab_hdr).sh_flags = (*bed).elf_strtab_flags;
                                                                                                                            (*symstrtab_hdr).sh_addr = 0 as libc::c_int as bfd_vma;
                                                                                                                            (*symstrtab_hdr)
                                                                                                                                .sh_size = _bfd_elf_strtab_size(flinfo.symstrtab);
                                                                                                                            (*symstrtab_hdr)
                                                                                                                                .sh_entsize = 0 as libc::c_int as bfd_size_type;
                                                                                                                            (*symstrtab_hdr).sh_link = 0 as libc::c_int as libc::c_uint;
                                                                                                                            (*symstrtab_hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                                                                                                            (*symstrtab_hdr).sh_addralign = 1 as libc::c_int as bfd_vma;
                                                                                                                            off_0 = _bfd_elf_assign_file_position_for_section(
                                                                                                                                symstrtab_hdr,
                                                                                                                                off_0,
                                                                                                                                1 as libc::c_int != 0,
                                                                                                                            );
                                                                                                                            (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos = off_0;
                                                                                                                            if bfd_seek(
                                                                                                                                abfd,
                                                                                                                                (*symstrtab_hdr).sh_offset,
                                                                                                                                0 as libc::c_int,
                                                                                                                            ) != 0 as libc::c_int
                                                                                                                                || !_bfd_elf_strtab_emit(abfd, flinfo.symstrtab)
                                                                                                                            {
                                                                                                                                ret = 0 as libc::c_int != 0;
                                                                                                                                current_block = 6681060674233533360;
                                                                                                                            } else {
                                                                                                                                current_block = 6356445669134572965;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    current_block = 6356445669134572965;
                                                                                                                }
                                                                                                                match current_block {
                                                                                                                    6681060674233533360 => {}
                                                                                                                    _ => {
                                                                                                                        if !((*info).out_implib_bfd).is_null()
                                                                                                                            && !elf_output_implib(abfd, info)
                                                                                                                        {
                                                                                                                            _bfd_error_handler(
                                                                                                                                dcgettext(
                                                                                                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                    b"%pB: failed to generate import library\0" as *const u8
                                                                                                                                        as *const libc::c_char,
                                                                                                                                    5 as libc::c_int,
                                                                                                                                ),
                                                                                                                                (*info).out_implib_bfd,
                                                                                                                            );
                                                                                                                            ret = 0 as libc::c_int != 0;
                                                                                                                            current_block = 6681060674233533360;
                                                                                                                        } else {
                                                                                                                            o = (*abfd).sections;
                                                                                                                            loop {
                                                                                                                                if o.is_null() {
                                                                                                                                    current_block = 1613427988851011995;
                                                                                                                                    break;
                                                                                                                                }
                                                                                                                                let mut esdo_1: *mut bfd_elf_section_data = (*o).used_by_bfd
                                                                                                                                    as *mut bfd_elf_section_data;
                                                                                                                                let mut sort: bool = false;
                                                                                                                                if !((*o).flags & 0x4 as libc::c_int as libc::c_uint
                                                                                                                                    == 0 as libc::c_int as libc::c_uint)
                                                                                                                                {
                                                                                                                                    sort = ((*bed).sort_relocs_p).is_none()
                                                                                                                                        || (Some(
                                                                                                                                            ((*bed).sort_relocs_p).expect("non-null function pointer"),
                                                                                                                                        ))
                                                                                                                                            .expect("non-null function pointer")(o) as libc::c_int != 0;
                                                                                                                                    if !((*esdo_1).rel.hdr).is_null()
                                                                                                                                        && !elf_link_adjust_relocs(
                                                                                                                                            abfd,
                                                                                                                                            o,
                                                                                                                                            &mut (*esdo_1).rel,
                                                                                                                                            sort,
                                                                                                                                            info,
                                                                                                                                        )
                                                                                                                                    {
                                                                                                                                        ret = 0 as libc::c_int != 0;
                                                                                                                                        current_block = 6681060674233533360;
                                                                                                                                        break;
                                                                                                                                    } else if !((*esdo_1).rela.hdr).is_null()
                                                                                                                                        && !elf_link_adjust_relocs(
                                                                                                                                            abfd,
                                                                                                                                            o,
                                                                                                                                            &mut (*esdo_1).rela,
                                                                                                                                            sort,
                                                                                                                                            info,
                                                                                                                                        )
                                                                                                                                    {
                                                                                                                                        ret = 0 as libc::c_int != 0;
                                                                                                                                        current_block = 6681060674233533360;
                                                                                                                                        break;
                                                                                                                                    } else {
                                                                                                                                        (*o).reloc_count = 0 as libc::c_int as libc::c_uint;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                o = (*o).next;
                                                                                                                            }
                                                                                                                            match current_block {
                                                                                                                                6681060674233533360 => {}
                                                                                                                                _ => {
                                                                                                                                    if dynamic as libc::c_int != 0
                                                                                                                                        && (*info).combreloc() as libc::c_int != 0
                                                                                                                                        && !dynobj.is_null()
                                                                                                                                    {
                                                                                                                                        relativecount = elf_link_sort_relocs(
                                                                                                                                            abfd,
                                                                                                                                            info,
                                                                                                                                            &mut reldyn,
                                                                                                                                        );
                                                                                                                                    }
                                                                                                                                    if dynamic {
                                                                                                                                        let mut dyncon: *mut bfd_byte = 0 as *mut bfd_byte;
                                                                                                                                        let mut dynconend: *mut bfd_byte = 0 as *mut bfd_byte;
                                                                                                                                        o = bfd_get_linker_section(
                                                                                                                                            dynobj,
                                                                                                                                            b".dynamic\0" as *const u8 as *const libc::c_char,
                                                                                                                                        );
                                                                                                                                        if o.is_null() {
                                                                                                                                            bfd_assert(
                                                                                                                                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                                                                                                                12915 as libc::c_int,
                                                                                                                                            );
                                                                                                                                        }
                                                                                                                                        dyncon = (*o).contents;
                                                                                                                                        dynconend = ((*o).contents).offset((*o).size as isize);
                                                                                                                                        loop {
                                                                                                                                            if !(dyncon < dynconend) {
                                                                                                                                                current_block = 8155699268269024736;
                                                                                                                                                break;
                                                                                                                                            }
                                                                                                                                            let mut dyn_0: Elf_Internal_Dyn = Elf_Internal_Dyn {
                                                                                                                                                d_tag: 0,
                                                                                                                                                d_un: C2RustUnnamed_21 { d_val: 0 },
                                                                                                                                            };
                                                                                                                                            let mut name_0: *const libc::c_char = 0
                                                                                                                                                as *const libc::c_char;
                                                                                                                                            let mut type_0: libc::c_uint = 0;
                                                                                                                                            let mut sh_size: bfd_size_type = 0;
                                                                                                                                            let mut sh_addr: bfd_vma = 0;
                                                                                                                                            ((*(*bed).s).swap_dyn_in)
                                                                                                                                                .expect(
                                                                                                                                                    "non-null function pointer",
                                                                                                                                                )(dynobj, dyncon as *const libc::c_void, &mut dyn_0);
                                                                                                                                            match dyn_0.d_tag {
                                                                                                                                                0 => {
                                                                                                                                                    if relativecount > 0 as libc::c_int as libc::c_ulong
                                                                                                                                                        && dyncon
                                                                                                                                                            .offset((*(*bed).s).sizeof_dyn as libc::c_int as isize)
                                                                                                                                                            < dynconend
                                                                                                                                                    {
                                                                                                                                                        match (*((*reldyn).used_by_bfd
                                                                                                                                                            as *mut bfd_elf_section_data))
                                                                                                                                                            .this_hdr
                                                                                                                                                            .sh_type
                                                                                                                                                        {
                                                                                                                                                            9 => {
                                                                                                                                                                current_block = 1512335524007036744;
                                                                                                                                                                match current_block {
                                                                                                                                                                    9525377375035201936 => {
                                                                                                                                                                        dyn_0.d_tag = 0x6ffffff9 as libc::c_int as bfd_vma;
                                                                                                                                                                    }
                                                                                                                                                                    _ => {
                                                                                                                                                                        dyn_0.d_tag = 0x6ffffffa as libc::c_int as bfd_vma;
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                                dyn_0.d_un.d_val = relativecount;
                                                                                                                                                                relativecount = 0 as libc::c_int as size_t;
                                                                                                                                                                current_block = 11297176373744872492;
                                                                                                                                                            }
                                                                                                                                                            4 => {
                                                                                                                                                                current_block = 9525377375035201936;
                                                                                                                                                                match current_block {
                                                                                                                                                                    9525377375035201936 => {
                                                                                                                                                                        dyn_0.d_tag = 0x6ffffff9 as libc::c_int as bfd_vma;
                                                                                                                                                                    }
                                                                                                                                                                    _ => {
                                                                                                                                                                        dyn_0.d_tag = 0x6ffffffa as libc::c_int as bfd_vma;
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                                dyn_0.d_un.d_val = relativecount;
                                                                                                                                                                relativecount = 0 as libc::c_int as size_t;
                                                                                                                                                                current_block = 11297176373744872492;
                                                                                                                                                            }
                                                                                                                                                            _ => {
                                                                                                                                                                current_block = 10066646996736658063;
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    } else {
                                                                                                                                                        current_block = 10066646996736658063;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                12 => {
                                                                                                                                                    name_0 = (*info).init_function;
                                                                                                                                                    current_block = 4492410755057838308;
                                                                                                                                                }
                                                                                                                                                13 => {
                                                                                                                                                    name_0 = (*info).fini_function;
                                                                                                                                                    current_block = 4492410755057838308;
                                                                                                                                                }
                                                                                                                                                33 => {
                                                                                                                                                    name_0 = b".preinit_array\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 13468778398218930095;
                                                                                                                                                }
                                                                                                                                                27 => {
                                                                                                                                                    name_0 = b".init_array\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 13468778398218930095;
                                                                                                                                                }
                                                                                                                                                28 => {
                                                                                                                                                    name_0 = b".fini_array\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 13468778398218930095;
                                                                                                                                                }
                                                                                                                                                32 => {
                                                                                                                                                    name_0 = b".preinit_array\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 300583877346050200;
                                                                                                                                                }
                                                                                                                                                25 => {
                                                                                                                                                    name_0 = b".init_array\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 300583877346050200;
                                                                                                                                                }
                                                                                                                                                26 => {
                                                                                                                                                    name_0 = b".fini_array\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 300583877346050200;
                                                                                                                                                }
                                                                                                                                                4 => {
                                                                                                                                                    name_0 = b".hash\0" as *const u8 as *const libc::c_char;
                                                                                                                                                    current_block = 10065219314531138578;
                                                                                                                                                }
                                                                                                                                                1879047925 => {
                                                                                                                                                    name_0 = b".gnu.hash\0" as *const u8 as *const libc::c_char;
                                                                                                                                                    current_block = 10065219314531138578;
                                                                                                                                                }
                                                                                                                                                5 => {
                                                                                                                                                    name_0 = b".dynstr\0" as *const u8 as *const libc::c_char;
                                                                                                                                                    current_block = 10065219314531138578;
                                                                                                                                                }
                                                                                                                                                6 => {
                                                                                                                                                    name_0 = b".dynsym\0" as *const u8 as *const libc::c_char;
                                                                                                                                                    current_block = 10065219314531138578;
                                                                                                                                                }
                                                                                                                                                1879048188 => {
                                                                                                                                                    name_0 = b".gnu.version_d\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 10065219314531138578;
                                                                                                                                                }
                                                                                                                                                1879048190 => {
                                                                                                                                                    name_0 = b".gnu.version_r\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 10065219314531138578;
                                                                                                                                                }
                                                                                                                                                1879048176 => {
                                                                                                                                                    name_0 = b".gnu.version\0" as *const u8
                                                                                                                                                        as *const libc::c_char;
                                                                                                                                                    current_block = 10065219314531138578;
                                                                                                                                                }
                                                                                                                                                17 | 7 | 18 | 8 => {
                                                                                                                                                    if dyn_0.d_tag == 17 as libc::c_int as libc::c_ulong
                                                                                                                                                        || dyn_0.d_tag == 18 as libc::c_int as libc::c_ulong
                                                                                                                                                    {
                                                                                                                                                        type_0 = 9 as libc::c_int as libc::c_uint;
                                                                                                                                                    } else {
                                                                                                                                                        type_0 = 4 as libc::c_int as libc::c_uint;
                                                                                                                                                    }
                                                                                                                                                    sh_size = 0 as libc::c_int as bfd_size_type;
                                                                                                                                                    sh_addr = 0 as libc::c_int as bfd_vma;
                                                                                                                                                    i = 1 as libc::c_int as libc::c_uint;
                                                                                                                                                    while i < (*(*abfd).tdata.elf_obj_data).num_elf_sections {
                                                                                                                                                        let mut hdr: *mut Elf_Internal_Shdr = 0
                                                                                                                                                            as *mut Elf_Internal_Shdr;
                                                                                                                                                        hdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                                                                                                                                            .offset(i as isize);
                                                                                                                                                        if (*hdr).sh_type == type_0
                                                                                                                                                            && (*hdr).sh_flags
                                                                                                                                                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                                                                                                                                                != 0 as libc::c_int as libc::c_ulong
                                                                                                                                                        {
                                                                                                                                                            sh_size = (sh_size as libc::c_ulong)
                                                                                                                                                                .wrapping_add((*hdr).sh_size) as bfd_size_type
                                                                                                                                                                as bfd_size_type;
                                                                                                                                                            if sh_addr == 0 as libc::c_int as libc::c_ulong
                                                                                                                                                                || sh_addr > (*hdr).sh_addr
                                                                                                                                                            {
                                                                                                                                                                sh_addr = (*hdr).sh_addr;
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        i = i.wrapping_add(1);
                                                                                                                                                        i;
                                                                                                                                                    }
                                                                                                                                                    if (*bed).dtrel_excludes_plt() as libc::c_int != 0
                                                                                                                                                        && !((*htab).srelplt).is_null()
                                                                                                                                                    {
                                                                                                                                                        let mut opb_0: libc::c_uint = bfd_octets_per_byte(abfd, o);
                                                                                                                                                        sh_size = (sh_size as libc::c_ulong)
                                                                                                                                                            .wrapping_sub((*(*htab).srelplt).size) as bfd_size_type
                                                                                                                                                            as bfd_size_type;
                                                                                                                                                        if sh_size == 0 as libc::c_int as libc::c_ulong {
                                                                                                                                                            sh_addr = 0 as libc::c_int as bfd_vma;
                                                                                                                                                        } else if sh_addr
                                                                                                                                                            == ((*(*(*htab).srelplt).output_section).vma)
                                                                                                                                                                .wrapping_add((*(*htab).srelplt).output_offset)
                                                                                                                                                                .wrapping_mul(opb_0 as libc::c_ulong)
                                                                                                                                                        {
                                                                                                                                                            sh_addr = (sh_addr as libc::c_ulong)
                                                                                                                                                                .wrapping_add((*(*htab).srelplt).size) as bfd_vma
                                                                                                                                                                as bfd_vma;
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    if dyn_0.d_tag == 18 as libc::c_int as libc::c_ulong
                                                                                                                                                        || dyn_0.d_tag == 8 as libc::c_int as libc::c_ulong
                                                                                                                                                    {
                                                                                                                                                        dyn_0.d_un.d_val = sh_size;
                                                                                                                                                    } else {
                                                                                                                                                        dyn_0.d_un.d_ptr = sh_addr;
                                                                                                                                                    }
                                                                                                                                                    current_block = 11297176373744872492;
                                                                                                                                                }
                                                                                                                                                _ => {
                                                                                                                                                    current_block = 10066646996736658063;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            match current_block {
                                                                                                                                                4492410755057838308 => {
                                                                                                                                                    let mut h: *mut elf_link_hash_entry = 0
                                                                                                                                                        as *mut elf_link_hash_entry;
                                                                                                                                                    h = elf_link_hash_lookup(
                                                                                                                                                        htab,
                                                                                                                                                        name_0,
                                                                                                                                                        0 as libc::c_int != 0,
                                                                                                                                                        0 as libc::c_int != 0,
                                                                                                                                                        1 as libc::c_int != 0,
                                                                                                                                                    );
                                                                                                                                                    if !h.is_null()
                                                                                                                                                        && (((*h).root).type_0() as libc::c_int
                                                                                                                                                            == bfd_link_hash_defined as libc::c_int
                                                                                                                                                            || ((*h).root).type_0() as libc::c_int
                                                                                                                                                                == bfd_link_hash_defweak as libc::c_int)
                                                                                                                                                    {
                                                                                                                                                        dyn_0.d_un.d_ptr = (*h).root.u.def.value;
                                                                                                                                                        o = (*h).root.u.def.section;
                                                                                                                                                        if !((*o).output_section).is_null() {
                                                                                                                                                            dyn_0
                                                                                                                                                                .d_un
                                                                                                                                                                .d_ptr = (dyn_0.d_un.d_ptr as libc::c_ulong)
                                                                                                                                                                .wrapping_add(
                                                                                                                                                                    ((*(*o).output_section).vma)
                                                                                                                                                                        .wrapping_add((*o).output_offset),
                                                                                                                                                                ) as bfd_vma as bfd_vma;
                                                                                                                                                        } else {
                                                                                                                                                            dyn_0.d_un.d_ptr = 0 as libc::c_int as bfd_vma;
                                                                                                                                                        }
                                                                                                                                                        current_block = 11297176373744872492;
                                                                                                                                                    } else {
                                                                                                                                                        current_block = 10066646996736658063;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                13468778398218930095 => {
                                                                                                                                                    o = bfd_get_section_by_name(abfd, name_0);
                                                                                                                                                    if o.is_null() {
                                                                                                                                                        _bfd_error_handler(
                                                                                                                                                            dcgettext(
                                                                                                                                                                b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                b"could not find section %s\0" as *const u8
                                                                                                                                                                    as *const libc::c_char,
                                                                                                                                                                5 as libc::c_int,
                                                                                                                                                            ),
                                                                                                                                                            name_0,
                                                                                                                                                        );
                                                                                                                                                        current_block = 10443503258980814984;
                                                                                                                                                        break;
                                                                                                                                                    } else {
                                                                                                                                                        if (*o).size == 0 as libc::c_int as libc::c_ulong {
                                                                                                                                                            _bfd_error_handler(
                                                                                                                                                                dcgettext(
                                                                                                                                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                    b"warning: %s section has zero size\0" as *const u8
                                                                                                                                                                        as *const libc::c_char,
                                                                                                                                                                    5 as libc::c_int,
                                                                                                                                                                ),
                                                                                                                                                                name_0,
                                                                                                                                                            );
                                                                                                                                                        }
                                                                                                                                                        dyn_0.d_un.d_val = (*o).size;
                                                                                                                                                    }
                                                                                                                                                    current_block = 11297176373744872492;
                                                                                                                                                }
                                                                                                                                                300583877346050200 => {
                                                                                                                                                    o = bfd_get_section_by_name(abfd, name_0);
                                                                                                                                                    current_block = 17563703419135654311;
                                                                                                                                                }
                                                                                                                                                10065219314531138578 => {
                                                                                                                                                    o = bfd_get_linker_section(dynobj, name_0);
                                                                                                                                                    current_block = 17563703419135654311;
                                                                                                                                                }
                                                                                                                                                _ => {}
                                                                                                                                            }
                                                                                                                                            match current_block {
                                                                                                                                                17563703419135654311 => {
                                                                                                                                                    if o.is_null()
                                                                                                                                                        || bfd_is_abs_section((*o).output_section) as libc::c_int
                                                                                                                                                            != 0
                                                                                                                                                    {
                                                                                                                                                        _bfd_error_handler(
                                                                                                                                                            dcgettext(
                                                                                                                                                                b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                b"could not find section %s\0" as *const u8
                                                                                                                                                                    as *const libc::c_char,
                                                                                                                                                                5 as libc::c_int,
                                                                                                                                                            ),
                                                                                                                                                            name_0,
                                                                                                                                                        );
                                                                                                                                                        current_block = 10443503258980814984;
                                                                                                                                                        break;
                                                                                                                                                    } else if (*((*(*o).output_section).used_by_bfd
                                                                                                                                                        as *mut bfd_elf_section_data))
                                                                                                                                                        .this_hdr
                                                                                                                                                        .sh_type == 7 as libc::c_int as libc::c_uint
                                                                                                                                                    {
                                                                                                                                                        _bfd_error_handler(
                                                                                                                                                            dcgettext(
                                                                                                                                                                b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                b"warning: section '%s' is being made into a note\0"
                                                                                                                                                                    as *const u8 as *const libc::c_char,
                                                                                                                                                                5 as libc::c_int,
                                                                                                                                                            ),
                                                                                                                                                            name_0,
                                                                                                                                                        );
                                                                                                                                                        bfd_set_error(bfd_error_nonrepresentable_section);
                                                                                                                                                        current_block = 10443503258980814984;
                                                                                                                                                        break;
                                                                                                                                                    } else {
                                                                                                                                                        dyn_0
                                                                                                                                                            .d_un
                                                                                                                                                            .d_ptr = ((*(*o).output_section).vma)
                                                                                                                                                            .wrapping_add((*o).output_offset);
                                                                                                                                                    }
                                                                                                                                                    current_block = 11297176373744872492;
                                                                                                                                                }
                                                                                                                                                _ => {}
                                                                                                                                            }
                                                                                                                                            match current_block {
                                                                                                                                                11297176373744872492 => {
                                                                                                                                                    ((*(*bed).s).swap_dyn_out)
                                                                                                                                                        .expect(
                                                                                                                                                            "non-null function pointer",
                                                                                                                                                        )(dynobj, &mut dyn_0, dyncon as *mut libc::c_void);
                                                                                                                                                }
                                                                                                                                                _ => {}
                                                                                                                                            }
                                                                                                                                            dyncon = dyncon
                                                                                                                                                .offset((*(*bed).s).sizeof_dyn as libc::c_int as isize);
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        current_block = 8155699268269024736;
                                                                                                                                    }
                                                                                                                                    match current_block {
                                                                                                                                        10443503258980814984 => {}
                                                                                                                                        _ => {
                                                                                                                                            if !dynobj.is_null() {
                                                                                                                                                if !(Some(
                                                                                                                                                    ((*bed).elf_backend_finish_dynamic_sections)
                                                                                                                                                        .expect("non-null function pointer"),
                                                                                                                                                ))
                                                                                                                                                    .expect("non-null function pointer")(abfd, info)
                                                                                                                                                {
                                                                                                                                                    current_block = 10443503258980814984;
                                                                                                                                                } else {
                                                                                                                                                    if (*info).textrel_check() as libc::c_int
                                                                                                                                                        != textrel_check_none as libc::c_int
                                                                                                                                                        && {
                                                                                                                                                            o = bfd_get_linker_section(
                                                                                                                                                                dynobj,
                                                                                                                                                                b".dynamic\0" as *const u8 as *const libc::c_char,
                                                                                                                                                            );
                                                                                                                                                            !o.is_null()
                                                                                                                                                        }
                                                                                                                                                    {
                                                                                                                                                        let mut dyncon_0: *mut bfd_byte = 0 as *mut bfd_byte;
                                                                                                                                                        let mut dynconend_0: *mut bfd_byte = 0 as *mut bfd_byte;
                                                                                                                                                        dyncon_0 = (*o).contents;
                                                                                                                                                        dynconend_0 = ((*o).contents).offset((*o).size as isize);
                                                                                                                                                        while dyncon_0 < dynconend_0 {
                                                                                                                                                            let mut dyn_1: Elf_Internal_Dyn = Elf_Internal_Dyn {
                                                                                                                                                                d_tag: 0,
                                                                                                                                                                d_un: C2RustUnnamed_21 { d_val: 0 },
                                                                                                                                                            };
                                                                                                                                                            ((*(*bed).s).swap_dyn_in)
                                                                                                                                                                .expect(
                                                                                                                                                                    "non-null function pointer",
                                                                                                                                                                )(dynobj, dyncon_0 as *const libc::c_void, &mut dyn_1);
                                                                                                                                                            if dyn_1.d_tag == 22 as libc::c_int as libc::c_ulong {
                                                                                                                                                                if (*info).textrel_check() as libc::c_int
                                                                                                                                                                    == textrel_check_error as libc::c_int
                                                                                                                                                                {
                                                                                                                                                                    ((*(*info).callbacks).einfo)
                                                                                                                                                                        .expect(
                                                                                                                                                                            "non-null function pointer",
                                                                                                                                                                        )(
                                                                                                                                                                        dcgettext(
                                                                                                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                            b"%P%X: read-only segment has dynamic relocations\n\0"
                                                                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                                                                            5 as libc::c_int,
                                                                                                                                                                        ),
                                                                                                                                                                    );
                                                                                                                                                                } else if (*info).type_0() as libc::c_int
                                                                                                                                                                    == type_dll as libc::c_int
                                                                                                                                                                {
                                                                                                                                                                    ((*(*info).callbacks).einfo)
                                                                                                                                                                        .expect(
                                                                                                                                                                            "non-null function pointer",
                                                                                                                                                                        )(
                                                                                                                                                                        dcgettext(
                                                                                                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                            b"%P: warning: creating DT_TEXTREL in a shared object\n\0"
                                                                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                                                                            5 as libc::c_int,
                                                                                                                                                                        ),
                                                                                                                                                                    );
                                                                                                                                                                } else if (*info).type_0() as libc::c_int
                                                                                                                                                                    == type_pde as libc::c_int
                                                                                                                                                                {
                                                                                                                                                                    ((*(*info).callbacks).einfo)
                                                                                                                                                                        .expect(
                                                                                                                                                                            "non-null function pointer",
                                                                                                                                                                        )(
                                                                                                                                                                        dcgettext(
                                                                                                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                            b"%P: warning: creating DT_TEXTREL in a PDE\n\0"
                                                                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                                                                            5 as libc::c_int,
                                                                                                                                                                        ),
                                                                                                                                                                    );
                                                                                                                                                                } else {
                                                                                                                                                                    ((*(*info).callbacks).einfo)
                                                                                                                                                                        .expect(
                                                                                                                                                                            "non-null function pointer",
                                                                                                                                                                        )(
                                                                                                                                                                        dcgettext(
                                                                                                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                            b"%P: warning: creating DT_TEXTREL in a PIE\n\0"
                                                                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                                                                            5 as libc::c_int,
                                                                                                                                                                        ),
                                                                                                                                                                    );
                                                                                                                                                                }
                                                                                                                                                                break;
                                                                                                                                                            } else {
                                                                                                                                                                dyncon_0 = dyncon_0
                                                                                                                                                                    .offset((*(*bed).s).sizeof_dyn as libc::c_int as isize);
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    o = (*dynobj).sections;
                                                                                                                                                    loop {
                                                                                                                                                        if o.is_null() {
                                                                                                                                                            current_block = 6031918995612662703;
                                                                                                                                                            break;
                                                                                                                                                        }
                                                                                                                                                        if !((*o).flags & 0x100 as libc::c_int as libc::c_uint
                                                                                                                                                            == 0 as libc::c_int as libc::c_uint
                                                                                                                                                            || (*o).size == 0 as libc::c_int as libc::c_ulong
                                                                                                                                                            || (*o).output_section
                                                                                                                                                                == &mut *_bfd_std_section
                                                                                                                                                                    .as_mut_ptr()
                                                                                                                                                                    .offset(2 as libc::c_int as isize) as *mut asection)
                                                                                                                                                        {
                                                                                                                                                            if !((*o).flags & 0x100000 as libc::c_int as libc::c_uint
                                                                                                                                                                == 0 as libc::c_int as libc::c_uint)
                                                                                                                                                            {
                                                                                                                                                                if !((*htab).stab_info.stabstr == o) {
                                                                                                                                                                    if !((*htab).eh_info.hdr_sec == o) {
                                                                                                                                                                        if strcmp(
                                                                                                                                                                            (*o).name,
                                                                                                                                                                            b".dynstr\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                        ) != 0 as libc::c_int
                                                                                                                                                                        {
                                                                                                                                                                            let mut octets: bfd_size_type = ((*o).output_offset
                                                                                                                                                                                as file_ptr * bfd_octets_per_byte(abfd, o) as libc::c_long)
                                                                                                                                                                                as bfd_size_type;
                                                                                                                                                                            if !bfd_set_section_contents(
                                                                                                                                                                                abfd,
                                                                                                                                                                                (*o).output_section,
                                                                                                                                                                                (*o).contents as *const libc::c_void,
                                                                                                                                                                                octets as file_ptr,
                                                                                                                                                                                (*o).size,
                                                                                                                                                                            ) {
                                                                                                                                                                                current_block = 10443503258980814984;
                                                                                                                                                                                break;
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                            let mut off_1: file_ptr = 0;
                                                                                                                                                                            off_1 = (*((*(*o).output_section).used_by_bfd
                                                                                                                                                                                as *mut bfd_elf_section_data))
                                                                                                                                                                                .this_hdr
                                                                                                                                                                                .sh_offset;
                                                                                                                                                                            if bfd_seek(abfd, off_1, 0 as libc::c_int)
                                                                                                                                                                                != 0 as libc::c_int
                                                                                                                                                                                || !_bfd_elf_strtab_emit(abfd, (*htab).dynstr)
                                                                                                                                                                            {
                                                                                                                                                                                current_block = 10443503258980814984;
                                                                                                                                                                                break;
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        o = (*o).next;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                current_block = 6031918995612662703;
                                                                                                                                            }
                                                                                                                                            match current_block {
                                                                                                                                                10443503258980814984 => {}
                                                                                                                                                _ => {
                                                                                                                                                    if (*info).resolve_section_groups() == 0 {
                                                                                                                                                        let mut failed: bool = 0 as libc::c_int != 0;
                                                                                                                                                        if !((*info).type_0() as libc::c_int
                                                                                                                                                            == type_relocatable as libc::c_int)
                                                                                                                                                        {
                                                                                                                                                            bfd_assert(
                                                                                                                                                                b"elflink.c\0" as *const u8 as *const libc::c_char,
                                                                                                                                                                13194 as libc::c_int,
                                                                                                                                                            );
                                                                                                                                                        }
                                                                                                                                                        bfd_map_over_sections(
                                                                                                                                                            abfd,
                                                                                                                                                            Some(
                                                                                                                                                                bfd_elf_set_group_contents
                                                                                                                                                                    as unsafe extern "C" fn(
                                                                                                                                                                        *mut bfd,
                                                                                                                                                                        *mut asection,
                                                                                                                                                                        *mut libc::c_void,
                                                                                                                                                                    ) -> (),
                                                                                                                                                            ),
                                                                                                                                                            &mut failed as *mut bool as *mut libc::c_void,
                                                                                                                                                        );
                                                                                                                                                        if failed {
                                                                                                                                                            current_block = 10443503258980814984;
                                                                                                                                                        } else {
                                                                                                                                                            current_block = 7381833562023054431;
                                                                                                                                                        }
                                                                                                                                                    } else {
                                                                                                                                                        current_block = 7381833562023054431;
                                                                                                                                                    }
                                                                                                                                                    match current_block {
                                                                                                                                                        10443503258980814984 => {}
                                                                                                                                                        _ => {
                                                                                                                                                            if !((*htab).stab_info.stabstr).is_null() {
                                                                                                                                                                if !_bfd_write_stab_strings(abfd, &mut (*htab).stab_info) {
                                                                                                                                                                    current_block = 10443503258980814984;
                                                                                                                                                                } else {
                                                                                                                                                                    current_block = 873127498622619052;
                                                                                                                                                                }
                                                                                                                                                            } else {
                                                                                                                                                                current_block = 873127498622619052;
                                                                                                                                                            }
                                                                                                                                                            match current_block {
                                                                                                                                                                10443503258980814984 => {}
                                                                                                                                                                _ => {
                                                                                                                                                                    if !_bfd_elf_write_section_eh_frame_hdr(abfd, info) {
                                                                                                                                                                        current_block = 10443503258980814984;
                                                                                                                                                                    } else {
                                                                                                                                                                        if ((*(*info).callbacks).emit_ctf).is_some() {
                                                                                                                                                                            ((*(*info).callbacks).emit_ctf)
                                                                                                                                                                                .expect("non-null function pointer")();
                                                                                                                                                                        }
                                                                                                                                                                        elf_final_link_free(abfd, &mut flinfo);
                                                                                                                                                                        if !attr_section.is_null() {
                                                                                                                                                                            let mut contents_0: *mut bfd_byte = bfd_malloc(attr_size)
                                                                                                                                                                                as *mut bfd_byte;
                                                                                                                                                                            if contents_0.is_null() {
                                                                                                                                                                                ret = 0 as libc::c_int != 0;
                                                                                                                                                                            } else {
                                                                                                                                                                                bfd_elf_set_obj_attr_contents(abfd, contents_0, attr_size);
                                                                                                                                                                                bfd_set_section_contents(
                                                                                                                                                                                    abfd,
                                                                                                                                                                                    attr_section,
                                                                                                                                                                                    contents_0 as *const libc::c_void,
                                                                                                                                                                                    0 as libc::c_int as file_ptr,
                                                                                                                                                                                    attr_size,
                                                                                                                                                                                );
                                                                                                                                                                                free(contents_0 as *mut libc::c_void);
                                                                                                                                                                            }
                                                                                                                                                                            current_block = 6681060674233533360;
                                                                                                                                                                        } else {
                                                                                                                                                                            current_block = 6681060674233533360;
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        10443503258980814984 => {
            elf_final_link_free(abfd, &mut flinfo);
            ret = 0 as libc::c_int != 0;
        }
        _ => {}
    }
    if (*info).unique_symbol() != 0 {
        bfd_hash_table_free(&mut flinfo.local_hash_table);
    }
    return ret;
}
unsafe extern "C" fn init_reloc_cookie(
    mut cookie: *mut elf_reloc_cookie,
    mut info: *mut bfd_link_info,
    mut abfd: *mut bfd,
) -> bool {
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    symtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    (*cookie).abfd = abfd;
    (*cookie).sym_hashes = (*(*abfd).tdata.elf_obj_data).sym_hashes;
    (*cookie).bad_symtab = (*(*abfd).tdata.elf_obj_data).bad_symtab() != 0;
    if (*cookie).bad_symtab {
        (*cookie)
            .locsymcount = ((*symtab_hdr).sh_size)
            .wrapping_div((*(*bed).s).sizeof_sym as libc::c_ulong);
        (*cookie).extsymoff = 0 as libc::c_int as size_t;
    } else {
        (*cookie).locsymcount = (*symtab_hdr).sh_info as size_t;
        (*cookie).extsymoff = (*symtab_hdr).sh_info as size_t;
    }
    if (*(*bed).s).arch_size as libc::c_int == 32 as libc::c_int {
        (*cookie).r_sym_shift = 8 as libc::c_int;
    } else {
        (*cookie).r_sym_shift = 32 as libc::c_int;
    }
    (*cookie).locsyms = (*symtab_hdr).contents as *mut Elf_Internal_Sym;
    if ((*cookie).locsyms).is_null()
        && (*cookie).locsymcount != 0 as libc::c_int as libc::c_ulong
    {
        (*cookie)
            .locsyms = bfd_elf_get_elf_syms(
            abfd,
            symtab_hdr,
            (*cookie).locsymcount,
            0 as libc::c_int as size_t,
            0 as *mut Elf_Internal_Sym,
            0 as *mut libc::c_void,
            0 as *mut Elf_External_Sym_Shndx,
        );
        if ((*cookie).locsyms).is_null() {
            ((*(*info).callbacks).einfo)
                .expect(
                    "non-null function pointer",
                )(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%P%X: can not read symbols: %E\n\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
            );
            return 0 as libc::c_int != 0;
        }
        if (*info).keep_memory() != 0 {
            (*symtab_hdr).contents = (*cookie).locsyms as *mut bfd_byte;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn fini_reloc_cookie(
    mut cookie: *mut elf_reloc_cookie,
    mut abfd: *mut bfd,
) {
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    symtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    if (*symtab_hdr).contents != (*cookie).locsyms as *mut libc::c_uchar {
        free((*cookie).locsyms as *mut libc::c_void);
    }
}
unsafe extern "C" fn init_reloc_cookie_rels(
    mut cookie: *mut elf_reloc_cookie,
    mut info: *mut bfd_link_info,
    mut abfd: *mut bfd,
    mut sec: *mut asection,
) -> bool {
    if (*sec).reloc_count == 0 as libc::c_int as libc::c_uint {
        (*cookie).rels = 0 as *mut Elf_Internal_Rela;
        (*cookie).relend = 0 as *mut Elf_Internal_Rela;
    } else {
        (*cookie)
            .rels = _bfd_elf_link_read_relocs(
            abfd,
            sec,
            0 as *mut libc::c_void,
            0 as *mut Elf_Internal_Rela,
            (*info).keep_memory() != 0,
        );
        if ((*cookie).rels).is_null() {
            return 0 as libc::c_int != 0;
        }
        (*cookie).rel = (*cookie).rels;
        (*cookie).relend = ((*cookie).rels).offset((*sec).reloc_count as isize);
    }
    (*cookie).rel = (*cookie).rels;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn fini_reloc_cookie_rels(
    mut cookie: *mut elf_reloc_cookie,
    mut sec: *mut asection,
) {
    if (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).relocs != (*cookie).rels {
        free((*cookie).rels as *mut libc::c_void);
    }
}
unsafe extern "C" fn init_reloc_cookie_for_section(
    mut cookie: *mut elf_reloc_cookie,
    mut info: *mut bfd_link_info,
    mut sec: *mut asection,
) -> bool {
    if init_reloc_cookie(cookie, info, (*sec).owner) {
        if !init_reloc_cookie_rels(cookie, info, (*sec).owner, sec) {
            fini_reloc_cookie(cookie, (*sec).owner);
        } else {
            return 1 as libc::c_int != 0
        }
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn fini_reloc_cookie_for_section(
    mut cookie: *mut elf_reloc_cookie,
    mut sec: *mut asection,
) {
    fini_reloc_cookie_rels(cookie, sec);
    fini_reloc_cookie(cookie, (*sec).owner);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_gc_mark_hook(
    mut sec: *mut asection,
    mut _info: *mut bfd_link_info,
    mut _rel: *mut Elf_Internal_Rela,
    mut h: *mut elf_link_hash_entry,
    mut sym: *mut Elf_Internal_Sym,
) -> *mut asection {
    if !h.is_null() {
        match ((*h).root).type_0() as libc::c_int {
            3 | 4 => return (*h).root.u.def.section,
            5 => return (*(*h).root.u.c.p).section,
            _ => {}
        }
    } else {
        return bfd_section_from_elf_index((*sec).owner, (*sym).st_shndx)
    }
    return 0 as *mut asection;
}
unsafe extern "C" fn elf_gc_mark_debug_section(
    mut sec: *mut asection,
    mut _info: *mut bfd_link_info,
    mut _rel: *mut Elf_Internal_Rela,
    mut h: *mut elf_link_hash_entry,
    mut sym: *mut Elf_Internal_Sym,
) -> *mut asection {
    if !h.is_null() {
        if (((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defweak as libc::c_int)
            && (*(*h).root.u.def.section).flags & 0x2000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
        {
            return (*h).root.u.def.section;
        }
    } else {
        let mut isec: *mut asection = bfd_section_from_elf_index(
            (*sec).owner,
            (*sym).st_shndx,
        );
        if (*isec).flags & 0x2000 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        {
            return isec;
        }
    }
    return 0 as *mut asection;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_gc_mark_rsec(
    mut info: *mut bfd_link_info,
    mut sec: *mut asection,
    mut gc_mark_hook: elf_gc_mark_hook_fn,
    mut cookie: *mut elf_reloc_cookie,
    mut start_stop: *mut bool,
) -> *mut asection {
    let mut r_symndx: libc::c_ulong = 0;
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut hw: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    r_symndx = (*(*cookie).rel).r_info >> (*cookie).r_sym_shift;
    if r_symndx == 0 as libc::c_int as libc::c_ulong {
        return 0 as *mut asection;
    }
    if r_symndx >= (*cookie).locsymcount
        || (*((*cookie).locsyms).offset(r_symndx as isize)).st_info as libc::c_uint
            >> 4 as libc::c_int != 0 as libc::c_int as libc::c_uint
    {
        let mut was_marked: bool = false;
        h = *((*cookie).sym_hashes)
            .offset(r_symndx.wrapping_sub((*cookie).extsymoff) as isize);
        if h.is_null() {
            ((*(*info).callbacks).einfo)
                .expect(
                    "non-null function pointer",
                )(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%F%P: corrupt input: %pB\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*sec).owner,
            );
            return 0 as *mut asection;
        }
        while ((*h).root).type_0() as libc::c_int
            == bfd_link_hash_indirect as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_warning as libc::c_int
        {
            h = (*h).root.u.i.link as *mut elf_link_hash_entry;
        }
        was_marked = (*h).mark() != 0;
        (*h).set_mark(1 as libc::c_int as libc::c_uint);
        hw = h;
        while (*hw).is_weakalias() != 0 {
            hw = (*hw).u.alias;
            (*hw).set_mark(1 as libc::c_int as libc::c_uint);
        }
        if !was_marked && (*h).start_stop() as libc::c_int != 0
            && ((*h).root).ldscript_def() == 0
        {
            if (*info).start_stop_gc != 0 {
                return 0 as *mut asection
            } else if !start_stop.is_null() {
                let mut s: *mut asection = (*h).u2.start_stop_section;
                *start_stop = 1 as libc::c_int != 0;
                return s;
            }
        }
        return (Some(gc_mark_hook.expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(sec, info, (*cookie).rel, h, 0 as *mut Elf_Internal_Sym);
    }
    return (Some(gc_mark_hook.expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        sec,
        info,
        (*cookie).rel,
        0 as *mut elf_link_hash_entry,
        &mut *((*cookie).locsyms).offset(r_symndx as isize),
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_gc_mark_reloc(
    mut info: *mut bfd_link_info,
    mut sec: *mut asection,
    mut gc_mark_hook: elf_gc_mark_hook_fn,
    mut cookie: *mut elf_reloc_cookie,
) -> bool {
    let mut rsec: *mut asection = 0 as *mut asection;
    let mut start_stop: bool = 0 as libc::c_int != 0;
    rsec = _bfd_elf_gc_mark_rsec(info, sec, gc_mark_hook, cookie, &mut start_stop);
    while !rsec.is_null() {
        if (*rsec).gc_mark() == 0 {
            if bfd_get_flavour((*rsec).owner) as libc::c_uint
                != bfd_target_elf_flavour as libc::c_int as libc::c_uint
                || (*(*rsec).owner).flags & 0x40 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
            {
                (*rsec).set_gc_mark(1 as libc::c_int as libc::c_uint);
            } else if !_bfd_elf_gc_mark(info, rsec, gc_mark_hook) {
                return 0 as libc::c_int != 0
            }
        }
        if !start_stop {
            break;
        }
        rsec = bfd_get_next_section_by_name((*rsec).owner, rsec);
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_gc_mark(
    mut info: *mut bfd_link_info,
    mut sec: *mut asection,
    mut gc_mark_hook: elf_gc_mark_hook_fn,
) -> bool {
    let mut ret: bool = false;
    let mut group_sec: *mut asection = 0 as *mut asection;
    let mut eh_frame: *mut asection = 0 as *mut asection;
    (*sec).set_gc_mark(1 as libc::c_int as libc::c_uint);
    group_sec = (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
    if !group_sec.is_null() && (*group_sec).gc_mark() == 0 {
        if !_bfd_elf_gc_mark(info, group_sec, gc_mark_hook) {
            return 0 as libc::c_int != 0;
        }
    }
    ret = 1 as libc::c_int != 0;
    eh_frame = (*(*(*sec).owner).tdata.elf_obj_data).eh_frame_section;
    if (*sec).flags & 0x4 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
        && (*sec).reloc_count > 0 as libc::c_int as libc::c_uint && sec != eh_frame
    {
        let mut cookie: elf_reloc_cookie = elf_reloc_cookie {
            rels: 0 as *mut Elf_Internal_Rela,
            rel: 0 as *mut Elf_Internal_Rela,
            relend: 0 as *mut Elf_Internal_Rela,
            locsyms: 0 as *mut Elf_Internal_Sym,
            abfd: 0 as *mut bfd,
            locsymcount: 0,
            extsymoff: 0,
            sym_hashes: 0 as *mut *mut elf_link_hash_entry,
            r_sym_shift: 0,
            bad_symtab: false,
        };
        if !init_reloc_cookie_for_section(&mut cookie, info, sec) {
            ret = 0 as libc::c_int != 0;
        } else {
            while cookie.rel < cookie.relend {
                if !_bfd_elf_gc_mark_reloc(info, sec, gc_mark_hook, &mut cookie) {
                    ret = 0 as libc::c_int != 0;
                    break;
                } else {
                    cookie.rel = (cookie.rel).offset(1);
                    cookie.rel;
                }
            }
            fini_reloc_cookie_for_section(&mut cookie, sec);
        }
    }
    if ret as libc::c_int != 0 && !eh_frame.is_null()
        && !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).fde_list).is_null()
    {
        let mut cookie_0: elf_reloc_cookie = elf_reloc_cookie {
            rels: 0 as *mut Elf_Internal_Rela,
            rel: 0 as *mut Elf_Internal_Rela,
            relend: 0 as *mut Elf_Internal_Rela,
            locsyms: 0 as *mut Elf_Internal_Sym,
            abfd: 0 as *mut bfd,
            locsymcount: 0,
            extsymoff: 0,
            sym_hashes: 0 as *mut *mut elf_link_hash_entry,
            r_sym_shift: 0,
            bad_symtab: false,
        };
        if !init_reloc_cookie_for_section(&mut cookie_0, info, eh_frame) {
            ret = 0 as libc::c_int != 0;
        } else {
            if !_bfd_elf_gc_mark_fdes(info, sec, eh_frame, gc_mark_hook, &mut cookie_0) {
                ret = 0 as libc::c_int != 0;
            }
            fini_reloc_cookie_for_section(&mut cookie_0, eh_frame);
        }
    }
    eh_frame = (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).eh_frame_entry;
    if ret as libc::c_int != 0 && !eh_frame.is_null() && (*eh_frame).gc_mark() == 0 {
        if !_bfd_elf_gc_mark(info, eh_frame, gc_mark_hook) {
            ret = 0 as libc::c_int != 0;
        }
    }
    return ret;
}
unsafe extern "C" fn _bfd_elf_gc_mark_debug_special_section_group(
    mut grp: *mut asection,
) {
    let mut ssec: *mut asection = 0 as *mut asection;
    let mut msec: *mut asection = 0 as *mut asection;
    let mut is_special_grp: bool = 1 as libc::c_int != 0;
    let mut is_debug_grp: bool = 1 as libc::c_int != 0;
    msec = (*((*grp).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
    ssec = msec;
    loop {
        if (*msec).flags & 0x2000 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        {
            is_debug_grp = 0 as libc::c_int != 0;
        }
        if (*msec).flags
            & (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int)
                as libc::c_uint != 0 as libc::c_int as libc::c_uint
        {
            is_special_grp = 0 as libc::c_int != 0;
        }
        msec = (*((*msec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
        if !(msec != ssec) {
            break;
        }
    }
    if is_debug_grp as libc::c_int != 0 || is_special_grp as libc::c_int != 0 {
        loop {
            (*msec).set_gc_mark(1 as libc::c_int as libc::c_uint);
            msec = (*((*msec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
            if !(msec != ssec) {
                break;
            }
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_gc_mark_extra_sections(
    mut info: *mut bfd_link_info,
    mut mark_hook: elf_gc_mark_hook_fn,
) -> bool {
    let mut ibfd: *mut bfd = 0 as *mut bfd;
    ibfd = (*info).input_bfds;
    while !ibfd.is_null() {
        let mut isec: *mut asection = 0 as *mut asection;
        let mut some_kept: bool = false;
        let mut debug_frag_seen: bool = false;
        let mut has_kept_debug_info: bool = false;
        if !(bfd_get_flavour(ibfd) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint)
        {
            isec = (*ibfd).sections;
            if !(isec.is_null()
                || (*isec).sec_info_type() as libc::c_int == 4 as libc::c_int)
            {
                has_kept_debug_info = 0 as libc::c_int != 0;
                some_kept = has_kept_debug_info;
                debug_frag_seen = some_kept;
                isec = (*ibfd).sections;
                while !isec.is_null() {
                    if (*isec).flags & 0x100000 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        (*isec).set_gc_mark(1 as libc::c_int as libc::c_uint);
                    } else if (*isec).gc_mark() as libc::c_int != 0
                        && (*isec).flags & 0x1 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        && (*((*isec).used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_type != 7 as libc::c_int as libc::c_uint
                    {
                        some_kept = 1 as libc::c_int != 0;
                    } else {
                        let mut linked_to_sec: *mut asection = 0 as *mut asection;
                        linked_to_sec = (*((*isec).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .linked_to;
                        while !linked_to_sec.is_null()
                            && (*linked_to_sec).linker_mark() == 0
                        {
                            if (*linked_to_sec).gc_mark() != 0 {
                                if !_bfd_elf_gc_mark(info, isec, mark_hook) {
                                    return 0 as libc::c_int != 0;
                                }
                                break;
                            } else {
                                (*linked_to_sec)
                                    .set_linker_mark(1 as libc::c_int as libc::c_uint);
                                linked_to_sec = (*((*linked_to_sec).used_by_bfd
                                    as *mut bfd_elf_section_data))
                                    .linked_to;
                            }
                        }
                        linked_to_sec = (*((*isec).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .linked_to;
                        while !linked_to_sec.is_null()
                            && (*linked_to_sec).linker_mark() as libc::c_int != 0
                        {
                            (*linked_to_sec)
                                .set_linker_mark(0 as libc::c_int as libc::c_uint);
                            linked_to_sec = (*((*linked_to_sec).used_by_bfd
                                as *mut bfd_elf_section_data))
                                .linked_to;
                        }
                    }
                    if !debug_frag_seen
                        && (*isec).flags & 0x2000 as libc::c_int as libc::c_uint != 0
                        && startswith(
                            (*isec).name,
                            b".debug_line.\0" as *const u8 as *const libc::c_char,
                        ) as libc::c_int != 0
                    {
                        debug_frag_seen = 1 as libc::c_int != 0;
                    } else if strcmp(
                        bfd_section_name(isec),
                        b"__patchable_function_entries\0" as *const u8
                            as *const libc::c_char,
                    ) == 0 as libc::c_int
                        && ((*((*isec).used_by_bfd as *mut bfd_elf_section_data))
                            .linked_to)
                            .is_null()
                    {
                        ((*(*info).callbacks).einfo)
                            .expect(
                                "non-null function pointer",
                            )(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%F%P: %pB(%pA): error: need linked-to section for --gc-sections\n\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*isec).owner,
                            isec,
                        );
                    }
                    isec = (*isec).next;
                }
                if some_kept {
                    isec = (*ibfd).sections;
                    while !isec.is_null() {
                        if (*isec).flags & 0x2000000 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_elf_gc_mark_debug_special_section_group(isec);
                        } else if ((*isec).flags & 0x2000 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                            || (*isec).flags
                                & (0x1 as libc::c_int | 0x2 as libc::c_int
                                    | 0x4 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint)
                            && ((*((*isec).used_by_bfd as *mut bfd_elf_section_data))
                                .next_in_group)
                                .is_null()
                            && ((*((*isec).used_by_bfd as *mut bfd_elf_section_data))
                                .linked_to)
                                .is_null()
                        {
                            (*isec).set_gc_mark(1 as libc::c_int as libc::c_uint);
                        }
                        if (*isec).gc_mark() as libc::c_int != 0
                            && (*isec).flags & 0x2000 as libc::c_int as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                        {
                            has_kept_debug_info = 1 as libc::c_int != 0;
                        }
                        isec = (*isec).next;
                    }
                    if debug_frag_seen {
                        isec = (*ibfd).sections;
                        while !isec.is_null() {
                            if (*isec).flags & 0x10 as libc::c_int as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*isec).gc_mark() as libc::c_int == 0 as libc::c_int
                            {
                                let mut ilen: libc::c_uint = 0;
                                let mut dsec: *mut asection = 0 as *mut asection;
                                ilen = strlen((*isec).name) as libc::c_uint;
                                dsec = (*ibfd).sections;
                                while !dsec.is_null() {
                                    let mut dlen: libc::c_uint = 0;
                                    if !((*dsec).gc_mark() as libc::c_int == 0 as libc::c_int
                                        || (*dsec).flags & 0x2000 as libc::c_int as libc::c_uint
                                            == 0 as libc::c_int as libc::c_uint)
                                    {
                                        dlen = strlen((*dsec).name) as libc::c_uint;
                                        if dlen > ilen
                                            && strncmp(
                                                ((*dsec).name).offset(dlen.wrapping_sub(ilen) as isize),
                                                (*isec).name,
                                                ilen as libc::c_ulong,
                                            ) == 0 as libc::c_int
                                        {
                                            (*dsec).set_gc_mark(0 as libc::c_int as libc::c_uint);
                                        }
                                    }
                                    dsec = (*dsec).next;
                                }
                            }
                            isec = (*isec).next;
                        }
                    }
                    if has_kept_debug_info {
                        isec = (*ibfd).sections;
                        while !isec.is_null() {
                            if (*isec).gc_mark() as libc::c_int != 0
                                && (*isec).flags & 0x2000 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                            {
                                if !_bfd_elf_gc_mark(
                                    info,
                                    isec,
                                    Some(
                                        elf_gc_mark_debug_section
                                            as unsafe extern "C" fn(
                                                *mut asection,
                                                *mut bfd_link_info,
                                                *mut Elf_Internal_Rela,
                                                *mut elf_link_hash_entry,
                                                *mut Elf_Internal_Sym,
                                            ) -> *mut asection,
                                    ),
                                ) {
                                    return 0 as libc::c_int != 0;
                                }
                            }
                            isec = (*isec).next;
                        }
                    }
                }
            }
        }
        ibfd = (*ibfd).link.next;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_gc_sweep(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut sub: *mut bfd = 0 as *mut bfd;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    sub = (*info).input_bfds;
    while !sub.is_null() {
        let mut o: *mut asection = 0 as *mut asection;
        if !(bfd_get_flavour(sub) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
            || (*(*sub).tdata.elf_obj_data).object_id() as libc::c_uint
                != elf_hash_table_id(elf_hash_table(info)) as libc::c_uint
            || !(Some(((*bed).relocs_compatible).expect("non-null function pointer")))
                .expect("non-null function pointer")((*sub).xvec, (*abfd).xvec))
        {
            o = (*sub).sections;
            if !(o.is_null() || (*o).sec_info_type() as libc::c_int == 4 as libc::c_int)
            {
                o = (*sub).sections;
                while !o.is_null() {
                    if (*o).flags & 0x2000000 as libc::c_int as libc::c_uint != 0 {
                        let mut first: *mut asection = (*((*o).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .next_in_group;
                        (*o).set_gc_mark((*first).gc_mark());
                    }
                    if !((*o).gc_mark() != 0) {
                        if !((*o).flags & 0x8000 as libc::c_int as libc::c_uint != 0) {
                            (*o).flags |= 0x8000 as libc::c_int as libc::c_uint;
                            if (*info).print_gc_sections() as libc::c_int != 0
                                && (*o).size != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"removing unused section '%pA' in file '%pB'\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    o,
                                    sub,
                                );
                            }
                        }
                    }
                    o = (*o).next;
                }
            }
        }
        sub = (*sub).link.next;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_gc_propagate_vtable_entries_used(
    mut h: *mut elf_link_hash_entry,
    mut okp: *mut libc::c_void,
) -> bool {
    if (*h).start_stop() as libc::c_int != 0 || ((*h).u2.vtable).is_null()
        || ((*(*h).u2.vtable).parent).is_null()
    {
        return 1 as libc::c_int != 0;
    }
    if (*(*h).u2.vtable).parent == -(1 as libc::c_int) as *mut elf_link_hash_entry {
        return 1 as libc::c_int != 0;
    }
    if !((*(*h).u2.vtable).used).is_null()
        && *((*(*h).u2.vtable).used).offset(-(1 as libc::c_int) as isize) as libc::c_int
            != 0
    {
        return 1 as libc::c_int != 0;
    }
    elf_gc_propagate_vtable_entries_used((*(*h).u2.vtable).parent, okp);
    if ((*(*h).u2.vtable).used).is_null() {
        (*(*h).u2.vtable).used = (*(*(*(*h).u2.vtable).parent).u2.vtable).used;
        (*(*h).u2.vtable).size = (*(*(*(*h).u2.vtable).parent).u2.vtable).size;
    } else {
        let mut n: size_t = 0;
        let mut cu: *mut bool = 0 as *mut bool;
        let mut pu: *mut bool = 0 as *mut bool;
        cu = (*(*h).u2.vtable).used;
        *cu.offset(-(1 as libc::c_int) as isize) = 1 as libc::c_int != 0;
        pu = (*(*(*(*h).u2.vtable).parent).u2.vtable).used;
        if !pu.is_null() {
            let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
            let mut log_file_align: libc::c_uint = 0;
            bed = (*(*(*(*h).root.u.def.section).owner).xvec).backend_data
                as *const elf_backend_data;
            log_file_align = (*(*bed).s).log_file_align as libc::c_uint;
            n = (*(*(*(*h).u2.vtable).parent).u2.vtable).size >> log_file_align;
            loop {
                let fresh41 = n;
                n = n.wrapping_sub(1);
                if !(fresh41 != 0) {
                    break;
                }
                if *pu {
                    *cu = 1 as libc::c_int != 0;
                }
                pu = pu.offset(1);
                pu;
                cu = cu.offset(1);
                cu;
            }
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_gc_smash_unused_vtentry_relocs(
    mut h: *mut elf_link_hash_entry,
    mut okp: *mut libc::c_void,
) -> bool {
    let mut sec: *mut asection = 0 as *mut asection;
    let mut hstart: bfd_vma = 0;
    let mut hend: bfd_vma = 0;
    let mut relstart: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut relend: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut rel: *mut Elf_Internal_Rela = 0 as *mut Elf_Internal_Rela;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut log_file_align: libc::c_uint = 0;
    if (*h).start_stop() as libc::c_int != 0 || ((*h).u2.vtable).is_null()
        || ((*(*h).u2.vtable).parent).is_null()
    {
        return 1 as libc::c_int != 0;
    }
    if !(((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_defweak as libc::c_int)
    {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            13901 as libc::c_int,
        );
    }
    sec = (*h).root.u.def.section;
    hstart = (*h).root.u.def.value;
    hend = hstart.wrapping_add((*h).size);
    relstart = _bfd_elf_link_read_relocs(
        (*sec).owner,
        sec,
        0 as *mut libc::c_void,
        0 as *mut Elf_Internal_Rela,
        1 as libc::c_int != 0,
    );
    if relstart.is_null() {
        let ref mut fresh42 = *(okp as *mut bool);
        *fresh42 = 0 as libc::c_int != 0;
        return *fresh42;
    }
    bed = (*(*(*sec).owner).xvec).backend_data as *const elf_backend_data;
    log_file_align = (*(*bed).s).log_file_align as libc::c_uint;
    relend = relstart.offset((*sec).reloc_count as isize);
    let mut current_block_16: u64;
    rel = relstart;
    while rel < relend {
        if (*rel).r_offset >= hstart && (*rel).r_offset < hend {
            if !((*(*h).u2.vtable).used).is_null()
                && ((*rel).r_offset).wrapping_sub(hstart) < (*(*h).u2.vtable).size
            {
                let mut entry: bfd_vma = ((*rel).r_offset).wrapping_sub(hstart)
                    >> log_file_align;
                if *((*(*h).u2.vtable).used).offset(entry as isize) {
                    current_block_16 = 13586036798005543211;
                } else {
                    current_block_16 = 15652330335145281839;
                }
            } else {
                current_block_16 = 15652330335145281839;
            }
            match current_block_16 {
                13586036798005543211 => {}
                _ => {
                    (*rel).r_addend = 0 as libc::c_int as bfd_vma;
                    (*rel).r_info = (*rel).r_addend;
                    (*rel).r_offset = (*rel).r_info;
                }
            }
        }
        rel = rel.offset(1);
        rel;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_gc_mark_dynamic_ref_symbol(
    mut h: *mut elf_link_hash_entry,
    mut inf: *mut libc::c_void,
) -> bool {
    let mut info: *mut bfd_link_info = inf as *mut bfd_link_info;
    let mut d: *mut bfd_elf_dynamic_list = (*info).dynamic_list;
    if (((*h).root).type_0() as libc::c_int == bfd_link_hash_defined as libc::c_int
        || ((*h).root).type_0() as libc::c_int == bfd_link_hash_defweak as libc::c_int)
        && ((*h).start_stop() == 0 || ((*h).root).ldscript_def() as libc::c_int != 0
            || (*info).start_stop_gc == 0)
        && ((*h).ref_dynamic() as libc::c_int != 0 && (*h).forced_local() == 0
            || ((*h).def_regular() as libc::c_int != 0
                || (*h).def_regular() == 0 && (*h).def_dynamic() == 0
                    && ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_defined as libc::c_int)
                && (*h).other() as libc::c_int & 0x3 as libc::c_int != 1 as libc::c_int
                && (*h).other() as libc::c_int & 0x3 as libc::c_int != 2 as libc::c_int
                && (!((*info).type_0() as libc::c_int == type_pde as libc::c_int
                    || (*info).type_0() as libc::c_int == type_pie as libc::c_int)
                    || (*info).gc_keep_exported() as libc::c_int != 0
                    || (*info).export_dynamic() as libc::c_int != 0
                    || (*h).dynamic() as libc::c_int != 0 && !d.is_null()
                        && !((Some(((*d).match_0).expect("non-null function pointer")))
                            .expect(
                                "non-null function pointer",
                            )(
                            &mut (*d).head,
                            0 as *mut bfd_elf_version_expr,
                            (*h).root.root.string,
                        ))
                            .is_null())
                && ((*h).versioned() as libc::c_int >= versioned as libc::c_int
                    || !bfd_hide_sym_by_version(
                        (*info).version_info,
                        (*h).root.root.string,
                    )))
    {
        (*(*h).root.u.def.section).flags |= 0x200000 as libc::c_int as libc::c_uint;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_gc_keep(mut info: *mut bfd_link_info) {
    let mut sym: *mut bfd_sym_chain = 0 as *mut bfd_sym_chain;
    sym = (*info).gc_sym_list;
    while !sym.is_null() {
        let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
        h = elf_link_hash_lookup(
            elf_hash_table(info),
            (*sym).name,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
        );
        if !h.is_null()
            && (((*h).root).type_0() as libc::c_int
                == bfd_link_hash_defined as libc::c_int
                || ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_defweak as libc::c_int)
            && !bfd_is_const_section((*h).root.u.def.section)
        {
            (*(*h).root.u.def.section).flags |= 0x200000 as libc::c_int as libc::c_uint;
        }
        sym = (*sym).next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_parse_eh_frame_entries(
    mut _abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut ibfd: *mut bfd = (*info).input_bfds;
    ibfd = (*info).input_bfds;
    while !ibfd.is_null() {
        let mut sec: *mut asection = 0 as *mut asection;
        let mut cookie: elf_reloc_cookie = elf_reloc_cookie {
            rels: 0 as *mut Elf_Internal_Rela,
            rel: 0 as *mut Elf_Internal_Rela,
            relend: 0 as *mut Elf_Internal_Rela,
            locsyms: 0 as *mut Elf_Internal_Sym,
            abfd: 0 as *mut bfd,
            locsymcount: 0,
            extsymoff: 0,
            sym_hashes: 0 as *mut *mut elf_link_hash_entry,
            r_sym_shift: 0,
            bad_symtab: false,
        };
        if !(bfd_get_flavour(ibfd) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint)
        {
            sec = (*ibfd).sections;
            if !(sec.is_null()
                || (*sec).sec_info_type() as libc::c_int == 4 as libc::c_int)
            {
                if !init_reloc_cookie(&mut cookie, info, ibfd) {
                    return 0 as libc::c_int != 0;
                }
                sec = (*ibfd).sections;
                while !sec.is_null() {
                    if startswith(
                        bfd_section_name(sec),
                        b".eh_frame_entry\0" as *const u8 as *const libc::c_char,
                    ) as libc::c_int != 0
                        && init_reloc_cookie_rels(&mut cookie, info, ibfd, sec)
                            as libc::c_int != 0
                    {
                        _bfd_elf_parse_eh_frame_entry(info, sec, &mut cookie);
                        fini_reloc_cookie_rels(&mut cookie, sec);
                    }
                    sec = (*sec).next;
                }
            }
        }
        ibfd = (*ibfd).link.next;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_gc_sections(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut ok: bool = 1 as libc::c_int != 0;
    let mut sub: *mut bfd = 0 as *mut bfd;
    let mut gc_mark_hook: elf_gc_mark_hook_fn = None;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut htab: *mut elf_link_hash_table = 0 as *mut elf_link_hash_table;
    if (*bed).can_gc_sections() == 0 || !is_elf_hash_table((*info).hash) {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"warning: gc-sections option ignored\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        return 1 as libc::c_int != 0;
    }
    ((*bed).gc_keep).expect("non-null function pointer")(info);
    htab = elf_hash_table(info);
    sub = (*info).input_bfds;
    while (*info).eh_frame_hdr_type() as libc::c_int != 2 as libc::c_int
        && !sub.is_null()
    {
        let mut sec: *mut asection = 0 as *mut asection;
        let mut cookie: elf_reloc_cookie = elf_reloc_cookie {
            rels: 0 as *mut Elf_Internal_Rela,
            rel: 0 as *mut Elf_Internal_Rela,
            relend: 0 as *mut Elf_Internal_Rela,
            locsyms: 0 as *mut Elf_Internal_Sym,
            abfd: 0 as *mut bfd,
            locsymcount: 0,
            extsymoff: 0,
            sym_hashes: 0 as *mut *mut elf_link_hash_entry,
            r_sym_shift: 0,
            bad_symtab: false,
        };
        sec = (*sub).sections;
        if !(sec.is_null() || (*sec).sec_info_type() as libc::c_int == 4 as libc::c_int)
        {
            sec = bfd_get_section_by_name(
                sub,
                b".eh_frame\0" as *const u8 as *const libc::c_char,
            );
            while !sec.is_null()
                && init_reloc_cookie_for_section(&mut cookie, info, sec) as libc::c_int
                    != 0
            {
                _bfd_elf_parse_eh_frame(sub, info, sec, &mut cookie);
                if !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).sec_info)
                    .is_null()
                    && (*sec).flags & 0x100000 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                {
                    (*(*sub).tdata.elf_obj_data).eh_frame_section = sec;
                }
                fini_reloc_cookie_for_section(&mut cookie, sec);
                sec = bfd_get_next_section_by_name(0 as *mut bfd, sec);
            }
        }
        sub = (*sub).link.next;
    }
    elf_link_hash_traverse(
        htab,
        Some(
            elf_gc_propagate_vtable_entries_used
                as unsafe extern "C" fn(
                    *mut elf_link_hash_entry,
                    *mut libc::c_void,
                ) -> bool,
        ),
        &mut ok as *mut bool as *mut libc::c_void,
    );
    if !ok {
        return 0 as libc::c_int != 0;
    }
    elf_link_hash_traverse(
        htab,
        Some(
            elf_gc_smash_unused_vtentry_relocs
                as unsafe extern "C" fn(
                    *mut elf_link_hash_entry,
                    *mut libc::c_void,
                ) -> bool,
        ),
        &mut ok as *mut bool as *mut libc::c_void,
    );
    if !ok {
        return 0 as libc::c_int != 0;
    }
    if (*htab).dynamic_sections_created as libc::c_int != 0
        || (*info).gc_keep_exported() as libc::c_int != 0
    {
        elf_link_hash_traverse(
            htab,
            (*bed).gc_mark_dynamic_ref,
            info as *mut libc::c_void,
        );
    }
    gc_mark_hook = (*bed).gc_mark_hook;
    sub = (*info).input_bfds;
    while !sub.is_null() {
        let mut o: *mut asection = 0 as *mut asection;
        if !(bfd_get_flavour(sub) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
            || (*(*sub).tdata.elf_obj_data).object_id() as libc::c_uint
                != elf_hash_table_id(htab) as libc::c_uint
            || !(Some(((*bed).relocs_compatible).expect("non-null function pointer")))
                .expect("non-null function pointer")((*sub).xvec, (*abfd).xvec))
        {
            o = (*sub).sections;
            if !(o.is_null() || (*o).sec_info_type() as libc::c_int == 4 as libc::c_int)
            {
                o = (*sub).sections;
                while !o.is_null() {
                    if (*o).gc_mark() == 0
                        && (*o).flags & 0x8000 as libc::c_int as libc::c_uint
                            == 0 as libc::c_int as libc::c_uint
                        && ((*o).flags & 0x200000 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                            || (*info).type_0() as libc::c_int
                                == type_relocatable as libc::c_int
                                && ((*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                    .this_hdr
                                    .sh_type == 16 as libc::c_int as libc::c_uint
                                    || (*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                        .this_hdr
                                        .sh_type == 14 as libc::c_int as libc::c_uint
                                    || (*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                        .this_hdr
                                        .sh_type == 15 as libc::c_int as libc::c_uint)
                            || (*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                .this_hdr
                                .sh_type == 7 as libc::c_int as libc::c_uint
                                && ((*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                    .next_in_group)
                                    .is_null()
                                && ((*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                    .linked_to)
                                    .is_null()
                            || (*(*sub).tdata.elf_obj_data).has_gnu_osabi()
                                as libc::c_int & elf_gnu_osabi_retain as libc::c_int != 0
                                && (*((*o).used_by_bfd as *mut bfd_elf_section_data))
                                    .this_hdr
                                    .sh_flags
                                    & ((1 as libc::c_int) << 21 as libc::c_int) as libc::c_ulong
                                    != 0)
                    {
                        if !_bfd_elf_gc_mark(info, o, gc_mark_hook) {
                            return 0 as libc::c_int != 0;
                        }
                    }
                    o = (*o).next;
                }
            }
        }
        sub = (*sub).link.next;
    }
    ((*bed).gc_mark_extra_sections)
        .expect("non-null function pointer")(info, gc_mark_hook);
    return elf_gc_sweep(abfd, info);
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_gc_record_vtinherit(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut h: *mut elf_link_hash_entry,
    mut offset: bfd_vma,
) -> bool {
    let mut current_block: u64;
    let mut sym_hashes: *mut *mut elf_link_hash_entry = 0
        as *mut *mut elf_link_hash_entry;
    let mut sym_hashes_end: *mut *mut elf_link_hash_entry = 0
        as *mut *mut elf_link_hash_entry;
    let mut search: *mut *mut elf_link_hash_entry = 0 as *mut *mut elf_link_hash_entry;
    let mut child: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    let mut extsymcount: size_t = 0;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    extsymcount = ((*(*abfd).tdata.elf_obj_data).symtab_hdr.sh_size)
        .wrapping_div((*(*bed).s).sizeof_sym as libc::c_ulong);
    if (*(*abfd).tdata.elf_obj_data).bad_symtab() == 0 {
        extsymcount = (extsymcount as libc::c_ulong)
            .wrapping_sub(
                (*(*abfd).tdata.elf_obj_data).symtab_hdr.sh_info as libc::c_ulong,
            ) as size_t as size_t;
    }
    sym_hashes = (*(*abfd).tdata.elf_obj_data).sym_hashes;
    sym_hashes_end = sym_hashes.offset(extsymcount as isize);
    search = sym_hashes;
    loop {
        if !(search != sym_hashes_end) {
            current_block = 17216689946888361452;
            break;
        }
        child = *search;
        if !child.is_null()
            && (((*child).root).type_0() as libc::c_int
                == bfd_link_hash_defined as libc::c_int
                || ((*child).root).type_0() as libc::c_int
                    == bfd_link_hash_defweak as libc::c_int)
            && (*child).root.u.def.section == sec && (*child).root.u.def.value == offset
        {
            current_block = 5949718643732908263;
            break;
        }
        search = search.offset(1);
        search;
    }
    match current_block {
        5949718643732908263 => {
            if ((*child).u2.vtable).is_null() {
                (*child)
                    .u2
                    .vtable = bfd_zalloc(
                    abfd,
                    ::core::mem::size_of::<elf_link_virtual_table_entry>()
                        as libc::c_ulong,
                ) as *mut elf_link_virtual_table_entry;
                if ((*child).u2.vtable).is_null() {
                    return 0 as libc::c_int != 0;
                }
            }
            if h.is_null() {
                (*(*child).u2.vtable)
                    .parent = -(1 as libc::c_int) as *mut elf_link_hash_entry;
            } else {
                (*(*child).u2.vtable).parent = h;
            }
            return 1 as libc::c_int != 0;
        }
        _ => {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: %pA+%#lx: no symbol found for INHERIT\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                sec,
                offset,
            );
            bfd_set_error(bfd_error_invalid_operation);
            return 0 as libc::c_int != 0;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_gc_record_vtentry(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut h: *mut elf_link_hash_entry,
    mut addend: bfd_vma,
) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut log_file_align: libc::c_uint = (*(*bed).s).log_file_align as libc::c_uint;
    if h.is_null() {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: section '%pA': corrupt VTENTRY entry\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            sec,
        );
        bfd_set_error(bfd_error_bad_value);
        return 0 as libc::c_int != 0;
    }
    if ((*h).u2.vtable).is_null() {
        (*h)
            .u2
            .vtable = bfd_zalloc(
            abfd,
            ::core::mem::size_of::<elf_link_virtual_table_entry>() as libc::c_ulong,
        ) as *mut elf_link_virtual_table_entry;
        if ((*h).u2.vtable).is_null() {
            return 0 as libc::c_int != 0;
        }
    }
    if addend >= (*(*h).u2.vtable).size {
        let mut size: size_t = 0;
        let mut bytes: size_t = 0;
        let mut file_align: size_t = 0;
        let mut ptr: *mut bool = (*(*h).u2.vtable).used;
        file_align = ((1 as libc::c_int) << log_file_align) as size_t;
        if ((*h).root).type_0() as libc::c_int == bfd_link_hash_undefined as libc::c_int
        {
            size = addend.wrapping_add(file_align);
        } else {
            size = (*h).size;
            if addend >= size {
                size = addend.wrapping_add(file_align);
            }
        }
        size = size
            .wrapping_add(file_align)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) & file_align.wrapping_neg();
        bytes = (size >> log_file_align)
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<bool>() as libc::c_ulong);
        if !ptr.is_null() {
            ptr = bfd_realloc(
                ptr.offset(-(1 as libc::c_int as isize)) as *mut libc::c_void,
                bytes,
            ) as *mut bool;
            if !ptr.is_null() {
                let mut oldbytes: size_t = 0;
                oldbytes = ((*(*h).u2.vtable).size >> log_file_align)
                    .wrapping_add(1 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<bool>() as libc::c_ulong);
                memset(
                    (ptr as *mut libc::c_char).offset(oldbytes as isize)
                        as *mut libc::c_void,
                    0 as libc::c_int,
                    bytes.wrapping_sub(oldbytes),
                );
            }
        } else {
            ptr = bfd_zmalloc(bytes) as *mut bool;
        }
        if ptr.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*(*h).u2.vtable).used = ptr.offset(1 as libc::c_int as isize);
        (*(*h).u2.vtable).size = size;
    }
    *((*(*h).u2.vtable).used)
        .offset((addend >> log_file_align) as isize) = 1 as libc::c_int != 0;
    return 1 as libc::c_int != 0;
}
static mut elf_flags_to_names: [elf_flags_to_name_table; 12] = [
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_WRITE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 0 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_ALLOC\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 1 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_EXECINSTR\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 2 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_MERGE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 4 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_STRINGS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 5 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_INFO_LINK\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 6 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_LINK_ORDER\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 7 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_OS_NONCONFORMING\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 8 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_GROUP\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 9 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_TLS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: ((1 as libc::c_int) << 10 as libc::c_int) as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_MASKOS\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: 0xff00000 as libc::c_int as flagword,
        };
        init
    },
    {
        let mut init = elf_flags_to_name_table {
            flag_name: b"SHF_EXCLUDE\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            flag_value: 0x80000000 as libc::c_uint,
        };
        init
    },
];
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_lookup_section_flags(
    mut info: *mut bfd_link_info,
    mut flaginfo: *mut flag_info,
    mut section: *mut asection,
) -> bool {
    let sh_flags: bfd_vma = (*((*section).used_by_bfd as *mut bfd_elf_section_data))
        .this_hdr
        .sh_flags;
    if !(*flaginfo).flags_initialized {
        let mut obfd: *mut bfd = (*info).output_bfd;
        let mut bed: *const elf_backend_data = (*(*obfd).xvec).backend_data
            as *const elf_backend_data;
        let mut tf: *mut flag_info_list = (*flaginfo).flag_list;
        let mut with_hex: libc::c_int = 0 as libc::c_int;
        let mut without_hex: libc::c_int = 0 as libc::c_int;
        let mut current_block_17: u64;
        tf = (*flaginfo).flag_list;
        while !tf.is_null() {
            let mut i: libc::c_uint = 0;
            let mut lookup: Option::<
                unsafe extern "C" fn(*mut libc::c_char) -> flagword,
            > = None;
            lookup = (*bed).elf_backend_lookup_section_flags_hook;
            if lookup.is_some() {
                let mut hexval: flagword = (Some(
                    lookup.expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )((*tf).name as *mut libc::c_char);
                if hexval != 0 as libc::c_int as libc::c_uint {
                    if (*tf).with as libc::c_uint
                        == with_flags as libc::c_int as libc::c_uint
                    {
                        with_hex = (with_hex as libc::c_uint | hexval) as libc::c_int;
                    } else if (*tf).with as libc::c_uint
                        == without_flags as libc::c_int as libc::c_uint
                    {
                        without_hex = (without_hex as libc::c_uint | hexval)
                            as libc::c_int;
                    }
                    (*tf).valid = 1 as libc::c_int != 0;
                    current_block_17 = 10680521327981672866;
                } else {
                    current_block_17 = 13586036798005543211;
                }
            } else {
                current_block_17 = 13586036798005543211;
            }
            match current_block_17 {
                13586036798005543211 => {
                    i = 0 as libc::c_int as libc::c_uint;
                    while (i as libc::c_ulong)
                        < (::core::mem::size_of::<[elf_flags_to_name_table; 12]>()
                            as libc::c_ulong)
                            .wrapping_div(
                                ::core::mem::size_of::<elf_flags_to_name_table>()
                                    as libc::c_ulong,
                            )
                    {
                        if strcmp((*tf).name, elf_flags_to_names[i as usize].flag_name)
                            == 0 as libc::c_int
                        {
                            if (*tf).with as libc::c_uint
                                == with_flags as libc::c_int as libc::c_uint
                            {
                                with_hex = (with_hex as libc::c_uint
                                    | elf_flags_to_names[i as usize].flag_value) as libc::c_int;
                            } else if (*tf).with as libc::c_uint
                                == without_flags as libc::c_int as libc::c_uint
                            {
                                without_hex = (without_hex as libc::c_uint
                                    | elf_flags_to_names[i as usize].flag_value) as libc::c_int;
                            }
                            (*tf).valid = 1 as libc::c_int != 0;
                            break;
                        } else {
                            i = i.wrapping_add(1);
                            i;
                        }
                    }
                    if !(*tf).valid {
                        ((*(*info).callbacks).einfo)
                            .expect(
                                "non-null function pointer",
                            )(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"unrecognized INPUT_SECTION_FLAG %s\n\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            (*tf).name,
                        );
                        return 0 as libc::c_int != 0;
                    }
                }
                _ => {}
            }
            tf = (*tf).next;
        }
        (*flaginfo).flags_initialized = 1 as libc::c_int != 0;
        (*flaginfo).only_with_flags |= with_hex as libc::c_uint;
        (*flaginfo).not_with_flags |= without_hex as libc::c_uint;
    }
    if (*flaginfo).only_with_flags as libc::c_ulong & sh_flags
        != (*flaginfo).only_with_flags as libc::c_ulong
    {
        return 0 as libc::c_int != 0;
    }
    if (*flaginfo).not_with_flags as libc::c_ulong & sh_flags
        != 0 as libc::c_int as libc::c_ulong
    {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_gc_allocate_got_offsets(
    mut h: *mut elf_link_hash_entry,
    mut arg: *mut libc::c_void,
) -> bool {
    let mut gofarg: *mut alloc_got_off_arg = arg as *mut alloc_got_off_arg;
    let mut obfd: *mut bfd = (*(*gofarg).info).output_bfd;
    let mut bed: *const elf_backend_data = (*(*obfd).xvec).backend_data
        as *const elf_backend_data;
    if (*h).got.refcount > 0 as libc::c_int as libc::c_long {
        (*h).got.offset = (*gofarg).gotoff;
        (*gofarg)
            .gotoff = ((*gofarg).gotoff as libc::c_ulong)
            .wrapping_add(
                ((*bed).got_elt_size)
                    .expect(
                        "non-null function pointer",
                    )(
                    obfd,
                    (*gofarg).info,
                    h,
                    0 as *mut bfd,
                    0 as libc::c_int as libc::c_ulong,
                ),
            ) as bfd_vma as bfd_vma;
    } else {
        (*h).got.offset = -(1 as libc::c_int) as bfd_vma;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_gc_common_finalize_got_offsets(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut i: *mut bfd = 0 as *mut bfd;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut gotoff: bfd_vma = 0;
    let mut gofarg: alloc_got_off_arg = alloc_got_off_arg {
        gotoff: 0,
        info: 0 as *mut bfd_link_info,
    };
    if !(abfd == (*info).output_bfd) {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            14405 as libc::c_int,
        );
    }
    if !is_elf_hash_table((*info).hash) {
        return 0 as libc::c_int != 0;
    }
    if (*bed).want_got_plt() != 0 {
        gotoff = 0 as libc::c_int as bfd_vma;
    } else {
        gotoff = (*bed).got_header_size;
    }
    i = (*info).input_bfds;
    while !i.is_null() {
        let mut local_got: *mut bfd_signed_vma = 0 as *mut bfd_signed_vma;
        let mut j: size_t = 0;
        let mut locsymcount: size_t = 0;
        let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        if !(bfd_get_flavour(i) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint)
        {
            local_got = (*(*i).tdata.elf_obj_data).local_got.refcounts;
            if !local_got.is_null() {
                symtab_hdr = &mut (*(*i).tdata.elf_obj_data).symtab_hdr;
                if (*(*i).tdata.elf_obj_data).bad_symtab() != 0 {
                    locsymcount = ((*symtab_hdr).sh_size)
                        .wrapping_div((*(*bed).s).sizeof_sym as libc::c_ulong);
                } else {
                    locsymcount = (*symtab_hdr).sh_info as size_t;
                }
                j = 0 as libc::c_int as size_t;
                while j < locsymcount {
                    if *local_got.offset(j as isize) > 0 as libc::c_int as libc::c_long {
                        *local_got.offset(j as isize) = gotoff as bfd_signed_vma;
                        gotoff = (gotoff as libc::c_ulong)
                            .wrapping_add(
                                ((*bed).got_elt_size)
                                    .expect(
                                        "non-null function pointer",
                                    )(abfd, info, 0 as *mut elf_link_hash_entry, i, j),
                            ) as bfd_vma as bfd_vma;
                    } else {
                        *local_got
                            .offset(
                                j as isize,
                            ) = -(1 as libc::c_int) as bfd_vma as bfd_signed_vma;
                    }
                    j = j.wrapping_add(1);
                    j;
                }
            }
        }
        i = (*i).link.next;
    }
    gofarg.gotoff = gotoff;
    gofarg.info = info;
    elf_link_hash_traverse(
        elf_hash_table(info),
        Some(
            elf_gc_allocate_got_offsets
                as unsafe extern "C" fn(
                    *mut elf_link_hash_entry,
                    *mut libc::c_void,
                ) -> bool,
        ),
        &mut gofarg as *mut alloc_got_off_arg as *mut libc::c_void,
    );
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_gc_common_final_link(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    if !bfd_elf_gc_common_finalize_got_offsets(abfd, info) {
        return 0 as libc::c_int != 0;
    }
    return bfd_elf_final_link(abfd, info);
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_reloc_symbol_deleted_p(
    mut offset: bfd_vma,
    mut cookie: *mut libc::c_void,
) -> bool {
    let mut rcookie: *mut elf_reloc_cookie = cookie as *mut elf_reloc_cookie;
    if (*rcookie).bad_symtab {
        (*rcookie).rel = (*rcookie).rels;
    }
    while (*rcookie).rel < (*rcookie).relend {
        let mut r_symndx: libc::c_ulong = 0;
        if !(*rcookie).bad_symtab {
            if (*(*rcookie).rel).r_offset > offset {
                return 0 as libc::c_int != 0;
            }
        }
        if (*(*rcookie).rel).r_offset != offset {
            (*rcookie).rel = ((*rcookie).rel).offset(1);
            (*rcookie).rel;
        } else {
            r_symndx = (*(*rcookie).rel).r_info >> (*rcookie).r_sym_shift;
            if r_symndx == 0 as libc::c_int as libc::c_ulong {
                return 1 as libc::c_int != 0;
            }
            if r_symndx >= (*rcookie).locsymcount
                || (*((*rcookie).locsyms).offset(r_symndx as isize)).st_info
                    as libc::c_uint >> 4 as libc::c_int
                    != 0 as libc::c_int as libc::c_uint
            {
                let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
                h = *((*rcookie).sym_hashes)
                    .offset(r_symndx.wrapping_sub((*rcookie).extsymoff) as isize);
                while ((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_indirect as libc::c_int
                    || ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_warning as libc::c_int
                {
                    h = (*h).root.u.i.link as *mut elf_link_hash_entry;
                }
                if (((*h).root).type_0() as libc::c_int
                    == bfd_link_hash_defined as libc::c_int
                    || ((*h).root).type_0() as libc::c_int
                        == bfd_link_hash_defweak as libc::c_int)
                    && ((*(*h).root.u.def.section).owner != (*rcookie).abfd
                        || !((*(*h).root.u.def.section).kept_section).is_null()
                        || discarded_section((*h).root.u.def.section) as libc::c_int
                            != 0)
                {
                    return 1 as libc::c_int != 0;
                }
            } else {
                let mut isec: *mut asection = 0 as *mut asection;
                let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
                isym = &mut *((*rcookie).locsyms).offset(r_symndx as isize)
                    as *mut Elf_Internal_Sym;
                isec = bfd_section_from_elf_index((*rcookie).abfd, (*isym).st_shndx);
                if !isec.is_null()
                    && (!((*isec).kept_section).is_null()
                        || discarded_section(isec) as libc::c_int != 0)
                {
                    return 1 as libc::c_int != 0;
                }
            }
            return 0 as libc::c_int != 0;
        }
    }
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_discard_info(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> libc::c_int {
    let mut cookie: elf_reloc_cookie = elf_reloc_cookie {
        rels: 0 as *mut Elf_Internal_Rela,
        rel: 0 as *mut Elf_Internal_Rela,
        relend: 0 as *mut Elf_Internal_Rela,
        locsyms: 0 as *mut Elf_Internal_Sym,
        abfd: 0 as *mut bfd,
        locsymcount: 0,
        extsymoff: 0,
        sym_hashes: 0 as *mut *mut elf_link_hash_entry,
        r_sym_shift: 0,
        bad_symtab: false,
    };
    let mut o: *mut asection = 0 as *mut asection;
    let mut abfd: *mut bfd = 0 as *mut bfd;
    let mut changed: libc::c_int = 0 as libc::c_int;
    if (*info).traditional_format() as libc::c_int != 0
        || !is_elf_hash_table((*info).hash)
    {
        return 0 as libc::c_int;
    }
    o = bfd_get_section_by_name(
        output_bfd,
        b".stab\0" as *const u8 as *const libc::c_char,
    );
    if !o.is_null() {
        let mut i: *mut asection = 0 as *mut asection;
        i = (*o).map_head.s;
        while !i.is_null() {
            if !((*i).size == 0 as libc::c_int as libc::c_ulong
                || (*i).reloc_count == 0 as libc::c_int as libc::c_uint
                || (*i).sec_info_type() as libc::c_int != 1 as libc::c_int)
            {
                abfd = (*i).owner;
                if !(bfd_get_flavour(abfd) as libc::c_uint
                    != bfd_target_elf_flavour as libc::c_int as libc::c_uint)
                {
                    if !init_reloc_cookie_for_section(&mut cookie, info, i) {
                        return -(1 as libc::c_int);
                    }
                    if _bfd_discard_section_stabs(
                        abfd,
                        i,
                        (*((*i).used_by_bfd as *mut bfd_elf_section_data)).sec_info,
                        Some(
                            bfd_elf_reloc_symbol_deleted_p
                                as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> bool,
                        ),
                        &mut cookie as *mut elf_reloc_cookie as *mut libc::c_void,
                    ) {
                        changed = 1 as libc::c_int;
                    }
                    fini_reloc_cookie_for_section(&mut cookie, i);
                }
            }
            i = (*i).map_head.s;
        }
    }
    o = 0 as *mut asection;
    if (*info).eh_frame_hdr_type() as libc::c_int != 2 as libc::c_int {
        o = bfd_get_section_by_name(
            output_bfd,
            b".eh_frame\0" as *const u8 as *const libc::c_char,
        );
    }
    if !o.is_null() {
        let mut i_0: *mut asection = 0 as *mut asection;
        let mut eh_changed: libc::c_int = 0 as libc::c_int;
        let mut eh_alignment: libc::c_uint = 0;
        i_0 = (*o).map_head.s;
        while !i_0.is_null() {
            if !((*i_0).size == 0 as libc::c_int as libc::c_ulong) {
                abfd = (*i_0).owner;
                if !(bfd_get_flavour(abfd) as libc::c_uint
                    != bfd_target_elf_flavour as libc::c_int as libc::c_uint)
                {
                    if !init_reloc_cookie_for_section(&mut cookie, info, i_0) {
                        return -(1 as libc::c_int);
                    }
                    _bfd_elf_parse_eh_frame(abfd, info, i_0, &mut cookie);
                    if _bfd_elf_discard_section_eh_frame(
                        abfd,
                        info,
                        i_0,
                        Some(
                            bfd_elf_reloc_symbol_deleted_p
                                as unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> bool,
                        ),
                        &mut cookie,
                    ) {
                        eh_changed = 1 as libc::c_int;
                        if (*i_0).size != (*i_0).rawsize {
                            changed = 1 as libc::c_int;
                        }
                    }
                    fini_reloc_cookie_for_section(&mut cookie, i_0);
                }
            }
            i_0 = (*i_0).map_head.s;
        }
        eh_alignment = (((1 as libc::c_int) << (*o).alignment_power) as libc::c_uint)
            .wrapping_mul(bfd_octets_per_byte(output_bfd, o));
        i_0 = (*o).map_tail.s;
        while !i_0.is_null() {
            if (*i_0).size == 0 as libc::c_int as libc::c_ulong {
                (*i_0).flags |= 0x8000 as libc::c_int as libc::c_uint;
            } else if (*i_0).size > 4 as libc::c_int as libc::c_ulong {
                break;
            }
            i_0 = (*i_0).map_tail.s;
        }
        if !i_0.is_null() {
            i_0 = (*i_0).map_tail.s;
        }
        while !i_0.is_null() {
            if (*i_0).size == 4 as libc::c_int as libc::c_ulong {
                bfd_assert(
                    b"elflink.c\0" as *const u8 as *const libc::c_char,
                    14631 as libc::c_int,
                );
            } else {
                let mut size: bfd_size_type = ((*i_0).size)
                    .wrapping_add(eh_alignment as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    & eh_alignment.wrapping_neg() as libc::c_ulong;
                if (*i_0).size != size {
                    (*i_0).size = size;
                    changed = 1 as libc::c_int;
                    eh_changed = 1 as libc::c_int;
                }
            }
            i_0 = (*i_0).map_tail.s;
        }
        if eh_changed != 0 {
            elf_link_hash_traverse(
                elf_hash_table(info),
                Some(
                    _bfd_elf_adjust_eh_frame_global_symbol
                        as unsafe extern "C" fn(
                            *mut elf_link_hash_entry,
                            *mut libc::c_void,
                        ) -> bool,
                ),
                0 as *mut libc::c_void,
            );
        }
    }
    abfd = (*info).input_bfds;
    while !abfd.is_null() {
        let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
        let mut s: *mut asection = 0 as *mut asection;
        if !(bfd_get_flavour(abfd) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint)
        {
            s = (*abfd).sections;
            if !(s.is_null() || (*s).sec_info_type() as libc::c_int == 4 as libc::c_int)
            {
                bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
                if ((*bed).elf_backend_discard_info).is_some() {
                    if !init_reloc_cookie(&mut cookie, info, abfd) {
                        return -(1 as libc::c_int);
                    }
                    if (Some(
                        ((*bed).elf_backend_discard_info)
                            .expect("non-null function pointer"),
                    ))
                        .expect("non-null function pointer")(abfd, &mut cookie, info)
                    {
                        changed = 1 as libc::c_int;
                    }
                    fini_reloc_cookie(&mut cookie, abfd);
                }
            }
        }
        abfd = (*abfd).link.next;
    }
    if (*info).eh_frame_hdr_type() as libc::c_int == 2 as libc::c_int {
        _bfd_elf_end_eh_frame_parsing(info);
    }
    if (*info).eh_frame_hdr_type() as libc::c_int != 0
        && !((*info).type_0() as libc::c_int == type_relocatable as libc::c_int)
        && _bfd_elf_discard_section_eh_frame_hdr(output_bfd, info) as libc::c_int != 0
    {
        changed = 1 as libc::c_int;
    }
    return changed;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_section_already_linked(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut flags: flagword = 0;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut key: *const libc::c_char = 0 as *const libc::c_char;
    let mut l: *mut bfd_section_already_linked = 0 as *mut bfd_section_already_linked;
    let mut already_linked_list: *mut bfd_section_already_linked_hash_entry = 0
        as *mut bfd_section_already_linked_hash_entry;
    if (*sec).output_section
        == &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
            as *mut asection
    {
        return 0 as libc::c_int != 0;
    }
    flags = (*sec).flags;
    if flags & 0x20000 as libc::c_int as libc::c_uint == 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    if !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).sec_group).is_null() {
        return 0 as libc::c_int != 0;
    }
    name = (*sec).name;
    if flags & 0x2000000 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
        && !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group)
            .is_null()
        && !((*((*(*((*sec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group)
            .used_by_bfd as *mut bfd_elf_section_data))
            .group
            .name)
            .is_null()
    {
        key = (*((*(*((*sec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group)
            .used_by_bfd as *mut bfd_elf_section_data))
            .group
            .name;
    } else if startswith(name, b".gnu.linkonce.\0" as *const u8 as *const libc::c_char)
        as libc::c_int != 0
        && {
            key = strchr(
                name
                    .offset(
                        ::core::mem::size_of::<[libc::c_char; 15]>() as libc::c_ulong
                            as isize,
                    )
                    .offset(-(1 as libc::c_int as isize)),
                '.' as i32,
            );
            !key.is_null()
        }
    {
        key = key.offset(1);
        key;
    } else {
        key = name;
    }
    already_linked_list = bfd_section_already_linked_table_lookup(key);
    l = (*already_linked_list).entry;
    while !l.is_null() {
        if flags & 0x2000000 as libc::c_int as libc::c_uint
            == (*(*l).sec).flags & 0x2000000 as libc::c_int as libc::c_uint
            && (flags & 0x2000000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
                || strcmp(name, (*(*l).sec).name) == 0 as libc::c_int)
            || (*(*(*l).sec).owner).flags & 0x10000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
            || (*(*sec).owner).flags & 0x10000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
        {
            if !_bfd_handle_already_linked(sec, l, info) {
                return 0 as libc::c_int != 0;
            }
            if flags & 0x2000000 as libc::c_int as libc::c_uint != 0 {
                let mut first: *mut asection = (*((*sec).used_by_bfd
                    as *mut bfd_elf_section_data))
                    .next_in_group;
                let mut s: *mut asection = first;
                while !s.is_null() {
                    (*s)
                        .output_section = &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize) as *mut asection;
                    (*s).kept_section = (*l).sec;
                    s = (*((*s).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
                    if s == first {
                        break;
                    }
                }
            }
            return 1 as libc::c_int != 0;
        }
        l = (*l).next;
    }
    if flags & 0x2000000 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        let mut first_0: *mut asection = (*((*sec).used_by_bfd
            as *mut bfd_elf_section_data))
            .next_in_group;
        if !first_0.is_null()
            && (*((*first_0).used_by_bfd as *mut bfd_elf_section_data)).next_in_group
                == first_0
        {
            l = (*already_linked_list).entry;
            while !l.is_null() {
                if (*(*l).sec).flags & 0x2000000 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                    && bfd_elf_match_symbols_in_sections((*l).sec, first_0, info)
                        as libc::c_int != 0
                {
                    (*first_0)
                        .output_section = &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize) as *mut asection;
                    (*first_0).kept_section = (*l).sec;
                    (*sec)
                        .output_section = &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize) as *mut asection;
                    break;
                } else {
                    l = (*l).next;
                }
            }
        }
    } else {
        l = (*already_linked_list).entry;
        while !l.is_null() {
            if (*(*l).sec).flags & 0x2000000 as libc::c_int as libc::c_uint != 0 {
                let mut first_1: *mut asection = (*((*(*l).sec).used_by_bfd
                    as *mut bfd_elf_section_data))
                    .next_in_group;
                if !first_1.is_null()
                    && (*((*first_1).used_by_bfd as *mut bfd_elf_section_data))
                        .next_in_group == first_1
                    && bfd_elf_match_symbols_in_sections(first_1, sec, info)
                        as libc::c_int != 0
                {
                    (*sec)
                        .output_section = &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize) as *mut asection;
                    (*sec).kept_section = first_1;
                    break;
                }
            }
            l = (*l).next;
        }
    }
    if flags & 0x2000000 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
        && startswith(name, b".gnu.linkonce.r.\0" as *const u8 as *const libc::c_char)
            as libc::c_int != 0
    {
        l = (*already_linked_list).entry;
        while !l.is_null() {
            if (*(*l).sec).flags & 0x2000000 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
                && startswith(
                    (*(*l).sec).name,
                    b".gnu.linkonce.t.\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
            {
                if abfd != (*(*l).sec).owner {
                    (*sec)
                        .output_section = &mut *_bfd_std_section
                        .as_mut_ptr()
                        .offset(2 as libc::c_int as isize) as *mut asection;
                }
                break;
            } else {
                l = (*l).next;
            }
        }
    }
    if !bfd_section_already_linked_table_insert(already_linked_list, sec) {
        ((*(*info).callbacks).einfo)
            .expect(
                "non-null function pointer",
            )(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%F%P: already_linked_table: %E\n\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
    }
    return (*sec).output_section
        == &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
            as *mut asection;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_common_definition(
    mut sym: *mut Elf_Internal_Sym,
) -> bool {
    return (*sym).st_shndx == (0xe as libc::c_uint).wrapping_neg();
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_common_section_index(
    mut _sec: *mut asection,
) -> libc::c_uint {
    return (0xe as libc::c_uint).wrapping_neg();
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_common_section(
    mut _sec: *mut asection,
) -> *mut asection {
    return &mut *_bfd_std_section.as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut asection;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_default_got_elt_size(
    mut abfd: *mut bfd,
    mut _info: *mut bfd_link_info,
    mut _h: *mut elf_link_hash_entry,
    mut _ibfd: *mut bfd,
    mut _symndx: libc::c_ulong,
) -> bfd_vma {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    return ((*(*bed).s).arch_size as libc::c_int / 8 as libc::c_int) as bfd_vma;
}
unsafe extern "C" fn get_dynamic_reloc_section_name(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut is_rela: bool,
) -> *const libc::c_char {
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut old_name: *const libc::c_char = bfd_section_name(sec);
    let mut prefix: *const libc::c_char = if is_rela as libc::c_int != 0 {
        b".rela\0" as *const u8 as *const libc::c_char
    } else {
        b".rel\0" as *const u8 as *const libc::c_char
    };
    if old_name.is_null() {
        return 0 as *const libc::c_char;
    }
    name = bfd_alloc(
        abfd,
        (strlen(prefix))
            .wrapping_add(strlen(old_name))
            .wrapping_add(1 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
    sprintf(name, b"%s%s\0" as *const u8 as *const libc::c_char, prefix, old_name);
    return name;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_dynamic_reloc_section(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut is_rela: bool,
) -> *mut asection {
    let mut reloc_sec: *mut asection = (*((*sec).used_by_bfd
        as *mut bfd_elf_section_data))
        .sreloc;
    if reloc_sec.is_null() {
        let mut name: *const libc::c_char = get_dynamic_reloc_section_name(
            abfd,
            sec,
            is_rela,
        );
        if !name.is_null() {
            reloc_sec = bfd_get_linker_section(abfd, name);
            if !reloc_sec.is_null() {
                let ref mut fresh43 = (*((*sec).used_by_bfd
                    as *mut bfd_elf_section_data))
                    .sreloc;
                *fresh43 = reloc_sec;
            }
        }
    }
    return reloc_sec;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_make_dynamic_reloc_section(
    mut sec: *mut asection,
    mut dynobj: *mut bfd,
    mut alignment: libc::c_uint,
    mut abfd: *mut bfd,
    mut is_rela: bool,
) -> *mut asection {
    let mut reloc_sec: *mut asection = (*((*sec).used_by_bfd
        as *mut bfd_elf_section_data))
        .sreloc;
    if reloc_sec.is_null() {
        let mut name: *const libc::c_char = get_dynamic_reloc_section_name(
            abfd,
            sec,
            is_rela,
        );
        if name.is_null() {
            return 0 as *mut asection;
        }
        reloc_sec = bfd_get_linker_section(dynobj, name);
        if reloc_sec.is_null() {
            let mut flags: flagword = (0x100 as libc::c_int | 0x8 as libc::c_int
                | 0x4000 as libc::c_int | 0x100000 as libc::c_int) as flagword;
            if (*sec).flags & 0x1 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
            {
                flags |= (0x1 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint;
            }
            reloc_sec = bfd_make_section_anyway_with_flags(dynobj, name, flags);
            if !reloc_sec.is_null() {
                (*((*reloc_sec).used_by_bfd as *mut bfd_elf_section_data))
                    .this_hdr
                    .sh_type = (if is_rela as libc::c_int != 0 {
                    4 as libc::c_int
                } else {
                    9 as libc::c_int
                }) as libc::c_uint;
                if !bfd_set_section_alignment(reloc_sec, alignment) {
                    reloc_sec = 0 as *mut asection;
                }
            }
        }
        let ref mut fresh44 = (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
            .sreloc;
        *fresh44 = reloc_sec;
    }
    return reloc_sec;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_copy_link_hash_symbol_type(
    mut abfd: *mut bfd,
    mut hdest: *mut bfd_link_hash_entry,
    mut hsrc: *mut bfd_link_hash_entry,
) {
    let mut ehdest: *mut elf_link_hash_entry = hdest as *mut elf_link_hash_entry;
    let mut ehsrc: *mut elf_link_hash_entry = hsrc as *mut elf_link_hash_entry;
    let mut isym: Elf_Internal_Sym = Elf_Internal_Sym {
        st_value: 0,
        st_size: 0,
        st_name: 0,
        st_info: 0,
        st_other: 0,
        st_target_internal: 0,
        st_shndx: 0,
    };
    (*ehdest).set_type_0((*ehsrc).type_0());
    (*ehdest).set_target_internal((*ehsrc).target_internal());
    isym.st_other = (*ehsrc).other() as libc::c_uchar;
    elf_merge_st_other(
        abfd,
        ehdest,
        isym.st_other as libc::c_uint,
        0 as *mut asection,
        1 as libc::c_int != 0,
        0 as libc::c_int != 0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elf_append_rela(
    mut abfd: *mut bfd,
    mut s: *mut asection,
    mut rel: *mut Elf_Internal_Rela,
) {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let fresh45 = (*s).reloc_count;
    (*s).reloc_count = ((*s).reloc_count).wrapping_add(1);
    let mut loc: *mut bfd_byte = ((*s).contents)
        .offset(fresh45.wrapping_mul((*(*bed).s).sizeof_rela as libc::c_uint) as isize);
    if !(loc.offset((*(*bed).s).sizeof_rela as libc::c_int as isize)
        <= ((*s).contents).offset((*s).size as isize))
    {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            14993 as libc::c_int,
        );
    }
    ((*(*bed).s).swap_reloca_out).expect("non-null function pointer")(abfd, rel, loc);
}
#[no_mangle]
pub unsafe extern "C" fn elf_append_rel(
    mut abfd: *mut bfd,
    mut s: *mut asection,
    mut rel: *mut Elf_Internal_Rela,
) {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let fresh46 = (*s).reloc_count;
    (*s).reloc_count = ((*s).reloc_count).wrapping_add(1);
    let mut loc: *mut bfd_byte = ((*s).contents)
        .offset(fresh46.wrapping_mul((*(*bed).s).sizeof_rel as libc::c_uint) as isize);
    if !(loc.offset((*(*bed).s).sizeof_rel as libc::c_int as isize)
        <= ((*s).contents).offset((*s).size as isize))
    {
        bfd_assert(
            b"elflink.c\0" as *const u8 as *const libc::c_char,
            15004 as libc::c_int,
        );
    }
    ((*(*bed).s).swap_reloc_out).expect("non-null function pointer")(abfd, rel, loc);
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_define_start_stop(
    mut info: *mut bfd_link_info,
    mut symbol: *const libc::c_char,
    mut sec: *mut asection,
) -> *mut bfd_link_hash_entry {
    let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
    h = elf_link_hash_lookup(
        elf_hash_table(info),
        symbol,
        0 as libc::c_int != 0,
        0 as libc::c_int != 0,
        1 as libc::c_int != 0,
    );
    if !h.is_null() && ((*h).root).ldscript_def() == 0
        && (((*h).root).type_0() as libc::c_int == bfd_link_hash_undefined as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_undefweak as libc::c_int
            || ((*h).ref_regular() as libc::c_int != 0
                || (*h).def_dynamic() as libc::c_int != 0) && (*h).def_regular() == 0
                && ((*h).root).type_0() as libc::c_int
                    != bfd_link_hash_common as libc::c_int)
    {
        let mut was_dynamic: bool = (*h).ref_dynamic() as libc::c_int != 0
            || (*h).def_dynamic() as libc::c_int != 0;
        (*h).verinfo.verdef = 0 as *mut Elf_Internal_Verdef;
        ((*h).root).set_type_0(bfd_link_hash_defined);
        (*h).root.u.def.section = sec;
        (*h).root.u.def.value = 0 as libc::c_int as bfd_vma;
        (*h).set_def_regular(1 as libc::c_int as libc::c_uint);
        (*h).set_def_dynamic(0 as libc::c_int as libc::c_uint);
        (*h).set_start_stop(1 as libc::c_int as libc::c_uint);
        (*h).u2.start_stop_section = sec;
        if *symbol.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32 {
            let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
            bed = (*(*(*info).output_bfd).xvec).backend_data as *const elf_backend_data;
            (Some(((*bed).elf_backend_hide_symbol).expect("non-null function pointer")))
                .expect("non-null function pointer")(info, h, 1 as libc::c_int != 0);
        } else {
            if (*h).other() as libc::c_int & 0x3 as libc::c_int == 0 as libc::c_int {
                (*h)
                    .set_other(
                        ((*h).other() as libc::c_int
                            & !(-(1 as libc::c_int) & 0x3 as libc::c_int))
                            as libc::c_uint | (*info).start_stop_visibility,
                    );
            }
            if was_dynamic {
                bfd_elf_link_record_dynamic_symbol(info, h);
            }
        }
        return &mut (*h).root;
    }
    return 0 as *mut bfd_link_hash_entry;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_readonly_dynrelocs(
    mut h: *mut elf_link_hash_entry,
) -> *mut asection {
    let mut p: *mut elf_dyn_relocs = 0 as *mut elf_dyn_relocs;
    p = (*h).dyn_relocs;
    while !p.is_null() {
        let mut s: *mut asection = (*(*p).sec).output_section;
        if !s.is_null()
            && (*s).flags & 0x8 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
        {
            return (*p).sec;
        }
        p = (*p).next;
    }
    return 0 as *mut asection;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_maybe_set_textrel(
    mut h: *mut elf_link_hash_entry,
    mut inf: *mut libc::c_void,
) -> bool {
    let mut sec: *mut asection = 0 as *mut asection;
    if ((*h).root).type_0() as libc::c_int == bfd_link_hash_indirect as libc::c_int {
        return 1 as libc::c_int != 0;
    }
    sec = _bfd_elf_readonly_dynrelocs(h);
    if !sec.is_null() {
        let mut info: *mut bfd_link_info = inf as *mut bfd_link_info;
        (*info).flags |= ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong;
        ((*(*info).callbacks).minfo)
            .expect(
                "non-null function pointer",
            )(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: dynamic relocation against `%pT' in read-only section `%pA'\n\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            (*sec).owner,
            (*h).root.root.string,
            sec,
        );
        if (*info).textrel_check() as libc::c_int != textrel_check_none as libc::c_int {
            ((*(*info).callbacks).einfo)
                .expect(
                    "non-null function pointer",
                )(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%P: %pB: warning: relocation against `%s' in read-only section `%pA'\n\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                (*sec).owner,
                (*h).root.root.string,
                sec,
            );
        }
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_add_dynamic_tags(
    mut output_bfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut need_dynamic_reloc: bool,
) -> bool {
    let mut htab: *mut elf_link_hash_table = elf_hash_table(info);
    if (*htab).dynamic_sections_created {
        let mut bed: *const elf_backend_data = (*(*output_bfd).xvec).backend_data
            as *const elf_backend_data;
        if (*info).type_0() as libc::c_int == type_pde as libc::c_int
            || (*info).type_0() as libc::c_int == type_pie as libc::c_int
        {
            if !_bfd_elf_add_dynamic_entry(
                info,
                21 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
        }
        if (*htab).dt_pltgot_required as libc::c_int != 0
            || (*(*htab).splt).size != 0 as libc::c_int as libc::c_ulong
        {
            if !_bfd_elf_add_dynamic_entry(
                info,
                3 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            ) {
                return 0 as libc::c_int != 0;
            }
        }
        if (*htab).dt_jmprel_required as libc::c_int != 0
            || (*(*htab).srelplt).size != 0 as libc::c_int as libc::c_ulong
        {
            if !_bfd_elf_add_dynamic_entry(
                info,
                2 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    20 as libc::c_int as bfd_vma,
                    (if (*bed).rela_plts_and_copies_p() as libc::c_int != 0 {
                        7 as libc::c_int
                    } else {
                        17 as libc::c_int
                    }) as bfd_vma,
                )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    23 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
            {
                return 0 as libc::c_int != 0;
            }
        }
        if (*htab).tlsdesc_plt != 0
            && (!_bfd_elf_add_dynamic_entry(
                info,
                0x6ffffef6 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    0x6ffffef7 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                ))
        {
            return 0 as libc::c_int != 0;
        }
        if need_dynamic_reloc {
            if (*bed).rela_plts_and_copies_p() != 0 {
                if !_bfd_elf_add_dynamic_entry(
                    info,
                    7 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
                    || !_bfd_elf_add_dynamic_entry(
                        info,
                        8 as libc::c_int as bfd_vma,
                        0 as libc::c_int as bfd_vma,
                    )
                    || !_bfd_elf_add_dynamic_entry(
                        info,
                        9 as libc::c_int as bfd_vma,
                        (*(*bed).s).sizeof_rela as bfd_vma,
                    )
                {
                    return 0 as libc::c_int != 0;
                }
            } else if !_bfd_elf_add_dynamic_entry(
                info,
                17 as libc::c_int as bfd_vma,
                0 as libc::c_int as bfd_vma,
            )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    18 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                )
                || !_bfd_elf_add_dynamic_entry(
                    info,
                    19 as libc::c_int as bfd_vma,
                    (*(*bed).s).sizeof_rel as bfd_vma,
                )
            {
                return 0 as libc::c_int != 0
            }
            if (*info).flags & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong
                == 0 as libc::c_int as libc::c_ulong
            {
                elf_link_hash_traverse(
                    htab,
                    Some(
                        _bfd_elf_maybe_set_textrel
                            as unsafe extern "C" fn(
                                *mut elf_link_hash_entry,
                                *mut libc::c_void,
                            ) -> bool,
                    ),
                    info as *mut libc::c_void,
                );
            }
            if (*info).flags & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong
                != 0 as libc::c_int as libc::c_ulong
            {
                if (*htab).ifunc_resolvers {
                    ((*(*info).callbacks).einfo)
                        .expect(
                            "non-null function pointer",
                        )(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%P: warning: GNU indirect functions with DT_TEXTREL may result in a segfault at runtime; recompile with %s\n\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        if (*info).type_0() as libc::c_int == type_dll as libc::c_int {
                            b"-fPIC\0" as *const u8 as *const libc::c_char
                        } else {
                            b"-fPIE\0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                if !_bfd_elf_add_dynamic_entry(
                    info,
                    22 as libc::c_int as bfd_vma,
                    0 as libc::c_int as bfd_vma,
                ) {
                    return 0 as libc::c_int != 0;
                }
            }
        }
    }
    return 1 as libc::c_int != 0;
}
