use ::libc;
use ::c2rust_bitfields;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type bfd_sym_data_struct;
    pub type bfd_pef_xlib_data_struct;
    pub type bfd_pef_data_struct;
    pub type plugin_data_struct;
    pub type mach_o_fat_data_struct;
    pub type mach_o_data_struct;
    pub type netbsd_core_struct;
    pub type versados_data_struct;
    pub type cisco_core_struct;
    pub type osf_core_struct;
    pub type lynx_core_struct;
    pub type sgi_core_struct;
    pub type hppabsd_core_struct;
    pub type hpux_core_struct;
    pub type som_data_struct;
    pub type trad_core_struct;
    pub type sco5_core_struct;
    pub type sun_core_struct;
    pub type mmo_data_struct;
    pub type elf_strtab_hash;
    pub type dwarf1_debug;
    pub type got_entry;
    pub type plt_entry;
    pub type tekhex_data_struct;
    pub type ihex_data_struct;
    pub type verilog_data_struct;
    pub type srec_data_struct;
    pub type ecoff_tdata;
    pub type xcoff_tdata;
    pub type pe_tdata;
    pub type coff_tdata;
    pub type aout_data_struct;
    pub type bfd_strtab_hash;
    pub type ecoff_debug_swap;
    pub type cie;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn memchr(
        _: *const libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    static mut stderr: *mut FILE;
    static mut stdout: *mut FILE;
    fn dcgettext(
        __domainname: *const libc::c_char,
        __msgid: *const libc::c_char,
        __category: libc::c_int,
    ) -> *mut libc::c_char;
    fn bfd_sprintf_vma(_: *mut bfd, _: *mut libc::c_char, _: bfd_vma);
    fn bfd_fprintf_vma(_: *mut bfd, _: *mut libc::c_void, _: bfd_vma);
    fn bfd_bread(_: *mut libc::c_void, _: bfd_size_type, _: *mut bfd) -> bfd_size_type;
    fn bfd_bwrite(
        _: *const libc::c_void,
        _: bfd_size_type,
        _: *mut bfd,
    ) -> bfd_size_type;
    fn bfd_seek(_: *mut bfd, _: file_ptr, _: libc::c_int) -> libc::c_int;
    fn bfd_alloc(abfd: *mut bfd, wanted: bfd_size_type) -> *mut libc::c_void;
    fn bfd_zalloc(abfd: *mut bfd, wanted: bfd_size_type) -> *mut libc::c_void;
    fn bfd_get_file_size(abfd: *mut bfd) -> ufile_ptr;
    static mut _bfd_std_section: [asection; 4];
    fn bfd_get_section_by_name(
        abfd: *mut bfd,
        name: *const libc::c_char,
    ) -> *mut asection;
    fn bfd_make_section_anyway_with_flags(
        abfd: *mut bfd,
        name: *const libc::c_char,
        flags: flagword,
    ) -> *mut asection;
    fn bfd_make_section_anyway(
        abfd: *mut bfd,
        name: *const libc::c_char,
    ) -> *mut asection;
    fn bfd_make_section_with_flags(
        _: *mut bfd,
        name: *const libc::c_char,
        flags: flagword,
    ) -> *mut asection;
    fn bfd_make_section(_: *mut bfd, name: *const libc::c_char) -> *mut asection;
    fn bfd_set_section_flags(sec: *mut asection, flags: flagword) -> bool;
    fn bfd_rename_section(sec: *mut asection, newname: *const libc::c_char);
    fn bfd_map_over_sections(
        abfd: *mut bfd,
        func: Option::<
            unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_void) -> (),
        >,
        obj: *mut libc::c_void,
    );
    fn bfd_set_section_size(sec: *mut asection, val: bfd_size_type) -> bool;
    fn bfd_get_section_contents(
        abfd: *mut bfd,
        section: *mut asection,
        location: *mut libc::c_void,
        offset: file_ptr,
        count: bfd_size_type,
    ) -> bool;
    fn bfd_malloc_and_get_section(
        abfd: *mut bfd,
        section: *mut asection,
        buf: *mut *mut bfd_byte,
    ) -> bool;
    fn bfd_default_set_arch_mach(
        abfd: *mut bfd,
        arch: bfd_architecture,
        mach: libc::c_ulong,
    ) -> bool;
    fn bfd_get_arch(abfd: *const bfd) -> bfd_architecture;
    fn bfd_arch_bits_per_address(abfd: *const bfd) -> libc::c_uint;
    fn bfd_octets_per_byte(abfd: *const bfd, sec: *const asection) -> libc::c_uint;
    fn bfd_reloc_type_lookup(
        abfd: *mut bfd,
        code: bfd_reloc_code_real_type,
    ) -> *const reloc_howto_type;
    fn bfd_set_symtab(
        abfd: *mut bfd,
        location: *mut *mut asymbol,
        count: libc::c_uint,
    ) -> bool;
    fn bfd_print_symbol_vandf(
        abfd: *mut bfd,
        file: *mut libc::c_void,
        symbol: *mut asymbol,
    );
    fn bfd_symbol_info(symbol: *mut asymbol, ret: *mut symbol_info);
    fn bfd_set_error(error_tag: bfd_error_type);
    fn _bfd_error_handler(fmt: *const libc::c_char, _: ...);
    fn bfd_get_arch_size(abfd: *mut bfd) -> libc::c_int;
    fn bfd_compress_section(
        abfd: *mut bfd,
        section: *mut asection,
        uncompressed_buffer: *mut bfd_byte,
    ) -> bool;
    fn bfd_init_section_compress_status(abfd: *mut bfd, section: *mut asection) -> bool;
    fn bfd_init_section_decompress_status(
        abfd: *mut bfd,
        section: *mut asection,
    ) -> bool;
    fn bfd_is_section_compressed_with_header(
        abfd: *mut bfd,
        section: *mut asection,
        compression_header_size_p: *mut libc::c_int,
        uncompressed_size_p: *mut bfd_size_type,
        uncompressed_alignment_power_p: *mut libc::c_uint,
    ) -> bool;
    fn bfd_link_hash_lookup(
        _: *mut bfd_link_hash_table,
        _: *const libc::c_char,
        create: bool,
        copy: bool,
        follow: bool,
    ) -> *mut bfd_link_hash_entry;
    fn bfd_malloc(_: bfd_size_type) -> *mut libc::c_void;
    fn bfd_release(_: *mut bfd, _: *mut libc::c_void);
    fn _bfd_archive_close_and_cleanup(_: *mut bfd) -> bool;
    fn _bfd_generic_new_section_hook(_: *mut bfd, _: *mut asection) -> bool;
    fn _bfd_stab_section_find_nearest_line(
        _: *mut bfd,
        _: *mut *mut asymbol,
        _: *mut asection,
        _: bfd_vma,
        _: *mut bool,
        _: *mut *const libc::c_char,
        _: *mut *const libc::c_char,
        _: *mut libc::c_uint,
        _: *mut *mut libc::c_void,
    ) -> bool;
    fn _bfd_dwarf1_find_nearest_line(
        _: *mut bfd,
        _: *mut *mut asymbol,
        _: *mut asection,
        _: bfd_vma,
        _: *mut *const libc::c_char,
        _: *mut *const libc::c_char,
        _: *mut libc::c_uint,
    ) -> bool;
    static dwarf_debug_sections: [dwarf_debug_section; 0];
    fn _bfd_dwarf2_find_nearest_line(
        _: *mut bfd,
        _: *mut *mut asymbol,
        _: *mut asymbol,
        _: *mut asection,
        _: bfd_vma,
        _: *mut *const libc::c_char,
        _: *mut *const libc::c_char,
        _: *mut libc::c_uint,
        _: *mut libc::c_uint,
        _: *const dwarf_debug_section,
        _: *mut *mut libc::c_void,
    ) -> libc::c_int;
    fn _bfd_dwarf2_find_inliner_info(
        _: *mut bfd,
        _: *mut *const libc::c_char,
        _: *mut *const libc::c_char,
        _: *mut libc::c_uint,
        _: *mut *mut libc::c_void,
    ) -> bool;
    fn _bfd_dwarf2_cleanup_debug_info(_: *mut bfd, _: *mut *mut libc::c_void);
    fn _bfd_stab_section_offset(
        _: *mut asection,
        _: *mut libc::c_void,
        _: bfd_vma,
    ) -> bfd_vma;
    fn _bfd_merged_section_offset(
        _: *mut bfd,
        _: *mut *mut asection,
        _: *mut libc::c_void,
        _: bfd_vma,
    ) -> bfd_vma;
    fn bfd_assert(_: *const libc::c_char, _: libc::c_int);
    fn _bfd_abort(_: *const libc::c_char, _: libc::c_int, _: *const libc::c_char) -> !;
    fn bfd_zmalloc(SIZE: bfd_size_type) -> *mut libc::c_void;
    fn bfd_log2(x: bfd_vma) -> libc::c_uint;
    fn elf32_r_sym(_: bfd_vma) -> bfd_vma;
    fn elf32_r_info(_: bfd_vma, _: bfd_vma) -> bfd_vma;
    fn elf64_r_sym(_: bfd_vma) -> bfd_vma;
    fn elf64_r_info(_: bfd_vma, _: bfd_vma) -> bfd_vma;
    fn _bfd_elf_copy_obj_attributes(_: *mut bfd, _: *mut bfd);
    fn bfd_elf_get_dt_soname(_: *mut bfd) -> *const libc::c_char;
    fn _bfd_elf_eh_frame_section_offset(
        _: *mut bfd,
        _: *mut bfd_link_info,
        _: *mut asection,
        _: bfd_vma,
    ) -> bfd_vma;
    fn _bfd_elf_parse_gnu_properties(_: *mut bfd, _: *mut Elf_Internal_Note) -> bool;
    fn _bfd_elf_parse_attributes(_: *mut bfd, _: *mut Elf_Internal_Shdr);
    fn _bfd_elf_check_kept_section(
        _: *mut asection,
        _: *mut bfd_link_info,
    ) -> *mut asection;
    fn _bfd_elf_strtab_emit(_: *mut bfd, _: *mut elf_strtab_hash) -> bool;
    fn _bfd_elf_strtab_offset(_: *mut elf_strtab_hash, _: size_t) -> bfd_size_type;
    fn _bfd_elf_strtab_size(_: *mut elf_strtab_hash) -> bfd_size_type;
    fn _bfd_elf_strtab_finalize(_: *mut elf_strtab_hash);
    fn _bfd_elf_strtab_add(
        _: *mut elf_strtab_hash,
        _: *const libc::c_char,
        _: bool,
    ) -> size_t;
    fn _bfd_elf_strtab_free(_: *mut elf_strtab_hash);
    fn _bfd_elf_strtab_init() -> *mut elf_strtab_hash;
    fn _bfd_elf_strtab_addref(_: *mut elf_strtab_hash, _: size_t);
    fn _bfd_elf_strtab_clear_all_refs(_: *mut elf_strtab_hash);
    fn _bfd_elf_find_function(
        _: *mut bfd,
        _: *mut *mut asymbol,
        _: *mut asection,
        _: bfd_vma,
        _: *mut *const libc::c_char,
        _: *mut *const libc::c_char,
    ) -> *mut asymbol;
    static _sch_istable: [libc::c_ushort; 256];
}
pub type size_t = libc::c_ulong;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type pid_t = __pid_t;
pub type int16_t = __int16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __compar_fn_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type hashval_t = libc::c_uint;
pub type htab_hash = Option::<unsafe extern "C" fn(*const libc::c_void) -> hashval_t>;
pub type htab_eq = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
pub type htab_del = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type htab_alloc = Option::<
    unsafe extern "C" fn(size_t, size_t) -> *mut libc::c_void,
>;
pub type htab_free = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type htab_alloc_with_arg = Option::<
    unsafe extern "C" fn(*mut libc::c_void, size_t, size_t) -> *mut libc::c_void,
>;
pub type htab_free_with_arg = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct htab {
    pub hash_f: htab_hash,
    pub eq_f: htab_eq,
    pub del_f: htab_del,
    pub entries: *mut *mut libc::c_void,
    pub size: size_t,
    pub n_elements: size_t,
    pub n_deleted: size_t,
    pub searches: libc::c_uint,
    pub collisions: libc::c_uint,
    pub alloc_f: htab_alloc,
    pub free_f: htab_free,
    pub alloc_arg: *mut libc::c_void,
    pub alloc_with_arg_f: htab_alloc_with_arg,
    pub free_with_arg_f: htab_free_with_arg,
    pub size_prime_index: libc::c_uint,
}
pub type htab_t = *mut htab;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type bfd_int64_t = libc::c_long;
pub type bfd_uint64_t = libc::c_ulong;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd {
    pub filename: *const libc::c_char,
    pub xvec: *const bfd_target,
    pub iostream: *mut libc::c_void,
    pub iovec: *const bfd_iovec,
    pub lru_prev: *mut bfd,
    pub lru_next: *mut bfd,
    pub where_0: ufile_ptr,
    pub mtime: libc::c_long,
    pub id: libc::c_uint,
    pub flags: flagword,
    #[bitfield(name = "format", ty = "bfd_format", bits = "0..=2")]
    #[bitfield(name = "direction", ty = "bfd_direction", bits = "3..=4")]
    #[bitfield(name = "cacheable", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "target_defaulted", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "opened_once", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "mtime_set", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "no_export", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "output_has_begun", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "has_armap", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "is_thin_archive", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "no_element_cache", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "selective_search", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "is_linker_output", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "is_linker_input", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "plugin_format", ty = "bfd_plugin_format", bits = "17..=18")]
    #[bitfield(name = "lto_output", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "lto_slim_object", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "read_only", ty = "libc::c_uint", bits = "21..=21")]
    pub format_direction_cacheable_target_defaulted_opened_once_mtime_set_no_export_output_has_begun_has_armap_is_thin_archive_no_element_cache_selective_search_is_linker_output_is_linker_input_plugin_format_lto_output_lto_slim_object_read_only: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 5],
    pub plugin_dummy_bfd: *mut bfd,
    pub origin: ufile_ptr,
    pub proxy_origin: ufile_ptr,
    pub section_htab: bfd_hash_table,
    pub sections: *mut bfd_section,
    pub section_last: *mut bfd_section,
    pub section_count: libc::c_uint,
    pub archive_plugin_fd: libc::c_int,
    pub archive_plugin_fd_open_count: libc::c_uint,
    pub archive_pass: libc::c_int,
    pub start_address: bfd_vma,
    pub outsymbols: *mut *mut bfd_symbol,
    pub symcount: libc::c_uint,
    pub dynsymcount: libc::c_uint,
    pub arch_info: *const bfd_arch_info,
    pub size: ufile_ptr,
    pub arelt_data: *mut libc::c_void,
    pub my_archive: *mut bfd,
    pub archive_next: *mut bfd,
    pub archive_head: *mut bfd,
    pub nested_archives: *mut bfd,
    pub link: C2RustUnnamed_19,
    pub tdata: C2RustUnnamed,
    pub usrdata: *mut libc::c_void,
    pub memory: *mut libc::c_void,
    pub build_id: *const bfd_build_id,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_build_id {
    pub size: bfd_size_type,
    pub data: [bfd_byte; 1],
}
pub type bfd_byte = libc::c_uchar;
pub type bfd_size_type = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
    pub aout_data: *mut aout_data_struct,
    pub aout_ar_data: *mut artdata,
    pub coff_obj_data: *mut coff_tdata,
    pub pe_obj_data: *mut pe_tdata,
    pub xcoff_obj_data: *mut xcoff_tdata,
    pub ecoff_obj_data: *mut ecoff_tdata,
    pub srec_data: *mut srec_data_struct,
    pub verilog_data: *mut verilog_data_struct,
    pub ihex_data: *mut ihex_data_struct,
    pub tekhex_data: *mut tekhex_data_struct,
    pub elf_obj_data: *mut elf_obj_tdata,
    pub mmo_data: *mut mmo_data_struct,
    pub sun_core_data: *mut sun_core_struct,
    pub sco5_core_data: *mut sco5_core_struct,
    pub trad_core_data: *mut trad_core_struct,
    pub som_data: *mut som_data_struct,
    pub hpux_core_data: *mut hpux_core_struct,
    pub hppabsd_core_data: *mut hppabsd_core_struct,
    pub sgi_core_data: *mut sgi_core_struct,
    pub lynx_core_data: *mut lynx_core_struct,
    pub osf_core_data: *mut osf_core_struct,
    pub cisco_core_data: *mut cisco_core_struct,
    pub versados_data: *mut versados_data_struct,
    pub netbsd_core_data: *mut netbsd_core_struct,
    pub mach_o_data: *mut mach_o_data_struct,
    pub mach_o_fat_data: *mut mach_o_fat_data_struct,
    pub plugin_data: *mut plugin_data_struct,
    pub pef_data: *mut bfd_pef_data_struct,
    pub pef_xlib_data: *mut bfd_pef_xlib_data_struct,
    pub sym_data: *mut bfd_sym_data_struct,
    pub any: *mut libc::c_void,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_obj_tdata {
    pub elf_header: [Elf_Internal_Ehdr; 1],
    pub elf_sect_ptr: *mut *mut Elf_Internal_Shdr,
    pub phdr: *mut Elf_Internal_Phdr,
    pub symtab_hdr: Elf_Internal_Shdr,
    pub shstrtab_hdr: Elf_Internal_Shdr,
    pub strtab_hdr: Elf_Internal_Shdr,
    pub dynsymtab_hdr: Elf_Internal_Shdr,
    pub dynstrtab_hdr: Elf_Internal_Shdr,
    pub dynversym_hdr: Elf_Internal_Shdr,
    pub dynverref_hdr: Elf_Internal_Shdr,
    pub dynverdef_hdr: Elf_Internal_Shdr,
    pub symtab_shndx_list: *mut elf_section_list,
    pub gp: bfd_vma,
    pub gp_size: libc::c_uint,
    pub num_elf_sections: libc::c_uint,
    pub being_created: *mut libc::c_uchar,
    pub sym_hashes: *mut *mut elf_link_hash_entry,
    pub local_got: C2RustUnnamed_15,
    pub dt_name: *const libc::c_char,
    pub dt_audit: *const libc::c_char,
    pub line_info: *mut libc::c_void,
    pub dwarf1_find_line_info: *mut dwarf1_debug,
    pub dwarf2_find_line_info: *mut libc::c_void,
    pub elf_find_function_cache: *mut libc::c_void,
    pub cverdefs: libc::c_uint,
    pub cverrefs: libc::c_uint,
    pub verdef: *mut Elf_Internal_Verdef,
    pub verref: *mut Elf_Internal_Verneed,
    pub eh_frame_section: *mut asection,
    pub symbuf: *mut libc::c_void,
    pub properties: *mut elf_property_list,
    pub known_obj_attributes: [[obj_attribute; 71]; 2],
    pub other_obj_attributes: [*mut obj_attribute_list; 2],
    pub sdt_note_head: *mut sdt_note,
    pub group_sect_ptr: *mut *mut Elf_Internal_Shdr,
    pub num_group: libc::c_uint,
    pub group_search_offset: libc::c_uint,
    pub symtab_section: libc::c_uint,
    pub dynsymtab_section: libc::c_uint,
    pub dynversym_section: libc::c_uint,
    pub dynverdef_section: libc::c_uint,
    pub dynverref_section: libc::c_uint,
    #[bitfield(name = "object_id", ty = "elf_target_id", bits = "0..=5")]
    #[bitfield(name = "dyn_lib_class", ty = "dynamic_lib_link_class", bits = "6..=9")]
    #[bitfield(name = "has_gnu_osabi", ty = "elf_gnu_osabi", bits = "10..=13")]
    #[bitfield(name = "has_no_copy_on_protected", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "bad_symtab", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "is_pie", ty = "libc::c_uint", bits = "16..=16")]
    pub object_id_dyn_lib_class_has_gnu_osabi_has_no_copy_on_protected_bad_symtab_is_pie: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub core: *mut core_elf_obj_tdata,
    pub o: *mut output_elf_obj_tdata,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct output_elf_obj_tdata {
    pub seg_map: *mut elf_segment_map,
    pub strtab_ptr: *mut elf_strtab_hash,
    pub section_syms: *mut *mut asymbol,
    pub eh_frame_hdr: *mut asection,
    pub build_id: C2RustUnnamed_13,
    pub program_header_size: bfd_size_type,
    pub next_file_pos: file_ptr,
    pub link_info: *mut bfd_link_info,
    pub num_section_syms: libc::c_int,
    pub shstrtab_section: libc::c_uint,
    pub strtab_section: libc::c_uint,
    pub stack_flags: libc::c_uint,
    pub flags_init: bool,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_link_info {
    #[bitfield(name = "type_0", ty = "output_type", bits = "0..=1")]
    #[bitfield(name = "symbolic", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "nocopyreloc", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "export_dynamic", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "create_default_symver", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "gc_sections", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "gc_keep_exported", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "notice_all", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "lto_plugin_active", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "lto_all_symbols_read", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "strip_discarded", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "dynamic_data", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "resolve_section_groups", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "big_endian", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "strip", ty = "bfd_link_strip", bits = "15..=16")]
    #[bitfield(name = "discard", ty = "bfd_link_discard", bits = "17..=18")]
    #[bitfield(name = "elf_stt_common", ty = "bfd_link_elf_stt_common", bits = "19..=20")]
    #[bitfield(name = "common_skip_ar_symbols", ty = "bfd_link_common_skip_ar_symbols", bits = "21..=22")]
    #[bitfield(name = "unresolved_syms_in_objects", ty = "report_method", bits = "23..=24")]
    #[bitfield(name = "unresolved_syms_in_shared_libs", ty = "report_method", bits = "25..=26")]
    #[bitfield(name = "warn_unresolved_syms", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "static_link", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "keep_memory", ty = "libc::c_uint", bits = "29..=29")]
    #[bitfield(name = "emitrelocations", ty = "libc::c_uint", bits = "30..=30")]
    #[bitfield(name = "relro", ty = "libc::c_uint", bits = "31..=31")]
    #[bitfield(name = "separate_code", ty = "libc::c_uint", bits = "32..=32")]
    #[bitfield(name = "eh_frame_hdr_type", ty = "libc::c_uint", bits = "33..=34")]
    #[bitfield(name = "textrel_check", ty = "textrel_check_method", bits = "35..=36")]
    #[bitfield(name = "emit_hash", ty = "libc::c_uint", bits = "37..=37")]
    #[bitfield(name = "emit_gnu_hash", ty = "libc::c_uint", bits = "38..=38")]
    #[bitfield(name = "reduce_memory_overheads", ty = "libc::c_uint", bits = "39..=39")]
    #[bitfield(name = "traditional_format", ty = "libc::c_uint", bits = "40..=40")]
    #[bitfield(name = "combreloc", ty = "libc::c_uint", bits = "41..=41")]
    #[bitfield(name = "default_imported_symver", ty = "libc::c_uint", bits = "42..=42")]
    #[bitfield(name = "new_dtags", ty = "libc::c_uint", bits = "43..=43")]
    #[bitfield(name = "no_ld_generated_unwind_info", ty = "libc::c_uint", bits = "44..=44")]
    #[bitfield(name = "task_link", ty = "libc::c_uint", bits = "45..=45")]
    #[bitfield(name = "allow_multiple_definition", ty = "libc::c_uint", bits = "46..=46")]
    #[bitfield(name = "prohibit_multiple_definition_absolute", ty = "libc::c_uint", bits = "47..=47")]
    #[bitfield(name = "warn_multiple_definition", ty = "libc::c_uint", bits = "48..=48")]
    #[bitfield(name = "allow_undefined_version", ty = "libc::c_uint", bits = "49..=49")]
    #[bitfield(name = "dynamic", ty = "libc::c_uint", bits = "50..=50")]
    #[bitfield(name = "execstack", ty = "libc::c_uint", bits = "51..=51")]
    #[bitfield(name = "noexecstack", ty = "libc::c_uint", bits = "52..=52")]
    #[bitfield(name = "optimize", ty = "libc::c_uint", bits = "53..=53")]
    #[bitfield(name = "print_gc_sections", ty = "libc::c_uint", bits = "54..=54")]
    #[bitfield(name = "warn_alternate_em", ty = "libc::c_uint", bits = "55..=55")]
    #[bitfield(name = "user_phdrs", ty = "libc::c_uint", bits = "56..=56")]
    #[bitfield(name = "load_phdrs", ty = "libc::c_uint", bits = "57..=57")]
    #[bitfield(name = "check_relocs_after_open_input", ty = "libc::c_uint", bits = "58..=58")]
    #[bitfield(name = "nointerp", ty = "libc::c_uint", bits = "59..=59")]
    #[bitfield(name = "inhibit_common_definition", ty = "libc::c_uint", bits = "60..=60")]
    #[bitfield(name = "has_map_file", ty = "libc::c_uint", bits = "61..=61")]
    #[bitfield(name = "non_contiguous_regions", ty = "libc::c_uint", bits = "62..=62")]
    #[bitfield(name = "non_contiguous_regions_warnings", ty = "libc::c_uint", bits = "63..=63")]
    #[bitfield(name = "unique_symbol", ty = "libc::c_uint", bits = "64..=64")]
    pub type_0_symbolic_nocopyreloc_export_dynamic_create_default_symver_gc_sections_gc_keep_exported_notice_all_lto_plugin_active_lto_all_symbols_read_strip_discarded_dynamic_data_resolve_section_groups_big_endian_strip_discard_elf_stt_common_common_skip_ar_symbols_unresolved_syms_in_objects_unresolved_syms_in_shared_libs_warn_unresolved_syms_static_link_keep_memory_emitrelocations_relro_separate_code_eh_frame_hdr_type_textrel_check_emit_hash_emit_gnu_hash_reduce_memory_overheads_traditional_format_combreloc_default_imported_symver_new_dtags_no_ld_generated_unwind_info_task_link_allow_multiple_definition_prohibit_multiple_definition_absolute_warn_multiple_definition_allow_undefined_version_dynamic_execstack_noexecstack_optimize_print_gc_sections_warn_alternate_em_user_phdrs_load_phdrs_check_relocs_after_open_input_nointerp_inhibit_common_definition_has_map_file_non_contiguous_regions_non_contiguous_regions_warnings_unique_symbol: [u8; 9],
    pub wrap_char: libc::c_char,
    pub path_separator: libc::c_char,
    pub compress_debug: compressed_debug_section_type,
    pub stacksize: bfd_signed_vma,
    pub disable_target_specific_optimizations: libc::c_int,
    pub callbacks: *const bfd_link_callbacks,
    pub hash: *mut bfd_link_hash_table,
    pub keep_hash: *mut bfd_hash_table,
    pub notice_hash: *mut bfd_hash_table,
    pub wrap_hash: *mut bfd_hash_table,
    pub ignore_hash: *mut bfd_hash_table,
    pub output_bfd: *mut bfd,
    pub out_implib_bfd: *mut bfd,
    pub input_bfds: *mut bfd,
    pub input_bfds_tail: *mut *mut bfd,
    pub create_object_symbols_section: *mut asection,
    pub gc_sym_list: *mut bfd_sym_chain,
    pub base_file: *mut libc::c_void,
    pub init_function: *const libc::c_char,
    pub fini_function: *const libc::c_char,
    pub relax_pass: libc::c_int,
    pub relax_trip: libc::c_int,
    pub extern_protected_data: libc::c_int,
    pub dynamic_undefined_weak: libc::c_int,
    pub pei386_auto_import: libc::c_int,
    pub pei386_runtime_pseudo_reloc: libc::c_int,
    pub spare_dynamic_tags: libc::c_uint,
    pub flags: bfd_vma,
    pub flags_1: bfd_vma,
    pub gnu_flags_1: bfd_vma,
    pub start_stop_gc: libc::c_int,
    pub start_stop_visibility: libc::c_uint,
    pub maxpagesize: bfd_vma,
    pub commonpagesize: bfd_vma,
    pub relro_start: bfd_vma,
    pub relro_end: bfd_vma,
    pub dynamic_list: *mut bfd_elf_dynamic_list,
    pub version_info: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_tree {
    pub next: *mut bfd_elf_version_tree,
    pub name: *const libc::c_char,
    pub vernum: libc::c_uint,
    pub globals: bfd_elf_version_expr_head,
    pub locals: bfd_elf_version_expr_head,
    pub deps: *mut bfd_elf_version_deps,
    pub name_indx: libc::c_uint,
    pub used: libc::c_int,
    pub match_0: Option::<
        unsafe extern "C" fn(
            *mut bfd_elf_version_expr_head,
            *mut bfd_elf_version_expr,
            *const libc::c_char,
        ) -> *mut bfd_elf_version_expr,
    >,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_elf_version_expr {
    pub next: *mut bfd_elf_version_expr,
    pub pattern: *const libc::c_char,
    #[bitfield(name = "literal", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "symver", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "script", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "mask", ty = "libc::c_uint", bits = "3..=5")]
    pub literal_symver_script_mask: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 7],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_expr_head {
    pub list: *mut bfd_elf_version_expr,
    pub htab: *mut libc::c_void,
    pub remaining: *mut bfd_elf_version_expr,
    pub mask: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_version_deps {
    pub next: *mut bfd_elf_version_deps,
    pub version_needed: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_dynamic_list {
    pub head: bfd_elf_version_expr_head,
    pub match_0: Option::<
        unsafe extern "C" fn(
            *mut bfd_elf_version_expr_head,
            *mut bfd_elf_version_expr,
            *const libc::c_char,
        ) -> *mut bfd_elf_version_expr,
    >,
}
pub type bfd_vma = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_sym_chain {
    pub next: *mut bfd_sym_chain,
    pub name: *const libc::c_char,
}
pub type asection = bfd_section;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_section {
    pub name: *const libc::c_char,
    pub id: libc::c_uint,
    pub section_id: libc::c_uint,
    pub index: libc::c_uint,
    pub next: *mut bfd_section,
    pub prev: *mut bfd_section,
    pub flags: flagword,
    #[bitfield(name = "user_set_vma", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "linker_mark", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "linker_has_input", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "gc_mark", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "compress_status", ty = "libc::c_uint", bits = "4..=5")]
    #[bitfield(name = "segment_mark", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "sec_info_type", ty = "libc::c_uint", bits = "7..=9")]
    #[bitfield(name = "use_rela_p", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "sec_flg0", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "sec_flg1", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "sec_flg2", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "sec_flg3", ty = "libc::c_uint", bits = "14..=14")]
    #[bitfield(name = "sec_flg4", ty = "libc::c_uint", bits = "15..=15")]
    #[bitfield(name = "sec_flg5", ty = "libc::c_uint", bits = "16..=16")]
    pub user_set_vma_linker_mark_linker_has_input_gc_mark_compress_status_segment_mark_sec_info_type_use_rela_p_sec_flg0_sec_flg1_sec_flg2_sec_flg3_sec_flg4_sec_flg5: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub vma: bfd_vma,
    pub lma: bfd_vma,
    pub size: bfd_size_type,
    pub rawsize: bfd_size_type,
    pub compressed_size: bfd_size_type,
    pub relax: *mut relax_table,
    pub relax_count: libc::c_int,
    pub output_offset: bfd_vma,
    pub output_section: *mut bfd_section,
    pub alignment_power: libc::c_uint,
    pub relocation: *mut reloc_cache_entry,
    pub orelocation: *mut *mut reloc_cache_entry,
    pub reloc_count: libc::c_uint,
    pub filepos: file_ptr,
    pub rel_filepos: file_ptr,
    pub line_filepos: file_ptr,
    pub userdata: *mut libc::c_void,
    pub contents: *mut libc::c_uchar,
    pub lineno: *mut alent,
    pub lineno_count: libc::c_uint,
    pub entsize: libc::c_uint,
    pub kept_section: *mut bfd_section,
    pub moving_line_filepos: file_ptr,
    pub target_index: libc::c_int,
    pub used_by_bfd: *mut libc::c_void,
    pub constructor_chain: *mut relent_chain,
    pub owner: *mut bfd,
    pub symbol: *mut bfd_symbol,
    pub symbol_ptr_ptr: *mut *mut bfd_symbol,
    pub map_head: C2RustUnnamed_0,
    pub map_tail: C2RustUnnamed_0,
    pub already_assigned: *mut bfd_section,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub link_order: *mut bfd_link_order,
    pub s: *mut bfd_section,
    pub linked_to_symbol_name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_order {
    pub next: *mut bfd_link_order,
    pub type_0: bfd_link_order_type,
    pub offset: bfd_vma,
    pub size: bfd_size_type,
    pub u: C2RustUnnamed_1,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub indirect: C2RustUnnamed_5,
    pub data: C2RustUnnamed_4,
    pub reloc: C2RustUnnamed_2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub p: *mut bfd_link_order_reloc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_order_reloc {
    pub reloc: bfd_reloc_code_real_type,
    pub u: C2RustUnnamed_3,
    pub addend: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub section: *mut asection,
    pub name: *const libc::c_char,
}
pub type bfd_reloc_code_real_type = bfd_reloc_code_real;
pub type bfd_reloc_code_real = libc::c_uint;
pub const BFD_RELOC_UNUSED: bfd_reloc_code_real = 2383;
pub const BFD_RELOC_S12Z_OPR: bfd_reloc_code_real = 2382;
pub const BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4: bfd_reloc_code_real = 2381;
pub const BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4: bfd_reloc_code_real = 2380;
pub const BFD_RELOC_CKCORE_IRELATIVE: bfd_reloc_code_real = 2379;
pub const BFD_RELOC_CKCORE_CALLGRAPH: bfd_reloc_code_real = 2378;
pub const BFD_RELOC_CKCORE_NOJSRI: bfd_reloc_code_real = 2377;
pub const BFD_RELOC_CKCORE_PCREL_FLRW_IMM8BY4: bfd_reloc_code_real = 2376;
pub const BFD_RELOC_CKCORE_TLS_TPOFF32: bfd_reloc_code_real = 2375;
pub const BFD_RELOC_CKCORE_TLS_DTPOFF32: bfd_reloc_code_real = 2374;
pub const BFD_RELOC_CKCORE_TLS_DTPMOD32: bfd_reloc_code_real = 2373;
pub const BFD_RELOC_CKCORE_TLS_LDO32: bfd_reloc_code_real = 2372;
pub const BFD_RELOC_CKCORE_TLS_LDM32: bfd_reloc_code_real = 2371;
pub const BFD_RELOC_CKCORE_TLS_GD32: bfd_reloc_code_real = 2370;
pub const BFD_RELOC_CKCORE_TLS_IE32: bfd_reloc_code_real = 2369;
pub const BFD_RELOC_CKCORE_TLS_LE32: bfd_reloc_code_real = 2368;
pub const BFD_RELOC_CKCORE_PCREL_IMM7BY4: bfd_reloc_code_real = 2367;
pub const BFD_RELOC_CKCORE_PLT_IMM18BY4: bfd_reloc_code_real = 2366;
pub const BFD_RELOC_CKCORE_GOT_IMM18BY4: bfd_reloc_code_real = 2365;
pub const BFD_RELOC_CKCORE_GOTOFF_IMM18: bfd_reloc_code_real = 2364;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18BY4: bfd_reloc_code_real = 2363;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18BY2: bfd_reloc_code_real = 2362;
pub const BFD_RELOC_CKCORE_DOFFSET_IMM18: bfd_reloc_code_real = 2361;
pub const BFD_RELOC_CKCORE_PCREL_IMM18BY2: bfd_reloc_code_real = 2360;
pub const BFD_RELOC_CKCORE_DOFFSET_LO16: bfd_reloc_code_real = 2359;
pub const BFD_RELOC_CKCORE_TOFFSET_LO16: bfd_reloc_code_real = 2358;
pub const BFD_RELOC_CKCORE_PCREL_JSR_IMM26BY2: bfd_reloc_code_real = 2357;
pub const BFD_RELOC_CKCORE_ADDRPLT_LO16: bfd_reloc_code_real = 2356;
pub const BFD_RELOC_CKCORE_ADDRPLT_HI16: bfd_reloc_code_real = 2355;
pub const BFD_RELOC_CKCORE_ADDRGOT_LO16: bfd_reloc_code_real = 2354;
pub const BFD_RELOC_CKCORE_ADDRGOT_HI16: bfd_reloc_code_real = 2353;
pub const BFD_RELOC_CKCORE_PLT_LO16: bfd_reloc_code_real = 2352;
pub const BFD_RELOC_CKCORE_PLT_HI16: bfd_reloc_code_real = 2351;
pub const BFD_RELOC_CKCORE_PLT12: bfd_reloc_code_real = 2350;
pub const BFD_RELOC_CKCORE_GOT_LO16: bfd_reloc_code_real = 2349;
pub const BFD_RELOC_CKCORE_GOT_HI16: bfd_reloc_code_real = 2348;
pub const BFD_RELOC_CKCORE_GOT12: bfd_reloc_code_real = 2347;
pub const BFD_RELOC_CKCORE_GOTOFF_LO16: bfd_reloc_code_real = 2346;
pub const BFD_RELOC_CKCORE_GOTOFF_HI16: bfd_reloc_code_real = 2345;
pub const BFD_RELOC_CKCORE_GOTPC_LO16: bfd_reloc_code_real = 2344;
pub const BFD_RELOC_CKCORE_GOTPC_HI16: bfd_reloc_code_real = 2343;
pub const BFD_RELOC_CKCORE_ADDR_LO16: bfd_reloc_code_real = 2342;
pub const BFD_RELOC_CKCORE_ADDR_HI16: bfd_reloc_code_real = 2341;
pub const BFD_RELOC_CKCORE_PCREL_IMM10BY4: bfd_reloc_code_real = 2340;
pub const BFD_RELOC_CKCORE_PCREL_IMM10BY2: bfd_reloc_code_real = 2339;
pub const BFD_RELOC_CKCORE_PCREL_IMM16BY4: bfd_reloc_code_real = 2338;
pub const BFD_RELOC_CKCORE_PCREL_IMM16BY2: bfd_reloc_code_real = 2337;
pub const BFD_RELOC_CKCORE_PCREL_IMM26BY2: bfd_reloc_code_real = 2336;
pub const BFD_RELOC_CKCORE_ADDRPLT: bfd_reloc_code_real = 2335;
pub const BFD_RELOC_CKCORE_ADDRGOT: bfd_reloc_code_real = 2334;
pub const BFD_RELOC_CKCORE_PLT32: bfd_reloc_code_real = 2333;
pub const BFD_RELOC_CKCORE_GOT32: bfd_reloc_code_real = 2332;
pub const BFD_RELOC_CKCORE_GOTPC: bfd_reloc_code_real = 2331;
pub const BFD_RELOC_CKCORE_GOTOFF: bfd_reloc_code_real = 2330;
pub const BFD_RELOC_CKCORE_JUMP_SLOT: bfd_reloc_code_real = 2329;
pub const BFD_RELOC_CKCORE_GLOB_DAT: bfd_reloc_code_real = 2328;
pub const BFD_RELOC_CKCORE_COPY: bfd_reloc_code_real = 2327;
pub const BFD_RELOC_CKCORE_RELATIVE: bfd_reloc_code_real = 2326;
pub const BFD_RELOC_CKCORE_GNU_VTENTRY: bfd_reloc_code_real = 2325;
pub const BFD_RELOC_CKCORE_GNU_VTINHERIT: bfd_reloc_code_real = 2324;
pub const BFD_RELOC_CKCORE_PCREL_JSR_IMM11BY2: bfd_reloc_code_real = 2323;
pub const BFD_RELOC_CKCORE_PCREL32: bfd_reloc_code_real = 2322;
pub const BFD_RELOC_CKCORE_PCREL_IMM4BY2: bfd_reloc_code_real = 2321;
pub const BFD_RELOC_CKCORE_PCREL_IMM11BY2: bfd_reloc_code_real = 2320;
pub const BFD_RELOC_CKCORE_PCREL_IMM8BY4: bfd_reloc_code_real = 2319;
pub const BFD_RELOC_CKCORE_ADDR32: bfd_reloc_code_real = 2318;
pub const BFD_RELOC_CKCORE_NONE: bfd_reloc_code_real = 2317;
pub const BFD_RELOC_WASM32_PLT_SIG: bfd_reloc_code_real = 2316;
pub const BFD_RELOC_WASM32_INDEX: bfd_reloc_code_real = 2315;
pub const BFD_RELOC_WASM32_CODE_POINTER: bfd_reloc_code_real = 2314;
pub const BFD_RELOC_WASM32_COPY: bfd_reloc_code_real = 2313;
pub const BFD_RELOC_WASM32_ABS32_CODE: bfd_reloc_code_real = 2312;
pub const BFD_RELOC_WASM32_PLT_INDEX: bfd_reloc_code_real = 2311;
pub const BFD_RELOC_WASM32_LEB128_PLT: bfd_reloc_code_real = 2310;
pub const BFD_RELOC_WASM32_LEB128_GOT_CODE: bfd_reloc_code_real = 2309;
pub const BFD_RELOC_WASM32_LEB128_GOT: bfd_reloc_code_real = 2308;
pub const BFD_RELOC_WASM32_LEB128: bfd_reloc_code_real = 2307;
pub const BFD_RELOC_VISIUM_IM16_PCREL: bfd_reloc_code_real = 2306;
pub const BFD_RELOC_VISIUM_LO16_PCREL: bfd_reloc_code_real = 2305;
pub const BFD_RELOC_VISIUM_HI16_PCREL: bfd_reloc_code_real = 2304;
pub const BFD_RELOC_VISIUM_REL16: bfd_reloc_code_real = 2303;
pub const BFD_RELOC_VISIUM_IM16: bfd_reloc_code_real = 2302;
pub const BFD_RELOC_VISIUM_LO16: bfd_reloc_code_real = 2301;
pub const BFD_RELOC_VISIUM_HI16: bfd_reloc_code_real = 2300;
pub const BFD_RELOC_EPIPHANY_IMM8: bfd_reloc_code_real = 2299;
pub const BFD_RELOC_EPIPHANY_IMM11: bfd_reloc_code_real = 2298;
pub const BFD_RELOC_EPIPHANY_SIMM11: bfd_reloc_code_real = 2297;
pub const BFD_RELOC_EPIPHANY_LOW: bfd_reloc_code_real = 2296;
pub const BFD_RELOC_EPIPHANY_HIGH: bfd_reloc_code_real = 2295;
pub const BFD_RELOC_EPIPHANY_SIMM24: bfd_reloc_code_real = 2294;
pub const BFD_RELOC_EPIPHANY_SIMM8: bfd_reloc_code_real = 2293;
pub const BFD_RELOC_BPF_DISP32: bfd_reloc_code_real = 2292;
pub const BFD_RELOC_BPF_DISP16: bfd_reloc_code_real = 2291;
pub const BFD_RELOC_BPF_16: bfd_reloc_code_real = 2290;
pub const BFD_RELOC_BPF_32: bfd_reloc_code_real = 2289;
pub const BFD_RELOC_BPF_64: bfd_reloc_code_real = 2288;
pub const BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD: bfd_reloc_code_real = 2287;
pub const BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD: bfd_reloc_code_real = 2286;
pub const BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD: bfd_reloc_code_real = 2285;
pub const BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD: bfd_reloc_code_real = 2284;
pub const BFD_RELOC_TILEGX_TLS_IE_LOAD: bfd_reloc_code_real = 2283;
pub const BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD: bfd_reloc_code_real = 2282;
pub const BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD: bfd_reloc_code_real = 2281;
pub const BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD: bfd_reloc_code_real = 2280;
pub const BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD: bfd_reloc_code_real = 2279;
pub const BFD_RELOC_TILEGX_TLS_GD_CALL: bfd_reloc_code_real = 2278;
pub const BFD_RELOC_TILEGX_TLS_TPOFF32: bfd_reloc_code_real = 2277;
pub const BFD_RELOC_TILEGX_TLS_DTPOFF32: bfd_reloc_code_real = 2276;
pub const BFD_RELOC_TILEGX_TLS_DTPMOD32: bfd_reloc_code_real = 2275;
pub const BFD_RELOC_TILEGX_TLS_TPOFF64: bfd_reloc_code_real = 2274;
pub const BFD_RELOC_TILEGX_TLS_DTPOFF64: bfd_reloc_code_real = 2273;
pub const BFD_RELOC_TILEGX_TLS_DTPMOD64: bfd_reloc_code_real = 2272;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE: bfd_reloc_code_real = 2271;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE: bfd_reloc_code_real = 2270;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE: bfd_reloc_code_real = 2269;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE: bfd_reloc_code_real = 2268;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL: bfd_reloc_code_real = 2267;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL: bfd_reloc_code_real = 2266;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL: bfd_reloc_code_real = 2265;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL: bfd_reloc_code_real = 2264;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL: bfd_reloc_code_real = 2263;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL: bfd_reloc_code_real = 2262;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE: bfd_reloc_code_real = 2261;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE: bfd_reloc_code_real = 2260;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD: bfd_reloc_code_real = 2259;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD: bfd_reloc_code_real = 2258;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD: bfd_reloc_code_real = 2257;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD: bfd_reloc_code_real = 2256;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE: bfd_reloc_code_real = 2255;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE: bfd_reloc_code_real = 2254;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE: bfd_reloc_code_real = 2253;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE: bfd_reloc_code_real = 2252;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE: bfd_reloc_code_real = 2251;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE: bfd_reloc_code_real = 2250;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD: bfd_reloc_code_real = 2249;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD: bfd_reloc_code_real = 2248;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL: bfd_reloc_code_real = 2247;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL: bfd_reloc_code_real = 2246;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT: bfd_reloc_code_real = 2245;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT: bfd_reloc_code_real = 2244;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT: bfd_reloc_code_real = 2243;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT: bfd_reloc_code_real = 2242;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL: bfd_reloc_code_real = 2241;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL: bfd_reloc_code_real = 2240;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL: bfd_reloc_code_real = 2239;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL: bfd_reloc_code_real = 2238;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL: bfd_reloc_code_real = 2237;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL: bfd_reloc_code_real = 2236;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT: bfd_reloc_code_real = 2235;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT: bfd_reloc_code_real = 2234;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL: bfd_reloc_code_real = 2233;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL: bfd_reloc_code_real = 2232;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL: bfd_reloc_code_real = 2231;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL: bfd_reloc_code_real = 2230;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL: bfd_reloc_code_real = 2229;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL: bfd_reloc_code_real = 2228;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL: bfd_reloc_code_real = 2227;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL: bfd_reloc_code_real = 2226;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL: bfd_reloc_code_real = 2225;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL: bfd_reloc_code_real = 2224;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL: bfd_reloc_code_real = 2223;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL: bfd_reloc_code_real = 2222;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL: bfd_reloc_code_real = 2221;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL: bfd_reloc_code_real = 2220;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST: bfd_reloc_code_real = 2219;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST: bfd_reloc_code_real = 2218;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST: bfd_reloc_code_real = 2217;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST: bfd_reloc_code_real = 2216;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST: bfd_reloc_code_real = 2215;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST: bfd_reloc_code_real = 2214;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW3: bfd_reloc_code_real = 2213;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW3: bfd_reloc_code_real = 2212;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW2: bfd_reloc_code_real = 2211;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW2: bfd_reloc_code_real = 2210;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW1: bfd_reloc_code_real = 2209;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW1: bfd_reloc_code_real = 2208;
pub const BFD_RELOC_TILEGX_IMM16_X1_HW0: bfd_reloc_code_real = 2207;
pub const BFD_RELOC_TILEGX_IMM16_X0_HW0: bfd_reloc_code_real = 2206;
pub const BFD_RELOC_TILEGX_SHAMT_Y1: bfd_reloc_code_real = 2205;
pub const BFD_RELOC_TILEGX_SHAMT_Y0: bfd_reloc_code_real = 2204;
pub const BFD_RELOC_TILEGX_SHAMT_X1: bfd_reloc_code_real = 2203;
pub const BFD_RELOC_TILEGX_SHAMT_X0: bfd_reloc_code_real = 2202;
pub const BFD_RELOC_TILEGX_MMEND_X0: bfd_reloc_code_real = 2201;
pub const BFD_RELOC_TILEGX_MMSTART_X0: bfd_reloc_code_real = 2200;
pub const BFD_RELOC_TILEGX_MF_IMM14_X1: bfd_reloc_code_real = 2199;
pub const BFD_RELOC_TILEGX_MT_IMM14_X1: bfd_reloc_code_real = 2198;
pub const BFD_RELOC_TILEGX_DEST_IMM8_X1: bfd_reloc_code_real = 2197;
pub const BFD_RELOC_TILEGX_IMM8_Y1: bfd_reloc_code_real = 2196;
pub const BFD_RELOC_TILEGX_IMM8_X1: bfd_reloc_code_real = 2195;
pub const BFD_RELOC_TILEGX_IMM8_Y0: bfd_reloc_code_real = 2194;
pub const BFD_RELOC_TILEGX_IMM8_X0: bfd_reloc_code_real = 2193;
pub const BFD_RELOC_TILEGX_JUMPOFF_X1_PLT: bfd_reloc_code_real = 2192;
pub const BFD_RELOC_TILEGX_JUMPOFF_X1: bfd_reloc_code_real = 2191;
pub const BFD_RELOC_TILEGX_BROFF_X1: bfd_reloc_code_real = 2190;
pub const BFD_RELOC_TILEGX_RELATIVE: bfd_reloc_code_real = 2189;
pub const BFD_RELOC_TILEGX_JMP_SLOT: bfd_reloc_code_real = 2188;
pub const BFD_RELOC_TILEGX_GLOB_DAT: bfd_reloc_code_real = 2187;
pub const BFD_RELOC_TILEGX_COPY: bfd_reloc_code_real = 2186;
pub const BFD_RELOC_TILEGX_HW2_LAST: bfd_reloc_code_real = 2185;
pub const BFD_RELOC_TILEGX_HW1_LAST: bfd_reloc_code_real = 2184;
pub const BFD_RELOC_TILEGX_HW0_LAST: bfd_reloc_code_real = 2183;
pub const BFD_RELOC_TILEGX_HW3: bfd_reloc_code_real = 2182;
pub const BFD_RELOC_TILEGX_HW2: bfd_reloc_code_real = 2181;
pub const BFD_RELOC_TILEGX_HW1: bfd_reloc_code_real = 2180;
pub const BFD_RELOC_TILEGX_HW0: bfd_reloc_code_real = 2179;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA: bfd_reloc_code_real = 2178;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA: bfd_reloc_code_real = 2177;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI: bfd_reloc_code_real = 2176;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI: bfd_reloc_code_real = 2175;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO: bfd_reloc_code_real = 2174;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO: bfd_reloc_code_real = 2173;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE: bfd_reloc_code_real = 2172;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE: bfd_reloc_code_real = 2171;
pub const BFD_RELOC_TILEPRO_TLS_TPOFF32: bfd_reloc_code_real = 2170;
pub const BFD_RELOC_TILEPRO_TLS_DTPOFF32: bfd_reloc_code_real = 2169;
pub const BFD_RELOC_TILEPRO_TLS_DTPMOD32: bfd_reloc_code_real = 2168;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA: bfd_reloc_code_real = 2167;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA: bfd_reloc_code_real = 2166;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI: bfd_reloc_code_real = 2165;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI: bfd_reloc_code_real = 2164;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO: bfd_reloc_code_real = 2163;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO: bfd_reloc_code_real = 2162;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE: bfd_reloc_code_real = 2161;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE: bfd_reloc_code_real = 2160;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA: bfd_reloc_code_real = 2159;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA: bfd_reloc_code_real = 2158;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI: bfd_reloc_code_real = 2157;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI: bfd_reloc_code_real = 2156;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO: bfd_reloc_code_real = 2155;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO: bfd_reloc_code_real = 2154;
pub const BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD: bfd_reloc_code_real = 2153;
pub const BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD: bfd_reloc_code_real = 2152;
pub const BFD_RELOC_TILEPRO_TLS_IE_LOAD: bfd_reloc_code_real = 2151;
pub const BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD: bfd_reloc_code_real = 2150;
pub const BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD: bfd_reloc_code_real = 2149;
pub const BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD: bfd_reloc_code_real = 2148;
pub const BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD: bfd_reloc_code_real = 2147;
pub const BFD_RELOC_TILEPRO_TLS_GD_CALL: bfd_reloc_code_real = 2146;
pub const BFD_RELOC_TILEPRO_SHAMT_Y1: bfd_reloc_code_real = 2145;
pub const BFD_RELOC_TILEPRO_SHAMT_Y0: bfd_reloc_code_real = 2144;
pub const BFD_RELOC_TILEPRO_SHAMT_X1: bfd_reloc_code_real = 2143;
pub const BFD_RELOC_TILEPRO_SHAMT_X0: bfd_reloc_code_real = 2142;
pub const BFD_RELOC_TILEPRO_MMEND_X1: bfd_reloc_code_real = 2141;
pub const BFD_RELOC_TILEPRO_MMSTART_X1: bfd_reloc_code_real = 2140;
pub const BFD_RELOC_TILEPRO_MMEND_X0: bfd_reloc_code_real = 2139;
pub const BFD_RELOC_TILEPRO_MMSTART_X0: bfd_reloc_code_real = 2138;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA: bfd_reloc_code_real = 2137;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA: bfd_reloc_code_real = 2136;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI: bfd_reloc_code_real = 2135;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI: bfd_reloc_code_real = 2134;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO: bfd_reloc_code_real = 2133;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO: bfd_reloc_code_real = 2132;
pub const BFD_RELOC_TILEPRO_IMM16_X1_GOT: bfd_reloc_code_real = 2131;
pub const BFD_RELOC_TILEPRO_IMM16_X0_GOT: bfd_reloc_code_real = 2130;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL: bfd_reloc_code_real = 2129;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL: bfd_reloc_code_real = 2128;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL: bfd_reloc_code_real = 2127;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL: bfd_reloc_code_real = 2126;
pub const BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL: bfd_reloc_code_real = 2125;
pub const BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL: bfd_reloc_code_real = 2124;
pub const BFD_RELOC_TILEPRO_IMM16_X1_PCREL: bfd_reloc_code_real = 2123;
pub const BFD_RELOC_TILEPRO_IMM16_X0_PCREL: bfd_reloc_code_real = 2122;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HA: bfd_reloc_code_real = 2121;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HA: bfd_reloc_code_real = 2120;
pub const BFD_RELOC_TILEPRO_IMM16_X1_HI: bfd_reloc_code_real = 2119;
pub const BFD_RELOC_TILEPRO_IMM16_X0_HI: bfd_reloc_code_real = 2118;
pub const BFD_RELOC_TILEPRO_IMM16_X1_LO: bfd_reloc_code_real = 2117;
pub const BFD_RELOC_TILEPRO_IMM16_X0_LO: bfd_reloc_code_real = 2116;
pub const BFD_RELOC_TILEPRO_IMM16_X1: bfd_reloc_code_real = 2115;
pub const BFD_RELOC_TILEPRO_IMM16_X0: bfd_reloc_code_real = 2114;
pub const BFD_RELOC_TILEPRO_MF_IMM15_X1: bfd_reloc_code_real = 2113;
pub const BFD_RELOC_TILEPRO_MT_IMM15_X1: bfd_reloc_code_real = 2112;
pub const BFD_RELOC_TILEPRO_DEST_IMM8_X1: bfd_reloc_code_real = 2111;
pub const BFD_RELOC_TILEPRO_IMM8_Y1: bfd_reloc_code_real = 2110;
pub const BFD_RELOC_TILEPRO_IMM8_X1: bfd_reloc_code_real = 2109;
pub const BFD_RELOC_TILEPRO_IMM8_Y0: bfd_reloc_code_real = 2108;
pub const BFD_RELOC_TILEPRO_IMM8_X0: bfd_reloc_code_real = 2107;
pub const BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT: bfd_reloc_code_real = 2106;
pub const BFD_RELOC_TILEPRO_JOFFLONG_X1: bfd_reloc_code_real = 2105;
pub const BFD_RELOC_TILEPRO_BROFF_X1: bfd_reloc_code_real = 2104;
pub const BFD_RELOC_TILEPRO_RELATIVE: bfd_reloc_code_real = 2103;
pub const BFD_RELOC_TILEPRO_JMP_SLOT: bfd_reloc_code_real = 2102;
pub const BFD_RELOC_TILEPRO_GLOB_DAT: bfd_reloc_code_real = 2101;
pub const BFD_RELOC_TILEPRO_COPY: bfd_reloc_code_real = 2100;
pub const BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC: bfd_reloc_code_real = 2099;
pub const BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2098;
pub const BFD_RELOC_AARCH64_LD_GOT_LO12_NC: bfd_reloc_code_real = 2097;
pub const BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12_NC: bfd_reloc_code_real = 2096;
pub const BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12: bfd_reloc_code_real = 2095;
pub const BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC: bfd_reloc_code_real = 2094;
pub const BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12: bfd_reloc_code_real = 2093;
pub const BFD_RELOC_AARCH64_LDST_LO12: bfd_reloc_code_real = 2092;
pub const BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP: bfd_reloc_code_real = 2091;
pub const BFD_RELOC_AARCH64_RELOC_END: bfd_reloc_code_real = 2090;
pub const BFD_RELOC_AARCH64_IRELATIVE: bfd_reloc_code_real = 2089;
pub const BFD_RELOC_AARCH64_TLSDESC: bfd_reloc_code_real = 2088;
pub const BFD_RELOC_AARCH64_TLS_TPREL: bfd_reloc_code_real = 2087;
pub const BFD_RELOC_AARCH64_TLS_DTPREL: bfd_reloc_code_real = 2086;
pub const BFD_RELOC_AARCH64_TLS_DTPMOD: bfd_reloc_code_real = 2085;
pub const BFD_RELOC_AARCH64_RELATIVE: bfd_reloc_code_real = 2084;
pub const BFD_RELOC_AARCH64_JUMP_SLOT: bfd_reloc_code_real = 2083;
pub const BFD_RELOC_AARCH64_GLOB_DAT: bfd_reloc_code_real = 2082;
pub const BFD_RELOC_AARCH64_COPY: bfd_reloc_code_real = 2081;
pub const BFD_RELOC_AARCH64_TLSDESC_CALL: bfd_reloc_code_real = 2080;
pub const BFD_RELOC_AARCH64_TLSDESC_ADD: bfd_reloc_code_real = 2079;
pub const BFD_RELOC_AARCH64_TLSDESC_LDR: bfd_reloc_code_real = 2078;
pub const BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC: bfd_reloc_code_real = 2077;
pub const BFD_RELOC_AARCH64_TLSDESC_OFF_G1: bfd_reloc_code_real = 2076;
pub const BFD_RELOC_AARCH64_TLSDESC_ADD_LO12: bfd_reloc_code_real = 2075;
pub const BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC: bfd_reloc_code_real = 2074;
pub const BFD_RELOC_AARCH64_TLSDESC_LD64_LO12: bfd_reloc_code_real = 2073;
pub const BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21: bfd_reloc_code_real = 2072;
pub const BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21: bfd_reloc_code_real = 2071;
pub const BFD_RELOC_AARCH64_TLSDESC_LD_PREL19: bfd_reloc_code_real = 2070;
pub const BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12_NC: bfd_reloc_code_real = 2069;
pub const BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12: bfd_reloc_code_real = 2068;
pub const BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12_NC: bfd_reloc_code_real = 2067;
pub const BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12: bfd_reloc_code_real = 2066;
pub const BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12_NC: bfd_reloc_code_real = 2065;
pub const BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12: bfd_reloc_code_real = 2064;
pub const BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12_NC: bfd_reloc_code_real = 2063;
pub const BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12: bfd_reloc_code_real = 2062;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC: bfd_reloc_code_real = 2061;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12: bfd_reloc_code_real = 2060;
pub const BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12: bfd_reloc_code_real = 2059;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC: bfd_reloc_code_real = 2058;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0: bfd_reloc_code_real = 2057;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC: bfd_reloc_code_real = 2056;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1: bfd_reloc_code_real = 2055;
pub const BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2: bfd_reloc_code_real = 2054;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2: bfd_reloc_code_real = 2053;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC: bfd_reloc_code_real = 2052;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1: bfd_reloc_code_real = 2051;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC: bfd_reloc_code_real = 2050;
pub const BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0: bfd_reloc_code_real = 2049;
pub const BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC: bfd_reloc_code_real = 2048;
pub const BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12: bfd_reloc_code_real = 2047;
pub const BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC: bfd_reloc_code_real = 2046;
pub const BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12: bfd_reloc_code_real = 2045;
pub const BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC: bfd_reloc_code_real = 2044;
pub const BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12: bfd_reloc_code_real = 2043;
pub const BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC: bfd_reloc_code_real = 2042;
pub const BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12: bfd_reloc_code_real = 2041;
pub const BFD_RELOC_AARCH64_TLSLD_ADR_PREL21: bfd_reloc_code_real = 2040;
pub const BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21: bfd_reloc_code_real = 2039;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC: bfd_reloc_code_real = 2038;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC: bfd_reloc_code_real = 2037;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12: bfd_reloc_code_real = 2036;
pub const BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12: bfd_reloc_code_real = 2035;
pub const BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1: bfd_reloc_code_real = 2034;
pub const BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC: bfd_reloc_code_real = 2033;
pub const BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19: bfd_reloc_code_real = 2032;
pub const BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2031;
pub const BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC: bfd_reloc_code_real = 2030;
pub const BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21: bfd_reloc_code_real = 2029;
pub const BFD_RELOC_AARCH64_TLSGD_MOVW_G1: bfd_reloc_code_real = 2028;
pub const BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC: bfd_reloc_code_real = 2027;
pub const BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC: bfd_reloc_code_real = 2026;
pub const BFD_RELOC_AARCH64_TLSGD_ADR_PREL21: bfd_reloc_code_real = 2025;
pub const BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21: bfd_reloc_code_real = 2024;
pub const BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15: bfd_reloc_code_real = 2023;
pub const BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14: bfd_reloc_code_real = 2022;
pub const BFD_RELOC_AARCH64_LD64_GOTOFF_LO15: bfd_reloc_code_real = 2021;
pub const BFD_RELOC_AARCH64_MOVW_GOTOFF_G1: bfd_reloc_code_real = 2020;
pub const BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC: bfd_reloc_code_real = 2019;
pub const BFD_RELOC_AARCH64_LD32_GOT_LO12_NC: bfd_reloc_code_real = 2018;
pub const BFD_RELOC_AARCH64_LD64_GOT_LO12_NC: bfd_reloc_code_real = 2017;
pub const BFD_RELOC_AARCH64_ADR_GOT_PAGE: bfd_reloc_code_real = 2016;
pub const BFD_RELOC_AARCH64_GOT_LD_PREL19: bfd_reloc_code_real = 2015;
pub const BFD_RELOC_AARCH64_LDST128_LO12: bfd_reloc_code_real = 2014;
pub const BFD_RELOC_AARCH64_LDST64_LO12: bfd_reloc_code_real = 2013;
pub const BFD_RELOC_AARCH64_LDST32_LO12: bfd_reloc_code_real = 2012;
pub const BFD_RELOC_AARCH64_LDST16_LO12: bfd_reloc_code_real = 2011;
pub const BFD_RELOC_AARCH64_CALL26: bfd_reloc_code_real = 2010;
pub const BFD_RELOC_AARCH64_JUMP26: bfd_reloc_code_real = 2009;
pub const BFD_RELOC_AARCH64_BRANCH19: bfd_reloc_code_real = 2008;
pub const BFD_RELOC_AARCH64_TSTBR14: bfd_reloc_code_real = 2007;
pub const BFD_RELOC_AARCH64_LDST8_LO12: bfd_reloc_code_real = 2006;
pub const BFD_RELOC_AARCH64_ADD_LO12: bfd_reloc_code_real = 2005;
pub const BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL: bfd_reloc_code_real = 2004;
pub const BFD_RELOC_AARCH64_ADR_HI21_PCREL: bfd_reloc_code_real = 2003;
pub const BFD_RELOC_AARCH64_ADR_LO21_PCREL: bfd_reloc_code_real = 2002;
pub const BFD_RELOC_AARCH64_LD_LO19_PCREL: bfd_reloc_code_real = 2001;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G3: bfd_reloc_code_real = 2000;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G2_NC: bfd_reloc_code_real = 1999;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G2: bfd_reloc_code_real = 1998;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G1_NC: bfd_reloc_code_real = 1997;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G1: bfd_reloc_code_real = 1996;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G0_NC: bfd_reloc_code_real = 1995;
pub const BFD_RELOC_AARCH64_MOVW_PREL_G0: bfd_reloc_code_real = 1994;
pub const BFD_RELOC_AARCH64_MOVW_G2_S: bfd_reloc_code_real = 1993;
pub const BFD_RELOC_AARCH64_MOVW_G1_S: bfd_reloc_code_real = 1992;
pub const BFD_RELOC_AARCH64_MOVW_G0_S: bfd_reloc_code_real = 1991;
pub const BFD_RELOC_AARCH64_MOVW_G3: bfd_reloc_code_real = 1990;
pub const BFD_RELOC_AARCH64_MOVW_G2_NC: bfd_reloc_code_real = 1989;
pub const BFD_RELOC_AARCH64_MOVW_G2: bfd_reloc_code_real = 1988;
pub const BFD_RELOC_AARCH64_MOVW_G1_NC: bfd_reloc_code_real = 1987;
pub const BFD_RELOC_AARCH64_MOVW_G1: bfd_reloc_code_real = 1986;
pub const BFD_RELOC_AARCH64_MOVW_G0_NC: bfd_reloc_code_real = 1985;
pub const BFD_RELOC_AARCH64_MOVW_G0: bfd_reloc_code_real = 1984;
pub const BFD_RELOC_AARCH64_16_PCREL: bfd_reloc_code_real = 1983;
pub const BFD_RELOC_AARCH64_32_PCREL: bfd_reloc_code_real = 1982;
pub const BFD_RELOC_AARCH64_64_PCREL: bfd_reloc_code_real = 1981;
pub const BFD_RELOC_AARCH64_16: bfd_reloc_code_real = 1980;
pub const BFD_RELOC_AARCH64_32: bfd_reloc_code_real = 1979;
pub const BFD_RELOC_AARCH64_64: bfd_reloc_code_real = 1978;
pub const BFD_RELOC_AARCH64_NONE: bfd_reloc_code_real = 1977;
pub const BFD_RELOC_AARCH64_NULL: bfd_reloc_code_real = 1976;
pub const BFD_RELOC_AARCH64_RELOC_START: bfd_reloc_code_real = 1975;
pub const BFD_RELOC_MICROBLAZE_64_TEXTREL: bfd_reloc_code_real = 1974;
pub const BFD_RELOC_MICROBLAZE_64_TEXTPCREL: bfd_reloc_code_real = 1973;
pub const BFD_RELOC_MICROBLAZE_64_TLSTPREL: bfd_reloc_code_real = 1972;
pub const BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL: bfd_reloc_code_real = 1971;
pub const BFD_RELOC_MICROBLAZE_64_TLSDTPREL: bfd_reloc_code_real = 1970;
pub const BFD_RELOC_MICROBLAZE_32_TLSDTPREL: bfd_reloc_code_real = 1969;
pub const BFD_RELOC_MICROBLAZE_32_TLSDTPMOD: bfd_reloc_code_real = 1968;
pub const BFD_RELOC_MICROBLAZE_64_TLSLD: bfd_reloc_code_real = 1967;
pub const BFD_RELOC_MICROBLAZE_64_TLSGD: bfd_reloc_code_real = 1966;
pub const BFD_RELOC_MICROBLAZE_64_TLS: bfd_reloc_code_real = 1965;
pub const BFD_RELOC_MICROBLAZE_COPY: bfd_reloc_code_real = 1964;
pub const BFD_RELOC_MICROBLAZE_32_GOTOFF: bfd_reloc_code_real = 1963;
pub const BFD_RELOC_MICROBLAZE_64_GOTOFF: bfd_reloc_code_real = 1962;
pub const BFD_RELOC_MICROBLAZE_64_PLT: bfd_reloc_code_real = 1961;
pub const BFD_RELOC_MICROBLAZE_64_GOT: bfd_reloc_code_real = 1960;
pub const BFD_RELOC_MICROBLAZE_64_GOTPC: bfd_reloc_code_real = 1959;
pub const BFD_RELOC_MICROBLAZE_64_NONE: bfd_reloc_code_real = 1958;
pub const BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM: bfd_reloc_code_real = 1957;
pub const BFD_RELOC_MICROBLAZE_32_RWSDA: bfd_reloc_code_real = 1956;
pub const BFD_RELOC_MICROBLAZE_32_ROSDA: bfd_reloc_code_real = 1955;
pub const BFD_RELOC_MICROBLAZE_32_LO_PCREL: bfd_reloc_code_real = 1954;
pub const BFD_RELOC_MICROBLAZE_32_LO: bfd_reloc_code_real = 1953;
pub const BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT: bfd_reloc_code_real = 1952;
pub const BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12: bfd_reloc_code_real = 1951;
pub const BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21: bfd_reloc_code_real = 1950;
pub const BFD_RELOC_MACH_O_ARM64_ADDEND: bfd_reloc_code_real = 1949;
pub const BFD_RELOC_MACH_O_X86_64_TLV: bfd_reloc_code_real = 1948;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_4: bfd_reloc_code_real = 1947;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_2: bfd_reloc_code_real = 1946;
pub const BFD_RELOC_MACH_O_X86_64_PCREL32_1: bfd_reloc_code_real = 1945;
pub const BFD_RELOC_MACH_O_X86_64_GOT_LOAD: bfd_reloc_code_real = 1944;
pub const BFD_RELOC_MACH_O_X86_64_GOT: bfd_reloc_code_real = 1943;
pub const BFD_RELOC_MACH_O_X86_64_BRANCH8: bfd_reloc_code_real = 1942;
pub const BFD_RELOC_MACH_O_X86_64_BRANCH32: bfd_reloc_code_real = 1941;
pub const BFD_RELOC_MACH_O_SUBTRACTOR64: bfd_reloc_code_real = 1940;
pub const BFD_RELOC_MACH_O_SUBTRACTOR32: bfd_reloc_code_real = 1939;
pub const BFD_RELOC_MACH_O_PAIR: bfd_reloc_code_real = 1938;
pub const BFD_RELOC_MACH_O_LOCAL_SECTDIFF: bfd_reloc_code_real = 1937;
pub const BFD_RELOC_MACH_O_SECTDIFF: bfd_reloc_code_real = 1936;
pub const BFD_RELOC_LM32_RELATIVE: bfd_reloc_code_real = 1935;
pub const BFD_RELOC_LM32_JMP_SLOT: bfd_reloc_code_real = 1934;
pub const BFD_RELOC_LM32_GLOB_DAT: bfd_reloc_code_real = 1933;
pub const BFD_RELOC_LM32_COPY: bfd_reloc_code_real = 1932;
pub const BFD_RELOC_LM32_GOTOFF_LO16: bfd_reloc_code_real = 1931;
pub const BFD_RELOC_LM32_GOTOFF_HI16: bfd_reloc_code_real = 1930;
pub const BFD_RELOC_LM32_16_GOT: bfd_reloc_code_real = 1929;
pub const BFD_RELOC_LM32_BRANCH: bfd_reloc_code_real = 1928;
pub const BFD_RELOC_LM32_CALL: bfd_reloc_code_real = 1927;
pub const BFD_RELOC_Z8K_IMM4L: bfd_reloc_code_real = 1926;
pub const BFD_RELOC_Z8K_CALLR: bfd_reloc_code_real = 1925;
pub const BFD_RELOC_Z8K_DISP7: bfd_reloc_code_real = 1924;
pub const BFD_RELOC_Z80_16_BE: bfd_reloc_code_real = 1923;
pub const BFD_RELOC_Z80_WORD1: bfd_reloc_code_real = 1922;
pub const BFD_RELOC_Z80_WORD0: bfd_reloc_code_real = 1921;
pub const BFD_RELOC_Z80_BYTE3: bfd_reloc_code_real = 1920;
pub const BFD_RELOC_Z80_BYTE2: bfd_reloc_code_real = 1919;
pub const BFD_RELOC_Z80_BYTE1: bfd_reloc_code_real = 1918;
pub const BFD_RELOC_Z80_BYTE0: bfd_reloc_code_real = 1917;
pub const BFD_RELOC_Z80_DISP8: bfd_reloc_code_real = 1916;
pub const BFD_RELOC_XTENSA_NDIFF32: bfd_reloc_code_real = 1915;
pub const BFD_RELOC_XTENSA_NDIFF16: bfd_reloc_code_real = 1914;
pub const BFD_RELOC_XTENSA_NDIFF8: bfd_reloc_code_real = 1913;
pub const BFD_RELOC_XTENSA_PDIFF32: bfd_reloc_code_real = 1912;
pub const BFD_RELOC_XTENSA_PDIFF16: bfd_reloc_code_real = 1911;
pub const BFD_RELOC_XTENSA_PDIFF8: bfd_reloc_code_real = 1910;
pub const BFD_RELOC_XTENSA_TLS_CALL: bfd_reloc_code_real = 1909;
pub const BFD_RELOC_XTENSA_TLS_ARG: bfd_reloc_code_real = 1908;
pub const BFD_RELOC_XTENSA_TLS_FUNC: bfd_reloc_code_real = 1907;
pub const BFD_RELOC_XTENSA_TLS_TPOFF: bfd_reloc_code_real = 1906;
pub const BFD_RELOC_XTENSA_TLS_DTPOFF: bfd_reloc_code_real = 1905;
pub const BFD_RELOC_XTENSA_TLSDESC_ARG: bfd_reloc_code_real = 1904;
pub const BFD_RELOC_XTENSA_TLSDESC_FN: bfd_reloc_code_real = 1903;
pub const BFD_RELOC_XTENSA_ASM_SIMPLIFY: bfd_reloc_code_real = 1902;
pub const BFD_RELOC_XTENSA_ASM_EXPAND: bfd_reloc_code_real = 1901;
pub const BFD_RELOC_XTENSA_OP2: bfd_reloc_code_real = 1900;
pub const BFD_RELOC_XTENSA_OP1: bfd_reloc_code_real = 1899;
pub const BFD_RELOC_XTENSA_OP0: bfd_reloc_code_real = 1898;
pub const BFD_RELOC_XTENSA_SLOT14_ALT: bfd_reloc_code_real = 1897;
pub const BFD_RELOC_XTENSA_SLOT13_ALT: bfd_reloc_code_real = 1896;
pub const BFD_RELOC_XTENSA_SLOT12_ALT: bfd_reloc_code_real = 1895;
pub const BFD_RELOC_XTENSA_SLOT11_ALT: bfd_reloc_code_real = 1894;
pub const BFD_RELOC_XTENSA_SLOT10_ALT: bfd_reloc_code_real = 1893;
pub const BFD_RELOC_XTENSA_SLOT9_ALT: bfd_reloc_code_real = 1892;
pub const BFD_RELOC_XTENSA_SLOT8_ALT: bfd_reloc_code_real = 1891;
pub const BFD_RELOC_XTENSA_SLOT7_ALT: bfd_reloc_code_real = 1890;
pub const BFD_RELOC_XTENSA_SLOT6_ALT: bfd_reloc_code_real = 1889;
pub const BFD_RELOC_XTENSA_SLOT5_ALT: bfd_reloc_code_real = 1888;
pub const BFD_RELOC_XTENSA_SLOT4_ALT: bfd_reloc_code_real = 1887;
pub const BFD_RELOC_XTENSA_SLOT3_ALT: bfd_reloc_code_real = 1886;
pub const BFD_RELOC_XTENSA_SLOT2_ALT: bfd_reloc_code_real = 1885;
pub const BFD_RELOC_XTENSA_SLOT1_ALT: bfd_reloc_code_real = 1884;
pub const BFD_RELOC_XTENSA_SLOT0_ALT: bfd_reloc_code_real = 1883;
pub const BFD_RELOC_XTENSA_SLOT14_OP: bfd_reloc_code_real = 1882;
pub const BFD_RELOC_XTENSA_SLOT13_OP: bfd_reloc_code_real = 1881;
pub const BFD_RELOC_XTENSA_SLOT12_OP: bfd_reloc_code_real = 1880;
pub const BFD_RELOC_XTENSA_SLOT11_OP: bfd_reloc_code_real = 1879;
pub const BFD_RELOC_XTENSA_SLOT10_OP: bfd_reloc_code_real = 1878;
pub const BFD_RELOC_XTENSA_SLOT9_OP: bfd_reloc_code_real = 1877;
pub const BFD_RELOC_XTENSA_SLOT8_OP: bfd_reloc_code_real = 1876;
pub const BFD_RELOC_XTENSA_SLOT7_OP: bfd_reloc_code_real = 1875;
pub const BFD_RELOC_XTENSA_SLOT6_OP: bfd_reloc_code_real = 1874;
pub const BFD_RELOC_XTENSA_SLOT5_OP: bfd_reloc_code_real = 1873;
pub const BFD_RELOC_XTENSA_SLOT4_OP: bfd_reloc_code_real = 1872;
pub const BFD_RELOC_XTENSA_SLOT3_OP: bfd_reloc_code_real = 1871;
pub const BFD_RELOC_XTENSA_SLOT2_OP: bfd_reloc_code_real = 1870;
pub const BFD_RELOC_XTENSA_SLOT1_OP: bfd_reloc_code_real = 1869;
pub const BFD_RELOC_XTENSA_SLOT0_OP: bfd_reloc_code_real = 1868;
pub const BFD_RELOC_XTENSA_DIFF32: bfd_reloc_code_real = 1867;
pub const BFD_RELOC_XTENSA_DIFF16: bfd_reloc_code_real = 1866;
pub const BFD_RELOC_XTENSA_DIFF8: bfd_reloc_code_real = 1865;
pub const BFD_RELOC_XTENSA_PLT: bfd_reloc_code_real = 1864;
pub const BFD_RELOC_XTENSA_RELATIVE: bfd_reloc_code_real = 1863;
pub const BFD_RELOC_XTENSA_JMP_SLOT: bfd_reloc_code_real = 1862;
pub const BFD_RELOC_XTENSA_GLOB_DAT: bfd_reloc_code_real = 1861;
pub const BFD_RELOC_XTENSA_RTLD: bfd_reloc_code_real = 1860;
pub const BFD_RELOC_IQ2000_UHI16: bfd_reloc_code_real = 1859;
pub const BFD_RELOC_IQ2000_OFFSET_21: bfd_reloc_code_real = 1858;
pub const BFD_RELOC_IQ2000_OFFSET_16: bfd_reloc_code_real = 1857;
pub const BFD_RELOC_PRU_GNU_DIFF32_PMEM: bfd_reloc_code_real = 1856;
pub const BFD_RELOC_PRU_GNU_DIFF16_PMEM: bfd_reloc_code_real = 1855;
pub const BFD_RELOC_PRU_GNU_DIFF32: bfd_reloc_code_real = 1854;
pub const BFD_RELOC_PRU_GNU_DIFF16: bfd_reloc_code_real = 1853;
pub const BFD_RELOC_PRU_GNU_DIFF8: bfd_reloc_code_real = 1852;
pub const BFD_RELOC_PRU_16_PMEM: bfd_reloc_code_real = 1851;
pub const BFD_RELOC_PRU_32_PMEM: bfd_reloc_code_real = 1850;
pub const BFD_RELOC_PRU_U8_PCREL: bfd_reloc_code_real = 1849;
pub const BFD_RELOC_PRU_S10_PCREL: bfd_reloc_code_real = 1848;
pub const BFD_RELOC_PRU_LDI32: bfd_reloc_code_real = 1847;
pub const BFD_RELOC_PRU_U16_PMEMIMM: bfd_reloc_code_real = 1846;
pub const BFD_RELOC_PRU_U16: bfd_reloc_code_real = 1845;
pub const BFD_RELOC_NIOS2_R2_T1X1I6_2: bfd_reloc_code_real = 1844;
pub const BFD_RELOC_NIOS2_R2_T1X1I6: bfd_reloc_code_real = 1843;
pub const BFD_RELOC_NIOS2_R2_L5I4X1: bfd_reloc_code_real = 1842;
pub const BFD_RELOC_NIOS2_R2_F1I5_2: bfd_reloc_code_real = 1841;
pub const BFD_RELOC_NIOS2_R2_X2L5: bfd_reloc_code_real = 1840;
pub const BFD_RELOC_NIOS2_R2_X1I7_2: bfd_reloc_code_real = 1839;
pub const BFD_RELOC_NIOS2_R2_T2I4_2: bfd_reloc_code_real = 1838;
pub const BFD_RELOC_NIOS2_R2_T2I4_1: bfd_reloc_code_real = 1837;
pub const BFD_RELOC_NIOS2_R2_T2I4: bfd_reloc_code_real = 1836;
pub const BFD_RELOC_NIOS2_R2_T1I7_2: bfd_reloc_code_real = 1835;
pub const BFD_RELOC_NIOS2_R2_T1I7_1_PCREL: bfd_reloc_code_real = 1834;
pub const BFD_RELOC_NIOS2_R2_I10_1_PCREL: bfd_reloc_code_real = 1833;
pub const BFD_RELOC_NIOS2_R2_S12: bfd_reloc_code_real = 1832;
pub const BFD_RELOC_NIOS2_CALL_HA: bfd_reloc_code_real = 1831;
pub const BFD_RELOC_NIOS2_CALL_LO: bfd_reloc_code_real = 1830;
pub const BFD_RELOC_NIOS2_GOT_HA: bfd_reloc_code_real = 1829;
pub const BFD_RELOC_NIOS2_GOT_LO: bfd_reloc_code_real = 1828;
pub const BFD_RELOC_NIOS2_CALL26_NOAT: bfd_reloc_code_real = 1827;
pub const BFD_RELOC_NIOS2_GOTOFF: bfd_reloc_code_real = 1826;
pub const BFD_RELOC_NIOS2_RELATIVE: bfd_reloc_code_real = 1825;
pub const BFD_RELOC_NIOS2_JUMP_SLOT: bfd_reloc_code_real = 1824;
pub const BFD_RELOC_NIOS2_GLOB_DAT: bfd_reloc_code_real = 1823;
pub const BFD_RELOC_NIOS2_COPY: bfd_reloc_code_real = 1822;
pub const BFD_RELOC_NIOS2_TLS_TPREL: bfd_reloc_code_real = 1821;
pub const BFD_RELOC_NIOS2_TLS_DTPREL: bfd_reloc_code_real = 1820;
pub const BFD_RELOC_NIOS2_TLS_DTPMOD: bfd_reloc_code_real = 1819;
pub const BFD_RELOC_NIOS2_TLS_LE16: bfd_reloc_code_real = 1818;
pub const BFD_RELOC_NIOS2_TLS_IE16: bfd_reloc_code_real = 1817;
pub const BFD_RELOC_NIOS2_TLS_LDO16: bfd_reloc_code_real = 1816;
pub const BFD_RELOC_NIOS2_TLS_LDM16: bfd_reloc_code_real = 1815;
pub const BFD_RELOC_NIOS2_TLS_GD16: bfd_reloc_code_real = 1814;
pub const BFD_RELOC_NIOS2_PCREL_HA: bfd_reloc_code_real = 1813;
pub const BFD_RELOC_NIOS2_PCREL_LO: bfd_reloc_code_real = 1812;
pub const BFD_RELOC_NIOS2_GOTOFF_HA: bfd_reloc_code_real = 1811;
pub const BFD_RELOC_NIOS2_GOTOFF_LO: bfd_reloc_code_real = 1810;
pub const BFD_RELOC_NIOS2_CALL16: bfd_reloc_code_real = 1809;
pub const BFD_RELOC_NIOS2_GOT16: bfd_reloc_code_real = 1808;
pub const BFD_RELOC_NIOS2_ALIGN: bfd_reloc_code_real = 1807;
pub const BFD_RELOC_NIOS2_CALLR: bfd_reloc_code_real = 1806;
pub const BFD_RELOC_NIOS2_CJMP: bfd_reloc_code_real = 1805;
pub const BFD_RELOC_NIOS2_UJMP: bfd_reloc_code_real = 1804;
pub const BFD_RELOC_NIOS2_GPREL: bfd_reloc_code_real = 1803;
pub const BFD_RELOC_NIOS2_HIADJ16: bfd_reloc_code_real = 1802;
pub const BFD_RELOC_NIOS2_LO16: bfd_reloc_code_real = 1801;
pub const BFD_RELOC_NIOS2_HI16: bfd_reloc_code_real = 1800;
pub const BFD_RELOC_NIOS2_IMM8: bfd_reloc_code_real = 1799;
pub const BFD_RELOC_NIOS2_IMM6: bfd_reloc_code_real = 1798;
pub const BFD_RELOC_NIOS2_CACHE_OPX: bfd_reloc_code_real = 1797;
pub const BFD_RELOC_NIOS2_IMM5: bfd_reloc_code_real = 1796;
pub const BFD_RELOC_NIOS2_CALL26: bfd_reloc_code_real = 1795;
pub const BFD_RELOC_NIOS2_U16: bfd_reloc_code_real = 1794;
pub const BFD_RELOC_NIOS2_S16: bfd_reloc_code_real = 1793;
pub const BFD_RELOC_MSP430_SUB_ULEB128: bfd_reloc_code_real = 1792;
pub const BFD_RELOC_MSP430_SET_ULEB128: bfd_reloc_code_real = 1791;
pub const BFD_RELOC_MSP430_SYM_DIFF: bfd_reloc_code_real = 1790;
pub const BFD_RELOC_MSP430_PREL31: bfd_reloc_code_real = 1789;
pub const BFD_RELOC_MSP430_ABS_HI16: bfd_reloc_code_real = 1788;
pub const BFD_RELOC_MSP430X_ABS16: bfd_reloc_code_real = 1787;
pub const BFD_RELOC_MSP430X_PCR20_CALL: bfd_reloc_code_real = 1786;
pub const BFD_RELOC_MSP430X_PCR16: bfd_reloc_code_real = 1785;
pub const BFD_RELOC_MSP430X_ABS20_ADR_DST: bfd_reloc_code_real = 1784;
pub const BFD_RELOC_MSP430X_ABS20_ADR_SRC: bfd_reloc_code_real = 1783;
pub const BFD_RELOC_MSP430X_ABS20_EXT_ODST: bfd_reloc_code_real = 1782;
pub const BFD_RELOC_MSP430X_ABS20_EXT_DST: bfd_reloc_code_real = 1781;
pub const BFD_RELOC_MSP430X_ABS20_EXT_SRC: bfd_reloc_code_real = 1780;
pub const BFD_RELOC_MSP430X_PCR20_EXT_ODST: bfd_reloc_code_real = 1779;
pub const BFD_RELOC_MSP430X_PCR20_EXT_DST: bfd_reloc_code_real = 1778;
pub const BFD_RELOC_MSP430X_PCR20_EXT_SRC: bfd_reloc_code_real = 1777;
pub const BFD_RELOC_MSP430_ABS8: bfd_reloc_code_real = 1776;
pub const BFD_RELOC_MSP430_RL_PCREL: bfd_reloc_code_real = 1775;
pub const BFD_RELOC_MSP430_2X_PCREL: bfd_reloc_code_real = 1774;
pub const BFD_RELOC_MSP430_16_BYTE: bfd_reloc_code_real = 1773;
pub const BFD_RELOC_MSP430_16_PCREL_BYTE: bfd_reloc_code_real = 1772;
pub const BFD_RELOC_MSP430_16: bfd_reloc_code_real = 1771;
pub const BFD_RELOC_MSP430_16_PCREL: bfd_reloc_code_real = 1770;
pub const BFD_RELOC_MSP430_10_PCREL: bfd_reloc_code_real = 1769;
pub const BFD_RELOC_MT_PCINSN8: bfd_reloc_code_real = 1768;
pub const BFD_RELOC_MT_GNU_VTENTRY: bfd_reloc_code_real = 1767;
pub const BFD_RELOC_MT_GNU_VTINHERIT: bfd_reloc_code_real = 1766;
pub const BFD_RELOC_MT_LO16: bfd_reloc_code_real = 1765;
pub const BFD_RELOC_MT_HI16: bfd_reloc_code_real = 1764;
pub const BFD_RELOC_MT_PC16: bfd_reloc_code_real = 1763;
pub const BFD_RELOC_VAX_RELATIVE: bfd_reloc_code_real = 1762;
pub const BFD_RELOC_VAX_JMP_SLOT: bfd_reloc_code_real = 1761;
pub const BFD_RELOC_VAX_GLOB_DAT: bfd_reloc_code_real = 1760;
pub const BFD_RELOC_XC16X_SOF: bfd_reloc_code_real = 1759;
pub const BFD_RELOC_XC16X_SEG: bfd_reloc_code_real = 1758;
pub const BFD_RELOC_XC16X_POF: bfd_reloc_code_real = 1757;
pub const BFD_RELOC_XC16X_PAG: bfd_reloc_code_real = 1756;
pub const BFD_RELOC_RELC: bfd_reloc_code_real = 1755;
pub const BFD_RELOC_XSTORMY16_FPTR16: bfd_reloc_code_real = 1754;
pub const BFD_RELOC_XSTORMY16_24: bfd_reloc_code_real = 1753;
pub const BFD_RELOC_XSTORMY16_12: bfd_reloc_code_real = 1752;
pub const BFD_RELOC_XSTORMY16_REL_12: bfd_reloc_code_real = 1751;
pub const BFD_RELOC_H8_DISP32A16: bfd_reloc_code_real = 1750;
pub const BFD_RELOC_H8_DIR32A16: bfd_reloc_code_real = 1749;
pub const BFD_RELOC_H8_DIR24R8: bfd_reloc_code_real = 1748;
pub const BFD_RELOC_H8_DIR24A8: bfd_reloc_code_real = 1747;
pub const BFD_RELOC_H8_DIR16R8: bfd_reloc_code_real = 1746;
pub const BFD_RELOC_H8_DIR16A8: bfd_reloc_code_real = 1745;
pub const BFD_RELOC_OR1K_TLS_DTPMOD: bfd_reloc_code_real = 1744;
pub const BFD_RELOC_OR1K_TLS_DTPOFF: bfd_reloc_code_real = 1743;
pub const BFD_RELOC_OR1K_TLS_TPOFF: bfd_reloc_code_real = 1742;
pub const BFD_RELOC_OR1K_TLS_LE_SLO16: bfd_reloc_code_real = 1741;
pub const BFD_RELOC_OR1K_TLS_LE_LO16: bfd_reloc_code_real = 1740;
pub const BFD_RELOC_OR1K_TLS_LE_AHI16: bfd_reloc_code_real = 1739;
pub const BFD_RELOC_OR1K_TLS_LE_HI16: bfd_reloc_code_real = 1738;
pub const BFD_RELOC_OR1K_TLS_IE_LO13: bfd_reloc_code_real = 1737;
pub const BFD_RELOC_OR1K_TLS_IE_PG21: bfd_reloc_code_real = 1736;
pub const BFD_RELOC_OR1K_TLS_IE_LO16: bfd_reloc_code_real = 1735;
pub const BFD_RELOC_OR1K_TLS_IE_AHI16: bfd_reloc_code_real = 1734;
pub const BFD_RELOC_OR1K_TLS_IE_HI16: bfd_reloc_code_real = 1733;
pub const BFD_RELOC_OR1K_TLS_LDO_LO16: bfd_reloc_code_real = 1732;
pub const BFD_RELOC_OR1K_TLS_LDO_HI16: bfd_reloc_code_real = 1731;
pub const BFD_RELOC_OR1K_TLS_LDM_LO13: bfd_reloc_code_real = 1730;
pub const BFD_RELOC_OR1K_TLS_LDM_PG21: bfd_reloc_code_real = 1729;
pub const BFD_RELOC_OR1K_TLS_LDM_LO16: bfd_reloc_code_real = 1728;
pub const BFD_RELOC_OR1K_TLS_LDM_HI16: bfd_reloc_code_real = 1727;
pub const BFD_RELOC_OR1K_TLS_GD_LO13: bfd_reloc_code_real = 1726;
pub const BFD_RELOC_OR1K_TLS_GD_PG21: bfd_reloc_code_real = 1725;
pub const BFD_RELOC_OR1K_TLS_GD_LO16: bfd_reloc_code_real = 1724;
pub const BFD_RELOC_OR1K_TLS_GD_HI16: bfd_reloc_code_real = 1723;
pub const BFD_RELOC_OR1K_RELATIVE: bfd_reloc_code_real = 1722;
pub const BFD_RELOC_OR1K_JMP_SLOT: bfd_reloc_code_real = 1721;
pub const BFD_RELOC_OR1K_GLOB_DAT: bfd_reloc_code_real = 1720;
pub const BFD_RELOC_OR1K_COPY: bfd_reloc_code_real = 1719;
pub const BFD_RELOC_OR1K_GOTOFF_SLO16: bfd_reloc_code_real = 1718;
pub const BFD_RELOC_OR1K_PLTA26: bfd_reloc_code_real = 1717;
pub const BFD_RELOC_OR1K_PLT26: bfd_reloc_code_real = 1716;
pub const BFD_RELOC_OR1K_GOT_LO13: bfd_reloc_code_real = 1715;
pub const BFD_RELOC_OR1K_GOT_PG21: bfd_reloc_code_real = 1714;
pub const BFD_RELOC_OR1K_GOT16: bfd_reloc_code_real = 1713;
pub const BFD_RELOC_OR1K_GOT_AHI16: bfd_reloc_code_real = 1712;
pub const BFD_RELOC_OR1K_GOTPC_LO16: bfd_reloc_code_real = 1711;
pub const BFD_RELOC_OR1K_GOTPC_HI16: bfd_reloc_code_real = 1710;
pub const BFD_RELOC_OR1K_SLO13: bfd_reloc_code_real = 1709;
pub const BFD_RELOC_OR1K_LO13: bfd_reloc_code_real = 1708;
pub const BFD_RELOC_OR1K_PCREL_PG21: bfd_reloc_code_real = 1707;
pub const BFD_RELOC_OR1K_SLO16: bfd_reloc_code_real = 1706;
pub const BFD_RELOC_OR1K_REL_26: bfd_reloc_code_real = 1705;
pub const BFD_RELOC_CRIS_32_IE: bfd_reloc_code_real = 1704;
pub const BFD_RELOC_CRIS_DTPMOD: bfd_reloc_code_real = 1703;
pub const BFD_RELOC_CRIS_16_TPREL: bfd_reloc_code_real = 1702;
pub const BFD_RELOC_CRIS_32_TPREL: bfd_reloc_code_real = 1701;
pub const BFD_RELOC_CRIS_16_GOT_TPREL: bfd_reloc_code_real = 1700;
pub const BFD_RELOC_CRIS_32_GOT_TPREL: bfd_reloc_code_real = 1699;
pub const BFD_RELOC_CRIS_16_DTPREL: bfd_reloc_code_real = 1698;
pub const BFD_RELOC_CRIS_32_DTPREL: bfd_reloc_code_real = 1697;
pub const BFD_RELOC_CRIS_DTP: bfd_reloc_code_real = 1696;
pub const BFD_RELOC_CRIS_32_GD: bfd_reloc_code_real = 1695;
pub const BFD_RELOC_CRIS_16_GOT_GD: bfd_reloc_code_real = 1694;
pub const BFD_RELOC_CRIS_32_GOT_GD: bfd_reloc_code_real = 1693;
pub const BFD_RELOC_CRIS_32_PLT_PCREL: bfd_reloc_code_real = 1692;
pub const BFD_RELOC_CRIS_32_PLT_GOTREL: bfd_reloc_code_real = 1691;
pub const BFD_RELOC_CRIS_32_GOTREL: bfd_reloc_code_real = 1690;
pub const BFD_RELOC_CRIS_16_GOTPLT: bfd_reloc_code_real = 1689;
pub const BFD_RELOC_CRIS_32_GOTPLT: bfd_reloc_code_real = 1688;
pub const BFD_RELOC_CRIS_16_GOT: bfd_reloc_code_real = 1687;
pub const BFD_RELOC_CRIS_32_GOT: bfd_reloc_code_real = 1686;
pub const BFD_RELOC_CRIS_RELATIVE: bfd_reloc_code_real = 1685;
pub const BFD_RELOC_CRIS_JUMP_SLOT: bfd_reloc_code_real = 1684;
pub const BFD_RELOC_CRIS_GLOB_DAT: bfd_reloc_code_real = 1683;
pub const BFD_RELOC_CRIS_COPY: bfd_reloc_code_real = 1682;
pub const BFD_RELOC_CRIS_UNSIGNED_4: bfd_reloc_code_real = 1681;
pub const BFD_RELOC_CRIS_LAPCQ_OFFSET: bfd_reloc_code_real = 1680;
pub const BFD_RELOC_CRIS_UNSIGNED_16: bfd_reloc_code_real = 1679;
pub const BFD_RELOC_CRIS_SIGNED_16: bfd_reloc_code_real = 1678;
pub const BFD_RELOC_CRIS_UNSIGNED_8: bfd_reloc_code_real = 1677;
pub const BFD_RELOC_CRIS_SIGNED_8: bfd_reloc_code_real = 1676;
pub const BFD_RELOC_CRIS_UNSIGNED_6: bfd_reloc_code_real = 1675;
pub const BFD_RELOC_CRIS_SIGNED_6: bfd_reloc_code_real = 1674;
pub const BFD_RELOC_CRIS_UNSIGNED_5: bfd_reloc_code_real = 1673;
pub const BFD_RELOC_CRIS_BDISP8: bfd_reloc_code_real = 1672;
pub const BFD_RELOC_CRX_SWITCH32: bfd_reloc_code_real = 1671;
pub const BFD_RELOC_CRX_SWITCH16: bfd_reloc_code_real = 1670;
pub const BFD_RELOC_CRX_SWITCH8: bfd_reloc_code_real = 1669;
pub const BFD_RELOC_CRX_IMM32: bfd_reloc_code_real = 1668;
pub const BFD_RELOC_CRX_IMM16: bfd_reloc_code_real = 1667;
pub const BFD_RELOC_CRX_NUM32: bfd_reloc_code_real = 1666;
pub const BFD_RELOC_CRX_NUM16: bfd_reloc_code_real = 1665;
pub const BFD_RELOC_CRX_NUM8: bfd_reloc_code_real = 1664;
pub const BFD_RELOC_CRX_ABS32: bfd_reloc_code_real = 1663;
pub const BFD_RELOC_CRX_ABS16: bfd_reloc_code_real = 1662;
pub const BFD_RELOC_CRX_REGREL32: bfd_reloc_code_real = 1661;
pub const BFD_RELOC_CRX_REGREL28: bfd_reloc_code_real = 1660;
pub const BFD_RELOC_CRX_REGREL22: bfd_reloc_code_real = 1659;
pub const BFD_RELOC_CRX_REGREL12: bfd_reloc_code_real = 1658;
pub const BFD_RELOC_CRX_REL32: bfd_reloc_code_real = 1657;
pub const BFD_RELOC_CRX_REL24: bfd_reloc_code_real = 1656;
pub const BFD_RELOC_CRX_REL16: bfd_reloc_code_real = 1655;
pub const BFD_RELOC_CRX_REL8_CMP: bfd_reloc_code_real = 1654;
pub const BFD_RELOC_CRX_REL8: bfd_reloc_code_real = 1653;
pub const BFD_RELOC_CRX_REL4: bfd_reloc_code_real = 1652;
pub const BFD_RELOC_CR16_GLOB_DAT: bfd_reloc_code_real = 1651;
pub const BFD_RELOC_CR16_GOTC_REGREL20: bfd_reloc_code_real = 1650;
pub const BFD_RELOC_CR16_GOT_REGREL20: bfd_reloc_code_real = 1649;
pub const BFD_RELOC_CR16_SWITCH32: bfd_reloc_code_real = 1648;
pub const BFD_RELOC_CR16_SWITCH16: bfd_reloc_code_real = 1647;
pub const BFD_RELOC_CR16_SWITCH8: bfd_reloc_code_real = 1646;
pub const BFD_RELOC_CR16_DISP24a: bfd_reloc_code_real = 1645;
pub const BFD_RELOC_CR16_DISP24: bfd_reloc_code_real = 1644;
pub const BFD_RELOC_CR16_DISP20: bfd_reloc_code_real = 1643;
pub const BFD_RELOC_CR16_DISP16: bfd_reloc_code_real = 1642;
pub const BFD_RELOC_CR16_DISP8: bfd_reloc_code_real = 1641;
pub const BFD_RELOC_CR16_DISP4: bfd_reloc_code_real = 1640;
pub const BFD_RELOC_CR16_IMM32a: bfd_reloc_code_real = 1639;
pub const BFD_RELOC_CR16_IMM32: bfd_reloc_code_real = 1638;
pub const BFD_RELOC_CR16_IMM24: bfd_reloc_code_real = 1637;
pub const BFD_RELOC_CR16_IMM20: bfd_reloc_code_real = 1636;
pub const BFD_RELOC_CR16_IMM16: bfd_reloc_code_real = 1635;
pub const BFD_RELOC_CR16_IMM8: bfd_reloc_code_real = 1634;
pub const BFD_RELOC_CR16_IMM4: bfd_reloc_code_real = 1633;
pub const BFD_RELOC_CR16_ABS24: bfd_reloc_code_real = 1632;
pub const BFD_RELOC_CR16_ABS20: bfd_reloc_code_real = 1631;
pub const BFD_RELOC_CR16_REGREL20a: bfd_reloc_code_real = 1630;
pub const BFD_RELOC_CR16_REGREL20: bfd_reloc_code_real = 1629;
pub const BFD_RELOC_CR16_REGREL16: bfd_reloc_code_real = 1628;
pub const BFD_RELOC_CR16_REGREL14a: bfd_reloc_code_real = 1627;
pub const BFD_RELOC_CR16_REGREL14: bfd_reloc_code_real = 1626;
pub const BFD_RELOC_CR16_REGREL4a: bfd_reloc_code_real = 1625;
pub const BFD_RELOC_CR16_REGREL4: bfd_reloc_code_real = 1624;
pub const BFD_RELOC_CR16_REGREL0: bfd_reloc_code_real = 1623;
pub const BFD_RELOC_CR16_NUM32a: bfd_reloc_code_real = 1622;
pub const BFD_RELOC_CR16_NUM32: bfd_reloc_code_real = 1621;
pub const BFD_RELOC_CR16_NUM16: bfd_reloc_code_real = 1620;
pub const BFD_RELOC_CR16_NUM8: bfd_reloc_code_real = 1619;
pub const BFD_RELOC_S12Z_15_PCREL: bfd_reloc_code_real = 1618;
pub const BFD_RELOC_M68HC12_HI8XG: bfd_reloc_code_real = 1617;
pub const BFD_RELOC_M68HC12_LO8XG: bfd_reloc_code_real = 1616;
pub const BFD_RELOC_M68HC12_10_PCREL: bfd_reloc_code_real = 1615;
pub const BFD_RELOC_M68HC12_9_PCREL: bfd_reloc_code_real = 1614;
pub const BFD_RELOC_M68HC12_16B: bfd_reloc_code_real = 1613;
pub const BFD_RELOC_M68HC12_9B: bfd_reloc_code_real = 1612;
pub const BFD_RELOC_XGATE_IMM5: bfd_reloc_code_real = 1611;
pub const BFD_RELOC_XGATE_IMM4: bfd_reloc_code_real = 1610;
pub const BFD_RELOC_XGATE_IMM3: bfd_reloc_code_real = 1609;
pub const BFD_RELOC_XGATE_IMM8_HI: bfd_reloc_code_real = 1608;
pub const BFD_RELOC_XGATE_IMM8_LO: bfd_reloc_code_real = 1607;
pub const BFD_RELOC_XGATE_PCREL_10: bfd_reloc_code_real = 1606;
pub const BFD_RELOC_XGATE_PCREL_9: bfd_reloc_code_real = 1605;
pub const BFD_RELOC_XGATE_24: bfd_reloc_code_real = 1604;
pub const BFD_RELOC_XGATE_GPAGE: bfd_reloc_code_real = 1603;
pub const BFD_RELOC_XGATE_LO16: bfd_reloc_code_real = 1602;
pub const BFD_RELOC_XGATE_RL_GROUP: bfd_reloc_code_real = 1601;
pub const BFD_RELOC_XGATE_RL_JUMP: bfd_reloc_code_real = 1600;
pub const BFD_RELOC_M68HC12_5B: bfd_reloc_code_real = 1599;
pub const BFD_RELOC_M68HC11_24: bfd_reloc_code_real = 1598;
pub const BFD_RELOC_M68HC11_PAGE: bfd_reloc_code_real = 1597;
pub const BFD_RELOC_M68HC11_LO16: bfd_reloc_code_real = 1596;
pub const BFD_RELOC_M68HC11_RL_GROUP: bfd_reloc_code_real = 1595;
pub const BFD_RELOC_M68HC11_RL_JUMP: bfd_reloc_code_real = 1594;
pub const BFD_RELOC_M68HC11_3B: bfd_reloc_code_real = 1593;
pub const BFD_RELOC_M68HC11_LO8: bfd_reloc_code_real = 1592;
pub const BFD_RELOC_M68HC11_HI8: bfd_reloc_code_real = 1591;
pub const BFD_RELOC_IA64_LTOFF_DTPREL22: bfd_reloc_code_real = 1590;
pub const BFD_RELOC_IA64_DTPREL64LSB: bfd_reloc_code_real = 1589;
pub const BFD_RELOC_IA64_DTPREL64MSB: bfd_reloc_code_real = 1588;
pub const BFD_RELOC_IA64_DTPREL32LSB: bfd_reloc_code_real = 1587;
pub const BFD_RELOC_IA64_DTPREL32MSB: bfd_reloc_code_real = 1586;
pub const BFD_RELOC_IA64_DTPREL64I: bfd_reloc_code_real = 1585;
pub const BFD_RELOC_IA64_DTPREL22: bfd_reloc_code_real = 1584;
pub const BFD_RELOC_IA64_DTPREL14: bfd_reloc_code_real = 1583;
pub const BFD_RELOC_IA64_LTOFF_DTPMOD22: bfd_reloc_code_real = 1582;
pub const BFD_RELOC_IA64_DTPMOD64LSB: bfd_reloc_code_real = 1581;
pub const BFD_RELOC_IA64_DTPMOD64MSB: bfd_reloc_code_real = 1580;
pub const BFD_RELOC_IA64_LTOFF_TPREL22: bfd_reloc_code_real = 1579;
pub const BFD_RELOC_IA64_TPREL64LSB: bfd_reloc_code_real = 1578;
pub const BFD_RELOC_IA64_TPREL64MSB: bfd_reloc_code_real = 1577;
pub const BFD_RELOC_IA64_TPREL64I: bfd_reloc_code_real = 1576;
pub const BFD_RELOC_IA64_TPREL22: bfd_reloc_code_real = 1575;
pub const BFD_RELOC_IA64_TPREL14: bfd_reloc_code_real = 1574;
pub const BFD_RELOC_IA64_LDXMOV: bfd_reloc_code_real = 1573;
pub const BFD_RELOC_IA64_LTOFF22X: bfd_reloc_code_real = 1572;
pub const BFD_RELOC_IA64_COPY: bfd_reloc_code_real = 1571;
pub const BFD_RELOC_IA64_IPLTLSB: bfd_reloc_code_real = 1570;
pub const BFD_RELOC_IA64_IPLTMSB: bfd_reloc_code_real = 1569;
pub const BFD_RELOC_IA64_LTV64LSB: bfd_reloc_code_real = 1568;
pub const BFD_RELOC_IA64_LTV64MSB: bfd_reloc_code_real = 1567;
pub const BFD_RELOC_IA64_LTV32LSB: bfd_reloc_code_real = 1566;
pub const BFD_RELOC_IA64_LTV32MSB: bfd_reloc_code_real = 1565;
pub const BFD_RELOC_IA64_REL64LSB: bfd_reloc_code_real = 1564;
pub const BFD_RELOC_IA64_REL64MSB: bfd_reloc_code_real = 1563;
pub const BFD_RELOC_IA64_REL32LSB: bfd_reloc_code_real = 1562;
pub const BFD_RELOC_IA64_REL32MSB: bfd_reloc_code_real = 1561;
pub const BFD_RELOC_IA64_SECREL64LSB: bfd_reloc_code_real = 1560;
pub const BFD_RELOC_IA64_SECREL64MSB: bfd_reloc_code_real = 1559;
pub const BFD_RELOC_IA64_SECREL32LSB: bfd_reloc_code_real = 1558;
pub const BFD_RELOC_IA64_SECREL32MSB: bfd_reloc_code_real = 1557;
pub const BFD_RELOC_IA64_SEGREL64LSB: bfd_reloc_code_real = 1556;
pub const BFD_RELOC_IA64_SEGREL64MSB: bfd_reloc_code_real = 1555;
pub const BFD_RELOC_IA64_SEGREL32LSB: bfd_reloc_code_real = 1554;
pub const BFD_RELOC_IA64_SEGREL32MSB: bfd_reloc_code_real = 1553;
pub const BFD_RELOC_IA64_LTOFF_FPTR64LSB: bfd_reloc_code_real = 1552;
pub const BFD_RELOC_IA64_LTOFF_FPTR64MSB: bfd_reloc_code_real = 1551;
pub const BFD_RELOC_IA64_LTOFF_FPTR32LSB: bfd_reloc_code_real = 1550;
pub const BFD_RELOC_IA64_LTOFF_FPTR32MSB: bfd_reloc_code_real = 1549;
pub const BFD_RELOC_IA64_LTOFF_FPTR64I: bfd_reloc_code_real = 1548;
pub const BFD_RELOC_IA64_LTOFF_FPTR22: bfd_reloc_code_real = 1547;
pub const BFD_RELOC_IA64_PCREL64LSB: bfd_reloc_code_real = 1546;
pub const BFD_RELOC_IA64_PCREL64MSB: bfd_reloc_code_real = 1545;
pub const BFD_RELOC_IA64_PCREL32LSB: bfd_reloc_code_real = 1544;
pub const BFD_RELOC_IA64_PCREL32MSB: bfd_reloc_code_real = 1543;
pub const BFD_RELOC_IA64_PCREL64I: bfd_reloc_code_real = 1542;
pub const BFD_RELOC_IA64_PCREL60B: bfd_reloc_code_real = 1541;
pub const BFD_RELOC_IA64_PCREL22: bfd_reloc_code_real = 1540;
pub const BFD_RELOC_IA64_PCREL21F: bfd_reloc_code_real = 1539;
pub const BFD_RELOC_IA64_PCREL21M: bfd_reloc_code_real = 1538;
pub const BFD_RELOC_IA64_PCREL21BI: bfd_reloc_code_real = 1537;
pub const BFD_RELOC_IA64_PCREL21B: bfd_reloc_code_real = 1536;
pub const BFD_RELOC_IA64_FPTR64LSB: bfd_reloc_code_real = 1535;
pub const BFD_RELOC_IA64_FPTR64MSB: bfd_reloc_code_real = 1534;
pub const BFD_RELOC_IA64_FPTR32LSB: bfd_reloc_code_real = 1533;
pub const BFD_RELOC_IA64_FPTR32MSB: bfd_reloc_code_real = 1532;
pub const BFD_RELOC_IA64_FPTR64I: bfd_reloc_code_real = 1531;
pub const BFD_RELOC_IA64_PLTOFF64LSB: bfd_reloc_code_real = 1530;
pub const BFD_RELOC_IA64_PLTOFF64MSB: bfd_reloc_code_real = 1529;
pub const BFD_RELOC_IA64_PLTOFF64I: bfd_reloc_code_real = 1528;
pub const BFD_RELOC_IA64_PLTOFF22: bfd_reloc_code_real = 1527;
pub const BFD_RELOC_IA64_LTOFF64I: bfd_reloc_code_real = 1526;
pub const BFD_RELOC_IA64_LTOFF22: bfd_reloc_code_real = 1525;
pub const BFD_RELOC_IA64_GPREL64LSB: bfd_reloc_code_real = 1524;
pub const BFD_RELOC_IA64_GPREL64MSB: bfd_reloc_code_real = 1523;
pub const BFD_RELOC_IA64_GPREL32LSB: bfd_reloc_code_real = 1522;
pub const BFD_RELOC_IA64_GPREL32MSB: bfd_reloc_code_real = 1521;
pub const BFD_RELOC_IA64_GPREL64I: bfd_reloc_code_real = 1520;
pub const BFD_RELOC_IA64_GPREL22: bfd_reloc_code_real = 1519;
pub const BFD_RELOC_IA64_DIR64LSB: bfd_reloc_code_real = 1518;
pub const BFD_RELOC_IA64_DIR64MSB: bfd_reloc_code_real = 1517;
pub const BFD_RELOC_IA64_DIR32LSB: bfd_reloc_code_real = 1516;
pub const BFD_RELOC_IA64_DIR32MSB: bfd_reloc_code_real = 1515;
pub const BFD_RELOC_IA64_IMM64: bfd_reloc_code_real = 1514;
pub const BFD_RELOC_IA64_IMM22: bfd_reloc_code_real = 1513;
pub const BFD_RELOC_IA64_IMM14: bfd_reloc_code_real = 1512;
pub const BFD_RELOC_VTABLE_ENTRY: bfd_reloc_code_real = 1511;
pub const BFD_RELOC_VTABLE_INHERIT: bfd_reloc_code_real = 1510;
pub const BFD_RELOC_VPE4KMATH_INSN: bfd_reloc_code_real = 1509;
pub const BFD_RELOC_VPE4KMATH_DATA: bfd_reloc_code_real = 1508;
pub const BFD_RELOC_IP2K_FR_OFFSET: bfd_reloc_code_real = 1507;
pub const BFD_RELOC_IP2K_TEXT: bfd_reloc_code_real = 1506;
pub const BFD_RELOC_IP2K_PC_SKIP: bfd_reloc_code_real = 1505;
pub const BFD_RELOC_IP2K_HI8INSN: bfd_reloc_code_real = 1504;
pub const BFD_RELOC_IP2K_LO8INSN: bfd_reloc_code_real = 1503;
pub const BFD_RELOC_IP2K_EX8DATA: bfd_reloc_code_real = 1502;
pub const BFD_RELOC_IP2K_HI8DATA: bfd_reloc_code_real = 1501;
pub const BFD_RELOC_IP2K_LO8DATA: bfd_reloc_code_real = 1500;
pub const BFD_RELOC_IP2K_PAGE3: bfd_reloc_code_real = 1499;
pub const BFD_RELOC_IP2K_ADDR16CJP: bfd_reloc_code_real = 1498;
pub const BFD_RELOC_IP2K_BANK: bfd_reloc_code_real = 1497;
pub const BFD_RELOC_IP2K_FR9: bfd_reloc_code_real = 1496;
pub const BFD_RELOC_SCORE_DUMMY_HI16: bfd_reloc_code_real = 1495;
pub const BFD_RELOC_SCORE_CALL15: bfd_reloc_code_real = 1494;
pub const BFD_RELOC_SCORE_GOT_LO16: bfd_reloc_code_real = 1493;
pub const BFD_RELOC_SCORE_GOT15: bfd_reloc_code_real = 1492;
pub const BFD_RELOC_SCORE_BCMP: bfd_reloc_code_real = 1491;
pub const BFD_RELOC_SCORE16_BRANCH: bfd_reloc_code_real = 1490;
pub const BFD_RELOC_SCORE16_JMP: bfd_reloc_code_real = 1489;
pub const BFD_RELOC_SCORE_IMM32: bfd_reloc_code_real = 1488;
pub const BFD_RELOC_SCORE_IMM30: bfd_reloc_code_real = 1487;
pub const BFD_RELOC_SCORE_BRANCH: bfd_reloc_code_real = 1486;
pub const BFD_RELOC_SCORE_JMP: bfd_reloc_code_real = 1485;
pub const BFD_RELOC_SCORE_DUMMY2: bfd_reloc_code_real = 1484;
pub const BFD_RELOC_SCORE_GPREL15: bfd_reloc_code_real = 1483;
pub const BFD_RELOC_390_IRELATIVE: bfd_reloc_code_real = 1482;
pub const BFD_RELOC_390_TLS_GOTIE20: bfd_reloc_code_real = 1481;
pub const BFD_RELOC_390_GOTPLT20: bfd_reloc_code_real = 1480;
pub const BFD_RELOC_390_GOT20: bfd_reloc_code_real = 1479;
pub const BFD_RELOC_390_20: bfd_reloc_code_real = 1478;
pub const BFD_RELOC_390_TLS_TPOFF: bfd_reloc_code_real = 1477;
pub const BFD_RELOC_390_TLS_DTPOFF: bfd_reloc_code_real = 1476;
pub const BFD_RELOC_390_TLS_DTPMOD: bfd_reloc_code_real = 1475;
pub const BFD_RELOC_390_TLS_LDO64: bfd_reloc_code_real = 1474;
pub const BFD_RELOC_390_TLS_LDO32: bfd_reloc_code_real = 1473;
pub const BFD_RELOC_390_TLS_LE64: bfd_reloc_code_real = 1472;
pub const BFD_RELOC_390_TLS_LE32: bfd_reloc_code_real = 1471;
pub const BFD_RELOC_390_TLS_IEENT: bfd_reloc_code_real = 1470;
pub const BFD_RELOC_390_TLS_IE64: bfd_reloc_code_real = 1469;
pub const BFD_RELOC_390_TLS_IE32: bfd_reloc_code_real = 1468;
pub const BFD_RELOC_390_TLS_LDM64: bfd_reloc_code_real = 1467;
pub const BFD_RELOC_390_TLS_LDM32: bfd_reloc_code_real = 1466;
pub const BFD_RELOC_390_TLS_GOTIE64: bfd_reloc_code_real = 1465;
pub const BFD_RELOC_390_TLS_GOTIE32: bfd_reloc_code_real = 1464;
pub const BFD_RELOC_390_TLS_GOTIE12: bfd_reloc_code_real = 1463;
pub const BFD_RELOC_390_TLS_GD64: bfd_reloc_code_real = 1462;
pub const BFD_RELOC_390_TLS_GD32: bfd_reloc_code_real = 1461;
pub const BFD_RELOC_390_TLS_LDCALL: bfd_reloc_code_real = 1460;
pub const BFD_RELOC_390_TLS_GDCALL: bfd_reloc_code_real = 1459;
pub const BFD_RELOC_390_TLS_LOAD: bfd_reloc_code_real = 1458;
pub const BFD_RELOC_390_PLTOFF64: bfd_reloc_code_real = 1457;
pub const BFD_RELOC_390_PLTOFF32: bfd_reloc_code_real = 1456;
pub const BFD_RELOC_390_PLTOFF16: bfd_reloc_code_real = 1455;
pub const BFD_RELOC_390_GOTPLTENT: bfd_reloc_code_real = 1454;
pub const BFD_RELOC_390_GOTPLT64: bfd_reloc_code_real = 1453;
pub const BFD_RELOC_390_GOTPLT32: bfd_reloc_code_real = 1452;
pub const BFD_RELOC_390_GOTPLT16: bfd_reloc_code_real = 1451;
pub const BFD_RELOC_390_GOTPLT12: bfd_reloc_code_real = 1450;
pub const BFD_RELOC_390_GOTOFF64: bfd_reloc_code_real = 1449;
pub const BFD_RELOC_390_GOTENT: bfd_reloc_code_real = 1448;
pub const BFD_RELOC_390_PLT64: bfd_reloc_code_real = 1447;
pub const BFD_RELOC_390_GOT64: bfd_reloc_code_real = 1446;
pub const BFD_RELOC_390_GOTPCDBL: bfd_reloc_code_real = 1445;
pub const BFD_RELOC_390_PLT32DBL: bfd_reloc_code_real = 1444;
pub const BFD_RELOC_390_PC32DBL: bfd_reloc_code_real = 1443;
pub const BFD_RELOC_390_PLT24DBL: bfd_reloc_code_real = 1442;
pub const BFD_RELOC_390_PC24DBL: bfd_reloc_code_real = 1441;
pub const BFD_RELOC_390_PLT16DBL: bfd_reloc_code_real = 1440;
pub const BFD_RELOC_390_PC16DBL: bfd_reloc_code_real = 1439;
pub const BFD_RELOC_390_PLT12DBL: bfd_reloc_code_real = 1438;
pub const BFD_RELOC_390_PC12DBL: bfd_reloc_code_real = 1437;
pub const BFD_RELOC_390_GOT16: bfd_reloc_code_real = 1436;
pub const BFD_RELOC_390_GOTPC: bfd_reloc_code_real = 1435;
pub const BFD_RELOC_390_RELATIVE: bfd_reloc_code_real = 1434;
pub const BFD_RELOC_390_JMP_SLOT: bfd_reloc_code_real = 1433;
pub const BFD_RELOC_390_GLOB_DAT: bfd_reloc_code_real = 1432;
pub const BFD_RELOC_390_COPY: bfd_reloc_code_real = 1431;
pub const BFD_RELOC_390_PLT32: bfd_reloc_code_real = 1430;
pub const BFD_RELOC_390_GOT12: bfd_reloc_code_real = 1429;
pub const BFD_RELOC_390_12: bfd_reloc_code_real = 1428;
pub const BFD_RELOC_RX_RELAX: bfd_reloc_code_real = 1427;
pub const BFD_RELOC_RX_ABS16UL: bfd_reloc_code_real = 1426;
pub const BFD_RELOC_RX_ABS16UW: bfd_reloc_code_real = 1425;
pub const BFD_RELOC_RX_ABS16U: bfd_reloc_code_real = 1424;
pub const BFD_RELOC_RX_ABS32_REV: bfd_reloc_code_real = 1423;
pub const BFD_RELOC_RX_ABS32: bfd_reloc_code_real = 1422;
pub const BFD_RELOC_RX_ABS16_REV: bfd_reloc_code_real = 1421;
pub const BFD_RELOC_RX_ABS16: bfd_reloc_code_real = 1420;
pub const BFD_RELOC_RX_ABS8: bfd_reloc_code_real = 1419;
pub const BFD_RELOC_RX_OP_NEG: bfd_reloc_code_real = 1418;
pub const BFD_RELOC_RX_OP_SUBTRACT: bfd_reloc_code_real = 1417;
pub const BFD_RELOC_RX_SYM: bfd_reloc_code_real = 1416;
pub const BFD_RELOC_RX_GPRELL: bfd_reloc_code_real = 1415;
pub const BFD_RELOC_RX_GPRELW: bfd_reloc_code_real = 1414;
pub const BFD_RELOC_RX_GPRELB: bfd_reloc_code_real = 1413;
pub const BFD_RELOC_RX_DIFF: bfd_reloc_code_real = 1412;
pub const BFD_RELOC_RX_DIR3U_PCREL: bfd_reloc_code_real = 1411;
pub const BFD_RELOC_RX_24U: bfd_reloc_code_real = 1410;
pub const BFD_RELOC_RX_16U: bfd_reloc_code_real = 1409;
pub const BFD_RELOC_RX_8U: bfd_reloc_code_real = 1408;
pub const BFD_RELOC_RX_32_OP: bfd_reloc_code_real = 1407;
pub const BFD_RELOC_RX_24_OP: bfd_reloc_code_real = 1406;
pub const BFD_RELOC_RX_16_OP: bfd_reloc_code_real = 1405;
pub const BFD_RELOC_RX_NEG32: bfd_reloc_code_real = 1404;
pub const BFD_RELOC_RX_NEG24: bfd_reloc_code_real = 1403;
pub const BFD_RELOC_RX_NEG16: bfd_reloc_code_real = 1402;
pub const BFD_RELOC_RX_NEG8: bfd_reloc_code_real = 1401;
pub const BFD_RELOC_RL78_SADDR: bfd_reloc_code_real = 1400;
pub const BFD_RELOC_RL78_CODE: bfd_reloc_code_real = 1399;
pub const BFD_RELOC_RL78_LO16: bfd_reloc_code_real = 1398;
pub const BFD_RELOC_RL78_HI8: bfd_reloc_code_real = 1397;
pub const BFD_RELOC_RL78_HI16: bfd_reloc_code_real = 1396;
pub const BFD_RELOC_RL78_RELAX: bfd_reloc_code_real = 1395;
pub const BFD_RELOC_RL78_ABS16UL: bfd_reloc_code_real = 1394;
pub const BFD_RELOC_RL78_ABS16UW: bfd_reloc_code_real = 1393;
pub const BFD_RELOC_RL78_ABS16U: bfd_reloc_code_real = 1392;
pub const BFD_RELOC_RL78_ABS32_REV: bfd_reloc_code_real = 1391;
pub const BFD_RELOC_RL78_ABS32: bfd_reloc_code_real = 1390;
pub const BFD_RELOC_RL78_ABS16_REV: bfd_reloc_code_real = 1389;
pub const BFD_RELOC_RL78_ABS16: bfd_reloc_code_real = 1388;
pub const BFD_RELOC_RL78_ABS8: bfd_reloc_code_real = 1387;
pub const BFD_RELOC_RL78_OP_SHRA: bfd_reloc_code_real = 1386;
pub const BFD_RELOC_RL78_OP_AND: bfd_reloc_code_real = 1385;
pub const BFD_RELOC_RL78_OP_NEG: bfd_reloc_code_real = 1384;
pub const BFD_RELOC_RL78_OP_SUBTRACT: bfd_reloc_code_real = 1383;
pub const BFD_RELOC_RL78_SYM: bfd_reloc_code_real = 1382;
pub const BFD_RELOC_RL78_GPRELL: bfd_reloc_code_real = 1381;
pub const BFD_RELOC_RL78_GPRELW: bfd_reloc_code_real = 1380;
pub const BFD_RELOC_RL78_GPRELB: bfd_reloc_code_real = 1379;
pub const BFD_RELOC_RL78_DIFF: bfd_reloc_code_real = 1378;
pub const BFD_RELOC_RL78_DIR3U_PCREL: bfd_reloc_code_real = 1377;
pub const BFD_RELOC_RL78_24U: bfd_reloc_code_real = 1376;
pub const BFD_RELOC_RL78_16U: bfd_reloc_code_real = 1375;
pub const BFD_RELOC_RL78_8U: bfd_reloc_code_real = 1374;
pub const BFD_RELOC_RL78_32_OP: bfd_reloc_code_real = 1373;
pub const BFD_RELOC_RL78_24_OP: bfd_reloc_code_real = 1372;
pub const BFD_RELOC_RL78_16_OP: bfd_reloc_code_real = 1371;
pub const BFD_RELOC_RL78_NEG32: bfd_reloc_code_real = 1370;
pub const BFD_RELOC_RL78_NEG24: bfd_reloc_code_real = 1369;
pub const BFD_RELOC_RL78_NEG16: bfd_reloc_code_real = 1368;
pub const BFD_RELOC_RL78_NEG8: bfd_reloc_code_real = 1367;
pub const BFD_RELOC_RISCV_32_PCREL: bfd_reloc_code_real = 1366;
pub const BFD_RELOC_RISCV_SET32: bfd_reloc_code_real = 1365;
pub const BFD_RELOC_RISCV_SET16: bfd_reloc_code_real = 1364;
pub const BFD_RELOC_RISCV_SET8: bfd_reloc_code_real = 1363;
pub const BFD_RELOC_RISCV_SET6: bfd_reloc_code_real = 1362;
pub const BFD_RELOC_RISCV_SUB6: bfd_reloc_code_real = 1361;
pub const BFD_RELOC_RISCV_CFA: bfd_reloc_code_real = 1360;
pub const BFD_RELOC_RISCV_RELAX: bfd_reloc_code_real = 1359;
pub const BFD_RELOC_RISCV_TPREL_S: bfd_reloc_code_real = 1358;
pub const BFD_RELOC_RISCV_TPREL_I: bfd_reloc_code_real = 1357;
pub const BFD_RELOC_RISCV_GPREL_S: bfd_reloc_code_real = 1356;
pub const BFD_RELOC_RISCV_GPREL_I: bfd_reloc_code_real = 1355;
pub const BFD_RELOC_RISCV_RVC_LUI: bfd_reloc_code_real = 1354;
pub const BFD_RELOC_RISCV_RVC_JUMP: bfd_reloc_code_real = 1353;
pub const BFD_RELOC_RISCV_RVC_BRANCH: bfd_reloc_code_real = 1352;
pub const BFD_RELOC_RISCV_ALIGN: bfd_reloc_code_real = 1351;
pub const BFD_RELOC_RISCV_TLS_TPREL64: bfd_reloc_code_real = 1350;
pub const BFD_RELOC_RISCV_TLS_TPREL32: bfd_reloc_code_real = 1349;
pub const BFD_RELOC_RISCV_TLS_DTPREL64: bfd_reloc_code_real = 1348;
pub const BFD_RELOC_RISCV_TLS_DTPMOD64: bfd_reloc_code_real = 1347;
pub const BFD_RELOC_RISCV_TLS_DTPREL32: bfd_reloc_code_real = 1346;
pub const BFD_RELOC_RISCV_TLS_DTPMOD32: bfd_reloc_code_real = 1345;
pub const BFD_RELOC_RISCV_JMP: bfd_reloc_code_real = 1344;
pub const BFD_RELOC_RISCV_TLS_GD_HI20: bfd_reloc_code_real = 1343;
pub const BFD_RELOC_RISCV_TLS_GOT_HI20: bfd_reloc_code_real = 1342;
pub const BFD_RELOC_RISCV_GOT_HI20: bfd_reloc_code_real = 1341;
pub const BFD_RELOC_RISCV_SUB64: bfd_reloc_code_real = 1340;
pub const BFD_RELOC_RISCV_SUB32: bfd_reloc_code_real = 1339;
pub const BFD_RELOC_RISCV_SUB16: bfd_reloc_code_real = 1338;
pub const BFD_RELOC_RISCV_SUB8: bfd_reloc_code_real = 1337;
pub const BFD_RELOC_RISCV_ADD64: bfd_reloc_code_real = 1336;
pub const BFD_RELOC_RISCV_ADD32: bfd_reloc_code_real = 1335;
pub const BFD_RELOC_RISCV_ADD16: bfd_reloc_code_real = 1334;
pub const BFD_RELOC_RISCV_ADD8: bfd_reloc_code_real = 1333;
pub const BFD_RELOC_RISCV_CALL_PLT: bfd_reloc_code_real = 1332;
pub const BFD_RELOC_RISCV_CALL: bfd_reloc_code_real = 1331;
pub const BFD_RELOC_RISCV_TPREL_ADD: bfd_reloc_code_real = 1330;
pub const BFD_RELOC_RISCV_TPREL_LO12_S: bfd_reloc_code_real = 1329;
pub const BFD_RELOC_RISCV_TPREL_LO12_I: bfd_reloc_code_real = 1328;
pub const BFD_RELOC_RISCV_TPREL_HI20: bfd_reloc_code_real = 1327;
pub const BFD_RELOC_RISCV_GPREL12_S: bfd_reloc_code_real = 1326;
pub const BFD_RELOC_RISCV_GPREL12_I: bfd_reloc_code_real = 1325;
pub const BFD_RELOC_RISCV_LO12_S: bfd_reloc_code_real = 1324;
pub const BFD_RELOC_RISCV_LO12_I: bfd_reloc_code_real = 1323;
pub const BFD_RELOC_RISCV_PCREL_LO12_S: bfd_reloc_code_real = 1322;
pub const BFD_RELOC_RISCV_PCREL_LO12_I: bfd_reloc_code_real = 1321;
pub const BFD_RELOC_RISCV_PCREL_HI20: bfd_reloc_code_real = 1320;
pub const BFD_RELOC_RISCV_HI20: bfd_reloc_code_real = 1319;
pub const BFD_RELOC_AVR_PORT5: bfd_reloc_code_real = 1318;
pub const BFD_RELOC_AVR_PORT6: bfd_reloc_code_real = 1317;
pub const BFD_RELOC_AVR_LDS_STS_16: bfd_reloc_code_real = 1316;
pub const BFD_RELOC_AVR_DIFF32: bfd_reloc_code_real = 1315;
pub const BFD_RELOC_AVR_DIFF16: bfd_reloc_code_real = 1314;
pub const BFD_RELOC_AVR_DIFF8: bfd_reloc_code_real = 1313;
pub const BFD_RELOC_AVR_8_HLO: bfd_reloc_code_real = 1312;
pub const BFD_RELOC_AVR_8_HI: bfd_reloc_code_real = 1311;
pub const BFD_RELOC_AVR_8_LO: bfd_reloc_code_real = 1310;
pub const BFD_RELOC_AVR_6_ADIW: bfd_reloc_code_real = 1309;
pub const BFD_RELOC_AVR_6: bfd_reloc_code_real = 1308;
pub const BFD_RELOC_AVR_LDI: bfd_reloc_code_real = 1307;
pub const BFD_RELOC_AVR_CALL: bfd_reloc_code_real = 1306;
pub const BFD_RELOC_AVR_HH8_LDI_PM_NEG: bfd_reloc_code_real = 1305;
pub const BFD_RELOC_AVR_HI8_LDI_PM_NEG: bfd_reloc_code_real = 1304;
pub const BFD_RELOC_AVR_LO8_LDI_PM_NEG: bfd_reloc_code_real = 1303;
pub const BFD_RELOC_AVR_HH8_LDI_PM: bfd_reloc_code_real = 1302;
pub const BFD_RELOC_AVR_HI8_LDI_GS: bfd_reloc_code_real = 1301;
pub const BFD_RELOC_AVR_HI8_LDI_PM: bfd_reloc_code_real = 1300;
pub const BFD_RELOC_AVR_LO8_LDI_GS: bfd_reloc_code_real = 1299;
pub const BFD_RELOC_AVR_LO8_LDI_PM: bfd_reloc_code_real = 1298;
pub const BFD_RELOC_AVR_MS8_LDI_NEG: bfd_reloc_code_real = 1297;
pub const BFD_RELOC_AVR_HH8_LDI_NEG: bfd_reloc_code_real = 1296;
pub const BFD_RELOC_AVR_HI8_LDI_NEG: bfd_reloc_code_real = 1295;
pub const BFD_RELOC_AVR_LO8_LDI_NEG: bfd_reloc_code_real = 1294;
pub const BFD_RELOC_AVR_MS8_LDI: bfd_reloc_code_real = 1293;
pub const BFD_RELOC_AVR_HH8_LDI: bfd_reloc_code_real = 1292;
pub const BFD_RELOC_AVR_HI8_LDI: bfd_reloc_code_real = 1291;
pub const BFD_RELOC_AVR_LO8_LDI: bfd_reloc_code_real = 1290;
pub const BFD_RELOC_AVR_16_PM: bfd_reloc_code_real = 1289;
pub const BFD_RELOC_AVR_13_PCREL: bfd_reloc_code_real = 1288;
pub const BFD_RELOC_AVR_7_PCREL: bfd_reloc_code_real = 1287;
pub const BFD_RELOC_MMIX_LOCAL: bfd_reloc_code_real = 1286;
pub const BFD_RELOC_MMIX_BASE_PLUS_OFFSET: bfd_reloc_code_real = 1285;
pub const BFD_RELOC_MMIX_REG: bfd_reloc_code_real = 1284;
pub const BFD_RELOC_MMIX_REG_OR_BYTE: bfd_reloc_code_real = 1283;
pub const BFD_RELOC_MMIX_ADDR27: bfd_reloc_code_real = 1282;
pub const BFD_RELOC_MMIX_ADDR19: bfd_reloc_code_real = 1281;
pub const BFD_RELOC_MMIX_JMP_3: bfd_reloc_code_real = 1280;
pub const BFD_RELOC_MMIX_JMP_2: bfd_reloc_code_real = 1279;
pub const BFD_RELOC_MMIX_JMP_1: bfd_reloc_code_real = 1278;
pub const BFD_RELOC_MMIX_JMP: bfd_reloc_code_real = 1277;
pub const BFD_RELOC_MMIX_PUSHJ_STUBBABLE: bfd_reloc_code_real = 1276;
pub const BFD_RELOC_MMIX_PUSHJ_3: bfd_reloc_code_real = 1275;
pub const BFD_RELOC_MMIX_PUSHJ_2: bfd_reloc_code_real = 1274;
pub const BFD_RELOC_MMIX_PUSHJ_1: bfd_reloc_code_real = 1273;
pub const BFD_RELOC_MMIX_PUSHJ: bfd_reloc_code_real = 1272;
pub const BFD_RELOC_MMIX_CBRANCH_3: bfd_reloc_code_real = 1271;
pub const BFD_RELOC_MMIX_CBRANCH_2: bfd_reloc_code_real = 1270;
pub const BFD_RELOC_MMIX_CBRANCH_1: bfd_reloc_code_real = 1269;
pub const BFD_RELOC_MMIX_CBRANCH_J: bfd_reloc_code_real = 1268;
pub const BFD_RELOC_MMIX_CBRANCH: bfd_reloc_code_real = 1267;
pub const BFD_RELOC_MMIX_GETA_3: bfd_reloc_code_real = 1266;
pub const BFD_RELOC_MMIX_GETA_2: bfd_reloc_code_real = 1265;
pub const BFD_RELOC_MMIX_GETA_1: bfd_reloc_code_real = 1264;
pub const BFD_RELOC_MMIX_GETA: bfd_reloc_code_real = 1263;
pub const BFD_RELOC_METAG_TLS_LE_LO16: bfd_reloc_code_real = 1262;
pub const BFD_RELOC_METAG_TLS_LE_HI16: bfd_reloc_code_real = 1261;
pub const BFD_RELOC_METAG_TLS_LE: bfd_reloc_code_real = 1260;
pub const BFD_RELOC_METAG_TLS_DTPOFF: bfd_reloc_code_real = 1259;
pub const BFD_RELOC_METAG_TLS_DTPMOD: bfd_reloc_code_real = 1258;
pub const BFD_RELOC_METAG_TLS_TPOFF: bfd_reloc_code_real = 1257;
pub const BFD_RELOC_METAG_TLS_IENONPIC_LO16: bfd_reloc_code_real = 1256;
pub const BFD_RELOC_METAG_TLS_IENONPIC_HI16: bfd_reloc_code_real = 1255;
pub const BFD_RELOC_METAG_TLS_IENONPIC: bfd_reloc_code_real = 1254;
pub const BFD_RELOC_METAG_TLS_IE: bfd_reloc_code_real = 1253;
pub const BFD_RELOC_METAG_TLS_LDO: bfd_reloc_code_real = 1252;
pub const BFD_RELOC_METAG_TLS_LDO_LO16: bfd_reloc_code_real = 1251;
pub const BFD_RELOC_METAG_TLS_LDO_HI16: bfd_reloc_code_real = 1250;
pub const BFD_RELOC_METAG_TLS_LDM: bfd_reloc_code_real = 1249;
pub const BFD_RELOC_METAG_TLS_GD: bfd_reloc_code_real = 1248;
pub const BFD_RELOC_METAG_GLOB_DAT: bfd_reloc_code_real = 1247;
pub const BFD_RELOC_METAG_RELATIVE: bfd_reloc_code_real = 1246;
pub const BFD_RELOC_METAG_JMP_SLOT: bfd_reloc_code_real = 1245;
pub const BFD_RELOC_METAG_COPY: bfd_reloc_code_real = 1244;
pub const BFD_RELOC_METAG_PLT: bfd_reloc_code_real = 1243;
pub const BFD_RELOC_METAG_GOTOFF: bfd_reloc_code_real = 1242;
pub const BFD_RELOC_METAG_RELBRANCH_PLT: bfd_reloc_code_real = 1241;
pub const BFD_RELOC_METAG_LO16_PLT: bfd_reloc_code_real = 1240;
pub const BFD_RELOC_METAG_HI16_PLT: bfd_reloc_code_real = 1239;
pub const BFD_RELOC_METAG_LO16_GOTPC: bfd_reloc_code_real = 1238;
pub const BFD_RELOC_METAG_HI16_GOTPC: bfd_reloc_code_real = 1237;
pub const BFD_RELOC_METAG_GETSET_GOT: bfd_reloc_code_real = 1236;
pub const BFD_RELOC_METAG_GETSET_GOTOFF: bfd_reloc_code_real = 1235;
pub const BFD_RELOC_METAG_LO16_GOTOFF: bfd_reloc_code_real = 1234;
pub const BFD_RELOC_METAG_HI16_GOTOFF: bfd_reloc_code_real = 1233;
pub const BFD_RELOC_METAG_REL16: bfd_reloc_code_real = 1232;
pub const BFD_RELOC_METAG_REL8: bfd_reloc_code_real = 1231;
pub const BFD_RELOC_METAG_LOOG: bfd_reloc_code_real = 1230;
pub const BFD_RELOC_METAG_HIOG: bfd_reloc_code_real = 1229;
pub const BFD_RELOC_METAG_GETSETOFF: bfd_reloc_code_real = 1228;
pub const BFD_RELOC_METAG_RELBRANCH: bfd_reloc_code_real = 1227;
pub const BFD_RELOC_METAG_LOADDR16: bfd_reloc_code_real = 1226;
pub const BFD_RELOC_METAG_HIADDR16: bfd_reloc_code_real = 1225;
pub const BFD_RELOC_MEP_GNU_VTENTRY: bfd_reloc_code_real = 1224;
pub const BFD_RELOC_MEP_GNU_VTINHERIT: bfd_reloc_code_real = 1223;
pub const BFD_RELOC_MEP_ADDR24A4: bfd_reloc_code_real = 1222;
pub const BFD_RELOC_MEP_UIMM24: bfd_reloc_code_real = 1221;
pub const BFD_RELOC_MEP_TPREL7A4: bfd_reloc_code_real = 1220;
pub const BFD_RELOC_MEP_TPREL7A2: bfd_reloc_code_real = 1219;
pub const BFD_RELOC_MEP_TPREL7: bfd_reloc_code_real = 1218;
pub const BFD_RELOC_MEP_TPREL: bfd_reloc_code_real = 1217;
pub const BFD_RELOC_MEP_GPREL: bfd_reloc_code_real = 1216;
pub const BFD_RELOC_MEP_HI16S: bfd_reloc_code_real = 1215;
pub const BFD_RELOC_MEP_HI16U: bfd_reloc_code_real = 1214;
pub const BFD_RELOC_MEP_LOW16: bfd_reloc_code_real = 1213;
pub const BFD_RELOC_MEP_PCABS24A2: bfd_reloc_code_real = 1212;
pub const BFD_RELOC_MEP_PCREL24A2: bfd_reloc_code_real = 1211;
pub const BFD_RELOC_MEP_PCREL17A2: bfd_reloc_code_real = 1210;
pub const BFD_RELOC_MEP_PCREL12A2: bfd_reloc_code_real = 1209;
pub const BFD_RELOC_MEP_PCREL8A2: bfd_reloc_code_real = 1208;
pub const BFD_RELOC_MEP_32: bfd_reloc_code_real = 1207;
pub const BFD_RELOC_MEP_16: bfd_reloc_code_real = 1206;
pub const BFD_RELOC_MEP_8: bfd_reloc_code_real = 1205;
pub const BFD_RELOC_MCORE_RVA: bfd_reloc_code_real = 1204;
pub const BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2: bfd_reloc_code_real = 1203;
pub const BFD_RELOC_MCORE_PCREL_32: bfd_reloc_code_real = 1202;
pub const BFD_RELOC_MCORE_PCREL_IMM4BY2: bfd_reloc_code_real = 1201;
pub const BFD_RELOC_MCORE_PCREL_IMM11BY2: bfd_reloc_code_real = 1200;
pub const BFD_RELOC_MCORE_PCREL_IMM8BY4: bfd_reloc_code_real = 1199;
pub const BFD_RELOC_FR30_12_PCREL: bfd_reloc_code_real = 1198;
pub const BFD_RELOC_FR30_9_PCREL: bfd_reloc_code_real = 1197;
pub const BFD_RELOC_FR30_10_IN_8: bfd_reloc_code_real = 1196;
pub const BFD_RELOC_FR30_9_IN_8: bfd_reloc_code_real = 1195;
pub const BFD_RELOC_FR30_8_IN_8: bfd_reloc_code_real = 1194;
pub const BFD_RELOC_FR30_6_IN_4: bfd_reloc_code_real = 1193;
pub const BFD_RELOC_FR30_20: bfd_reloc_code_real = 1192;
pub const BFD_RELOC_FR30_48: bfd_reloc_code_real = 1191;
pub const BFD_RELOC_C6000_NOCMP: bfd_reloc_code_real = 1190;
pub const BFD_RELOC_C6000_FPHEAD: bfd_reloc_code_real = 1189;
pub const BFD_RELOC_C6000_ALIGN: bfd_reloc_code_real = 1188;
pub const BFD_RELOC_C6000_PCR_L16: bfd_reloc_code_real = 1187;
pub const BFD_RELOC_C6000_PCR_H16: bfd_reloc_code_real = 1186;
pub const BFD_RELOC_C6000_EHTYPE: bfd_reloc_code_real = 1185;
pub const BFD_RELOC_C6000_JUMP_SLOT: bfd_reloc_code_real = 1184;
pub const BFD_RELOC_C6000_COPY: bfd_reloc_code_real = 1183;
pub const BFD_RELOC_C6000_PREL31: bfd_reloc_code_real = 1182;
pub const BFD_RELOC_C6000_DSBT_INDEX: bfd_reloc_code_real = 1181;
pub const BFD_RELOC_C6000_SBR_GOT_H16_W: bfd_reloc_code_real = 1180;
pub const BFD_RELOC_C6000_SBR_GOT_L16_W: bfd_reloc_code_real = 1179;
pub const BFD_RELOC_C6000_SBR_GOT_U15_W: bfd_reloc_code_real = 1178;
pub const BFD_RELOC_C6000_SBR_H16_W: bfd_reloc_code_real = 1177;
pub const BFD_RELOC_C6000_SBR_H16_H: bfd_reloc_code_real = 1176;
pub const BFD_RELOC_C6000_SBR_H16_B: bfd_reloc_code_real = 1175;
pub const BFD_RELOC_C6000_SBR_L16_W: bfd_reloc_code_real = 1174;
pub const BFD_RELOC_C6000_SBR_L16_H: bfd_reloc_code_real = 1173;
pub const BFD_RELOC_C6000_SBR_L16_B: bfd_reloc_code_real = 1172;
pub const BFD_RELOC_C6000_SBR_S16: bfd_reloc_code_real = 1171;
pub const BFD_RELOC_C6000_SBR_U15_W: bfd_reloc_code_real = 1170;
pub const BFD_RELOC_C6000_SBR_U15_H: bfd_reloc_code_real = 1169;
pub const BFD_RELOC_C6000_SBR_U15_B: bfd_reloc_code_real = 1168;
pub const BFD_RELOC_C6000_ABS_H16: bfd_reloc_code_real = 1167;
pub const BFD_RELOC_C6000_ABS_L16: bfd_reloc_code_real = 1166;
pub const BFD_RELOC_C6000_ABS_S16: bfd_reloc_code_real = 1165;
pub const BFD_RELOC_C6000_PCR_S7: bfd_reloc_code_real = 1164;
pub const BFD_RELOC_C6000_PCR_S10: bfd_reloc_code_real = 1163;
pub const BFD_RELOC_C6000_PCR_S12: bfd_reloc_code_real = 1162;
pub const BFD_RELOC_C6000_PCR_S21: bfd_reloc_code_real = 1161;
pub const BFD_RELOC_TIC54X_MS7_OF_23: bfd_reloc_code_real = 1160;
pub const BFD_RELOC_TIC54X_16_OF_23: bfd_reloc_code_real = 1159;
pub const BFD_RELOC_TIC54X_23: bfd_reloc_code_real = 1158;
pub const BFD_RELOC_TIC54X_PARTMS9: bfd_reloc_code_real = 1157;
pub const BFD_RELOC_TIC54X_PARTLS7: bfd_reloc_code_real = 1156;
pub const BFD_RELOC_TIC30_LDP: bfd_reloc_code_real = 1155;
pub const BFD_RELOC_V850_DATA: bfd_reloc_code_real = 1154;
pub const BFD_RELOC_V850_CODE: bfd_reloc_code_real = 1153;
pub const BFD_RELOC_V850_32_GOTOFF: bfd_reloc_code_real = 1152;
pub const BFD_RELOC_V850_16_GOTOFF: bfd_reloc_code_real = 1151;
pub const BFD_RELOC_V850_RELATIVE: bfd_reloc_code_real = 1150;
pub const BFD_RELOC_V850_JMP_SLOT: bfd_reloc_code_real = 1149;
pub const BFD_RELOC_V850_GLOB_DAT: bfd_reloc_code_real = 1148;
pub const BFD_RELOC_V850_COPY: bfd_reloc_code_real = 1147;
pub const BFD_RELOC_V850_32_PLT_PCREL: bfd_reloc_code_real = 1146;
pub const BFD_RELOC_V850_22_PLT_PCREL: bfd_reloc_code_real = 1145;
pub const BFD_RELOC_V850_32_GOT: bfd_reloc_code_real = 1144;
pub const BFD_RELOC_V850_16_GOT: bfd_reloc_code_real = 1143;
pub const BFD_RELOC_V850_32_GOTPCREL: bfd_reloc_code_real = 1142;
pub const BFD_RELOC_V850_CALLT_15_16_OFFSET: bfd_reloc_code_real = 1141;
pub const BFD_RELOC_V850_LO16_S1: bfd_reloc_code_real = 1140;
pub const BFD_RELOC_V850_16_S1: bfd_reloc_code_real = 1139;
pub const BFD_RELOC_V850_16_SPLIT_OFFSET: bfd_reloc_code_real = 1138;
pub const BFD_RELOC_V850_32_ABS: bfd_reloc_code_real = 1137;
pub const BFD_RELOC_V850_32_PCREL: bfd_reloc_code_real = 1136;
pub const BFD_RELOC_V850_23: bfd_reloc_code_real = 1135;
pub const BFD_RELOC_V850_17_PCREL: bfd_reloc_code_real = 1134;
pub const BFD_RELOC_V850_16_PCREL: bfd_reloc_code_real = 1133;
pub const BFD_RELOC_V850_LO16_SPLIT_OFFSET: bfd_reloc_code_real = 1132;
pub const BFD_RELOC_V850_ALIGN: bfd_reloc_code_real = 1131;
pub const BFD_RELOC_V850_LONGJUMP: bfd_reloc_code_real = 1130;
pub const BFD_RELOC_V850_LONGCALL: bfd_reloc_code_real = 1129;
pub const BFD_RELOC_V850_CALLT_16_16_OFFSET: bfd_reloc_code_real = 1128;
pub const BFD_RELOC_V850_CALLT_6_7_OFFSET: bfd_reloc_code_real = 1127;
pub const BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET: bfd_reloc_code_real = 1126;
pub const BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET: bfd_reloc_code_real = 1125;
pub const BFD_RELOC_V850_TDA_4_4_OFFSET: bfd_reloc_code_real = 1124;
pub const BFD_RELOC_V850_TDA_4_5_OFFSET: bfd_reloc_code_real = 1123;
pub const BFD_RELOC_V850_TDA_16_16_OFFSET: bfd_reloc_code_real = 1122;
pub const BFD_RELOC_V850_TDA_7_7_OFFSET: bfd_reloc_code_real = 1121;
pub const BFD_RELOC_V850_TDA_7_8_OFFSET: bfd_reloc_code_real = 1120;
pub const BFD_RELOC_V850_TDA_6_8_OFFSET: bfd_reloc_code_real = 1119;
pub const BFD_RELOC_V850_ZDA_15_16_OFFSET: bfd_reloc_code_real = 1118;
pub const BFD_RELOC_V850_ZDA_16_16_OFFSET: bfd_reloc_code_real = 1117;
pub const BFD_RELOC_V850_SDA_15_16_OFFSET: bfd_reloc_code_real = 1116;
pub const BFD_RELOC_V850_SDA_16_16_OFFSET: bfd_reloc_code_real = 1115;
pub const BFD_RELOC_V850_22_PCREL: bfd_reloc_code_real = 1114;
pub const BFD_RELOC_V850_9_PCREL: bfd_reloc_code_real = 1113;
pub const BFD_RELOC_NDS32_LSI: bfd_reloc_code_real = 1112;
pub const BFD_RELOC_NDS32_GROUP: bfd_reloc_code_real = 1111;
pub const BFD_RELOC_NDS32_REMOVE: bfd_reloc_code_real = 1110;
pub const BFD_RELOC_NDS32_TLS_DESC_MEM: bfd_reloc_code_real = 1109;
pub const BFD_RELOC_NDS32_TLS_DESC_CALL: bfd_reloc_code_real = 1108;
pub const BFD_RELOC_NDS32_TLS_DESC_FUNC: bfd_reloc_code_real = 1107;
pub const BFD_RELOC_NDS32_TLS_DESC_ADD: bfd_reloc_code_real = 1106;
pub const BFD_RELOC_NDS32_TLS_DESC_SDA17S2: bfd_reloc_code_real = 1105;
pub const BFD_RELOC_NDS32_TLS_DESC_20: bfd_reloc_code_real = 1104;
pub const BFD_RELOC_NDS32_TLS_DESC_LO12: bfd_reloc_code_real = 1103;
pub const BFD_RELOC_NDS32_TLS_DESC_HI20: bfd_reloc_code_real = 1102;
pub const BFD_RELOC_NDS32_TLS_DESC: bfd_reloc_code_real = 1101;
pub const BFD_RELOC_NDS32_TLS_IEGP_LW: bfd_reloc_code_real = 1100;
pub const BFD_RELOC_NDS32_TLS_IEGP_LO12S2: bfd_reloc_code_real = 1099;
pub const BFD_RELOC_NDS32_TLS_IEGP_LO12: bfd_reloc_code_real = 1098;
pub const BFD_RELOC_NDS32_TLS_IEGP_HI20: bfd_reloc_code_real = 1097;
pub const BFD_RELOC_NDS32_TLS_IE_LO12S2: bfd_reloc_code_real = 1096;
pub const BFD_RELOC_NDS32_TLS_IE_LO12: bfd_reloc_code_real = 1095;
pub const BFD_RELOC_NDS32_TLS_IE_HI20: bfd_reloc_code_real = 1094;
pub const BFD_RELOC_NDS32_TLS_LE_LS: bfd_reloc_code_real = 1093;
pub const BFD_RELOC_NDS32_TLS_LE_ADD: bfd_reloc_code_real = 1092;
pub const BFD_RELOC_NDS32_TLS_LE_15S2: bfd_reloc_code_real = 1091;
pub const BFD_RELOC_NDS32_TLS_LE_15S1: bfd_reloc_code_real = 1090;
pub const BFD_RELOC_NDS32_TLS_LE_15S0: bfd_reloc_code_real = 1089;
pub const BFD_RELOC_NDS32_TLS_LE_20: bfd_reloc_code_real = 1088;
pub const BFD_RELOC_NDS32_TLS_LE_LO12: bfd_reloc_code_real = 1087;
pub const BFD_RELOC_NDS32_TLS_LE_HI20: bfd_reloc_code_real = 1086;
pub const BFD_RELOC_NDS32_GOTTPOFF: bfd_reloc_code_real = 1085;
pub const BFD_RELOC_NDS32_TPOFF: bfd_reloc_code_real = 1084;
pub const BFD_RELOC_NDS32_10IFCU_PCREL: bfd_reloc_code_real = 1083;
pub const BFD_RELOC_NDS32_17IFC_PCREL: bfd_reloc_code_real = 1082;
pub const BFD_RELOC_NDS32_TRAN: bfd_reloc_code_real = 1081;
pub const BFD_RELOC_NDS32_DATA: bfd_reloc_code_real = 1080;
pub const BFD_RELOC_NDS32_25_ABS: bfd_reloc_code_real = 1079;
pub const BFD_RELOC_NDS32_EMPTY: bfd_reloc_code_real = 1078;
pub const BFD_RELOC_NDS32_DIFF_ULEB128: bfd_reloc_code_real = 1077;
pub const BFD_RELOC_NDS32_DIFF32: bfd_reloc_code_real = 1076;
pub const BFD_RELOC_NDS32_DIFF16: bfd_reloc_code_real = 1075;
pub const BFD_RELOC_NDS32_DIFF8: bfd_reloc_code_real = 1074;
pub const BFD_RELOC_NDS32_SUBTRAHEND: bfd_reloc_code_real = 1073;
pub const BFD_RELOC_NDS32_MINUEND: bfd_reloc_code_real = 1072;
pub const BFD_RELOC_NDS32_RELAX_REGION_END: bfd_reloc_code_real = 1071;
pub const BFD_RELOC_NDS32_RELAX_REGION_BEGIN: bfd_reloc_code_real = 1070;
pub const BFD_RELOC_NDS32_PLTBLOCK: bfd_reloc_code_real = 1069;
pub const BFD_RELOC_NDS32_PTR_RESOLVED: bfd_reloc_code_real = 1068;
pub const BFD_RELOC_NDS32_PTR_COUNT: bfd_reloc_code_real = 1067;
pub const BFD_RELOC_NDS32_PTR: bfd_reloc_code_real = 1066;
pub const BFD_RELOC_NDS32_MULCALL_SUFF: bfd_reloc_code_real = 1065;
pub const BFD_RELOC_NDS32_PLT_GOT_SUFF: bfd_reloc_code_real = 1064;
pub const BFD_RELOC_NDS32_GOTOFF_SUFF: bfd_reloc_code_real = 1063;
pub const BFD_RELOC_NDS32_GOT_SUFF: bfd_reloc_code_real = 1062;
pub const BFD_RELOC_NDS32_RELAX_ENTRY: bfd_reloc_code_real = 1061;
pub const BFD_RELOC_NDS32_SDA_FP7U2_RELA: bfd_reloc_code_real = 1060;
pub const BFD_RELOC_NDS32_10_UPCREL: bfd_reloc_code_real = 1059;
pub const BFD_RELOC_NDS32_5: bfd_reloc_code_real = 1058;
pub const BFD_RELOC_NDS32_GOT17S2: bfd_reloc_code_real = 1057;
pub const BFD_RELOC_NDS32_GOT15S2: bfd_reloc_code_real = 1056;
pub const BFD_RELOC_NDS32_GOTOFF_LO19: bfd_reloc_code_real = 1055;
pub const BFD_RELOC_NDS32_GOTOFF_LO15: bfd_reloc_code_real = 1054;
pub const BFD_RELOC_NDS32_GOT_LO19: bfd_reloc_code_real = 1053;
pub const BFD_RELOC_NDS32_GOT_LO15: bfd_reloc_code_real = 1052;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO19: bfd_reloc_code_real = 1051;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO15: bfd_reloc_code_real = 1050;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO20: bfd_reloc_code_real = 1049;
pub const BFD_RELOC_NDS32_UPDATE_TA: bfd_reloc_code_real = 1048;
pub const BFD_RELOC_NDS32_DWARF2_LEB: bfd_reloc_code_real = 1047;
pub const BFD_RELOC_NDS32_DWARF2_OP2: bfd_reloc_code_real = 1046;
pub const BFD_RELOC_NDS32_DWARF2_OP1: bfd_reloc_code_real = 1045;
pub const BFD_RELOC_NDS32_LO12S2_SP: bfd_reloc_code_real = 1044;
pub const BFD_RELOC_NDS32_LO12S2_DP: bfd_reloc_code_real = 1043;
pub const BFD_RELOC_NDS32_SDA12S2_SP: bfd_reloc_code_real = 1042;
pub const BFD_RELOC_NDS32_SDA12S2_DP: bfd_reloc_code_real = 1041;
pub const BFD_RELOC_NDS32_PLT_GOTREL_LO12: bfd_reloc_code_real = 1040;
pub const BFD_RELOC_NDS32_PLT_GOTREL_HI20: bfd_reloc_code_real = 1039;
pub const BFD_RELOC_NDS32_PLTREL_LO12: bfd_reloc_code_real = 1038;
pub const BFD_RELOC_NDS32_PLTREL_HI20: bfd_reloc_code_real = 1037;
pub const BFD_RELOC_NDS32_LONGJUMP7: bfd_reloc_code_real = 1036;
pub const BFD_RELOC_NDS32_LONGJUMP6: bfd_reloc_code_real = 1035;
pub const BFD_RELOC_NDS32_LONGJUMP5: bfd_reloc_code_real = 1034;
pub const BFD_RELOC_NDS32_LONGJUMP4: bfd_reloc_code_real = 1033;
pub const BFD_RELOC_NDS32_LONGCALL6: bfd_reloc_code_real = 1032;
pub const BFD_RELOC_NDS32_LONGCALL5: bfd_reloc_code_real = 1031;
pub const BFD_RELOC_NDS32_LONGCALL4: bfd_reloc_code_real = 1030;
pub const BFD_RELOC_NDS32_25_FIXED: bfd_reloc_code_real = 1029;
pub const BFD_RELOC_NDS32_17_FIXED: bfd_reloc_code_real = 1028;
pub const BFD_RELOC_NDS32_15_FIXED: bfd_reloc_code_real = 1027;
pub const BFD_RELOC_NDS32_9_FIXED: bfd_reloc_code_real = 1026;
pub const BFD_RELOC_NDS32_LOADSTORE: bfd_reloc_code_real = 1025;
pub const BFD_RELOC_NDS32_LONGJUMP3: bfd_reloc_code_real = 1024;
pub const BFD_RELOC_NDS32_LONGJUMP2: bfd_reloc_code_real = 1023;
pub const BFD_RELOC_NDS32_LONGJUMP1: bfd_reloc_code_real = 1022;
pub const BFD_RELOC_NDS32_LONGCALL3: bfd_reloc_code_real = 1021;
pub const BFD_RELOC_NDS32_LONGCALL2: bfd_reloc_code_real = 1020;
pub const BFD_RELOC_NDS32_LONGCALL1: bfd_reloc_code_real = 1019;
pub const BFD_RELOC_NDS32_LABEL: bfd_reloc_code_real = 1018;
pub const BFD_RELOC_NDS32_INSN16: bfd_reloc_code_real = 1017;
pub const BFD_RELOC_NDS32_GOTPC_LO12: bfd_reloc_code_real = 1016;
pub const BFD_RELOC_NDS32_GOTPC_HI20: bfd_reloc_code_real = 1015;
pub const BFD_RELOC_NDS32_GOT_LO12: bfd_reloc_code_real = 1014;
pub const BFD_RELOC_NDS32_GOT_HI20: bfd_reloc_code_real = 1013;
pub const BFD_RELOC_NDS32_GOTPC20: bfd_reloc_code_real = 1012;
pub const BFD_RELOC_NDS32_GOTOFF_LO12: bfd_reloc_code_real = 1011;
pub const BFD_RELOC_NDS32_GOTOFF_HI20: bfd_reloc_code_real = 1010;
pub const BFD_RELOC_NDS32_GOTOFF: bfd_reloc_code_real = 1009;
pub const BFD_RELOC_NDS32_RELATIVE: bfd_reloc_code_real = 1008;
pub const BFD_RELOC_NDS32_JMP_SLOT: bfd_reloc_code_real = 1007;
pub const BFD_RELOC_NDS32_GLOB_DAT: bfd_reloc_code_real = 1006;
pub const BFD_RELOC_NDS32_COPY: bfd_reloc_code_real = 1005;
pub const BFD_RELOC_NDS32_25_PLTREL: bfd_reloc_code_real = 1004;
pub const BFD_RELOC_NDS32_9_PLTREL: bfd_reloc_code_real = 1003;
pub const BFD_RELOC_NDS32_GOT20: bfd_reloc_code_real = 1002;
pub const BFD_RELOC_NDS32_SDA19S0: bfd_reloc_code_real = 1001;
pub const BFD_RELOC_NDS32_SDA18S1: bfd_reloc_code_real = 1000;
pub const BFD_RELOC_NDS32_SDA17S2: bfd_reloc_code_real = 999;
pub const BFD_RELOC_NDS32_SDA16S3: bfd_reloc_code_real = 998;
pub const BFD_RELOC_NDS32_SDA15S0: bfd_reloc_code_real = 997;
pub const BFD_RELOC_NDS32_SDA15S1: bfd_reloc_code_real = 996;
pub const BFD_RELOC_NDS32_SDA15S2: bfd_reloc_code_real = 995;
pub const BFD_RELOC_NDS32_SDA15S3: bfd_reloc_code_real = 994;
pub const BFD_RELOC_NDS32_LO12S0_ORI: bfd_reloc_code_real = 993;
pub const BFD_RELOC_NDS32_LO12S0: bfd_reloc_code_real = 992;
pub const BFD_RELOC_NDS32_LO12S1: bfd_reloc_code_real = 991;
pub const BFD_RELOC_NDS32_LO12S2: bfd_reloc_code_real = 990;
pub const BFD_RELOC_NDS32_LO12S3: bfd_reloc_code_real = 989;
pub const BFD_RELOC_NDS32_HI20: bfd_reloc_code_real = 988;
pub const BFD_RELOC_NDS32_25_PCREL: bfd_reloc_code_real = 987;
pub const BFD_RELOC_NDS32_17_PCREL: bfd_reloc_code_real = 986;
pub const BFD_RELOC_NDS32_15_PCREL: bfd_reloc_code_real = 985;
pub const BFD_RELOC_NDS32_WORD_9_PCREL: bfd_reloc_code_real = 984;
pub const BFD_RELOC_NDS32_9_PCREL: bfd_reloc_code_real = 983;
pub const BFD_RELOC_NDS32_20: bfd_reloc_code_real = 982;
pub const BFD_RELOC_M32R_GOTPC_LO: bfd_reloc_code_real = 981;
pub const BFD_RELOC_M32R_GOTPC_HI_SLO: bfd_reloc_code_real = 980;
pub const BFD_RELOC_M32R_GOTPC_HI_ULO: bfd_reloc_code_real = 979;
pub const BFD_RELOC_M32R_GOT16_LO: bfd_reloc_code_real = 978;
pub const BFD_RELOC_M32R_GOT16_HI_SLO: bfd_reloc_code_real = 977;
pub const BFD_RELOC_M32R_GOT16_HI_ULO: bfd_reloc_code_real = 976;
pub const BFD_RELOC_M32R_GOTPC24: bfd_reloc_code_real = 975;
pub const BFD_RELOC_M32R_GOTOFF_LO: bfd_reloc_code_real = 974;
pub const BFD_RELOC_M32R_GOTOFF_HI_SLO: bfd_reloc_code_real = 973;
pub const BFD_RELOC_M32R_GOTOFF_HI_ULO: bfd_reloc_code_real = 972;
pub const BFD_RELOC_M32R_GOTOFF: bfd_reloc_code_real = 971;
pub const BFD_RELOC_M32R_RELATIVE: bfd_reloc_code_real = 970;
pub const BFD_RELOC_M32R_JMP_SLOT: bfd_reloc_code_real = 969;
pub const BFD_RELOC_M32R_GLOB_DAT: bfd_reloc_code_real = 968;
pub const BFD_RELOC_M32R_COPY: bfd_reloc_code_real = 967;
pub const BFD_RELOC_M32R_26_PLTREL: bfd_reloc_code_real = 966;
pub const BFD_RELOC_M32R_GOT24: bfd_reloc_code_real = 965;
pub const BFD_RELOC_M32R_SDA16: bfd_reloc_code_real = 964;
pub const BFD_RELOC_M32R_LO16: bfd_reloc_code_real = 963;
pub const BFD_RELOC_M32R_HI16_SLO: bfd_reloc_code_real = 962;
pub const BFD_RELOC_M32R_HI16_ULO: bfd_reloc_code_real = 961;
pub const BFD_RELOC_M32R_26_PCREL: bfd_reloc_code_real = 960;
pub const BFD_RELOC_M32R_18_PCREL: bfd_reloc_code_real = 959;
pub const BFD_RELOC_M32R_10_PCREL: bfd_reloc_code_real = 958;
pub const BFD_RELOC_M32R_24: bfd_reloc_code_real = 957;
pub const BFD_RELOC_M32C_RL_2ADDR: bfd_reloc_code_real = 956;
pub const BFD_RELOC_M32C_RL_1ADDR: bfd_reloc_code_real = 955;
pub const BFD_RELOC_M32C_RL_JUMP: bfd_reloc_code_real = 954;
pub const BFD_RELOC_M32C_HI8: bfd_reloc_code_real = 953;
pub const BFD_RELOC_DLX_JMP26: bfd_reloc_code_real = 952;
pub const BFD_RELOC_DLX_LO16: bfd_reloc_code_real = 951;
pub const BFD_RELOC_DLX_HI16_S: bfd_reloc_code_real = 950;
pub const BFD_RELOC_D30V_32_PCREL: bfd_reloc_code_real = 949;
pub const BFD_RELOC_D30V_32: bfd_reloc_code_real = 948;
pub const BFD_RELOC_D30V_21_PCREL_R: bfd_reloc_code_real = 947;
pub const BFD_RELOC_D30V_21_PCREL: bfd_reloc_code_real = 946;
pub const BFD_RELOC_D30V_21: bfd_reloc_code_real = 945;
pub const BFD_RELOC_D30V_15_PCREL_R: bfd_reloc_code_real = 944;
pub const BFD_RELOC_D30V_15_PCREL: bfd_reloc_code_real = 943;
pub const BFD_RELOC_D30V_15: bfd_reloc_code_real = 942;
pub const BFD_RELOC_D30V_9_PCREL_R: bfd_reloc_code_real = 941;
pub const BFD_RELOC_D30V_9_PCREL: bfd_reloc_code_real = 940;
pub const BFD_RELOC_D30V_6: bfd_reloc_code_real = 939;
pub const BFD_RELOC_D10V_18_PCREL: bfd_reloc_code_real = 938;
pub const BFD_RELOC_D10V_18: bfd_reloc_code_real = 937;
pub const BFD_RELOC_D10V_10_PCREL_L: bfd_reloc_code_real = 936;
pub const BFD_RELOC_D10V_10_PCREL_R: bfd_reloc_code_real = 935;
pub const BFD_ARELOC_BFIN_ADDR: bfd_reloc_code_real = 934;
pub const BFD_ARELOC_BFIN_HWPAGE: bfd_reloc_code_real = 933;
pub const BFD_ARELOC_BFIN_PAGE: bfd_reloc_code_real = 932;
pub const BFD_ARELOC_BFIN_COMP: bfd_reloc_code_real = 931;
pub const BFD_ARELOC_BFIN_NEG: bfd_reloc_code_real = 930;
pub const BFD_ARELOC_BFIN_LEN: bfd_reloc_code_real = 929;
pub const BFD_ARELOC_BFIN_LOR: bfd_reloc_code_real = 928;
pub const BFD_ARELOC_BFIN_LAND: bfd_reloc_code_real = 927;
pub const BFD_ARELOC_BFIN_XOR: bfd_reloc_code_real = 926;
pub const BFD_ARELOC_BFIN_OR: bfd_reloc_code_real = 925;
pub const BFD_ARELOC_BFIN_AND: bfd_reloc_code_real = 924;
pub const BFD_ARELOC_BFIN_RSHIFT: bfd_reloc_code_real = 923;
pub const BFD_ARELOC_BFIN_LSHIFT: bfd_reloc_code_real = 922;
pub const BFD_ARELOC_BFIN_MOD: bfd_reloc_code_real = 921;
pub const BFD_ARELOC_BFIN_DIV: bfd_reloc_code_real = 920;
pub const BFD_ARELOC_BFIN_MULT: bfd_reloc_code_real = 919;
pub const BFD_ARELOC_BFIN_SUB: bfd_reloc_code_real = 918;
pub const BFD_ARELOC_BFIN_ADD: bfd_reloc_code_real = 917;
pub const BFD_ARELOC_BFIN_CONST: bfd_reloc_code_real = 916;
pub const BFD_ARELOC_BFIN_PUSH: bfd_reloc_code_real = 915;
pub const BFD_RELOC_BFIN_PLTPC: bfd_reloc_code_real = 914;
pub const BFD_RELOC_BFIN_GOT: bfd_reloc_code_real = 913;
pub const BFD_RELOC_BFIN_GOTOFFLO: bfd_reloc_code_real = 912;
pub const BFD_RELOC_BFIN_GOTOFFHI: bfd_reloc_code_real = 911;
pub const BFD_RELOC_BFIN_GOTOFF17M4: bfd_reloc_code_real = 910;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO: bfd_reloc_code_real = 909;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI: bfd_reloc_code_real = 908;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4: bfd_reloc_code_real = 907;
pub const BFD_RELOC_BFIN_FUNCDESC_VALUE: bfd_reloc_code_real = 906;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTLO: bfd_reloc_code_real = 905;
pub const BFD_RELOC_BFIN_FUNCDESC_GOTHI: bfd_reloc_code_real = 904;
pub const BFD_RELOC_BFIN_FUNCDESC_GOT17M4: bfd_reloc_code_real = 903;
pub const BFD_RELOC_BFIN_FUNCDESC: bfd_reloc_code_real = 902;
pub const BFD_RELOC_BFIN_GOTLO: bfd_reloc_code_real = 901;
pub const BFD_RELOC_BFIN_GOTHI: bfd_reloc_code_real = 900;
pub const BFD_RELOC_BFIN_GOT17M4: bfd_reloc_code_real = 899;
pub const BFD_RELOC_BFIN_24_PCREL_JUMP_L: bfd_reloc_code_real = 898;
pub const BFD_RELOC_BFIN_24_PCREL_CALL_X: bfd_reloc_code_real = 897;
pub const BFD_RELOC_BFIN_12_PCREL_JUMP_S: bfd_reloc_code_real = 896;
pub const BFD_RELOC_BFIN_12_PCREL_JUMP: bfd_reloc_code_real = 895;
pub const BFD_RELOC_BFIN_11_PCREL: bfd_reloc_code_real = 894;
pub const BFD_RELOC_BFIN_10_PCREL: bfd_reloc_code_real = 893;
pub const BFD_RELOC_BFIN_16_LOW: bfd_reloc_code_real = 892;
pub const BFD_RELOC_BFIN_5_PCREL: bfd_reloc_code_real = 891;
pub const BFD_RELOC_BFIN_4_PCREL: bfd_reloc_code_real = 890;
pub const BFD_RELOC_BFIN_16_HIGH: bfd_reloc_code_real = 889;
pub const BFD_RELOC_BFIN_16_IMM: bfd_reloc_code_real = 888;
pub const BFD_RELOC_ARC_JLI_SECTOFF: bfd_reloc_code_real = 887;
pub const BFD_RELOC_ARC_NPS_CMEM16: bfd_reloc_code_real = 886;
pub const BFD_RELOC_ARC_S21H_PCREL_PLT: bfd_reloc_code_real = 885;
pub const BFD_RELOC_ARC_S25W_PCREL_PLT: bfd_reloc_code_real = 884;
pub const BFD_RELOC_ARC_TLS_LE_32: bfd_reloc_code_real = 883;
pub const BFD_RELOC_ARC_TLS_LE_S9: bfd_reloc_code_real = 882;
pub const BFD_RELOC_ARC_TLS_DTPOFF_S9: bfd_reloc_code_real = 881;
pub const BFD_RELOC_ARC_TLS_DTPOFF: bfd_reloc_code_real = 880;
pub const BFD_RELOC_ARC_TLS_IE_GOT: bfd_reloc_code_real = 879;
pub const BFD_RELOC_ARC_TLS_GD_CALL: bfd_reloc_code_real = 878;
pub const BFD_RELOC_ARC_TLS_GD_LD: bfd_reloc_code_real = 877;
pub const BFD_RELOC_ARC_TLS_GD_GOT: bfd_reloc_code_real = 876;
pub const BFD_RELOC_ARC_TLS_TPOFF: bfd_reloc_code_real = 875;
pub const BFD_RELOC_ARC_TLS_DTPMOD: bfd_reloc_code_real = 874;
pub const BFD_RELOC_ARC_S25H_PCREL_PLT: bfd_reloc_code_real = 873;
pub const BFD_RELOC_ARC_S21W_PCREL_PLT: bfd_reloc_code_real = 872;
pub const BFD_RELOC_ARC_GOTPC: bfd_reloc_code_real = 871;
pub const BFD_RELOC_ARC_GOTOFF: bfd_reloc_code_real = 870;
pub const BFD_RELOC_ARC_RELATIVE: bfd_reloc_code_real = 869;
pub const BFD_RELOC_ARC_JMP_SLOT: bfd_reloc_code_real = 868;
pub const BFD_RELOC_ARC_GLOB_DAT: bfd_reloc_code_real = 867;
pub const BFD_RELOC_ARC_COPY: bfd_reloc_code_real = 866;
pub const BFD_RELOC_ARC_PLT32: bfd_reloc_code_real = 865;
pub const BFD_RELOC_ARC_GOTPC32: bfd_reloc_code_real = 864;
pub const BFD_RELOC_ARC_GOT32: bfd_reloc_code_real = 863;
pub const BFD_RELOC_ARC_PC32: bfd_reloc_code_real = 862;
pub const BFD_RELOC_ARC_32_PCREL: bfd_reloc_code_real = 861;
pub const BFD_RELOC_ARC_SDA16_ST2: bfd_reloc_code_real = 860;
pub const BFD_RELOC_ARC_SDA_12: bfd_reloc_code_real = 859;
pub const BFD_RELOC_ARC_SECTOFF_2: bfd_reloc_code_real = 858;
pub const BFD_RELOC_ARC_SECTOFF_1: bfd_reloc_code_real = 857;
pub const BFD_RELOC_ARC_SECTOFF_ME_2: bfd_reloc_code_real = 856;
pub const BFD_RELOC_ARC_SECTOFF_ME_1: bfd_reloc_code_real = 855;
pub const BFD_RELOC_AC_SECTOFF_S9_2: bfd_reloc_code_real = 854;
pub const BFD_RELOC_AC_SECTOFF_S9_1: bfd_reloc_code_real = 853;
pub const BFD_RELOC_AC_SECTOFF_S9: bfd_reloc_code_real = 852;
pub const BFD_RELOC_AC_SECTOFF_U8_2: bfd_reloc_code_real = 851;
pub const BFD_RELOC_AC_SECTOFF_U8_1: bfd_reloc_code_real = 850;
pub const BFD_RELOC_AC_SECTOFF_U8: bfd_reloc_code_real = 849;
pub const BFD_RELOC_ARC_W_ME: bfd_reloc_code_real = 848;
pub const BFD_RELOC_ARC_SDA32_ME: bfd_reloc_code_real = 847;
pub const BFD_RELOC_ARC_SECTOFF_ME: bfd_reloc_code_real = 846;
pub const BFD_RELOC_ARC_N32_ME: bfd_reloc_code_real = 845;
pub const BFD_RELOC_ARC_32_ME_S: bfd_reloc_code_real = 844;
pub const BFD_RELOC_ARC_32_ME: bfd_reloc_code_real = 843;
pub const BFD_RELOC_ARC_W: bfd_reloc_code_real = 842;
pub const BFD_RELOC_ARC_S13_PCREL: bfd_reloc_code_real = 841;
pub const BFD_RELOC_ARC_SDA16_LD2: bfd_reloc_code_real = 840;
pub const BFD_RELOC_ARC_SDA16_LD1: bfd_reloc_code_real = 839;
pub const BFD_RELOC_ARC_SDA16_LD: bfd_reloc_code_real = 838;
pub const BFD_RELOC_ARC_SDA_LDST2: bfd_reloc_code_real = 837;
pub const BFD_RELOC_ARC_SDA_LDST1: bfd_reloc_code_real = 836;
pub const BFD_RELOC_ARC_SDA_LDST: bfd_reloc_code_real = 835;
pub const BFD_RELOC_ARC_SDA32: bfd_reloc_code_real = 834;
pub const BFD_RELOC_ARC_S25W_PCREL: bfd_reloc_code_real = 833;
pub const BFD_RELOC_ARC_S25H_PCREL: bfd_reloc_code_real = 832;
pub const BFD_RELOC_ARC_S21W_PCREL: bfd_reloc_code_real = 831;
pub const BFD_RELOC_ARC_S21H_PCREL: bfd_reloc_code_real = 830;
pub const BFD_RELOC_ARC_SECTOFF: bfd_reloc_code_real = 829;
pub const BFD_RELOC_ARC_SDA: bfd_reloc_code_real = 828;
pub const BFD_RELOC_ARC_N32: bfd_reloc_code_real = 827;
pub const BFD_RELOC_ARC_N24: bfd_reloc_code_real = 826;
pub const BFD_RELOC_ARC_N16: bfd_reloc_code_real = 825;
pub const BFD_RELOC_ARC_N8: bfd_reloc_code_real = 824;
pub const BFD_RELOC_ARC_32: bfd_reloc_code_real = 823;
pub const BFD_RELOC_ARC_24: bfd_reloc_code_real = 822;
pub const BFD_RELOC_ARC_16: bfd_reloc_code_real = 821;
pub const BFD_RELOC_ARC_8: bfd_reloc_code_real = 820;
pub const BFD_RELOC_ARC_NONE: bfd_reloc_code_real = 819;
pub const BFD_RELOC_SH_FUNCDESC: bfd_reloc_code_real = 818;
pub const BFD_RELOC_SH_GOTOFFFUNCDESC20: bfd_reloc_code_real = 817;
pub const BFD_RELOC_SH_GOTOFFFUNCDESC: bfd_reloc_code_real = 816;
pub const BFD_RELOC_SH_GOTFUNCDESC20: bfd_reloc_code_real = 815;
pub const BFD_RELOC_SH_GOTFUNCDESC: bfd_reloc_code_real = 814;
pub const BFD_RELOC_SH_GOTOFF20: bfd_reloc_code_real = 813;
pub const BFD_RELOC_SH_GOT20: bfd_reloc_code_real = 812;
pub const BFD_RELOC_SH_TLS_TPOFF32: bfd_reloc_code_real = 811;
pub const BFD_RELOC_SH_TLS_DTPOFF32: bfd_reloc_code_real = 810;
pub const BFD_RELOC_SH_TLS_DTPMOD32: bfd_reloc_code_real = 809;
pub const BFD_RELOC_SH_TLS_LE_32: bfd_reloc_code_real = 808;
pub const BFD_RELOC_SH_TLS_IE_32: bfd_reloc_code_real = 807;
pub const BFD_RELOC_SH_TLS_LDO_32: bfd_reloc_code_real = 806;
pub const BFD_RELOC_SH_TLS_LD_32: bfd_reloc_code_real = 805;
pub const BFD_RELOC_SH_TLS_GD_32: bfd_reloc_code_real = 804;
pub const BFD_RELOC_SH_PT_16: bfd_reloc_code_real = 803;
pub const BFD_RELOC_SH_IMM_HI16_PCREL: bfd_reloc_code_real = 802;
pub const BFD_RELOC_SH_IMM_HI16: bfd_reloc_code_real = 801;
pub const BFD_RELOC_SH_IMM_MEDHI16_PCREL: bfd_reloc_code_real = 800;
pub const BFD_RELOC_SH_IMM_MEDHI16: bfd_reloc_code_real = 799;
pub const BFD_RELOC_SH_IMM_MEDLOW16_PCREL: bfd_reloc_code_real = 798;
pub const BFD_RELOC_SH_IMM_MEDLOW16: bfd_reloc_code_real = 797;
pub const BFD_RELOC_SH_IMM_LOW16_PCREL: bfd_reloc_code_real = 796;
pub const BFD_RELOC_SH_IMM_LOW16: bfd_reloc_code_real = 795;
pub const BFD_RELOC_SH_IMMU16: bfd_reloc_code_real = 794;
pub const BFD_RELOC_SH_IMMS16: bfd_reloc_code_real = 793;
pub const BFD_RELOC_SH_IMMS10BY8: bfd_reloc_code_real = 792;
pub const BFD_RELOC_SH_IMMS10BY4: bfd_reloc_code_real = 791;
pub const BFD_RELOC_SH_IMMS10BY2: bfd_reloc_code_real = 790;
pub const BFD_RELOC_SH_IMMS10: bfd_reloc_code_real = 789;
pub const BFD_RELOC_SH_IMMU6: bfd_reloc_code_real = 788;
pub const BFD_RELOC_SH_IMMS6BY32: bfd_reloc_code_real = 787;
pub const BFD_RELOC_SH_IMMS6: bfd_reloc_code_real = 786;
pub const BFD_RELOC_SH_IMMU5: bfd_reloc_code_real = 785;
pub const BFD_RELOC_SH_SHMEDIA_CODE: bfd_reloc_code_real = 784;
pub const BFD_RELOC_SH_GOTPLT32: bfd_reloc_code_real = 783;
pub const BFD_RELOC_SH_GOTPLT10BY8: bfd_reloc_code_real = 782;
pub const BFD_RELOC_SH_GOTPLT10BY4: bfd_reloc_code_real = 781;
pub const BFD_RELOC_SH_GOT10BY8: bfd_reloc_code_real = 780;
pub const BFD_RELOC_SH_GOT10BY4: bfd_reloc_code_real = 779;
pub const BFD_RELOC_SH_RELATIVE64: bfd_reloc_code_real = 778;
pub const BFD_RELOC_SH_JMP_SLOT64: bfd_reloc_code_real = 777;
pub const BFD_RELOC_SH_GLOB_DAT64: bfd_reloc_code_real = 776;
pub const BFD_RELOC_SH_COPY64: bfd_reloc_code_real = 775;
pub const BFD_RELOC_SH_GOTPC_HI16: bfd_reloc_code_real = 774;
pub const BFD_RELOC_SH_GOTPC_MEDHI16: bfd_reloc_code_real = 773;
pub const BFD_RELOC_SH_GOTPC_MEDLOW16: bfd_reloc_code_real = 772;
pub const BFD_RELOC_SH_GOTPC_LOW16: bfd_reloc_code_real = 771;
pub const BFD_RELOC_SH_GOTOFF_HI16: bfd_reloc_code_real = 770;
pub const BFD_RELOC_SH_GOTOFF_MEDHI16: bfd_reloc_code_real = 769;
pub const BFD_RELOC_SH_GOTOFF_MEDLOW16: bfd_reloc_code_real = 768;
pub const BFD_RELOC_SH_GOTOFF_LOW16: bfd_reloc_code_real = 767;
pub const BFD_RELOC_SH_PLT_HI16: bfd_reloc_code_real = 766;
pub const BFD_RELOC_SH_PLT_MEDHI16: bfd_reloc_code_real = 765;
pub const BFD_RELOC_SH_PLT_MEDLOW16: bfd_reloc_code_real = 764;
pub const BFD_RELOC_SH_PLT_LOW16: bfd_reloc_code_real = 763;
pub const BFD_RELOC_SH_GOTPLT_HI16: bfd_reloc_code_real = 762;
pub const BFD_RELOC_SH_GOTPLT_MEDHI16: bfd_reloc_code_real = 761;
pub const BFD_RELOC_SH_GOTPLT_MEDLOW16: bfd_reloc_code_real = 760;
pub const BFD_RELOC_SH_GOTPLT_LOW16: bfd_reloc_code_real = 759;
pub const BFD_RELOC_SH_GOT_HI16: bfd_reloc_code_real = 758;
pub const BFD_RELOC_SH_GOT_MEDHI16: bfd_reloc_code_real = 757;
pub const BFD_RELOC_SH_GOT_MEDLOW16: bfd_reloc_code_real = 756;
pub const BFD_RELOC_SH_GOT_LOW16: bfd_reloc_code_real = 755;
pub const BFD_RELOC_SH_GOTPC: bfd_reloc_code_real = 754;
pub const BFD_RELOC_SH_RELATIVE: bfd_reloc_code_real = 753;
pub const BFD_RELOC_SH_JMP_SLOT: bfd_reloc_code_real = 752;
pub const BFD_RELOC_SH_GLOB_DAT: bfd_reloc_code_real = 751;
pub const BFD_RELOC_SH_COPY: bfd_reloc_code_real = 750;
pub const BFD_RELOC_SH_LOOP_END: bfd_reloc_code_real = 749;
pub const BFD_RELOC_SH_LOOP_START: bfd_reloc_code_real = 748;
pub const BFD_RELOC_SH_LABEL: bfd_reloc_code_real = 747;
pub const BFD_RELOC_SH_DATA: bfd_reloc_code_real = 746;
pub const BFD_RELOC_SH_CODE: bfd_reloc_code_real = 745;
pub const BFD_RELOC_SH_ALIGN: bfd_reloc_code_real = 744;
pub const BFD_RELOC_SH_COUNT: bfd_reloc_code_real = 743;
pub const BFD_RELOC_SH_USES: bfd_reloc_code_real = 742;
pub const BFD_RELOC_SH_SWITCH32: bfd_reloc_code_real = 741;
pub const BFD_RELOC_SH_SWITCH16: bfd_reloc_code_real = 740;
pub const BFD_RELOC_SH_PCRELIMM8BY4: bfd_reloc_code_real = 739;
pub const BFD_RELOC_SH_PCRELIMM8BY2: bfd_reloc_code_real = 738;
pub const BFD_RELOC_SH_IMM8BY4: bfd_reloc_code_real = 737;
pub const BFD_RELOC_SH_IMM8BY2: bfd_reloc_code_real = 736;
pub const BFD_RELOC_SH_IMM8: bfd_reloc_code_real = 735;
pub const BFD_RELOC_SH_IMM4BY4: bfd_reloc_code_real = 734;
pub const BFD_RELOC_SH_IMM4BY2: bfd_reloc_code_real = 733;
pub const BFD_RELOC_SH_IMM4: bfd_reloc_code_real = 732;
pub const BFD_RELOC_SH_DISP20BY8: bfd_reloc_code_real = 731;
pub const BFD_RELOC_SH_DISP20: bfd_reloc_code_real = 730;
pub const BFD_RELOC_SH_DISP12BY8: bfd_reloc_code_real = 729;
pub const BFD_RELOC_SH_DISP12BY4: bfd_reloc_code_real = 728;
pub const BFD_RELOC_SH_DISP12BY2: bfd_reloc_code_real = 727;
pub const BFD_RELOC_SH_DISP12: bfd_reloc_code_real = 726;
pub const BFD_RELOC_SH_IMM3U: bfd_reloc_code_real = 725;
pub const BFD_RELOC_SH_IMM3: bfd_reloc_code_real = 724;
pub const BFD_RELOC_SH_PCDISP12BY2: bfd_reloc_code_real = 723;
pub const BFD_RELOC_SH_PCDISP8BY2: bfd_reloc_code_real = 722;
pub const BFD_RELOC_ARM_THUMB_SHIFT: bfd_reloc_code_real = 721;
pub const BFD_RELOC_ARM_THUMB_IMM: bfd_reloc_code_real = 720;
pub const BFD_RELOC_ARM_THUMB_ADD: bfd_reloc_code_real = 719;
pub const BFD_RELOC_ARM_HWLITERAL: bfd_reloc_code_real = 718;
pub const BFD_RELOC_ARM_T32_OFFSET_IMM: bfd_reloc_code_real = 717;
pub const BFD_RELOC_ARM_T32_OFFSET_U8: bfd_reloc_code_real = 716;
pub const BFD_RELOC_ARM_OFFSET_IMM8: bfd_reloc_code_real = 715;
pub const BFD_RELOC_ARM_IN_POOL: bfd_reloc_code_real = 714;
pub const BFD_RELOC_ARM_LITERAL: bfd_reloc_code_real = 713;
pub const BFD_RELOC_ARM_LDR_IMM: bfd_reloc_code_real = 712;
pub const BFD_RELOC_ARM_ADR_IMM: bfd_reloc_code_real = 711;
pub const BFD_RELOC_ARM_T32_VLDR_VSTR_OFF_IMM: bfd_reloc_code_real = 710;
pub const BFD_RELOC_ARM_T32_CP_OFF_IMM_S2: bfd_reloc_code_real = 709;
pub const BFD_RELOC_ARM_T32_CP_OFF_IMM: bfd_reloc_code_real = 708;
pub const BFD_RELOC_ARM_CP_OFF_IMM_S2: bfd_reloc_code_real = 707;
pub const BFD_RELOC_ARM_CP_OFF_IMM: bfd_reloc_code_real = 706;
pub const BFD_RELOC_ARM_MULTI: bfd_reloc_code_real = 705;
pub const BFD_RELOC_ARM_SWI: bfd_reloc_code_real = 704;
pub const BFD_RELOC_ARM_HVC: bfd_reloc_code_real = 703;
pub const BFD_RELOC_ARM_SMC: bfd_reloc_code_real = 702;
pub const BFD_RELOC_ARM_SHIFT_IMM: bfd_reloc_code_real = 701;
pub const BFD_RELOC_ARM_T32_ADD_PC12: bfd_reloc_code_real = 700;
pub const BFD_RELOC_ARM_T32_IMM12: bfd_reloc_code_real = 699;
pub const BFD_RELOC_ARM_T32_ADD_IMM: bfd_reloc_code_real = 698;
pub const BFD_RELOC_ARM_T32_IMMEDIATE: bfd_reloc_code_real = 697;
pub const BFD_RELOC_ARM_ADRL_IMMEDIATE: bfd_reloc_code_real = 696;
pub const BFD_RELOC_ARM_IMMEDIATE: bfd_reloc_code_real = 695;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC: bfd_reloc_code_real = 694;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC: bfd_reloc_code_real = 693;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC: bfd_reloc_code_real = 692;
pub const BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC: bfd_reloc_code_real = 691;
pub const BFD_RELOC_ARM_IRELATIVE: bfd_reloc_code_real = 690;
pub const BFD_RELOC_ARM_V4BX: bfd_reloc_code_real = 689;
pub const BFD_RELOC_ARM_LDC_SB_G2: bfd_reloc_code_real = 688;
pub const BFD_RELOC_ARM_LDC_SB_G1: bfd_reloc_code_real = 687;
pub const BFD_RELOC_ARM_LDC_SB_G0: bfd_reloc_code_real = 686;
pub const BFD_RELOC_ARM_LDRS_SB_G2: bfd_reloc_code_real = 685;
pub const BFD_RELOC_ARM_LDRS_SB_G1: bfd_reloc_code_real = 684;
pub const BFD_RELOC_ARM_LDRS_SB_G0: bfd_reloc_code_real = 683;
pub const BFD_RELOC_ARM_LDR_SB_G2: bfd_reloc_code_real = 682;
pub const BFD_RELOC_ARM_LDR_SB_G1: bfd_reloc_code_real = 681;
pub const BFD_RELOC_ARM_LDR_SB_G0: bfd_reloc_code_real = 680;
pub const BFD_RELOC_ARM_ALU_SB_G2: bfd_reloc_code_real = 679;
pub const BFD_RELOC_ARM_ALU_SB_G1: bfd_reloc_code_real = 678;
pub const BFD_RELOC_ARM_ALU_SB_G1_NC: bfd_reloc_code_real = 677;
pub const BFD_RELOC_ARM_ALU_SB_G0: bfd_reloc_code_real = 676;
pub const BFD_RELOC_ARM_ALU_SB_G0_NC: bfd_reloc_code_real = 675;
pub const BFD_RELOC_ARM_LDC_PC_G2: bfd_reloc_code_real = 674;
pub const BFD_RELOC_ARM_LDC_PC_G1: bfd_reloc_code_real = 673;
pub const BFD_RELOC_ARM_LDC_PC_G0: bfd_reloc_code_real = 672;
pub const BFD_RELOC_ARM_LDRS_PC_G2: bfd_reloc_code_real = 671;
pub const BFD_RELOC_ARM_LDRS_PC_G1: bfd_reloc_code_real = 670;
pub const BFD_RELOC_ARM_LDRS_PC_G0: bfd_reloc_code_real = 669;
pub const BFD_RELOC_ARM_LDR_PC_G2: bfd_reloc_code_real = 668;
pub const BFD_RELOC_ARM_LDR_PC_G1: bfd_reloc_code_real = 667;
pub const BFD_RELOC_ARM_LDR_PC_G0: bfd_reloc_code_real = 666;
pub const BFD_RELOC_ARM_ALU_PC_G2: bfd_reloc_code_real = 665;
pub const BFD_RELOC_ARM_ALU_PC_G1: bfd_reloc_code_real = 664;
pub const BFD_RELOC_ARM_ALU_PC_G1_NC: bfd_reloc_code_real = 663;
pub const BFD_RELOC_ARM_ALU_PC_G0: bfd_reloc_code_real = 662;
pub const BFD_RELOC_ARM_ALU_PC_G0_NC: bfd_reloc_code_real = 661;
pub const BFD_RELOC_ARM_TLS_DESC: bfd_reloc_code_real = 660;
pub const BFD_RELOC_ARM_THM_TLS_DESCSEQ: bfd_reloc_code_real = 659;
pub const BFD_RELOC_ARM_TLS_DESCSEQ: bfd_reloc_code_real = 658;
pub const BFD_RELOC_ARM_THM_TLS_CALL: bfd_reloc_code_real = 657;
pub const BFD_RELOC_ARM_TLS_CALL: bfd_reloc_code_real = 656;
pub const BFD_RELOC_ARM_TLS_GOTDESC: bfd_reloc_code_real = 655;
pub const BFD_RELOC_ARM_TLS_LE32: bfd_reloc_code_real = 654;
pub const BFD_RELOC_ARM_TLS_IE32: bfd_reloc_code_real = 653;
pub const BFD_RELOC_ARM_TLS_TPOFF32: bfd_reloc_code_real = 652;
pub const BFD_RELOC_ARM_TLS_DTPMOD32: bfd_reloc_code_real = 651;
pub const BFD_RELOC_ARM_TLS_DTPOFF32: bfd_reloc_code_real = 650;
pub const BFD_RELOC_ARM_TLS_LDM32: bfd_reloc_code_real = 649;
pub const BFD_RELOC_ARM_TLS_LDO32: bfd_reloc_code_real = 648;
pub const BFD_RELOC_ARM_TLS_GD32: bfd_reloc_code_real = 647;
pub const BFD_RELOC_ARM_GOT_PREL: bfd_reloc_code_real = 646;
pub const BFD_RELOC_ARM_GOTPC: bfd_reloc_code_real = 645;
pub const BFD_RELOC_ARM_GOTOFF: bfd_reloc_code_real = 644;
pub const BFD_RELOC_ARM_RELATIVE: bfd_reloc_code_real = 643;
pub const BFD_RELOC_ARM_PLT32: bfd_reloc_code_real = 642;
pub const BFD_RELOC_ARM_GOT32: bfd_reloc_code_real = 641;
pub const BFD_RELOC_ARM_GLOB_DAT: bfd_reloc_code_real = 640;
pub const BFD_RELOC_ARM_JUMP_SLOT: bfd_reloc_code_real = 639;
pub const BFD_RELOC_ARM_TLS_IE32_FDPIC: bfd_reloc_code_real = 638;
pub const BFD_RELOC_ARM_TLS_LDM32_FDPIC: bfd_reloc_code_real = 637;
pub const BFD_RELOC_ARM_TLS_GD32_FDPIC: bfd_reloc_code_real = 636;
pub const BFD_RELOC_ARM_FUNCDESC_VALUE: bfd_reloc_code_real = 635;
pub const BFD_RELOC_ARM_FUNCDESC: bfd_reloc_code_real = 634;
pub const BFD_RELOC_ARM_GOTOFFFUNCDESC: bfd_reloc_code_real = 633;
pub const BFD_RELOC_ARM_GOTFUNCDESC: bfd_reloc_code_real = 632;
pub const BFD_RELOC_ARM_THUMB_MOVT_PCREL: bfd_reloc_code_real = 631;
pub const BFD_RELOC_ARM_THUMB_MOVW_PCREL: bfd_reloc_code_real = 630;
pub const BFD_RELOC_ARM_THUMB_MOVT: bfd_reloc_code_real = 629;
pub const BFD_RELOC_ARM_THUMB_MOVW: bfd_reloc_code_real = 628;
pub const BFD_RELOC_ARM_MOVT_PCREL: bfd_reloc_code_real = 627;
pub const BFD_RELOC_ARM_MOVW_PCREL: bfd_reloc_code_real = 626;
pub const BFD_RELOC_ARM_MOVT: bfd_reloc_code_real = 625;
pub const BFD_RELOC_ARM_MOVW: bfd_reloc_code_real = 624;
pub const BFD_RELOC_ARM_PREL31: bfd_reloc_code_real = 623;
pub const BFD_RELOC_ARM_TARGET2: bfd_reloc_code_real = 622;
pub const BFD_RELOC_ARM_SBREL32: bfd_reloc_code_real = 621;
pub const BFD_RELOC_ARM_ROSEGREL32: bfd_reloc_code_real = 620;
pub const BFD_RELOC_ARM_TARGET1: bfd_reloc_code_real = 619;
pub const BFD_RELOC_ARM_THUMB_OFFSET: bfd_reloc_code_real = 618;
pub const BFD_RELOC_ARM_OFFSET_IMM: bfd_reloc_code_real = 617;
pub const BFD_RELOC_THUMB_PCREL_BRANCH25: bfd_reloc_code_real = 616;
pub const BFD_RELOC_THUMB_PCREL_BRANCH23: bfd_reloc_code_real = 615;
pub const BFD_RELOC_THUMB_PCREL_BRANCH20: bfd_reloc_code_real = 614;
pub const BFD_RELOC_THUMB_PCREL_BRANCH12: bfd_reloc_code_real = 613;
pub const BFD_RELOC_THUMB_PCREL_BRANCH9: bfd_reloc_code_real = 612;
pub const BFD_RELOC_THUMB_PCREL_BRANCH7: bfd_reloc_code_real = 611;
pub const BFD_RELOC_ARM_THUMB_LOOP12: bfd_reloc_code_real = 610;
pub const BFD_RELOC_ARM_THUMB_BF19: bfd_reloc_code_real = 609;
pub const BFD_RELOC_ARM_THUMB_BF13: bfd_reloc_code_real = 608;
pub const BFD_RELOC_ARM_THUMB_BF17: bfd_reloc_code_real = 607;
pub const BFD_RELOC_THUMB_PCREL_BFCSEL: bfd_reloc_code_real = 606;
pub const BFD_RELOC_THUMB_PCREL_BRANCH5: bfd_reloc_code_real = 605;
pub const BFD_RELOC_ARM_PCREL_JUMP: bfd_reloc_code_real = 604;
pub const BFD_RELOC_ARM_PCREL_CALL: bfd_reloc_code_real = 603;
pub const BFD_RELOC_THUMB_PCREL_BLX: bfd_reloc_code_real = 602;
pub const BFD_RELOC_ARM_PCREL_BLX: bfd_reloc_code_real = 601;
pub const BFD_RELOC_ARM_PCREL_BRANCH: bfd_reloc_code_real = 600;
pub const BFD_RELOC_CTOR: bfd_reloc_code_real = 599;
pub const BFD_RELOC_I370_D12: bfd_reloc_code_real = 598;
pub const BFD_RELOC_PPC64_TLS_PCREL: bfd_reloc_code_real = 597;
pub const BFD_RELOC_PPC64_GOT_DTPREL_PCREL34: bfd_reloc_code_real = 596;
pub const BFD_RELOC_PPC64_GOT_TPREL_PCREL34: bfd_reloc_code_real = 595;
pub const BFD_RELOC_PPC64_GOT_TLSLD_PCREL34: bfd_reloc_code_real = 594;
pub const BFD_RELOC_PPC64_GOT_TLSGD_PCREL34: bfd_reloc_code_real = 593;
pub const BFD_RELOC_PPC64_DTPREL34: bfd_reloc_code_real = 592;
pub const BFD_RELOC_PPC64_TPREL34: bfd_reloc_code_real = 591;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHESTA: bfd_reloc_code_real = 590;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHEST: bfd_reloc_code_real = 589;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHERA: bfd_reloc_code_real = 588;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHER: bfd_reloc_code_real = 587;
pub const BFD_RELOC_PPC64_DTPREL16_HIGHA: bfd_reloc_code_real = 586;
pub const BFD_RELOC_PPC64_DTPREL16_HIGH: bfd_reloc_code_real = 585;
pub const BFD_RELOC_PPC64_DTPREL16_LO_DS: bfd_reloc_code_real = 584;
pub const BFD_RELOC_PPC64_DTPREL16_DS: bfd_reloc_code_real = 583;
pub const BFD_RELOC_PPC64_TPREL16_HIGHESTA: bfd_reloc_code_real = 582;
pub const BFD_RELOC_PPC64_TPREL16_HIGHEST: bfd_reloc_code_real = 581;
pub const BFD_RELOC_PPC64_TPREL16_HIGHERA: bfd_reloc_code_real = 580;
pub const BFD_RELOC_PPC64_TPREL16_HIGHER: bfd_reloc_code_real = 579;
pub const BFD_RELOC_PPC64_TPREL16_HIGHA: bfd_reloc_code_real = 578;
pub const BFD_RELOC_PPC64_TPREL16_HIGH: bfd_reloc_code_real = 577;
pub const BFD_RELOC_PPC64_TPREL16_LO_DS: bfd_reloc_code_real = 576;
pub const BFD_RELOC_PPC64_TPREL16_DS: bfd_reloc_code_real = 575;
pub const BFD_RELOC_PPC64_TLSML: bfd_reloc_code_real = 574;
pub const BFD_RELOC_PPC64_TLSM: bfd_reloc_code_real = 573;
pub const BFD_RELOC_PPC64_TLSIE: bfd_reloc_code_real = 572;
pub const BFD_RELOC_PPC64_TLSLE: bfd_reloc_code_real = 571;
pub const BFD_RELOC_PPC64_TLSLD: bfd_reloc_code_real = 570;
pub const BFD_RELOC_PPC64_TLSGD: bfd_reloc_code_real = 569;
pub const BFD_RELOC_PPC_GOT_DTPREL16_HA: bfd_reloc_code_real = 568;
pub const BFD_RELOC_PPC_GOT_DTPREL16_HI: bfd_reloc_code_real = 567;
pub const BFD_RELOC_PPC_GOT_DTPREL16_LO: bfd_reloc_code_real = 566;
pub const BFD_RELOC_PPC_GOT_DTPREL16: bfd_reloc_code_real = 565;
pub const BFD_RELOC_PPC_GOT_TPREL16_HA: bfd_reloc_code_real = 564;
pub const BFD_RELOC_PPC_GOT_TPREL16_HI: bfd_reloc_code_real = 563;
pub const BFD_RELOC_PPC_GOT_TPREL16_LO: bfd_reloc_code_real = 562;
pub const BFD_RELOC_PPC_GOT_TPREL16: bfd_reloc_code_real = 561;
pub const BFD_RELOC_PPC_GOT_TLSLD16_HA: bfd_reloc_code_real = 560;
pub const BFD_RELOC_PPC_GOT_TLSLD16_HI: bfd_reloc_code_real = 559;
pub const BFD_RELOC_PPC_GOT_TLSLD16_LO: bfd_reloc_code_real = 558;
pub const BFD_RELOC_PPC_GOT_TLSLD16: bfd_reloc_code_real = 557;
pub const BFD_RELOC_PPC_GOT_TLSGD16_HA: bfd_reloc_code_real = 556;
pub const BFD_RELOC_PPC_GOT_TLSGD16_HI: bfd_reloc_code_real = 555;
pub const BFD_RELOC_PPC_GOT_TLSGD16_LO: bfd_reloc_code_real = 554;
pub const BFD_RELOC_PPC_GOT_TLSGD16: bfd_reloc_code_real = 553;
pub const BFD_RELOC_PPC_DTPREL: bfd_reloc_code_real = 552;
pub const BFD_RELOC_PPC_DTPREL16_HA: bfd_reloc_code_real = 551;
pub const BFD_RELOC_PPC_DTPREL16_HI: bfd_reloc_code_real = 550;
pub const BFD_RELOC_PPC_DTPREL16_LO: bfd_reloc_code_real = 549;
pub const BFD_RELOC_PPC_DTPREL16: bfd_reloc_code_real = 548;
pub const BFD_RELOC_PPC_TPREL: bfd_reloc_code_real = 547;
pub const BFD_RELOC_PPC_TPREL16_HA: bfd_reloc_code_real = 546;
pub const BFD_RELOC_PPC_TPREL16_HI: bfd_reloc_code_real = 545;
pub const BFD_RELOC_PPC_TPREL16_LO: bfd_reloc_code_real = 544;
pub const BFD_RELOC_PPC_TPREL16: bfd_reloc_code_real = 543;
pub const BFD_RELOC_PPC_DTPMOD: bfd_reloc_code_real = 542;
pub const BFD_RELOC_PPC_TLSML: bfd_reloc_code_real = 541;
pub const BFD_RELOC_PPC_TLSM: bfd_reloc_code_real = 540;
pub const BFD_RELOC_PPC_TLSIE: bfd_reloc_code_real = 539;
pub const BFD_RELOC_PPC_TLSLE: bfd_reloc_code_real = 538;
pub const BFD_RELOC_PPC_TLSLD: bfd_reloc_code_real = 537;
pub const BFD_RELOC_PPC_TLSGD: bfd_reloc_code_real = 536;
pub const BFD_RELOC_PPC_TLS: bfd_reloc_code_real = 535;
pub const BFD_RELOC_PPC64_PCREL28: bfd_reloc_code_real = 534;
pub const BFD_RELOC_PPC64_D28: bfd_reloc_code_real = 533;
pub const BFD_RELOC_PPC64_REL16_HIGHESTA34: bfd_reloc_code_real = 532;
pub const BFD_RELOC_PPC64_REL16_HIGHEST34: bfd_reloc_code_real = 531;
pub const BFD_RELOC_PPC64_REL16_HIGHERA34: bfd_reloc_code_real = 530;
pub const BFD_RELOC_PPC64_REL16_HIGHER34: bfd_reloc_code_real = 529;
pub const BFD_RELOC_PPC64_ADDR16_HIGHESTA34: bfd_reloc_code_real = 528;
pub const BFD_RELOC_PPC64_ADDR16_HIGHEST34: bfd_reloc_code_real = 527;
pub const BFD_RELOC_PPC64_ADDR16_HIGHERA34: bfd_reloc_code_real = 526;
pub const BFD_RELOC_PPC64_ADDR16_HIGHER34: bfd_reloc_code_real = 525;
pub const BFD_RELOC_PPC64_PLT_PCREL34: bfd_reloc_code_real = 524;
pub const BFD_RELOC_PPC64_GOT_PCREL34: bfd_reloc_code_real = 523;
pub const BFD_RELOC_PPC64_PCREL34: bfd_reloc_code_real = 522;
pub const BFD_RELOC_PPC64_D34_HA30: bfd_reloc_code_real = 521;
pub const BFD_RELOC_PPC64_D34_HI30: bfd_reloc_code_real = 520;
pub const BFD_RELOC_PPC64_D34_LO: bfd_reloc_code_real = 519;
pub const BFD_RELOC_PPC64_D34: bfd_reloc_code_real = 518;
pub const BFD_RELOC_PPC64_REL24_NOTOC: bfd_reloc_code_real = 517;
pub const BFD_RELOC_PPC64_ENTRY: bfd_reloc_code_real = 516;
pub const BFD_RELOC_PPC64_ADDR64_LOCAL: bfd_reloc_code_real = 515;
pub const BFD_RELOC_PPC64_REL16_HIGHESTA: bfd_reloc_code_real = 514;
pub const BFD_RELOC_PPC64_REL16_HIGHEST: bfd_reloc_code_real = 513;
pub const BFD_RELOC_PPC64_REL16_HIGHERA: bfd_reloc_code_real = 512;
pub const BFD_RELOC_PPC64_REL16_HIGHER: bfd_reloc_code_real = 511;
pub const BFD_RELOC_PPC64_REL16_HIGHA: bfd_reloc_code_real = 510;
pub const BFD_RELOC_PPC64_REL16_HIGH: bfd_reloc_code_real = 509;
pub const BFD_RELOC_PPC64_ADDR16_HIGHA: bfd_reloc_code_real = 508;
pub const BFD_RELOC_PPC64_ADDR16_HIGH: bfd_reloc_code_real = 507;
pub const BFD_RELOC_PPC64_PLTGOT16_LO_DS: bfd_reloc_code_real = 506;
pub const BFD_RELOC_PPC64_PLTGOT16_DS: bfd_reloc_code_real = 505;
pub const BFD_RELOC_PPC64_TOC16_LO_DS: bfd_reloc_code_real = 504;
pub const BFD_RELOC_PPC64_TOC16_DS: bfd_reloc_code_real = 503;
pub const BFD_RELOC_PPC64_SECTOFF_LO_DS: bfd_reloc_code_real = 502;
pub const BFD_RELOC_PPC64_SECTOFF_DS: bfd_reloc_code_real = 501;
pub const BFD_RELOC_PPC64_PLT16_LO_DS: bfd_reloc_code_real = 500;
pub const BFD_RELOC_PPC64_GOT16_LO_DS: bfd_reloc_code_real = 499;
pub const BFD_RELOC_PPC64_GOT16_DS: bfd_reloc_code_real = 498;
pub const BFD_RELOC_PPC64_ADDR16_LO_DS: bfd_reloc_code_real = 497;
pub const BFD_RELOC_PPC64_ADDR16_DS: bfd_reloc_code_real = 496;
pub const BFD_RELOC_PPC64_PLTGOT16_HA: bfd_reloc_code_real = 495;
pub const BFD_RELOC_PPC64_PLTGOT16_HI: bfd_reloc_code_real = 494;
pub const BFD_RELOC_PPC64_PLTGOT16_LO: bfd_reloc_code_real = 493;
pub const BFD_RELOC_PPC64_PLTGOT16: bfd_reloc_code_real = 492;
pub const BFD_RELOC_PPC64_TOC: bfd_reloc_code_real = 491;
pub const BFD_RELOC_PPC64_TOC16_HA: bfd_reloc_code_real = 490;
pub const BFD_RELOC_PPC64_TOC16_HI: bfd_reloc_code_real = 489;
pub const BFD_RELOC_PPC64_TOC16_LO: bfd_reloc_code_real = 488;
pub const BFD_RELOC_PPC64_HIGHEST_S: bfd_reloc_code_real = 487;
pub const BFD_RELOC_PPC64_HIGHEST: bfd_reloc_code_real = 486;
pub const BFD_RELOC_PPC64_HIGHER_S: bfd_reloc_code_real = 485;
pub const BFD_RELOC_PPC64_HIGHER: bfd_reloc_code_real = 484;
pub const BFD_RELOC_PPC_NEG: bfd_reloc_code_real = 483;
pub const BFD_RELOC_PPC_REL16DX_HA: bfd_reloc_code_real = 482;
pub const BFD_RELOC_PPC_16DX_HA: bfd_reloc_code_real = 481;
pub const BFD_RELOC_PPC_VLE_SDAREL_HA16D: bfd_reloc_code_real = 480;
pub const BFD_RELOC_PPC_VLE_SDAREL_HA16A: bfd_reloc_code_real = 479;
pub const BFD_RELOC_PPC_VLE_SDAREL_HI16D: bfd_reloc_code_real = 478;
pub const BFD_RELOC_PPC_VLE_SDAREL_HI16A: bfd_reloc_code_real = 477;
pub const BFD_RELOC_PPC_VLE_SDAREL_LO16D: bfd_reloc_code_real = 476;
pub const BFD_RELOC_PPC_VLE_SDAREL_LO16A: bfd_reloc_code_real = 475;
pub const BFD_RELOC_PPC_VLE_SDA21_LO: bfd_reloc_code_real = 474;
pub const BFD_RELOC_PPC_VLE_SDA21: bfd_reloc_code_real = 473;
pub const BFD_RELOC_PPC_VLE_HA16D: bfd_reloc_code_real = 472;
pub const BFD_RELOC_PPC_VLE_HA16A: bfd_reloc_code_real = 471;
pub const BFD_RELOC_PPC_VLE_HI16D: bfd_reloc_code_real = 470;
pub const BFD_RELOC_PPC_VLE_HI16A: bfd_reloc_code_real = 469;
pub const BFD_RELOC_PPC_VLE_LO16D: bfd_reloc_code_real = 468;
pub const BFD_RELOC_PPC_VLE_LO16A: bfd_reloc_code_real = 467;
pub const BFD_RELOC_PPC_VLE_REL24: bfd_reloc_code_real = 466;
pub const BFD_RELOC_PPC_VLE_REL15: bfd_reloc_code_real = 465;
pub const BFD_RELOC_PPC_VLE_REL8: bfd_reloc_code_real = 464;
pub const BFD_RELOC_PPC_EMB_RELSDA: bfd_reloc_code_real = 463;
pub const BFD_RELOC_PPC_EMB_BIT_FLD: bfd_reloc_code_real = 462;
pub const BFD_RELOC_PPC_EMB_RELST_HA: bfd_reloc_code_real = 461;
pub const BFD_RELOC_PPC_EMB_RELST_HI: bfd_reloc_code_real = 460;
pub const BFD_RELOC_PPC_EMB_RELST_LO: bfd_reloc_code_real = 459;
pub const BFD_RELOC_PPC_EMB_RELSEC16: bfd_reloc_code_real = 458;
pub const BFD_RELOC_PPC_EMB_MRKREF: bfd_reloc_code_real = 457;
pub const BFD_RELOC_PPC_EMB_SDA21: bfd_reloc_code_real = 456;
pub const BFD_RELOC_PPC_EMB_SDA2REL: bfd_reloc_code_real = 455;
pub const BFD_RELOC_PPC_EMB_SDA2I16: bfd_reloc_code_real = 454;
pub const BFD_RELOC_PPC_EMB_SDAI16: bfd_reloc_code_real = 453;
pub const BFD_RELOC_PPC_EMB_NADDR16_HA: bfd_reloc_code_real = 452;
pub const BFD_RELOC_PPC_EMB_NADDR16_HI: bfd_reloc_code_real = 451;
pub const BFD_RELOC_PPC_EMB_NADDR16_LO: bfd_reloc_code_real = 450;
pub const BFD_RELOC_PPC_EMB_NADDR16: bfd_reloc_code_real = 449;
pub const BFD_RELOC_PPC_EMB_NADDR32: bfd_reloc_code_real = 448;
pub const BFD_RELOC_PPC_LOCAL24PC: bfd_reloc_code_real = 447;
pub const BFD_RELOC_PPC_RELATIVE: bfd_reloc_code_real = 446;
pub const BFD_RELOC_PPC_JMP_SLOT: bfd_reloc_code_real = 445;
pub const BFD_RELOC_PPC_GLOB_DAT: bfd_reloc_code_real = 444;
pub const BFD_RELOC_PPC_COPY: bfd_reloc_code_real = 443;
pub const BFD_RELOC_PPC_BA16_BRNTAKEN: bfd_reloc_code_real = 442;
pub const BFD_RELOC_PPC_BA16_BRTAKEN: bfd_reloc_code_real = 441;
pub const BFD_RELOC_PPC_BA16: bfd_reloc_code_real = 440;
pub const BFD_RELOC_PPC_B16_BRNTAKEN: bfd_reloc_code_real = 439;
pub const BFD_RELOC_PPC_B16_BRTAKEN: bfd_reloc_code_real = 438;
pub const BFD_RELOC_PPC_B16: bfd_reloc_code_real = 437;
pub const BFD_RELOC_PPC_TOC16_HI: bfd_reloc_code_real = 436;
pub const BFD_RELOC_PPC_TOC16_LO: bfd_reloc_code_real = 435;
pub const BFD_RELOC_PPC_TOC16: bfd_reloc_code_real = 434;
pub const BFD_RELOC_PPC_BA26: bfd_reloc_code_real = 433;
pub const BFD_RELOC_PPC_B26: bfd_reloc_code_real = 432;
pub const BFD_RELOC_PJ_CODE_REL32: bfd_reloc_code_real = 431;
pub const BFD_RELOC_PJ_CODE_REL16: bfd_reloc_code_real = 430;
pub const BFD_RELOC_PJ_CODE_DIR32: bfd_reloc_code_real = 429;
pub const BFD_RELOC_PJ_CODE_DIR16: bfd_reloc_code_real = 428;
pub const BFD_RELOC_PJ_CODE_LO16: bfd_reloc_code_real = 427;
pub const BFD_RELOC_PJ_CODE_HI16: bfd_reloc_code_real = 426;
pub const BFD_RELOC_PDP11_DISP_6_PCREL: bfd_reloc_code_real = 425;
pub const BFD_RELOC_PDP11_DISP_8_PCREL: bfd_reloc_code_real = 424;
pub const BFD_RELOC_NS32K_DISP_32_PCREL: bfd_reloc_code_real = 423;
pub const BFD_RELOC_NS32K_DISP_16_PCREL: bfd_reloc_code_real = 422;
pub const BFD_RELOC_NS32K_DISP_8_PCREL: bfd_reloc_code_real = 421;
pub const BFD_RELOC_NS32K_DISP_32: bfd_reloc_code_real = 420;
pub const BFD_RELOC_NS32K_DISP_16: bfd_reloc_code_real = 419;
pub const BFD_RELOC_NS32K_DISP_8: bfd_reloc_code_real = 418;
pub const BFD_RELOC_NS32K_IMM_32_PCREL: bfd_reloc_code_real = 417;
pub const BFD_RELOC_NS32K_IMM_16_PCREL: bfd_reloc_code_real = 416;
pub const BFD_RELOC_NS32K_IMM_8_PCREL: bfd_reloc_code_real = 415;
pub const BFD_RELOC_NS32K_IMM_32: bfd_reloc_code_real = 414;
pub const BFD_RELOC_NS32K_IMM_16: bfd_reloc_code_real = 413;
pub const BFD_RELOC_NS32K_IMM_8: bfd_reloc_code_real = 412;
pub const BFD_RELOC_X86_64_REX_GOTPCRELX: bfd_reloc_code_real = 411;
pub const BFD_RELOC_X86_64_GOTPCRELX: bfd_reloc_code_real = 410;
pub const BFD_RELOC_X86_64_PLT32_BND: bfd_reloc_code_real = 409;
pub const BFD_RELOC_X86_64_PC32_BND: bfd_reloc_code_real = 408;
pub const BFD_RELOC_X86_64_IRELATIVE: bfd_reloc_code_real = 407;
pub const BFD_RELOC_X86_64_TLSDESC: bfd_reloc_code_real = 406;
pub const BFD_RELOC_X86_64_TLSDESC_CALL: bfd_reloc_code_real = 405;
pub const BFD_RELOC_X86_64_GOTPC32_TLSDESC: bfd_reloc_code_real = 404;
pub const BFD_RELOC_X86_64_PLTOFF64: bfd_reloc_code_real = 403;
pub const BFD_RELOC_X86_64_GOTPLT64: bfd_reloc_code_real = 402;
pub const BFD_RELOC_X86_64_GOTPC64: bfd_reloc_code_real = 401;
pub const BFD_RELOC_X86_64_GOTPCREL64: bfd_reloc_code_real = 400;
pub const BFD_RELOC_X86_64_GOT64: bfd_reloc_code_real = 399;
pub const BFD_RELOC_X86_64_GOTPC32: bfd_reloc_code_real = 398;
pub const BFD_RELOC_X86_64_GOTOFF64: bfd_reloc_code_real = 397;
pub const BFD_RELOC_X86_64_TPOFF32: bfd_reloc_code_real = 396;
pub const BFD_RELOC_X86_64_GOTTPOFF: bfd_reloc_code_real = 395;
pub const BFD_RELOC_X86_64_DTPOFF32: bfd_reloc_code_real = 394;
pub const BFD_RELOC_X86_64_TLSLD: bfd_reloc_code_real = 393;
pub const BFD_RELOC_X86_64_TLSGD: bfd_reloc_code_real = 392;
pub const BFD_RELOC_X86_64_TPOFF64: bfd_reloc_code_real = 391;
pub const BFD_RELOC_X86_64_DTPOFF64: bfd_reloc_code_real = 390;
pub const BFD_RELOC_X86_64_DTPMOD64: bfd_reloc_code_real = 389;
pub const BFD_RELOC_X86_64_32S: bfd_reloc_code_real = 388;
pub const BFD_RELOC_X86_64_GOTPCREL: bfd_reloc_code_real = 387;
pub const BFD_RELOC_X86_64_RELATIVE: bfd_reloc_code_real = 386;
pub const BFD_RELOC_X86_64_JUMP_SLOT: bfd_reloc_code_real = 385;
pub const BFD_RELOC_X86_64_GLOB_DAT: bfd_reloc_code_real = 384;
pub const BFD_RELOC_X86_64_COPY: bfd_reloc_code_real = 383;
pub const BFD_RELOC_X86_64_PLT32: bfd_reloc_code_real = 382;
pub const BFD_RELOC_X86_64_GOT32: bfd_reloc_code_real = 381;
pub const BFD_RELOC_386_GOT32X: bfd_reloc_code_real = 380;
pub const BFD_RELOC_386_IRELATIVE: bfd_reloc_code_real = 379;
pub const BFD_RELOC_386_TLS_DESC: bfd_reloc_code_real = 378;
pub const BFD_RELOC_386_TLS_DESC_CALL: bfd_reloc_code_real = 377;
pub const BFD_RELOC_386_TLS_GOTDESC: bfd_reloc_code_real = 376;
pub const BFD_RELOC_386_TLS_TPOFF32: bfd_reloc_code_real = 375;
pub const BFD_RELOC_386_TLS_DTPOFF32: bfd_reloc_code_real = 374;
pub const BFD_RELOC_386_TLS_DTPMOD32: bfd_reloc_code_real = 373;
pub const BFD_RELOC_386_TLS_LE_32: bfd_reloc_code_real = 372;
pub const BFD_RELOC_386_TLS_IE_32: bfd_reloc_code_real = 371;
pub const BFD_RELOC_386_TLS_LDO_32: bfd_reloc_code_real = 370;
pub const BFD_RELOC_386_TLS_LDM: bfd_reloc_code_real = 369;
pub const BFD_RELOC_386_TLS_GD: bfd_reloc_code_real = 368;
pub const BFD_RELOC_386_TLS_LE: bfd_reloc_code_real = 367;
pub const BFD_RELOC_386_TLS_GOTIE: bfd_reloc_code_real = 366;
pub const BFD_RELOC_386_TLS_IE: bfd_reloc_code_real = 365;
pub const BFD_RELOC_386_TLS_TPOFF: bfd_reloc_code_real = 364;
pub const BFD_RELOC_386_GOTPC: bfd_reloc_code_real = 363;
pub const BFD_RELOC_386_GOTOFF: bfd_reloc_code_real = 362;
pub const BFD_RELOC_386_RELATIVE: bfd_reloc_code_real = 361;
pub const BFD_RELOC_386_JUMP_SLOT: bfd_reloc_code_real = 360;
pub const BFD_RELOC_386_GLOB_DAT: bfd_reloc_code_real = 359;
pub const BFD_RELOC_386_COPY: bfd_reloc_code_real = 358;
pub const BFD_RELOC_386_PLT32: bfd_reloc_code_real = 357;
pub const BFD_RELOC_386_GOT32: bfd_reloc_code_real = 356;
pub const BFD_RELOC_MN10300_16_PCREL: bfd_reloc_code_real = 355;
pub const BFD_RELOC_MN10300_32_PCREL: bfd_reloc_code_real = 354;
pub const BFD_RELOC_MN10300_TLS_TPOFF: bfd_reloc_code_real = 353;
pub const BFD_RELOC_MN10300_TLS_DTPOFF: bfd_reloc_code_real = 352;
pub const BFD_RELOC_MN10300_TLS_DTPMOD: bfd_reloc_code_real = 351;
pub const BFD_RELOC_MN10300_TLS_LE: bfd_reloc_code_real = 350;
pub const BFD_RELOC_MN10300_TLS_IE: bfd_reloc_code_real = 349;
pub const BFD_RELOC_MN10300_TLS_GOTIE: bfd_reloc_code_real = 348;
pub const BFD_RELOC_MN10300_TLS_LDO: bfd_reloc_code_real = 347;
pub const BFD_RELOC_MN10300_TLS_LD: bfd_reloc_code_real = 346;
pub const BFD_RELOC_MN10300_TLS_GD: bfd_reloc_code_real = 345;
pub const BFD_RELOC_MN10300_ALIGN: bfd_reloc_code_real = 344;
pub const BFD_RELOC_MN10300_SYM_DIFF: bfd_reloc_code_real = 343;
pub const BFD_RELOC_MN10300_RELATIVE: bfd_reloc_code_real = 342;
pub const BFD_RELOC_MN10300_JMP_SLOT: bfd_reloc_code_real = 341;
pub const BFD_RELOC_MN10300_GLOB_DAT: bfd_reloc_code_real = 340;
pub const BFD_RELOC_MN10300_COPY: bfd_reloc_code_real = 339;
pub const BFD_RELOC_MN10300_GOT16: bfd_reloc_code_real = 338;
pub const BFD_RELOC_MN10300_GOT24: bfd_reloc_code_real = 337;
pub const BFD_RELOC_MN10300_GOT32: bfd_reloc_code_real = 336;
pub const BFD_RELOC_MN10300_GOTOFF24: bfd_reloc_code_real = 335;
pub const BFD_RELOC_FRV_TLSMOFF: bfd_reloc_code_real = 334;
pub const BFD_RELOC_FRV_TLSOFF_RELAX: bfd_reloc_code_real = 333;
pub const BFD_RELOC_FRV_GETTLSOFF_RELAX: bfd_reloc_code_real = 332;
pub const BFD_RELOC_FRV_TLSDESC_RELAX: bfd_reloc_code_real = 331;
pub const BFD_RELOC_FRV_TLSOFF: bfd_reloc_code_real = 330;
pub const BFD_RELOC_FRV_GOTTLSOFFLO: bfd_reloc_code_real = 329;
pub const BFD_RELOC_FRV_GOTTLSOFFHI: bfd_reloc_code_real = 328;
pub const BFD_RELOC_FRV_GOTTLSOFF12: bfd_reloc_code_real = 327;
pub const BFD_RELOC_FRV_TLSMOFFLO: bfd_reloc_code_real = 326;
pub const BFD_RELOC_FRV_TLSMOFFHI: bfd_reloc_code_real = 325;
pub const BFD_RELOC_FRV_TLSMOFF12: bfd_reloc_code_real = 324;
pub const BFD_RELOC_FRV_GOTTLSDESCLO: bfd_reloc_code_real = 323;
pub const BFD_RELOC_FRV_GOTTLSDESCHI: bfd_reloc_code_real = 322;
pub const BFD_RELOC_FRV_GOTTLSDESC12: bfd_reloc_code_real = 321;
pub const BFD_RELOC_FRV_TLSDESC_VALUE: bfd_reloc_code_real = 320;
pub const BFD_RELOC_FRV_GETTLSOFF: bfd_reloc_code_real = 319;
pub const BFD_RELOC_FRV_GOTOFFLO: bfd_reloc_code_real = 318;
pub const BFD_RELOC_FRV_GOTOFFHI: bfd_reloc_code_real = 317;
pub const BFD_RELOC_FRV_GOTOFF12: bfd_reloc_code_real = 316;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFFLO: bfd_reloc_code_real = 315;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFFHI: bfd_reloc_code_real = 314;
pub const BFD_RELOC_FRV_FUNCDESC_GOTOFF12: bfd_reloc_code_real = 313;
pub const BFD_RELOC_FRV_FUNCDESC_VALUE: bfd_reloc_code_real = 312;
pub const BFD_RELOC_FRV_FUNCDESC_GOTLO: bfd_reloc_code_real = 311;
pub const BFD_RELOC_FRV_FUNCDESC_GOTHI: bfd_reloc_code_real = 310;
pub const BFD_RELOC_FRV_FUNCDESC_GOT12: bfd_reloc_code_real = 309;
pub const BFD_RELOC_FRV_FUNCDESC: bfd_reloc_code_real = 308;
pub const BFD_RELOC_FRV_GOTLO: bfd_reloc_code_real = 307;
pub const BFD_RELOC_FRV_GOTHI: bfd_reloc_code_real = 306;
pub const BFD_RELOC_FRV_GOT12: bfd_reloc_code_real = 305;
pub const BFD_RELOC_FRV_GPRELLO: bfd_reloc_code_real = 304;
pub const BFD_RELOC_FRV_GPRELHI: bfd_reloc_code_real = 303;
pub const BFD_RELOC_FRV_GPREL32: bfd_reloc_code_real = 302;
pub const BFD_RELOC_FRV_GPRELU12: bfd_reloc_code_real = 301;
pub const BFD_RELOC_FRV_GPREL12: bfd_reloc_code_real = 300;
pub const BFD_RELOC_FRV_HI16: bfd_reloc_code_real = 299;
pub const BFD_RELOC_FRV_LO16: bfd_reloc_code_real = 298;
pub const BFD_RELOC_FRV_LABEL24: bfd_reloc_code_real = 297;
pub const BFD_RELOC_FRV_LABEL16: bfd_reloc_code_real = 296;
pub const BFD_RELOC_FT32_DIFF32: bfd_reloc_code_real = 295;
pub const BFD_RELOC_FT32_15: bfd_reloc_code_real = 294;
pub const BFD_RELOC_FT32_SC1: bfd_reloc_code_real = 293;
pub const BFD_RELOC_FT32_SC0: bfd_reloc_code_real = 292;
pub const BFD_RELOC_FT32_RELAX: bfd_reloc_code_real = 291;
pub const BFD_RELOC_FT32_18: bfd_reloc_code_real = 290;
pub const BFD_RELOC_FT32_17: bfd_reloc_code_real = 289;
pub const BFD_RELOC_FT32_20: bfd_reloc_code_real = 288;
pub const BFD_RELOC_FT32_10: bfd_reloc_code_real = 287;
pub const BFD_RELOC_MOXIE_10_PCREL: bfd_reloc_code_real = 286;
pub const BFD_RELOC_MIPS_JUMP_SLOT: bfd_reloc_code_real = 285;
pub const BFD_RELOC_MIPS_COPY: bfd_reloc_code_real = 284;
pub const BFD_RELOC_MIPS_EH: bfd_reloc_code_real = 283;
pub const BFD_RELOC_MICROMIPS_TLS_TPREL_LO16: bfd_reloc_code_real = 282;
pub const BFD_RELOC_MIPS_TLS_TPREL_LO16: bfd_reloc_code_real = 281;
pub const BFD_RELOC_MICROMIPS_TLS_TPREL_HI16: bfd_reloc_code_real = 280;
pub const BFD_RELOC_MIPS_TLS_TPREL_HI16: bfd_reloc_code_real = 279;
pub const BFD_RELOC_MIPS_TLS_TPREL64: bfd_reloc_code_real = 278;
pub const BFD_RELOC_MIPS_TLS_TPREL32: bfd_reloc_code_real = 277;
pub const BFD_RELOC_MICROMIPS_TLS_GOTTPREL: bfd_reloc_code_real = 276;
pub const BFD_RELOC_MIPS_TLS_GOTTPREL: bfd_reloc_code_real = 275;
pub const BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16: bfd_reloc_code_real = 274;
pub const BFD_RELOC_MIPS_TLS_DTPREL_LO16: bfd_reloc_code_real = 273;
pub const BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16: bfd_reloc_code_real = 272;
pub const BFD_RELOC_MIPS_TLS_DTPREL_HI16: bfd_reloc_code_real = 271;
pub const BFD_RELOC_MICROMIPS_TLS_LDM: bfd_reloc_code_real = 270;
pub const BFD_RELOC_MIPS_TLS_LDM: bfd_reloc_code_real = 269;
pub const BFD_RELOC_MICROMIPS_TLS_GD: bfd_reloc_code_real = 268;
pub const BFD_RELOC_MIPS_TLS_GD: bfd_reloc_code_real = 267;
pub const BFD_RELOC_MIPS_TLS_DTPREL64: bfd_reloc_code_real = 266;
pub const BFD_RELOC_MIPS_TLS_DTPMOD64: bfd_reloc_code_real = 265;
pub const BFD_RELOC_MIPS_TLS_DTPREL32: bfd_reloc_code_real = 264;
pub const BFD_RELOC_MIPS_TLS_DTPMOD32: bfd_reloc_code_real = 263;
pub const BFD_RELOC_MICROMIPS_JALR: bfd_reloc_code_real = 262;
pub const BFD_RELOC_MIPS_JALR: bfd_reloc_code_real = 261;
pub const BFD_RELOC_MIPS_RELGOT: bfd_reloc_code_real = 260;
pub const BFD_RELOC_MIPS_REL16: bfd_reloc_code_real = 259;
pub const BFD_RELOC_MICROMIPS_SCN_DISP: bfd_reloc_code_real = 258;
pub const BFD_RELOC_MIPS_SCN_DISP: bfd_reloc_code_real = 257;
pub const BFD_RELOC_MICROMIPS_HIGHER: bfd_reloc_code_real = 256;
pub const BFD_RELOC_MIPS_HIGHER: bfd_reloc_code_real = 255;
pub const BFD_RELOC_MICROMIPS_HIGHEST: bfd_reloc_code_real = 254;
pub const BFD_RELOC_MIPS_HIGHEST: bfd_reloc_code_real = 253;
pub const BFD_RELOC_MIPS_DELETE: bfd_reloc_code_real = 252;
pub const BFD_RELOC_MIPS_INSERT_B: bfd_reloc_code_real = 251;
pub const BFD_RELOC_MIPS_INSERT_A: bfd_reloc_code_real = 250;
pub const BFD_RELOC_MIPS_SHIFT6: bfd_reloc_code_real = 249;
pub const BFD_RELOC_MIPS_SHIFT5: bfd_reloc_code_real = 248;
pub const BFD_RELOC_MICROMIPS_GOT_DISP: bfd_reloc_code_real = 247;
pub const BFD_RELOC_MIPS_GOT_DISP: bfd_reloc_code_real = 246;
pub const BFD_RELOC_MICROMIPS_GOT_OFST: bfd_reloc_code_real = 245;
pub const BFD_RELOC_MIPS_GOT_OFST: bfd_reloc_code_real = 244;
pub const BFD_RELOC_MICROMIPS_GOT_PAGE: bfd_reloc_code_real = 243;
pub const BFD_RELOC_MIPS_GOT_PAGE: bfd_reloc_code_real = 242;
pub const BFD_RELOC_MICROMIPS_SUB: bfd_reloc_code_real = 241;
pub const BFD_RELOC_MIPS_SUB: bfd_reloc_code_real = 240;
pub const BFD_RELOC_MICROMIPS_CALL_LO16: bfd_reloc_code_real = 239;
pub const BFD_RELOC_MIPS_CALL_LO16: bfd_reloc_code_real = 238;
pub const BFD_RELOC_MICROMIPS_CALL_HI16: bfd_reloc_code_real = 237;
pub const BFD_RELOC_MIPS_CALL_HI16: bfd_reloc_code_real = 236;
pub const BFD_RELOC_MICROMIPS_GOT_LO16: bfd_reloc_code_real = 235;
pub const BFD_RELOC_MIPS_GOT_LO16: bfd_reloc_code_real = 234;
pub const BFD_RELOC_MICROMIPS_GOT_HI16: bfd_reloc_code_real = 233;
pub const BFD_RELOC_MIPS_GOT_HI16: bfd_reloc_code_real = 232;
pub const BFD_RELOC_MICROMIPS_CALL16: bfd_reloc_code_real = 231;
pub const BFD_RELOC_MIPS_CALL16: bfd_reloc_code_real = 230;
pub const BFD_RELOC_MICROMIPS_GOT16: bfd_reloc_code_real = 229;
pub const BFD_RELOC_MIPS_GOT16: bfd_reloc_code_real = 228;
pub const BFD_RELOC_MICROMIPS_LO16: bfd_reloc_code_real = 227;
pub const BFD_RELOC_MICROMIPS_HI16_S: bfd_reloc_code_real = 226;
pub const BFD_RELOC_MICROMIPS_HI16: bfd_reloc_code_real = 225;
pub const BFD_RELOC_MICROMIPS_GPREL16: bfd_reloc_code_real = 224;
pub const BFD_RELOC_MIPS_19_PCREL_S2: bfd_reloc_code_real = 223;
pub const BFD_RELOC_MIPS_18_PCREL_S3: bfd_reloc_code_real = 222;
pub const BFD_RELOC_MIPS_26_PCREL_S2: bfd_reloc_code_real = 221;
pub const BFD_RELOC_MIPS_21_PCREL_S2: bfd_reloc_code_real = 220;
pub const BFD_RELOC_MIPS16_16_PCREL_S1: bfd_reloc_code_real = 219;
pub const BFD_RELOC_MICROMIPS_16_PCREL_S1: bfd_reloc_code_real = 218;
pub const BFD_RELOC_MICROMIPS_10_PCREL_S1: bfd_reloc_code_real = 217;
pub const BFD_RELOC_MICROMIPS_7_PCREL_S1: bfd_reloc_code_real = 216;
pub const BFD_RELOC_MICROMIPS_LITERAL: bfd_reloc_code_real = 215;
pub const BFD_RELOC_MIPS_LITERAL: bfd_reloc_code_real = 214;
pub const BFD_RELOC_MIPS16_TLS_TPREL_LO16: bfd_reloc_code_real = 213;
pub const BFD_RELOC_MIPS16_TLS_TPREL_HI16: bfd_reloc_code_real = 212;
pub const BFD_RELOC_MIPS16_TLS_GOTTPREL: bfd_reloc_code_real = 211;
pub const BFD_RELOC_MIPS16_TLS_DTPREL_LO16: bfd_reloc_code_real = 210;
pub const BFD_RELOC_MIPS16_TLS_DTPREL_HI16: bfd_reloc_code_real = 209;
pub const BFD_RELOC_MIPS16_TLS_LDM: bfd_reloc_code_real = 208;
pub const BFD_RELOC_MIPS16_TLS_GD: bfd_reloc_code_real = 207;
pub const BFD_RELOC_MIPS16_LO16: bfd_reloc_code_real = 206;
pub const BFD_RELOC_MIPS16_HI16_S: bfd_reloc_code_real = 205;
pub const BFD_RELOC_MIPS16_HI16: bfd_reloc_code_real = 204;
pub const BFD_RELOC_MIPS16_CALL16: bfd_reloc_code_real = 203;
pub const BFD_RELOC_MIPS16_GOT16: bfd_reloc_code_real = 202;
pub const BFD_RELOC_LO16_PCREL: bfd_reloc_code_real = 201;
pub const BFD_RELOC_HI16_S_PCREL: bfd_reloc_code_real = 200;
pub const BFD_RELOC_HI16_PCREL: bfd_reloc_code_real = 199;
pub const BFD_RELOC_LO16: bfd_reloc_code_real = 198;
pub const BFD_RELOC_HI16_S: bfd_reloc_code_real = 197;
pub const BFD_RELOC_HI16: bfd_reloc_code_real = 196;
pub const BFD_RELOC_MIPS16_GPREL: bfd_reloc_code_real = 195;
pub const BFD_RELOC_MIPS16_JMP: bfd_reloc_code_real = 194;
pub const BFD_RELOC_MICROMIPS_JMP: bfd_reloc_code_real = 193;
pub const BFD_RELOC_MIPS_JMP: bfd_reloc_code_real = 192;
pub const BFD_RELOC_ALPHA_TPREL16: bfd_reloc_code_real = 191;
pub const BFD_RELOC_ALPHA_TPREL_LO16: bfd_reloc_code_real = 190;
pub const BFD_RELOC_ALPHA_TPREL_HI16: bfd_reloc_code_real = 189;
pub const BFD_RELOC_ALPHA_TPREL64: bfd_reloc_code_real = 188;
pub const BFD_RELOC_ALPHA_GOTTPREL16: bfd_reloc_code_real = 187;
pub const BFD_RELOC_ALPHA_DTPREL16: bfd_reloc_code_real = 186;
pub const BFD_RELOC_ALPHA_DTPREL_LO16: bfd_reloc_code_real = 185;
pub const BFD_RELOC_ALPHA_DTPREL_HI16: bfd_reloc_code_real = 184;
pub const BFD_RELOC_ALPHA_DTPREL64: bfd_reloc_code_real = 183;
pub const BFD_RELOC_ALPHA_GOTDTPREL16: bfd_reloc_code_real = 182;
pub const BFD_RELOC_ALPHA_DTPMOD64: bfd_reloc_code_real = 181;
pub const BFD_RELOC_ALPHA_TLSLDM: bfd_reloc_code_real = 180;
pub const BFD_RELOC_ALPHA_TLSGD: bfd_reloc_code_real = 179;
pub const BFD_RELOC_ALPHA_BOH: bfd_reloc_code_real = 178;
pub const BFD_RELOC_ALPHA_LDA: bfd_reloc_code_real = 177;
pub const BFD_RELOC_ALPHA_BSR: bfd_reloc_code_real = 176;
pub const BFD_RELOC_ALPHA_NOP: bfd_reloc_code_real = 175;
pub const BFD_RELOC_ALPHA_BRSGP: bfd_reloc_code_real = 174;
pub const BFD_RELOC_ALPHA_GPREL_LO16: bfd_reloc_code_real = 173;
pub const BFD_RELOC_ALPHA_GPREL_HI16: bfd_reloc_code_real = 172;
pub const BFD_RELOC_ALPHA_CODEADDR: bfd_reloc_code_real = 171;
pub const BFD_RELOC_ALPHA_LINKAGE: bfd_reloc_code_real = 170;
pub const BFD_RELOC_ALPHA_HINT: bfd_reloc_code_real = 169;
pub const BFD_RELOC_ALPHA_LITUSE: bfd_reloc_code_real = 168;
pub const BFD_RELOC_ALPHA_ELF_LITERAL: bfd_reloc_code_real = 167;
pub const BFD_RELOC_ALPHA_LITERAL: bfd_reloc_code_real = 166;
pub const BFD_RELOC_ALPHA_GPDISP: bfd_reloc_code_real = 165;
pub const BFD_RELOC_ALPHA_GPDISP_LO16: bfd_reloc_code_real = 164;
pub const BFD_RELOC_ALPHA_GPDISP_HI16: bfd_reloc_code_real = 163;
pub const BFD_RELOC_SPU_ADD_PIC: bfd_reloc_code_real = 162;
pub const BFD_RELOC_SPU_PPU64: bfd_reloc_code_real = 161;
pub const BFD_RELOC_SPU_PPU32: bfd_reloc_code_real = 160;
pub const BFD_RELOC_SPU_HI16: bfd_reloc_code_real = 159;
pub const BFD_RELOC_SPU_LO16: bfd_reloc_code_real = 158;
pub const BFD_RELOC_SPU_PCREL16: bfd_reloc_code_real = 157;
pub const BFD_RELOC_SPU_PCREL9b: bfd_reloc_code_real = 156;
pub const BFD_RELOC_SPU_PCREL9a: bfd_reloc_code_real = 155;
pub const BFD_RELOC_SPU_IMM18: bfd_reloc_code_real = 154;
pub const BFD_RELOC_SPU_IMM16W: bfd_reloc_code_real = 153;
pub const BFD_RELOC_SPU_IMM16: bfd_reloc_code_real = 152;
pub const BFD_RELOC_SPU_IMM10W: bfd_reloc_code_real = 151;
pub const BFD_RELOC_SPU_IMM10: bfd_reloc_code_real = 150;
pub const BFD_RELOC_SPU_IMM8: bfd_reloc_code_real = 149;
pub const BFD_RELOC_SPU_IMM7: bfd_reloc_code_real = 148;
pub const BFD_RELOC_SPARC_TLS_TPOFF64: bfd_reloc_code_real = 147;
pub const BFD_RELOC_SPARC_TLS_TPOFF32: bfd_reloc_code_real = 146;
pub const BFD_RELOC_SPARC_TLS_DTPOFF64: bfd_reloc_code_real = 145;
pub const BFD_RELOC_SPARC_TLS_DTPOFF32: bfd_reloc_code_real = 144;
pub const BFD_RELOC_SPARC_TLS_DTPMOD64: bfd_reloc_code_real = 143;
pub const BFD_RELOC_SPARC_TLS_DTPMOD32: bfd_reloc_code_real = 142;
pub const BFD_RELOC_SPARC_TLS_LE_LOX10: bfd_reloc_code_real = 141;
pub const BFD_RELOC_SPARC_TLS_LE_HIX22: bfd_reloc_code_real = 140;
pub const BFD_RELOC_SPARC_TLS_IE_ADD: bfd_reloc_code_real = 139;
pub const BFD_RELOC_SPARC_TLS_IE_LDX: bfd_reloc_code_real = 138;
pub const BFD_RELOC_SPARC_TLS_IE_LD: bfd_reloc_code_real = 137;
pub const BFD_RELOC_SPARC_TLS_IE_LO10: bfd_reloc_code_real = 136;
pub const BFD_RELOC_SPARC_TLS_IE_HI22: bfd_reloc_code_real = 135;
pub const BFD_RELOC_SPARC_TLS_LDO_ADD: bfd_reloc_code_real = 134;
pub const BFD_RELOC_SPARC_TLS_LDO_LOX10: bfd_reloc_code_real = 133;
pub const BFD_RELOC_SPARC_TLS_LDO_HIX22: bfd_reloc_code_real = 132;
pub const BFD_RELOC_SPARC_TLS_LDM_CALL: bfd_reloc_code_real = 131;
pub const BFD_RELOC_SPARC_TLS_LDM_ADD: bfd_reloc_code_real = 130;
pub const BFD_RELOC_SPARC_TLS_LDM_LO10: bfd_reloc_code_real = 129;
pub const BFD_RELOC_SPARC_TLS_LDM_HI22: bfd_reloc_code_real = 128;
pub const BFD_RELOC_SPARC_TLS_GD_CALL: bfd_reloc_code_real = 127;
pub const BFD_RELOC_SPARC_TLS_GD_ADD: bfd_reloc_code_real = 126;
pub const BFD_RELOC_SPARC_TLS_GD_LO10: bfd_reloc_code_real = 125;
pub const BFD_RELOC_SPARC_TLS_GD_HI22: bfd_reloc_code_real = 124;
pub const BFD_RELOC_SPARC_REV32: bfd_reloc_code_real = 123;
pub const BFD_RELOC_SPARC_WDISP10: bfd_reloc_code_real = 122;
pub const BFD_RELOC_SPARC_SIZE64: bfd_reloc_code_real = 121;
pub const BFD_RELOC_SPARC_SIZE32: bfd_reloc_code_real = 120;
pub const BFD_RELOC_SPARC_H34: bfd_reloc_code_real = 119;
pub const BFD_RELOC_SPARC_REGISTER: bfd_reloc_code_real = 118;
pub const BFD_RELOC_SPARC_L44: bfd_reloc_code_real = 117;
pub const BFD_RELOC_SPARC_M44: bfd_reloc_code_real = 116;
pub const BFD_RELOC_SPARC_H44: bfd_reloc_code_real = 115;
pub const BFD_RELOC_SPARC_LOX10: bfd_reloc_code_real = 114;
pub const BFD_RELOC_SPARC_HIX22: bfd_reloc_code_real = 113;
pub const BFD_RELOC_SPARC_PLT64: bfd_reloc_code_real = 112;
pub const BFD_RELOC_SPARC_PLT32: bfd_reloc_code_real = 111;
pub const BFD_RELOC_SPARC_5: bfd_reloc_code_real = 110;
pub const BFD_RELOC_SPARC_6: bfd_reloc_code_real = 109;
pub const BFD_RELOC_SPARC_7: bfd_reloc_code_real = 108;
pub const BFD_RELOC_SPARC_WDISP19: bfd_reloc_code_real = 107;
pub const BFD_RELOC_SPARC_WDISP16: bfd_reloc_code_real = 106;
pub const BFD_RELOC_SPARC_PC_LM22: bfd_reloc_code_real = 105;
pub const BFD_RELOC_SPARC_PC_HM10: bfd_reloc_code_real = 104;
pub const BFD_RELOC_SPARC_PC_HH22: bfd_reloc_code_real = 103;
pub const BFD_RELOC_SPARC_LM22: bfd_reloc_code_real = 102;
pub const BFD_RELOC_SPARC_HM10: bfd_reloc_code_real = 101;
pub const BFD_RELOC_SPARC_HH22: bfd_reloc_code_real = 100;
pub const BFD_RELOC_SPARC_OLO10: bfd_reloc_code_real = 99;
pub const BFD_RELOC_SPARC_11: bfd_reloc_code_real = 98;
pub const BFD_RELOC_SPARC_10: bfd_reloc_code_real = 97;
pub const BFD_RELOC_SPARC_BASE22: bfd_reloc_code_real = 96;
pub const BFD_RELOC_SPARC_BASE13: bfd_reloc_code_real = 95;
pub const BFD_RELOC_SPARC_IRELATIVE: bfd_reloc_code_real = 94;
pub const BFD_RELOC_SPARC_JMP_IREL: bfd_reloc_code_real = 93;
pub const BFD_RELOC_SPARC_GOTDATA_OP: bfd_reloc_code_real = 92;
pub const BFD_RELOC_SPARC_GOTDATA_OP_LOX10: bfd_reloc_code_real = 91;
pub const BFD_RELOC_SPARC_GOTDATA_OP_HIX22: bfd_reloc_code_real = 90;
pub const BFD_RELOC_SPARC_GOTDATA_LOX10: bfd_reloc_code_real = 89;
pub const BFD_RELOC_SPARC_GOTDATA_HIX22: bfd_reloc_code_real = 88;
pub const BFD_RELOC_SPARC_UA64: bfd_reloc_code_real = 87;
pub const BFD_RELOC_SPARC_UA32: bfd_reloc_code_real = 86;
pub const BFD_RELOC_SPARC_UA16: bfd_reloc_code_real = 85;
pub const BFD_RELOC_SPARC_RELATIVE: bfd_reloc_code_real = 84;
pub const BFD_RELOC_SPARC_JMP_SLOT: bfd_reloc_code_real = 83;
pub const BFD_RELOC_SPARC_GLOB_DAT: bfd_reloc_code_real = 82;
pub const BFD_RELOC_SPARC_COPY: bfd_reloc_code_real = 81;
pub const BFD_RELOC_SPARC_WPLT30: bfd_reloc_code_real = 80;
pub const BFD_RELOC_SPARC_PC22: bfd_reloc_code_real = 79;
pub const BFD_RELOC_SPARC_PC10: bfd_reloc_code_real = 78;
pub const BFD_RELOC_SPARC_GOT22: bfd_reloc_code_real = 77;
pub const BFD_RELOC_SPARC_GOT13: bfd_reloc_code_real = 76;
pub const BFD_RELOC_SPARC_GOT10: bfd_reloc_code_real = 75;
pub const BFD_RELOC_SPARC13: bfd_reloc_code_real = 74;
pub const BFD_RELOC_SPARC22: bfd_reloc_code_real = 73;
pub const BFD_RELOC_SPARC_WDISP22: bfd_reloc_code_real = 72;
pub const BFD_RELOC_NONE: bfd_reloc_code_real = 71;
pub const BFD_RELOC_GPREL32: bfd_reloc_code_real = 70;
pub const BFD_RELOC_GPREL16: bfd_reloc_code_real = 69;
pub const BFD_RELOC_LO10: bfd_reloc_code_real = 68;
pub const BFD_RELOC_HI22: bfd_reloc_code_real = 67;
pub const BFD_RELOC_23_PCREL_S2: bfd_reloc_code_real = 66;
pub const BFD_RELOC_16_PCREL_S2: bfd_reloc_code_real = 65;
pub const BFD_RELOC_32_PCREL_S2: bfd_reloc_code_real = 64;
pub const BFD_RELOC_8_FFnn: bfd_reloc_code_real = 63;
pub const BFD_RELOC_RVA: bfd_reloc_code_real = 62;
pub const BFD_RELOC_8_BASEREL: bfd_reloc_code_real = 61;
pub const BFD_RELOC_HI16_S_BASEREL: bfd_reloc_code_real = 60;
pub const BFD_RELOC_HI16_BASEREL: bfd_reloc_code_real = 59;
pub const BFD_RELOC_LO16_BASEREL: bfd_reloc_code_real = 58;
pub const BFD_RELOC_16_BASEREL: bfd_reloc_code_real = 57;
pub const BFD_RELOC_32_BASEREL: bfd_reloc_code_real = 56;
pub const BFD_RELOC_68K_TLS_LE8: bfd_reloc_code_real = 55;
pub const BFD_RELOC_68K_TLS_LE16: bfd_reloc_code_real = 54;
pub const BFD_RELOC_68K_TLS_LE32: bfd_reloc_code_real = 53;
pub const BFD_RELOC_68K_TLS_IE8: bfd_reloc_code_real = 52;
pub const BFD_RELOC_68K_TLS_IE16: bfd_reloc_code_real = 51;
pub const BFD_RELOC_68K_TLS_IE32: bfd_reloc_code_real = 50;
pub const BFD_RELOC_68K_TLS_LDO8: bfd_reloc_code_real = 49;
pub const BFD_RELOC_68K_TLS_LDO16: bfd_reloc_code_real = 48;
pub const BFD_RELOC_68K_TLS_LDO32: bfd_reloc_code_real = 47;
pub const BFD_RELOC_68K_TLS_LDM8: bfd_reloc_code_real = 46;
pub const BFD_RELOC_68K_TLS_LDM16: bfd_reloc_code_real = 45;
pub const BFD_RELOC_68K_TLS_LDM32: bfd_reloc_code_real = 44;
pub const BFD_RELOC_68K_TLS_GD8: bfd_reloc_code_real = 43;
pub const BFD_RELOC_68K_TLS_GD16: bfd_reloc_code_real = 42;
pub const BFD_RELOC_68K_TLS_GD32: bfd_reloc_code_real = 41;
pub const BFD_RELOC_68K_RELATIVE: bfd_reloc_code_real = 40;
pub const BFD_RELOC_68K_JMP_SLOT: bfd_reloc_code_real = 39;
pub const BFD_RELOC_68K_GLOB_DAT: bfd_reloc_code_real = 38;
pub const BFD_RELOC_SIZE64: bfd_reloc_code_real = 37;
pub const BFD_RELOC_SIZE32: bfd_reloc_code_real = 36;
pub const BFD_RELOC_8_PLTOFF: bfd_reloc_code_real = 35;
pub const BFD_RELOC_HI16_S_PLTOFF: bfd_reloc_code_real = 34;
pub const BFD_RELOC_HI16_PLTOFF: bfd_reloc_code_real = 33;
pub const BFD_RELOC_LO16_PLTOFF: bfd_reloc_code_real = 32;
pub const BFD_RELOC_16_PLTOFF: bfd_reloc_code_real = 31;
pub const BFD_RELOC_32_PLTOFF: bfd_reloc_code_real = 30;
pub const BFD_RELOC_64_PLTOFF: bfd_reloc_code_real = 29;
pub const BFD_RELOC_8_PLT_PCREL: bfd_reloc_code_real = 28;
pub const BFD_RELOC_16_PLT_PCREL: bfd_reloc_code_real = 27;
pub const BFD_RELOC_24_PLT_PCREL: bfd_reloc_code_real = 26;
pub const BFD_RELOC_32_PLT_PCREL: bfd_reloc_code_real = 25;
pub const BFD_RELOC_64_PLT_PCREL: bfd_reloc_code_real = 24;
pub const BFD_RELOC_8_GOTOFF: bfd_reloc_code_real = 23;
pub const BFD_RELOC_HI16_S_GOTOFF: bfd_reloc_code_real = 22;
pub const BFD_RELOC_HI16_GOTOFF: bfd_reloc_code_real = 21;
pub const BFD_RELOC_LO16_GOTOFF: bfd_reloc_code_real = 20;
pub const BFD_RELOC_16_GOTOFF: bfd_reloc_code_real = 19;
pub const BFD_RELOC_32_GOTOFF: bfd_reloc_code_real = 18;
pub const BFD_RELOC_8_GOT_PCREL: bfd_reloc_code_real = 17;
pub const BFD_RELOC_16_GOT_PCREL: bfd_reloc_code_real = 16;
pub const BFD_RELOC_32_GOT_PCREL: bfd_reloc_code_real = 15;
pub const BFD_RELOC_32_SECREL: bfd_reloc_code_real = 14;
pub const BFD_RELOC_8_PCREL: bfd_reloc_code_real = 13;
pub const BFD_RELOC_12_PCREL: bfd_reloc_code_real = 12;
pub const BFD_RELOC_16_PCREL: bfd_reloc_code_real = 11;
pub const BFD_RELOC_24_PCREL: bfd_reloc_code_real = 10;
pub const BFD_RELOC_32_PCREL: bfd_reloc_code_real = 9;
pub const BFD_RELOC_64_PCREL: bfd_reloc_code_real = 8;
pub const BFD_RELOC_8: bfd_reloc_code_real = 7;
pub const BFD_RELOC_14: bfd_reloc_code_real = 6;
pub const BFD_RELOC_16: bfd_reloc_code_real = 5;
pub const BFD_RELOC_24: bfd_reloc_code_real = 4;
pub const BFD_RELOC_26: bfd_reloc_code_real = 3;
pub const BFD_RELOC_32: bfd_reloc_code_real = 2;
pub const BFD_RELOC_64: bfd_reloc_code_real = 1;
pub const _dummy_first_bfd_reloc_code_real: bfd_reloc_code_real = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub size: libc::c_uint,
    pub contents: *mut bfd_byte,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub section: *mut asection,
}
pub type bfd_link_order_type = libc::c_uint;
pub const bfd_symbol_reloc_link_order: bfd_link_order_type = 4;
pub const bfd_section_reloc_link_order: bfd_link_order_type = 3;
pub const bfd_data_link_order: bfd_link_order_type = 2;
pub const bfd_indirect_link_order: bfd_link_order_type = 1;
pub const bfd_undefined_link_order: bfd_link_order_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_symbol {
    pub the_bfd: *mut bfd,
    pub name: *const libc::c_char,
    pub value: symvalue,
    pub flags: flagword,
    pub section: *mut bfd_section,
    pub udata: C2RustUnnamed_6,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub p: *mut libc::c_void,
    pub i: bfd_vma,
}
pub type flagword = libc::c_uint;
pub type symvalue = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct relent_chain {
    pub relent: arelent,
    pub next: *mut relent_chain,
}
pub type arelent = reloc_cache_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct reloc_cache_entry {
    pub sym_ptr_ptr: *mut *mut bfd_symbol,
    pub address: bfd_size_type,
    pub addend: bfd_vma,
    pub howto: *const reloc_howto_type,
}
pub type reloc_howto_type = reloc_howto_struct;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct reloc_howto_struct {
    pub type_0: libc::c_uint,
    #[bitfield(name = "size", ty = "libc::c_uint", bits = "0..=2")]
    #[bitfield(name = "bitsize", ty = "libc::c_uint", bits = "3..=9")]
    #[bitfield(name = "rightshift", ty = "libc::c_uint", bits = "10..=15")]
    #[bitfield(name = "bitpos", ty = "libc::c_uint", bits = "16..=21")]
    #[bitfield(name = "complain_on_overflow", ty = "complain_overflow", bits = "22..=23")]
    #[bitfield(name = "negate", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "pc_relative", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "partial_inplace", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "pcrel_offset", ty = "libc::c_uint", bits = "27..=27")]
    pub size_bitsize_rightshift_bitpos_complain_on_overflow_negate_pc_relative_partial_inplace_pcrel_offset: [u8; 4],
    pub src_mask: bfd_vma,
    pub dst_mask: bfd_vma,
    pub special_function: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut arelent,
            *mut bfd_symbol,
            *mut libc::c_void,
            *mut asection,
            *mut bfd,
            *mut *mut libc::c_char,
        ) -> bfd_reloc_status_type,
    >,
    pub name: *const libc::c_char,
}
pub type bfd_reloc_status_type = bfd_reloc_status;
pub type bfd_reloc_status = libc::c_uint;
pub const bfd_reloc_dangerous: bfd_reloc_status = 9;
pub const bfd_reloc_undefined: bfd_reloc_status = 8;
pub const bfd_reloc_other: bfd_reloc_status = 7;
pub const bfd_reloc_notsupported: bfd_reloc_status = 6;
pub const bfd_reloc_continue: bfd_reloc_status = 5;
pub const bfd_reloc_outofrange: bfd_reloc_status = 4;
pub const bfd_reloc_overflow: bfd_reloc_status = 3;
pub const bfd_reloc_ok: bfd_reloc_status = 2;
pub type complain_overflow = libc::c_uint;
pub const complain_overflow_unsigned: complain_overflow = 3;
pub const complain_overflow_signed: complain_overflow = 2;
pub const complain_overflow_bitfield: complain_overflow = 1;
pub const complain_overflow_dont: complain_overflow = 0;
pub type file_ptr = libc::c_long;
pub type alent = lineno_cache_entry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lineno_cache_entry {
    pub line_number: libc::c_uint,
    pub u: C2RustUnnamed_7,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub sym: *mut bfd_symbol,
    pub offset: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct relax_table {
    pub addr: bfd_vma,
    pub size: libc::c_int,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_hash_table {
    pub table: *mut *mut bfd_hash_entry,
    pub newfunc: Option::<
        unsafe extern "C" fn(
            *mut bfd_hash_entry,
            *mut bfd_hash_table,
            *const libc::c_char,
        ) -> *mut bfd_hash_entry,
    >,
    pub memory: *mut libc::c_void,
    pub size: libc::c_uint,
    pub count: libc::c_uint,
    pub entsize: libc::c_uint,
    #[bitfield(name = "frozen", ty = "libc::c_uint", bits = "0..=0")]
    pub frozen: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_hash_entry {
    pub next: *mut bfd_hash_entry,
    pub string: *const libc::c_char,
    pub hash: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_hash_table {
    pub table: bfd_hash_table,
    pub undefs: *mut bfd_link_hash_entry,
    pub undefs_tail: *mut bfd_link_hash_entry,
    pub hash_table_free: Option::<unsafe extern "C" fn(*mut bfd) -> ()>,
    pub type_0: bfd_link_hash_table_type,
}
pub type bfd_link_hash_table_type = libc::c_uint;
pub const bfd_link_elf_hash_table: bfd_link_hash_table_type = 1;
pub const bfd_link_generic_hash_table: bfd_link_hash_table_type = 0;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct bfd_link_hash_entry {
    pub root: bfd_hash_entry,
    #[bitfield(name = "type_0", ty = "bfd_link_hash_type", bits = "0..=7")]
    #[bitfield(name = "non_ir_ref_regular", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "non_ir_ref_dynamic", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "linker_def", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "ldscript_def", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "rel_from_abs", ty = "libc::c_uint", bits = "12..=12")]
    pub type_0_non_ir_ref_regular_non_ir_ref_dynamic_linker_def_ldscript_def_rel_from_abs: [u8; 2],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 6],
    pub u: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub undef: C2RustUnnamed_12,
    pub def: C2RustUnnamed_11,
    pub i: C2RustUnnamed_10,
    pub c: C2RustUnnamed_9,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub next: *mut bfd_link_hash_entry,
    pub p: *mut bfd_link_hash_common_entry,
    pub size: bfd_size_type,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_hash_common_entry {
    pub alignment_power: libc::c_uint,
    pub section: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub next: *mut bfd_link_hash_entry,
    pub link: *mut bfd_link_hash_entry,
    pub warning: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub next: *mut bfd_link_hash_entry,
    pub section: *mut asection,
    pub value: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub next: *mut bfd_link_hash_entry,
    pub abfd: *mut bfd,
}
pub type bfd_link_hash_type = libc::c_uint;
pub const bfd_link_hash_warning: bfd_link_hash_type = 7;
pub const bfd_link_hash_indirect: bfd_link_hash_type = 6;
pub const bfd_link_hash_common: bfd_link_hash_type = 5;
pub const bfd_link_hash_defweak: bfd_link_hash_type = 4;
pub const bfd_link_hash_defined: bfd_link_hash_type = 3;
pub const bfd_link_hash_undefweak: bfd_link_hash_type = 2;
pub const bfd_link_hash_undefined: bfd_link_hash_type = 1;
pub const bfd_link_hash_new: bfd_link_hash_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_callbacks {
    pub add_archive_element: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *const libc::c_char,
            *mut *mut bfd,
        ) -> bool,
    >,
    pub multiple_definition: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub multiple_common: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd,
            bfd_link_hash_type,
            bfd_vma,
        ) -> (),
    >,
    pub add_to_set: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            bfd_reloc_code_real_type,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub constructor: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            bool,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub warning: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub undefined_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
            bool,
        ) -> (),
    >,
    pub reloc_overflow: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *const libc::c_char,
            *const libc::c_char,
            bfd_vma,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub reloc_dangerous: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub unattached_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut bfd,
            *mut asection,
            bfd_vma,
        ) -> (),
    >,
    pub notice: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
            *mut bfd_link_hash_entry,
            *mut bfd,
            *mut asection,
            bfd_vma,
            flagword,
        ) -> bool,
    >,
    pub einfo: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub info: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub minfo: Option::<unsafe extern "C" fn(*const libc::c_char, ...) -> ()>,
    pub override_segment_assignment: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *mut asection,
            *mut asection,
            bool,
        ) -> bool,
    >,
    pub examine_strtab: Option::<unsafe extern "C" fn(*mut elf_strtab_hash) -> ()>,
    pub ctf_new_symbol: Option::<
        unsafe extern "C" fn(libc::c_int, *mut elf_internal_sym) -> (),
    >,
    pub ctf_new_dynsym: Option::<
        unsafe extern "C" fn(libc::c_int, *mut elf_internal_sym) -> (),
    >,
    pub emit_ctf: Option::<unsafe extern "C" fn() -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_sym {
    pub st_value: bfd_vma,
    pub st_size: bfd_vma,
    pub st_name: libc::c_ulong,
    pub st_info: libc::c_uchar,
    pub st_other: libc::c_uchar,
    pub st_target_internal: libc::c_uchar,
    pub st_shndx: libc::c_uint,
}
pub type bfd_signed_vma = libc::c_long;
pub type compressed_debug_section_type = libc::c_uint;
pub const COMPRESS_DEBUG_GABI_ZLIB: compressed_debug_section_type = 5;
pub const COMPRESS_DEBUG_GNU_ZLIB: compressed_debug_section_type = 3;
pub const COMPRESS_DEBUG: compressed_debug_section_type = 1;
pub const COMPRESS_DEBUG_NONE: compressed_debug_section_type = 0;
pub type textrel_check_method = libc::c_uint;
pub const textrel_check_error: textrel_check_method = 2;
pub const textrel_check_warning: textrel_check_method = 1;
pub const textrel_check_none: textrel_check_method = 0;
pub type report_method = libc::c_uint;
pub const RM_DIAGNOSE: report_method = 2;
pub const RM_IGNORE: report_method = 1;
pub const RM_NOT_YET_SET: report_method = 0;
pub type bfd_link_common_skip_ar_symbols = libc::c_uint;
pub const bfd_link_common_skip_all: bfd_link_common_skip_ar_symbols = 3;
pub const bfd_link_common_skip_data: bfd_link_common_skip_ar_symbols = 2;
pub const bfd_link_common_skip_text: bfd_link_common_skip_ar_symbols = 1;
pub const bfd_link_common_skip_none: bfd_link_common_skip_ar_symbols = 0;
pub type bfd_link_elf_stt_common = libc::c_uint;
pub const no_elf_stt_common: bfd_link_elf_stt_common = 2;
pub const elf_stt_common: bfd_link_elf_stt_common = 1;
pub const unchanged: bfd_link_elf_stt_common = 0;
pub type bfd_link_discard = libc::c_uint;
pub const discard_all: bfd_link_discard = 3;
pub const discard_l: bfd_link_discard = 2;
pub const discard_none: bfd_link_discard = 1;
pub const discard_sec_merge: bfd_link_discard = 0;
pub type bfd_link_strip = libc::c_uint;
pub const strip_all: bfd_link_strip = 3;
pub const strip_some: bfd_link_strip = 2;
pub const strip_debugger: bfd_link_strip = 1;
pub const strip_none: bfd_link_strip = 0;
pub type output_type = libc::c_uint;
pub const type_dll: output_type = 3;
pub const type_relocatable: output_type = 2;
pub const type_pie: output_type = 1;
pub const type_pde: output_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub after_write_object_contents: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub style: *const libc::c_char,
    pub sec: *mut asection,
}
pub type asymbol = bfd_symbol;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_segment_map {
    pub next: *mut elf_segment_map,
    pub p_type: libc::c_ulong,
    pub p_flags: libc::c_ulong,
    pub p_paddr: bfd_vma,
    pub p_vaddr_offset: bfd_vma,
    pub p_align: bfd_vma,
    pub p_size: bfd_vma,
    #[bitfield(name = "p_flags_valid", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "p_paddr_valid", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "p_align_valid", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "p_size_valid", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "includes_filehdr", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "includes_phdrs", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "no_sort_lma", ty = "libc::c_uint", bits = "6..=6")]
    pub p_flags_valid_p_paddr_valid_p_align_valid_p_size_valid_includes_filehdr_includes_phdrs_no_sort_lma: [u8; 1],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 3],
    pub idx: libc::c_uint,
    pub count: libc::c_uint,
    pub sections: [*mut asection; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct core_elf_obj_tdata {
    pub signal: libc::c_int,
    pub pid: libc::c_int,
    pub lwpid: libc::c_int,
    pub program: *mut libc::c_char,
    pub command: *mut libc::c_char,
}
pub type elf_gnu_osabi = libc::c_uint;
pub const elf_gnu_osabi_retain: elf_gnu_osabi = 8;
pub const elf_gnu_osabi_unique: elf_gnu_osabi = 4;
pub const elf_gnu_osabi_ifunc: elf_gnu_osabi = 2;
pub const elf_gnu_osabi_mbind: elf_gnu_osabi = 1;
pub type dynamic_lib_link_class = libc::c_uint;
pub const DYN_NO_NEEDED: dynamic_lib_link_class = 8;
pub const DYN_NO_ADD_NEEDED: dynamic_lib_link_class = 4;
pub const DYN_DT_NEEDED: dynamic_lib_link_class = 2;
pub const DYN_AS_NEEDED: dynamic_lib_link_class = 1;
pub const DYN_NORMAL: dynamic_lib_link_class = 0;
pub type elf_target_id = libc::c_uint;
pub const GENERIC_ELF_DATA: elf_target_id = 38;
pub const RISCV_ELF_DATA: elf_target_id = 37;
pub const TILEPRO_ELF_DATA: elf_target_id = 36;
pub const TILEGX_ELF_DATA: elf_target_id = 35;
pub const XTENSA_ELF_DATA: elf_target_id = 34;
pub const X86_64_ELF_DATA: elf_target_id = 33;
pub const TIC6X_ELF_DATA: elf_target_id = 32;
pub const SPU_ELF_DATA: elf_target_id = 31;
pub const SPARC_ELF_DATA: elf_target_id = 30;
pub const SH_ELF_DATA: elf_target_id = 29;
pub const S390_ELF_DATA: elf_target_id = 28;
pub const PRU_ELF_DATA: elf_target_id = 27;
pub const PPC64_ELF_DATA: elf_target_id = 26;
pub const PPC32_ELF_DATA: elf_target_id = 25;
pub const OR1K_ELF_DATA: elf_target_id = 24;
pub const NIOS2_ELF_DATA: elf_target_id = 23;
pub const NDS32_ELF_DATA: elf_target_id = 22;
pub const MN10300_ELF_DATA: elf_target_id = 21;
pub const MIPS_ELF_DATA: elf_target_id = 20;
pub const MICROBLAZE_ELF_DATA: elf_target_id = 19;
pub const METAG_ELF_DATA: elf_target_id = 18;
pub const M68K_ELF_DATA: elf_target_id = 17;
pub const M68HC11_ELF_DATA: elf_target_id = 16;
pub const M32R_ELF_DATA: elf_target_id = 15;
pub const LM32_ELF_DATA: elf_target_id = 14;
pub const IA64_ELF_DATA: elf_target_id = 13;
pub const I386_ELF_DATA: elf_target_id = 12;
pub const HPPA64_ELF_DATA: elf_target_id = 11;
pub const HPPA32_ELF_DATA: elf_target_id = 10;
pub const FRV_ELF_DATA: elf_target_id = 9;
pub const CSKY_ELF_DATA: elf_target_id = 8;
pub const CRIS_ELF_DATA: elf_target_id = 7;
pub const BFIN_ELF_DATA: elf_target_id = 6;
pub const AVR_ELF_DATA: elf_target_id = 5;
pub const ARM_ELF_DATA: elf_target_id = 4;
pub const ARC_ELF_DATA: elf_target_id = 3;
pub const ALPHA_ELF_DATA: elf_target_id = 2;
pub const AARCH64_ELF_DATA: elf_target_id = 1;
pub type Elf_Internal_Shdr = elf_internal_shdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_shdr {
    pub sh_name: libc::c_uint,
    pub sh_type: libc::c_uint,
    pub sh_flags: bfd_vma,
    pub sh_addr: bfd_vma,
    pub sh_offset: file_ptr,
    pub sh_size: bfd_size_type,
    pub sh_link: libc::c_uint,
    pub sh_info: libc::c_uint,
    pub sh_addralign: bfd_vma,
    pub sh_entsize: bfd_size_type,
    pub bfd_section: *mut asection,
    pub contents: *mut libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sdt_note {
    pub next: *mut sdt_note,
    pub size: bfd_size_type,
    pub data: [bfd_byte; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct obj_attribute_list {
    pub next: *mut obj_attribute_list,
    pub tag: libc::c_uint,
    pub attr: obj_attribute,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct obj_attribute {
    pub type_0: libc::c_int,
    pub i: libc::c_uint,
    pub s: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_property_list {
    pub next: *mut elf_property_list,
    pub property: elf_property,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_property {
    pub pr_type: libc::c_uint,
    pub pr_datasz: libc::c_uint,
    pub u: C2RustUnnamed_14,
    pub pr_kind: elf_property_kind,
}
pub type elf_property_kind = libc::c_uint;
pub const property_number: elf_property_kind = 4;
pub const property_remove: elf_property_kind = 3;
pub const property_corrupt: elf_property_kind = 2;
pub const property_ignored: elf_property_kind = 1;
pub const property_unknown: elf_property_kind = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_14 {
    pub number: bfd_vma,
}
pub type Elf_Internal_Verneed = elf_internal_verneed;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verneed {
    pub vn_version: libc::c_ushort,
    pub vn_cnt: libc::c_ushort,
    pub vn_file: libc::c_ulong,
    pub vn_aux: libc::c_ulong,
    pub vn_next: libc::c_ulong,
    pub vn_bfd: *mut bfd,
    pub vn_filename: *const libc::c_char,
    pub vn_auxptr: *mut elf_internal_vernaux,
    pub vn_nextref: *mut elf_internal_verneed,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_vernaux {
    pub vna_hash: libc::c_ulong,
    pub vna_flags: libc::c_ushort,
    pub vna_other: libc::c_ushort,
    pub vna_name: libc::c_ulong,
    pub vna_next: libc::c_ulong,
    pub vna_nodename: *const libc::c_char,
    pub vna_nextptr: *mut elf_internal_vernaux,
}
pub type Elf_Internal_Verdef = elf_internal_verdef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verdef {
    pub vd_version: libc::c_ushort,
    pub vd_flags: libc::c_ushort,
    pub vd_ndx: libc::c_ushort,
    pub vd_cnt: libc::c_ushort,
    pub vd_hash: libc::c_ulong,
    pub vd_aux: libc::c_ulong,
    pub vd_next: libc::c_ulong,
    pub vd_bfd: *mut bfd,
    pub vd_nodename: *const libc::c_char,
    pub vd_nextdef: *mut elf_internal_verdef,
    pub vd_auxptr: *mut elf_internal_verdaux,
    pub vd_exp_refno: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_verdaux {
    pub vda_name: libc::c_ulong,
    pub vda_next: libc::c_ulong,
    pub vda_nodename: *const libc::c_char,
    pub vda_nextptr: *mut elf_internal_verdaux,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub refcounts: *mut bfd_signed_vma,
    pub offsets: *mut bfd_vma,
    pub ents: *mut *mut got_entry,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_link_hash_entry {
    pub root: bfd_link_hash_entry,
    pub indx: libc::c_long,
    pub dynindx: libc::c_long,
    pub got: gotplt_union,
    pub plt: gotplt_union,
    pub size: bfd_size_type,
    pub dyn_relocs: *mut elf_dyn_relocs,
    #[bitfield(name = "type_0", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "other", ty = "libc::c_uint", bits = "8..=15")]
    #[bitfield(name = "target_internal", ty = "libc::c_uint", bits = "16..=23")]
    #[bitfield(name = "ref_regular", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "def_regular", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "ref_dynamic", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "def_dynamic", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "ref_regular_nonweak", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "ref_ir_nonweak", ty = "libc::c_uint", bits = "29..=29")]
    #[bitfield(name = "dynamic_adjusted", ty = "libc::c_uint", bits = "30..=30")]
    #[bitfield(name = "needs_copy", ty = "libc::c_uint", bits = "31..=31")]
    #[bitfield(name = "needs_plt", ty = "libc::c_uint", bits = "32..=32")]
    #[bitfield(name = "non_elf", ty = "libc::c_uint", bits = "33..=33")]
    #[bitfield(name = "versioned", ty = "elf_symbol_version", bits = "34..=35")]
    #[bitfield(name = "forced_local", ty = "libc::c_uint", bits = "36..=36")]
    #[bitfield(name = "dynamic", ty = "libc::c_uint", bits = "37..=37")]
    #[bitfield(name = "mark", ty = "libc::c_uint", bits = "38..=38")]
    #[bitfield(name = "non_got_ref", ty = "libc::c_uint", bits = "39..=39")]
    #[bitfield(name = "dynamic_def", ty = "libc::c_uint", bits = "40..=40")]
    #[bitfield(name = "ref_dynamic_nonweak", ty = "libc::c_uint", bits = "41..=41")]
    #[bitfield(name = "pointer_equality_needed", ty = "libc::c_uint", bits = "42..=42")]
    #[bitfield(name = "unique_global", ty = "libc::c_uint", bits = "43..=43")]
    #[bitfield(name = "protected_def", ty = "libc::c_uint", bits = "44..=44")]
    #[bitfield(name = "start_stop", ty = "libc::c_uint", bits = "45..=45")]
    #[bitfield(name = "is_weakalias", ty = "libc::c_uint", bits = "46..=46")]
    pub type_0_other_target_internal_ref_regular_def_regular_ref_dynamic_def_dynamic_ref_regular_nonweak_ref_ir_nonweak_dynamic_adjusted_needs_copy_needs_plt_non_elf_versioned_forced_local_dynamic_mark_non_got_ref_dynamic_def_ref_dynamic_nonweak_pointer_equality_needed_unique_global_protected_def_start_stop_is_weakalias: [u8; 6],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 2],
    pub dynstr_index: libc::c_ulong,
    pub u: C2RustUnnamed_18,
    pub verinfo: C2RustUnnamed_17,
    pub u2: C2RustUnnamed_16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_16 {
    pub start_stop_section: *mut asection,
    pub vtable: *mut elf_link_virtual_table_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_virtual_table_entry {
    pub size: size_t,
    pub used: *mut bool,
    pub parent: *mut elf_link_hash_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_17 {
    pub verdef: *mut Elf_Internal_Verdef,
    pub vertree: *mut bfd_elf_version_tree,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_18 {
    pub alias: *mut elf_link_hash_entry,
    pub elf_hash_value: libc::c_ulong,
}
pub type elf_symbol_version = libc::c_uint;
pub const versioned_hidden: elf_symbol_version = 3;
pub const versioned: elf_symbol_version = 2;
pub const unversioned: elf_symbol_version = 1;
pub const unknown: elf_symbol_version = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_dyn_relocs {
    pub next: *mut elf_dyn_relocs,
    pub sec: *mut asection,
    pub count: bfd_size_type,
    pub pc_count: bfd_size_type,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union gotplt_union {
    pub refcount: bfd_signed_vma,
    pub offset: bfd_vma,
    pub glist: *mut got_entry,
    pub plist: *mut plt_entry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_section_list {
    pub hdr: Elf_Internal_Shdr,
    pub ndx: libc::c_uint,
    pub next: *mut elf_section_list,
}
pub type Elf_Internal_Phdr = elf_internal_phdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_phdr {
    pub p_type: libc::c_ulong,
    pub p_flags: libc::c_ulong,
    pub p_offset: bfd_vma,
    pub p_vaddr: bfd_vma,
    pub p_paddr: bfd_vma,
    pub p_filesz: bfd_vma,
    pub p_memsz: bfd_vma,
    pub p_align: bfd_vma,
}
pub type Elf_Internal_Ehdr = elf_internal_ehdr;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_ehdr {
    pub e_ident: [libc::c_uchar; 16],
    pub e_entry: bfd_vma,
    pub e_phoff: bfd_size_type,
    pub e_shoff: bfd_size_type,
    pub e_version: libc::c_ulong,
    pub e_flags: libc::c_ulong,
    pub e_type: libc::c_ushort,
    pub e_machine: libc::c_ushort,
    pub e_ehsize: libc::c_uint,
    pub e_phentsize: libc::c_uint,
    pub e_phnum: libc::c_uint,
    pub e_shentsize: libc::c_uint,
    pub e_shnum: libc::c_uint,
    pub e_shstrndx: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct artdata {
    pub first_file_filepos: file_ptr,
    pub cache: htab_t,
    pub archive_head: *mut bfd,
    pub symdefs: *mut carsym,
    pub symdef_count: symindex,
    pub extended_names: *mut libc::c_char,
    pub extended_names_size: bfd_size_type,
    pub armap_timestamp: libc::c_long,
    pub armap_datepos: file_ptr,
    pub tdata: *mut libc::c_void,
}
pub type symindex = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct carsym {
    pub name: *const libc::c_char,
    pub file_offset: file_ptr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_19 {
    pub next: *mut bfd,
    pub hash: *mut bfd_link_hash_table,
}
pub type ufile_ptr = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_arch_info {
    pub bits_per_word: libc::c_int,
    pub bits_per_address: libc::c_int,
    pub bits_per_byte: libc::c_int,
    pub arch: bfd_architecture,
    pub mach: libc::c_ulong,
    pub arch_name: *const libc::c_char,
    pub printable_name: *const libc::c_char,
    pub section_align_power: libc::c_uint,
    pub the_default: bool,
    pub compatible: Option::<
        unsafe extern "C" fn(
            *const bfd_arch_info,
            *const bfd_arch_info,
        ) -> *const bfd_arch_info,
    >,
    pub scan: Option::<
        unsafe extern "C" fn(*const bfd_arch_info, *const libc::c_char) -> bool,
    >,
    pub fill: Option::<
        unsafe extern "C" fn(bfd_size_type, bool, bool) -> *mut libc::c_void,
    >,
    pub next: *const bfd_arch_info,
    pub max_reloc_offset_into_insn: libc::c_int,
}
pub type bfd_architecture = libc::c_uint;
pub const bfd_arch_last: bfd_architecture = 88;
pub const bfd_arch_csky: bfd_architecture = 87;
pub const bfd_arch_nfp: bfd_architecture = 86;
pub const bfd_arch_pru: bfd_architecture = 85;
pub const bfd_arch_wasm32: bfd_architecture = 84;
pub const bfd_arch_visium: bfd_architecture = 83;
pub const bfd_arch_nios2: bfd_architecture = 82;
pub const bfd_arch_aarch64: bfd_architecture = 81;
pub const bfd_arch_tilegx: bfd_architecture = 80;
pub const bfd_arch_tilepro: bfd_architecture = 79;
pub const bfd_arch_microblaze: bfd_architecture = 78;
pub const bfd_arch_lm32: bfd_architecture = 77;
pub const bfd_arch_z80: bfd_architecture = 76;
pub const bfd_arch_xtensa: bfd_architecture = 75;
pub const bfd_arch_xgate: bfd_architecture = 74;
pub const bfd_arch_xc16x: bfd_architecture = 73;
pub const bfd_arch_msp430: bfd_architecture = 72;
pub const bfd_arch_xstormy16: bfd_architecture = 71;
pub const bfd_arch_mmix: bfd_architecture = 70;
pub const bfd_arch_score: bfd_architecture = 69;
pub const bfd_arch_s390: bfd_architecture = 68;
pub const bfd_arch_rx: bfd_architecture = 67;
pub const bfd_arch_rl78: bfd_architecture = 66;
pub const bfd_arch_riscv: bfd_architecture = 65;
pub const bfd_arch_cris: bfd_architecture = 64;
pub const bfd_arch_crx: bfd_architecture = 63;
pub const bfd_arch_cr16: bfd_architecture = 62;
pub const bfd_arch_bfin: bfd_architecture = 61;
pub const bfd_arch_avr: bfd_architecture = 60;
pub const bfd_arch_pj: bfd_architecture = 59;
pub const bfd_arch_mt: bfd_architecture = 58;
pub const bfd_arch_epiphany: bfd_architecture = 57;
pub const bfd_arch_bpf: bfd_architecture = 56;
pub const bfd_arch_iq2000: bfd_architecture = 55;
pub const bfd_arch_ip2k: bfd_architecture = 54;
pub const bfd_arch_ia64: bfd_architecture = 53;
pub const bfd_arch_metag: bfd_architecture = 52;
pub const bfd_arch_mep: bfd_architecture = 51;
pub const bfd_arch_mcore: bfd_architecture = 50;
pub const bfd_arch_ft32: bfd_architecture = 49;
pub const bfd_arch_moxie: bfd_architecture = 48;
pub const bfd_arch_frv: bfd_architecture = 47;
pub const bfd_arch_fr30: bfd_architecture = 46;
pub const bfd_arch_mn10300: bfd_architecture = 45;
pub const bfd_arch_mn10200: bfd_architecture = 44;
pub const bfd_arch_m32r: bfd_architecture = 43;
pub const bfd_arch_m32c: bfd_architecture = 42;
pub const bfd_arch_arc: bfd_architecture = 41;
pub const bfd_arch_v850_rh850: bfd_architecture = 40;
pub const bfd_arch_v850: bfd_architecture = 39;
pub const bfd_arch_tic6x: bfd_architecture = 38;
pub const bfd_arch_tic54x: bfd_architecture = 37;
pub const bfd_arch_tic4x: bfd_architecture = 36;
pub const bfd_arch_tic30: bfd_architecture = 35;
pub const bfd_arch_ns32k: bfd_architecture = 34;
pub const bfd_arch_nds32: bfd_architecture = 33;
pub const bfd_arch_arm: bfd_architecture = 32;
pub const bfd_arch_alpha: bfd_architecture = 31;
pub const bfd_arch_sh: bfd_architecture = 30;
pub const bfd_arch_z8k: bfd_architecture = 29;
pub const bfd_arch_s12z: bfd_architecture = 28;
pub const bfd_arch_m9s12xg: bfd_architecture = 27;
pub const bfd_arch_m9s12x: bfd_architecture = 26;
pub const bfd_arch_m68hc12: bfd_architecture = 25;
pub const bfd_arch_m68hc11: bfd_architecture = 24;
pub const bfd_arch_dlx: bfd_architecture = 23;
pub const bfd_arch_d30v: bfd_architecture = 22;
pub const bfd_arch_d10v: bfd_architecture = 21;
pub const bfd_arch_hppa: bfd_architecture = 20;
pub const bfd_arch_rs6000: bfd_architecture = 19;
pub const bfd_arch_powerpc: bfd_architecture = 18;
pub const bfd_arch_pdp11: bfd_architecture = 17;
pub const bfd_arch_h8300: bfd_architecture = 16;
pub const bfd_arch_pyramid: bfd_architecture = 15;
pub const bfd_arch_m98k: bfd_architecture = 14;
pub const bfd_arch_convex: bfd_architecture = 13;
pub const bfd_arch_romp: bfd_architecture = 12;
pub const bfd_arch_iamcu: bfd_architecture = 11;
pub const bfd_arch_k1om: bfd_architecture = 10;
pub const bfd_arch_l1om: bfd_architecture = 9;
pub const bfd_arch_i386: bfd_architecture = 8;
pub const bfd_arch_mips: bfd_architecture = 7;
pub const bfd_arch_spu: bfd_architecture = 6;
pub const bfd_arch_sparc: bfd_architecture = 5;
pub const bfd_arch_or1k: bfd_architecture = 4;
pub const bfd_arch_vax: bfd_architecture = 3;
pub const bfd_arch_m68k: bfd_architecture = 2;
pub const bfd_arch_obscure: bfd_architecture = 1;
pub const bfd_arch_unknown: bfd_architecture = 0;
pub type bfd_plugin_format = libc::c_uint;
pub const bfd_plugin_no: bfd_plugin_format = 2;
pub const bfd_plugin_yes: bfd_plugin_format = 1;
pub const bfd_plugin_unknown: bfd_plugin_format = 0;
pub type bfd_direction = libc::c_uint;
pub const both_direction: bfd_direction = 3;
pub const write_direction: bfd_direction = 2;
pub const read_direction: bfd_direction = 1;
pub const no_direction: bfd_direction = 0;
pub type bfd_format = libc::c_uint;
pub const bfd_type_end: bfd_format = 4;
pub const bfd_core: bfd_format = 3;
pub const bfd_archive: bfd_format = 2;
pub const bfd_object: bfd_format = 1;
pub const bfd_unknown: bfd_format = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_iovec {
    pub bread: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void, file_ptr) -> file_ptr,
    >,
    pub bwrite: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_void, file_ptr) -> file_ptr,
    >,
    pub btell: Option::<unsafe extern "C" fn(*mut bfd) -> file_ptr>,
    pub bseek: Option::<
        unsafe extern "C" fn(*mut bfd, file_ptr, libc::c_int) -> libc::c_int,
    >,
    pub bclose: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub bflush: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub bstat: Option::<unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int>,
    pub bmmap: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            bfd_size_type,
            libc::c_int,
            libc::c_int,
            file_ptr,
            *mut *mut libc::c_void,
            *mut bfd_size_type,
        ) -> *mut libc::c_void,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_target {
    pub name: *const libc::c_char,
    pub flavour: bfd_flavour,
    pub byteorder: bfd_endian,
    pub header_byteorder: bfd_endian,
    pub object_flags: flagword,
    pub section_flags: flagword,
    pub symbol_leading_char: libc::c_char,
    pub ar_pad_char: libc::c_char,
    pub ar_max_namelen: libc::c_uchar,
    pub match_priority: libc::c_uchar,
    pub keep_unused_section_symbols: bool,
    pub bfd_getx64: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t>,
    pub bfd_getx_signed_64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
    >,
    pub bfd_putx64: Option::<
        unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
    >,
    pub bfd_getx32: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_getx_signed_32: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_putx32: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_getx16: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_getx_signed_16: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_putx16: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_h_getx64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_uint64_t,
    >,
    pub bfd_h_getx_signed_64: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_int64_t,
    >,
    pub bfd_h_putx64: Option::<
        unsafe extern "C" fn(bfd_uint64_t, *mut libc::c_void) -> (),
    >,
    pub bfd_h_getx32: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_h_getx_signed_32: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_h_putx32: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub bfd_h_getx16: Option::<unsafe extern "C" fn(*const libc::c_void) -> bfd_vma>,
    pub bfd_h_getx_signed_16: Option::<
        unsafe extern "C" fn(*const libc::c_void) -> bfd_signed_vma,
    >,
    pub bfd_h_putx16: Option::<unsafe extern "C" fn(bfd_vma, *mut libc::c_void) -> ()>,
    pub _bfd_check_format: [Option::<unsafe extern "C" fn(*mut bfd) -> bfd_cleanup>; 4],
    pub _bfd_set_format: [Option::<unsafe extern "C" fn(*mut bfd) -> bool>; 4],
    pub _bfd_write_contents: [Option::<unsafe extern "C" fn(*mut bfd) -> bool>; 4],
    pub _close_and_cleanup: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_free_cached_info: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _new_section_hook: Option::<unsafe extern "C" fn(*mut bfd, sec_ptr) -> bool>,
    pub _bfd_get_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut libc::c_void,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_get_section_contents_in_window: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut bfd_window,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_copy_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _bfd_merge_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_init_private_section_data: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut bfd,
            sec_ptr,
            *mut bfd_link_info,
        ) -> bool,
    >,
    pub _bfd_copy_private_section_data: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr, *mut bfd, sec_ptr) -> bool,
    >,
    pub _bfd_copy_private_symbol_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol, *mut bfd, *mut asymbol) -> bool,
    >,
    pub _bfd_copy_private_header_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _bfd_set_private_flags: Option::<
        unsafe extern "C" fn(*mut bfd, flagword) -> bool,
    >,
    pub _bfd_print_private_bfd_data: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void) -> bool,
    >,
    pub _core_file_failing_command: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut libc::c_char,
    >,
    pub _core_file_failing_signal: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_int,
    >,
    pub _core_file_matches_executable_p: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool,
    >,
    pub _core_file_pid: Option::<unsafe extern "C" fn(*mut bfd) -> libc::c_int>,
    pub _bfd_slurp_armap: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_slurp_extended_name_table: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_construct_extended_name_table: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut libc::c_char,
            *mut bfd_size_type,
            *mut *const libc::c_char,
        ) -> bool,
    >,
    pub _bfd_truncate_arname: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char, *mut libc::c_char) -> (),
    >,
    pub write_armap: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_uint,
            *mut orl,
            libc::c_uint,
            libc::c_int,
        ) -> bool,
    >,
    pub _bfd_read_ar_hdr_fn: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut libc::c_void,
    >,
    pub _bfd_write_ar_hdr_fn: Option::<unsafe extern "C" fn(*mut bfd, *mut bfd) -> bool>,
    pub openr_next_archived_file: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd) -> *mut bfd,
    >,
    pub _bfd_get_elt_at_index: Option::<
        unsafe extern "C" fn(*mut bfd, symindex) -> *mut bfd,
    >,
    pub _bfd_stat_arch_elt: Option::<
        unsafe extern "C" fn(*mut bfd, *mut stat) -> libc::c_int,
    >,
    pub _bfd_update_armap_timestamp: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub _bfd_get_symtab_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_symtab: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut bfd_symbol) -> libc::c_long,
    >,
    pub _bfd_make_empty_symbol: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut bfd_symbol,
    >,
    pub _bfd_print_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            *mut bfd_symbol,
            bfd_print_symbol_type,
        ) -> (),
    >,
    pub _bfd_get_symbol_info: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_symbol, *mut symbol_info) -> (),
    >,
    pub _bfd_get_symbol_version_string: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_symbol,
            bool,
            *mut bool,
        ) -> *const libc::c_char,
    >,
    pub _bfd_is_local_label_name: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> bool,
    >,
    pub _bfd_is_target_special_symbol: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
    >,
    pub _get_lineno: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_symbol) -> *mut alent,
    >,
    pub _bfd_find_nearest_line: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut bfd_symbol,
            *mut bfd_section,
            bfd_vma,
            *mut *const libc::c_char,
            *mut *const libc::c_char,
            *mut libc::c_uint,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_find_line: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut bfd_symbol,
            *mut bfd_symbol,
            *mut *const libc::c_char,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_find_inliner_info: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *const libc::c_char,
            *mut *const libc::c_char,
            *mut libc::c_uint,
        ) -> bool,
    >,
    pub _bfd_make_debug_symbol: Option::<
        unsafe extern "C" fn(*mut bfd, *mut libc::c_void, libc::c_ulong) -> *mut asymbol,
    >,
    pub _read_minisymbols: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bool,
            *mut *mut libc::c_void,
            *mut libc::c_uint,
        ) -> libc::c_long,
    >,
    pub _minisymbol_to_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bool,
            *const libc::c_void,
            *mut asymbol,
        ) -> *mut asymbol,
    >,
    pub _get_reloc_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr) -> libc::c_long,
    >,
    pub _bfd_canonicalize_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *mut *mut arelent,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub _bfd_set_reloc: Option::<
        unsafe extern "C" fn(*mut bfd, sec_ptr, *mut *mut arelent, libc::c_uint) -> (),
    >,
    pub reloc_type_lookup: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bfd_reloc_code_real_type,
        ) -> *const reloc_howto_type,
    >,
    pub reloc_name_lookup: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> *const reloc_howto_type,
    >,
    pub _bfd_set_arch_mach: Option::<
        unsafe extern "C" fn(*mut bfd, bfd_architecture, libc::c_ulong) -> bool,
    >,
    pub _bfd_set_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            sec_ptr,
            *const libc::c_void,
            file_ptr,
            bfd_size_type,
        ) -> bool,
    >,
    pub _bfd_sizeof_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
    >,
    pub _bfd_get_relocated_section_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_order,
            *mut bfd_byte,
            bool,
            *mut *mut bfd_symbol,
        ) -> *mut bfd_byte,
    >,
    pub _bfd_relax_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_section,
            *mut bfd_link_info,
            *mut bool,
        ) -> bool,
    >,
    pub _bfd_link_hash_table_create: Option::<
        unsafe extern "C" fn(*mut bfd) -> *mut bfd_link_hash_table,
    >,
    pub _bfd_link_add_symbols: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_link_just_syms: Option::<
        unsafe extern "C" fn(*mut asection, *mut bfd_link_info) -> (),
    >,
    pub _bfd_copy_link_hash_symbol_type: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_hash_entry,
            *mut bfd_link_hash_entry,
        ) -> (),
    >,
    pub _bfd_final_link: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_link_split_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
    >,
    pub _bfd_link_check_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_gc_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_lookup_section_flags: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut flag_info, *mut asection) -> bool,
    >,
    pub _bfd_merge_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_is_group_section: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_section) -> bool,
    >,
    pub _bfd_group_name: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_section) -> *const libc::c_char,
    >,
    pub _bfd_discard_group: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_section) -> bool,
    >,
    pub _section_already_linked: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut bfd_link_info) -> bool,
    >,
    pub _bfd_define_common_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
        ) -> bool,
    >,
    pub _bfd_link_hide_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd_link_hash_entry,
        ) -> (),
    >,
    pub _bfd_define_start_stop: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut asection,
        ) -> *mut bfd_link_hash_entry,
    >,
    pub _bfd_get_dynamic_symtab_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_dynamic_symtab: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut bfd_symbol) -> libc::c_long,
    >,
    pub _bfd_get_synthetic_symtab: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_long,
            *mut *mut bfd_symbol,
            libc::c_long,
            *mut *mut bfd_symbol,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub _bfd_get_dynamic_reloc_upper_bound: Option::<
        unsafe extern "C" fn(*mut bfd) -> libc::c_long,
    >,
    pub _bfd_canonicalize_dynamic_reloc: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut *mut arelent,
            *mut *mut bfd_symbol,
        ) -> libc::c_long,
    >,
    pub alternative_target: *const bfd_target,
    pub backend_data: *const libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct flag_info {
    pub only_with_flags: flagword,
    pub not_with_flags: flagword,
    pub flag_list: *mut flag_info_list,
    pub flags_initialized: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct flag_info_list {
    pub with: flag_type,
    pub name: *const libc::c_char,
    pub valid: bool,
    pub next: *mut flag_info_list,
}
pub type flag_type = libc::c_uint;
pub const without_flags: flag_type = 1;
pub const with_flags: flag_type = 0;
pub type sec_ptr = *mut bfd_section;
pub type symbol_info = _symbol_info;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _symbol_info {
    pub value: symvalue,
    pub type_0: libc::c_char,
    pub name: *const libc::c_char,
    pub stab_type: libc::c_uchar,
    pub stab_other: libc::c_char,
    pub stab_desc: libc::c_short,
    pub stab_name: *const libc::c_char,
}
pub type bfd_print_symbol_type = bfd_print_symbol;
pub type bfd_print_symbol = libc::c_uint;
pub const bfd_print_symbol_all: bfd_print_symbol = 2;
pub const bfd_print_symbol_more: bfd_print_symbol = 1;
pub const bfd_print_symbol_name: bfd_print_symbol = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct orl {
    pub name: *mut *mut libc::c_char,
    pub u: C2RustUnnamed_20,
    pub namidx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_20 {
    pub pos: file_ptr,
    pub abfd: *mut bfd,
}
pub type bfd_window = _bfd_window;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _bfd_window {
    pub data: *mut libc::c_void,
    pub size: bfd_size_type,
    pub i: *mut _bfd_window_internal,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct _bfd_window_internal {
    pub next: *mut _bfd_window_internal,
    pub data: *mut libc::c_void,
    pub size: bfd_size_type,
    #[bitfield(name = "refcount", ty = "libc::c_int", bits = "0..=30")]
    #[bitfield(name = "mapped", ty = "libc::c_uint", bits = "31..=31")]
    pub refcount_mapped: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
pub type bfd_cleanup = Option::<unsafe extern "C" fn(*mut bfd) -> ()>;
pub type bfd_endian = libc::c_uint;
pub const BFD_ENDIAN_UNKNOWN: bfd_endian = 2;
pub const BFD_ENDIAN_LITTLE: bfd_endian = 1;
pub const BFD_ENDIAN_BIG: bfd_endian = 0;
pub type bfd_flavour = libc::c_uint;
pub const bfd_target_sym_flavour: bfd_flavour = 20;
pub const bfd_target_pef_xlib_flavour: bfd_flavour = 19;
pub const bfd_target_pef_flavour: bfd_flavour = 18;
pub const bfd_target_mach_o_flavour: bfd_flavour = 17;
pub const bfd_target_mmo_flavour: bfd_flavour = 16;
pub const bfd_target_evax_flavour: bfd_flavour = 15;
pub const bfd_target_ovax_flavour: bfd_flavour = 14;
pub const bfd_target_msdos_flavour: bfd_flavour = 13;
pub const bfd_target_versados_flavour: bfd_flavour = 12;
pub const bfd_target_os9k_flavour: bfd_flavour = 11;
pub const bfd_target_som_flavour: bfd_flavour = 10;
pub const bfd_target_ihex_flavour: bfd_flavour = 9;
pub const bfd_target_verilog_flavour: bfd_flavour = 8;
pub const bfd_target_srec_flavour: bfd_flavour = 7;
pub const bfd_target_tekhex_flavour: bfd_flavour = 6;
pub const bfd_target_elf_flavour: bfd_flavour = 5;
pub const bfd_target_xcoff_flavour: bfd_flavour = 4;
pub const bfd_target_ecoff_flavour: bfd_flavour = 3;
pub const bfd_target_coff_flavour: bfd_flavour = 2;
pub const bfd_target_aout_flavour: bfd_flavour = 1;
pub const bfd_target_unknown_flavour: bfd_flavour = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stab_info {
    pub strings: *mut bfd_strtab_hash,
    pub includes: bfd_hash_table,
    pub stabstr: *mut bfd_section,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct elf_backend_data {
    pub arch: bfd_architecture,
    pub target_id: elf_target_id,
    pub target_os: elf_target_os,
    pub elf_machine_code: libc::c_int,
    pub elf_osabi: libc::c_int,
    pub maxpagesize: bfd_vma,
    pub minpagesize: bfd_vma,
    pub commonpagesize: bfd_vma,
    pub relropagesize: bfd_vma,
    pub dynamic_sec_flags: flagword,
    pub arch_data: *const libc::c_void,
    pub elf_info_to_howto: Option::<
        unsafe extern "C" fn(*mut bfd, *mut arelent, *mut Elf_Internal_Rela) -> bool,
    >,
    pub elf_info_to_howto_rel: Option::<
        unsafe extern "C" fn(*mut bfd, *mut arelent, *mut Elf_Internal_Rela) -> bool,
    >,
    pub elf_backend_sym_is_global: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> bool,
    >,
    pub elf_backend_object_p: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub elf_backend_symbol_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asymbol) -> (),
    >,
    pub elf_backend_symbol_table_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_symbol_type, libc::c_uint) -> bool,
    >,
    pub elf_backend_get_symbol_type: Option::<
        unsafe extern "C" fn(*mut Elf_Internal_Sym, libc::c_int) -> libc::c_int,
    >,
    pub elf_backend_archive_symbol_lookup: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *const libc::c_char,
        ) -> *mut bfd_link_hash_entry,
    >,
    pub elf_backend_name_local_section_symbols: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_section_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Shdr) -> bool,
    >,
    pub elf_backend_section_from_shdr: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Shdr,
            *const libc::c_char,
            libc::c_int,
        ) -> bool,
    >,
    pub elf_backend_section_flags: Option::<
        unsafe extern "C" fn(*const Elf_Internal_Shdr) -> bool,
    >,
    pub get_sec_type_attr: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection) -> *const bfd_elf_special_section,
    >,
    pub elf_backend_section_from_phdr: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Phdr,
            libc::c_int,
            *const libc::c_char,
        ) -> bool,
    >,
    pub elf_backend_fake_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Shdr, *mut asection) -> bool,
    >,
    pub elf_backend_section_from_bfd_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_int) -> bool,
    >,
    pub elf_add_symbol_hook: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut Elf_Internal_Sym,
            *mut *const libc::c_char,
            *mut flagword,
            *mut *mut asection,
            *mut bfd_vma,
        ) -> bool,
    >,
    pub elf_backend_link_output_symbol_hook: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *const libc::c_char,
            *mut Elf_Internal_Sym,
            *mut asection,
            *mut elf_link_hash_entry,
        ) -> libc::c_int,
    >,
    pub elf_backend_create_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_omit_section_dynsym: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub relocs_compatible: Option::<
        unsafe extern "C" fn(*const bfd_target, *const bfd_target) -> bool,
    >,
    pub check_relocs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            *const Elf_Internal_Rela,
        ) -> bool,
    >,
    pub check_directives: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub notice_as_needed: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            notice_asneeded_action,
        ) -> bool,
    >,
    pub elf_backend_adjust_dynamic_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_always_size_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_size_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_strip_zero_sized_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> bool,
    >,
    pub elf_backend_init_index_section: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
    >,
    pub elf_backend_relocate_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut bfd,
            *mut asection,
            *mut bfd_byte,
            *mut Elf_Internal_Rela,
            *mut Elf_Internal_Sym,
            *mut *mut asection,
        ) -> libc::c_int,
    >,
    pub elf_backend_finish_dynamic_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut Elf_Internal_Sym,
        ) -> bool,
    >,
    pub elf_backend_finish_dynamic_sections: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_begin_write_processing: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> (),
    >,
    pub elf_backend_final_write_processing: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_additional_program_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> libc::c_int,
    >,
    pub elf_backend_modify_segment_map: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_modify_headers: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_allow_non_load_phdr: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Phdr, libc::c_uint) -> bool,
    >,
    pub gc_keep: Option::<unsafe extern "C" fn(*mut bfd_link_info) -> ()>,
    pub gc_mark_dynamic_ref: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, *mut libc::c_void) -> bool,
    >,
    pub gc_mark_hook: elf_gc_mark_hook_fn,
    pub gc_mark_extra_sections: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, elf_gc_mark_hook_fn) -> bool,
    >,
    pub elf_backend_init_file_header: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_print_symbol_all: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_void,
            *mut asymbol,
        ) -> *const libc::c_char,
    >,
    pub elf_backend_output_arch_local_syms: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const libc::c_char,
                    *mut Elf_Internal_Sym,
                    *mut asection,
                    *mut elf_link_hash_entry,
                ) -> libc::c_int,
            >,
        ) -> bool,
    >,
    pub elf_backend_output_arch_syms: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut libc::c_void,
            Option::<
                unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const libc::c_char,
                    *mut Elf_Internal_Sym,
                    *mut asection,
                    *mut elf_link_hash_entry,
                ) -> libc::c_int,
            >,
        ) -> bool,
    >,
    pub elf_backend_filter_implib_symbols: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut *mut asymbol,
            libc::c_long,
        ) -> libc::c_uint,
    >,
    pub elf_backend_copy_indirect_symbol: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut elf_link_hash_entry,
        ) -> (),
    >,
    pub elf_backend_hide_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry, bool) -> (),
    >,
    pub elf_backend_fixup_symbol: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_merge_symbol_attribute: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, libc::c_uint, bool, bool) -> (),
    >,
    pub elf_backend_get_target_dtag: Option::<
        unsafe extern "C" fn(bfd_vma) -> *mut libc::c_char,
    >,
    pub elf_backend_ignore_undef_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
    >,
    pub elf_backend_emit_relocs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut asection,
            *mut Elf_Internal_Shdr,
            *mut Elf_Internal_Rela,
            *mut *mut elf_link_hash_entry,
        ) -> bool,
    >,
    pub elf_backend_update_relocs: Option::<
        unsafe extern "C" fn(*mut asection, *mut bfd_elf_section_reloc_data) -> (),
    >,
    pub elf_backend_count_relocs: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut asection) -> libc::c_uint,
    >,
    pub elf_backend_count_additional_relocs: Option::<
        unsafe extern "C" fn(*mut asection) -> libc::c_uint,
    >,
    pub sort_relocs_p: Option::<unsafe extern "C" fn(*mut asection) -> bool>,
    pub elf_backend_grok_prstatus: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_grok_psinfo: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_grok_freebsd_prstatus: Option::<
        unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool,
    >,
    pub elf_backend_write_core_note: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut libc::c_char,
            *mut libc::c_int,
            libc::c_int,
            ...
        ) -> *mut libc::c_char,
    >,
    pub elf_backend_lookup_section_flags_hook: Option::<
        unsafe extern "C" fn(*mut libc::c_char) -> flagword,
    >,
    pub elf_backend_reloc_type_class: Option::<
        unsafe extern "C" fn(
            *const bfd_link_info,
            *const asection,
            *const Elf_Internal_Rela,
        ) -> elf_reloc_type_class,
    >,
    pub elf_backend_discard_info: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_reloc_cookie, *mut bfd_link_info) -> bool,
    >,
    pub elf_backend_ignore_discarded_relocs: Option::<
        unsafe extern "C" fn(*mut asection) -> bool,
    >,
    pub action_discarded: Option::<unsafe extern "C" fn(*mut asection) -> libc::c_uint>,
    pub elf_backend_eh_frame_address_size: Option::<
        unsafe extern "C" fn(*mut bfd, *const asection) -> libc::c_uint,
    >,
    pub elf_backend_can_make_relative_eh_frame: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub elf_backend_can_make_lsda_relative_eh_frame: Option::<
        unsafe extern "C" fn(*mut bfd, *mut bfd_link_info, *mut asection) -> bool,
    >,
    pub elf_backend_encode_eh_address: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            bfd_vma,
            *mut asection,
            bfd_vma,
            *mut bfd_vma,
        ) -> bfd_byte,
    >,
    pub elf_backend_write_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut asection,
            *mut bfd_byte,
        ) -> bool,
    >,
    pub elf_backend_elfsym_local_is_section: Option::<
        unsafe extern "C" fn(*mut bfd) -> bool,
    >,
    pub elf_backend_mips_irix_compat: Option::<
        unsafe extern "C" fn(*mut bfd) -> irix_compat_t,
    >,
    pub elf_backend_mips_rtype_to_howto: Option::<
        unsafe extern "C" fn(*mut bfd, libc::c_uint, bool) -> *const reloc_howto_type,
    >,
    pub elf_backend_ecoff_debug_swap: *const ecoff_debug_swap,
    pub elf_backend_bfd_from_remote_memory: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            bfd_vma,
            bfd_size_type,
            *mut bfd_vma,
            Option::<
                unsafe extern "C" fn(
                    bfd_vma,
                    *mut bfd_byte,
                    bfd_size_type,
                ) -> libc::c_int,
            >,
        ) -> *mut bfd,
    >,
    pub elf_backend_core_find_build_id: Option::<
        unsafe extern "C" fn(*mut bfd, bfd_vma) -> bool,
    >,
    pub plt_sym_val: Option::<
        unsafe extern "C" fn(bfd_vma, *const asection, *const arelent) -> bfd_vma,
    >,
    pub common_definition: Option::<unsafe extern "C" fn(*mut Elf_Internal_Sym) -> bool>,
    pub common_section_index: Option::<
        unsafe extern "C" fn(*mut asection) -> libc::c_uint,
    >,
    pub common_section: Option::<unsafe extern "C" fn(*mut asection) -> *mut asection>,
    pub merge_symbol: Option::<
        unsafe extern "C" fn(
            *mut elf_link_hash_entry,
            *const Elf_Internal_Sym,
            *mut *mut asection,
            bool,
            bool,
            *mut bfd,
            *const asection,
        ) -> bool,
    >,
    pub elf_hash_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry) -> bool,
    >,
    pub record_xhash_symbol: Option::<
        unsafe extern "C" fn(*mut elf_link_hash_entry, bfd_vma) -> (),
    >,
    pub is_function_type: Option::<unsafe extern "C" fn(libc::c_uint) -> bool>,
    pub maybe_function_sym: Option::<
        unsafe extern "C" fn(
            *const asymbol,
            *mut asection,
            *mut bfd_vma,
        ) -> bfd_size_type,
    >,
    pub get_reloc_section: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_char) -> *mut asection,
    >,
    pub elf_backend_copy_special_section_fields: Option::<
        unsafe extern "C" fn(
            *const bfd,
            *mut bfd,
            *const Elf_Internal_Shdr,
            *mut Elf_Internal_Shdr,
        ) -> bool,
    >,
    pub link_order_error_handler: Option::<
        unsafe extern "C" fn(*const libc::c_char, ...) -> (),
    >,
    pub relplt_name: *const libc::c_char,
    pub elf_machine_alt1: libc::c_int,
    pub elf_machine_alt2: libc::c_int,
    pub s: *const elf_size_info,
    pub special_sections: *const bfd_elf_special_section,
    pub got_header_size: bfd_vma,
    pub got_elt_size: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut bfd_link_info,
            *mut elf_link_hash_entry,
            *mut bfd,
            libc::c_ulong,
        ) -> bfd_vma,
    >,
    pub obj_attrs_vendor: *const libc::c_char,
    pub obj_attrs_section: *const libc::c_char,
    pub obj_attrs_arg_type: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub obj_attrs_section_type: libc::c_uint,
    pub obj_attrs_order: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub obj_attrs_handle_unknown: Option::<
        unsafe extern "C" fn(*mut bfd, libc::c_int) -> bool,
    >,
    pub parse_gnu_properties: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            libc::c_uint,
            *mut bfd_byte,
            libc::c_uint,
        ) -> elf_property_kind,
    >,
    pub merge_gnu_properties: Option::<
        unsafe extern "C" fn(
            *mut bfd_link_info,
            *mut bfd,
            *mut bfd,
            *mut elf_property,
            *mut elf_property,
        ) -> bool,
    >,
    pub setup_gnu_properties: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> *mut bfd,
    >,
    pub fixup_gnu_properties: Option::<
        unsafe extern "C" fn(*mut bfd_link_info, *mut *mut elf_property_list) -> (),
    >,
    pub compact_eh_encoding: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> libc::c_int,
    >,
    pub cant_unwind_opcode: Option::<
        unsafe extern "C" fn(*mut bfd_link_info) -> libc::c_int,
    >,
    pub symbol_section_index: Option::<
        unsafe extern "C" fn(*mut bfd, *mut elf_symbol_type) -> libc::c_uint,
    >,
    pub init_secondary_reloc_section: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *mut Elf_Internal_Shdr,
            *const libc::c_char,
            libc::c_uint,
        ) -> bool,
    >,
    pub slurp_secondary_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut *mut asymbol, bool) -> bool,
    >,
    pub write_secondary_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection) -> bool,
    >,
    pub static_tls_alignment: libc::c_uint,
    pub stack_align: libc::c_uint,
    pub elf_strtab_flags: libc::c_ulong,
    #[bitfield(name = "collect", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "type_change_ok", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "may_use_rel_p", ty = "libc::c_uint", bits = "2..=2")]
    #[bitfield(name = "may_use_rela_p", ty = "libc::c_uint", bits = "3..=3")]
    #[bitfield(name = "default_use_rela_p", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "rela_plts_and_copies_p", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "rela_normal", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "dtrel_excludes_plt", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "sign_extend_vma", ty = "libc::c_uint", bits = "8..=8")]
    #[bitfield(name = "want_got_plt", ty = "libc::c_uint", bits = "9..=9")]
    #[bitfield(name = "plt_readonly", ty = "libc::c_uint", bits = "10..=10")]
    #[bitfield(name = "want_plt_sym", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "plt_not_loaded", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "plt_alignment", ty = "libc::c_uint", bits = "13..=16")]
    #[bitfield(name = "can_gc_sections", ty = "libc::c_uint", bits = "17..=17")]
    #[bitfield(name = "can_refcount", ty = "libc::c_uint", bits = "18..=18")]
    #[bitfield(name = "want_got_sym", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "want_dynbss", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "want_dynrelro", ty = "libc::c_uint", bits = "21..=21")]
    #[bitfield(name = "want_p_paddr_set_to_zero", ty = "libc::c_uint", bits = "22..=22")]
    #[bitfield(name = "no_page_alias", ty = "libc::c_uint", bits = "23..=23")]
    #[bitfield(name = "default_execstack", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "caches_rawsize", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "extern_protected_data", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "always_renumber_dynsyms", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "linux_prpsinfo32_ugid16", ty = "libc::c_uint", bits = "28..=28")]
    #[bitfield(name = "linux_prpsinfo64_ugid16", ty = "libc::c_uint", bits = "29..=29")]
    pub collect_type_change_ok_may_use_rel_p_may_use_rela_p_default_use_rela_p_rela_plts_and_copies_p_rela_normal_dtrel_excludes_plt_sign_extend_vma_want_got_plt_plt_readonly_want_plt_sym_plt_not_loaded_plt_alignment_can_gc_sections_can_refcount_want_got_sym_want_dynbss_want_dynrelro_want_p_paddr_set_to_zero_no_page_alias_default_execstack_caches_rawsize_extern_protected_data_always_renumber_dynsyms_linux_prpsinfo32_ugid16_linux_prpsinfo64_ugid16: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_symbol_type {
    pub symbol: asymbol,
    pub internal_elf_sym: Elf_Internal_Sym,
    pub tc_data: C2RustUnnamed_21,
    pub version: libc::c_ushort,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_21 {
    pub hppa_arg_reloc: libc::c_uint,
    pub mips_extr: *mut libc::c_void,
    pub any: *mut libc::c_void,
}
pub type Elf_Internal_Sym = elf_internal_sym;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_special_section {
    pub prefix: *const libc::c_char,
    pub prefix_length: libc::c_uint,
    pub suffix_length: libc::c_int,
    pub type_0: libc::c_uint,
    pub attr: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_size_info {
    pub sizeof_ehdr: libc::c_uchar,
    pub sizeof_phdr: libc::c_uchar,
    pub sizeof_shdr: libc::c_uchar,
    pub sizeof_rel: libc::c_uchar,
    pub sizeof_rela: libc::c_uchar,
    pub sizeof_sym: libc::c_uchar,
    pub sizeof_dyn: libc::c_uchar,
    pub sizeof_note: libc::c_uchar,
    pub sizeof_hash_entry: libc::c_uchar,
    pub int_rels_per_ext_rel: libc::c_uchar,
    pub arch_size: libc::c_uchar,
    pub log_file_align: libc::c_uchar,
    pub elfclass: libc::c_uchar,
    pub ev_current: libc::c_uchar,
    pub write_out_phdrs: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const Elf_Internal_Phdr,
            libc::c_uint,
        ) -> libc::c_int,
    >,
    pub write_shdrs_and_ehdr: Option::<unsafe extern "C" fn(*mut bfd) -> bool>,
    pub checksum_contents: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            Option::<
                unsafe extern "C" fn(
                    *const libc::c_void,
                    size_t,
                    *mut libc::c_void,
                ) -> (),
            >,
            *mut libc::c_void,
        ) -> bool,
    >,
    pub write_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_void) -> (),
    >,
    pub swap_symbol_in: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const libc::c_void,
            *const libc::c_void,
            *mut Elf_Internal_Sym,
        ) -> bool,
    >,
    pub swap_symbol_out: Option::<
        unsafe extern "C" fn(
            *mut bfd,
            *const Elf_Internal_Sym,
            *mut libc::c_void,
            *mut libc::c_void,
        ) -> (),
    >,
    pub slurp_reloc_table: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut *mut asymbol, bool) -> bool,
    >,
    pub slurp_symbol_table: Option::<
        unsafe extern "C" fn(*mut bfd, *mut *mut asymbol, bool) -> libc::c_long,
    >,
    pub swap_dyn_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const libc::c_void, *mut Elf_Internal_Dyn) -> (),
    >,
    pub swap_dyn_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Dyn, *mut libc::c_void) -> (),
    >,
    pub swap_reloc_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    >,
    pub swap_reloc_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    >,
    pub swap_reloca_in: Option::<
        unsafe extern "C" fn(*mut bfd, *const bfd_byte, *mut Elf_Internal_Rela) -> (),
    >,
    pub swap_reloca_out: Option::<
        unsafe extern "C" fn(*mut bfd, *const Elf_Internal_Rela, *mut bfd_byte) -> (),
    >,
}
pub type Elf_Internal_Rela = elf_internal_rela;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_rela {
    pub r_offset: bfd_vma,
    pub r_info: bfd_vma,
    pub r_addend: bfd_vma,
}
pub type Elf_Internal_Dyn = elf_internal_dyn;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_dyn {
    pub d_tag: bfd_vma,
    pub d_un: C2RustUnnamed_22,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_22 {
    pub d_val: bfd_vma,
    pub d_ptr: bfd_vma,
}
pub type irix_compat_t = libc::c_uint;
pub const ict_irix6: irix_compat_t = 2;
pub const ict_irix5: irix_compat_t = 1;
pub const ict_none: irix_compat_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_reloc_cookie {
    pub rels: *mut Elf_Internal_Rela,
    pub rel: *mut Elf_Internal_Rela,
    pub relend: *mut Elf_Internal_Rela,
    pub locsyms: *mut Elf_Internal_Sym,
    pub abfd: *mut bfd,
    pub locsymcount: size_t,
    pub extsymoff: size_t,
    pub sym_hashes: *mut *mut elf_link_hash_entry,
    pub r_sym_shift: libc::c_int,
    pub bad_symtab: bool,
}
pub type elf_reloc_type_class = libc::c_uint;
pub const reloc_class_plt: elf_reloc_type_class = 4;
pub const reloc_class_ifunc: elf_reloc_type_class = 3;
pub const reloc_class_copy: elf_reloc_type_class = 2;
pub const reloc_class_relative: elf_reloc_type_class = 1;
pub const reloc_class_normal: elf_reloc_type_class = 0;
pub type Elf_Internal_Note = elf_internal_note;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_note {
    pub namesz: libc::c_ulong,
    pub descsz: libc::c_ulong,
    pub type_0: libc::c_ulong,
    pub namedata: *mut libc::c_char,
    pub descdata: *mut libc::c_char,
    pub descpos: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_section_reloc_data {
    pub hdr: *mut Elf_Internal_Shdr,
    pub count: libc::c_uint,
    pub idx: libc::c_int,
    pub hashes: *mut *mut elf_link_hash_entry,
}
pub type elf_gc_mark_hook_fn = Option::<
    unsafe extern "C" fn(
        *mut asection,
        *mut bfd_link_info,
        *mut Elf_Internal_Rela,
        *mut elf_link_hash_entry,
        *mut Elf_Internal_Sym,
    ) -> *mut asection,
>;
pub type notice_asneeded_action = libc::c_uint;
pub const notice_needed: notice_asneeded_action = 2;
pub const notice_not_needed: notice_asneeded_action = 1;
pub const notice_as_needed: notice_asneeded_action = 0;
pub type elf_target_os = libc::c_uint;
pub const is_nacl: elf_target_os = 3;
pub const is_vxworks: elf_target_os = 2;
pub const is_solaris: elf_target_os = 1;
pub const is_normal: elf_target_os = 0;
pub type bfd_error = libc::c_uint;
pub const bfd_error_invalid_error_code: bfd_error = 22;
pub const bfd_error_on_input: bfd_error = 21;
pub const bfd_error_sorry: bfd_error = 20;
pub const bfd_error_file_too_big: bfd_error = 19;
pub const bfd_error_file_truncated: bfd_error = 18;
pub const bfd_error_bad_value: bfd_error = 17;
pub const bfd_error_no_debug_section: bfd_error = 16;
pub const bfd_error_nonrepresentable_section: bfd_error = 15;
pub const bfd_error_no_contents: bfd_error = 14;
pub const bfd_error_file_ambiguously_recognized: bfd_error = 13;
pub const bfd_error_file_not_recognized: bfd_error = 12;
pub const bfd_error_missing_dso: bfd_error = 11;
pub const bfd_error_malformed_archive: bfd_error = 10;
pub const bfd_error_no_more_archived_files: bfd_error = 9;
pub const bfd_error_no_armap: bfd_error = 8;
pub const bfd_error_no_symbols: bfd_error = 7;
pub const bfd_error_no_memory: bfd_error = 6;
pub const bfd_error_invalid_operation: bfd_error = 5;
pub const bfd_error_wrong_object_format: bfd_error = 4;
pub const bfd_error_wrong_format: bfd_error = 3;
pub const bfd_error_invalid_target: bfd_error = 2;
pub const bfd_error_system_call: bfd_error = 1;
pub const bfd_error_no_error: bfd_error = 0;
pub type bfd_error_type = bfd_error;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_debug_section {
    pub uncompressed_name: *const libc::c_char,
    pub compressed_name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Sym_Shndx {
    pub est_shndx: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Note {
    pub namesz: [libc::c_uchar; 4],
    pub descsz: [libc::c_uchar; 4],
    pub type_0: [libc::c_uchar; 4],
    pub name: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verdef {
    pub vd_version: [libc::c_uchar; 2],
    pub vd_flags: [libc::c_uchar; 2],
    pub vd_ndx: [libc::c_uchar; 2],
    pub vd_cnt: [libc::c_uchar; 2],
    pub vd_hash: [libc::c_uchar; 4],
    pub vd_aux: [libc::c_uchar; 4],
    pub vd_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verdaux {
    pub vda_name: [libc::c_uchar; 4],
    pub vda_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Verneed {
    pub vn_version: [libc::c_uchar; 2],
    pub vn_cnt: [libc::c_uchar; 2],
    pub vn_file: [libc::c_uchar; 4],
    pub vn_aux: [libc::c_uchar; 4],
    pub vn_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf_External_Vernaux {
    pub vna_hash: [libc::c_uchar; 4],
    pub vna_flags: [libc::c_uchar; 2],
    pub vna_other: [libc::c_uchar; 2],
    pub vna_name: [libc::c_uchar; 4],
    pub vna_next: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct Elf_External_Versym {
    pub vs_vers: [libc::c_uchar; 2],
}
pub type Elf_Internal_Verdaux = elf_internal_verdaux;
pub type Elf_Internal_Vernaux = elf_internal_vernaux;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_versym {
    pub vs_vers: libc::c_ushort,
}
pub type Elf_Internal_Versym = elf_internal_versym;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_local_dynamic_entry {
    pub next: *mut elf_link_local_dynamic_entry,
    pub input_bfd: *mut bfd,
    pub input_indx: libc::c_long,
    pub dynindx: libc::c_long,
    pub isym: Elf_Internal_Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_loaded_list {
    pub next: *mut elf_link_loaded_list,
    pub abfd: *mut bfd,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct eh_cie_fde {
    pub u: C2RustUnnamed_23,
    pub reloc_index: libc::c_uint,
    pub size: libc::c_uint,
    pub offset: libc::c_uint,
    pub new_offset: libc::c_uint,
    #[bitfield(name = "fde_encoding", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "lsda_encoding", ty = "libc::c_uint", bits = "8..=15")]
    #[bitfield(name = "lsda_offset", ty = "libc::c_uint", bits = "16..=23")]
    #[bitfield(name = "cie", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "removed", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "add_augmentation_size", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "make_relative", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "pad1", ty = "libc::c_uint", bits = "28..=31")]
    pub fde_encoding_lsda_encoding_lsda_offset_cie_removed_add_augmentation_size_make_relative_pad1: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
    pub set_loc: *mut libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_23 {
    pub fde: C2RustUnnamed_26,
    pub cie: C2RustUnnamed_24,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_24 {
    pub u: C2RustUnnamed_25,
    #[bitfield(name = "personality_offset", ty = "libc::c_uint", bits = "0..=7")]
    #[bitfield(name = "aug_str_len", ty = "libc::c_uint", bits = "8..=10")]
    #[bitfield(name = "aug_data_len", ty = "libc::c_uint", bits = "11..=15")]
    #[bitfield(name = "gc_mark", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "make_lsda_relative", ty = "libc::c_uint", bits = "17..=17")]
    #[bitfield(name = "make_per_encoding_relative", ty = "libc::c_uint", bits = "18..=18")]
    #[bitfield(name = "per_encoding_relative", ty = "libc::c_uint", bits = "19..=19")]
    #[bitfield(name = "per_encoding_aligned8", ty = "libc::c_uint", bits = "20..=20")]
    #[bitfield(name = "add_fde_encoding", ty = "libc::c_uint", bits = "21..=21")]
    #[bitfield(name = "merged", ty = "libc::c_uint", bits = "22..=22")]
    #[bitfield(name = "pad1", ty = "libc::c_uint", bits = "23..=31")]
    pub personality_offset_aug_str_len_aug_data_len_gc_mark_make_lsda_relative_make_per_encoding_relative_per_encoding_relative_per_encoding_aligned8_add_fde_encoding_merged_pad1: [u8; 4],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_25 {
    pub full_cie: *mut cie,
    pub merged_with: *mut eh_cie_fde,
    pub sec: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_26 {
    pub cie_inf: *mut eh_cie_fde,
    pub next_for_section: *mut eh_cie_fde,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct eh_frame_array_ent {
    pub initial_loc: bfd_vma,
    pub range: bfd_size_type,
    pub fde: bfd_vma,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_eh_frame_hdr_info {
    pub cies: *mut htab,
    pub fde_count: libc::c_uint,
    pub table: bool,
    pub array: *mut eh_frame_array_ent,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct compact_eh_frame_hdr_info {
    pub allocated_entries: libc::c_uint,
    pub entries: *mut *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct eh_frame_hdr_info {
    pub hdr_sec: *mut asection,
    pub array_count: libc::c_uint,
    pub frame_hdr_is_compact: bool,
    pub u: C2RustUnnamed_27,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_27 {
    pub dwarf: dwarf_eh_frame_hdr_info,
    pub compact: compact_eh_frame_hdr_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_sym_strtab {
    pub sym: Elf_Internal_Sym,
    pub dest_index: libc::c_ulong,
    pub destshndx_index: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_link_needed_list {
    pub next: *mut bfd_link_needed_list,
    pub by: *mut bfd,
    pub name: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sym_cache {
    pub abfd: *mut bfd,
    pub indx: [libc::c_ulong; 32],
    pub sym: [Elf_Internal_Sym; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_link_hash_table {
    pub root: bfd_link_hash_table,
    pub hash_table_id: elf_target_id,
    pub dynamic_sections_created: bool,
    pub dynamic_relocs: bool,
    pub is_relocatable_executable: bool,
    pub ifunc_resolvers: bool,
    pub dt_pltgot_required: bool,
    pub dt_jmprel_required: bool,
    pub dynobj: *mut bfd,
    pub init_got_refcount: gotplt_union,
    pub init_plt_refcount: gotplt_union,
    pub init_got_offset: gotplt_union,
    pub init_plt_offset: gotplt_union,
    pub dynsymcount: bfd_size_type,
    pub local_dynsymcount: bfd_size_type,
    pub dynstr: *mut elf_strtab_hash,
    pub strtabcount: bfd_size_type,
    pub strtabsize: bfd_size_type,
    pub strtab: *mut elf_sym_strtab,
    pub bucketcount: bfd_size_type,
    pub needed: *mut bfd_link_needed_list,
    pub text_index_section: *mut asection,
    pub data_index_section: *mut asection,
    pub hgot: *mut elf_link_hash_entry,
    pub hplt: *mut elf_link_hash_entry,
    pub hdynamic: *mut elf_link_hash_entry,
    pub merge_info: *mut libc::c_void,
    pub stab_info: stab_info,
    pub eh_info: eh_frame_hdr_info,
    pub dynlocal: *mut elf_link_local_dynamic_entry,
    pub runpath: *mut bfd_link_needed_list,
    pub tls_sec: *mut asection,
    pub tls_size: bfd_size_type,
    pub tlsdesc_plt: bfd_vma,
    pub tlsdesc_got: bfd_vma,
    pub target_os: elf_target_os,
    pub dyn_loaded: *mut elf_link_loaded_list,
    pub sym_cache: sym_cache,
    pub sgot: *mut asection,
    pub sgotplt: *mut asection,
    pub srelgot: *mut asection,
    pub splt: *mut asection,
    pub srelplt: *mut asection,
    pub sdynbss: *mut asection,
    pub srelbss: *mut asection,
    pub sdynrelro: *mut asection,
    pub sreldynrelro: *mut asection,
    pub igotplt: *mut asection,
    pub iplt: *mut asection,
    pub irelplt: *mut asection,
    pub irelifunc: *mut asection,
    pub dynsym: *mut asection,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bfd_elf_section_data {
    pub this_hdr: Elf_Internal_Shdr,
    pub section_flag_info: *mut flag_info,
    pub rel: bfd_elf_section_reloc_data,
    pub rela: bfd_elf_section_reloc_data,
    pub this_idx: libc::c_int,
    pub dynindx: libc::c_int,
    pub linked_to: *mut asection,
    pub relocs: *mut Elf_Internal_Rela,
    pub local_dynrel: *mut libc::c_void,
    pub sreloc: *mut asection,
    pub group: C2RustUnnamed_28,
    pub sec_group: *mut asection,
    pub next_in_group: *mut asection,
    pub fde_list: *mut eh_cie_fde,
    pub eh_frame_entry: *mut asection,
    pub has_secondary_relocs: bool,
    pub sec_info: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_28 {
    pub name: *const libc::c_char,
    pub id: *mut bfd_symbol,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lto_section {
    pub major_version: int16_t,
    pub minor_version: int16_t,
    pub slim_object: libc::c_uchar,
    pub flags: uint16_t,
}
pub const compress: C2RustUnnamed_29 = 1;
pub type C2RustUnnamed_29 = libc::c_uint;
pub const decompress: C2RustUnnamed_29 = 2;
pub const nothing: C2RustUnnamed_29 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_30 {
    pub string: *const libc::c_char,
    pub len: size_t,
    pub func: Option::<unsafe extern "C" fn(*mut bfd, *mut Elf_Internal_Note) -> bool>,
}
pub type elfcore_psinfo32_t = prpsinfo32_t;
pub type prpsinfo32_t = elf_prpsinfo32;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_prpsinfo32 {
    pub pr_state: libc::c_char,
    pub pr_sname: libc::c_char,
    pub pr_zomb: libc::c_char,
    pub pr_nice: libc::c_char,
    pub pr_flag: libc::c_uint,
    pub pr_uid: libc::c_ushort,
    pub pr_gid: libc::c_ushort,
    pub pr_pid: libc::c_int,
    pub pr_ppid: libc::c_int,
    pub pr_pgrp: libc::c_int,
    pub pr_sid: libc::c_int,
    pub pr_fname: [libc::c_char; 16],
    pub pr_psargs: [libc::c_char; 80],
}
pub type elfcore_psinfo_t = prpsinfo_t;
pub type prpsinfo_t = elf_prpsinfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_prpsinfo {
    pub pr_state: libc::c_char,
    pub pr_sname: libc::c_char,
    pub pr_zomb: libc::c_char,
    pub pr_nice: libc::c_char,
    pub pr_flag: libc::c_ulong,
    pub pr_uid: __pr_uid_t,
    pub pr_gid: __pr_gid_t,
    pub pr_pid: libc::c_int,
    pub pr_ppid: libc::c_int,
    pub pr_pgrp: libc::c_int,
    pub pr_sid: libc::c_int,
    pub pr_fname: [libc::c_char; 16],
    pub pr_psargs: [libc::c_char; 80],
}
pub type __pr_gid_t = libc::c_uint;
pub type __pr_uid_t = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_31 {
    pub type_name: *const libc::c_char,
    pub min_size: libc::c_ulong,
}
pub type prstatus32_t = elf_prstatus32;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_prstatus32 {
    pub pr_info: elf_siginfo,
    pub pr_cursig: libc::c_short,
    pub pr_sigpend: libc::c_uint,
    pub pr_sighold: libc::c_uint,
    pub pr_pid: pid_t,
    pub pr_ppid: pid_t,
    pub pr_pgrp: pid_t,
    pub pr_sid: pid_t,
    pub pr_utime: prstatus32_timeval,
    pub pr_stime: prstatus32_timeval,
    pub pr_cutime: prstatus32_timeval,
    pub pr_cstime: prstatus32_timeval,
    pub pr_reg: elf_gregset32_t,
    pub pr_fpvalid: libc::c_int,
}
pub type elf_gregset32_t = [elf_greg32_t; 17];
pub type elf_greg32_t = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct prstatus32_timeval {
    pub tv_sec: libc::c_int,
    pub tv_usec: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_siginfo {
    pub si_signo: libc::c_int,
    pub si_code: libc::c_int,
    pub si_errno: libc::c_int,
}
pub type prstatus_t = elf_prstatus;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_prstatus {
    pub pr_info: elf_siginfo,
    pub pr_cursig: libc::c_short,
    pub pr_sigpend: libc::c_ulong,
    pub pr_sighold: libc::c_ulong,
    pub pr_pid: __pid_t,
    pub pr_ppid: __pid_t,
    pub pr_pgrp: __pid_t,
    pub pr_sid: __pid_t,
    pub pr_utime: timeval,
    pub pr_stime: timeval,
    pub pr_cutime: timeval,
    pub pr_cstime: timeval,
    pub pr_reg: elf_gregset_t,
    pub pr_fpvalid: libc::c_int,
}
pub type elf_gregset_t = [elf_greg_t; 27];
pub type elf_greg_t = libc::c_ulonglong;
pub type Elf_Internal_Group = elf_internal_group;
#[derive(Copy, Clone)]
#[repr(C)]
pub union elf_internal_group {
    pub shdr: *mut Elf_Internal_Shdr,
    pub flags: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fake_section_arg {
    pub link_info: *mut bfd_link_info,
    pub failed: bool,
}
pub const _sch_isdigit: C2RustUnnamed_32 = 4;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_internal_linux_prpsinfo {
    pub pr_state: libc::c_char,
    pub pr_sname: libc::c_char,
    pub pr_zomb: libc::c_char,
    pub pr_nice: libc::c_char,
    pub pr_flag: libc::c_ulong,
    pub pr_uid: libc::c_uint,
    pub pr_gid: libc::c_uint,
    pub pr_pid: libc::c_int,
    pub pr_ppid: libc::c_int,
    pub pr_pgrp: libc::c_int,
    pub pr_sid: libc::c_int,
    pub pr_fname: [libc::c_char; 17],
    pub pr_psargs: [libc::c_char; 81],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_external_linux_prpsinfo32_ugid32 {
    pub pr_state: libc::c_char,
    pub pr_sname: libc::c_char,
    pub pr_zomb: libc::c_char,
    pub pr_nice: libc::c_char,
    pub pr_flag: [libc::c_char; 4],
    pub pr_uid: [libc::c_char; 4],
    pub pr_gid: [libc::c_char; 4],
    pub pr_pid: [libc::c_char; 4],
    pub pr_ppid: [libc::c_char; 4],
    pub pr_pgrp: [libc::c_char; 4],
    pub pr_sid: [libc::c_char; 4],
    pub pr_fname: [libc::c_char; 16],
    pub pr_psargs: [libc::c_char; 80],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_external_linux_prpsinfo32_ugid16 {
    pub pr_state: libc::c_char,
    pub pr_sname: libc::c_char,
    pub pr_zomb: libc::c_char,
    pub pr_nice: libc::c_char,
    pub pr_flag: [libc::c_char; 4],
    pub pr_uid: [libc::c_char; 2],
    pub pr_gid: [libc::c_char; 2],
    pub pr_pid: [libc::c_char; 4],
    pub pr_ppid: [libc::c_char; 4],
    pub pr_pgrp: [libc::c_char; 4],
    pub pr_sid: [libc::c_char; 4],
    pub pr_fname: [libc::c_char; 16],
    pub pr_psargs: [libc::c_char; 80],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_external_linux_prpsinfo64_ugid32 {
    pub pr_state: libc::c_char,
    pub pr_sname: libc::c_char,
    pub pr_zomb: libc::c_char,
    pub pr_nice: libc::c_char,
    pub gap: [libc::c_char; 4],
    pub pr_flag: [libc::c_char; 8],
    pub pr_uid: [libc::c_char; 4],
    pub pr_gid: [libc::c_char; 4],
    pub pr_pid: [libc::c_char; 4],
    pub pr_ppid: [libc::c_char; 4],
    pub pr_pgrp: [libc::c_char; 4],
    pub pr_sid: [libc::c_char; 4],
    pub pr_fname: [libc::c_char; 16],
    pub pr_psargs: [libc::c_char; 80],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct elf_external_linux_prpsinfo64_ugid16 {
    pub pr_state: libc::c_char,
    pub pr_sname: libc::c_char,
    pub pr_zomb: libc::c_char,
    pub pr_nice: libc::c_char,
    pub gap: [libc::c_char; 4],
    pub pr_flag: [libc::c_char; 8],
    pub pr_uid: [libc::c_char; 2],
    pub pr_gid: [libc::c_char; 2],
    pub pr_pid: [libc::c_char; 4],
    pub pr_ppid: [libc::c_char; 4],
    pub pr_pgrp: [libc::c_char; 4],
    pub pr_sid: [libc::c_char; 4],
    pub pr_fname: [libc::c_char; 16],
    pub pr_psargs: [libc::c_char; 80],
}
pub type C2RustUnnamed_32 = libc::c_uint;
pub const _sch_isbasic: C2RustUnnamed_32 = 3088;
pub const _sch_iscppsp: C2RustUnnamed_32 = 3072;
pub const _sch_isgraph: C2RustUnnamed_32 = 172;
pub const _sch_isidnum: C2RustUnnamed_32 = 516;
pub const _sch_isalnum: C2RustUnnamed_32 = 140;
pub const _sch_isalpha: C2RustUnnamed_32 = 136;
pub const _sch_isnvsp: C2RustUnnamed_32 = 2048;
pub const _sch_isvsp: C2RustUnnamed_32 = 1024;
pub const _sch_isidst: C2RustUnnamed_32 = 512;
pub const _sch_isxdigit: C2RustUnnamed_32 = 256;
pub const _sch_isupper: C2RustUnnamed_32 = 128;
pub const _sch_isspace: C2RustUnnamed_32 = 64;
pub const _sch_ispunct: C2RustUnnamed_32 = 32;
pub const _sch_isprint: C2RustUnnamed_32 = 16;
pub const _sch_islower: C2RustUnnamed_32 = 8;
pub const _sch_iscntrl: C2RustUnnamed_32 = 2;
pub const _sch_isblank: C2RustUnnamed_32 = 1;
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    return strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_int;
}
#[inline]
unsafe extern "C" fn startswith(
    mut str: *const libc::c_char,
    mut prefix: *const libc::c_char,
) -> bool {
    return strncmp(str, prefix, strlen(prefix)) == 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn bfd_section_name(mut sec: *const asection) -> *const libc::c_char {
    return (*sec).name;
}
#[inline]
unsafe extern "C" fn bfd_section_alignment(mut sec: *const asection) -> libc::c_uint {
    return (*sec).alignment_power;
}
#[inline]
unsafe extern "C" fn bfd_is_com_section(mut sec: *const asection) -> bool {
    return (*sec).flags & 0x1000 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint;
}
#[inline]
unsafe extern "C" fn bfd_set_section_vma(
    mut sec: *mut asection,
    mut val: bfd_vma,
) -> bool {
    (*sec).lma = val;
    (*sec).vma = (*sec).lma;
    (*sec).set_user_set_vma(1 as libc::c_int as libc::c_uint);
    return 1 as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn bfd_set_section_alignment(
    mut sec: *mut asection,
    mut val: libc::c_uint,
) -> bool {
    (*sec).alignment_power = val;
    return 1 as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn bfd_is_und_section(mut sec: *const asection) -> bool {
    return sec
        == &mut *_bfd_std_section.as_mut_ptr().offset(1 as libc::c_int as isize)
            as *mut asection as *const asection;
}
#[inline]
unsafe extern "C" fn bfd_is_abs_section(mut sec: *const asection) -> bool {
    return sec
        == &mut *_bfd_std_section.as_mut_ptr().offset(2 as libc::c_int as isize)
            as *mut asection as *const asection;
}
#[inline]
unsafe extern "C" fn discarded_section(mut sec: *const asection) -> bool {
    return !bfd_is_abs_section(sec)
        && bfd_is_abs_section((*sec).output_section) as libc::c_int != 0
        && (*sec).sec_info_type() as libc::c_int != 2 as libc::c_int
        && (*sec).sec_info_type() as libc::c_int != 4 as libc::c_int;
}
#[inline]
unsafe extern "C" fn bfd_get_format(mut abfd: *const bfd) -> bfd_format {
    return (*abfd).format();
}
#[inline]
unsafe extern "C" fn bfd_get_start_address(mut abfd: *const bfd) -> bfd_vma {
    return (*abfd).start_address;
}
#[inline]
unsafe extern "C" fn bfd_get_symcount(mut abfd: *const bfd) -> libc::c_uint {
    return (*abfd).symcount;
}
#[inline]
unsafe extern "C" fn bfd_get_dynamic_symcount(mut abfd: *const bfd) -> libc::c_uint {
    return (*abfd).dynsymcount;
}
#[inline]
unsafe extern "C" fn bfd_get_outsymbols(mut abfd: *const bfd) -> *mut *mut bfd_symbol {
    return (*abfd).outsymbols;
}
#[inline]
unsafe extern "C" fn bfd_count_sections(mut abfd: *const bfd) -> libc::c_uint {
    return (*abfd).section_count;
}
#[inline]
unsafe extern "C" fn bfd_asymbol_section(mut sy: *const asymbol) -> *mut asection {
    return (*sy).section;
}
#[inline]
unsafe extern "C" fn bfd_asymbol_name(mut sy: *const asymbol) -> *const libc::c_char {
    return (*sy).name;
}
#[inline]
unsafe extern "C" fn bfd_section_list_remove(mut abfd: *mut bfd, mut s: *mut asection) {
    let mut next: *mut asection = (*s).next;
    let mut prev: *mut asection = (*s).prev;
    if !prev.is_null() {
        (*prev).next = next;
    } else {
        (*abfd).sections = next;
    }
    if !next.is_null() {
        (*next).prev = prev;
    } else {
        (*abfd).section_last = prev;
    };
}
#[inline]
unsafe extern "C" fn bfd_get_flavour(mut abfd: *const bfd) -> bfd_flavour {
    return (*(*abfd).xvec).flavour;
}
#[inline]
unsafe extern "C" fn bfd_big_endian(mut abfd: *const bfd) -> bool {
    return (*(*abfd).xvec).byteorder as libc::c_uint
        == BFD_ENDIAN_BIG as libc::c_int as libc::c_uint;
}
#[inline]
unsafe extern "C" fn _bfd_alloc_and_read(
    mut abfd: *mut bfd,
    mut asize: bfd_size_type,
    mut rsize: bfd_size_type,
) -> *mut bfd_byte {
    let mut mem: *mut bfd_byte = 0 as *mut bfd_byte;
    if 0 == 0 {
        let mut filesize: ufile_ptr = bfd_get_file_size(abfd);
        if filesize != 0 as libc::c_int as libc::c_ulong && rsize > filesize {
            bfd_set_error(bfd_error_file_truncated);
            return 0 as *mut bfd_byte;
        }
    }
    mem = bfd_alloc(abfd, asize) as *mut bfd_byte;
    if !mem.is_null() {
        if bfd_bread(mem as *mut libc::c_void, rsize, abfd) == rsize {
            return mem;
        }
        bfd_release(abfd, mem as *mut libc::c_void);
    }
    return 0 as *mut bfd_byte;
}
#[inline]
unsafe extern "C" fn _bfd_malloc_and_read(
    mut abfd: *mut bfd,
    mut asize: bfd_size_type,
    mut rsize: bfd_size_type,
) -> *mut bfd_byte {
    let mut mem: *mut bfd_byte = 0 as *mut bfd_byte;
    if 0 == 0 {
        let mut filesize: ufile_ptr = bfd_get_file_size(abfd);
        if filesize != 0 as libc::c_int as libc::c_ulong && rsize > filesize {
            bfd_set_error(bfd_error_file_truncated);
            return 0 as *mut bfd_byte;
        }
    }
    mem = bfd_malloc(asize) as *mut bfd_byte;
    if !mem.is_null() {
        if bfd_bread(mem as *mut libc::c_void, rsize, abfd) == rsize {
            return mem;
        }
        free(mem as *mut libc::c_void);
    }
    return 0 as *mut bfd_byte;
}
#[inline]
unsafe extern "C" fn is_elf_hash_table(mut htab: *const bfd_link_hash_table) -> bool {
    return (*htab).type_0 as libc::c_uint
        == bfd_link_elf_hash_table as libc::c_int as libc::c_uint;
}
#[inline]
unsafe extern "C" fn elf_link_hash_lookup(
    mut table: *mut elf_link_hash_table,
    mut string: *const libc::c_char,
    mut create: bool,
    mut copy: bool,
    mut follow: bool,
) -> *mut elf_link_hash_entry {
    if 0 as libc::c_int != 0 && !is_elf_hash_table(&mut (*table).root) {
        _bfd_abort(
            b"./elf-bfd.h\0" as *const u8 as *const libc::c_char,
            731 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 114],
                &[libc::c_char; 114],
            >(
                b"struct elf_link_hash_entry *elf_link_hash_lookup(struct elf_link_hash_table *, const char *, _Bool, _Bool, _Bool)\0",
            ))
                .as_ptr(),
        );
    }
    return bfd_link_hash_lookup(&mut (*table).root, string, create, copy, follow)
        as *mut elf_link_hash_entry;
}
#[inline]
unsafe extern "C" fn elf_hash_table(
    mut info: *const bfd_link_info,
) -> *mut elf_link_hash_table {
    return (*info).hash as *mut elf_link_hash_table;
}
#[inline]
unsafe extern "C" fn bfd_section_is_ctf(mut sec: *const asection) -> bool {
    let mut name: *const libc::c_char = bfd_section_name(sec);
    return startswith(name, b".ctf\0" as *const u8 as *const libc::c_char) as libc::c_int
        != 0
        && (*name.offset(4 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
            || *name.offset(4 as libc::c_int as isize) as libc::c_int == '.' as i32);
}
#[inline]
unsafe extern "C" fn swap_linux_prpsinfo32_ugid32_out(
    mut obfd: *mut bfd,
    mut from: *const elf_internal_linux_prpsinfo,
    mut to: *mut elf_external_linux_prpsinfo32_ugid32,
) {
    *(&mut (*to).pr_state as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_state as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_sname as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_sname as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_zomb as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_zomb as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_nice as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_nice as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_flag, ((*to).pr_flag).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_uid as bfd_vma, ((*to).pr_uid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_gid as bfd_vma, ((*to).pr_gid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_pid as bfd_vma, ((*to).pr_pid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_ppid as bfd_vma, ((*to).pr_ppid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_pgrp as bfd_vma, ((*to).pr_pgrp).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_sid as bfd_vma, ((*to).pr_sid).as_mut_ptr() as *mut libc::c_void);
    strncpy(
        ((*to).pr_fname).as_mut_ptr(),
        ((*from).pr_fname).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    strncpy(
        ((*to).pr_psargs).as_mut_ptr(),
        ((*from).pr_psargs).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
    );
}
#[inline]
unsafe extern "C" fn swap_linux_prpsinfo32_ugid16_out(
    mut obfd: *mut bfd,
    mut from: *const elf_internal_linux_prpsinfo,
    mut to: *mut elf_external_linux_prpsinfo32_ugid16,
) {
    *(&mut (*to).pr_state as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_state as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_sname as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_sname as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_zomb as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_zomb as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_nice as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_nice as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_flag, ((*to).pr_flag).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_uid as bfd_vma, ((*to).pr_uid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_gid as bfd_vma, ((*to).pr_gid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_pid as bfd_vma, ((*to).pr_pid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_ppid as bfd_vma, ((*to).pr_ppid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_pgrp as bfd_vma, ((*to).pr_pgrp).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_sid as bfd_vma, ((*to).pr_sid).as_mut_ptr() as *mut libc::c_void);
    strncpy(
        ((*to).pr_fname).as_mut_ptr(),
        ((*from).pr_fname).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    strncpy(
        ((*to).pr_psargs).as_mut_ptr(),
        ((*from).pr_psargs).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
    );
}
#[inline]
unsafe extern "C" fn swap_linux_prpsinfo64_ugid32_out(
    mut obfd: *mut bfd,
    mut from: *const elf_internal_linux_prpsinfo,
    mut to: *mut elf_external_linux_prpsinfo64_ugid32,
) {
    *(&mut (*to).pr_state as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_state as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_sname as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_sname as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_zomb as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_zomb as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_nice as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_nice as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    (Some(((*(*obfd).xvec).bfd_putx64).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_flag, ((*to).pr_flag).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_uid as bfd_vma, ((*to).pr_uid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_gid as bfd_vma, ((*to).pr_gid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_pid as bfd_vma, ((*to).pr_pid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_ppid as bfd_vma, ((*to).pr_ppid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_pgrp as bfd_vma, ((*to).pr_pgrp).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_sid as bfd_vma, ((*to).pr_sid).as_mut_ptr() as *mut libc::c_void);
    strncpy(
        ((*to).pr_fname).as_mut_ptr(),
        ((*from).pr_fname).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    strncpy(
        ((*to).pr_psargs).as_mut_ptr(),
        ((*from).pr_psargs).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
    );
}
#[inline]
unsafe extern "C" fn swap_linux_prpsinfo64_ugid16_out(
    mut obfd: *mut bfd,
    mut from: *const elf_internal_linux_prpsinfo,
    mut to: *mut elf_external_linux_prpsinfo64_ugid16,
) {
    *(&mut (*to).pr_state as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_state as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_sname as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_sname as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_zomb as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_zomb as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    *(&mut (*to).pr_nice as *mut libc::c_char
        as *mut libc::c_uchar) = ((*from).pr_nice as libc::c_int & 0xff as libc::c_int)
        as libc::c_uchar;
    (Some(((*(*obfd).xvec).bfd_putx64).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_flag, ((*to).pr_flag).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_uid as bfd_vma, ((*to).pr_uid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_gid as bfd_vma, ((*to).pr_gid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_pid as bfd_vma, ((*to).pr_pid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_ppid as bfd_vma, ((*to).pr_ppid).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_pgrp as bfd_vma, ((*to).pr_pgrp).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*obfd).xvec).bfd_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*from).pr_sid as bfd_vma, ((*to).pr_sid).as_mut_ptr() as *mut libc::c_void);
    strncpy(
        ((*to).pr_fname).as_mut_ptr(),
        ((*from).pr_fname).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    strncpy(
        ((*to).pr_psargs).as_mut_ptr(),
        ((*from).pr_psargs).as_ptr(),
        ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_verdef_in(
    mut abfd: *mut bfd,
    mut src: *const Elf_External_Verdef,
    mut dst: *mut Elf_Internal_Verdef,
) {
    (*dst)
        .vd_version = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vd_version).as_ptr() as *const libc::c_void) as libc::c_ushort;
    (*dst)
        .vd_flags = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vd_flags).as_ptr() as *const libc::c_void) as libc::c_ushort;
    (*dst)
        .vd_ndx = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vd_ndx).as_ptr() as *const libc::c_void) as libc::c_ushort;
    (*dst)
        .vd_cnt = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vd_cnt).as_ptr() as *const libc::c_void) as libc::c_ushort;
    (*dst)
        .vd_hash = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vd_hash).as_ptr() as *const libc::c_void);
    (*dst)
        .vd_aux = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vd_aux).as_ptr() as *const libc::c_void);
    (*dst)
        .vd_next = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vd_next).as_ptr() as *const libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_verdef_out(
    mut abfd: *mut bfd,
    mut src: *const Elf_Internal_Verdef,
    mut dst: *mut Elf_External_Verdef,
) {
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (*src).vd_version as bfd_vma,
        ((*dst).vd_version).as_mut_ptr() as *mut libc::c_void,
    );
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (*src).vd_flags as bfd_vma,
        ((*dst).vd_flags).as_mut_ptr() as *mut libc::c_void,
    );
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vd_ndx as bfd_vma, ((*dst).vd_ndx).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vd_cnt as bfd_vma, ((*dst).vd_cnt).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vd_hash, ((*dst).vd_hash).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vd_aux, ((*dst).vd_aux).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vd_next, ((*dst).vd_next).as_mut_ptr() as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_verdaux_in(
    mut abfd: *mut bfd,
    mut src: *const Elf_External_Verdaux,
    mut dst: *mut Elf_Internal_Verdaux,
) {
    (*dst)
        .vda_name = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vda_name).as_ptr() as *const libc::c_void);
    (*dst)
        .vda_next = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vda_next).as_ptr() as *const libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_verdaux_out(
    mut abfd: *mut bfd,
    mut src: *const Elf_Internal_Verdaux,
    mut dst: *mut Elf_External_Verdaux,
) {
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vda_name, ((*dst).vda_name).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vda_next, ((*dst).vda_next).as_mut_ptr() as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_verneed_in(
    mut abfd: *mut bfd,
    mut src: *const Elf_External_Verneed,
    mut dst: *mut Elf_Internal_Verneed,
) {
    (*dst)
        .vn_version = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vn_version).as_ptr() as *const libc::c_void) as libc::c_ushort;
    (*dst)
        .vn_cnt = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vn_cnt).as_ptr() as *const libc::c_void) as libc::c_ushort;
    (*dst)
        .vn_file = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vn_file).as_ptr() as *const libc::c_void);
    (*dst)
        .vn_aux = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vn_aux).as_ptr() as *const libc::c_void);
    (*dst)
        .vn_next = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vn_next).as_ptr() as *const libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_verneed_out(
    mut abfd: *mut bfd,
    mut src: *const Elf_Internal_Verneed,
    mut dst: *mut Elf_External_Verneed,
) {
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (*src).vn_version as bfd_vma,
        ((*dst).vn_version).as_mut_ptr() as *mut libc::c_void,
    );
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vn_cnt as bfd_vma, ((*dst).vn_cnt).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vn_file, ((*dst).vn_file).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vn_aux, ((*dst).vn_aux).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vn_next, ((*dst).vn_next).as_mut_ptr() as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_vernaux_in(
    mut abfd: *mut bfd,
    mut src: *const Elf_External_Vernaux,
    mut dst: *mut Elf_Internal_Vernaux,
) {
    (*dst)
        .vna_hash = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vna_hash).as_ptr() as *const libc::c_void);
    (*dst)
        .vna_flags = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vna_flags).as_ptr() as *const libc::c_void) as libc::c_ushort;
    (*dst)
        .vna_other = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vna_other).as_ptr() as *const libc::c_void) as libc::c_ushort;
    (*dst)
        .vna_name = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vna_name).as_ptr() as *const libc::c_void);
    (*dst)
        .vna_next = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vna_next).as_ptr() as *const libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_vernaux_out(
    mut abfd: *mut bfd,
    mut src: *const Elf_Internal_Vernaux,
    mut dst: *mut Elf_External_Vernaux,
) {
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vna_hash, ((*dst).vna_hash).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (*src).vna_flags as bfd_vma,
        ((*dst).vna_flags).as_mut_ptr() as *mut libc::c_void,
    );
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (*src).vna_other as bfd_vma,
        ((*dst).vna_other).as_mut_ptr() as *mut libc::c_void,
    );
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vna_name, ((*dst).vna_name).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vna_next, ((*dst).vna_next).as_mut_ptr() as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_versym_in(
    mut abfd: *mut bfd,
    mut src: *const Elf_External_Versym,
    mut dst: *mut Elf_Internal_Versym,
) {
    (*dst)
        .vs_vers = (Some(
        ((*(*abfd).xvec).bfd_h_getx16).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(((*src).vs_vers).as_ptr() as *const libc::c_void) as libc::c_ushort;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_swap_versym_out(
    mut abfd: *mut bfd,
    mut src: *const Elf_Internal_Versym,
    mut dst: *mut Elf_External_Versym,
) {
    (Some(((*(*abfd).xvec).bfd_h_putx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*src).vs_vers as bfd_vma, ((*dst).vs_vers).as_mut_ptr() as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_hash(
    mut namearg: *const libc::c_char,
) -> libc::c_ulong {
    let mut name: *const libc::c_uchar = namearg as *const libc::c_uchar;
    let mut h: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut g: libc::c_ulong = 0;
    let mut ch: libc::c_int = 0;
    loop {
        let fresh0 = name;
        name = name.offset(1);
        ch = *fresh0 as libc::c_int;
        if !(ch != '\0' as i32) {
            break;
        }
        h = (h << 4 as libc::c_int).wrapping_add(ch as libc::c_ulong);
        g = h & 0xf0000000 as libc::c_uint as libc::c_ulong;
        if g != 0 as libc::c_int as libc::c_ulong {
            h ^= g >> 24 as libc::c_int;
            h ^= g;
        }
    }
    return h & 0xffffffff as libc::c_uint as libc::c_ulong;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_gnu_hash(
    mut namearg: *const libc::c_char,
) -> libc::c_ulong {
    let mut name: *const libc::c_uchar = namearg as *const libc::c_uchar;
    let mut h: libc::c_ulong = 5381 as libc::c_int as libc::c_ulong;
    let mut ch: libc::c_uchar = 0;
    loop {
        let fresh1 = name;
        name = name.offset(1);
        ch = *fresh1;
        if !(ch as libc::c_int != '\0' as i32) {
            break;
        }
        h = (h << 5 as libc::c_int).wrapping_add(h).wrapping_add(ch as libc::c_ulong);
    }
    return h & 0xffffffff as libc::c_uint as libc::c_ulong;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_allocate_object(
    mut abfd: *mut bfd,
    mut object_size: size_t,
    mut object_id: elf_target_id,
) -> bool {
    if !(object_size >= ::core::mem::size_of::<elf_obj_tdata>() as libc::c_ulong) {
        bfd_assert(b"elf.c\0" as *const u8 as *const libc::c_char, 240 as libc::c_int);
    }
    (*abfd).tdata.any = bfd_zalloc(abfd, object_size);
    if ((*abfd).tdata.any).is_null() {
        return 0 as libc::c_int != 0;
    }
    (*(*abfd).tdata.elf_obj_data).set_object_id(object_id);
    if (*abfd).direction() as libc::c_int != read_direction as libc::c_int {
        let mut o: *mut output_elf_obj_tdata = bfd_zalloc(
            abfd,
            ::core::mem::size_of::<output_elf_obj_tdata>() as libc::c_ulong,
        ) as *mut output_elf_obj_tdata;
        if o.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*(*abfd).tdata.elf_obj_data).o = o;
        (*(*(*abfd).tdata.elf_obj_data).o)
            .program_header_size = -(1 as libc::c_int) as bfd_size_type;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_make_object(mut abfd: *mut bfd) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    return bfd_elf_allocate_object(
        abfd,
        ::core::mem::size_of::<elf_obj_tdata>() as libc::c_ulong,
        (*bed).target_id,
    );
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_mkcorefile(mut abfd: *mut bfd) -> bool {
    if !((*(*abfd).xvec)._bfd_set_format[bfd_object as libc::c_int as usize])
        .expect("non-null function pointer")(abfd)
    {
        return 0 as libc::c_int != 0;
    }
    (*(*abfd).tdata.elf_obj_data)
        .core = bfd_zalloc(
        abfd,
        ::core::mem::size_of::<core_elf_obj_tdata>() as libc::c_ulong,
    ) as *mut core_elf_obj_tdata;
    return !((*(*abfd).tdata.elf_obj_data).core).is_null();
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_get_str_section(
    mut abfd: *mut bfd,
    mut shindex: libc::c_uint,
) -> *mut libc::c_char {
    let mut i_shdrp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    let mut shstrtab: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut offset: file_ptr = 0;
    let mut shstrtabsize: bfd_size_type = 0;
    i_shdrp = (*(*abfd).tdata.elf_obj_data).elf_sect_ptr;
    if i_shdrp.is_null() || shindex >= (*(*abfd).tdata.elf_obj_data).num_elf_sections
        || (*i_shdrp.offset(shindex as isize)).is_null()
    {
        return 0 as *mut libc::c_char;
    }
    shstrtab = (**i_shdrp.offset(shindex as isize)).contents;
    if shstrtab.is_null() {
        offset = (**i_shdrp.offset(shindex as isize)).sh_offset;
        shstrtabsize = (**i_shdrp.offset(shindex as isize)).sh_size;
        if shstrtabsize.wrapping_add(1 as libc::c_int as libc::c_ulong)
            <= 1 as libc::c_int as libc::c_ulong
            || bfd_seek(abfd, offset, 0 as libc::c_int) != 0 as libc::c_int
            || {
                shstrtab = _bfd_alloc_and_read(
                    abfd,
                    shstrtabsize.wrapping_add(1 as libc::c_int as libc::c_ulong),
                    shstrtabsize,
                );
                shstrtab.is_null()
            }
        {
            (**i_shdrp.offset(shindex as isize))
                .sh_size = 0 as libc::c_int as bfd_size_type;
        } else {
            *shstrtab.offset(shstrtabsize as isize) = '\0' as i32 as bfd_byte;
        }
        let ref mut fresh2 = (**i_shdrp.offset(shindex as isize)).contents;
        *fresh2 = shstrtab;
    }
    return shstrtab as *mut libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_string_from_elf_section(
    mut abfd: *mut bfd,
    mut shindex: libc::c_uint,
    mut strindex: libc::c_uint,
) -> *mut libc::c_char {
    let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    if strindex == 0 as libc::c_int as libc::c_uint {
        return b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if ((*(*abfd).tdata.elf_obj_data).elf_sect_ptr).is_null()
        || shindex >= (*(*abfd).tdata.elf_obj_data).num_elf_sections
    {
        return 0 as *mut libc::c_char;
    }
    hdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr).offset(shindex as isize);
    if ((*hdr).contents).is_null() {
        if (*hdr).sh_type != 3 as libc::c_int as libc::c_uint
            && (*hdr).sh_type < 0x60000000 as libc::c_int as libc::c_uint
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: attempt to load strings from a non-string section (number %d)\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                shindex,
            );
            return 0 as *mut libc::c_char;
        }
        if (bfd_elf_get_str_section(abfd, shindex)).is_null() {
            return 0 as *mut libc::c_char;
        }
    } else if (*hdr).sh_size == 0 as libc::c_int as libc::c_ulong
        || *((*hdr).contents)
            .offset(
                ((*hdr).sh_size).wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
            ) as libc::c_int != 0 as libc::c_int
    {
        return 0 as *mut libc::c_char
    }
    if strindex as libc::c_ulong >= (*hdr).sh_size {
        let mut shstrndx: libc::c_uint = (*((*(*abfd).tdata.elf_obj_data).elf_header)
            .as_mut_ptr())
            .e_shstrndx;
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: invalid string offset %u >= %lu for section `%s'\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            strindex,
            (*hdr).sh_size,
            if shindex == shstrndx && strindex == (*hdr).sh_name {
                b".shstrtab\0" as *const u8 as *const libc::c_char
            } else {
                bfd_elf_string_from_elf_section(abfd, shstrndx, (*hdr).sh_name)
                    as *const libc::c_char
            },
        );
        return 0 as *mut libc::c_char;
    }
    return ((*hdr).contents as *mut libc::c_char).offset(strindex as isize);
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_get_elf_syms(
    mut ibfd: *mut bfd,
    mut symtab_hdr: *mut Elf_Internal_Shdr,
    mut symcount: size_t,
    mut symoffset: size_t,
    mut intsym_buf: *mut Elf_Internal_Sym,
    mut extsym_buf: *mut libc::c_void,
    mut extshndx_buf: *mut Elf_External_Sym_Shndx,
) -> *mut Elf_Internal_Sym {
    let mut current_block: u64;
    let mut shndx_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut alloc_ext: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut esym: *const bfd_byte = 0 as *const bfd_byte;
    let mut alloc_extshndx: *mut Elf_External_Sym_Shndx = 0
        as *mut Elf_External_Sym_Shndx;
    let mut shndx: *mut Elf_External_Sym_Shndx = 0 as *mut Elf_External_Sym_Shndx;
    let mut alloc_intsym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isym: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut isymend: *mut Elf_Internal_Sym = 0 as *mut Elf_Internal_Sym;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut extsym_size: size_t = 0;
    let mut amt: size_t = 0;
    let mut pos: file_ptr = 0;
    if bfd_get_flavour(ibfd) as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        _bfd_abort(
            b"elf.c\0" as *const u8 as *const libc::c_char,
            404 as libc::c_int,
            (*::core::mem::transmute::<
                &[u8; 137],
                &[libc::c_char; 137],
            >(
                b"Elf_Internal_Sym *bfd_elf_get_elf_syms(bfd *, Elf_Internal_Shdr *, size_t, size_t, Elf_Internal_Sym *, void *, Elf_External_Sym_Shndx *)\0",
            ))
                .as_ptr(),
        );
    }
    if symcount == 0 as libc::c_int as libc::c_ulong {
        return intsym_buf;
    }
    shndx_hdr = 0 as *mut Elf_Internal_Shdr;
    if !((*(*ibfd).tdata.elf_obj_data).symtab_shndx_list).is_null() {
        let mut entry: *mut elf_section_list = 0 as *mut elf_section_list;
        let mut sections: *mut *mut Elf_Internal_Shdr = (*(*ibfd).tdata.elf_obj_data)
            .elf_sect_ptr;
        entry = (*(*ibfd).tdata.elf_obj_data).symtab_shndx_list;
        while !entry.is_null() {
            if !((*entry).hdr.sh_link >= (*(*ibfd).tdata.elf_obj_data).num_elf_sections)
            {
                if *sections.offset((*entry).hdr.sh_link as isize) == symtab_hdr {
                    shndx_hdr = &mut (*entry).hdr;
                    break;
                }
            }
            entry = (*entry).next;
        }
        if shndx_hdr.is_null() {
            if symtab_hdr
                == &mut (*(*ibfd).tdata.elf_obj_data).symtab_hdr
                    as *mut Elf_Internal_Shdr
            {
                shndx_hdr = &mut (*(*(*ibfd).tdata.elf_obj_data).symtab_shndx_list).hdr;
            }
        }
    }
    alloc_ext = 0 as *mut libc::c_void;
    alloc_extshndx = 0 as *mut Elf_External_Sym_Shndx;
    alloc_intsym = 0 as *mut Elf_Internal_Sym;
    bed = (*(*ibfd).xvec).backend_data as *const elf_backend_data;
    extsym_size = (*(*bed).s).sizeof_sym as size_t;
    amt = symcount;
    amt = (amt as libc::c_ulong).wrapping_mul(extsym_size) as size_t as size_t;
    if extsym_size != 0 as libc::c_int as libc::c_ulong
        && amt.wrapping_div(extsym_size) != symcount
    {
        bfd_set_error(bfd_error_file_too_big);
        intsym_buf = 0 as *mut Elf_Internal_Sym;
    } else {
        pos = ((*symtab_hdr).sh_offset as libc::c_ulong)
            .wrapping_add(symoffset.wrapping_mul(extsym_size)) as file_ptr;
        if extsym_buf.is_null() {
            alloc_ext = bfd_malloc(amt);
            extsym_buf = alloc_ext;
        }
        if extsym_buf.is_null()
            || bfd_seek(ibfd, pos, 0 as libc::c_int) != 0 as libc::c_int
            || bfd_bread(extsym_buf, amt, ibfd) != amt
        {
            intsym_buf = 0 as *mut Elf_Internal_Sym;
        } else {
            if shndx_hdr.is_null()
                || (*shndx_hdr).sh_size == 0 as libc::c_int as libc::c_ulong
            {
                extshndx_buf = 0 as *mut Elf_External_Sym_Shndx;
                current_block = 4567019141635105728;
            } else {
                amt = symcount;
                amt = (amt as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<Elf_External_Sym_Shndx>() as libc::c_ulong,
                    ) as size_t as size_t;
                if ::core::mem::size_of::<Elf_External_Sym_Shndx>() as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                    && amt
                        .wrapping_div(
                            ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                as libc::c_ulong,
                        ) != symcount
                {
                    bfd_set_error(bfd_error_file_too_big);
                    intsym_buf = 0 as *mut Elf_Internal_Sym;
                    current_block = 16445257676252610945;
                } else {
                    pos = ((*shndx_hdr).sh_offset as libc::c_ulong)
                        .wrapping_add(
                            symoffset
                                .wrapping_mul(
                                    ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                        as libc::c_ulong,
                                ),
                        ) as file_ptr;
                    if extshndx_buf.is_null() {
                        alloc_extshndx = bfd_malloc(amt) as *mut Elf_External_Sym_Shndx;
                        extshndx_buf = alloc_extshndx;
                    }
                    if extshndx_buf.is_null()
                        || bfd_seek(ibfd, pos, 0 as libc::c_int) != 0 as libc::c_int
                        || bfd_bread(extshndx_buf as *mut libc::c_void, amt, ibfd) != amt
                    {
                        intsym_buf = 0 as *mut Elf_Internal_Sym;
                        current_block = 16445257676252610945;
                    } else {
                        current_block = 4567019141635105728;
                    }
                }
            }
            match current_block {
                16445257676252610945 => {}
                _ => {
                    if intsym_buf.is_null() {
                        amt = symcount;
                        amt = (amt as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
                            ) as size_t as size_t;
                        if ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong
                            != 0 as libc::c_int as libc::c_ulong
                            && amt
                                .wrapping_div(
                                    ::core::mem::size_of::<Elf_Internal_Sym>() as libc::c_ulong,
                                ) != symcount
                        {
                            bfd_set_error(bfd_error_file_too_big);
                            current_block = 16445257676252610945;
                        } else {
                            alloc_intsym = bfd_malloc(amt) as *mut Elf_Internal_Sym;
                            intsym_buf = alloc_intsym;
                            if intsym_buf.is_null() {
                                current_block = 16445257676252610945;
                            } else {
                                current_block = 10150597327160359210;
                            }
                        }
                    } else {
                        current_block = 10150597327160359210;
                    }
                    match current_block {
                        16445257676252610945 => {}
                        _ => {
                            isymend = intsym_buf.offset(symcount as isize);
                            esym = extsym_buf as *const bfd_byte;
                            isym = intsym_buf;
                            shndx = extshndx_buf;
                            while isym < isymend {
                                if !(Some(
                                    ((*(*bed).s).swap_symbol_in)
                                        .expect("non-null function pointer"),
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ibfd,
                                    esym as *const libc::c_void,
                                    shndx as *const libc::c_void,
                                    isym,
                                )
                                {
                                    symoffset = (symoffset as libc::c_ulong)
                                        .wrapping_add(
                                            (esym.offset_from(extsym_buf as *mut bfd_byte)
                                                as libc::c_long as libc::c_ulong)
                                                .wrapping_div(extsym_size),
                                        ) as size_t as size_t;
                                    _bfd_error_handler(
                                        dcgettext(
                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                            b"%pB symbol number %lu references nonexistent SHT_SYMTAB_SHNDX section\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        ibfd,
                                        symoffset,
                                    );
                                    free(alloc_intsym as *mut libc::c_void);
                                    intsym_buf = 0 as *mut Elf_Internal_Sym;
                                    break;
                                } else {
                                    esym = esym.offset(extsym_size as isize);
                                    isym = isym.offset(1);
                                    isym;
                                    shndx = if !shndx.is_null() {
                                        shndx.offset(1 as libc::c_int as isize)
                                    } else {
                                        0 as *mut Elf_External_Sym_Shndx
                                    };
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    free(alloc_ext);
    free(alloc_extshndx as *mut libc::c_void);
    return intsym_buf;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_sym_name(
    mut abfd: *mut bfd,
    mut symtab_hdr: *mut Elf_Internal_Shdr,
    mut isym: *mut Elf_Internal_Sym,
    mut sym_sec: *mut asection,
) -> *const libc::c_char {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut iname: libc::c_uint = (*isym).st_name as libc::c_uint;
    let mut shindex: libc::c_uint = (*symtab_hdr).sh_link;
    if iname == 0 as libc::c_int as libc::c_uint
        && (*isym).st_info as libc::c_int & 0xf as libc::c_int == 3 as libc::c_int
        && (*isym).st_shndx < (*(*abfd).tdata.elf_obj_data).num_elf_sections
    {
        iname = (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
            .offset((*isym).st_shndx as isize))
            .sh_name;
        shindex = (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_shstrndx;
    }
    name = bfd_elf_string_from_elf_section(abfd, shindex, iname);
    if name.is_null() {
        name = b"(null)\0" as *const u8 as *const libc::c_char;
    } else if !sym_sec.is_null() && *name as libc::c_int == '\0' as i32 {
        name = bfd_section_name(sym_sec);
    }
    return name;
}
unsafe extern "C" fn group_signature(
    mut abfd: *mut bfd,
    mut ghdr: *mut Elf_Internal_Shdr,
) -> *const libc::c_char {
    let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut esym: [libc::c_uchar; 24] = [0; 24];
    let mut eshndx: Elf_External_Sym_Shndx = Elf_External_Sym_Shndx {
        est_shndx: [0; 4],
    };
    let mut isym: Elf_Internal_Sym = Elf_Internal_Sym {
        st_value: 0,
        st_size: 0,
        st_name: 0,
        st_info: 0,
        st_other: 0,
        st_target_internal: 0,
        st_shndx: 0,
    };
    if (*ghdr).sh_link >= (*(*abfd).tdata.elf_obj_data).num_elf_sections {
        return 0 as *const libc::c_char;
    }
    hdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr).offset((*ghdr).sh_link as isize);
    if (*hdr).sh_type != 2 as libc::c_int as libc::c_uint
        || !bfd_section_from_shdr(abfd, (*ghdr).sh_link)
    {
        return 0 as *const libc::c_char;
    }
    hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    if (bfd_elf_get_elf_syms(
        abfd,
        hdr,
        1 as libc::c_int as size_t,
        (*ghdr).sh_info as size_t,
        &mut isym,
        esym.as_mut_ptr() as *mut libc::c_void,
        &mut eshndx,
    ))
        .is_null()
    {
        return 0 as *const libc::c_char;
    }
    return bfd_elf_sym_name(abfd, hdr, &mut isym, 0 as *mut asection);
}
unsafe extern "C" fn setup_group(
    mut abfd: *mut bfd,
    mut hdr: *mut Elf_Internal_Shdr,
    mut newsect: *mut asection,
) -> bool {
    let mut num_group: libc::c_uint = (*(*abfd).tdata.elf_obj_data).num_group;
    if num_group == 0 as libc::c_int as libc::c_uint {
        let mut i: libc::c_uint = 0;
        let mut shnum: libc::c_uint = 0;
        shnum = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
        num_group = 0 as libc::c_int as libc::c_uint;
        i = 0 as libc::c_int as libc::c_uint;
        while i < shnum {
            let mut shdr: *mut Elf_Internal_Shdr = *((*(*abfd).tdata.elf_obj_data)
                .elf_sect_ptr)
                .offset(i as isize);
            if (*shdr).sh_type == 17 as libc::c_int as libc::c_uint
                && (*shdr).sh_size
                    >= (2 as libc::c_int * 4 as libc::c_int) as libc::c_ulong
                && (*shdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                && ((*shdr).sh_size).wrapping_rem(4 as libc::c_int as libc::c_ulong)
                    == 0 as libc::c_int as libc::c_ulong
            {
                num_group = num_group.wrapping_add(1 as libc::c_int as libc::c_uint);
            }
            i = i.wrapping_add(1);
            i;
        }
        if num_group == 0 as libc::c_int as libc::c_uint {
            num_group = -(1 as libc::c_int) as libc::c_uint;
            (*(*abfd).tdata.elf_obj_data).num_group = num_group;
            (*(*abfd).tdata.elf_obj_data)
                .group_sect_ptr = 0 as *mut *mut Elf_Internal_Shdr;
        } else {
            let mut amt: size_t = 0;
            (*(*abfd).tdata.elf_obj_data).num_group = num_group;
            amt = (num_group as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut Elf_Internal_Shdr>() as libc::c_ulong,
                );
            (*(*abfd).tdata.elf_obj_data)
                .group_sect_ptr = bfd_zalloc(abfd, amt) as *mut *mut Elf_Internal_Shdr;
            if ((*(*abfd).tdata.elf_obj_data).group_sect_ptr).is_null() {
                return 0 as libc::c_int != 0;
            }
            num_group = 0 as libc::c_int as libc::c_uint;
            i = 0 as libc::c_int as libc::c_uint;
            while i < shnum {
                let mut shdr_0: *mut Elf_Internal_Shdr = *((*(*abfd).tdata.elf_obj_data)
                    .elf_sect_ptr)
                    .offset(i as isize);
                if (*shdr_0).sh_type == 17 as libc::c_int as libc::c_uint
                    && (*shdr_0).sh_size
                        >= (2 as libc::c_int * 4 as libc::c_int) as libc::c_ulong
                    && (*shdr_0).sh_entsize == 4 as libc::c_int as libc::c_ulong
                    && ((*shdr_0).sh_size)
                        .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                        == 0 as libc::c_int as libc::c_ulong
                {
                    let mut src: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                    let mut dest: *mut Elf_Internal_Group = 0 as *mut Elf_Internal_Group;
                    if !bfd_section_from_shdr(abfd, i) {
                        return 0 as libc::c_int != 0;
                    }
                    let ref mut fresh3 = *((*(*abfd).tdata.elf_obj_data).group_sect_ptr)
                        .offset(num_group as isize);
                    *fresh3 = shdr_0;
                    num_group = num_group.wrapping_add(1 as libc::c_int as libc::c_uint);
                    if !(::core::mem::size_of::<Elf_Internal_Group>() as libc::c_ulong
                        >= 4 as libc::c_int as libc::c_ulong
                        && (::core::mem::size_of::<Elf_Internal_Group>()
                            as libc::c_ulong)
                            .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                            == 0 as libc::c_int as libc::c_ulong)
                    {
                        bfd_assert(
                            b"elf.c\0" as *const u8 as *const libc::c_char,
                            666 as libc::c_int,
                        );
                    }
                    (*shdr_0).contents = 0 as *mut libc::c_uchar;
                    amt = (*shdr_0).sh_size;
                    amt = (amt as libc::c_ulong)
                        .wrapping_mul(
                            (::core::mem::size_of::<Elf_Internal_Group>()
                                as libc::c_ulong)
                                .wrapping_div(4 as libc::c_int as libc::c_ulong),
                        ) as size_t as size_t;
                    if (::core::mem::size_of::<Elf_Internal_Group>() as libc::c_ulong)
                        .wrapping_div(4 as libc::c_int as libc::c_ulong)
                        != 0 as libc::c_int as libc::c_ulong
                        && amt
                            .wrapping_div(
                                (::core::mem::size_of::<Elf_Internal_Group>()
                                    as libc::c_ulong)
                                    .wrapping_div(4 as libc::c_int as libc::c_ulong),
                            ) != (*shdr_0).sh_size
                        || bfd_seek(abfd, (*shdr_0).sh_offset, 0 as libc::c_int)
                            != 0 as libc::c_int
                        || {
                            (*shdr_0)
                                .contents = _bfd_alloc_and_read(
                                abfd,
                                amt,
                                (*shdr_0).sh_size,
                            );
                            ((*shdr_0).contents).is_null()
                        }
                    {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%pB: invalid size field in group section header: %#lx\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            abfd,
                            (*shdr_0).sh_size,
                        );
                        bfd_set_error(bfd_error_bad_value);
                        num_group = num_group.wrapping_sub(1);
                        num_group;
                    } else {
                        src = ((*shdr_0).contents).offset((*shdr_0).sh_size as isize);
                        dest = ((*shdr_0).contents).offset(amt as isize)
                            as *mut Elf_Internal_Group;
                        loop {
                            let mut idx: libc::c_uint = 0;
                            src = src.offset(-(4 as libc::c_int as isize));
                            dest = dest.offset(-1);
                            dest;
                            idx = (Some(
                                ((*(*abfd).xvec).bfd_h_getx32)
                                    .expect("non-null function pointer"),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(src as *const libc::c_void) as libc::c_uint;
                            if src == (*shdr_0).contents {
                                (*dest).shdr = 0 as *mut Elf_Internal_Shdr;
                                (*dest).flags = idx;
                                if !((*shdr_0).bfd_section).is_null()
                                    && idx & 0x1 as libc::c_int as libc::c_uint != 0
                                {
                                    (*(*shdr_0).bfd_section).flags
                                        |= (0x20000 as libc::c_int | 0 as libc::c_int)
                                            as libc::c_uint;
                                }
                                break;
                            } else {
                                if idx < shnum {
                                    (*dest)
                                        .shdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(idx as isize);
                                    (*(*dest).shdr).sh_flags
                                        |= ((1 as libc::c_int) << 9 as libc::c_int)
                                            as libc::c_ulong;
                                }
                                if idx >= shnum
                                    || (*(*dest).shdr).sh_type
                                        == 17 as libc::c_int as libc::c_uint
                                {
                                    _bfd_error_handler(
                                        dcgettext(
                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                            b"%pB: invalid entry in SHT_GROUP section [%u]\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        abfd,
                                        i,
                                    );
                                    (*dest).shdr = 0 as *mut Elf_Internal_Shdr;
                                }
                            }
                        }
                    }
                }
                i = i.wrapping_add(1);
                i;
            }
            if num_group != (*(*abfd).tdata.elf_obj_data).num_group {
                (*(*abfd).tdata.elf_obj_data).num_group = num_group;
                if num_group == 0 as libc::c_int as libc::c_uint {
                    (*(*abfd).tdata.elf_obj_data)
                        .group_sect_ptr = 0 as *mut *mut Elf_Internal_Shdr;
                    num_group = -(1 as libc::c_int) as libc::c_uint;
                    (*(*abfd).tdata.elf_obj_data).num_group = num_group;
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: no valid group sections found\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                    );
                    bfd_set_error(bfd_error_bad_value);
                }
            }
        }
    }
    if num_group != -(1 as libc::c_int) as libc::c_uint {
        let mut search_offset: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
            .group_search_offset;
        let mut j: libc::c_uint = 0;
        j = 0 as libc::c_int as libc::c_uint;
        while j < num_group {
            let mut i_0: libc::c_uint = j
                .wrapping_add(search_offset)
                .wrapping_rem(num_group);
            let mut shdr_1: *mut Elf_Internal_Shdr = *((*(*abfd).tdata.elf_obj_data)
                .group_sect_ptr)
                .offset(i_0 as isize);
            let mut idx_0: *mut Elf_Internal_Group = 0 as *mut Elf_Internal_Group;
            let mut n_elt: bfd_size_type = 0;
            if !shdr_1.is_null() {
                idx_0 = (*shdr_1).contents as *mut Elf_Internal_Group;
                if idx_0.is_null()
                    || (*shdr_1).sh_size < 4 as libc::c_int as libc::c_ulong
                {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: group section '%pA' has no contents\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        (*shdr_1).bfd_section,
                    );
                    let ref mut fresh4 = *((*(*abfd).tdata.elf_obj_data).group_sect_ptr)
                        .offset(i_0 as isize);
                    *fresh4 = 0 as *mut Elf_Internal_Shdr;
                    bfd_set_error(bfd_error_bad_value);
                    return 0 as libc::c_int != 0;
                }
                n_elt = ((*shdr_1).sh_size)
                    .wrapping_div(4 as libc::c_int as libc::c_ulong);
                loop {
                    n_elt = n_elt.wrapping_sub(1);
                    if !(n_elt != 0 as libc::c_int as libc::c_ulong) {
                        break;
                    }
                    idx_0 = idx_0.offset(1);
                    if !((*idx_0).shdr == hdr) {
                        continue;
                    }
                    let mut s: *mut asection = 0 as *mut asection;
                    idx_0 = (*shdr_1).contents as *mut Elf_Internal_Group;
                    n_elt = ((*shdr_1).sh_size)
                        .wrapping_div(4 as libc::c_int as libc::c_ulong);
                    loop {
                        n_elt = n_elt.wrapping_sub(1);
                        if !(n_elt != 0 as libc::c_int as libc::c_ulong) {
                            break;
                        }
                        idx_0 = idx_0.offset(1);
                        if !((*idx_0).shdr).is_null()
                            && {
                                s = (*(*idx_0).shdr).bfd_section;
                                !s.is_null()
                            }
                            && !((*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                .next_in_group)
                                .is_null()
                        {
                            break;
                        }
                    }
                    if n_elt != 0 as libc::c_int as libc::c_ulong {
                        let ref mut fresh5 = (*((*newsect).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .group
                            .name;
                        *fresh5 = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                            .group
                            .name;
                        let ref mut fresh6 = (*((*newsect).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .next_in_group;
                        *fresh6 = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                            .next_in_group;
                        let ref mut fresh7 = (*((*s).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .next_in_group;
                        *fresh7 = newsect;
                    } else {
                        let mut gname: *const libc::c_char = 0 as *const libc::c_char;
                        gname = group_signature(abfd, shdr_1);
                        if gname.is_null() {
                            return 0 as libc::c_int != 0;
                        }
                        let ref mut fresh8 = (*((*newsect).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .group
                            .name;
                        *fresh8 = gname;
                        let ref mut fresh9 = (*((*newsect).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .next_in_group;
                        *fresh9 = newsect;
                    }
                    if !((*shdr_1).bfd_section).is_null() {
                        let ref mut fresh10 = (*((*(*shdr_1).bfd_section).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .next_in_group;
                        *fresh10 = newsect;
                    }
                    (*(*abfd).tdata.elf_obj_data).group_search_offset = i_0;
                    j = num_group.wrapping_sub(1 as libc::c_int as libc::c_uint);
                    break;
                }
            }
            j = j.wrapping_add(1);
            j;
        }
    }
    if ((*((*newsect).used_by_bfd as *mut bfd_elf_section_data)).group.name).is_null() {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: no group info for section '%pA'\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            newsect,
        );
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_setup_sections(mut abfd: *mut bfd) -> bool {
    let mut i: libc::c_uint = 0;
    let mut num_group: libc::c_uint = (*(*abfd).tdata.elf_obj_data).num_group;
    let mut result: bool = 1 as libc::c_int != 0;
    let mut s: *mut asection = 0 as *mut asection;
    s = (*abfd).sections;
    while !s.is_null() {
        let mut this_hdr: *mut Elf_Internal_Shdr = &mut (*((*s).used_by_bfd
            as *mut bfd_elf_section_data))
            .this_hdr;
        if (*this_hdr).sh_flags
            & ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_ulong
            != 0 as libc::c_int as libc::c_ulong
        {
            let mut elfsec: libc::c_uint = (*this_hdr).sh_link;
            if elfsec == 0 as libc::c_int as libc::c_uint {
                let ref mut fresh11 = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                    .linked_to;
                *fresh11 = 0 as *mut asection;
            } else {
                let mut linksec: *mut asection = 0 as *mut asection;
                if elfsec < (*(*abfd).tdata.elf_obj_data).num_elf_sections {
                    this_hdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                        .offset(elfsec as isize);
                    linksec = (*this_hdr).bfd_section;
                }
                if linksec.is_null() {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: sh_link [%d] in section `%pA' is incorrect\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        (*s).owner,
                        elfsec,
                        s,
                    );
                    result = 0 as libc::c_int != 0;
                }
                let ref mut fresh12 = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                    .linked_to;
                *fresh12 = linksec;
            }
        } else if (*this_hdr).sh_type == 17 as libc::c_int as libc::c_uint
            && ((*((*s).used_by_bfd as *mut bfd_elf_section_data)).next_in_group)
                .is_null()
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: SHT_GROUP section [index %d] has no SHF_GROUP sections\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                (*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_idx,
            );
            result = 0 as libc::c_int != 0;
        }
        s = (*s).next;
    }
    if num_group == -(1 as libc::c_int) as libc::c_uint {
        return result;
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < num_group {
        let mut shdr: *mut Elf_Internal_Shdr = *((*(*abfd).tdata.elf_obj_data)
            .group_sect_ptr)
            .offset(i as isize);
        let mut idx: *mut Elf_Internal_Group = 0 as *mut Elf_Internal_Group;
        let mut n_elt: libc::c_uint = 0;
        if shdr.is_null() || ((*shdr).bfd_section).is_null()
            || ((*shdr).contents).is_null()
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: section group entry number %u is corrupt\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                i,
            );
            result = 0 as libc::c_int != 0;
        } else {
            idx = (*shdr).contents as *mut Elf_Internal_Group;
            n_elt = ((*shdr).sh_size).wrapping_div(4 as libc::c_int as libc::c_ulong)
                as libc::c_uint;
            loop {
                n_elt = n_elt.wrapping_sub(1);
                if !(n_elt != 0 as libc::c_int as libc::c_uint) {
                    break;
                }
                idx = idx.offset(1);
                idx;
                if ((*idx).shdr).is_null() {
                    continue;
                }
                if !((*(*idx).shdr).bfd_section).is_null() {
                    let ref mut fresh13 = (*((*(*(*idx).shdr).bfd_section).used_by_bfd
                        as *mut bfd_elf_section_data))
                        .sec_group;
                    *fresh13 = (*shdr).bfd_section;
                } else if (*(*idx).shdr).sh_type != 4 as libc::c_int as libc::c_uint
                    && (*(*idx).shdr).sh_type != 9 as libc::c_int as libc::c_uint
                {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: unknown type [%#x] section `%s' in group [%pA]\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        (*(*idx).shdr).sh_type,
                        bfd_elf_string_from_elf_section(
                            abfd,
                            (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
                                .e_shstrndx,
                            (*(*idx).shdr).sh_name,
                        ),
                        (*shdr).bfd_section,
                    );
                    result = 0 as libc::c_int != 0;
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_is_group_section(
    mut _abfd: *mut bfd,
    mut sec: *const asection,
) -> bool {
    return !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group)
        .is_null();
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_group_name(
    mut _abfd: *mut bfd,
    mut sec: *const asection,
) -> *const libc::c_char {
    if !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).sec_group).is_null() {
        return (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).group.name;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn convert_debug_to_zdebug(
    mut abfd: *mut bfd,
    mut name: *const libc::c_char,
) -> *mut libc::c_char {
    let mut len: libc::c_uint = strlen(name) as libc::c_uint;
    let mut new_name: *mut libc::c_char = bfd_alloc(
        abfd,
        len.wrapping_add(2 as libc::c_int as libc::c_uint) as bfd_size_type,
    ) as *mut libc::c_char;
    if new_name.is_null() {
        return 0 as *mut libc::c_char;
    }
    *new_name.offset(0 as libc::c_int as isize) = '.' as i32 as libc::c_char;
    *new_name.offset(1 as libc::c_int as isize) = 'z' as i32 as libc::c_char;
    memcpy(
        new_name.offset(2 as libc::c_int as isize) as *mut libc::c_void,
        name.offset(1 as libc::c_int as isize) as *const libc::c_void,
        len as libc::c_ulong,
    );
    return new_name;
}
unsafe extern "C" fn convert_zdebug_to_debug(
    mut abfd: *mut bfd,
    mut name: *const libc::c_char,
) -> *mut libc::c_char {
    let mut len: libc::c_uint = strlen(name) as libc::c_uint;
    let mut new_name: *mut libc::c_char = bfd_alloc(abfd, len as bfd_size_type)
        as *mut libc::c_char;
    if new_name.is_null() {
        return 0 as *mut libc::c_char;
    }
    *new_name.offset(0 as libc::c_int as isize) = '.' as i32 as libc::c_char;
    memcpy(
        new_name.offset(1 as libc::c_int as isize) as *mut libc::c_void,
        name.offset(2 as libc::c_int as isize) as *const libc::c_void,
        len.wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
    );
    return new_name;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_make_section_from_shdr(
    mut abfd: *mut bfd,
    mut hdr: *mut Elf_Internal_Shdr,
    mut name: *const libc::c_char,
    mut shindex: libc::c_int,
) -> bool {
    let mut newsect: *mut asection = 0 as *mut asection;
    let mut flags: flagword = 0;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut opb: libc::c_uint = bfd_octets_per_byte(abfd, 0 as *const asection);
    if !((*hdr).bfd_section).is_null() {
        return 1 as libc::c_int != 0;
    }
    newsect = bfd_make_section_anyway(abfd, name);
    if newsect.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*hdr).bfd_section = newsect;
    (*((*newsect).used_by_bfd as *mut bfd_elf_section_data)).this_hdr = *hdr;
    (*((*newsect).used_by_bfd as *mut bfd_elf_section_data)).this_idx = shindex;
    (*((*newsect).used_by_bfd as *mut bfd_elf_section_data))
        .this_hdr
        .sh_type = (*hdr).sh_type;
    (*((*newsect).used_by_bfd as *mut bfd_elf_section_data))
        .this_hdr
        .sh_flags = (*hdr).sh_flags;
    (*newsect).filepos = (*hdr).sh_offset;
    flags = 0 as libc::c_int as flagword;
    if (*hdr).sh_type != 8 as libc::c_int as libc::c_uint {
        flags |= 0x100 as libc::c_int as libc::c_uint;
    }
    if (*hdr).sh_type == 17 as libc::c_int as libc::c_uint {
        flags |= 0x2000000 as libc::c_int as libc::c_uint;
    }
    if (*hdr).sh_flags & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
        != 0 as libc::c_int as libc::c_ulong
    {
        flags |= 0x1 as libc::c_int as libc::c_uint;
        if (*hdr).sh_type != 8 as libc::c_int as libc::c_uint {
            flags |= 0x2 as libc::c_int as libc::c_uint;
        }
    }
    if (*hdr).sh_flags & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong
        == 0 as libc::c_int as libc::c_ulong
    {
        flags |= 0x8 as libc::c_int as libc::c_uint;
    }
    if (*hdr).sh_flags & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong
        != 0 as libc::c_int as libc::c_ulong
    {
        flags |= 0x10 as libc::c_int as libc::c_uint;
    } else if flags & 0x2 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        flags |= 0x20 as libc::c_int as libc::c_uint;
    }
    if (*hdr).sh_flags & ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_ulong
        != 0 as libc::c_int as libc::c_ulong
    {
        flags |= 0x800000 as libc::c_int as libc::c_uint;
        (*newsect).entsize = (*hdr).sh_entsize as libc::c_uint;
    }
    if (*hdr).sh_flags & ((1 as libc::c_int) << 5 as libc::c_int) as libc::c_ulong
        != 0 as libc::c_int as libc::c_ulong
    {
        flags |= 0x1000000 as libc::c_int as libc::c_uint;
    }
    if (*hdr).sh_flags & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong != 0 {
        if !setup_group(abfd, hdr, newsect) {
            return 0 as libc::c_int != 0;
        }
    }
    if (*hdr).sh_flags & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
        != 0 as libc::c_int as libc::c_ulong
    {
        flags |= 0x400 as libc::c_int as libc::c_uint;
    }
    if (*hdr).sh_flags & 0x80000000 as libc::c_uint as libc::c_ulong
        != 0 as libc::c_int as libc::c_ulong
    {
        flags |= 0x8000 as libc::c_int as libc::c_uint;
    }
    let mut current_block_43: u64;
    match (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[7 as libc::c_int as usize] as libc::c_int
    {
        3 | 9 => {
            if (*hdr).sh_flags
                & ((1 as libc::c_int) << 21 as libc::c_int) as libc::c_ulong
                != 0 as libc::c_int as libc::c_ulong
            {
                (*(*abfd).tdata.elf_obj_data)
                    .set_has_gnu_osabi(
                        (*(*abfd).tdata.elf_obj_data).has_gnu_osabi()
                            | elf_gnu_osabi_retain as libc::c_int as elf_gnu_osabi,
                    );
            }
            current_block_43 = 16832770566744101373;
        }
        0 => {
            current_block_43 = 16832770566744101373;
        }
        _ => {
            current_block_43 = 8180496224585318153;
        }
    }
    match current_block_43 {
        16832770566744101373 => {
            if (*hdr).sh_flags & 0x1000000 as libc::c_int as libc::c_ulong
                != 0 as libc::c_int as libc::c_ulong
            {
                (*(*abfd).tdata.elf_obj_data)
                    .set_has_gnu_osabi(
                        (*(*abfd).tdata.elf_obj_data).has_gnu_osabi()
                            | elf_gnu_osabi_mbind as libc::c_int as elf_gnu_osabi,
                    );
            }
        }
        _ => {}
    }
    if flags & 0x1 as libc::c_int as libc::c_uint == 0 as libc::c_int as libc::c_uint {
        if *name.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32 {
            if startswith(name, b".debug\0" as *const u8 as *const libc::c_char)
                as libc::c_int != 0
                || startswith(
                    name,
                    b".gnu.debuglto_.debug_\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
                || startswith(
                    name,
                    b".gnu.linkonce.wi.\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
                || startswith(name, b".zdebug\0" as *const u8 as *const libc::c_char)
                    as libc::c_int != 0
            {
                flags
                    |= (0x2000 as libc::c_int | 0x40000000 as libc::c_int)
                        as libc::c_uint;
            } else if startswith(
                name,
                b".gnu.build.attributes\0" as *const u8 as *const libc::c_char,
            ) as libc::c_int != 0
                || startswith(name, b".note.gnu\0" as *const u8 as *const libc::c_char)
                    as libc::c_int != 0
            {
                flags |= 0x40000000 as libc::c_int as libc::c_uint;
                opb = 1 as libc::c_int as libc::c_uint;
            } else if startswith(name, b".line\0" as *const u8 as *const libc::c_char)
                as libc::c_int != 0
                || startswith(name, b".stab\0" as *const u8 as *const libc::c_char)
                    as libc::c_int != 0
                || strcmp(name, b".gdb_index\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
            {
                flags |= 0x2000 as libc::c_int as libc::c_uint;
            }
        }
    }
    if !bfd_set_section_vma(newsect, ((*hdr).sh_addr).wrapping_div(opb as libc::c_ulong))
        || !bfd_set_section_size(newsect, (*hdr).sh_size)
        || !bfd_set_section_alignment(newsect, bfd_log2((*hdr).sh_addralign))
    {
        return 0 as libc::c_int != 0;
    }
    if startswith(name, b".gnu.linkonce\0" as *const u8 as *const libc::c_char)
        as libc::c_int != 0
        && ((*((*newsect).used_by_bfd as *mut bfd_elf_section_data)).next_in_group)
            .is_null()
    {
        flags |= (0x20000 as libc::c_int | 0 as libc::c_int) as libc::c_uint;
    }
    if !bfd_set_section_flags(newsect, flags) {
        return 0 as libc::c_int != 0;
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if ((*bed).elf_backend_section_flags).is_some() {
        if !((*bed).elf_backend_section_flags).expect("non-null function pointer")(hdr) {
            return 0 as libc::c_int != 0;
        }
    }
    if (*hdr).sh_type == 7 as libc::c_int as libc::c_uint {
        let mut contents: *mut bfd_byte = 0 as *mut bfd_byte;
        if !bfd_malloc_and_get_section(abfd, newsect, &mut contents) {
            return 0 as libc::c_int != 0;
        }
        elf_parse_notes(
            abfd,
            contents as *mut libc::c_char,
            (*hdr).sh_size,
            (*hdr).sh_offset,
            (*hdr).sh_addralign,
        );
        free(contents as *mut libc::c_void);
    }
    if (*newsect).flags & 0x1 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        let mut phdr: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
        let mut i: libc::c_uint = 0;
        let mut nload: libc::c_uint = 0;
        phdr = (*(*abfd).tdata.elf_obj_data).phdr;
        nload = 0 as libc::c_int as libc::c_uint;
        i = 0 as libc::c_int as libc::c_uint;
        while i < (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum {
            if (*phdr).p_paddr != 0 as libc::c_int as libc::c_ulong {
                break;
            }
            if (*phdr).p_type == 1 as libc::c_int as libc::c_ulong
                && (*phdr).p_memsz != 0 as libc::c_int as libc::c_ulong
            {
                nload = nload.wrapping_add(1);
                nload;
            }
            i = i.wrapping_add(1);
            i;
            phdr = phdr.offset(1);
            phdr;
        }
        if i >= (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum
            && nload > 1 as libc::c_int as libc::c_uint
        {
            return 1 as libc::c_int != 0;
        }
        phdr = (*(*abfd).tdata.elf_obj_data).phdr;
        i = 0 as libc::c_int as libc::c_uint;
        while i < (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum {
            if ((*phdr).p_type == 1 as libc::c_int as libc::c_ulong
                && (*hdr).sh_flags
                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                    == 0 as libc::c_int as libc::c_ulong
                || (*phdr).p_type == 7 as libc::c_int as libc::c_ulong)
                && (((*hdr).sh_flags
                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                    && ((*phdr).p_type == 7 as libc::c_int as libc::c_ulong
                        || (*phdr).p_type
                            == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                as libc::c_ulong
                        || (*phdr).p_type == 1 as libc::c_int as libc::c_ulong)
                    || (*hdr).sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        == 0 as libc::c_int as libc::c_ulong
                        && (*phdr).p_type != 7 as libc::c_int as libc::c_ulong
                        && (*phdr).p_type != 6 as libc::c_int as libc::c_ulong)
                    && !((*hdr).sh_flags
                        & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                        == 0 as libc::c_int as libc::c_ulong
                        && ((*phdr).p_type == 1 as libc::c_int as libc::c_ulong
                            || (*phdr).p_type == 2 as libc::c_int as libc::c_ulong
                            || (*phdr).p_type
                                == (0x60000000 as libc::c_int + 0x474e550 as libc::c_int)
                                    as libc::c_ulong
                            || (*phdr).p_type
                                == (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                                    as libc::c_ulong
                            || (*phdr).p_type
                                == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                    as libc::c_ulong
                            || (*phdr).p_type
                                >= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int)
                                    as libc::c_ulong
                                && (*phdr).p_type
                                    <= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int
                                        + 4096 as libc::c_int - 1 as libc::c_int) as libc::c_ulong))
                    && ((*hdr).sh_type == 8 as libc::c_int as libc::c_uint
                        || (*hdr).sh_offset as bfd_vma >= (*phdr).p_offset
                            && (0 as libc::c_int == 0
                                || ((*hdr).sh_offset as libc::c_ulong)
                                    .wrapping_sub((*phdr).p_offset)
                                    <= ((*phdr).p_filesz)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            && ((*hdr).sh_offset as libc::c_ulong)
                                .wrapping_sub((*phdr).p_offset)
                                .wrapping_add(
                                    if (*hdr).sh_flags
                                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                        != 0 as libc::c_int as libc::c_ulong
                                        && (*hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                        && (*phdr).p_type != 7 as libc::c_int as libc::c_ulong
                                    {
                                        0 as libc::c_int as libc::c_ulong
                                    } else {
                                        (*hdr).sh_size
                                    },
                                ) <= (*phdr).p_filesz)
                    && (1 as libc::c_int == 0
                        || (*hdr).sh_flags
                            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                            == 0 as libc::c_int as libc::c_ulong
                        || (*hdr).sh_addr >= (*phdr).p_vaddr
                            && (0 as libc::c_int == 0
                                || ((*hdr).sh_addr).wrapping_sub((*phdr).p_vaddr)
                                    <= ((*phdr).p_memsz)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            && ((*hdr).sh_addr)
                                .wrapping_sub((*phdr).p_vaddr)
                                .wrapping_add(
                                    if (*hdr).sh_flags
                                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                        != 0 as libc::c_int as libc::c_ulong
                                        && (*hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                        && (*phdr).p_type != 7 as libc::c_int as libc::c_ulong
                                    {
                                        0 as libc::c_int as libc::c_ulong
                                    } else {
                                        (*hdr).sh_size
                                    },
                                ) <= (*phdr).p_memsz)
                    && ((*phdr).p_type != 2 as libc::c_int as libc::c_ulong
                        && (*phdr).p_type != 4 as libc::c_int as libc::c_ulong
                        || (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong
                        || (*phdr).p_memsz == 0 as libc::c_int as libc::c_ulong
                        || ((*hdr).sh_type == 8 as libc::c_int as libc::c_uint
                            || (*hdr).sh_offset as bfd_vma > (*phdr).p_offset
                                && ((*hdr).sh_offset as libc::c_ulong)
                                    .wrapping_sub((*phdr).p_offset) < (*phdr).p_filesz)
                            && ((*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                == 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_addr > (*phdr).p_vaddr
                                    && ((*hdr).sh_addr).wrapping_sub((*phdr).p_vaddr)
                                        < (*phdr).p_memsz)))
            {
                if (*newsect).flags & 0x2 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    (*newsect)
                        .lma = ((*phdr).p_paddr)
                        .wrapping_add((*hdr).sh_addr)
                        .wrapping_sub((*phdr).p_vaddr)
                        .wrapping_div(opb as libc::c_ulong);
                } else {
                    (*newsect)
                        .lma = ((*phdr).p_paddr)
                        .wrapping_add((*hdr).sh_offset as libc::c_ulong)
                        .wrapping_sub((*phdr).p_offset)
                        .wrapping_div(opb as libc::c_ulong);
                }
                if (*hdr).sh_addr >= (*phdr).p_vaddr
                    && ((*hdr).sh_addr).wrapping_add((*hdr).sh_size)
                        <= ((*phdr).p_vaddr).wrapping_add((*phdr).p_memsz)
                {
                    break;
                }
            }
            i = i.wrapping_add(1);
            i;
            phdr = phdr.offset(1);
            phdr;
        }
    }
    if (*newsect).flags & 0x2000 as libc::c_int as libc::c_uint != 0
        && (*name.offset(1 as libc::c_int as isize) as libc::c_int == 'd' as i32
            && *name.offset(6 as libc::c_int as isize) as libc::c_int == '_' as i32
            || *name.offset(1 as libc::c_int as isize) as libc::c_int == 'z' as i32
                && *name.offset(7 as libc::c_int as isize) as libc::c_int == '_' as i32)
    {
        let mut action: C2RustUnnamed_29 = nothing;
        let mut compression_header_size: libc::c_int = 0;
        let mut uncompressed_size: bfd_size_type = 0;
        let mut uncompressed_align_power: libc::c_uint = 0;
        let mut compressed: bool = bfd_is_section_compressed_with_header(
            abfd,
            newsect,
            &mut compression_header_size,
            &mut uncompressed_size,
            &mut uncompressed_align_power,
        );
        if compressed {
            if (*abfd).flags & 0x8000 as libc::c_int as libc::c_uint != 0 {
                action = decompress;
            }
        }
        if action as libc::c_uint == nothing as libc::c_int as libc::c_uint {
            if (*newsect).size != 0 as libc::c_int as libc::c_ulong
                && (*abfd).flags & 0x4000 as libc::c_int as libc::c_uint != 0
                && compression_header_size >= 0 as libc::c_int
                && uncompressed_size > 0 as libc::c_int as libc::c_ulong
                && (!compressed
                    || (compression_header_size > 0 as libc::c_int) as libc::c_int
                        != ((*abfd).flags & 0x20000 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint) as libc::c_int)
            {
                action = compress;
            } else {
                return 1 as libc::c_int != 0
            }
        }
        if action as libc::c_uint == compress as libc::c_int as libc::c_uint {
            if !bfd_init_section_compress_status(abfd, newsect) {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB: unable to initialize compress status for section %s\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abfd,
                    name,
                );
                return 0 as libc::c_int != 0;
            }
        } else if !bfd_init_section_decompress_status(abfd, newsect) {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: unable to initialize decompress status for section %s\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                name,
            );
            return 0 as libc::c_int != 0;
        }
        if (*abfd).is_linker_input() != 0 {
            if *name.offset(1 as libc::c_int as isize) as libc::c_int == 'z' as i32
                && (action as libc::c_uint == decompress as libc::c_int as libc::c_uint
                    || action as libc::c_uint == compress as libc::c_int as libc::c_uint
                        && (*abfd).flags & 0x20000 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint)
            {
                let mut new_name: *mut libc::c_char = convert_zdebug_to_debug(
                    abfd,
                    name,
                );
                if new_name.is_null() {
                    return 0 as libc::c_int != 0;
                }
                bfd_rename_section(newsect, new_name);
            }
        } else {
            (*newsect).flags |= 0x10000000 as libc::c_int as libc::c_uint;
        }
    }
    if startswith(name, b".gnu.lto_.lto.\0" as *const u8 as *const libc::c_char) {
        let mut lsection: lto_section = lto_section {
            major_version: 0,
            minor_version: 0,
            slim_object: 0,
            flags: 0,
        };
        if bfd_get_section_contents(
            abfd,
            newsect,
            &mut lsection as *mut lto_section as *mut libc::c_void,
            0 as libc::c_int as file_ptr,
            ::core::mem::size_of::<lto_section>() as libc::c_ulong,
        ) {
            (*abfd).set_lto_slim_object(lsection.slim_object as libc::c_uint);
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub static mut bfd_elf_section_type_names: [*const libc::c_char; 12] = [
    b"SHT_NULL\0" as *const u8 as *const libc::c_char,
    b"SHT_PROGBITS\0" as *const u8 as *const libc::c_char,
    b"SHT_SYMTAB\0" as *const u8 as *const libc::c_char,
    b"SHT_STRTAB\0" as *const u8 as *const libc::c_char,
    b"SHT_RELA\0" as *const u8 as *const libc::c_char,
    b"SHT_HASH\0" as *const u8 as *const libc::c_char,
    b"SHT_DYNAMIC\0" as *const u8 as *const libc::c_char,
    b"SHT_NOTE\0" as *const u8 as *const libc::c_char,
    b"SHT_NOBITS\0" as *const u8 as *const libc::c_char,
    b"SHT_REL\0" as *const u8 as *const libc::c_char,
    b"SHT_SHLIB\0" as *const u8 as *const libc::c_char,
    b"SHT_DYNSYM\0" as *const u8 as *const libc::c_char,
];
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_generic_reloc(
    mut _abfd: *mut bfd,
    mut reloc_entry: *mut arelent,
    mut symbol: *mut asymbol,
    mut _data: *mut libc::c_void,
    mut input_section: *mut asection,
    mut output_bfd: *mut bfd,
    mut _error_message: *mut *mut libc::c_char,
) -> bfd_reloc_status_type {
    if !output_bfd.is_null()
        && (*symbol).flags & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        && ((*(*reloc_entry).howto).partial_inplace() == 0
            || (*reloc_entry).addend == 0 as libc::c_int as libc::c_ulong)
    {
        (*reloc_entry)
            .address = ((*reloc_entry).address as libc::c_ulong)
            .wrapping_add((*input_section).output_offset) as bfd_size_type
            as bfd_size_type;
        return bfd_reloc_ok;
    }
    if output_bfd.is_null() && (*(*reloc_entry).howto).pc_relative() == 0
        && (*(*symbol).section).flags & 0x2000 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        && (*input_section).flags & 0x2000 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
    {
        (*reloc_entry)
            .addend = ((*reloc_entry).addend as libc::c_ulong)
            .wrapping_sub((*(*(*symbol).section).output_section).vma) as bfd_vma
            as bfd_vma;
    }
    return bfd_reloc_continue;
}
unsafe extern "C" fn section_match(
    mut a: *const Elf_Internal_Shdr,
    mut b: *const Elf_Internal_Shdr,
) -> bool {
    if (*a).sh_type != (*b).sh_type
        || ((*a).sh_flags ^ (*b).sh_flags)
            & !((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong
            != 0 as libc::c_int as libc::c_ulong
        || (*a).sh_addralign != (*b).sh_addralign || (*a).sh_entsize != (*b).sh_entsize
    {
        return 0 as libc::c_int != 0;
    }
    if (*a).sh_type == 2 as libc::c_int as libc::c_uint
        || (*a).sh_type == 3 as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    return (*a).sh_size == (*b).sh_size;
}
unsafe extern "C" fn find_link(
    mut obfd: *const bfd,
    mut iheader: *const Elf_Internal_Shdr,
    hint: libc::c_uint,
) -> libc::c_uint {
    let mut oheaders: *mut *mut Elf_Internal_Shdr = (*(*obfd).tdata.elf_obj_data)
        .elf_sect_ptr;
    let mut i: libc::c_uint = 0;
    if iheader.is_null() {
        bfd_assert(b"elf.c\0" as *const u8 as *const libc::c_char, 1373 as libc::c_int);
    }
    if hint < (*(*obfd).tdata.elf_obj_data).num_elf_sections
        && !(*oheaders.offset(hint as isize)).is_null()
        && section_match(*oheaders.offset(hint as isize), iheader) as libc::c_int != 0
    {
        return hint;
    }
    i = 1 as libc::c_int as libc::c_uint;
    while i < (*(*obfd).tdata.elf_obj_data).num_elf_sections {
        let mut oheader: *mut Elf_Internal_Shdr = *oheaders.offset(i as isize);
        if !oheader.is_null() {
            if section_match(oheader, iheader) {
                return i;
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    return 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn copy_special_section_fields(
    mut ibfd: *const bfd,
    mut obfd: *mut bfd,
    mut iheader: *const Elf_Internal_Shdr,
    mut oheader: *mut Elf_Internal_Shdr,
    secnum: libc::c_uint,
) -> bool {
    let mut bed: *const elf_backend_data = (*(*obfd).xvec).backend_data
        as *const elf_backend_data;
    let mut iheaders: *mut *const Elf_Internal_Shdr = (*(*ibfd).tdata.elf_obj_data)
        .elf_sect_ptr as *mut *const Elf_Internal_Shdr;
    let mut changed: bool = 0 as libc::c_int != 0;
    let mut sh_link: libc::c_uint = 0;
    if (*oheader).sh_type == 8 as libc::c_int as libc::c_uint {
        if (*oheader).sh_link == 0 as libc::c_int as libc::c_uint {
            (*oheader).sh_link = (*iheader).sh_link;
        }
        if (*oheader).sh_info == 0 as libc::c_int as libc::c_uint {
            (*oheader).sh_info = (*iheader).sh_info;
        }
        return 1 as libc::c_int != 0;
    }
    if ((*bed).elf_backend_copy_special_section_fields)
        .expect("non-null function pointer")(ibfd, obfd, iheader, oheader)
    {
        return 1 as libc::c_int != 0;
    }
    if (*iheader).sh_link != 0 as libc::c_int as libc::c_uint {
        if (*iheader).sh_link >= (*(*ibfd).tdata.elf_obj_data).num_elf_sections {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: invalid sh_link field (%d) in section number %d\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                ibfd,
                (*iheader).sh_link,
                secnum,
            );
            return 0 as libc::c_int != 0;
        }
        sh_link = find_link(
            obfd,
            *iheaders.offset((*iheader).sh_link as isize),
            (*iheader).sh_link,
        );
        if sh_link != 0 as libc::c_int as libc::c_uint {
            (*oheader).sh_link = sh_link;
            changed = 1 as libc::c_int != 0;
        } else {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: failed to find link section for section %d\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                obfd,
                secnum,
            );
        }
    }
    if (*iheader).sh_info != 0 {
        if (*iheader).sh_flags
            & ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong != 0
        {
            sh_link = find_link(
                obfd,
                *iheaders.offset((*iheader).sh_info as isize),
                (*iheader).sh_info,
            );
            if sh_link != 0 as libc::c_int as libc::c_uint {
                (*oheader).sh_flags
                    |= ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong;
            }
        } else {
            sh_link = (*iheader).sh_info;
        }
        if sh_link != 0 as libc::c_int as libc::c_uint {
            (*oheader).sh_info = sh_link;
            changed = 1 as libc::c_int != 0;
        } else {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: failed to find info section for section %d\0" as *const u8
                        as *const libc::c_char,
                    5 as libc::c_int,
                ),
                obfd,
                secnum,
            );
        }
    }
    return changed;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_copy_private_bfd_data(
    mut ibfd: *mut bfd,
    mut obfd: *mut bfd,
) -> bool {
    let mut iheaders: *mut *const Elf_Internal_Shdr = (*(*ibfd).tdata.elf_obj_data)
        .elf_sect_ptr as *mut *const Elf_Internal_Shdr;
    let mut oheaders: *mut *mut Elf_Internal_Shdr = (*(*obfd).tdata.elf_obj_data)
        .elf_sect_ptr;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut i: libc::c_uint = 0;
    if bfd_get_flavour(ibfd) as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || bfd_get_flavour(obfd) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    if !(*(*(*obfd).tdata.elf_obj_data).o).flags_init {
        (*((*(*obfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
            .e_flags = (*((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
            .e_flags;
        (*(*(*obfd).tdata.elf_obj_data).o).flags_init = 1 as libc::c_int != 0;
    }
    (*(*obfd).tdata.elf_obj_data).gp = (*(*ibfd).tdata.elf_obj_data).gp;
    (*((*(*obfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[7 as libc::c_int
        as usize] = (*((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[7 as libc::c_int as usize];
    if (*((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[8 as libc::c_int as usize] != 0
    {
        (*((*(*obfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
            .e_ident[8 as libc::c_int
            as usize] = (*((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
            .e_ident[8 as libc::c_int as usize];
    }
    _bfd_elf_copy_obj_attributes(ibfd, obfd);
    if iheaders.is_null() || oheaders.is_null() {
        return 1 as libc::c_int != 0;
    }
    bed = (*(*obfd).xvec).backend_data as *const elf_backend_data;
    i = 1 as libc::c_int as libc::c_uint;
    while i < (*(*obfd).tdata.elf_obj_data).num_elf_sections {
        let mut j: libc::c_uint = 0;
        let mut oheader: *mut Elf_Internal_Shdr = *oheaders.offset(i as isize);
        if !(oheader.is_null()
            || (*oheader).sh_type != 8 as libc::c_int as libc::c_uint
                && (*oheader).sh_type < 0x60000000 as libc::c_int as libc::c_uint)
        {
            if !((*oheader).sh_size == 0 as libc::c_int as libc::c_ulong
                || (*oheader).sh_info != 0 as libc::c_int as libc::c_uint
                    && (*oheader).sh_link != 0 as libc::c_int as libc::c_uint)
            {
                j = 1 as libc::c_int as libc::c_uint;
                while j < (*(*ibfd).tdata.elf_obj_data).num_elf_sections {
                    let mut iheader: *const Elf_Internal_Shdr = *iheaders
                        .offset(j as isize);
                    if !iheader.is_null() {
                        if !((*oheader).bfd_section).is_null()
                            && !((*iheader).bfd_section).is_null()
                            && !((*(*iheader).bfd_section).output_section).is_null()
                            && (*(*iheader).bfd_section).output_section
                                == (*oheader).bfd_section
                        {
                            if !copy_special_section_fields(
                                ibfd,
                                obfd,
                                iheader,
                                oheader,
                                i,
                            ) {
                                j = (*(*ibfd).tdata.elf_obj_data).num_elf_sections;
                            }
                            break;
                        }
                    }
                    j = j.wrapping_add(1);
                    j;
                }
                if !(j < (*(*ibfd).tdata.elf_obj_data).num_elf_sections) {
                    j = 1 as libc::c_int as libc::c_uint;
                    while j < (*(*ibfd).tdata.elf_obj_data).num_elf_sections {
                        let mut iheader_0: *const Elf_Internal_Shdr = *iheaders
                            .offset(j as isize);
                        if !iheader_0.is_null() {
                            if ((*oheader).sh_type == 8 as libc::c_int as libc::c_uint
                                || (*iheader_0).sh_type == (*oheader).sh_type)
                                && (*iheader_0).sh_flags
                                    & !((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong
                                    == (*oheader).sh_flags
                                        & !((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong
                                && (*iheader_0).sh_addralign == (*oheader).sh_addralign
                                && (*iheader_0).sh_entsize == (*oheader).sh_entsize
                                && (*iheader_0).sh_size == (*oheader).sh_size
                                && (*iheader_0).sh_addr == (*oheader).sh_addr
                                && ((*iheader_0).sh_info != (*oheader).sh_info
                                    || (*iheader_0).sh_link != (*oheader).sh_link)
                            {
                                if copy_special_section_fields(
                                    ibfd,
                                    obfd,
                                    iheader_0,
                                    oheader,
                                    i,
                                ) {
                                    break;
                                }
                            }
                        }
                        j = j.wrapping_add(1);
                        j;
                    }
                    if j == (*(*ibfd).tdata.elf_obj_data).num_elf_sections
                        && (*oheader).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                    {
                        ((*bed).elf_backend_copy_special_section_fields)
                            .expect(
                                "non-null function pointer",
                            )(ibfd, obfd, 0 as *const Elf_Internal_Shdr, oheader);
                    }
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_segment_type(mut p_type: libc::c_uint) -> *const libc::c_char {
    let mut pt: *const libc::c_char = 0 as *const libc::c_char;
    match p_type {
        0 => {
            pt = b"NULL\0" as *const u8 as *const libc::c_char;
        }
        1 => {
            pt = b"LOAD\0" as *const u8 as *const libc::c_char;
        }
        2 => {
            pt = b"DYNAMIC\0" as *const u8 as *const libc::c_char;
        }
        3 => {
            pt = b"INTERP\0" as *const u8 as *const libc::c_char;
        }
        4 => {
            pt = b"NOTE\0" as *const u8 as *const libc::c_char;
        }
        5 => {
            pt = b"SHLIB\0" as *const u8 as *const libc::c_char;
        }
        6 => {
            pt = b"PHDR\0" as *const u8 as *const libc::c_char;
        }
        7 => {
            pt = b"TLS\0" as *const u8 as *const libc::c_char;
        }
        1685382480 => {
            pt = b"EH_FRAME\0" as *const u8 as *const libc::c_char;
        }
        1685382481 => {
            pt = b"STACK\0" as *const u8 as *const libc::c_char;
        }
        1685382482 => {
            pt = b"RELRO\0" as *const u8 as *const libc::c_char;
        }
        _ => {
            pt = 0 as *const libc::c_char;
        }
    }
    return pt;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_print_private_bfd_data(
    mut abfd: *mut bfd,
    mut farg: *mut libc::c_void,
) -> bool {
    let mut current_block: u64;
    let mut f: *mut FILE = farg as *mut FILE;
    let mut p: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut s: *mut asection = 0 as *mut asection;
    let mut dynbuf: *mut bfd_byte = 0 as *mut bfd_byte;
    p = (*(*abfd).tdata.elf_obj_data).phdr;
    if !p.is_null() {
        let mut i: libc::c_uint = 0;
        let mut c: libc::c_uint = 0;
        fprintf(
            f,
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"\nProgram Header:\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        c = (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum;
        i = 0 as libc::c_int as libc::c_uint;
        while i < c {
            let mut pt: *const libc::c_char = get_segment_type(
                (*p).p_type as libc::c_uint,
            );
            let mut buf: [libc::c_char; 20] = [0; 20];
            if pt.is_null() {
                sprintf(
                    buf.as_mut_ptr(),
                    b"0x%lx\0" as *const u8 as *const libc::c_char,
                    (*p).p_type,
                );
                pt = buf.as_mut_ptr();
            }
            fprintf(f, b"%8s off    0x\0" as *const u8 as *const libc::c_char, pt);
            bfd_fprintf_vma(abfd, f as *mut libc::c_void, (*p).p_offset);
            fprintf(f, b" vaddr 0x\0" as *const u8 as *const libc::c_char);
            bfd_fprintf_vma(abfd, f as *mut libc::c_void, (*p).p_vaddr);
            fprintf(f, b" paddr 0x\0" as *const u8 as *const libc::c_char);
            bfd_fprintf_vma(abfd, f as *mut libc::c_void, (*p).p_paddr);
            fprintf(
                f,
                b" align 2**%u\n\0" as *const u8 as *const libc::c_char,
                bfd_log2((*p).p_align),
            );
            fprintf(f, b"         filesz 0x\0" as *const u8 as *const libc::c_char);
            bfd_fprintf_vma(abfd, f as *mut libc::c_void, (*p).p_filesz);
            fprintf(f, b" memsz 0x\0" as *const u8 as *const libc::c_char);
            bfd_fprintf_vma(abfd, f as *mut libc::c_void, (*p).p_memsz);
            fprintf(
                f,
                b" flags %c%c%c\0" as *const u8 as *const libc::c_char,
                if (*p).p_flags
                    & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                {
                    'r' as i32
                } else {
                    '-' as i32
                },
                if (*p).p_flags
                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                {
                    'w' as i32
                } else {
                    '-' as i32
                },
                if (*p).p_flags
                    & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                {
                    'x' as i32
                } else {
                    '-' as i32
                },
            );
            if (*p).p_flags
                & !(((1 as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint)
                    as libc::c_ulong != 0 as libc::c_int as libc::c_ulong
            {
                fprintf(
                    f,
                    b" %lx\0" as *const u8 as *const libc::c_char,
                    (*p).p_flags
                        & !(((1 as libc::c_int) << 2 as libc::c_int
                            | (1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint)
                            as libc::c_ulong,
                );
            }
            fprintf(f, b"\n\0" as *const u8 as *const libc::c_char);
            i = i.wrapping_add(1);
            i;
            p = p.offset(1);
            p;
        }
    }
    s = bfd_get_section_by_name(abfd, b".dynamic\0" as *const u8 as *const libc::c_char);
    if !s.is_null() {
        let mut elfsec: libc::c_uint = 0;
        let mut shlink: libc::c_ulong = 0;
        let mut extdyn: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut extdynend: *mut bfd_byte = 0 as *mut bfd_byte;
        let mut extdynsize: size_t = 0;
        let mut swap_dyn_in: Option::<
            unsafe extern "C" fn(
                *mut bfd,
                *const libc::c_void,
                *mut Elf_Internal_Dyn,
            ) -> (),
        > = None;
        fprintf(
            f,
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"\nDynamic Section:\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        if !bfd_malloc_and_get_section(abfd, s, &mut dynbuf) {
            current_block = 1589221425345162700;
        } else {
            elfsec = _bfd_elf_section_from_bfd_section(abfd, s);
            if elfsec == (0x101 as libc::c_uint).wrapping_neg() {
                current_block = 1589221425345162700;
            } else {
                shlink = (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                    .offset(elfsec as isize))
                    .sh_link as libc::c_ulong;
                extdynsize = (*(*((*(*abfd).xvec).backend_data
                    as *const elf_backend_data))
                    .s)
                    .sizeof_dyn as size_t;
                swap_dyn_in = (*(*((*(*abfd).xvec).backend_data
                    as *const elf_backend_data))
                    .s)
                    .swap_dyn_in;
                extdyn = dynbuf;
                if (*s).size < extdynsize {
                    current_block = 1589221425345162700;
                } else {
                    extdynend = extdyn.offset((*s).size as isize);
                    loop {
                        if !(extdyn <= extdynend.offset(-(extdynsize as isize))) {
                            current_block = 9343041660989783267;
                            break;
                        }
                        let mut dyn_0: Elf_Internal_Dyn = Elf_Internal_Dyn {
                            d_tag: 0,
                            d_un: C2RustUnnamed_22 { d_val: 0 },
                        };
                        let mut name: *const libc::c_char = b"\0" as *const u8
                            as *const libc::c_char;
                        let mut ab: [libc::c_char; 20] = [0; 20];
                        let mut stringp: bool = false;
                        let mut bed: *const elf_backend_data = (*(*abfd).xvec)
                            .backend_data as *const elf_backend_data;
                        (Some(swap_dyn_in.expect("non-null function pointer")))
                            .expect(
                                "non-null function pointer",
                            )(abfd, extdyn as *const libc::c_void, &mut dyn_0);
                        if dyn_0.d_tag == 0 as libc::c_int as libc::c_ulong {
                            current_block = 9343041660989783267;
                            break;
                        }
                        stringp = 0 as libc::c_int != 0;
                        match dyn_0.d_tag {
                            1 => {
                                name = b"NEEDED\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            2 => {
                                name = b"PLTRELSZ\0" as *const u8 as *const libc::c_char;
                            }
                            3 => {
                                name = b"PLTGOT\0" as *const u8 as *const libc::c_char;
                            }
                            4 => {
                                name = b"HASH\0" as *const u8 as *const libc::c_char;
                            }
                            5 => {
                                name = b"STRTAB\0" as *const u8 as *const libc::c_char;
                            }
                            6 => {
                                name = b"SYMTAB\0" as *const u8 as *const libc::c_char;
                            }
                            7 => {
                                name = b"RELA\0" as *const u8 as *const libc::c_char;
                            }
                            8 => {
                                name = b"RELASZ\0" as *const u8 as *const libc::c_char;
                            }
                            9 => {
                                name = b"RELAENT\0" as *const u8 as *const libc::c_char;
                            }
                            10 => {
                                name = b"STRSZ\0" as *const u8 as *const libc::c_char;
                            }
                            11 => {
                                name = b"SYMENT\0" as *const u8 as *const libc::c_char;
                            }
                            12 => {
                                name = b"INIT\0" as *const u8 as *const libc::c_char;
                            }
                            13 => {
                                name = b"FINI\0" as *const u8 as *const libc::c_char;
                            }
                            14 => {
                                name = b"SONAME\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            15 => {
                                name = b"RPATH\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            16 => {
                                name = b"SYMBOLIC\0" as *const u8 as *const libc::c_char;
                            }
                            17 => {
                                name = b"REL\0" as *const u8 as *const libc::c_char;
                            }
                            18 => {
                                name = b"RELSZ\0" as *const u8 as *const libc::c_char;
                            }
                            19 => {
                                name = b"RELENT\0" as *const u8 as *const libc::c_char;
                            }
                            20 => {
                                name = b"PLTREL\0" as *const u8 as *const libc::c_char;
                            }
                            21 => {
                                name = b"DEBUG\0" as *const u8 as *const libc::c_char;
                            }
                            22 => {
                                name = b"TEXTREL\0" as *const u8 as *const libc::c_char;
                            }
                            23 => {
                                name = b"JMPREL\0" as *const u8 as *const libc::c_char;
                            }
                            24 => {
                                name = b"BIND_NOW\0" as *const u8 as *const libc::c_char;
                            }
                            25 => {
                                name = b"INIT_ARRAY\0" as *const u8 as *const libc::c_char;
                            }
                            26 => {
                                name = b"FINI_ARRAY\0" as *const u8 as *const libc::c_char;
                            }
                            27 => {
                                name = b"INIT_ARRAYSZ\0" as *const u8
                                    as *const libc::c_char;
                            }
                            28 => {
                                name = b"FINI_ARRAYSZ\0" as *const u8
                                    as *const libc::c_char;
                            }
                            29 => {
                                name = b"RUNPATH\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            30 => {
                                name = b"FLAGS\0" as *const u8 as *const libc::c_char;
                            }
                            32 => {
                                name = b"PREINIT_ARRAY\0" as *const u8
                                    as *const libc::c_char;
                            }
                            33 => {
                                name = b"PREINIT_ARRAYSZ\0" as *const u8
                                    as *const libc::c_char;
                            }
                            1879047672 => {
                                name = b"CHECKSUM\0" as *const u8 as *const libc::c_char;
                            }
                            1879047673 => {
                                name = b"PLTPADSZ\0" as *const u8 as *const libc::c_char;
                            }
                            1879047674 => {
                                name = b"MOVEENT\0" as *const u8 as *const libc::c_char;
                            }
                            1879047675 => {
                                name = b"MOVESZ\0" as *const u8 as *const libc::c_char;
                            }
                            1879047676 => {
                                name = b"FEATURE\0" as *const u8 as *const libc::c_char;
                            }
                            1879047677 => {
                                name = b"POSFLAG_1\0" as *const u8 as *const libc::c_char;
                            }
                            1879047678 => {
                                name = b"SYMINSZ\0" as *const u8 as *const libc::c_char;
                            }
                            1879047679 => {
                                name = b"SYMINENT\0" as *const u8 as *const libc::c_char;
                            }
                            1879047930 => {
                                name = b"CONFIG\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            1879047931 => {
                                name = b"DEPAUDIT\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            1879047932 => {
                                name = b"AUDIT\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            1879047933 => {
                                name = b"PLTPAD\0" as *const u8 as *const libc::c_char;
                            }
                            1879047934 => {
                                name = b"MOVETAB\0" as *const u8 as *const libc::c_char;
                            }
                            1879047935 => {
                                name = b"SYMINFO\0" as *const u8 as *const libc::c_char;
                            }
                            1879048185 => {
                                name = b"RELACOUNT\0" as *const u8 as *const libc::c_char;
                            }
                            1879048186 => {
                                name = b"RELCOUNT\0" as *const u8 as *const libc::c_char;
                            }
                            1879048187 => {
                                name = b"FLAGS_1\0" as *const u8 as *const libc::c_char;
                            }
                            1879048176 => {
                                name = b"VERSYM\0" as *const u8 as *const libc::c_char;
                            }
                            1879048188 => {
                                name = b"VERDEF\0" as *const u8 as *const libc::c_char;
                            }
                            1879048189 => {
                                name = b"VERDEFNUM\0" as *const u8 as *const libc::c_char;
                            }
                            1879048190 => {
                                name = b"VERNEED\0" as *const u8 as *const libc::c_char;
                            }
                            1879048191 => {
                                name = b"VERNEEDNUM\0" as *const u8 as *const libc::c_char;
                            }
                            2147483645 => {
                                name = b"AUXILIARY\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            2147483646 => {
                                name = b"USED\0" as *const u8 as *const libc::c_char;
                            }
                            2147483647 => {
                                name = b"FILTER\0" as *const u8 as *const libc::c_char;
                                stringp = 1 as libc::c_int != 0;
                            }
                            1879047925 => {
                                name = b"GNU_HASH\0" as *const u8 as *const libc::c_char;
                            }
                            _ => {
                                if ((*bed).elf_backend_get_target_dtag).is_some() {
                                    name = (Some(
                                        ((*bed).elf_backend_get_target_dtag)
                                            .expect("non-null function pointer"),
                                    ))
                                        .expect("non-null function pointer")(dyn_0.d_tag);
                                }
                                if strcmp(name, b"\0" as *const u8 as *const libc::c_char)
                                    == 0
                                {
                                    sprintf(
                                        ab.as_mut_ptr(),
                                        b"%#lx\0" as *const u8 as *const libc::c_char,
                                        dyn_0.d_tag,
                                    );
                                    name = ab.as_mut_ptr();
                                }
                            }
                        }
                        fprintf(
                            f,
                            b"  %-20s \0" as *const u8 as *const libc::c_char,
                            name,
                        );
                        if !stringp {
                            fprintf(f, b"0x\0" as *const u8 as *const libc::c_char);
                            bfd_fprintf_vma(
                                abfd,
                                f as *mut libc::c_void,
                                dyn_0.d_un.d_val,
                            );
                        } else {
                            let mut string: *const libc::c_char = 0
                                as *const libc::c_char;
                            let mut tagv: libc::c_uint = dyn_0.d_un.d_val
                                as libc::c_uint;
                            string = bfd_elf_string_from_elf_section(
                                abfd,
                                shlink as libc::c_uint,
                                tagv,
                            );
                            if string.is_null() {
                                current_block = 1589221425345162700;
                                break;
                            }
                            fprintf(
                                f,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                string,
                            );
                        }
                        fprintf(f, b"\n\0" as *const u8 as *const libc::c_char);
                        extdyn = extdyn.offset(extdynsize as isize);
                    }
                    match current_block {
                        1589221425345162700 => {}
                        _ => {
                            free(dynbuf as *mut libc::c_void);
                            dynbuf = 0 as *mut bfd_byte;
                            current_block = 5089124893069931607;
                        }
                    }
                }
            }
        }
        match current_block {
            5089124893069931607 => {}
            _ => {
                free(dynbuf as *mut libc::c_void);
                return 0 as libc::c_int != 0;
            }
        }
    }
    if (*(*abfd).tdata.elf_obj_data).dynverdef_section
        != 0 as libc::c_int as libc::c_uint
        && ((*(*abfd).tdata.elf_obj_data).verdef).is_null()
        || (*(*abfd).tdata.elf_obj_data).dynverref_section
            != 0 as libc::c_int as libc::c_uint
            && ((*(*abfd).tdata.elf_obj_data).verref).is_null()
    {
        if !_bfd_elf_slurp_version_tables(abfd, 0 as libc::c_int != 0) {
            return 0 as libc::c_int != 0;
        }
    }
    if (*(*abfd).tdata.elf_obj_data).dynverdef_section
        != 0 as libc::c_int as libc::c_uint
    {
        let mut t: *mut Elf_Internal_Verdef = 0 as *mut Elf_Internal_Verdef;
        fprintf(
            f,
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"\nVersion definitions:\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        t = (*(*abfd).tdata.elf_obj_data).verdef;
        while !t.is_null() {
            fprintf(
                f,
                b"%d 0x%2.2x 0x%8.8lx %s\n\0" as *const u8 as *const libc::c_char,
                (*t).vd_ndx as libc::c_int,
                (*t).vd_flags as libc::c_int,
                (*t).vd_hash,
                if !((*t).vd_nodename).is_null() {
                    (*t).vd_nodename
                } else {
                    b"<corrupt>\0" as *const u8 as *const libc::c_char
                },
            );
            if !((*t).vd_auxptr).is_null() && !((*(*t).vd_auxptr).vda_nextptr).is_null()
            {
                let mut a: *mut Elf_Internal_Verdaux = 0 as *mut Elf_Internal_Verdaux;
                fprintf(f, b"\t\0" as *const u8 as *const libc::c_char);
                a = (*(*t).vd_auxptr).vda_nextptr;
                while !a.is_null() {
                    fprintf(
                        f,
                        b"%s \0" as *const u8 as *const libc::c_char,
                        if !((*a).vda_nodename).is_null() {
                            (*a).vda_nodename
                        } else {
                            b"<corrupt>\0" as *const u8 as *const libc::c_char
                        },
                    );
                    a = (*a).vda_nextptr;
                }
                fprintf(f, b"\n\0" as *const u8 as *const libc::c_char);
            }
            t = (*t).vd_nextdef;
        }
    }
    if (*(*abfd).tdata.elf_obj_data).dynverref_section
        != 0 as libc::c_int as libc::c_uint
    {
        let mut t_0: *mut Elf_Internal_Verneed = 0 as *mut Elf_Internal_Verneed;
        fprintf(
            f,
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"\nVersion References:\n\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
        );
        t_0 = (*(*abfd).tdata.elf_obj_data).verref;
        while !t_0.is_null() {
            let mut a_0: *mut Elf_Internal_Vernaux = 0 as *mut Elf_Internal_Vernaux;
            fprintf(
                f,
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"  required from %s:\n\0" as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                if !((*t_0).vn_filename).is_null() {
                    (*t_0).vn_filename
                } else {
                    b"<corrupt>\0" as *const u8 as *const libc::c_char
                },
            );
            a_0 = (*t_0).vn_auxptr;
            while !a_0.is_null() {
                fprintf(
                    f,
                    b"    0x%8.8lx 0x%2.2x %2.2d %s\n\0" as *const u8
                        as *const libc::c_char,
                    (*a_0).vna_hash,
                    (*a_0).vna_flags as libc::c_int,
                    (*a_0).vna_other as libc::c_int,
                    if !((*a_0).vna_nodename).is_null() {
                        (*a_0).vna_nodename
                    } else {
                        b"<corrupt>\0" as *const u8 as *const libc::c_char
                    },
                );
                a_0 = (*a_0).vna_nextptr;
            }
            t_0 = (*t_0).vn_nextref;
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_symbol_version_string(
    mut abfd: *mut bfd,
    mut symbol: *mut asymbol,
    mut base_p: bool,
    mut hidden: *mut bool,
) -> *const libc::c_char {
    let mut version_string: *const libc::c_char = 0 as *const libc::c_char;
    if (*(*abfd).tdata.elf_obj_data).dynversym_section
        != 0 as libc::c_int as libc::c_uint
        && ((*(*abfd).tdata.elf_obj_data).dynverdef_section
            != 0 as libc::c_int as libc::c_uint
            || (*(*abfd).tdata.elf_obj_data).dynverref_section
                != 0 as libc::c_int as libc::c_uint)
    {
        let mut vernum: libc::c_uint = (*(symbol as *mut elf_symbol_type)).version
            as libc::c_uint;
        *hidden = vernum & 0x8000 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint;
        vernum &= 0x7fff as libc::c_int as libc::c_uint;
        if vernum == 0 as libc::c_int as libc::c_uint {
            version_string = b"\0" as *const u8 as *const libc::c_char;
        } else if vernum == 1 as libc::c_int as libc::c_uint
            && (vernum > (*(*abfd).tdata.elf_obj_data).cverdefs
                || (*((*(*abfd).tdata.elf_obj_data).verdef)
                    .offset(0 as libc::c_int as isize))
                    .vd_flags as libc::c_int == 0x1 as libc::c_int)
        {
            version_string = if base_p as libc::c_int != 0 {
                b"Base\0" as *const u8 as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            };
        } else if vernum <= (*(*abfd).tdata.elf_obj_data).cverdefs {
            let mut nodename: *const libc::c_char = (*((*(*abfd).tdata.elf_obj_data)
                .verdef)
                .offset(vernum.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize))
                .vd_nodename;
            version_string = b"\0" as *const u8 as *const libc::c_char;
            if base_p as libc::c_int != 0 || nodename.is_null()
                || ((*symbol).name).is_null()
                || strcmp((*symbol).name, nodename) != 0 as libc::c_int
            {
                version_string = nodename;
            }
        } else {
            let mut t: *mut Elf_Internal_Verneed = 0 as *mut Elf_Internal_Verneed;
            version_string = dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"<corrupt>\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            );
            t = (*(*abfd).tdata.elf_obj_data).verref;
            while !t.is_null() {
                let mut a: *mut Elf_Internal_Vernaux = 0 as *mut Elf_Internal_Vernaux;
                a = (*t).vn_auxptr;
                while !a.is_null() {
                    if (*a).vna_other as libc::c_uint == vernum {
                        version_string = (*a).vna_nodename;
                        break;
                    } else {
                        a = (*a).vna_nextptr;
                    }
                }
                t = (*t).vn_nextref;
            }
        }
    }
    return version_string;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_print_symbol(
    mut abfd: *mut bfd,
    mut filep: *mut libc::c_void,
    mut symbol: *mut asymbol,
    mut how: bfd_print_symbol_type,
) {
    let mut file: *mut FILE = filep as *mut FILE;
    match how as libc::c_uint {
        0 => {
            fprintf(file, b"%s\0" as *const u8 as *const libc::c_char, (*symbol).name);
        }
        1 => {
            fprintf(file, b"elf \0" as *const u8 as *const libc::c_char);
            bfd_fprintf_vma(abfd, file as *mut libc::c_void, (*symbol).value);
            fprintf(file, b" %x\0" as *const u8 as *const libc::c_char, (*symbol).flags);
        }
        2 => {
            let mut section_name: *const libc::c_char = 0 as *const libc::c_char;
            let mut name: *const libc::c_char = 0 as *const libc::c_char;
            let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
            let mut st_other: libc::c_uchar = 0;
            let mut val: bfd_vma = 0;
            let mut version_string: *const libc::c_char = 0 as *const libc::c_char;
            let mut hidden: bool = false;
            section_name = if !((*symbol).section).is_null() {
                (*(*symbol).section).name
            } else {
                b"(*none*)\0" as *const u8 as *const libc::c_char
            };
            bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
            if ((*bed).elf_backend_print_symbol_all).is_some() {
                name = (Some(
                    ((*bed).elf_backend_print_symbol_all)
                        .expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(abfd, filep, symbol);
            }
            if name.is_null() {
                name = (*symbol).name;
                bfd_print_symbol_vandf(abfd, file as *mut libc::c_void, symbol);
            }
            fprintf(file, b" %s\t\0" as *const u8 as *const libc::c_char, section_name);
            if !((*symbol).section).is_null()
                && bfd_is_com_section((*symbol).section) as libc::c_int != 0
            {
                val = (*(symbol as *mut elf_symbol_type)).internal_elf_sym.st_value;
            } else {
                val = (*(symbol as *mut elf_symbol_type)).internal_elf_sym.st_size;
            }
            bfd_fprintf_vma(abfd, file as *mut libc::c_void, val);
            version_string = _bfd_elf_get_symbol_version_string(
                abfd,
                symbol,
                1 as libc::c_int != 0,
                &mut hidden,
            );
            if !version_string.is_null() {
                if !hidden {
                    fprintf(
                        file,
                        b"  %-11s\0" as *const u8 as *const libc::c_char,
                        version_string,
                    );
                } else {
                    let mut i: libc::c_int = 0;
                    fprintf(
                        file,
                        b" (%s)\0" as *const u8 as *const libc::c_char,
                        version_string,
                    );
                    i = (10 as libc::c_int as libc::c_ulong)
                        .wrapping_sub(strlen(version_string)) as libc::c_int;
                    while i > 0 as libc::c_int {
                        putc(' ' as i32, file);
                        i -= 1;
                        i;
                    }
                }
            }
            st_other = (*(symbol as *mut elf_symbol_type)).internal_elf_sym.st_other;
            match st_other as libc::c_int {
                0 => {}
                1 => {
                    fprintf(file, b" .internal\0" as *const u8 as *const libc::c_char);
                }
                2 => {
                    fprintf(file, b" .hidden\0" as *const u8 as *const libc::c_char);
                }
                3 => {
                    fprintf(file, b" .protected\0" as *const u8 as *const libc::c_char);
                }
                _ => {
                    fprintf(
                        file,
                        b" 0x%02x\0" as *const u8 as *const libc::c_char,
                        st_other as libc::c_uint,
                    );
                }
            }
            fprintf(file, b" %s\0" as *const u8 as *const libc::c_char, name);
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn bfd_section_from_shdr(
    mut abfd: *mut bfd,
    mut shindex: libc::c_uint,
) -> bool {
    let mut current_block: u64;
    let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut ehdr: *mut Elf_Internal_Ehdr = 0 as *mut Elf_Internal_Ehdr;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut ret: bool = 1 as libc::c_int != 0;
    if shindex >= (*(*abfd).tdata.elf_obj_data).num_elf_sections {
        return 0 as libc::c_int != 0;
    }
    if *((*(*abfd).tdata.elf_obj_data).being_created).offset(shindex as isize) != 0 {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: warning: loop in section dependencies detected\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
        );
        return 0 as libc::c_int != 0;
    }
    *((*(*abfd).tdata.elf_obj_data).being_created)
        .offset(shindex as isize) = 1 as libc::c_int as libc::c_uchar;
    hdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr).offset(shindex as isize);
    ehdr = ((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr();
    name = bfd_elf_string_from_elf_section(abfd, (*ehdr).e_shstrndx, (*hdr).sh_name);
    if name.is_null() {
        current_block = 10695972253283192696;
    } else {
        bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
        match (*hdr).sh_type {
            0 => {
                current_block = 3452655618864563377;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            1 => {
                current_block = 989657623022141796;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            8 => {
                current_block = 17907968148454622562;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            5 => {
                current_block = 6127088460976951292;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            7 => {
                current_block = 15384943048769972658;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            14 => {
                current_block = 8424152728259710616;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            15 => {
                current_block = 18006174008171024618;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            16 => {
                current_block = 5495064098325561391;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            1879048183 | 1879048182 => {
                current_block = 12240754414610395687;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            6 => {
                current_block = 1278593570178231916;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            2 => {
                current_block = 16002996352208026731;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            11 => {
                current_block = 4586132807052707276;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            18 => {
                current_block = 4746626699541760585;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            3 => {
                current_block = 18068747621716396018;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            9 | 4 => {
                current_block = 4804377075063615140;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            1879048189 => {
                current_block = 9213847233065829893;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            1879048191 => {
                current_block = 16712706016264835665;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            1879048190 => {
                current_block = 2255898549154743461;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            10 => {
                current_block = 12411140617278309634;
            }
            17 => {
                current_block = 16590085851696370826;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
            _ => {
                current_block = 10479481364292988405;
                match current_block {
                    10479481364292988405 => {
                        if (*hdr).sh_type == 0x6ffffff5 as libc::c_int as libc::c_uint
                            || (*hdr).sh_type == (*bed).obj_attrs_section_type
                        {
                            if !_bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            ) {
                                current_block = 10695972253283192696;
                            } else {
                                _bfd_elf_parse_attributes(abfd, hdr);
                                current_block = 12411140617278309634;
                            }
                        } else if ((*bed).elf_backend_section_from_shdr)
                            .expect(
                                "non-null function pointer",
                            )(abfd, hdr, name, shindex as libc::c_int)
                        {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_type >= 0x80000000 as libc::c_uint
                            && (*hdr).sh_type <= 0xffffffff as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else if (*hdr).sh_type
                            >= 0x70000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x7fffffff as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_type
                            >= 0x60000000 as libc::c_int as libc::c_uint
                            && (*hdr).sh_type
                                <= 0x6fffffff as libc::c_int as libc::c_uint
                        {
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                            as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    (*hdr).sh_type,
                                    name,
                                );
                                current_block = 10695972253283192696;
                            } else {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            }
                        } else {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: unknown type [%#x] section `%s'\0" as *const u8
                                        as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_type,
                                name,
                            );
                            current_block = 10695972253283192696;
                        }
                    }
                    16590085851696370826 => {
                        if !((*hdr).sh_type == 17 as libc::c_int as libc::c_uint
                            && (*hdr).sh_size >= 4 as libc::c_int as libc::c_ulong
                            && (*hdr).sh_entsize == 4 as libc::c_int as libc::c_ulong
                            && ((*hdr).sh_size)
                                .wrapping_rem(4 as libc::c_int as libc::c_ulong)
                                == 0 as libc::c_int as libc::c_ulong)
                        {
                            current_block = 10695972253283192696;
                        } else if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else {
                            current_block = 12411140617278309634;
                        }
                    }
                    2255898549154743461 => {
                        (*(*abfd).tdata.elf_obj_data).dynverref_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverref_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    16712706016264835665 => {
                        if (*hdr).sh_entsize
                            != ::core::mem::size_of::<Elf_External_Versym>()
                                as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).dynversym_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).dynversym_hdr = *hdr;
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        }
                    }
                    9213847233065829893 => {
                        (*(*abfd).tdata.elf_obj_data).dynverdef_section = shindex;
                        (*(*abfd).tdata.elf_obj_data).dynverdef_hdr = *hdr;
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                    4804377075063615140 => {
                        let mut target_sect: *mut asection = 0 as *mut asection;
                        let mut hdr2_2: *mut Elf_Internal_Shdr = 0
                            as *mut Elf_Internal_Shdr;
                        let mut p_hdr: *mut *mut Elf_Internal_Shdr = 0
                            as *mut *mut Elf_Internal_Shdr;
                        let mut num_sec_2: libc::c_uint = (*(*abfd).tdata.elf_obj_data)
                            .num_elf_sections;
                        let mut esdt: *mut bfd_elf_section_data = 0
                            as *mut bfd_elf_section_data;
                        if (*hdr).sh_entsize
                            != (if (*hdr).sh_type == 9 as libc::c_int as libc::c_uint {
                                (*(*bed).s).sizeof_rel as libc::c_int
                            } else {
                                (*(*bed).s).sizeof_rela as libc::c_int
                            }) as bfd_size_type
                        {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link >= num_sec_2 {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: invalid link %u for reloc section %s (index %u)\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                (*hdr).sh_link,
                                name,
                                shindex,
                            );
                            ret = _bfd_elf_make_section_from_shdr(
                                abfd,
                                hdr,
                                name,
                                shindex as libc::c_int,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 2 as libc::c_int as libc::c_uint
                                && (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type != 11 as libc::c_int as libc::c_uint
                            {
                                let mut scan: libc::c_uint = 0;
                                let mut found: libc::c_int = 0;
                                found = 0 as libc::c_int;
                                scan = 1 as libc::c_int as libc::c_uint;
                                while scan < num_sec_2 {
                                    if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(scan as isize))
                                        .sh_type == 2 as libc::c_int as libc::c_uint
                                        || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(scan as isize))
                                            .sh_type == 11 as libc::c_int as libc::c_uint
                                    {
                                        if found != 0 as libc::c_int {
                                            found = 0 as libc::c_int;
                                            break;
                                        } else {
                                            found = scan as libc::c_int;
                                        }
                                    }
                                    scan = scan.wrapping_add(1);
                                    scan;
                                }
                                if found != 0 as libc::c_int {
                                    (*hdr).sh_link = found as libc::c_uint;
                                }
                            }
                            if ((**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type == 2 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_link as isize))
                                    .sh_type == 11 as libc::c_int as libc::c_uint)
                                && !bfd_section_from_shdr(abfd, (*hdr).sh_link)
                            {
                                current_block = 10695972253283192696;
                            } else if (*abfd).flags
                                & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                                && (*hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                || (*hdr).sh_link == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_link
                                    != (*(*abfd).tdata.elf_obj_data).symtab_section
                                || (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
                                || (*hdr).sh_info >= num_sec_2
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 9 as libc::c_int as libc::c_uint
                                || (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset((*hdr).sh_info as isize))
                                    .sh_type == 4 as libc::c_int as libc::c_uint
                            {
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                                current_block = 12411140617278309634;
                            } else if !bfd_section_from_shdr(abfd, (*hdr).sh_info) {
                                current_block = 10695972253283192696;
                            } else {
                                target_sect = bfd_section_from_elf_index(
                                    abfd,
                                    (*hdr).sh_info,
                                );
                                if target_sect.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    esdt = (*target_sect).used_by_bfd
                                        as *mut bfd_elf_section_data;
                                    if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                        p_hdr = &mut (*esdt).rela.hdr;
                                    } else {
                                        p_hdr = &mut (*esdt).rel.hdr;
                                    }
                                    if !(*p_hdr).is_null() {
                                        if !((*bed).init_secondary_reloc_section)
                                            .expect(
                                                "non-null function pointer",
                                            )(abfd, hdr, name, shindex)
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: warning: secondary relocation section '%s' for section %pA found - ignoring\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                name,
                                                target_sect,
                                            );
                                        } else {
                                            (*esdt).has_secondary_relocs = 1 as libc::c_int != 0;
                                        }
                                        current_block = 12411140617278309634;
                                    } else {
                                        hdr2_2 = bfd_alloc(
                                            abfd,
                                            ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
                                        ) as *mut Elf_Internal_Shdr;
                                        if hdr2_2.is_null() {
                                            current_block = 10695972253283192696;
                                        } else {
                                            *hdr2_2 = *hdr;
                                            *p_hdr = hdr2_2;
                                            let ref mut fresh20 = *((*(*abfd).tdata.elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(shindex as isize);
                                            *fresh20 = hdr2_2;
                                            (*target_sect)
                                                .reloc_count = ((*target_sect).reloc_count as libc::c_ulong)
                                                .wrapping_add(
                                                    (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                                                        ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                                                    } else {
                                                        0 as libc::c_int as libc::c_ulong
                                                    })
                                                        .wrapping_mul(
                                                            (*(*bed).s).int_rels_per_ext_rel as libc::c_ulong,
                                                        ),
                                                ) as libc::c_uint as libc::c_uint;
                                            (*target_sect).flags |= 0x4 as libc::c_int as libc::c_uint;
                                            (*target_sect).relocation = 0 as *mut reloc_cache_entry;
                                            (*target_sect).rel_filepos = (*hdr).sh_offset;
                                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                                if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint {
                                                    (*target_sect)
                                                        .set_use_rela_p(1 as libc::c_int as libc::c_uint);
                                                }
                                            }
                                            (*abfd).flags |= 0x1 as libc::c_int as libc::c_uint;
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    18068747621716396018 => {
                        if !((*hdr).bfd_section).is_null() {
                            current_block = 12411140617278309634;
                        } else if (*ehdr).e_shstrndx == shindex {
                            (*(*abfd).tdata.elf_obj_data).shstrtab_hdr = *hdr;
                            let ref mut fresh17 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh17 = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
                            current_block = 12411140617278309634;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset(
                                    (*(*abfd).tdata.elf_obj_data).symtab_section as isize,
                                ))
                                .sh_link == shindex
                            {
                                current_block = 6723411834872699216;
                            } else {
                                if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                    .offset(
                                        (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                    ))
                                    .sh_link == shindex
                                {
                                    current_block = 896636745168647018;
                                } else {
                                    if (*(*abfd).tdata.elf_obj_data).symtab_section
                                        == 0 as libc::c_int as libc::c_uint
                                        || (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                            == 0 as libc::c_int as libc::c_uint
                                    {
                                        let mut i_1: libc::c_uint = 0;
                                        let mut num_sec_1: libc::c_uint = 0;
                                        num_sec_1 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_1 = 1 as libc::c_int as libc::c_uint;
                                        loop {
                                            if !(i_1 < num_sec_1) {
                                                current_block = 9521147444787763968;
                                                break;
                                            }
                                            let mut hdr2_1: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_1 as isize);
                                            if (*hdr2_1).sh_link == shindex {
                                                if i_1 == shindex {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if !bfd_section_from_shdr(abfd, i_1) {
                                                    current_block = 10695972253283192696;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).symtab_section == i_1 {
                                                    current_block = 6723411834872699216;
                                                    break;
                                                }
                                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == i_1 {
                                                    current_block = 896636745168647018;
                                                    break;
                                                }
                                            }
                                            i_1 = i_1.wrapping_add(1);
                                            i_1;
                                        }
                                    } else {
                                        current_block = 9521147444787763968;
                                    }
                                    match current_block {
                                        896636745168647018 => {}
                                        6723411834872699216 => {}
                                        10695972253283192696 => {}
                                        _ => {
                                            ret = _bfd_elf_make_section_from_shdr(
                                                abfd,
                                                hdr,
                                                name,
                                                shindex as libc::c_int,
                                            );
                                            current_block = 12411140617278309634;
                                        }
                                    }
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    6723411834872699216 => {}
                                    10695972253283192696 => {}
                                    _ => {
                                        (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr = *hdr;
                                        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynstrtab_hdr;
                                        let ref mut fresh19 = *((*(*abfd).tdata.elf_obj_data)
                                            .elf_sect_ptr)
                                            .offset(shindex as isize);
                                        *fresh19 = hdr;
                                        ret = _bfd_elf_make_section_from_shdr(
                                            abfd,
                                            hdr,
                                            name,
                                            shindex as libc::c_int,
                                        );
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                            match current_block {
                                12411140617278309634 => {}
                                10695972253283192696 => {}
                                _ => {
                                    (*(*abfd).tdata.elf_obj_data).strtab_hdr = *hdr;
                                    let ref mut fresh18 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh18 = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4746626699541760585 => {
                        let mut entry_0: *mut elf_section_list = 0
                            as *mut elf_section_list;
                        entry_0 = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                        loop {
                            if entry_0.is_null() {
                                current_block = 5793491756164225964;
                                break;
                            }
                            if (*entry_0).ndx == shindex {
                                current_block = 12411140617278309634;
                                break;
                            }
                            entry_0 = (*entry_0).next;
                        }
                        match current_block {
                            12411140617278309634 => {}
                            _ => {
                                entry_0 = bfd_alloc(
                                    abfd,
                                    ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
                                ) as *mut elf_section_list;
                                if entry_0.is_null() {
                                    current_block = 10695972253283192696;
                                } else {
                                    (*entry_0).ndx = shindex;
                                    (*entry_0).hdr = *hdr;
                                    (*entry_0)
                                        .next = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                    (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry_0;
                                    let ref mut fresh16 = *((*(*abfd).tdata.elf_obj_data)
                                        .elf_sect_ptr)
                                        .offset(shindex as isize);
                                    *fresh16 = &mut (*entry_0).hdr;
                                    current_block = 12411140617278309634;
                                }
                            }
                        }
                    }
                    4586132807052707276 => {
                        if (*(*abfd).tdata.elf_obj_data).dynsymtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else {
                            if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                != 0 as libc::c_int as libc::c_uint
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB: warning: multiple dynamic symbol tables detected - ignoring the table in section %u\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    shindex,
                                );
                            } else {
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_section = shindex;
                                (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr = *hdr;
                                hdr = &mut (*(*abfd).tdata.elf_obj_data).dynsymtab_hdr;
                                let ref mut fresh15 = *((*(*abfd).tdata.elf_obj_data)
                                    .elf_sect_ptr)
                                    .offset(shindex as isize);
                                *fresh15 = hdr;
                                (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                                ret = _bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                );
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    16002996352208026731 => {
                        if (*(*abfd).tdata.elf_obj_data).symtab_section == shindex {
                            current_block = 12411140617278309634;
                        } else if (*hdr).sh_entsize
                            != (*(*bed).s).sizeof_sym as libc::c_ulong
                        {
                            current_block = 10695972253283192696;
                        } else if ((*hdr).sh_info as libc::c_ulong)
                            .wrapping_mul((*hdr).sh_entsize) > (*hdr).sh_size
                        {
                            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                                current_block = 10695972253283192696;
                            } else {
                                (*hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                                current_block = 12411140617278309634;
                            }
                        } else if (*(*abfd).tdata.elf_obj_data).symtab_section
                            != 0 as libc::c_int as libc::c_uint
                        {
                            _bfd_error_handler(
                                dcgettext(
                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                    b"%pB: warning: multiple symbol tables detected - ignoring the table in section %u\0"
                                        as *const u8 as *const libc::c_char,
                                    5 as libc::c_int,
                                ),
                                abfd,
                                shindex,
                            );
                            current_block = 12411140617278309634;
                        } else {
                            (*(*abfd).tdata.elf_obj_data).symtab_section = shindex;
                            (*(*abfd).tdata.elf_obj_data).symtab_hdr = *hdr;
                            hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
                            let ref mut fresh14 = *((*(*abfd).tdata.elf_obj_data)
                                .elf_sect_ptr)
                                .offset(shindex as isize);
                            *fresh14 = hdr;
                            (*abfd).flags |= 0x10 as libc::c_int as libc::c_uint;
                            if (*hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                                && (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                && !_bfd_elf_make_section_from_shdr(
                                    abfd,
                                    hdr,
                                    name,
                                    shindex as libc::c_int,
                                )
                            {
                                current_block = 10695972253283192696;
                            } else {
                                let mut entry: *mut elf_section_list = 0
                                    as *mut elf_section_list;
                                let mut i_0: libc::c_uint = 0;
                                let mut num_sec_0: libc::c_uint = 0;
                                entry = (*(*abfd).tdata.elf_obj_data).symtab_shndx_list;
                                loop {
                                    if entry.is_null() {
                                        current_block = 5141539773904409130;
                                        break;
                                    }
                                    if (*entry).hdr.sh_link == shindex {
                                        current_block = 12411140617278309634;
                                        break;
                                    }
                                    entry = (*entry).next;
                                }
                                match current_block {
                                    12411140617278309634 => {}
                                    _ => {
                                        num_sec_0 = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                        i_0 = shindex
                                            .wrapping_add(1 as libc::c_int as libc::c_uint);
                                        while i_0 < num_sec_0 {
                                            let mut hdr2: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                .tdata
                                                .elf_obj_data)
                                                .elf_sect_ptr)
                                                .offset(i_0 as isize);
                                            if (*hdr2).sh_type == 18 as libc::c_int as libc::c_uint
                                                && (*hdr2).sh_link == shindex
                                            {
                                                break;
                                            }
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        if i_0 == num_sec_0 {
                                            i_0 = 1 as libc::c_int as libc::c_uint;
                                            while i_0 < shindex {
                                                let mut hdr2_0: *mut Elf_Internal_Shdr = *((*(*abfd)
                                                    .tdata
                                                    .elf_obj_data)
                                                    .elf_sect_ptr)
                                                    .offset(i_0 as isize);
                                                if (*hdr2_0).sh_type == 18 as libc::c_int as libc::c_uint
                                                    && (*hdr2_0).sh_link == shindex
                                                {
                                                    break;
                                                }
                                                i_0 = i_0.wrapping_add(1);
                                                i_0;
                                            }
                                        }
                                        if i_0 != shindex {
                                            ret = bfd_section_from_shdr(abfd, i_0);
                                        }
                                        current_block = 12411140617278309634;
                                    }
                                }
                            }
                        }
                    }
                    1278593570178231916 => {
                        if !_bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        ) {
                            current_block = 10695972253283192696;
                        } else if (*hdr).sh_link
                            > (*(*abfd).tdata.elf_obj_data).num_elf_sections
                        {
                            match bfd_get_arch(abfd) as libc::c_uint {
                                8 | 5 => {
                                    if (*hdr).sh_link
                                        == (0x100 as libc::c_uint).wrapping_neg()
                                            & 0xffff as libc::c_int as libc::c_uint
                                        || (*hdr).sh_link
                                            == (0x100 as libc::c_uint)
                                                .wrapping_neg()
                                                .wrapping_add(1 as libc::c_int as libc::c_uint)
                                                & 0xffff as libc::c_int as libc::c_uint
                                    {
                                        current_block = 12411140617278309634;
                                    } else {
                                        current_block = 10695972253283192696;
                                    }
                                }
                                _ => {
                                    current_block = 10695972253283192696;
                                }
                            }
                        } else if (*((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                            .offset((*hdr).sh_link as isize))
                            .is_null()
                        {
                            current_block = 10695972253283192696;
                        } else {
                            if (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                .offset((*hdr).sh_link as isize))
                                .sh_type != 3 as libc::c_int as libc::c_uint
                            {
                                let mut dynsymhdr: *mut Elf_Internal_Shdr = 0
                                    as *mut Elf_Internal_Shdr;
                                if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                        .offset(
                                            (*(*abfd).tdata.elf_obj_data).dynsymtab_section as isize,
                                        );
                                    (*hdr).sh_link = (*dynsymhdr).sh_link;
                                } else {
                                    let mut i: libc::c_uint = 0;
                                    let mut num_sec: libc::c_uint = 0;
                                    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
                                    i = 1 as libc::c_int as libc::c_uint;
                                    while i < num_sec {
                                        dynsymhdr = *((*(*abfd).tdata.elf_obj_data).elf_sect_ptr)
                                            .offset(i as isize);
                                        if (*dynsymhdr).sh_type == 11 as libc::c_int as libc::c_uint
                                        {
                                            (*hdr).sh_link = (*dynsymhdr).sh_link;
                                            break;
                                        } else {
                                            i = i.wrapping_add(1);
                                            i;
                                        }
                                    }
                                }
                            }
                            current_block = 12411140617278309634;
                        }
                    }
                    3452655618864563377 => {
                        current_block = 12411140617278309634;
                    }
                    989657623022141796 => {
                        current_block = 17907968148454622562;
                    }
                    _ => {}
                }
                match current_block {
                    10695972253283192696 => {}
                    12411140617278309634 => {}
                    _ => {
                        match current_block {
                            17907968148454622562 => {
                                current_block = 6127088460976951292;
                            }
                            _ => {}
                        }
                        match current_block {
                            6127088460976951292 => {
                                current_block = 15384943048769972658;
                            }
                            _ => {}
                        }
                        match current_block {
                            15384943048769972658 => {
                                current_block = 8424152728259710616;
                            }
                            _ => {}
                        }
                        match current_block {
                            8424152728259710616 => {
                                current_block = 18006174008171024618;
                            }
                            _ => {}
                        }
                        match current_block {
                            18006174008171024618 => {
                                current_block = 5495064098325561391;
                            }
                            _ => {}
                        }
                        match current_block {
                            5495064098325561391 => {}
                            _ => {}
                        }
                        ret = _bfd_elf_make_section_from_shdr(
                            abfd,
                            hdr,
                            name,
                            shindex as libc::c_int,
                        );
                        current_block = 12411140617278309634;
                    }
                }
            }
        }
    }
    match current_block {
        10695972253283192696 => {
            ret = 0 as libc::c_int != 0;
        }
        _ => {}
    }
    *((*(*abfd).tdata.elf_obj_data).being_created)
        .offset(shindex as isize) = 0 as libc::c_int as libc::c_uchar;
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_sym_from_r_symndx(
    mut cache: *mut sym_cache,
    mut abfd: *mut bfd,
    mut r_symndx: libc::c_ulong,
) -> *mut Elf_Internal_Sym {
    let mut ent: libc::c_uint = r_symndx.wrapping_rem(32 as libc::c_int as libc::c_ulong)
        as libc::c_uint;
    if (*cache).abfd != abfd || (*cache).indx[ent as usize] != r_symndx {
        let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut esym: [libc::c_uchar; 24] = [0; 24];
        let mut eshndx: Elf_External_Sym_Shndx = Elf_External_Sym_Shndx {
            est_shndx: [0; 4],
        };
        symtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
        if (bfd_elf_get_elf_syms(
            abfd,
            symtab_hdr,
            1 as libc::c_int as size_t,
            r_symndx,
            &mut *((*cache).sym).as_mut_ptr().offset(ent as isize),
            esym.as_mut_ptr() as *mut libc::c_void,
            &mut eshndx,
        ))
            .is_null()
        {
            return 0 as *mut Elf_Internal_Sym;
        }
        if (*cache).abfd != abfd {
            memset(
                ((*cache).indx).as_mut_ptr() as *mut libc::c_void,
                -(1 as libc::c_int),
                ::core::mem::size_of::<[libc::c_ulong; 32]>() as libc::c_ulong,
            );
            (*cache).abfd = abfd;
        }
        (*cache).indx[ent as usize] = r_symndx;
    }
    return &mut *((*cache).sym).as_mut_ptr().offset(ent as isize)
        as *mut Elf_Internal_Sym;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_section_from_elf_index(
    mut abfd: *mut bfd,
    mut sec_index: libc::c_uint,
) -> *mut asection {
    if sec_index >= (*(*abfd).tdata.elf_obj_data).num_elf_sections {
        return 0 as *mut asection;
    }
    return (**((*(*abfd).tdata.elf_obj_data).elf_sect_ptr).offset(sec_index as isize))
        .bfd_section;
}
static mut special_sections_b: [bfd_elf_special_section; 2] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 2];
static mut special_sections_c: [bfd_elf_special_section; 3] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 3];
static mut special_sections_d: [bfd_elf_special_section; 11] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 11];
static mut special_sections_f: [bfd_elf_special_section; 3] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 3];
static mut special_sections_g: [bfd_elf_special_section; 12] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 12];
static mut special_sections_h: [bfd_elf_special_section; 2] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 2];
static mut special_sections_i: [bfd_elf_special_section; 4] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 4];
static mut special_sections_l: [bfd_elf_special_section; 2] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 2];
static mut special_sections_n: [bfd_elf_special_section; 4] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 4];
static mut special_sections_p: [bfd_elf_special_section; 5] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 5];
static mut special_sections_r: [bfd_elf_special_section; 5] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 5];
static mut special_sections_s: [bfd_elf_special_section; 5] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 5];
static mut special_sections_t: [bfd_elf_special_section; 4] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 4];
static mut special_sections_z: [bfd_elf_special_section; 5] = [bfd_elf_special_section {
    prefix: 0 as *const libc::c_char,
    prefix_length: 0,
    suffix_length: 0,
    type_0: 0,
    attr: 0,
}; 5];
static mut special_sections: [*const bfd_elf_special_section; 25] = unsafe {
    [
        special_sections_b.as_ptr(),
        special_sections_c.as_ptr(),
        special_sections_d.as_ptr(),
        0 as *const bfd_elf_special_section,
        special_sections_f.as_ptr(),
        special_sections_g.as_ptr(),
        special_sections_h.as_ptr(),
        special_sections_i.as_ptr(),
        0 as *const bfd_elf_special_section,
        0 as *const bfd_elf_special_section,
        special_sections_l.as_ptr(),
        0 as *const bfd_elf_special_section,
        special_sections_n.as_ptr(),
        0 as *const bfd_elf_special_section,
        special_sections_p.as_ptr(),
        0 as *const bfd_elf_special_section,
        special_sections_r.as_ptr(),
        special_sections_s.as_ptr(),
        special_sections_t.as_ptr(),
        0 as *const bfd_elf_special_section,
        0 as *const bfd_elf_special_section,
        0 as *const bfd_elf_special_section,
        0 as *const bfd_elf_special_section,
        0 as *const bfd_elf_special_section,
        special_sections_z.as_ptr(),
    ]
};
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_special_section(
    mut name: *const libc::c_char,
    mut spec: *const bfd_elf_special_section,
    mut rela: libc::c_uint,
) -> *const bfd_elf_special_section {
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    len = strlen(name) as libc::c_int;
    let mut current_block_3: u64;
    i = 0 as libc::c_int;
    while !((*spec.offset(i as isize)).prefix).is_null() {
        let mut suffix_len: libc::c_int = 0;
        let mut prefix_len: libc::c_int = (*spec.offset(i as isize)).prefix_length
            as libc::c_int;
        if !(len < prefix_len) {
            if !(memcmp(
                name as *const libc::c_void,
                (*spec.offset(i as isize)).prefix as *const libc::c_void,
                prefix_len as libc::c_ulong,
            ) != 0 as libc::c_int)
            {
                suffix_len = (*spec.offset(i as isize)).suffix_length;
                if suffix_len <= 0 as libc::c_int {
                    if *name.offset(prefix_len as isize) as libc::c_int
                        != 0 as libc::c_int
                    {
                        if suffix_len == 0 as libc::c_int {
                            current_block_3 = 16559507199688588974;
                        } else if *name.offset(prefix_len as isize) as libc::c_int
                            != '.' as i32
                            && (suffix_len == -(2 as libc::c_int)
                                || rela != 0
                                    && (*spec.offset(i as isize)).type_0
                                        == 9 as libc::c_int as libc::c_uint)
                        {
                            current_block_3 = 16559507199688588974;
                        } else {
                            current_block_3 = 3512920355445576850;
                        }
                    } else {
                        current_block_3 = 3512920355445576850;
                    }
                } else if len < prefix_len + suffix_len {
                    current_block_3 = 16559507199688588974;
                } else if memcmp(
                    name.offset(len as isize).offset(-(suffix_len as isize))
                        as *const libc::c_void,
                    ((*spec.offset(i as isize)).prefix).offset(prefix_len as isize)
                        as *const libc::c_void,
                    suffix_len as libc::c_ulong,
                ) != 0 as libc::c_int
                {
                    current_block_3 = 16559507199688588974;
                } else {
                    current_block_3 = 3512920355445576850;
                }
                match current_block_3 {
                    16559507199688588974 => {}
                    _ => {
                        return &*spec.offset(i as isize)
                            as *const bfd_elf_special_section;
                    }
                }
            }
        }
        i += 1;
        i;
    }
    return 0 as *const bfd_elf_special_section;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_sec_type_attr(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
) -> *const bfd_elf_special_section {
    let mut i: libc::c_int = 0;
    let mut spec: *const bfd_elf_special_section = 0 as *const bfd_elf_special_section;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    if ((*sec).name).is_null() {
        return 0 as *const bfd_elf_special_section;
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    spec = (*bed).special_sections;
    if !spec.is_null() {
        spec = _bfd_elf_get_special_section(
            (*sec).name,
            (*bed).special_sections,
            (*sec).use_rela_p(),
        );
        if !spec.is_null() {
            return spec;
        }
    }
    if *((*sec).name).offset(0 as libc::c_int as isize) as libc::c_int != '.' as i32 {
        return 0 as *const bfd_elf_special_section;
    }
    i = *((*sec).name).offset(1 as libc::c_int as isize) as libc::c_int - 'b' as i32;
    if i < 0 as libc::c_int || i > 'z' as i32 - 'b' as i32 {
        return 0 as *const bfd_elf_special_section;
    }
    spec = special_sections[i as usize];
    if spec.is_null() {
        return 0 as *const bfd_elf_special_section;
    }
    return _bfd_elf_get_special_section((*sec).name, spec, (*sec).use_rela_p());
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_new_section_hook(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
) -> bool {
    let mut sdata: *mut bfd_elf_section_data = 0 as *mut bfd_elf_section_data;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut ssect: *const bfd_elf_special_section = 0 as *const bfd_elf_special_section;
    sdata = (*sec).used_by_bfd as *mut bfd_elf_section_data;
    if sdata.is_null() {
        sdata = bfd_zalloc(
            abfd,
            ::core::mem::size_of::<bfd_elf_section_data>() as libc::c_ulong,
        ) as *mut bfd_elf_section_data;
        if sdata.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*sec).used_by_bfd = sdata as *mut libc::c_void;
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    (*sec).set_use_rela_p((*bed).default_use_rela_p());
    ssect = (Some(((*bed).get_sec_type_attr).expect("non-null function pointer")))
        .expect("non-null function pointer")(abfd, sec);
    if !ssect.is_null() {
        (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_type = (*ssect).type_0;
        (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_flags = (*ssect).attr;
    }
    return _bfd_generic_new_section_hook(abfd, sec);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_make_section_from_phdr(
    mut abfd: *mut bfd,
    mut hdr: *mut Elf_Internal_Phdr,
    mut hdr_index: libc::c_int,
    mut type_name: *const libc::c_char,
) -> bool {
    let mut newsect: *mut asection = 0 as *mut asection;
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut namebuf: [libc::c_char; 64] = [0; 64];
    let mut len: size_t = 0;
    let mut split: libc::c_int = 0;
    let mut opb: libc::c_uint = bfd_octets_per_byte(abfd, 0 as *const asection);
    split = ((*hdr).p_memsz > 0 as libc::c_int as libc::c_ulong
        && (*hdr).p_filesz > 0 as libc::c_int as libc::c_ulong
        && (*hdr).p_memsz > (*hdr).p_filesz) as libc::c_int;
    if (*hdr).p_filesz > 0 as libc::c_int as libc::c_ulong {
        sprintf(
            namebuf.as_mut_ptr(),
            b"%s%d%s\0" as *const u8 as *const libc::c_char,
            type_name,
            hdr_index,
            if split != 0 {
                b"a\0" as *const u8 as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
        );
        len = (strlen(namebuf.as_mut_ptr()))
            .wrapping_add(1 as libc::c_int as libc::c_ulong);
        name = bfd_alloc(abfd, len) as *mut libc::c_char;
        if name.is_null() {
            return 0 as libc::c_int != 0;
        }
        memcpy(
            name as *mut libc::c_void,
            namebuf.as_mut_ptr() as *const libc::c_void,
            len,
        );
        newsect = bfd_make_section(abfd, name);
        if newsect.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*newsect).vma = ((*hdr).p_vaddr).wrapping_div(opb as libc::c_ulong);
        (*newsect).lma = ((*hdr).p_paddr).wrapping_div(opb as libc::c_ulong);
        (*newsect).size = (*hdr).p_filesz;
        (*newsect).filepos = (*hdr).p_offset as file_ptr;
        (*newsect).flags |= 0x100 as libc::c_int as libc::c_uint;
        (*newsect).alignment_power = bfd_log2((*hdr).p_align);
        if (*hdr).p_type == 1 as libc::c_int as libc::c_ulong {
            (*newsect).flags |= 0x1 as libc::c_int as libc::c_uint;
            (*newsect).flags |= 0x2 as libc::c_int as libc::c_uint;
            if (*hdr).p_flags & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong
                != 0
            {
                (*newsect).flags |= 0x10 as libc::c_int as libc::c_uint;
            }
        }
        if (*hdr).p_flags & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
            == 0
        {
            (*newsect).flags |= 0x8 as libc::c_int as libc::c_uint;
        }
    }
    if (*hdr).p_memsz > (*hdr).p_filesz {
        let mut align: bfd_vma = 0;
        sprintf(
            namebuf.as_mut_ptr(),
            b"%s%d%s\0" as *const u8 as *const libc::c_char,
            type_name,
            hdr_index,
            if split != 0 {
                b"b\0" as *const u8 as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
        );
        len = (strlen(namebuf.as_mut_ptr()))
            .wrapping_add(1 as libc::c_int as libc::c_ulong);
        name = bfd_alloc(abfd, len) as *mut libc::c_char;
        if name.is_null() {
            return 0 as libc::c_int != 0;
        }
        memcpy(
            name as *mut libc::c_void,
            namebuf.as_mut_ptr() as *const libc::c_void,
            len,
        );
        newsect = bfd_make_section(abfd, name);
        if newsect.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*newsect)
            .vma = ((*hdr).p_vaddr)
            .wrapping_add((*hdr).p_filesz)
            .wrapping_div(opb as libc::c_ulong);
        (*newsect)
            .lma = ((*hdr).p_paddr)
            .wrapping_add((*hdr).p_filesz)
            .wrapping_div(opb as libc::c_ulong);
        (*newsect).size = ((*hdr).p_memsz).wrapping_sub((*hdr).p_filesz);
        (*newsect).filepos = ((*hdr).p_offset).wrapping_add((*hdr).p_filesz) as file_ptr;
        align = (*newsect).vma & ((*newsect).vma).wrapping_neg();
        if align == 0 as libc::c_int as libc::c_ulong || align > (*hdr).p_align {
            align = (*hdr).p_align;
        }
        (*newsect).alignment_power = bfd_log2(align);
        if (*hdr).p_type == 1 as libc::c_int as libc::c_ulong {
            (*newsect).flags |= 0x1 as libc::c_int as libc::c_uint;
            if (*hdr).p_flags & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong
                != 0
            {
                (*newsect).flags |= 0x10 as libc::c_int as libc::c_uint;
            }
        }
        if (*hdr).p_flags & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
            == 0
        {
            (*newsect).flags |= 0x8 as libc::c_int as libc::c_uint;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_core_find_build_id(
    mut templ: *mut bfd,
    mut offset: bfd_vma,
) -> bool {
    if (*(*templ).xvec).flavour as libc::c_uint
        == bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return (Some(
            ((*((*(*templ).xvec).backend_data as *const elf_backend_data))
                .elf_backend_core_find_build_id)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(templ, offset);
    }
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_section_from_phdr(
    mut abfd: *mut bfd,
    mut hdr: *mut Elf_Internal_Phdr,
    mut hdr_index: libc::c_int,
) -> bool {
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    match (*hdr).p_type {
        0 => {
            return _bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"null\0" as *const u8 as *const libc::c_char,
            );
        }
        1 => {
            if !_bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"load\0" as *const u8 as *const libc::c_char,
            ) {
                return 0 as libc::c_int != 0;
            }
            if bfd_get_format(abfd) as libc::c_uint
                == bfd_core as libc::c_int as libc::c_uint
                && ((*abfd).build_id).is_null()
            {
                _bfd_elf_core_find_build_id(abfd, (*hdr).p_offset);
            }
            return 1 as libc::c_int != 0;
        }
        2 => {
            return _bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"dynamic\0" as *const u8 as *const libc::c_char,
            );
        }
        3 => {
            return _bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"interp\0" as *const u8 as *const libc::c_char,
            );
        }
        4 => {
            if !_bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"note\0" as *const u8 as *const libc::c_char,
            ) {
                return 0 as libc::c_int != 0;
            }
            if !elf_read_notes(
                abfd,
                (*hdr).p_offset as file_ptr,
                (*hdr).p_filesz,
                (*hdr).p_align,
            ) {
                return 0 as libc::c_int != 0;
            }
            return 1 as libc::c_int != 0;
        }
        5 => {
            return _bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"shlib\0" as *const u8 as *const libc::c_char,
            );
        }
        6 => {
            return _bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"phdr\0" as *const u8 as *const libc::c_char,
            );
        }
        1685382480 => {
            return _bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"eh_frame_hdr\0" as *const u8 as *const libc::c_char,
            );
        }
        1685382481 => {
            return _bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"stack\0" as *const u8 as *const libc::c_char,
            );
        }
        1685382482 => {
            return _bfd_elf_make_section_from_phdr(
                abfd,
                hdr,
                hdr_index,
                b"relro\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {
            bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
            return ((*bed).elf_backend_section_from_phdr)
                .expect(
                    "non-null function pointer",
                )(abfd, hdr, hdr_index, b"proc\0" as *const u8 as *const libc::c_char);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_single_rel_hdr(
    mut sec: *mut asection,
) -> *mut Elf_Internal_Shdr {
    if !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).rel.hdr).is_null() {
        if !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).rela.hdr).is_null() {
            bfd_assert(
                b"elf.c\0" as *const u8 as *const libc::c_char,
                3100 as libc::c_int,
            );
        }
        return (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).rel.hdr;
    } else {
        return (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).rela.hdr
    };
}
unsafe extern "C" fn _bfd_elf_set_reloc_sh_name(
    mut abfd: *mut bfd,
    mut rel_hdr: *mut Elf_Internal_Shdr,
    mut sec_name: *const libc::c_char,
    mut use_rela_p: bool,
) -> bool {
    let mut name: *mut libc::c_char = bfd_alloc(
        abfd,
        (::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong)
            .wrapping_add(strlen(sec_name)),
    ) as *mut libc::c_char;
    if name.is_null() {
        return 0 as libc::c_int != 0;
    }
    sprintf(
        name,
        b"%s%s\0" as *const u8 as *const libc::c_char,
        if use_rela_p as libc::c_int != 0 {
            b".rela\0" as *const u8 as *const libc::c_char
        } else {
            b".rel\0" as *const u8 as *const libc::c_char
        },
        sec_name,
    );
    (*rel_hdr)
        .sh_name = _bfd_elf_strtab_add(
        (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
        name,
        0 as libc::c_int != 0,
    ) as libc::c_uint;
    if (*rel_hdr).sh_name == -(1 as libc::c_int) as libc::c_uint {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_init_reloc_shdr(
    mut abfd: *mut bfd,
    mut reldata: *mut bfd_elf_section_reloc_data,
    mut sec_name: *const libc::c_char,
    mut use_rela_p: bool,
    mut delay_st_name_p: bool,
) -> bool {
    let mut rel_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    if !((*reldata).hdr).is_null() {
        bfd_assert(b"elf.c\0" as *const u8 as *const libc::c_char, 3143 as libc::c_int);
    }
    rel_hdr = bfd_zalloc(
        abfd,
        ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
    ) as *mut Elf_Internal_Shdr;
    (*reldata).hdr = rel_hdr;
    if delay_st_name_p {
        (*rel_hdr).sh_name = -(1 as libc::c_int) as libc::c_uint;
    } else if !_bfd_elf_set_reloc_sh_name(abfd, rel_hdr, sec_name, use_rela_p) {
        return 0 as libc::c_int != 0
    }
    (*rel_hdr)
        .sh_type = (if use_rela_p as libc::c_int != 0 {
        4 as libc::c_int
    } else {
        9 as libc::c_int
    }) as libc::c_uint;
    (*rel_hdr)
        .sh_entsize = (if use_rela_p as libc::c_int != 0 {
        (*(*bed).s).sizeof_rela as libc::c_int
    } else {
        (*(*bed).s).sizeof_rel as libc::c_int
    }) as bfd_size_type;
    (*rel_hdr)
        .sh_addralign = (1 as libc::c_int as bfd_vma)
        << (*(*bed).s).log_file_align as libc::c_int;
    (*rel_hdr).sh_flags = 0 as libc::c_int as bfd_vma;
    (*rel_hdr).sh_addr = 0 as libc::c_int as bfd_vma;
    (*rel_hdr).sh_size = 0 as libc::c_int as bfd_size_type;
    (*rel_hdr).sh_offset = 0 as libc::c_int as file_ptr;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_get_default_section_type(
    mut flags: flagword,
) -> libc::c_int {
    if flags & (0x1 as libc::c_int | 0x1000 as libc::c_int) as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
        && flags & (0x2 as libc::c_int | 0x100 as libc::c_int) as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
    {
        return 8 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn elf_fake_sections(
    mut abfd: *mut bfd,
    mut asect: *mut asection,
    mut fsarg: *mut libc::c_void,
) {
    let mut arg: *mut fake_section_arg = fsarg as *mut fake_section_arg;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut esd: *mut bfd_elf_section_data = (*asect).used_by_bfd
        as *mut bfd_elf_section_data;
    let mut this_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut sh_type: libc::c_uint = 0;
    let mut name: *const libc::c_char = (*asect).name;
    let mut delay_st_name_p: bool = 0 as libc::c_int != 0;
    let mut mask: bfd_vma = 0;
    if (*arg).failed {
        return;
    }
    this_hdr = &mut (*esd).this_hdr;
    if !((*arg).link_info).is_null() {
        if (*(*arg).link_info).compress_debug as libc::c_uint
            & COMPRESS_DEBUG as libc::c_int as libc::c_uint != 0
            && (*asect).flags & 0x2000 as libc::c_int as libc::c_uint != 0
            && *name.offset(1 as libc::c_int as isize) as libc::c_int == 'd' as i32
            && *name.offset(6 as libc::c_int as isize) as libc::c_int == '_' as i32
        {
            (*asect).flags |= 0x8000000 as libc::c_int as libc::c_uint;
            delay_st_name_p = 1 as libc::c_int != 0;
        }
    } else if (*asect).flags & 0x10000000 as libc::c_int as libc::c_uint != 0 {
        if (*abfd).flags
            & (0x8000 as libc::c_int | 0x20000 as libc::c_int) as libc::c_uint != 0
        {
            if *name.offset(1 as libc::c_int as isize) as libc::c_int == 'z' as i32 {
                let mut new_name: *mut libc::c_char = convert_zdebug_to_debug(
                    abfd,
                    name,
                );
                if new_name.is_null() {
                    (*arg).failed = 1 as libc::c_int != 0;
                    return;
                }
                name = new_name;
            }
        } else if (*asect).compress_status() as libc::c_int == 1 as libc::c_int {
            let mut new_name_0: *mut libc::c_char = convert_debug_to_zdebug(abfd, name);
            if new_name_0.is_null() {
                (*arg).failed = 1 as libc::c_int != 0;
                return;
            }
            if !(*name.offset(1 as libc::c_int as isize) as libc::c_int != 'z' as i32) {
                bfd_assert(
                    b"elf.c\0" as *const u8 as *const libc::c_char,
                    3253 as libc::c_int,
                );
            }
            name = new_name_0;
        }
    }
    if delay_st_name_p {
        (*this_hdr).sh_name = -(1 as libc::c_int) as libc::c_uint;
    } else {
        (*this_hdr)
            .sh_name = _bfd_elf_strtab_add(
            (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
            name,
            0 as libc::c_int != 0,
        ) as libc::c_uint;
        if (*this_hdr).sh_name == -(1 as libc::c_int) as libc::c_uint {
            (*arg).failed = 1 as libc::c_int != 0;
            return;
        }
    }
    if (*asect).flags & 0x1 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
        || (*asect).user_set_vma() as libc::c_int != 0
    {
        (*this_hdr)
            .sh_addr = ((*asect).vma)
            .wrapping_mul(bfd_octets_per_byte(abfd, asect) as libc::c_ulong);
    } else {
        (*this_hdr).sh_addr = 0 as libc::c_int as bfd_vma;
    }
    (*this_hdr).sh_offset = 0 as libc::c_int as file_ptr;
    (*this_hdr).sh_size = (*asect).size;
    (*this_hdr).sh_link = 0 as libc::c_int as libc::c_uint;
    if (*asect).alignment_power as libc::c_ulong
        >= (::core::mem::size_of::<bfd_vma>() as libc::c_ulong)
            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
    {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: error: alignment power %d of section `%pA' is too big\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            (*asect).alignment_power,
            asect,
        );
        (*arg).failed = 1 as libc::c_int != 0;
        return;
    }
    mask = (1 as libc::c_int as bfd_vma) << (*asect).alignment_power
        | (*this_hdr).sh_addr;
    (*this_hdr).sh_addralign = mask & mask.wrapping_neg();
    (*this_hdr).bfd_section = asect;
    (*this_hdr).contents = 0 as *mut libc::c_uchar;
    if (*asect).flags & 0x2000000 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        sh_type = 17 as libc::c_int as libc::c_uint;
    } else {
        sh_type = bfd_elf_get_default_section_type((*asect).flags) as libc::c_uint;
    }
    if (*this_hdr).sh_type == 0 as libc::c_int as libc::c_uint {
        (*this_hdr).sh_type = sh_type;
    } else if (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
        && sh_type == 1 as libc::c_int as libc::c_uint
        && (*asect).flags & 0x1 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
    {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"warning: section `%pA' type changed to PROGBITS\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            asect,
        );
        (*this_hdr).sh_type = sh_type;
    }
    match (*this_hdr).sh_type {
        14 | 15 | 16 => {
            (*this_hdr)
                .sh_entsize = ((*(*bed).s).arch_size as libc::c_int / 8 as libc::c_int)
                as bfd_size_type;
        }
        5 => {
            (*this_hdr).sh_entsize = (*(*bed).s).sizeof_hash_entry as bfd_size_type;
        }
        11 => {
            (*this_hdr).sh_entsize = (*(*bed).s).sizeof_sym as bfd_size_type;
        }
        6 => {
            (*this_hdr).sh_entsize = (*(*bed).s).sizeof_dyn as bfd_size_type;
        }
        4 => {
            if (*((*(*abfd).xvec).backend_data as *const elf_backend_data))
                .may_use_rela_p() != 0
            {
                (*this_hdr).sh_entsize = (*(*bed).s).sizeof_rela as bfd_size_type;
            }
        }
        9 => {
            if (*((*(*abfd).xvec).backend_data as *const elf_backend_data))
                .may_use_rel_p() != 0
            {
                (*this_hdr).sh_entsize = (*(*bed).s).sizeof_rel as bfd_size_type;
            }
        }
        1879048191 => {
            (*this_hdr)
                .sh_entsize = ::core::mem::size_of::<Elf_External_Versym>()
                as libc::c_ulong;
        }
        1879048189 => {
            (*this_hdr).sh_entsize = 0 as libc::c_int as bfd_size_type;
            if (*this_hdr).sh_info == 0 as libc::c_int as libc::c_uint {
                (*this_hdr).sh_info = (*(*abfd).tdata.elf_obj_data).cverdefs;
            } else if !((*(*abfd).tdata.elf_obj_data).cverdefs
                == 0 as libc::c_int as libc::c_uint
                || (*this_hdr).sh_info == (*(*abfd).tdata.elf_obj_data).cverdefs)
            {
                bfd_assert(
                    b"elf.c\0" as *const u8 as *const libc::c_char,
                    3377 as libc::c_int,
                );
            }
        }
        1879048190 => {
            (*this_hdr).sh_entsize = 0 as libc::c_int as bfd_size_type;
            if (*this_hdr).sh_info == 0 as libc::c_int as libc::c_uint {
                (*this_hdr).sh_info = (*(*abfd).tdata.elf_obj_data).cverrefs;
            } else if !((*(*abfd).tdata.elf_obj_data).cverrefs
                == 0 as libc::c_int as libc::c_uint
                || (*this_hdr).sh_info == (*(*abfd).tdata.elf_obj_data).cverrefs)
            {
                bfd_assert(
                    b"elf.c\0" as *const u8 as *const libc::c_char,
                    3389 as libc::c_int,
                );
            }
        }
        17 => {
            (*this_hdr).sh_entsize = 4 as libc::c_int as bfd_size_type;
        }
        1879048182 => {
            (*this_hdr)
                .sh_entsize = (if (*(*bed).s).arch_size as libc::c_int
                == 64 as libc::c_int
            {
                0 as libc::c_int
            } else {
                4 as libc::c_int
            }) as bfd_size_type;
        }
        3 | 7 | 8 | 1 | _ => {}
    }
    if (*asect).flags & 0x1 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        (*this_hdr).sh_flags
            |= ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong;
    }
    if (*asect).flags & 0x8 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        (*this_hdr).sh_flags
            |= ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong;
    }
    if (*asect).flags & 0x10 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        (*this_hdr).sh_flags
            |= ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong;
    }
    if (*asect).flags & 0x800000 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        (*this_hdr).sh_flags
            |= ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_ulong;
        (*this_hdr).sh_entsize = (*asect).entsize as bfd_size_type;
    }
    if (*asect).flags & 0x1000000 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        (*this_hdr).sh_flags
            |= ((1 as libc::c_int) << 5 as libc::c_int) as libc::c_ulong;
    }
    if (*asect).flags & 0x2000000 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
        && !((*((*asect).used_by_bfd as *mut bfd_elf_section_data)).group.name).is_null()
    {
        (*this_hdr).sh_flags
            |= ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong;
    }
    if (*asect).flags & 0x400 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        (*this_hdr).sh_flags
            |= ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong;
        if (*asect).size == 0 as libc::c_int as libc::c_ulong
            && (*asect).flags & 0x100 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
        {
            let mut o: *mut bfd_link_order = (*asect).map_tail.link_order;
            (*this_hdr).sh_size = 0 as libc::c_int as bfd_size_type;
            if !o.is_null() {
                (*this_hdr).sh_size = ((*o).offset).wrapping_add((*o).size);
                if (*this_hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                    (*this_hdr).sh_type = 8 as libc::c_int as libc::c_uint;
                }
            }
        }
    }
    if (*asect).flags
        & (0x2000000 as libc::c_int | 0x8000 as libc::c_int) as libc::c_uint
        == 0x8000 as libc::c_int as libc::c_uint
    {
        (*this_hdr).sh_flags |= 0x80000000 as libc::c_uint as libc::c_ulong;
    }
    if (*asect).flags & 0x4 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        if !((*arg).link_info).is_null()
            && ((*esd).rel.count).wrapping_add((*esd).rela.count)
                > 0 as libc::c_int as libc::c_uint
            && ((*(*arg).link_info).type_0() as libc::c_int
                == type_relocatable as libc::c_int
                || (*(*arg).link_info).emitrelocations() as libc::c_int != 0)
        {
            if (*esd).rel.count != 0 && ((*esd).rel.hdr).is_null()
                && !_bfd_elf_init_reloc_shdr(
                    abfd,
                    &mut (*esd).rel,
                    name,
                    0 as libc::c_int != 0,
                    delay_st_name_p,
                )
            {
                (*arg).failed = 1 as libc::c_int != 0;
                return;
            }
            if (*esd).rela.count != 0 && ((*esd).rela.hdr).is_null()
                && !_bfd_elf_init_reloc_shdr(
                    abfd,
                    &mut (*esd).rela,
                    name,
                    1 as libc::c_int != 0,
                    delay_st_name_p,
                )
            {
                (*arg).failed = 1 as libc::c_int != 0;
                return;
            }
        } else if !_bfd_elf_init_reloc_shdr(
            abfd,
            if (*asect).use_rela_p() as libc::c_int != 0 {
                &mut (*esd).rela
            } else {
                &mut (*esd).rel
            },
            name,
            (*asect).use_rela_p() != 0,
            delay_st_name_p,
        ) {
            (*arg).failed = 1 as libc::c_int != 0;
            return;
        }
    }
    sh_type = (*this_hdr).sh_type;
    if ((*bed).elf_backend_fake_sections).is_some()
        && !(Some(
            ((*bed).elf_backend_fake_sections).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd, this_hdr, asect)
    {
        (*arg).failed = 1 as libc::c_int != 0;
        return;
    }
    if sh_type == 8 as libc::c_int as libc::c_uint
        && (*asect).size != 0 as libc::c_int as libc::c_ulong
    {
        (*this_hdr).sh_type = sh_type;
    }
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_set_group_contents(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut failedptrarg: *mut libc::c_void,
) {
    let mut failedptr: *mut bool = failedptrarg as *mut bool;
    let mut elt: *mut asection = 0 as *mut asection;
    let mut first: *mut asection = 0 as *mut asection;
    let mut loc: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut gas: bool = false;
    if (*sec).flags
        & (0x2000000 as libc::c_int | 0x100000 as libc::c_int) as libc::c_uint
        != 0x2000000 as libc::c_int as libc::c_uint
        || (*sec).size == 0 as libc::c_int as libc::c_ulong
        || *failedptr as libc::c_int != 0
    {
        return;
    }
    if (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_info
        == 0 as libc::c_int as libc::c_uint
    {
        let mut symindx: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
        if !((*((*sec).used_by_bfd as *mut bfd_elf_section_data)).group.id).is_null() {
            symindx = (*(*((*sec).used_by_bfd as *mut bfd_elf_section_data)).group.id)
                .udata
                .i;
        }
        if symindx == 0 as libc::c_int as libc::c_ulong {
            if ((*(*(*abfd).tdata.elf_obj_data).o).section_syms).is_null() {
                *failedptr = 1 as libc::c_int != 0;
                return;
            }
            symindx = (**((*(*(*abfd).tdata.elf_obj_data).o).section_syms)
                .offset((*sec).index as isize))
                .udata
                .i;
        }
        (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_info = symindx as libc::c_uint;
    } else if (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_info
        == -(2 as libc::c_int) as libc::c_uint
    {
        let mut igroup: *mut asection = 0 as *mut asection;
        let mut sec_data: *mut bfd_elf_section_data = 0 as *mut bfd_elf_section_data;
        let mut symndx: libc::c_ulong = 0;
        let mut extsymoff: libc::c_ulong = 0;
        let mut h: *mut elf_link_hash_entry = 0 as *mut elf_link_hash_entry;
        igroup = (*((*(*((*sec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group)
            .used_by_bfd as *mut bfd_elf_section_data))
            .sec_group;
        sec_data = (*igroup).used_by_bfd as *mut bfd_elf_section_data;
        symndx = (*sec_data).this_hdr.sh_info as libc::c_ulong;
        extsymoff = 0 as libc::c_int as libc::c_ulong;
        if (*(*(*igroup).owner).tdata.elf_obj_data).bad_symtab() == 0 {
            let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
            symtab_hdr = &mut (*(*(*igroup).owner).tdata.elf_obj_data).symtab_hdr;
            extsymoff = (*symtab_hdr).sh_info as libc::c_ulong;
        }
        h = *((*(*(*igroup).owner).tdata.elf_obj_data).sym_hashes)
            .offset(symndx.wrapping_sub(extsymoff) as isize);
        while ((*h).root).type_0() as libc::c_int
            == bfd_link_hash_indirect as libc::c_int
            || ((*h).root).type_0() as libc::c_int
                == bfd_link_hash_warning as libc::c_int
        {
            h = (*h).root.u.i.link as *mut elf_link_hash_entry;
        }
        (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_info = (*h).indx as libc::c_uint;
    }
    gas = 1 as libc::c_int != 0;
    if ((*sec).contents).is_null() {
        gas = 0 as libc::c_int != 0;
        (*sec).contents = bfd_alloc(abfd, (*sec).size) as *mut libc::c_uchar;
        let ref mut fresh21 = (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .contents;
        *fresh21 = (*sec).contents;
        if ((*sec).contents).is_null() {
            *failedptr = 1 as libc::c_int != 0;
            return;
        }
    }
    loc = ((*sec).contents).offset((*sec).size as isize);
    elt = (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
    first = elt;
    while !elt.is_null() {
        let mut s: *mut asection = 0 as *mut asection;
        s = elt;
        if !gas {
            s = (*s).output_section;
        }
        if !s.is_null() && !bfd_is_abs_section(s) {
            let mut elf_sec: *mut bfd_elf_section_data = (*s).used_by_bfd
                as *mut bfd_elf_section_data;
            let mut input_elf_sec: *mut bfd_elf_section_data = (*elt).used_by_bfd
                as *mut bfd_elf_section_data;
            if !((*elf_sec).rel.hdr).is_null()
                && (gas as libc::c_int != 0
                    || (!((*input_elf_sec).rel.hdr).is_null()
                        && (*(*input_elf_sec).rel.hdr).sh_flags
                            & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong
                            != 0) as libc::c_int != 0 as libc::c_int)
            {
                (*(*elf_sec).rel.hdr).sh_flags
                    |= ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong;
                loc = loc.offset(-(4 as libc::c_int as isize));
                (Some(
                    ((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )((*elf_sec).rel.idx as bfd_vma, loc as *mut libc::c_void);
            }
            if !((*elf_sec).rela.hdr).is_null()
                && (gas as libc::c_int != 0
                    || (!((*input_elf_sec).rela.hdr).is_null()
                        && (*(*input_elf_sec).rela.hdr).sh_flags
                            & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong
                            != 0) as libc::c_int != 0 as libc::c_int)
            {
                (*(*elf_sec).rela.hdr).sh_flags
                    |= ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong;
                loc = loc.offset(-(4 as libc::c_int as isize));
                (Some(
                    ((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )((*elf_sec).rela.idx as bfd_vma, loc as *mut libc::c_void);
            }
            loc = loc.offset(-(4 as libc::c_int as isize));
            (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
                .expect(
                    "non-null function pointer",
                )((*elf_sec).this_idx as bfd_vma, loc as *mut libc::c_void);
        }
        elt = (*((*elt).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
        if elt == first {
            break;
        }
    }
    loc = loc.offset(-(4 as libc::c_int as isize));
    if !(loc == (*sec).contents) {
        bfd_assert(b"elf.c\0" as *const u8 as *const libc::c_char, 3637 as libc::c_int);
    }
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (if (*sec).flags & 0x20000 as libc::c_int as libc::c_uint != 0 {
            0x1 as libc::c_int
        } else {
            0 as libc::c_int
        }) as bfd_vma,
        loc as *mut libc::c_void,
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_plt_get_reloc_section(
    mut abfd: *mut bfd,
    mut name: *const libc::c_char,
) -> *mut asection {
    if (*((*(*abfd).xvec).backend_data as *const elf_backend_data)).want_got_plt()
        as libc::c_int != 0
        && strcmp(name, b".plt\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        let mut sec: *mut asection = 0 as *mut asection;
        name = b".got.plt\0" as *const u8 as *const libc::c_char;
        sec = bfd_get_section_by_name(abfd, name);
        if !sec.is_null() {
            return sec;
        }
        name = b".got\0" as *const u8 as *const libc::c_char;
    }
    return bfd_get_section_by_name(abfd, name);
}
unsafe extern "C" fn elf_get_reloc_section(
    mut reloc_sec: *mut asection,
) -> *mut asection {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut type_0: libc::c_uint = 0;
    let mut abfd: *mut bfd = 0 as *mut bfd;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    type_0 = (*((*reloc_sec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type;
    if type_0 != 9 as libc::c_int as libc::c_uint
        && type_0 != 4 as libc::c_int as libc::c_uint
    {
        return 0 as *mut asection;
    }
    name = (*reloc_sec).name;
    if !startswith(name, b".rel\0" as *const u8 as *const libc::c_char) {
        return 0 as *mut asection;
    }
    name = name.offset(4 as libc::c_int as isize);
    if type_0 == 4 as libc::c_int as libc::c_uint
        && {
            let fresh22 = name;
            name = name.offset(1);
            *fresh22 as libc::c_int != 'a' as i32
        }
    {
        return 0 as *mut asection;
    }
    abfd = (*reloc_sec).owner;
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    return ((*bed).get_reloc_section).expect("non-null function pointer")(abfd, name);
}
unsafe extern "C" fn assign_section_numbers(
    mut abfd: *mut bfd,
    mut link_info: *mut bfd_link_info,
) -> bool {
    let mut t: *mut elf_obj_tdata = (*abfd).tdata.elf_obj_data;
    let mut sec: *mut asection = 0 as *mut asection;
    let mut section_number: libc::c_uint = 0;
    let mut i_shdrp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    let mut d: *mut bfd_elf_section_data = 0 as *mut bfd_elf_section_data;
    let mut need_symtab: bool = false;
    let mut amt: size_t = 0;
    section_number = 1 as libc::c_int as libc::c_uint;
    _bfd_elf_strtab_clear_all_refs((*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr);
    if link_info.is_null() || (*link_info).resolve_section_groups() == 0 {
        let mut reloc_count: size_t = 0 as libc::c_int as size_t;
        sec = (*abfd).sections;
        while !sec.is_null() {
            d = (*sec).used_by_bfd as *mut bfd_elf_section_data;
            if (*d).this_hdr.sh_type == 17 as libc::c_int as libc::c_uint {
                if (*sec).flags & 0x100000 as libc::c_int as libc::c_uint != 0 {
                    bfd_section_list_remove(abfd, sec);
                    (*abfd).section_count = ((*abfd).section_count).wrapping_sub(1);
                    (*abfd).section_count;
                } else {
                    let fresh23 = section_number;
                    section_number = section_number.wrapping_add(1);
                    (*d).this_idx = fresh23 as libc::c_int;
                }
            }
            reloc_count = (reloc_count as libc::c_ulong)
                .wrapping_add((*sec).reloc_count as libc::c_ulong) as size_t as size_t;
            sec = (*sec).next;
        }
        if reloc_count == 0 as libc::c_int as libc::c_ulong {
            (*abfd).flags &= !(0x1 as libc::c_int) as libc::c_uint;
        }
    }
    sec = (*abfd).sections;
    while !sec.is_null() {
        d = (*sec).used_by_bfd as *mut bfd_elf_section_data;
        if (*d).this_hdr.sh_type != 17 as libc::c_int as libc::c_uint {
            let fresh24 = section_number;
            section_number = section_number.wrapping_add(1);
            (*d).this_idx = fresh24 as libc::c_int;
        }
        if (*d).this_hdr.sh_name != -(1 as libc::c_int) as libc::c_uint {
            _bfd_elf_strtab_addref(
                (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
                (*d).this_hdr.sh_name as size_t,
            );
        }
        if !((*d).rel.hdr).is_null() {
            let fresh25 = section_number;
            section_number = section_number.wrapping_add(1);
            (*d).rel.idx = fresh25 as libc::c_int;
            if (*(*d).rel.hdr).sh_name != -(1 as libc::c_int) as libc::c_uint {
                _bfd_elf_strtab_addref(
                    (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
                    (*(*d).rel.hdr).sh_name as size_t,
                );
            }
        } else {
            (*d).rel.idx = 0 as libc::c_int;
        }
        if !((*d).rela.hdr).is_null() {
            let fresh26 = section_number;
            section_number = section_number.wrapping_add(1);
            (*d).rela.idx = fresh26 as libc::c_int;
            if (*(*d).rela.hdr).sh_name != -(1 as libc::c_int) as libc::c_uint {
                _bfd_elf_strtab_addref(
                    (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
                    (*(*d).rela.hdr).sh_name as size_t,
                );
            }
        } else {
            (*d).rela.idx = 0 as libc::c_int;
        }
        sec = (*sec).next;
    }
    need_symtab = bfd_get_symcount(abfd) > 0 as libc::c_int as libc::c_uint
        || link_info.is_null()
            && (*abfd).flags
                & (0x2 as libc::c_int | 0x40 as libc::c_int | 0x1 as libc::c_int)
                    as libc::c_uint == 0x1 as libc::c_int as libc::c_uint;
    if need_symtab {
        let fresh27 = section_number;
        section_number = section_number.wrapping_add(1);
        (*(*abfd).tdata.elf_obj_data).symtab_section = fresh27;
        _bfd_elf_strtab_addref(
            (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
            (*t).symtab_hdr.sh_name as size_t,
        );
        if section_number
            > (0x100 as libc::c_uint)
                .wrapping_neg()
                .wrapping_sub(2 as libc::c_int as libc::c_uint)
                & 0xffff as libc::c_int as libc::c_uint
        {
            let mut entry: *mut elf_section_list = 0 as *mut elf_section_list;
            if !((*(*abfd).tdata.elf_obj_data).symtab_shndx_list).is_null() {
                bfd_assert(
                    b"elf.c\0" as *const u8 as *const libc::c_char,
                    3783 as libc::c_int,
                );
            }
            entry = bfd_zalloc(
                abfd,
                ::core::mem::size_of::<elf_section_list>() as libc::c_ulong,
            ) as *mut elf_section_list;
            let fresh28 = section_number;
            section_number = section_number.wrapping_add(1);
            (*entry).ndx = fresh28;
            (*(*abfd).tdata.elf_obj_data).symtab_shndx_list = entry;
            (*entry)
                .hdr
                .sh_name = _bfd_elf_strtab_add(
                (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
                b".symtab_shndx\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int != 0,
            ) as libc::c_uint;
            if (*entry).hdr.sh_name == -(1 as libc::c_int) as libc::c_uint {
                return 0 as libc::c_int != 0;
            }
        }
        let fresh29 = section_number;
        section_number = section_number.wrapping_add(1);
        (*(*(*abfd).tdata.elf_obj_data).o).strtab_section = fresh29;
        _bfd_elf_strtab_addref(
            (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
            (*t).strtab_hdr.sh_name as size_t,
        );
    }
    let fresh30 = section_number;
    section_number = section_number.wrapping_add(1);
    (*(*(*abfd).tdata.elf_obj_data).o).shstrtab_section = fresh30;
    _bfd_elf_strtab_addref(
        (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
        (*t).shstrtab_hdr.sh_name as size_t,
    );
    (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_shstrndx = (*(*(*abfd).tdata.elf_obj_data).o).shstrtab_section;
    if section_number >= (0x100 as libc::c_uint).wrapping_neg() {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: too many sections: %u\0" as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            section_number,
        );
        return 0 as libc::c_int != 0;
    }
    (*(*abfd).tdata.elf_obj_data).num_elf_sections = section_number;
    (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_shnum = section_number;
    amt = (section_number as libc::c_ulong)
        .wrapping_mul(::core::mem::size_of::<*mut Elf_Internal_Shdr>() as libc::c_ulong);
    i_shdrp = bfd_zalloc(abfd, amt) as *mut *mut Elf_Internal_Shdr;
    if i_shdrp.is_null() {
        return 0 as libc::c_int != 0;
    }
    let ref mut fresh31 = *i_shdrp.offset(0 as libc::c_int as isize);
    *fresh31 = bfd_zalloc(
        abfd,
        ::core::mem::size_of::<Elf_Internal_Shdr>() as libc::c_ulong,
    ) as *mut Elf_Internal_Shdr;
    if (*i_shdrp.offset(0 as libc::c_int as isize)).is_null() {
        bfd_release(abfd, i_shdrp as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    (*(*abfd).tdata.elf_obj_data).elf_sect_ptr = i_shdrp;
    let ref mut fresh32 = *i_shdrp
        .offset((*(*(*abfd).tdata.elf_obj_data).o).shstrtab_section as isize);
    *fresh32 = &mut (*t).shstrtab_hdr;
    if need_symtab {
        let ref mut fresh33 = *i_shdrp
            .offset((*(*abfd).tdata.elf_obj_data).symtab_section as isize);
        *fresh33 = &mut (*t).symtab_hdr;
        if (*(*abfd).tdata.elf_obj_data).num_elf_sections
            > (0x100 as libc::c_uint).wrapping_neg()
                & 0xffff as libc::c_int as libc::c_uint
        {
            let mut entry_0: *mut elf_section_list = (*(*abfd).tdata.elf_obj_data)
                .symtab_shndx_list;
            if entry_0.is_null() {
                bfd_assert(
                    b"elf.c\0" as *const u8 as *const libc::c_char,
                    3837 as libc::c_int,
                );
            }
            let ref mut fresh34 = *i_shdrp.offset((*entry_0).ndx as isize);
            *fresh34 = &mut (*entry_0).hdr;
            (*entry_0).hdr.sh_link = (*(*abfd).tdata.elf_obj_data).symtab_section;
        }
        let ref mut fresh35 = *i_shdrp
            .offset((*(*(*abfd).tdata.elf_obj_data).o).strtab_section as isize);
        *fresh35 = &mut (*t).strtab_hdr;
        (*t).symtab_hdr.sh_link = (*(*(*abfd).tdata.elf_obj_data).o).strtab_section;
    }
    sec = (*abfd).sections;
    while !sec.is_null() {
        let mut s: *mut asection = 0 as *mut asection;
        d = (*sec).used_by_bfd as *mut bfd_elf_section_data;
        let ref mut fresh36 = *i_shdrp.offset((*d).this_idx as isize);
        *fresh36 = &mut (*d).this_hdr;
        if (*d).rel.idx != 0 as libc::c_int {
            let ref mut fresh37 = *i_shdrp.offset((*d).rel.idx as isize);
            *fresh37 = (*d).rel.hdr;
        }
        if (*d).rela.idx != 0 as libc::c_int {
            let ref mut fresh38 = *i_shdrp.offset((*d).rela.idx as isize);
            *fresh38 = (*d).rela.hdr;
        }
        if (*d).rel.idx != 0 as libc::c_int {
            (*(*d).rel.hdr).sh_link = (*(*abfd).tdata.elf_obj_data).symtab_section;
            (*(*d).rel.hdr).sh_info = (*d).this_idx as libc::c_uint;
            (*(*d).rel.hdr).sh_flags
                |= ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong;
        }
        if (*d).rela.idx != 0 as libc::c_int {
            (*(*d).rela.hdr).sh_link = (*(*abfd).tdata.elf_obj_data).symtab_section;
            (*(*d).rela.hdr).sh_info = (*d).this_idx as libc::c_uint;
            (*(*d).rela.hdr).sh_flags
                |= ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong;
        }
        if (*d).this_hdr.sh_flags
            & ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_ulong
            != 0 as libc::c_int as libc::c_ulong
        {
            s = (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).linked_to;
            if !s.is_null() {
                if discarded_section(s) {
                    let mut kept: *mut asection = 0 as *mut asection;
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: sh_link of section `%pA' points to discarded section `%pA' of `%pB'\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        (*d).this_hdr.bfd_section,
                        s,
                        (*s).owner,
                    );
                    kept = _bfd_elf_check_kept_section(s, link_info);
                    if kept.is_null() {
                        bfd_set_error(bfd_error_bad_value);
                        return 0 as libc::c_int != 0;
                    }
                    s = kept;
                } else if ((*s).output_section).is_null() {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: sh_link of section `%pA' points to removed section `%pA' of `%pB'\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        (*d).this_hdr.bfd_section,
                        s,
                        (*s).owner,
                    );
                    bfd_set_error(bfd_error_bad_value);
                    return 0 as libc::c_int != 0;
                }
                s = (*s).output_section;
                (*d)
                    .this_hdr
                    .sh_link = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                    .this_idx as libc::c_uint;
            }
        }
        match (*d).this_hdr.sh_type {
            9 | 4 => {
                s = bfd_get_section_by_name(
                    abfd,
                    b".dynsym\0" as *const u8 as *const libc::c_char,
                );
                if !s.is_null() {
                    (*d)
                        .this_hdr
                        .sh_link = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                        .this_idx as libc::c_uint;
                }
                s = elf_get_reloc_section(sec);
                if !s.is_null() {
                    (*d)
                        .this_hdr
                        .sh_info = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                        .this_idx as libc::c_uint;
                    (*d).this_hdr.sh_flags
                        |= ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_ulong;
                }
            }
            3 => {
                if startswith(
                    (*sec).name,
                    b".stab\0" as *const u8 as *const libc::c_char,
                ) as libc::c_int != 0
                    && strcmp(
                        ((*sec).name)
                            .offset(strlen((*sec).name) as isize)
                            .offset(-(3 as libc::c_int as isize)),
                        b"str\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                {
                    let mut len: size_t = 0;
                    let mut alc: *mut libc::c_char = 0 as *mut libc::c_char;
                    len = strlen((*sec).name);
                    alc = bfd_malloc(len.wrapping_sub(2 as libc::c_int as libc::c_ulong))
                        as *mut libc::c_char;
                    if alc.is_null() {
                        return 0 as libc::c_int != 0;
                    }
                    memcpy(
                        alc as *mut libc::c_void,
                        (*sec).name as *const libc::c_void,
                        len.wrapping_sub(3 as libc::c_int as libc::c_ulong),
                    );
                    *alc
                        .offset(
                            len.wrapping_sub(3 as libc::c_int as libc::c_ulong) as isize,
                        ) = '\0' as i32 as libc::c_char;
                    s = bfd_get_section_by_name(abfd, alc);
                    free(alc as *mut libc::c_void);
                    if !s.is_null() {
                        (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_link = (*d).this_idx as libc::c_uint;
                        (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_entsize = 12 as libc::c_int as bfd_size_type;
                    }
                }
            }
            6 | 11 | 1879048190 | 1879048189 => {
                s = bfd_get_section_by_name(
                    abfd,
                    b".dynstr\0" as *const u8 as *const libc::c_char,
                );
                if !s.is_null() {
                    (*d)
                        .this_hdr
                        .sh_link = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                        .this_idx as libc::c_uint;
                }
            }
            1879048183 => {
                s = bfd_get_section_by_name(
                    abfd,
                    if (*sec).flags & 0x1 as libc::c_int as libc::c_uint != 0 {
                        b".dynstr\0" as *const u8 as *const libc::c_char
                    } else {
                        b".gnu.libstr\0" as *const u8 as *const libc::c_char
                    },
                );
                if !s.is_null() {
                    (*d)
                        .this_hdr
                        .sh_link = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                        .this_idx as libc::c_uint;
                }
            }
            5 | 1879048182 | 1879048191 => {
                s = bfd_get_section_by_name(
                    abfd,
                    b".dynsym\0" as *const u8 as *const libc::c_char,
                );
                if !s.is_null() {
                    (*d)
                        .this_hdr
                        .sh_link = (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                        .this_idx as libc::c_uint;
                }
            }
            17 => {
                (*d).this_hdr.sh_link = (*(*abfd).tdata.elf_obj_data).symtab_section;
            }
            _ => {}
        }
        sec = (*sec).next;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn sym_is_global(mut abfd: *mut bfd, mut sym: *mut asymbol) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    if ((*bed).elf_backend_sym_is_global).is_some() {
        return (Some(
            ((*bed).elf_backend_sym_is_global).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd, sym);
    }
    return (*sym).flags
        & ((1 as libc::c_int) << 1 as libc::c_int
            | (1 as libc::c_int) << 7 as libc::c_int
            | (1 as libc::c_int) << 23 as libc::c_int) as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
        || bfd_is_und_section(bfd_asymbol_section(sym)) as libc::c_int != 0
        || bfd_is_com_section(bfd_asymbol_section(sym)) as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_filter_global_symbols(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut syms: *mut *mut asymbol,
    mut symcount: libc::c_long,
) -> libc::c_uint {
    let mut src_count: libc::c_long = 0;
    let mut dst_count: libc::c_long = 0 as libc::c_int as libc::c_long;
    src_count = 0 as libc::c_int as libc::c_long;
    while src_count < symcount {
        let mut sym: *mut asymbol = *syms.offset(src_count as isize);
        let mut name: *mut libc::c_char = bfd_asymbol_name(sym) as *mut libc::c_char;
        let mut h: *mut bfd_link_hash_entry = 0 as *mut bfd_link_hash_entry;
        if sym_is_global(abfd, sym) {
            h = bfd_link_hash_lookup(
                (*info).hash,
                name,
                0 as libc::c_int != 0,
                0 as libc::c_int != 0,
                0 as libc::c_int != 0,
            );
            if !h.is_null() {
                if !((*h).type_0() as libc::c_int != bfd_link_hash_defined as libc::c_int
                    && (*h).type_0() as libc::c_int
                        != bfd_link_hash_defweak as libc::c_int)
                {
                    if !((*h).linker_def() as libc::c_int != 0
                        || (*h).ldscript_def() as libc::c_int != 0)
                    {
                        let fresh39 = dst_count;
                        dst_count = dst_count + 1;
                        let ref mut fresh40 = *syms.offset(fresh39 as isize);
                        *fresh40 = sym;
                    }
                }
            }
        }
        src_count += 1;
        src_count;
    }
    let ref mut fresh41 = *syms.offset(dst_count as isize);
    *fresh41 = 0 as *mut asymbol;
    return dst_count as libc::c_uint;
}
unsafe extern "C" fn ignore_section_sym(
    mut abfd: *mut bfd,
    mut sym: *mut asymbol,
) -> bool {
    let mut type_ptr: *mut elf_symbol_type = 0 as *mut elf_symbol_type;
    if sym.is_null() {
        return 0 as libc::c_int != 0;
    }
    if (*sym).flags & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    if (*sym).flags & ((1 as libc::c_int) << 24 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    if ((*sym).section).is_null() {
        return 1 as libc::c_int != 0;
    }
    type_ptr = if (*sym).flags
        & ((1 as libc::c_int) << 21 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint && !((*sym).the_bfd).is_null()
        && (*(*(*sym).the_bfd).xvec).flavour as libc::c_uint
            == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && !((*(*sym).the_bfd).tdata.elf_obj_data).is_null()
    {
        sym as *mut elf_symbol_type
    } else {
        0 as *mut elf_symbol_type
    };
    return !type_ptr.is_null()
        && (*type_ptr).internal_elf_sym.st_shndx != 0 as libc::c_int as libc::c_uint
        && bfd_is_abs_section((*sym).section) as libc::c_int != 0
        || !((*(*sym).section).owner == abfd
            || !((*(*sym).section).output_section).is_null()
                && (*(*(*sym).section).output_section).owner == abfd
                && (*(*sym).section).output_offset == 0 as libc::c_int as libc::c_ulong
            || bfd_is_abs_section((*sym).section) as libc::c_int != 0);
}
unsafe extern "C" fn elf_map_symbols(
    mut abfd: *mut bfd,
    mut pnum_locals: *mut libc::c_uint,
) -> bool {
    let mut symcount: libc::c_uint = bfd_get_symcount(abfd);
    let mut syms: *mut *mut asymbol = bfd_get_outsymbols(abfd);
    let mut sect_syms: *mut *mut asymbol = 0 as *mut *mut asymbol;
    let mut num_locals: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut num_globals: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut num_locals2: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut num_globals2: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut max_index: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut idx: libc::c_uint = 0;
    let mut asect: *mut asection = 0 as *mut asection;
    let mut new_syms: *mut *mut asymbol = 0 as *mut *mut asymbol;
    let mut amt: size_t = 0;
    asect = (*abfd).sections;
    while !asect.is_null() {
        if max_index < (*asect).index {
            max_index = (*asect).index;
        }
        asect = (*asect).next;
    }
    max_index = max_index.wrapping_add(1);
    max_index;
    amt = (max_index as libc::c_ulong)
        .wrapping_mul(::core::mem::size_of::<*mut asymbol>() as libc::c_ulong);
    sect_syms = bfd_zalloc(abfd, amt) as *mut *mut asymbol;
    if sect_syms.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*(*(*abfd).tdata.elf_obj_data).o).section_syms = sect_syms;
    (*(*(*abfd).tdata.elf_obj_data).o).num_section_syms = max_index as libc::c_int;
    idx = 0 as libc::c_int as libc::c_uint;
    while idx < symcount {
        let mut sym: *mut asymbol = *syms.offset(idx as isize);
        if (*sym).flags & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
            && (*sym).value == 0 as libc::c_int as libc::c_ulong
            && !ignore_section_sym(abfd, sym) && !bfd_is_abs_section((*sym).section)
        {
            let mut sec: *mut asection = (*sym).section;
            if (*sec).owner != abfd {
                sec = (*sec).output_section;
            }
            let ref mut fresh42 = *sect_syms.offset((*sec).index as isize);
            *fresh42 = *syms.offset(idx as isize);
        }
        idx = idx.wrapping_add(1);
        idx;
    }
    idx = 0 as libc::c_int as libc::c_uint;
    while idx < symcount {
        if sym_is_global(abfd, *syms.offset(idx as isize)) {
            num_globals = num_globals.wrapping_add(1);
            num_globals;
        } else if !ignore_section_sym(abfd, *syms.offset(idx as isize)) {
            num_locals = num_locals.wrapping_add(1);
            num_locals;
        }
        idx = idx.wrapping_add(1);
        idx;
    }
    asect = (*abfd).sections;
    while !asect.is_null() {
        let mut sym_0: *mut asymbol = (*asect).symbol;
        if !ignore_section_sym(abfd, sym_0)
            && (*sect_syms.offset((*asect).index as isize)).is_null()
        {
            if !sym_is_global(abfd, (*asect).symbol) {
                num_locals = num_locals.wrapping_add(1);
                num_locals;
            } else {
                num_globals = num_globals.wrapping_add(1);
                num_globals;
            }
        }
        asect = (*asect).next;
    }
    amt = (num_locals.wrapping_add(num_globals) as libc::c_ulong)
        .wrapping_mul(::core::mem::size_of::<*mut asymbol>() as libc::c_ulong);
    new_syms = bfd_alloc(abfd, amt) as *mut *mut asymbol;
    if new_syms.is_null() {
        return 0 as libc::c_int != 0;
    }
    let mut current_block_43: u64;
    idx = 0 as libc::c_int as libc::c_uint;
    while idx < symcount {
        let mut sym_1: *mut asymbol = *syms.offset(idx as isize);
        let mut i: libc::c_uint = 0;
        if sym_is_global(abfd, sym_1) {
            let fresh43 = num_globals2;
            num_globals2 = num_globals2.wrapping_add(1);
            i = num_locals.wrapping_add(fresh43);
            current_block_43 = 1847472278776910194;
        } else if !ignore_section_sym(abfd, sym_1) {
            let fresh44 = num_locals2;
            num_locals2 = num_locals2.wrapping_add(1);
            i = fresh44;
            current_block_43 = 1847472278776910194;
        } else {
            current_block_43 = 7746103178988627676;
        }
        match current_block_43 {
            1847472278776910194 => {
                let ref mut fresh45 = *new_syms.offset(i as isize);
                *fresh45 = sym_1;
                (*sym_1)
                    .udata
                    .i = i.wrapping_add(1 as libc::c_int as libc::c_uint) as bfd_vma;
            }
            _ => {}
        }
        idx = idx.wrapping_add(1);
        idx;
    }
    asect = (*abfd).sections;
    while !asect.is_null() {
        let mut sym_2: *mut asymbol = (*asect).symbol;
        if !ignore_section_sym(abfd, sym_2)
            && (*sect_syms.offset((*asect).index as isize)).is_null()
        {
            let mut i_0: libc::c_uint = 0;
            let ref mut fresh46 = *sect_syms.offset((*asect).index as isize);
            *fresh46 = sym_2;
            if !sym_is_global(abfd, sym_2) {
                let fresh47 = num_locals2;
                num_locals2 = num_locals2.wrapping_add(1);
                i_0 = fresh47;
            } else {
                let fresh48 = num_globals2;
                num_globals2 = num_globals2.wrapping_add(1);
                i_0 = num_locals.wrapping_add(fresh48);
            }
            let ref mut fresh49 = *new_syms.offset(i_0 as isize);
            *fresh49 = sym_2;
            (*sym_2)
                .udata
                .i = i_0.wrapping_add(1 as libc::c_int as libc::c_uint) as bfd_vma;
        }
        asect = (*asect).next;
    }
    bfd_set_symtab(abfd, new_syms, num_locals.wrapping_add(num_globals));
    *pnum_locals = num_locals;
    return 1 as libc::c_int != 0;
}
#[inline]
unsafe extern "C" fn align_file_position(
    mut off: file_ptr,
    mut align: libc::c_int,
) -> file_ptr {
    return off + align as libc::c_long - 1 as libc::c_int as libc::c_long
        & !(align - 1 as libc::c_int) as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_assign_file_position_for_section(
    mut i_shdrp: *mut Elf_Internal_Shdr,
    mut offset: file_ptr,
    mut align: bool,
) -> file_ptr {
    if align as libc::c_int != 0
        && (*i_shdrp).sh_addralign > 1 as libc::c_int as libc::c_ulong
    {
        offset = (if (offset as bfd_vma)
            .wrapping_add((*i_shdrp).sh_addralign)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) >= offset as bfd_vma
        {
            (offset as bfd_vma)
                .wrapping_add(
                    ((*i_shdrp).sh_addralign)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                )
                & !((*i_shdrp).sh_addralign)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        } else {
            !(0 as libc::c_int as bfd_vma)
        }) as file_ptr;
    }
    (*i_shdrp).sh_offset = offset;
    if !((*i_shdrp).bfd_section).is_null() {
        (*(*i_shdrp).bfd_section).filepos = offset;
    }
    if (*i_shdrp).sh_type != 8 as libc::c_int as libc::c_uint {
        offset = (offset as libc::c_ulong).wrapping_add((*i_shdrp).sh_size) as file_ptr
            as file_ptr;
    }
    return offset;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_compute_section_file_positions(
    mut abfd: *mut bfd,
    mut link_info: *mut bfd_link_info,
) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut fsargs: fake_section_arg = fake_section_arg {
        link_info: 0 as *mut bfd_link_info,
        failed: false,
    };
    let mut failed: bool = false;
    let mut strtab: *mut elf_strtab_hash = 0 as *mut elf_strtab_hash;
    let mut shstrtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut need_symtab: bool = false;
    if (*abfd).output_has_begun() != 0 {
        return 1 as libc::c_int != 0;
    }
    if ((*bed).elf_backend_begin_write_processing).is_some() {
        (Some(
            ((*bed).elf_backend_begin_write_processing)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd, link_info);
    }
    if !(Some(((*bed).elf_backend_init_file_header).expect("non-null function pointer")))
        .expect("non-null function pointer")(abfd, link_info)
    {
        return 0 as libc::c_int != 0;
    }
    fsargs.failed = 0 as libc::c_int != 0;
    fsargs.link_info = link_info;
    bfd_map_over_sections(
        abfd,
        Some(
            elf_fake_sections
                as unsafe extern "C" fn(*mut bfd, *mut asection, *mut libc::c_void) -> (),
        ),
        &mut fsargs as *mut fake_section_arg as *mut libc::c_void,
    );
    if fsargs.failed {
        return 0 as libc::c_int != 0;
    }
    if !assign_section_numbers(abfd, link_info) {
        return 0 as libc::c_int != 0;
    }
    need_symtab = link_info.is_null()
        && (bfd_get_symcount(abfd) > 0 as libc::c_int as libc::c_uint
            || (*abfd).flags
                & (0x2 as libc::c_int | 0x40 as libc::c_int | 0x1 as libc::c_int)
                    as libc::c_uint == 0x1 as libc::c_int as libc::c_uint);
    if need_symtab {
        let mut relocatable_p: libc::c_int = ((*abfd).flags
            & (0x2 as libc::c_int | 0x40 as libc::c_int) as libc::c_uint == 0)
            as libc::c_int;
        if !swap_out_syms(abfd, &mut strtab, relocatable_p, link_info) {
            return 0 as libc::c_int != 0;
        }
    }
    failed = 0 as libc::c_int != 0;
    if link_info.is_null() {
        bfd_map_over_sections(
            abfd,
            Some(
                bfd_elf_set_group_contents
                    as unsafe extern "C" fn(
                        *mut bfd,
                        *mut asection,
                        *mut libc::c_void,
                    ) -> (),
            ),
            &mut failed as *mut bool as *mut libc::c_void,
        );
        if failed {
            return 0 as libc::c_int != 0;
        }
    }
    shstrtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
    (*shstrtab_hdr).sh_type = 3 as libc::c_int as libc::c_uint;
    (*shstrtab_hdr).sh_flags = (*bed).elf_strtab_flags;
    (*shstrtab_hdr).sh_addr = 0 as libc::c_int as bfd_vma;
    (*shstrtab_hdr).sh_entsize = 0 as libc::c_int as bfd_size_type;
    (*shstrtab_hdr).sh_link = 0 as libc::c_int as libc::c_uint;
    (*shstrtab_hdr).sh_info = 0 as libc::c_int as libc::c_uint;
    (*shstrtab_hdr).sh_addralign = 1 as libc::c_int as bfd_vma;
    if !assign_file_positions_except_relocs(abfd, link_info) {
        return 0 as libc::c_int != 0;
    }
    if need_symtab {
        let mut off: file_ptr = 0;
        let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        off = (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos;
        hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
        off = _bfd_elf_assign_file_position_for_section(hdr, off, 1 as libc::c_int != 0);
        if !((*(*abfd).tdata.elf_obj_data).symtab_shndx_list).is_null() {
            hdr = &mut (*(*(*abfd).tdata.elf_obj_data).symtab_shndx_list).hdr;
            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong {
                off = _bfd_elf_assign_file_position_for_section(
                    hdr,
                    off,
                    1 as libc::c_int != 0,
                );
            }
        }
        hdr = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
        off = _bfd_elf_assign_file_position_for_section(hdr, off, 1 as libc::c_int != 0);
        (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos = off;
        if bfd_seek(abfd, (*hdr).sh_offset, 0 as libc::c_int) != 0 as libc::c_int
            || !_bfd_elf_strtab_emit(abfd, strtab)
        {
            return 0 as libc::c_int != 0;
        }
        _bfd_elf_strtab_free(strtab);
    }
    (*abfd).set_output_has_begun(1 as libc::c_int as libc::c_uint);
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn get_program_header_size(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bfd_size_type {
    let mut segs: size_t = 0;
    let mut s: *mut asection = 0 as *mut asection;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    segs = 2 as libc::c_int as size_t;
    s = bfd_get_section_by_name(abfd, b".interp\0" as *const u8 as *const libc::c_char);
    if !s.is_null()
        && (*s).flags & 0x2 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
        && (*s).size != 0 as libc::c_int as libc::c_ulong
    {
        segs = (segs as libc::c_ulong).wrapping_add(2 as libc::c_int as libc::c_ulong)
            as size_t as size_t;
    }
    if !(bfd_get_section_by_name(
        abfd,
        b".dynamic\0" as *const u8 as *const libc::c_char,
    ))
        .is_null()
    {
        segs = segs.wrapping_add(1);
        segs;
    }
    if !info.is_null() && (*info).relro() as libc::c_int != 0 {
        segs = segs.wrapping_add(1);
        segs;
    }
    if !((*(*(*abfd).tdata.elf_obj_data).o).eh_frame_hdr).is_null() {
        segs = segs.wrapping_add(1);
        segs;
    }
    if (*(*(*abfd).tdata.elf_obj_data).o).stack_flags != 0 {
        segs = segs.wrapping_add(1);
        segs;
    }
    s = bfd_get_section_by_name(
        abfd,
        b".note.gnu.property\0" as *const u8 as *const libc::c_char,
    );
    if !s.is_null() && (*s).size != 0 as libc::c_int as libc::c_ulong {
        segs = segs.wrapping_add(1);
        segs;
    }
    s = (*abfd).sections;
    while !s.is_null() {
        if (*s).flags & 0x2 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint
            && (*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
                == 7 as libc::c_int as libc::c_uint
        {
            let mut alignment_power: libc::c_uint = 0;
            segs = segs.wrapping_add(1);
            segs;
            alignment_power = (*s).alignment_power;
            while !((*s).next).is_null()
                && (*(*s).next).alignment_power == alignment_power
                && (*(*s).next).flags & 0x2 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                && (*((*(*s).next).used_by_bfd as *mut bfd_elf_section_data))
                    .this_hdr
                    .sh_type == 7 as libc::c_int as libc::c_uint
            {
                s = (*s).next;
            }
        }
        s = (*s).next;
    }
    s = (*abfd).sections;
    while !s.is_null() {
        if (*s).flags & 0x400 as libc::c_int as libc::c_uint != 0 {
            segs = segs.wrapping_add(1);
            segs;
            break;
        } else {
            s = (*s).next;
        }
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if (*abfd).flags & 0x100 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
        && (*(*abfd).tdata.elf_obj_data).has_gnu_osabi() as libc::c_int
            & elf_gnu_osabi_mbind as libc::c_int != 0 as libc::c_int
    {
        let mut commonpagesize: bfd_vma = 0;
        let mut page_align_power: libc::c_uint = 0;
        if !info.is_null() {
            commonpagesize = (*info).commonpagesize;
        } else {
            commonpagesize = (*bed).commonpagesize;
        }
        page_align_power = bfd_log2(commonpagesize);
        s = (*abfd).sections;
        while !s.is_null() {
            if (*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_flags
                & 0x1000000 as libc::c_int as libc::c_ulong != 0
            {
                if (*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_info
                    > 4096 as libc::c_int as libc::c_uint
                {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: GNU_MBIND section `%pA' has invalid sh_info field: %d\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        s,
                        (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_info,
                    );
                } else {
                    if (*s).alignment_power < page_align_power {
                        (*s).alignment_power = page_align_power;
                    }
                    segs = segs.wrapping_add(1);
                    segs;
                }
            }
            s = (*s).next;
        }
    }
    if ((*bed).elf_backend_additional_program_headers).is_some() {
        let mut a: libc::c_int = 0;
        a = (Some(
            ((*bed).elf_backend_additional_program_headers)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd, info);
        if a == -(1 as libc::c_int) {
            _bfd_abort(
                b"elf.c\0" as *const u8 as *const libc::c_char,
                4490 as libc::c_int,
                (*::core::mem::transmute::<
                    &[u8; 69],
                    &[libc::c_char; 69],
                >(
                    b"bfd_size_type get_program_header_size(bfd *, struct bfd_link_info *)\0",
                ))
                    .as_ptr(),
            );
        }
        segs = (segs as libc::c_ulong).wrapping_add(a as libc::c_ulong) as size_t
            as size_t;
    }
    return segs.wrapping_mul((*(*bed).s).sizeof_phdr as libc::c_ulong);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_find_segment_containing_section(
    mut abfd: *mut bfd,
    mut section: *mut asection,
) -> *mut Elf_Internal_Phdr {
    let mut m: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut p: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    m = (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
    p = (*(*abfd).tdata.elf_obj_data).phdr;
    while !m.is_null() {
        let mut i: libc::c_int = 0;
        i = ((*m).count).wrapping_sub(1 as libc::c_int as libc::c_uint) as libc::c_int;
        while i >= 0 as libc::c_int {
            if *((*m).sections).as_mut_ptr().offset(i as isize) == section {
                return p;
            }
            i -= 1;
            i;
        }
        m = (*m).next;
        p = p.offset(1);
        p;
    }
    return 0 as *mut Elf_Internal_Phdr;
}
unsafe extern "C" fn make_mapping(
    mut abfd: *mut bfd,
    mut sections: *mut *mut asection,
    mut from: libc::c_uint,
    mut to: libc::c_uint,
    mut phdr: bool,
) -> *mut elf_segment_map {
    let mut m: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut i: libc::c_uint = 0;
    let mut hdrpp: *mut *mut asection = 0 as *mut *mut asection;
    let mut amt: size_t = 0;
    amt = (::core::mem::size_of::<elf_segment_map>() as libc::c_ulong)
        .wrapping_sub(::core::mem::size_of::<*mut asection>() as libc::c_ulong);
    amt = (amt as libc::c_ulong)
        .wrapping_add(
            (to.wrapping_sub(from) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut asection>() as libc::c_ulong),
        ) as size_t as size_t;
    m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
    if m.is_null() {
        return 0 as *mut elf_segment_map;
    }
    (*m).next = 0 as *mut elf_segment_map;
    (*m).p_type = 1 as libc::c_int as libc::c_ulong;
    i = from;
    hdrpp = sections.offset(from as isize);
    while i < to {
        let ref mut fresh50 = *((*m).sections)
            .as_mut_ptr()
            .offset(i.wrapping_sub(from) as isize);
        *fresh50 = *hdrpp;
        i = i.wrapping_add(1);
        i;
        hdrpp = hdrpp.offset(1);
        hdrpp;
    }
    (*m).count = to.wrapping_sub(from);
    if from == 0 as libc::c_int as libc::c_uint && phdr as libc::c_int != 0 {
        (*m).set_includes_filehdr(1 as libc::c_int as libc::c_uint);
        (*m).set_includes_phdrs(1 as libc::c_int as libc::c_uint);
    }
    return m;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_make_dynamic_segment(
    mut abfd: *mut bfd,
    mut dynsec: *mut asection,
) -> *mut elf_segment_map {
    let mut m: *mut elf_segment_map = 0 as *mut elf_segment_map;
    m = bfd_zalloc(abfd, ::core::mem::size_of::<elf_segment_map>() as libc::c_ulong)
        as *mut elf_segment_map;
    if m.is_null() {
        return 0 as *mut elf_segment_map;
    }
    (*m).next = 0 as *mut elf_segment_map;
    (*m).p_type = 2 as libc::c_int as libc::c_ulong;
    (*m).count = 1 as libc::c_int as libc::c_uint;
    let ref mut fresh51 = *((*m).sections)
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize);
    *fresh51 = dynsec;
    return m;
}
unsafe extern "C" fn elf_modify_segment_map(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut remove_empty_load: bool,
) -> bool {
    let mut m: *mut *mut elf_segment_map = 0 as *mut *mut elf_segment_map;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    m = &mut (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
    while !(*m).is_null() {
        let mut i: libc::c_uint = 0;
        let mut new_count: libc::c_uint = 0;
        new_count = 0 as libc::c_int as libc::c_uint;
        i = 0 as libc::c_int as libc::c_uint;
        while i < (**m).count {
            if (**((**m).sections).as_mut_ptr().offset(i as isize)).flags
                & 0x8000 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
                && ((**((**m).sections).as_mut_ptr().offset(i as isize)).flags
                    & 0x1 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                    || (**m).p_type != 1 as libc::c_int as libc::c_ulong)
            {
                let ref mut fresh52 = *((**m).sections)
                    .as_mut_ptr()
                    .offset(new_count as isize);
                *fresh52 = *((**m).sections).as_mut_ptr().offset(i as isize);
                new_count = new_count.wrapping_add(1);
                new_count;
            }
            i = i.wrapping_add(1);
            i;
        }
        (**m).count = new_count;
        if remove_empty_load as libc::c_int != 0
            && (**m).p_type == 1 as libc::c_int as libc::c_ulong
            && (**m).count == 0 as libc::c_int as libc::c_uint
            && (**m).includes_phdrs() == 0
        {
            *m = (**m).next;
        } else {
            m = &mut (**m).next;
        }
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if ((*bed).elf_backend_modify_segment_map).is_some() {
        if !(Some(
            ((*bed).elf_backend_modify_segment_map).expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd, info)
        {
            return 0 as libc::c_int != 0;
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_map_sections_to_segments(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut current_block: u64;
    let mut count: libc::c_uint = 0;
    let mut m: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut sections: *mut *mut asection = 0 as *mut *mut asection;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut no_user_phdrs: bool = false;
    no_user_phdrs = ((*(*(*abfd).tdata.elf_obj_data).o).seg_map).is_null();
    if !info.is_null() {
        (*info).set_user_phdrs(!no_user_phdrs as libc::c_int as libc::c_uint);
    }
    if no_user_phdrs as libc::c_int != 0
        && bfd_count_sections(abfd) != 0 as libc::c_int as libc::c_uint
    {
        let mut s: *mut asection = 0 as *mut asection;
        let mut i: libc::c_uint = 0;
        let mut mfirst: *mut elf_segment_map = 0 as *mut elf_segment_map;
        let mut pm: *mut *mut elf_segment_map = 0 as *mut *mut elf_segment_map;
        let mut last_hdr: *mut asection = 0 as *mut asection;
        let mut last_size: bfd_vma = 0;
        let mut hdr_index: libc::c_uint = 0;
        let mut maxpagesize: bfd_vma = 0;
        let mut hdrpp: *mut *mut asection = 0 as *mut *mut asection;
        let mut phdr_in_segment: bool = false;
        let mut writable: bool = false;
        let mut executable: bool = false;
        let mut tls_count: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        let mut first_tls: *mut asection = 0 as *mut asection;
        let mut first_mbind: *mut asection = 0 as *mut asection;
        let mut dynsec: *mut asection = 0 as *mut asection;
        let mut eh_frame_hdr: *mut asection = 0 as *mut asection;
        let mut amt: size_t = 0;
        let mut addr_mask: bfd_vma = 0;
        let mut wrap_to: bfd_vma = 0 as libc::c_int as bfd_vma;
        let mut phdr_size: bfd_size_type = 0;
        let mut opb: libc::c_uint = bfd_octets_per_byte(abfd, 0 as *const asection);
        amt = (bfd_count_sections(abfd) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut asection>() as libc::c_ulong);
        sections = bfd_malloc(amt) as *mut *mut asection;
        if sections.is_null() {
            current_block = 9161507880131146499;
        } else {
            addr_mask = ((1 as libc::c_int as bfd_vma)
                << (bfd_arch_bits_per_address(abfd))
                    .wrapping_sub(1 as libc::c_int as libc::c_uint))
                .wrapping_sub(1 as libc::c_int as libc::c_ulong);
            addr_mask = (addr_mask << 1 as libc::c_int)
                .wrapping_add(1 as libc::c_int as libc::c_ulong);
            i = 0 as libc::c_int as libc::c_uint;
            s = (*abfd).sections;
            while !s.is_null() {
                if (*s).flags & 0x1 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                {
                    (*s).target_index = i as libc::c_int;
                    let ref mut fresh53 = *sections.offset(i as isize);
                    *fresh53 = s;
                    i = i.wrapping_add(1);
                    i;
                    if ((*s).lma)
                        .wrapping_add(((*s).size).wrapping_div(opb as libc::c_ulong))
                        & addr_mask < (*s).lma & addr_mask
                    {
                        wrap_to = ((*s).lma)
                            .wrapping_add(((*s).size).wrapping_div(opb as libc::c_ulong))
                            & addr_mask;
                    }
                }
                s = (*s).next;
            }
            if !(i <= bfd_count_sections(abfd)) {
                bfd_assert(
                    b"elf.c\0" as *const u8 as *const libc::c_char,
                    4696 as libc::c_int,
                );
            }
            count = i;
            qsort(
                sections as *mut libc::c_void,
                count as size_t,
                ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                Some(
                    elf_sort_sections
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
            phdr_size = (*(*(*abfd).tdata.elf_obj_data).o).program_header_size;
            if phdr_size == -(1 as libc::c_int) as bfd_size_type {
                phdr_size = get_program_header_size(abfd, info);
            }
            phdr_size = (phdr_size as libc::c_ulong)
                .wrapping_add((*(*bed).s).sizeof_ehdr as libc::c_ulong) as bfd_size_type
                as bfd_size_type;
            phdr_size = (phdr_size as libc::c_ulong).wrapping_div(opb as libc::c_ulong)
                as bfd_size_type as bfd_size_type;
            if !info.is_null() {
                maxpagesize = (*info).maxpagesize;
            } else {
                maxpagesize = (*bed).maxpagesize;
            }
            if maxpagesize == 0 as libc::c_int as libc::c_ulong {
                maxpagesize = 1 as libc::c_int as bfd_vma;
            }
            phdr_in_segment = !info.is_null()
                && (*info).load_phdrs() as libc::c_int != 0;
            if count != 0 as libc::c_int as libc::c_uint
                && (**sections.offset(0 as libc::c_int as isize)).lma & addr_mask
                    & maxpagesize.wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    >= phdr_size
                        & maxpagesize.wrapping_sub(1 as libc::c_int as libc::c_ulong)
            {
                phdr_in_segment = 1 as libc::c_int != 0;
            }
            mfirst = 0 as *mut elf_segment_map;
            pm = &mut mfirst;
            s = bfd_get_section_by_name(
                abfd,
                b".interp\0" as *const u8 as *const libc::c_char,
            );
            if !s.is_null()
                && (*s).flags & 0x2 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                && (*s).size != 0 as libc::c_int as libc::c_ulong
            {
                amt = ::core::mem::size_of::<elf_segment_map>() as libc::c_ulong;
                m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                if m.is_null() {
                    current_block = 9161507880131146499;
                } else {
                    (*m).next = 0 as *mut elf_segment_map;
                    (*m).p_type = 6 as libc::c_int as libc::c_ulong;
                    (*m)
                        .p_flags = ((1 as libc::c_int) << 2 as libc::c_int)
                        as libc::c_ulong;
                    (*m).set_p_flags_valid(1 as libc::c_int as libc::c_uint);
                    (*m).set_includes_phdrs(1 as libc::c_int as libc::c_uint);
                    phdr_in_segment = 1 as libc::c_int != 0;
                    *pm = m;
                    pm = &mut (*m).next;
                    amt = ::core::mem::size_of::<elf_segment_map>() as libc::c_ulong;
                    m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                    if m.is_null() {
                        current_block = 9161507880131146499;
                    } else {
                        (*m).next = 0 as *mut elf_segment_map;
                        (*m).p_type = 3 as libc::c_int as libc::c_ulong;
                        (*m).count = 1 as libc::c_int as libc::c_uint;
                        let ref mut fresh54 = *((*m).sections)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize);
                        *fresh54 = s;
                        *pm = m;
                        pm = &mut (*m).next;
                        current_block = 17233182392562552756;
                    }
                }
            } else {
                current_block = 17233182392562552756;
            }
            match current_block {
                9161507880131146499 => {}
                _ => {
                    last_hdr = 0 as *mut asection;
                    last_size = 0 as libc::c_int as bfd_vma;
                    hdr_index = 0 as libc::c_int as libc::c_uint;
                    writable = 0 as libc::c_int != 0;
                    executable = 0 as libc::c_int != 0;
                    dynsec = bfd_get_section_by_name(
                        abfd,
                        b".dynamic\0" as *const u8 as *const libc::c_char,
                    );
                    if !dynsec.is_null()
                        && (*dynsec).flags & 0x2 as libc::c_int as libc::c_uint
                            == 0 as libc::c_int as libc::c_uint
                    {
                        dynsec = 0 as *mut asection;
                    }
                    if (*abfd).flags & 0x100 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        phdr_in_segment = 0 as libc::c_int != 0;
                    }
                    if phdr_in_segment as libc::c_int != 0
                        && count > 0 as libc::c_int as libc::c_uint
                    {
                        let mut phdr_lma: bfd_vma = 0;
                        let mut separate_phdr: bool = 0 as libc::c_int != 0;
                        phdr_lma = ((**sections.offset(0 as libc::c_int as isize)).lma)
                            .wrapping_sub(phdr_size) & addr_mask
                            & maxpagesize.wrapping_neg();
                        if !info.is_null() && (*info).separate_code() as libc::c_int != 0
                            && (**sections.offset(0 as libc::c_int as isize)).flags
                                & 0x10 as libc::c_int as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                        {
                            separate_phdr = 1 as libc::c_int != 0;
                            if phdr_lma
                                .wrapping_add(phdr_size)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong) & addr_mask
                                & maxpagesize.wrapping_neg()
                                == (**sections.offset(0 as libc::c_int as isize)).lma
                                    & addr_mask & maxpagesize.wrapping_neg()
                            {
                                if phdr_lma >= maxpagesize {
                                    phdr_lma = (phdr_lma as libc::c_ulong)
                                        .wrapping_sub(maxpagesize) as bfd_vma as bfd_vma;
                                } else {
                                    separate_phdr = 0 as libc::c_int != 0;
                                }
                            }
                        }
                        if (**sections.offset(0 as libc::c_int as isize)).lma & addr_mask
                            < phdr_lma
                            || (**sections.offset(0 as libc::c_int as isize)).lma
                                & addr_mask < phdr_size
                        {
                            phdr_in_segment = 0 as libc::c_int != 0;
                            current_block = 2472048668343472511;
                        } else if phdr_lma < wrap_to {
                            phdr_in_segment = 0 as libc::c_int != 0;
                            current_block = 2472048668343472511;
                        } else if separate_phdr {
                            m = make_mapping(
                                abfd,
                                sections,
                                0 as libc::c_int as libc::c_uint,
                                0 as libc::c_int as libc::c_uint,
                                phdr_in_segment,
                            );
                            if m.is_null() {
                                current_block = 9161507880131146499;
                            } else {
                                (*m).p_paddr = phdr_lma.wrapping_mul(opb as libc::c_ulong);
                                (*m)
                                    .p_vaddr_offset = ((**sections
                                    .offset(0 as libc::c_int as isize))
                                    .vma)
                                    .wrapping_sub(phdr_size) & addr_mask
                                    & maxpagesize.wrapping_neg();
                                (*m).set_p_paddr_valid(1 as libc::c_int as libc::c_uint);
                                *pm = m;
                                pm = &mut (*m).next;
                                phdr_in_segment = 0 as libc::c_int != 0;
                                current_block = 2472048668343472511;
                            }
                        } else {
                            current_block = 2472048668343472511;
                        }
                    } else {
                        current_block = 2472048668343472511;
                    }
                    match current_block {
                        9161507880131146499 => {}
                        _ => {
                            i = 0 as libc::c_int as libc::c_uint;
                            hdrpp = sections;
                            loop {
                                if !(i < count) {
                                    current_block = 7244994750255146185;
                                    break;
                                }
                                let mut hdr: *mut asection = 0 as *mut asection;
                                let mut new_segment: bool = false;
                                hdr = *hdrpp;
                                if last_hdr.is_null() {
                                    new_segment = 0 as libc::c_int != 0;
                                } else if ((*last_hdr).lma).wrapping_sub((*last_hdr).vma)
                                    != ((*hdr).lma).wrapping_sub((*hdr).vma)
                                {
                                    new_segment = 1 as libc::c_int != 0;
                                } else if (*hdr).lma
                                    < ((*last_hdr).lma).wrapping_add(last_size)
                                    || ((*last_hdr).lma).wrapping_add(last_size)
                                        < (*last_hdr).lma
                                {
                                    new_segment = 1 as libc::c_int != 0;
                                } else if (*abfd).flags
                                    & 0x100 as libc::c_int as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                    && ((*last_hdr).lma)
                                        .wrapping_add(last_size)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                        & maxpagesize.wrapping_neg()
                                        == (*hdr).lma & maxpagesize.wrapping_neg()
                                {
                                    new_segment = 0 as libc::c_int != 0;
                                } else if (if ((*last_hdr).lma)
                                    .wrapping_add(last_size)
                                    .wrapping_add(maxpagesize)
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                    >= ((*last_hdr).lma).wrapping_add(last_size)
                                {
                                    ((*last_hdr).lma)
                                        .wrapping_add(last_size)
                                        .wrapping_add(
                                            maxpagesize.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                        )
                                        & !maxpagesize
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                } else {
                                    !(0 as libc::c_int as bfd_vma)
                                })
                                    .wrapping_add(maxpagesize) > (*last_hdr).lma
                                    && (if ((*last_hdr).lma)
                                        .wrapping_add(last_size)
                                        .wrapping_add(maxpagesize)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                        >= ((*last_hdr).lma).wrapping_add(last_size)
                                    {
                                        ((*last_hdr).lma)
                                            .wrapping_add(last_size)
                                            .wrapping_add(
                                                maxpagesize.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                            )
                                            & !maxpagesize
                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                    } else {
                                        !(0 as libc::c_int as bfd_vma)
                                    })
                                        .wrapping_add(maxpagesize) <= (*hdr).lma
                                {
                                    new_segment = 1 as libc::c_int != 0;
                                } else if (*last_hdr).flags
                                    & (0x2 as libc::c_int | 0x400 as libc::c_int)
                                        as libc::c_uint == 0 as libc::c_int as libc::c_uint
                                    && (*hdr).flags
                                        & (0x2 as libc::c_int | 0x400 as libc::c_int)
                                            as libc::c_uint != 0 as libc::c_int as libc::c_uint
                                {
                                    new_segment = 1 as libc::c_int != 0;
                                } else if (*abfd).flags
                                    & 0x100 as libc::c_int as libc::c_uint
                                    == 0 as libc::c_int as libc::c_uint
                                {
                                    new_segment = 0 as libc::c_int != 0;
                                } else if !info.is_null()
                                    && (*info).separate_code() as libc::c_int != 0
                                    && executable as libc::c_int
                                        != ((*hdr).flags & 0x10 as libc::c_int as libc::c_uint
                                            != 0 as libc::c_int as libc::c_uint) as libc::c_int
                                {
                                    new_segment = 1 as libc::c_int != 0;
                                } else if !writable
                                    && (*hdr).flags & 0x8 as libc::c_int as libc::c_uint
                                        == 0 as libc::c_int as libc::c_uint
                                {
                                    new_segment = 1 as libc::c_int != 0;
                                } else {
                                    new_segment = 0 as libc::c_int != 0;
                                }
                                if !last_hdr.is_null() && !info.is_null()
                                    && ((*(*info).callbacks).override_segment_assignment)
                                        .is_some()
                                {
                                    new_segment = ((*(*info).callbacks)
                                        .override_segment_assignment)
                                        .expect(
                                            "non-null function pointer",
                                        )(info, abfd, hdr, last_hdr, new_segment);
                                }
                                if !new_segment {
                                    if (*hdr).flags & 0x8 as libc::c_int as libc::c_uint
                                        == 0 as libc::c_int as libc::c_uint
                                    {
                                        writable = 1 as libc::c_int != 0;
                                    }
                                    if (*hdr).flags & 0x10 as libc::c_int as libc::c_uint
                                        != 0 as libc::c_int as libc::c_uint
                                    {
                                        executable = 1 as libc::c_int != 0;
                                    }
                                    last_hdr = hdr;
                                    last_size = (if !((*hdr).flags
                                        & (0x400 as libc::c_int | 0x2 as libc::c_int)
                                            as libc::c_uint == 0x400 as libc::c_int as libc::c_uint)
                                    {
                                        (*hdr).size
                                    } else {
                                        0 as libc::c_int as libc::c_ulong
                                    })
                                        .wrapping_div(opb as libc::c_ulong);
                                } else {
                                    m = make_mapping(
                                        abfd,
                                        sections,
                                        hdr_index,
                                        i,
                                        phdr_in_segment,
                                    );
                                    if m.is_null() {
                                        current_block = 9161507880131146499;
                                        break;
                                    }
                                    *pm = m;
                                    pm = &mut (*m).next;
                                    if (*hdr).flags & 0x8 as libc::c_int as libc::c_uint
                                        == 0 as libc::c_int as libc::c_uint
                                    {
                                        writable = 1 as libc::c_int != 0;
                                    } else {
                                        writable = 0 as libc::c_int != 0;
                                    }
                                    if (*hdr).flags & 0x10 as libc::c_int as libc::c_uint
                                        == 0 as libc::c_int as libc::c_uint
                                    {
                                        executable = 0 as libc::c_int != 0;
                                    } else {
                                        executable = 1 as libc::c_int != 0;
                                    }
                                    last_hdr = hdr;
                                    last_size = (if !((*hdr).flags
                                        & (0x400 as libc::c_int | 0x2 as libc::c_int)
                                            as libc::c_uint == 0x400 as libc::c_int as libc::c_uint)
                                    {
                                        (*hdr).size
                                    } else {
                                        0 as libc::c_int as libc::c_ulong
                                    })
                                        .wrapping_div(opb as libc::c_ulong);
                                    hdr_index = i;
                                    phdr_in_segment = 0 as libc::c_int != 0;
                                }
                                i = i.wrapping_add(1);
                                i;
                                hdrpp = hdrpp.offset(1);
                                hdrpp;
                            }
                            match current_block {
                                9161507880131146499 => {}
                                _ => {
                                    if !last_hdr.is_null()
                                        && (i.wrapping_sub(hdr_index)
                                            != 1 as libc::c_int as libc::c_uint
                                            || !((*last_hdr).flags
                                                & (0x400 as libc::c_int | 0x2 as libc::c_int)
                                                    as libc::c_uint == 0x400 as libc::c_int as libc::c_uint))
                                    {
                                        m = make_mapping(
                                            abfd,
                                            sections,
                                            hdr_index,
                                            i,
                                            phdr_in_segment,
                                        );
                                        if m.is_null() {
                                            current_block = 9161507880131146499;
                                        } else {
                                            *pm = m;
                                            pm = &mut (*m).next;
                                            current_block = 10357520176418200368;
                                        }
                                    } else {
                                        current_block = 10357520176418200368;
                                    }
                                    match current_block {
                                        9161507880131146499 => {}
                                        _ => {
                                            if !dynsec.is_null() {
                                                m = _bfd_elf_make_dynamic_segment(abfd, dynsec);
                                                if m.is_null() {
                                                    current_block = 9161507880131146499;
                                                } else {
                                                    *pm = m;
                                                    pm = &mut (*m).next;
                                                    current_block = 11235674318412060590;
                                                }
                                            } else {
                                                current_block = 11235674318412060590;
                                            }
                                            match current_block {
                                                9161507880131146499 => {}
                                                _ => {
                                                    s = (*abfd).sections;
                                                    loop {
                                                        if s.is_null() {
                                                            current_block = 10282596542094995802;
                                                            break;
                                                        }
                                                        if (*s).flags & 0x2 as libc::c_int as libc::c_uint
                                                            != 0 as libc::c_int as libc::c_uint
                                                            && (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                                                .this_hdr
                                                                .sh_type == 7 as libc::c_int as libc::c_uint
                                                        {
                                                            let mut s2: *mut asection = 0 as *mut asection;
                                                            let mut alignment_power: libc::c_uint = (*s)
                                                                .alignment_power;
                                                            count = 1 as libc::c_int as libc::c_uint;
                                                            s2 = s;
                                                            while !((*s2).next).is_null() {
                                                                if !((*(*s2).next).alignment_power == alignment_power
                                                                    && (*(*s2).next).flags & 0x2 as libc::c_int as libc::c_uint
                                                                        != 0 as libc::c_int as libc::c_uint
                                                                    && (*((*(*s2).next).used_by_bfd
                                                                        as *mut bfd_elf_section_data))
                                                                        .this_hdr
                                                                        .sh_type == 7 as libc::c_int as libc::c_uint
                                                                    && ((*s2).lma)
                                                                        .wrapping_add(
                                                                            ((*s2).size).wrapping_div(opb as libc::c_ulong),
                                                                        )
                                                                        .wrapping_add(
                                                                            (1 as libc::c_int as bfd_vma) << alignment_power,
                                                                        )
                                                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                                                        & ((1 as libc::c_int as bfd_vma) << alignment_power)
                                                                            .wrapping_neg() == (*(*s2).next).lma)
                                                                {
                                                                    break;
                                                                }
                                                                count = count.wrapping_add(1);
                                                                count;
                                                                s2 = (*s2).next;
                                                            }
                                                            amt = (::core::mem::size_of::<elf_segment_map>()
                                                                as libc::c_ulong)
                                                                .wrapping_sub(
                                                                    ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                                                );
                                                            amt = (amt as libc::c_ulong)
                                                                .wrapping_add(
                                                                    (count as libc::c_ulong)
                                                                        .wrapping_mul(
                                                                            ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                                                        ),
                                                                ) as size_t as size_t;
                                                            m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                                                            if m.is_null() {
                                                                current_block = 9161507880131146499;
                                                                break;
                                                            }
                                                            (*m).next = 0 as *mut elf_segment_map;
                                                            (*m).p_type = 4 as libc::c_int as libc::c_ulong;
                                                            (*m).count = count;
                                                            while count > 1 as libc::c_int as libc::c_uint {
                                                                let fresh55 = count;
                                                                count = count.wrapping_sub(1);
                                                                let ref mut fresh56 = *((*m).sections)
                                                                    .as_mut_ptr()
                                                                    .offset(((*m).count).wrapping_sub(fresh55) as isize);
                                                                *fresh56 = s;
                                                                if !((*s).flags & 0x400 as libc::c_int as libc::c_uint
                                                                    == 0 as libc::c_int as libc::c_uint)
                                                                {
                                                                    bfd_assert(
                                                                        b"elf.c\0" as *const u8 as *const libc::c_char,
                                                                        5026 as libc::c_int,
                                                                    );
                                                                }
                                                                s = (*s).next;
                                                            }
                                                            let ref mut fresh57 = *((*m).sections)
                                                                .as_mut_ptr()
                                                                .offset(
                                                                    ((*m).count).wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                                        as isize,
                                                                );
                                                            *fresh57 = s;
                                                            if !((*s).flags & 0x400 as libc::c_int as libc::c_uint
                                                                == 0 as libc::c_int as libc::c_uint)
                                                            {
                                                                bfd_assert(
                                                                    b"elf.c\0" as *const u8 as *const libc::c_char,
                                                                    5030 as libc::c_int,
                                                                );
                                                            }
                                                            *pm = m;
                                                            pm = &mut (*m).next;
                                                        }
                                                        if (*s).flags & 0x400 as libc::c_int as libc::c_uint != 0 {
                                                            if tls_count == 0 {
                                                                first_tls = s;
                                                            }
                                                            tls_count = tls_count.wrapping_add(1);
                                                            tls_count;
                                                        }
                                                        if first_mbind.is_null()
                                                            && (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                                                .this_hdr
                                                                .sh_flags & 0x1000000 as libc::c_int as libc::c_ulong
                                                                != 0 as libc::c_int as libc::c_ulong
                                                        {
                                                            first_mbind = s;
                                                        }
                                                        s = (*s).next;
                                                    }
                                                    match current_block {
                                                        9161507880131146499 => {}
                                                        _ => {
                                                            if tls_count > 0 as libc::c_int as libc::c_uint {
                                                                amt = (::core::mem::size_of::<elf_segment_map>()
                                                                    as libc::c_ulong)
                                                                    .wrapping_sub(
                                                                        ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                                                    );
                                                                amt = (amt as libc::c_ulong)
                                                                    .wrapping_add(
                                                                        (tls_count as libc::c_ulong)
                                                                            .wrapping_mul(
                                                                                ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                                                            ),
                                                                    ) as size_t as size_t;
                                                                m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                                                                if m.is_null() {
                                                                    current_block = 9161507880131146499;
                                                                } else {
                                                                    (*m).next = 0 as *mut elf_segment_map;
                                                                    (*m).p_type = 7 as libc::c_int as libc::c_ulong;
                                                                    (*m).count = tls_count;
                                                                    (*m)
                                                                        .p_flags = ((1 as libc::c_int) << 2 as libc::c_int)
                                                                        as libc::c_ulong;
                                                                    (*m).set_p_flags_valid(1 as libc::c_int as libc::c_uint);
                                                                    s = first_tls;
                                                                    i = 0 as libc::c_int as libc::c_uint;
                                                                    loop {
                                                                        if !(i < tls_count) {
                                                                            current_block = 10710847385228534238;
                                                                            break;
                                                                        }
                                                                        if (*s).flags & 0x400 as libc::c_int as libc::c_uint
                                                                            == 0 as libc::c_int as libc::c_uint
                                                                        {
                                                                            _bfd_error_handler(
                                                                                dcgettext(
                                                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                    b"%pB: TLS sections are not adjacent:\0" as *const u8
                                                                                        as *const libc::c_char,
                                                                                    5 as libc::c_int,
                                                                                ),
                                                                                abfd,
                                                                            );
                                                                            s = first_tls;
                                                                            i = 0 as libc::c_int as libc::c_uint;
                                                                            while i < tls_count {
                                                                                if (*s).flags & 0x400 as libc::c_int as libc::c_uint
                                                                                    != 0 as libc::c_int as libc::c_uint
                                                                                {
                                                                                    _bfd_error_handler(
                                                                                        dcgettext(
                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                            b"\t    TLS: %pA\0" as *const u8 as *const libc::c_char,
                                                                                            5 as libc::c_int,
                                                                                        ),
                                                                                        s,
                                                                                    );
                                                                                    i = i.wrapping_add(1);
                                                                                    i;
                                                                                } else {
                                                                                    _bfd_error_handler(
                                                                                        dcgettext(
                                                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                                                            b"\tnon-TLS: %pA\0" as *const u8 as *const libc::c_char,
                                                                                            5 as libc::c_int,
                                                                                        ),
                                                                                        s,
                                                                                    );
                                                                                }
                                                                                s = (*s).next;
                                                                            }
                                                                            bfd_set_error(bfd_error_bad_value);
                                                                            current_block = 9161507880131146499;
                                                                            break;
                                                                        } else {
                                                                            let ref mut fresh58 = *((*m).sections)
                                                                                .as_mut_ptr()
                                                                                .offset(i as isize);
                                                                            *fresh58 = s;
                                                                            s = (*s).next;
                                                                            i = i.wrapping_add(1);
                                                                            i;
                                                                        }
                                                                    }
                                                                    match current_block {
                                                                        9161507880131146499 => {}
                                                                        _ => {
                                                                            *pm = m;
                                                                            pm = &mut (*m).next;
                                                                            current_block = 14557636130817708122;
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                current_block = 14557636130817708122;
                                                            }
                                                            match current_block {
                                                                9161507880131146499 => {}
                                                                _ => {
                                                                    if !first_mbind.is_null()
                                                                        && (*abfd).flags & 0x100 as libc::c_int as libc::c_uint
                                                                            != 0 as libc::c_int as libc::c_uint
                                                                        && (*(*abfd).tdata.elf_obj_data).has_gnu_osabi()
                                                                            as libc::c_int & elf_gnu_osabi_mbind as libc::c_int
                                                                            != 0 as libc::c_int
                                                                    {
                                                                        s = first_mbind;
                                                                        loop {
                                                                            if s.is_null() {
                                                                                current_block = 17353026871531185123;
                                                                                break;
                                                                            }
                                                                            if (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                                                                .this_hdr
                                                                                .sh_flags & 0x1000000 as libc::c_int as libc::c_ulong
                                                                                != 0 as libc::c_int as libc::c_ulong
                                                                                && (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                                                                    .this_hdr
                                                                                    .sh_info <= 4096 as libc::c_int as libc::c_uint
                                                                            {
                                                                                let mut p_flags: libc::c_ulong = ((1 as libc::c_int)
                                                                                    << 2 as libc::c_int) as libc::c_ulong;
                                                                                if (*s).flags & 0x8 as libc::c_int as libc::c_uint
                                                                                    == 0 as libc::c_int as libc::c_uint
                                                                                {
                                                                                    p_flags
                                                                                        |= ((1 as libc::c_int) << 1 as libc::c_int)
                                                                                            as libc::c_ulong;
                                                                                }
                                                                                if (*s).flags & 0x10 as libc::c_int as libc::c_uint
                                                                                    != 0 as libc::c_int as libc::c_uint
                                                                                {
                                                                                    p_flags
                                                                                        |= ((1 as libc::c_int) << 0 as libc::c_int)
                                                                                            as libc::c_ulong;
                                                                                }
                                                                                amt = (::core::mem::size_of::<elf_segment_map>()
                                                                                    as libc::c_ulong)
                                                                                    .wrapping_add(
                                                                                        ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                                                                    );
                                                                                m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                                                                                if m.is_null() {
                                                                                    current_block = 9161507880131146499;
                                                                                    break;
                                                                                }
                                                                                (*m).next = 0 as *mut elf_segment_map;
                                                                                (*m)
                                                                                    .p_type = ((0x60000000 as libc::c_int
                                                                                    + 0x474e555 as libc::c_int) as libc::c_uint)
                                                                                    .wrapping_add(
                                                                                        (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                                                                            .this_hdr
                                                                                            .sh_info,
                                                                                    ) as libc::c_ulong;
                                                                                (*m).count = 1 as libc::c_int as libc::c_uint;
                                                                                (*m).set_p_flags_valid(1 as libc::c_int as libc::c_uint);
                                                                                let ref mut fresh59 = *((*m).sections)
                                                                                    .as_mut_ptr()
                                                                                    .offset(0 as libc::c_int as isize);
                                                                                *fresh59 = s;
                                                                                (*m).p_flags = p_flags;
                                                                                *pm = m;
                                                                                pm = &mut (*m).next;
                                                                            }
                                                                            s = (*s).next;
                                                                        }
                                                                    } else {
                                                                        current_block = 17353026871531185123;
                                                                    }
                                                                    match current_block {
                                                                        9161507880131146499 => {}
                                                                        _ => {
                                                                            s = bfd_get_section_by_name(
                                                                                abfd,
                                                                                b".note.gnu.property\0" as *const u8 as *const libc::c_char,
                                                                            );
                                                                            if !s.is_null()
                                                                                && (*s).size != 0 as libc::c_int as libc::c_ulong
                                                                            {
                                                                                amt = (::core::mem::size_of::<elf_segment_map>()
                                                                                    as libc::c_ulong)
                                                                                    .wrapping_add(
                                                                                        ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                                                                    );
                                                                                m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                                                                                if m.is_null() {
                                                                                    current_block = 9161507880131146499;
                                                                                } else {
                                                                                    (*m).next = 0 as *mut elf_segment_map;
                                                                                    (*m)
                                                                                        .p_type = (0x60000000 as libc::c_int
                                                                                        + 0x474e553 as libc::c_int) as libc::c_ulong;
                                                                                    (*m).count = 1 as libc::c_int as libc::c_uint;
                                                                                    (*m).set_p_flags_valid(1 as libc::c_int as libc::c_uint);
                                                                                    let ref mut fresh60 = *((*m).sections)
                                                                                        .as_mut_ptr()
                                                                                        .offset(0 as libc::c_int as isize);
                                                                                    *fresh60 = s;
                                                                                    (*m)
                                                                                        .p_flags = ((1 as libc::c_int) << 2 as libc::c_int)
                                                                                        as libc::c_ulong;
                                                                                    *pm = m;
                                                                                    pm = &mut (*m).next;
                                                                                    current_block = 6497888915984600225;
                                                                                }
                                                                            } else {
                                                                                current_block = 6497888915984600225;
                                                                            }
                                                                            match current_block {
                                                                                9161507880131146499 => {}
                                                                                _ => {
                                                                                    eh_frame_hdr = (*(*(*abfd).tdata.elf_obj_data).o)
                                                                                        .eh_frame_hdr;
                                                                                    if !eh_frame_hdr.is_null()
                                                                                        && (*(*eh_frame_hdr).output_section).flags
                                                                                            & 0x2 as libc::c_int as libc::c_uint
                                                                                            != 0 as libc::c_int as libc::c_uint
                                                                                    {
                                                                                        amt = ::core::mem::size_of::<elf_segment_map>()
                                                                                            as libc::c_ulong;
                                                                                        m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                                                                                        if m.is_null() {
                                                                                            current_block = 9161507880131146499;
                                                                                        } else {
                                                                                            (*m).next = 0 as *mut elf_segment_map;
                                                                                            (*m)
                                                                                                .p_type = (0x60000000 as libc::c_int
                                                                                                + 0x474e550 as libc::c_int) as libc::c_ulong;
                                                                                            (*m).count = 1 as libc::c_int as libc::c_uint;
                                                                                            let ref mut fresh61 = *((*m).sections)
                                                                                                .as_mut_ptr()
                                                                                                .offset(0 as libc::c_int as isize);
                                                                                            *fresh61 = (*eh_frame_hdr).output_section;
                                                                                            *pm = m;
                                                                                            pm = &mut (*m).next;
                                                                                            current_block = 12691661418490471423;
                                                                                        }
                                                                                    } else {
                                                                                        current_block = 12691661418490471423;
                                                                                    }
                                                                                    match current_block {
                                                                                        9161507880131146499 => {}
                                                                                        _ => {
                                                                                            if (*(*(*abfd).tdata.elf_obj_data).o).stack_flags != 0 {
                                                                                                amt = ::core::mem::size_of::<elf_segment_map>()
                                                                                                    as libc::c_ulong;
                                                                                                m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                                                                                                if m.is_null() {
                                                                                                    current_block = 9161507880131146499;
                                                                                                } else {
                                                                                                    (*m).next = 0 as *mut elf_segment_map;
                                                                                                    (*m)
                                                                                                        .p_type = (0x60000000 as libc::c_int
                                                                                                        + 0x474e551 as libc::c_int) as libc::c_ulong;
                                                                                                    (*m)
                                                                                                        .p_flags = (*(*(*abfd).tdata.elf_obj_data).o).stack_flags
                                                                                                        as libc::c_ulong;
                                                                                                    (*m).p_align = (*bed).stack_align as bfd_vma;
                                                                                                    (*m).set_p_flags_valid(1 as libc::c_int as libc::c_uint);
                                                                                                    (*m)
                                                                                                        .set_p_align_valid(
                                                                                                            ((*m).p_align != 0 as libc::c_int as libc::c_ulong)
                                                                                                                as libc::c_int as libc::c_uint,
                                                                                                        );
                                                                                                    if (*info).stacksize > 0 as libc::c_int as libc::c_long {
                                                                                                        (*m).p_size = (*info).stacksize as bfd_vma;
                                                                                                        (*m).set_p_size_valid(1 as libc::c_int as libc::c_uint);
                                                                                                    }
                                                                                                    *pm = m;
                                                                                                    pm = &mut (*m).next;
                                                                                                    current_block = 14723351692138084861;
                                                                                                }
                                                                                            } else {
                                                                                                current_block = 14723351692138084861;
                                                                                            }
                                                                                            match current_block {
                                                                                                9161507880131146499 => {}
                                                                                                _ => {
                                                                                                    if !info.is_null() && (*info).relro() as libc::c_int != 0 {
                                                                                                        m = mfirst;
                                                                                                        while !m.is_null() {
                                                                                                            if (*m).p_type == 1 as libc::c_int as libc::c_ulong
                                                                                                                && (*m).count != 0 as libc::c_int as libc::c_uint
                                                                                                                && (**((*m).sections)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(0 as libc::c_int as isize))
                                                                                                                    .vma >= (*info).relro_start
                                                                                                                && (**((*m).sections)
                                                                                                                    .as_mut_ptr()
                                                                                                                    .offset(0 as libc::c_int as isize))
                                                                                                                    .vma < (*info).relro_end
                                                                                                            {
                                                                                                                i = (*m).count;
                                                                                                                loop {
                                                                                                                    i = i.wrapping_sub(1);
                                                                                                                    if !(i != -(1 as libc::c_int) as libc::c_uint) {
                                                                                                                        break;
                                                                                                                    }
                                                                                                                    if (**((*m).sections).as_mut_ptr().offset(i as isize)).size
                                                                                                                        > 0 as libc::c_int as libc::c_ulong
                                                                                                                        && (**((*m).sections).as_mut_ptr().offset(i as isize)).flags
                                                                                                                            & (0x2 as libc::c_int | 0x100 as libc::c_int)
                                                                                                                                as libc::c_uint
                                                                                                                            == (0x2 as libc::c_int | 0x100 as libc::c_int)
                                                                                                                                as libc::c_uint
                                                                                                                    {
                                                                                                                        break;
                                                                                                                    }
                                                                                                                }
                                                                                                                if i != -(1 as libc::c_int) as libc::c_uint {
                                                                                                                    break;
                                                                                                                }
                                                                                                            }
                                                                                                            m = (*m).next;
                                                                                                        }
                                                                                                        if !m.is_null() {
                                                                                                            amt = ::core::mem::size_of::<elf_segment_map>()
                                                                                                                as libc::c_ulong;
                                                                                                            m = bfd_zalloc(abfd, amt) as *mut elf_segment_map;
                                                                                                            if m.is_null() {
                                                                                                                current_block = 9161507880131146499;
                                                                                                            } else {
                                                                                                                (*m).next = 0 as *mut elf_segment_map;
                                                                                                                (*m)
                                                                                                                    .p_type = (0x60000000 as libc::c_int
                                                                                                                    + 0x474e552 as libc::c_int) as libc::c_ulong;
                                                                                                                *pm = m;
                                                                                                                pm = &mut (*m).next;
                                                                                                                current_block = 15455430299222214173;
                                                                                                            }
                                                                                                        } else {
                                                                                                            current_block = 15455430299222214173;
                                                                                                        }
                                                                                                    } else {
                                                                                                        current_block = 15455430299222214173;
                                                                                                    }
                                                                                                    match current_block {
                                                                                                        9161507880131146499 => {}
                                                                                                        _ => {
                                                                                                            free(sections as *mut libc::c_void);
                                                                                                            (*(*(*abfd).tdata.elf_obj_data).o).seg_map = mfirst;
                                                                                                            current_block = 7986280648684494582;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        match current_block {
            7986280648684494582 => {}
            _ => {
                free(sections as *mut libc::c_void);
                return 0 as libc::c_int != 0;
            }
        }
    }
    if !elf_modify_segment_map(abfd, info, no_user_phdrs) {
        return 0 as libc::c_int != 0;
    }
    count = 0 as libc::c_int as libc::c_uint;
    m = (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
    while !m.is_null() {
        count = count.wrapping_add(1);
        count;
        m = (*m).next;
    }
    (*(*(*abfd).tdata.elf_obj_data).o)
        .program_header_size = count
        .wrapping_mul((*(*bed).s).sizeof_phdr as libc::c_uint) as bfd_size_type;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elf_sort_sections(
    mut arg1: *const libc::c_void,
    mut arg2: *const libc::c_void,
) -> libc::c_int {
    let mut sec1: *const asection = *(arg1 as *mut *const asection);
    let mut sec2: *const asection = *(arg2 as *mut *const asection);
    let mut size1: bfd_size_type = 0;
    let mut size2: bfd_size_type = 0;
    if (*sec1).lma < (*sec2).lma {
        return -(1 as libc::c_int)
    } else if (*sec1).lma > (*sec2).lma {
        return 1 as libc::c_int
    }
    if (*sec1).vma < (*sec2).vma {
        return -(1 as libc::c_int)
    } else if (*sec1).vma > (*sec2).vma {
        return 1 as libc::c_int
    }
    if (*sec1).flags & (0x2 as libc::c_int | 0x400 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
        && (*sec1).size != 0 as libc::c_int as libc::c_ulong
    {
        if !((*sec2).flags & (0x2 as libc::c_int | 0x400 as libc::c_int) as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
            && (*sec2).size != 0 as libc::c_int as libc::c_ulong)
        {
            return 1 as libc::c_int;
        }
    } else if (*sec2).flags & (0x2 as libc::c_int | 0x400 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
        && (*sec2).size != 0 as libc::c_int as libc::c_ulong
    {
        return -(1 as libc::c_int)
    }
    size1 = if (*sec1).flags & 0x2 as libc::c_int as libc::c_uint != 0 {
        (*sec1).size
    } else {
        0 as libc::c_int as libc::c_ulong
    };
    size2 = if (*sec2).flags & 0x2 as libc::c_int as libc::c_uint != 0 {
        (*sec2).size
    } else {
        0 as libc::c_int as libc::c_ulong
    };
    if size1 < size2 {
        return -(1 as libc::c_int);
    }
    if size1 > size2 {
        return 1 as libc::c_int;
    }
    return (*sec1).target_index - (*sec2).target_index;
}
unsafe extern "C" fn elf_sort_segments(
    mut arg1: *const libc::c_void,
    mut arg2: *const libc::c_void,
) -> libc::c_int {
    let mut m1: *const elf_segment_map = *(arg1 as *mut *const elf_segment_map);
    let mut m2: *const elf_segment_map = *(arg2 as *mut *const elf_segment_map);
    if (*m1).p_type != (*m2).p_type {
        if (*m1).p_type == 0 as libc::c_int as libc::c_ulong {
            return 1 as libc::c_int;
        }
        if (*m2).p_type == 0 as libc::c_int as libc::c_ulong {
            return -(1 as libc::c_int);
        }
        return if (*m1).p_type < (*m2).p_type {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    }
    if (*m1).includes_filehdr() as libc::c_int != (*m2).includes_filehdr() as libc::c_int
    {
        return if (*m1).includes_filehdr() as libc::c_int != 0 {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    }
    if (*m1).no_sort_lma() as libc::c_int != (*m2).no_sort_lma() as libc::c_int {
        return if (*m1).no_sort_lma() as libc::c_int != 0 {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    }
    if (*m1).p_type == 1 as libc::c_int as libc::c_ulong && (*m1).no_sort_lma() == 0 {
        let mut lma1: bfd_vma = 0;
        let mut lma2: bfd_vma = 0;
        lma1 = 0 as libc::c_int as bfd_vma;
        if (*m1).p_paddr_valid() != 0 {
            lma1 = (*m1).p_paddr;
        } else if (*m1).count != 0 as libc::c_int as libc::c_uint {
            let mut opb: libc::c_uint = bfd_octets_per_byte(
                (**((*m1).sections).as_ptr().offset(0 as libc::c_int as isize)).owner,
                *((*m1).sections).as_ptr().offset(0 as libc::c_int as isize),
            );
            lma1 = ((**((*m1).sections).as_ptr().offset(0 as libc::c_int as isize)).lma)
                .wrapping_add((*m1).p_vaddr_offset)
                .wrapping_mul(opb as libc::c_ulong);
        }
        lma2 = 0 as libc::c_int as bfd_vma;
        if (*m2).p_paddr_valid() != 0 {
            lma2 = (*m2).p_paddr;
        } else if (*m2).count != 0 as libc::c_int as libc::c_uint {
            let mut opb_0: libc::c_uint = bfd_octets_per_byte(
                (**((*m2).sections).as_ptr().offset(0 as libc::c_int as isize)).owner,
                *((*m2).sections).as_ptr().offset(0 as libc::c_int as isize),
            );
            lma2 = ((**((*m2).sections).as_ptr().offset(0 as libc::c_int as isize)).lma)
                .wrapping_add((*m2).p_vaddr_offset)
                .wrapping_mul(opb_0 as libc::c_ulong);
        }
        if lma1 != lma2 {
            return if lma1 < lma2 { -(1 as libc::c_int) } else { 1 as libc::c_int };
        }
    }
    if (*m1).idx != (*m2).idx {
        return if (*m1).idx < (*m2).idx {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn vma_page_aligned_bias(
    mut vma: bfd_vma,
    mut off: ufile_ptr,
    mut maxpagesize: bfd_vma,
) -> file_ptr {
    if maxpagesize == 0 as libc::c_int as libc::c_ulong {
        maxpagesize = 1 as libc::c_int as bfd_vma;
    }
    return vma.wrapping_sub(off).wrapping_rem(maxpagesize) as file_ptr;
}
unsafe extern "C" fn print_segment_map(mut m: *const elf_segment_map) {
    let mut j: libc::c_uint = 0;
    let mut pt: *const libc::c_char = get_segment_type((*m).p_type as libc::c_uint);
    let mut buf: [libc::c_char; 32] = [0; 32];
    if pt.is_null() {
        if (*m).p_type >= 0x70000000 as libc::c_int as libc::c_ulong
            && (*m).p_type <= 0x7fffffff as libc::c_int as libc::c_ulong
        {
            sprintf(
                buf.as_mut_ptr(),
                b"LOPROC+%7.7x\0" as *const u8 as *const libc::c_char,
                ((*m).p_type).wrapping_sub(0x70000000 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
            );
        } else if (*m).p_type >= 0x60000000 as libc::c_int as libc::c_ulong
            && (*m).p_type <= 0x6fffffff as libc::c_int as libc::c_ulong
        {
            sprintf(
                buf.as_mut_ptr(),
                b"LOOS+%7.7x\0" as *const u8 as *const libc::c_char,
                ((*m).p_type).wrapping_sub(0x60000000 as libc::c_int as libc::c_ulong)
                    as libc::c_uint,
            );
        } else {
            snprintf(
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                b"%8.8x\0" as *const u8 as *const libc::c_char,
                (*m).p_type as libc::c_uint,
            );
        }
        pt = buf.as_mut_ptr();
    }
    fflush(stdout);
    fprintf(stderr, b"%s:\0" as *const u8 as *const libc::c_char, pt);
    j = 0 as libc::c_int as libc::c_uint;
    while j < (*m).count {
        fprintf(
            stderr,
            b" %s\0" as *const u8 as *const libc::c_char,
            (**((*m).sections).as_ptr().offset(j as isize)).name,
        );
        j = j.wrapping_add(1);
        j;
    }
    putc('\n' as i32, stderr);
    fflush(stderr);
}
unsafe extern "C" fn write_zeros(
    mut abfd: *mut bfd,
    mut pos: file_ptr,
    mut len: bfd_size_type,
) -> bool {
    let mut buf: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ret: bool = false;
    if bfd_seek(abfd, pos, 0 as libc::c_int) != 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    buf = bfd_zmalloc(len);
    if buf.is_null() {
        return 0 as libc::c_int != 0;
    }
    ret = bfd_bwrite(buf, len, abfd) == len;
    free(buf);
    return ret;
}
unsafe extern "C" fn assign_file_positions_for_load_sections(
    mut abfd: *mut bfd,
    mut link_info: *mut bfd_link_info,
) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut m: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut phdr_load_seg: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut phdrs: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut p: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut off: file_ptr = 0;
    let mut maxpagesize: bfd_size_type = 0;
    let mut alloc: libc::c_uint = 0;
    let mut actual: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    let mut sorted_seg_map: *mut *mut elf_segment_map = 0 as *mut *mut elf_segment_map;
    let mut opb: libc::c_uint = bfd_octets_per_byte(abfd, 0 as *const asection);
    if link_info.is_null() && !_bfd_elf_map_sections_to_segments(abfd, link_info) {
        return 0 as libc::c_int != 0;
    }
    alloc = 0 as libc::c_int as libc::c_uint;
    m = (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
    while !m.is_null() {
        let fresh62 = alloc;
        alloc = alloc.wrapping_add(1);
        (*m).idx = fresh62;
        m = (*m).next;
    }
    if alloc != 0 {
        (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
            .e_phoff = (*(*bed).s).sizeof_ehdr as bfd_size_type;
        (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
            .e_phentsize = (*(*bed).s).sizeof_phdr as libc::c_uint;
    } else {
        (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
            .e_phoff = 0 as libc::c_int as bfd_size_type;
        (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
            .e_phentsize = 0 as libc::c_int as libc::c_uint;
    }
    (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum = alloc;
    if (*(*(*abfd).tdata.elf_obj_data).o).program_header_size
        == -(1 as libc::c_int) as bfd_size_type
    {
        actual = alloc;
        (*(*(*abfd).tdata.elf_obj_data).o)
            .program_header_size = alloc
            .wrapping_mul((*(*bed).s).sizeof_phdr as libc::c_uint) as bfd_size_type;
    } else {
        actual = ((*(*(*abfd).tdata.elf_obj_data).o).program_header_size)
            .wrapping_div((*(*bed).s).sizeof_phdr as libc::c_ulong) as libc::c_uint;
        if !((*(*(*abfd).tdata.elf_obj_data).o).program_header_size
            == actual.wrapping_mul((*(*bed).s).sizeof_phdr as libc::c_uint)
                as libc::c_ulong)
        {
            bfd_assert(
                b"elf.c\0" as *const u8 as *const libc::c_char,
                5463 as libc::c_int,
            );
        }
        if !(actual >= alloc) {
            bfd_assert(
                b"elf.c\0" as *const u8 as *const libc::c_char,
                5464 as libc::c_int,
            );
        }
    }
    if alloc == 0 as libc::c_int as libc::c_uint {
        (*(*(*abfd).tdata.elf_obj_data).o)
            .next_file_pos = (*(*bed).s).sizeof_ehdr as file_ptr;
        return 1 as libc::c_int != 0;
    }
    phdrs = bfd_zalloc(
        abfd,
        (actual as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf_Internal_Phdr>() as libc::c_ulong)
            .wrapping_add(
                (alloc as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut elf_segment_map>() as libc::c_ulong,
                    ),
            ),
    ) as *mut Elf_Internal_Phdr;
    sorted_seg_map = phdrs.offset(actual as isize) as *mut *mut elf_segment_map;
    (*(*abfd).tdata.elf_obj_data).phdr = phdrs;
    if phdrs.is_null() {
        return 0 as libc::c_int != 0;
    }
    m = (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
    j = 0 as libc::c_int as libc::c_uint;
    while !m.is_null() {
        let ref mut fresh63 = *sorted_seg_map.offset(j as isize);
        *fresh63 = m;
        if (*m).count > 1 as libc::c_int as libc::c_uint
            && !((*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_type
                as libc::c_int == 4 as libc::c_int
                && (*m).p_type == 4 as libc::c_int as libc::c_ulong)
        {
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*m).count {
                (**((*m).sections).as_mut_ptr().offset(i as isize))
                    .target_index = i as libc::c_int;
                i = i.wrapping_add(1);
                i;
            }
            qsort(
                ((*m).sections).as_mut_ptr() as *mut libc::c_void,
                (*m).count as size_t,
                ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                Some(
                    elf_sort_sections
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
        }
        m = (*m).next;
        j = j.wrapping_add(1);
        j;
    }
    if alloc > 1 as libc::c_int as libc::c_uint {
        qsort(
            sorted_seg_map as *mut libc::c_void,
            alloc as size_t,
            ::core::mem::size_of::<*mut elf_segment_map>() as libc::c_ulong,
            Some(
                elf_sort_segments
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        );
    }
    maxpagesize = 1 as libc::c_int as bfd_size_type;
    if (*abfd).flags & 0x100 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        if !link_info.is_null() {
            maxpagesize = (*link_info).maxpagesize;
        } else {
            maxpagesize = (*bed).maxpagesize;
        }
    }
    off = (*(*bed).s).sizeof_ehdr as file_ptr;
    phdr_load_seg = 0 as *mut elf_segment_map;
    j = 0 as libc::c_int as libc::c_uint;
    while j < alloc {
        m = *sorted_seg_map.offset(j as isize);
        if (*m).p_type != 1 as libc::c_int as libc::c_ulong {
            break;
        }
        if (*m).includes_phdrs() != 0 {
            phdr_load_seg = m;
            break;
        } else {
            j = j.wrapping_add(1);
            j;
        }
    }
    if phdr_load_seg.is_null() {
        off
            += actual.wrapping_mul((*(*bed).s).sizeof_phdr as libc::c_uint)
                as libc::c_long;
    }
    j = 0 as libc::c_int as libc::c_uint;
    while j < alloc {
        let mut secpp: *mut *mut asection = 0 as *mut *mut asection;
        let mut off_adjust: bfd_vma = 0;
        let mut no_contents: bool = false;
        m = *sorted_seg_map.offset(j as isize);
        p = phdrs.offset((*m).idx as isize);
        (*p).p_type = (*m).p_type;
        (*p).p_flags = (*m).p_flags;
        if (*m).count == 0 as libc::c_int as libc::c_uint {
            (*p).p_vaddr = ((*m).p_vaddr_offset).wrapping_mul(opb as libc::c_ulong);
        } else {
            (*p)
                .p_vaddr = ((**((*m).sections)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .vma)
                .wrapping_add((*m).p_vaddr_offset)
                .wrapping_mul(opb as libc::c_ulong);
        }
        if (*m).p_paddr_valid() != 0 {
            (*p).p_paddr = (*m).p_paddr;
        } else if (*m).count == 0 as libc::c_int as libc::c_uint {
            (*p).p_paddr = 0 as libc::c_int as bfd_vma;
        } else {
            (*p)
                .p_paddr = ((**((*m).sections)
                .as_mut_ptr()
                .offset(0 as libc::c_int as isize))
                .lma)
                .wrapping_add((*m).p_vaddr_offset)
                .wrapping_mul(opb as libc::c_ulong);
        }
        if (*p).p_type == 1 as libc::c_int as libc::c_ulong
            && (*abfd).flags & 0x100 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
        {
            if (*m).p_align_valid() != 0 {
                maxpagesize = (*m).p_align;
            }
            (*p).p_align = maxpagesize;
        } else if (*m).p_align_valid() != 0 {
            (*p).p_align = (*m).p_align;
        } else if (*m).count == 0 as libc::c_int as libc::c_uint {
            (*p)
                .p_align = ((1 as libc::c_int)
                << (*(*bed).s).log_file_align as libc::c_int) as bfd_vma;
        }
        if m == phdr_load_seg {
            if (*m).includes_filehdr() == 0 {
                (*p).p_offset = off as bfd_vma;
            }
            off
                += actual.wrapping_mul((*(*bed).s).sizeof_phdr as libc::c_uint)
                    as libc::c_long;
        }
        no_contents = 0 as libc::c_int != 0;
        off_adjust = 0 as libc::c_int as bfd_vma;
        if (*p).p_type == 1 as libc::c_int as libc::c_ulong
            && (*m).count > 0 as libc::c_int as libc::c_uint
        {
            let mut align: bfd_size_type = 0;
            let mut align_power: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            if (*m).p_align_valid() != 0 {
                align = (*p).p_align;
            } else {
                i = 0 as libc::c_int as libc::c_uint;
                secpp = ((*m).sections).as_mut_ptr();
                while i < (*m).count {
                    let mut secalign: libc::c_uint = 0;
                    secalign = bfd_section_alignment(*secpp);
                    if secalign > align_power {
                        align_power = secalign;
                    }
                    i = i.wrapping_add(1);
                    i;
                    secpp = secpp.offset(1);
                    secpp;
                }
                align = (1 as libc::c_int as bfd_size_type) << align_power;
                if align < maxpagesize {
                    align = maxpagesize;
                }
            }
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*m).count {
                if (**((*m).sections).as_mut_ptr().offset(i as isize)).flags
                    & (0x2 as libc::c_int | 0x100 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    (*((**((*m).sections).as_mut_ptr().offset(i as isize)).used_by_bfd
                        as *mut bfd_elf_section_data))
                        .this_hdr
                        .sh_type = 8 as libc::c_int as libc::c_uint;
                }
                i = i.wrapping_add(1);
                i;
            }
            no_contents = 1 as libc::c_int != 0;
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*m).count {
                if (*((**((*m).sections).as_mut_ptr().offset(i as isize)).used_by_bfd
                    as *mut bfd_elf_section_data))
                    .this_hdr
                    .sh_type != 8 as libc::c_int as libc::c_uint
                {
                    no_contents = 0 as libc::c_int != 0;
                    break;
                } else {
                    i = i.wrapping_add(1);
                    i;
                }
            }
            off_adjust = vma_page_aligned_bias(
                (*p).p_vaddr,
                off as ufile_ptr,
                align.wrapping_mul(opb as libc::c_ulong),
            ) as bfd_vma;
            if j != 0 as libc::c_int as libc::c_uint
                && (*abfd).flags & 0x100 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                && (*bed).no_page_alias() as libc::c_int != 0
                && off as libc::c_ulong
                    & maxpagesize.wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    != 0 as libc::c_int as libc::c_ulong
                && off as libc::c_ulong & maxpagesize.wrapping_neg()
                    == (off as libc::c_ulong).wrapping_add(off_adjust)
                        & maxpagesize.wrapping_neg()
            {
                off_adjust = (off_adjust as libc::c_ulong).wrapping_add(maxpagesize)
                    as bfd_vma as bfd_vma;
            }
            off = (off as libc::c_ulong).wrapping_add(off_adjust) as file_ptr
                as file_ptr;
            if !no_contents {
                off_adjust = 0 as libc::c_int as bfd_vma;
            }
        } else if (*p).p_type == 2 as libc::c_int as libc::c_ulong
            && (*m).count > 1 as libc::c_int as libc::c_uint
            && strcmp(
                (**((*m).sections).as_mut_ptr().offset(0 as libc::c_int as isize)).name,
                b".dynamic\0" as *const u8 as *const libc::c_char,
            ) != 0 as libc::c_int
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: The first section in the PT_DYNAMIC segment is not the .dynamic section\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
            );
            bfd_set_error(bfd_error_bad_value);
            return 0 as libc::c_int != 0;
        } else if (*p).p_type == 4 as libc::c_int as libc::c_ulong {
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*m).count {
                (*((**((*m).sections).as_mut_ptr().offset(i as isize)).used_by_bfd
                    as *mut bfd_elf_section_data))
                    .this_hdr
                    .sh_type = 7 as libc::c_int as libc::c_uint;
                i = i.wrapping_add(1);
                i;
            }
        }
        if (*m).includes_filehdr() != 0 {
            if (*m).p_flags_valid() == 0 {
                (*p).p_flags
                    |= ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong;
            }
            (*p).p_filesz = (*(*bed).s).sizeof_ehdr as bfd_vma;
            (*p).p_memsz = (*(*bed).s).sizeof_ehdr as bfd_vma;
            if (*p).p_type == 1 as libc::c_int as libc::c_ulong {
                if (*m).count > 0 as libc::c_int as libc::c_uint {
                    if (*p).p_vaddr < off as bfd_vma
                        || (*m).p_paddr_valid() == 0 && (*p).p_paddr < off as bfd_vma
                    {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%pB: not enough room for program headers, try linking with -N\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            abfd,
                        );
                        bfd_set_error(bfd_error_bad_value);
                        return 0 as libc::c_int != 0;
                    }
                    (*p)
                        .p_vaddr = ((*p).p_vaddr as libc::c_ulong)
                        .wrapping_sub(off as libc::c_ulong) as bfd_vma as bfd_vma;
                    if (*m).p_paddr_valid() == 0 {
                        (*p)
                            .p_paddr = ((*p).p_paddr as libc::c_ulong)
                            .wrapping_sub(off as libc::c_ulong) as bfd_vma as bfd_vma;
                    }
                }
            } else if (**sorted_seg_map.offset(0 as libc::c_int as isize))
                .includes_filehdr() != 0
            {
                let mut filehdr: *mut Elf_Internal_Phdr = phdrs
                    .offset(
                        (**sorted_seg_map.offset(0 as libc::c_int as isize)).idx as isize,
                    );
                (*p).p_vaddr = (*filehdr).p_vaddr;
                if (*m).p_paddr_valid() == 0 {
                    (*p).p_paddr = (*filehdr).p_paddr;
                }
            }
        }
        if (*m).includes_phdrs() != 0 {
            if (*m).p_flags_valid() == 0 {
                (*p).p_flags
                    |= ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong;
            }
            (*p)
                .p_filesz = ((*p).p_filesz as libc::c_ulong)
                .wrapping_add(
                    actual.wrapping_mul((*(*bed).s).sizeof_phdr as libc::c_uint)
                        as libc::c_ulong,
                ) as bfd_vma as bfd_vma;
            (*p)
                .p_memsz = ((*p).p_memsz as libc::c_ulong)
                .wrapping_add(
                    actual.wrapping_mul((*(*bed).s).sizeof_phdr as libc::c_uint)
                        as libc::c_ulong,
                ) as bfd_vma as bfd_vma;
            if (*m).includes_filehdr() == 0 {
                if (*p).p_type == 1 as libc::c_int as libc::c_ulong {
                    (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
                        .e_phoff = (*p).p_offset;
                    if (*m).count > 0 as libc::c_int as libc::c_uint {
                        (*p)
                            .p_vaddr = ((*p).p_vaddr as libc::c_ulong)
                            .wrapping_sub(
                                (off as libc::c_ulong).wrapping_sub((*p).p_offset),
                            ) as bfd_vma as bfd_vma;
                        if (*m).p_paddr_valid() == 0 {
                            (*p)
                                .p_paddr = ((*p).p_paddr as libc::c_ulong)
                                .wrapping_sub(
                                    (off as libc::c_ulong).wrapping_sub((*p).p_offset),
                                ) as bfd_vma as bfd_vma;
                        }
                    }
                } else if !phdr_load_seg.is_null() {
                    let mut phdr: *mut Elf_Internal_Phdr = phdrs
                        .offset((*phdr_load_seg).idx as isize);
                    let mut phdr_off: bfd_vma = 0 as libc::c_int as bfd_vma;
                    if (*phdr_load_seg).includes_filehdr() != 0 {
                        phdr_off = (*(*bed).s).sizeof_ehdr as bfd_vma;
                    }
                    (*p).p_vaddr = ((*phdr).p_vaddr).wrapping_add(phdr_off);
                    if (*m).p_paddr_valid() == 0 {
                        (*p).p_paddr = ((*phdr).p_paddr).wrapping_add(phdr_off);
                    }
                    (*p).p_offset = ((*phdr).p_offset).wrapping_add(phdr_off);
                } else {
                    (*p).p_offset = (*(*bed).s).sizeof_ehdr as bfd_vma;
                }
            }
        }
        if (*p).p_type == 1 as libc::c_int as libc::c_ulong
            || (*p).p_type == 4 as libc::c_int as libc::c_ulong
                && bfd_get_format(abfd) as libc::c_uint
                    == bfd_core as libc::c_int as libc::c_uint
        {
            if (*m).includes_filehdr() == 0 && (*m).includes_phdrs() == 0 {
                (*p).p_offset = off as bfd_vma;
                if no_contents {
                    let mut align_0: bfd_size_type = maxpagesize;
                    if align_0 < (*p).p_align {
                        align_0 = (*p).p_align;
                    }
                    if align_0 < 1 as libc::c_int as libc::c_ulong {
                        align_0 = 1 as libc::c_int as bfd_size_type;
                    }
                    (*p).p_offset = (off as libc::c_ulong).wrapping_rem(align_0);
                }
            } else {
                let mut adjust: file_ptr = 0;
                adjust = (off as libc::c_ulong)
                    .wrapping_sub(((*p).p_offset).wrapping_add((*p).p_filesz))
                    as file_ptr;
                if !no_contents {
                    (*p)
                        .p_filesz = ((*p).p_filesz as libc::c_ulong)
                        .wrapping_add(adjust as libc::c_ulong) as bfd_vma as bfd_vma;
                }
                (*p)
                    .p_memsz = ((*p).p_memsz as libc::c_ulong)
                    .wrapping_add(adjust as libc::c_ulong) as bfd_vma as bfd_vma;
            }
        }
        let mut current_block_261: u64;
        i = 0 as libc::c_int as libc::c_uint;
        secpp = ((*m).sections).as_mut_ptr();
        while i < (*m).count {
            let mut sec: *mut asection = 0 as *mut asection;
            let mut align_1: bfd_size_type = 0;
            let mut this_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
            sec = *secpp;
            this_hdr = &mut (*((*sec).used_by_bfd as *mut bfd_elf_section_data))
                .this_hdr;
            align_1 = (1 as libc::c_int as bfd_size_type) << bfd_section_alignment(sec);
            if ((*p).p_type == 1 as libc::c_int as libc::c_ulong
                || (*p).p_type == 7 as libc::c_int as libc::c_ulong)
                && ((*this_hdr).sh_type != 8 as libc::c_int as libc::c_uint
                    || (*this_hdr).sh_flags
                        & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                        != 0 as libc::c_int as libc::c_ulong
                        && ((*this_hdr).sh_flags
                            & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                            == 0 as libc::c_int as libc::c_ulong
                            || (*p).p_type == 7 as libc::c_int as libc::c_ulong))
            {
                let mut p_start: bfd_vma = (*p).p_paddr;
                let mut p_end: bfd_vma = p_start.wrapping_add((*p).p_memsz);
                let mut s_start: bfd_vma = ((*sec).lma)
                    .wrapping_mul(opb as libc::c_ulong);
                let mut adjust_0: bfd_vma = s_start.wrapping_sub(p_end);
                if adjust_0 != 0 as libc::c_int as libc::c_ulong
                    && (s_start < p_end || p_end < p_start)
                {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: section %pA lma %#lx adjusted to %#lx\0" as *const u8
                                as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        sec,
                        s_start.wrapping_div(opb as libc::c_ulong),
                        p_end.wrapping_div(opb as libc::c_ulong),
                    );
                    adjust_0 = 0 as libc::c_int as bfd_vma;
                    (*sec).lma = p_end.wrapping_div(opb as libc::c_ulong);
                }
                (*p)
                    .p_memsz = ((*p).p_memsz as libc::c_ulong).wrapping_add(adjust_0)
                    as bfd_vma as bfd_vma;
                if (*p).p_type == 1 as libc::c_int as libc::c_ulong {
                    if (*this_hdr).sh_type != 8 as libc::c_int as libc::c_uint {
                        off_adjust = 0 as libc::c_int as bfd_vma;
                        if ((*p).p_filesz).wrapping_add(adjust_0) < (*p).p_memsz {
                            adjust_0 = ((*p).p_memsz).wrapping_sub((*p).p_filesz);
                            if !write_zeros(abfd, off, adjust_0) {
                                return 0 as libc::c_int != 0;
                            }
                        }
                    }
                    if (*this_hdr).sh_type != 8 as libc::c_int as libc::c_uint
                        || i == 0 as libc::c_int as libc::c_uint
                    {
                        off = (off as libc::c_ulong).wrapping_add(adjust_0) as file_ptr
                            as file_ptr;
                        if (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint {
                            off_adjust = (off_adjust as libc::c_ulong)
                                .wrapping_add(adjust_0) as bfd_vma as bfd_vma;
                        }
                    }
                }
                if (*this_hdr).sh_type != 8 as libc::c_int as libc::c_uint {
                    (*p)
                        .p_filesz = ((*p).p_filesz as libc::c_ulong)
                        .wrapping_add(adjust_0) as bfd_vma as bfd_vma;
                }
            }
            if (*p).p_type == 4 as libc::c_int as libc::c_ulong
                && bfd_get_format(abfd) as libc::c_uint
                    == bfd_core as libc::c_int as libc::c_uint
            {
                if i == 0 as libc::c_int as libc::c_uint {
                    (*sec).filepos = off;
                    (*this_hdr).sh_offset = (*sec).filepos;
                    off = (off as libc::c_ulong).wrapping_add((*this_hdr).sh_size)
                        as file_ptr as file_ptr;
                    (*p).p_filesz = (*this_hdr).sh_size;
                    (*p).p_memsz = 0 as libc::c_int as bfd_vma;
                    (*p).p_align = 1 as libc::c_int as bfd_vma;
                    current_block_261 = 11639917216603986996;
                } else {
                    (*sec).filepos = 0 as libc::c_int as file_ptr;
                    (*sec).size = 0 as libc::c_int as bfd_size_type;
                    (*sec).flags = 0 as libc::c_int as flagword;
                    current_block_261 = 1634947208139838470;
                }
            } else {
                if (*p).p_type == 1 as libc::c_int as libc::c_ulong {
                    (*sec).filepos = off;
                    (*this_hdr).sh_offset = (*sec).filepos;
                    if (*this_hdr).sh_type != 8 as libc::c_int as libc::c_uint {
                        off = (off as libc::c_ulong).wrapping_add((*this_hdr).sh_size)
                            as file_ptr as file_ptr;
                    }
                } else if (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                    && (*this_hdr).sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        != 0 as libc::c_int as libc::c_ulong
                    && (*this_hdr).sh_offset == 0 as libc::c_int as libc::c_long
                {
                    let mut adjust_1: bfd_vma = vma_page_aligned_bias(
                        (*this_hdr).sh_addr,
                        off as ufile_ptr,
                        align_1,
                    ) as bfd_vma;
                    (*sec)
                        .filepos = (off as libc::c_ulong).wrapping_add(adjust_1)
                        as file_ptr;
                    (*this_hdr).sh_offset = (*sec).filepos;
                }
                if (*this_hdr).sh_type != 8 as libc::c_int as libc::c_uint {
                    (*p)
                        .p_filesz = ((*p).p_filesz as libc::c_ulong)
                        .wrapping_add((*this_hdr).sh_size) as bfd_vma as bfd_vma;
                    if (*this_hdr).sh_flags
                        & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                        != 0 as libc::c_int as libc::c_ulong
                    {
                        (*p)
                            .p_memsz = ((*p).p_memsz as libc::c_ulong)
                            .wrapping_add((*this_hdr).sh_size) as bfd_vma as bfd_vma;
                    }
                } else if (*this_hdr).sh_flags
                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                {
                    if (*p).p_type == 7 as libc::c_int as libc::c_ulong {
                        (*p)
                            .p_memsz = ((*p).p_memsz as libc::c_ulong)
                            .wrapping_add((*this_hdr).sh_size) as bfd_vma as bfd_vma;
                    } else if (*this_hdr).sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        == 0 as libc::c_int as libc::c_ulong
                    {
                        (*p)
                            .p_memsz = ((*p).p_memsz as libc::c_ulong)
                            .wrapping_add((*this_hdr).sh_size) as bfd_vma as bfd_vma;
                    }
                }
                if align_1 > (*p).p_align && (*m).p_align_valid() == 0
                    && ((*p).p_type != 1 as libc::c_int as libc::c_ulong
                        || (*abfd).flags & 0x100 as libc::c_int as libc::c_uint
                            == 0 as libc::c_int as libc::c_uint)
                {
                    (*p).p_align = align_1;
                }
                current_block_261 = 11639917216603986996;
            }
            match current_block_261 {
                11639917216603986996 => {
                    if (*m).p_flags_valid() == 0 {
                        (*p).p_flags
                            |= ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong;
                        if (*this_hdr).sh_flags
                            & ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_ulong
                            != 0 as libc::c_int as libc::c_ulong
                        {
                            (*p).p_flags
                                |= ((1 as libc::c_int) << 0 as libc::c_int)
                                    as libc::c_ulong;
                        }
                        if (*this_hdr).sh_flags
                            & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_ulong
                            != 0 as libc::c_int as libc::c_ulong
                        {
                            (*p).p_flags
                                |= ((1 as libc::c_int) << 1 as libc::c_int)
                                    as libc::c_ulong;
                        }
                    }
                }
                _ => {}
            }
            i = i.wrapping_add(1);
            i;
            secpp = secpp.offset(1);
            secpp;
        }
        off = (off as libc::c_ulong).wrapping_sub(off_adjust) as file_ptr as file_ptr;
        if (*p).p_type == 6 as libc::c_int as libc::c_ulong && phdr_load_seg.is_null()
            && !(((*bed).elf_backend_allow_non_load_phdr).is_some()
                && ((*bed).elf_backend_allow_non_load_phdr)
                    .expect("non-null function pointer")(abfd, phdrs, alloc)
                    as libc::c_int != 0)
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB: error: PHDR segment not covered by LOAD segment\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
            );
            if link_info.is_null() {
                return 0 as libc::c_int != 0;
            }
            ((*(*link_info).callbacks).info)
                .expect(
                    "non-null function pointer",
                )(b"%X\0" as *const u8 as *const libc::c_char);
        }
        if (*p).p_type == 1 as libc::c_int as libc::c_ulong
            && bfd_get_format(abfd) as libc::c_uint
                != bfd_core as libc::c_int as libc::c_uint
        {
            let mut check_vma: bool = 1 as libc::c_int != 0;
            i = 1 as libc::c_int as libc::c_uint;
            while i < (*m).count {
                if (**((*m).sections).as_mut_ptr().offset(i as isize)).vma
                    == (**((*m).sections)
                        .as_mut_ptr()
                        .offset(
                            i.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                        ))
                        .vma
                    && (if (*((**((*m).sections).as_mut_ptr().offset(i as isize))
                        .used_by_bfd as *mut bfd_elf_section_data))
                        .this_hdr
                        .sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        != 0 as libc::c_int as libc::c_ulong
                        && (*((**((*m).sections).as_mut_ptr().offset(i as isize))
                            .used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_type == 8 as libc::c_int as libc::c_uint
                        && (*p).p_type != 7 as libc::c_int as libc::c_ulong
                    {
                        0 as libc::c_int as libc::c_ulong
                    } else {
                        (*((**((*m).sections).as_mut_ptr().offset(i as isize))
                            .used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_size
                    }) != 0 as libc::c_int as libc::c_ulong
                    && (if (*((**((*m).sections)
                        .as_mut_ptr()
                        .offset(
                            i.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                        ))
                        .used_by_bfd as *mut bfd_elf_section_data))
                        .this_hdr
                        .sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        != 0 as libc::c_int as libc::c_ulong
                        && (*((**((*m).sections)
                            .as_mut_ptr()
                            .offset(
                                i.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                            ))
                            .used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_type == 8 as libc::c_int as libc::c_uint
                        && (*p).p_type != 7 as libc::c_int as libc::c_ulong
                    {
                        0 as libc::c_int as libc::c_ulong
                    } else {
                        (*((**((*m).sections)
                            .as_mut_ptr()
                            .offset(
                                i.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                            ))
                            .used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_size
                    }) != 0 as libc::c_int as libc::c_ulong
                {
                    check_vma = 0 as libc::c_int != 0;
                    break;
                } else {
                    i = i.wrapping_add(1);
                    i;
                }
            }
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*m).count {
                let mut this_hdr_0: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
                let mut sec_0: *mut asection = 0 as *mut asection;
                sec_0 = *((*m).sections).as_mut_ptr().offset(i as isize);
                this_hdr_0 = &mut (*((*sec_0).used_by_bfd as *mut bfd_elf_section_data))
                    .this_hdr;
                if !(((*this_hdr_0).sh_flags
                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                    && ((*p).p_type == 7 as libc::c_int as libc::c_ulong
                        || (*p).p_type
                            == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                as libc::c_ulong
                        || (*p).p_type == 1 as libc::c_int as libc::c_ulong)
                    || (*this_hdr_0).sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        == 0 as libc::c_int as libc::c_ulong
                        && (*p).p_type != 7 as libc::c_int as libc::c_ulong
                        && (*p).p_type != 6 as libc::c_int as libc::c_ulong)
                    && !((*this_hdr_0).sh_flags
                        & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                        == 0 as libc::c_int as libc::c_ulong
                        && ((*p).p_type == 1 as libc::c_int as libc::c_ulong
                            || (*p).p_type == 2 as libc::c_int as libc::c_ulong
                            || (*p).p_type
                                == (0x60000000 as libc::c_int + 0x474e550 as libc::c_int)
                                    as libc::c_ulong
                            || (*p).p_type
                                == (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                                    as libc::c_ulong
                            || (*p).p_type
                                == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                    as libc::c_ulong
                            || (*p).p_type
                                >= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int)
                                    as libc::c_ulong
                                && (*p).p_type
                                    <= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int
                                        + 4096 as libc::c_int - 1 as libc::c_int) as libc::c_ulong))
                    && ((*this_hdr_0).sh_type == 8 as libc::c_int as libc::c_uint
                        || (*this_hdr_0).sh_offset as bfd_vma >= (*p).p_offset
                            && (0 as libc::c_int == 0
                                || ((*this_hdr_0).sh_offset as libc::c_ulong)
                                    .wrapping_sub((*p).p_offset)
                                    <= ((*p).p_filesz)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            && ((*this_hdr_0).sh_offset as libc::c_ulong)
                                .wrapping_sub((*p).p_offset)
                                .wrapping_add(
                                    if (*this_hdr_0).sh_flags
                                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                        != 0 as libc::c_int as libc::c_ulong
                                        && (*this_hdr_0).sh_type == 8 as libc::c_int as libc::c_uint
                                        && (*p).p_type != 7 as libc::c_int as libc::c_ulong
                                    {
                                        0 as libc::c_int as libc::c_ulong
                                    } else {
                                        (*this_hdr_0).sh_size
                                    },
                                ) <= (*p).p_filesz)
                    && (!check_vma
                        || (*this_hdr_0).sh_flags
                            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                            == 0 as libc::c_int as libc::c_ulong
                        || (*this_hdr_0).sh_addr >= (*p).p_vaddr
                            && (0 as libc::c_int == 0
                                || ((*this_hdr_0).sh_addr).wrapping_sub((*p).p_vaddr)
                                    <= ((*p).p_memsz)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            && ((*this_hdr_0).sh_addr)
                                .wrapping_sub((*p).p_vaddr)
                                .wrapping_add(
                                    if (*this_hdr_0).sh_flags
                                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                        != 0 as libc::c_int as libc::c_ulong
                                        && (*this_hdr_0).sh_type == 8 as libc::c_int as libc::c_uint
                                        && (*p).p_type != 7 as libc::c_int as libc::c_ulong
                                    {
                                        0 as libc::c_int as libc::c_ulong
                                    } else {
                                        (*this_hdr_0).sh_size
                                    },
                                ) <= (*p).p_memsz)
                    && ((*p).p_type != 2 as libc::c_int as libc::c_ulong
                        && (*p).p_type != 4 as libc::c_int as libc::c_ulong
                        || (*this_hdr_0).sh_size != 0 as libc::c_int as libc::c_ulong
                        || (*p).p_memsz == 0 as libc::c_int as libc::c_ulong
                        || ((*this_hdr_0).sh_type == 8 as libc::c_int as libc::c_uint
                            || (*this_hdr_0).sh_offset as bfd_vma > (*p).p_offset
                                && ((*this_hdr_0).sh_offset as libc::c_ulong)
                                    .wrapping_sub((*p).p_offset) < (*p).p_filesz)
                            && ((*this_hdr_0).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                == 0 as libc::c_int as libc::c_ulong
                                || (*this_hdr_0).sh_addr > (*p).p_vaddr
                                    && ((*this_hdr_0).sh_addr).wrapping_sub((*p).p_vaddr)
                                        < (*p).p_memsz)))
                    && !((*this_hdr_0).sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        != 0 as libc::c_int as libc::c_ulong
                        && (*this_hdr_0).sh_type == 8 as libc::c_int as libc::c_uint
                        && (*p).p_type != 7 as libc::c_int as libc::c_ulong)
                {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: section `%pA' can't be allocated in segment %d\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        sec_0,
                        j,
                    );
                    print_segment_map(m);
                }
                i = i.wrapping_add(1);
                i;
            }
        }
        j = j.wrapping_add(1);
        j;
    }
    (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos = off;
    if !link_info.is_null() && !phdr_load_seg.is_null()
        && (*phdr_load_seg).includes_filehdr() as libc::c_int != 0
    {
        let mut hash: *mut elf_link_hash_entry = elf_link_hash_lookup(
            elf_hash_table(link_info),
            b"__ehdr_start\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int != 0,
            0 as libc::c_int != 0,
            1 as libc::c_int != 0,
        );
        if !hash.is_null()
            && (((*hash).root).type_0() as libc::c_int
                == bfd_link_hash_new as libc::c_int
                || ((*hash).root).type_0() as libc::c_int
                    == bfd_link_hash_undefined as libc::c_int
                || ((*hash).root).type_0() as libc::c_int
                    == bfd_link_hash_undefweak as libc::c_int
                || ((*hash).root).type_0() as libc::c_int
                    == bfd_link_hash_common as libc::c_int)
        {
            let mut s: *mut asection = 0 as *mut asection;
            let mut filehdr_vaddr: bfd_vma = ((*phdrs
                .offset((*phdr_load_seg).idx as isize))
                .p_vaddr)
                .wrapping_div(opb as libc::c_ulong);
            if (*phdr_load_seg).count != 0 as libc::c_int as libc::c_uint {
                s = *((*phdr_load_seg).sections)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize);
            } else {
                m = (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
                while !m.is_null() {
                    if (*m).p_type == 1 as libc::c_int as libc::c_ulong
                        && (*m).count != 0 as libc::c_int as libc::c_uint
                    {
                        s = *((*m).sections)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize);
                        break;
                    } else {
                        m = (*m).next;
                    }
                }
            }
            if !s.is_null() {
                (*hash).root.u.def.value = filehdr_vaddr.wrapping_sub((*s).vma);
                (*hash).root.u.def.section = s;
            } else {
                (*hash).root.u.def.value = filehdr_vaddr;
                (*hash)
                    .root
                    .u
                    .def
                    .section = &mut *_bfd_std_section
                    .as_mut_ptr()
                    .offset(2 as libc::c_int as isize) as *mut asection;
            }
            ((*hash).root).set_type_0(bfd_link_hash_defined);
            (*hash).set_def_regular(1 as libc::c_int as libc::c_uint);
            (*hash).set_non_elf(0 as libc::c_int as libc::c_uint);
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn is_debuginfo_file(mut abfd: *mut bfd) -> bool {
    if abfd.is_null()
        || bfd_get_flavour(abfd) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    let mut start_headers: *mut *mut Elf_Internal_Shdr = (*(*abfd).tdata.elf_obj_data)
        .elf_sect_ptr;
    let mut end_headers: *mut *mut Elf_Internal_Shdr = start_headers
        .offset((*(*abfd).tdata.elf_obj_data).num_elf_sections as isize);
    let mut headerp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    headerp = start_headers;
    while headerp < end_headers {
        let mut header: *mut Elf_Internal_Shdr = *headerp;
        if (*header).sh_flags & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
            == ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
            && (*header).sh_type != 8 as libc::c_int as libc::c_uint
            && (*header).sh_type != 7 as libc::c_int as libc::c_uint
        {
            return 0 as libc::c_int != 0;
        }
        headerp = headerp.offset(1);
        headerp;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn assign_file_positions_for_non_load_sections(
    mut abfd: *mut bfd,
    mut link_info: *mut bfd_link_info,
) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut i_shdrpp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    let mut hdrpp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    let mut end_hdrpp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    let mut phdrs: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut p: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut m: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut off: file_ptr = 0;
    let mut opb: libc::c_uint = bfd_octets_per_byte(abfd, 0 as *const asection);
    let mut maxpagesize: bfd_vma = 0;
    if !link_info.is_null() {
        maxpagesize = (*link_info).maxpagesize;
    } else {
        maxpagesize = (*bed).maxpagesize;
    }
    i_shdrpp = (*(*abfd).tdata.elf_obj_data).elf_sect_ptr;
    end_hdrpp = i_shdrpp.offset((*(*abfd).tdata.elf_obj_data).num_elf_sections as isize);
    off = (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos;
    hdrpp = i_shdrpp.offset(1 as libc::c_int as isize);
    while hdrpp < end_hdrpp {
        let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        hdr = *hdrpp;
        if !((*hdr).bfd_section).is_null()
            && ((*(*hdr).bfd_section).filepos != 0 as libc::c_int as libc::c_long
                || (*hdr).sh_type == 8 as libc::c_int as libc::c_uint
                    && ((*hdr).contents).is_null())
        {
            if !((*hdr).sh_offset == (*(*hdr).bfd_section).filepos) {
                bfd_assert(
                    b"elf.c\0" as *const u8 as *const libc::c_char,
                    6117 as libc::c_int,
                );
            }
        } else if (*hdr).sh_flags
            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
            != 0 as libc::c_int as libc::c_ulong
        {
            if (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong
                && !is_debuginfo_file(abfd)
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB: warning: allocated section `%s' not in segment\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abfd,
                    if ((*hdr).bfd_section).is_null() {
                        b"*unknown*\0" as *const u8 as *const libc::c_char
                    } else {
                        (*(*hdr).bfd_section).name
                    },
                );
            }
            if (*abfd).flags & 0x100 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
                && (*hdr).sh_size != 0 as libc::c_int as libc::c_ulong
            {
                off
                    += vma_page_aligned_bias(
                        (*hdr).sh_addr,
                        off as ufile_ptr,
                        maxpagesize,
                    );
            } else {
                off
                    += vma_page_aligned_bias(
                        (*hdr).sh_addr,
                        off as ufile_ptr,
                        (*hdr).sh_addralign,
                    );
            }
            off = _bfd_elf_assign_file_position_for_section(
                hdr,
                off,
                0 as libc::c_int != 0,
            );
        } else if ((*hdr).sh_type == 9 as libc::c_int as libc::c_uint
            || (*hdr).sh_type == 4 as libc::c_int as libc::c_uint)
            && ((*hdr).bfd_section).is_null()
            || !((*hdr).bfd_section).is_null()
                && ((*(*hdr).bfd_section).flags
                    & 0x8000000 as libc::c_int as libc::c_uint != 0
                    || bfd_section_is_ctf((*hdr).bfd_section) as libc::c_int != 0
                        && (*abfd).is_linker_output() as libc::c_int != 0)
            || hdr
                == *i_shdrpp
                    .offset((*(*abfd).tdata.elf_obj_data).symtab_section as isize)
            || !((*(*abfd).tdata.elf_obj_data).symtab_shndx_list).is_null()
                && hdr
                    == *i_shdrpp
                        .offset(
                            (*(*(*abfd).tdata.elf_obj_data).symtab_shndx_list).ndx
                                as isize,
                        )
            || hdr
                == *i_shdrpp
                    .offset((*(*(*abfd).tdata.elf_obj_data).o).strtab_section as isize)
            || hdr
                == *i_shdrpp
                    .offset((*(*(*abfd).tdata.elf_obj_data).o).shstrtab_section as isize)
        {
            (*hdr).sh_offset = -(1 as libc::c_int) as file_ptr;
        } else {
            off = _bfd_elf_assign_file_position_for_section(
                hdr,
                off,
                1 as libc::c_int != 0,
            );
        }
        hdrpp = hdrpp.offset(1);
        hdrpp;
    }
    (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos = off;
    phdrs = (*(*abfd).tdata.elf_obj_data).phdr;
    m = (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
    p = phdrs;
    while !m.is_null() {
        if (*p).p_type
            == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int) as libc::c_ulong
        {
            let mut start: bfd_vma = 0;
            let mut end: bfd_vma = 0;
            let mut ok: bool = false;
            if !link_info.is_null() {
                start = (*link_info).relro_start;
                end = (*link_info).relro_end;
            } else if (*m).count != 0 as libc::c_int as libc::c_uint {
                if (*m).p_size_valid() == 0 {
                    _bfd_abort(
                        b"elf.c\0" as *const u8 as *const libc::c_char,
                        6184 as libc::c_int,
                        (*::core::mem::transmute::<
                            &[u8; 81],
                            &[libc::c_char; 81],
                        >(
                            b"_Bool assign_file_positions_for_non_load_sections(bfd *, struct bfd_link_info *)\0",
                        ))
                            .as_ptr(),
                    );
                }
                start = (**((*m).sections)
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .vma;
                end = start
                    .wrapping_add(((*m).p_size).wrapping_div(opb as libc::c_ulong));
            } else {
                start = 0 as libc::c_int as bfd_vma;
                end = 0 as libc::c_int as bfd_vma;
            }
            ok = 0 as libc::c_int != 0;
            if start < end {
                let mut lm: *mut elf_segment_map = 0 as *mut elf_segment_map;
                let mut lp: *const Elf_Internal_Phdr = 0 as *const Elf_Internal_Phdr;
                let mut i: libc::c_uint = 0;
                lm = (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
                lp = phdrs;
                while !lm.is_null() {
                    if (*lp).p_type == 1 as libc::c_int as libc::c_ulong
                        && (*lm).count != 0 as libc::c_int as libc::c_uint
                        && ((**((*lm).sections)
                            .as_mut_ptr()
                            .offset(
                                ((*lm).count).wrapping_sub(1 as libc::c_int as libc::c_uint)
                                    as isize,
                            ))
                            .vma)
                            .wrapping_add(
                                if !((**((*lm).sections)
                                    .as_mut_ptr()
                                    .offset(
                                        ((*lm).count).wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize,
                                    ))
                                    .flags
                                    & (0x400 as libc::c_int | 0x2 as libc::c_int)
                                        as libc::c_uint == 0x400 as libc::c_int as libc::c_uint)
                                {
                                    ((**((*lm).sections)
                                        .as_mut_ptr()
                                        .offset(
                                            ((*lm).count).wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                as isize,
                                        ))
                                        .size)
                                        .wrapping_div(opb as libc::c_ulong)
                                } else {
                                    0 as libc::c_int as libc::c_ulong
                                },
                            ) > start
                        && (**((*lm).sections)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize))
                            .vma < end
                    {
                        break;
                    }
                    lm = (*lm).next;
                    lp = lp.offset(1);
                    lp;
                }
                if !lm.is_null() {
                    i = 0 as libc::c_int as libc::c_uint;
                    while i < (*lm).count {
                        let mut s: *mut asection = *((*lm).sections)
                            .as_mut_ptr()
                            .offset(i as isize);
                        if (*s).vma >= start && (*s).vma < end
                            && (*s).size != 0 as libc::c_int as libc::c_ulong
                        {
                            break;
                        }
                        i = i.wrapping_add(1);
                        i;
                    }
                    if i < (*lm).count {
                        (*p)
                            .p_vaddr = ((**((*lm).sections)
                            .as_mut_ptr()
                            .offset(i as isize))
                            .vma)
                            .wrapping_mul(opb as libc::c_ulong);
                        (*p)
                            .p_paddr = ((**((*lm).sections)
                            .as_mut_ptr()
                            .offset(i as isize))
                            .lma)
                            .wrapping_mul(opb as libc::c_ulong);
                        (*p)
                            .p_offset = (**((*lm).sections)
                            .as_mut_ptr()
                            .offset(i as isize))
                            .filepos as bfd_vma;
                        (*p)
                            .p_memsz = end
                            .wrapping_mul(opb as libc::c_ulong)
                            .wrapping_sub((*p).p_vaddr);
                        (*p).p_filesz = (*p).p_memsz;
                        if (*p).p_filesz
                            > ((*lp).p_vaddr)
                                .wrapping_add((*lp).p_filesz)
                                .wrapping_sub((*p).p_vaddr)
                        {
                            (*p)
                                .p_filesz = ((*lp).p_vaddr)
                                .wrapping_add((*lp).p_filesz)
                                .wrapping_sub((*p).p_vaddr);
                        }
                        if (*m).p_align_valid() == 0 {
                            (*p).p_align = 1 as libc::c_int as bfd_vma;
                        }
                        if (*m).p_flags_valid() == 0 {
                            (*p)
                                .p_flags = ((1 as libc::c_int) << 2 as libc::c_int)
                                as libc::c_ulong;
                        }
                        ok = 1 as libc::c_int != 0;
                    }
                }
            }
            if !link_info.is_null() {
                if !ok {
                    bfd_assert(
                        b"elf.c\0" as *const u8 as *const libc::c_char,
                        6261 as libc::c_int,
                    );
                }
            }
            if !ok {
                memset(
                    p as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<Elf_Internal_Phdr>() as libc::c_ulong,
                );
            }
        } else if (*p).p_type
            == (0x60000000 as libc::c_int + 0x474e551 as libc::c_int) as libc::c_ulong
        {
            if (*m).p_size_valid() != 0 {
                (*p).p_memsz = (*m).p_size;
            }
        } else if (*m).count != 0 as libc::c_int as libc::c_uint {
            let mut i_0: libc::c_uint = 0;
            if (*p).p_type != 1 as libc::c_int as libc::c_ulong
                && ((*p).p_type != 4 as libc::c_int as libc::c_ulong
                    || bfd_get_format(abfd) as libc::c_uint
                        != bfd_core as libc::c_int as libc::c_uint)
            {
                if (*p).p_type == 6 as libc::c_int as libc::c_ulong {
                    (*m).count = 0 as libc::c_int as libc::c_uint;
                } else {
                    if (*m).includes_filehdr() as libc::c_int != 0
                        || (*m).includes_phdrs() as libc::c_int != 0
                    {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%pB: error: non-load segment %d includes file header and/or program header\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            abfd,
                            p.offset_from(phdrs) as libc::c_long as libc::c_int,
                        );
                        return 0 as libc::c_int != 0;
                    }
                    (*p).p_filesz = 0 as libc::c_int as bfd_vma;
                    (*p)
                        .p_offset = (**((*m).sections)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize))
                        .filepos as bfd_vma;
                    i_0 = (*m).count;
                    loop {
                        let fresh64 = i_0;
                        i_0 = i_0.wrapping_sub(1);
                        if !(fresh64 != 0 as libc::c_int as libc::c_uint) {
                            break;
                        }
                        let mut sect: *mut asection = *((*m).sections)
                            .as_mut_ptr()
                            .offset(i_0 as isize);
                        let mut hdr_0: *mut Elf_Internal_Shdr = &mut (*((*sect)
                            .used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr;
                        if !((*hdr_0).sh_type != 8 as libc::c_int as libc::c_uint) {
                            continue;
                        }
                        (*p)
                            .p_filesz = (((*sect).filepos
                            - (**((*m).sections)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize))
                                .filepos) as libc::c_ulong)
                            .wrapping_add((*hdr_0).sh_size);
                        if (*p).p_type == 4 as libc::c_int as libc::c_ulong
                            && (*hdr_0).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                        {
                            (*p).p_memsz = (*p).p_filesz;
                        }
                        break;
                    }
                }
            }
        }
        m = (*m).next;
        p = p.offset(1);
        p;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn find_section_in_list(
    mut i: libc::c_uint,
    mut list: *mut elf_section_list,
) -> *mut elf_section_list {
    while !list.is_null() {
        if (*list).ndx == i {
            break;
        }
        list = (*list).next;
    }
    return list;
}
unsafe extern "C" fn assign_file_positions_except_relocs(
    mut abfd: *mut bfd,
    mut link_info: *mut bfd_link_info,
) -> bool {
    let mut tdata: *mut elf_obj_tdata = (*abfd).tdata.elf_obj_data;
    let mut i_ehdrp: *mut Elf_Internal_Ehdr = ((*(*abfd).tdata.elf_obj_data).elf_header)
        .as_mut_ptr();
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut alloc: libc::c_uint = 0;
    if (*abfd).flags & (0x2 as libc::c_int | 0x40 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
        && bfd_get_format(abfd) as libc::c_uint
            != bfd_core as libc::c_int as libc::c_uint
    {
        let i_shdrpp: *mut *mut Elf_Internal_Shdr = (*(*abfd).tdata.elf_obj_data)
            .elf_sect_ptr;
        let mut num_sec: libc::c_uint = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
        let mut hdrpp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
        let mut i: libc::c_uint = 0;
        let mut off: file_ptr = 0;
        off = (*i_ehdrp).e_ehsize as file_ptr;
        i = 1 as libc::c_int as libc::c_uint;
        hdrpp = i_shdrpp.offset(1 as libc::c_int as isize);
        while i < num_sec {
            let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
            hdr = *hdrpp;
            if ((*hdr).sh_type == 9 as libc::c_int as libc::c_uint
                || (*hdr).sh_type == 4 as libc::c_int as libc::c_uint)
                && ((*hdr).bfd_section).is_null()
                || !((*hdr).bfd_section).is_null()
                    && ((*(*hdr).bfd_section).flags
                        & 0x8000000 as libc::c_int as libc::c_uint != 0
                        || bfd_section_is_ctf((*hdr).bfd_section) as libc::c_int != 0
                            && (*abfd).is_linker_output() as libc::c_int != 0)
                || i == (*(*abfd).tdata.elf_obj_data).symtab_section
                || !((*(*abfd).tdata.elf_obj_data).symtab_shndx_list).is_null()
                    && hdr
                        == *i_shdrpp
                            .offset(
                                (*(*(*abfd).tdata.elf_obj_data).symtab_shndx_list).ndx
                                    as isize,
                            ) || i == (*(*(*abfd).tdata.elf_obj_data).o).strtab_section
                || i == (*(*(*abfd).tdata.elf_obj_data).o).shstrtab_section
            {
                (*hdr).sh_offset = -(1 as libc::c_int) as file_ptr;
            } else {
                off = _bfd_elf_assign_file_position_for_section(
                    hdr,
                    off,
                    1 as libc::c_int != 0,
                );
            }
            i = i.wrapping_add(1);
            i;
            hdrpp = hdrpp.offset(1);
            hdrpp;
        }
        (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos = off;
        (*(*(*abfd).tdata.elf_obj_data).o)
            .program_header_size = 0 as libc::c_int as bfd_size_type;
    } else {
        if !assign_file_positions_for_load_sections(abfd, link_info) {
            return 0 as libc::c_int != 0;
        }
        if !assign_file_positions_for_non_load_sections(abfd, link_info) {
            return 0 as libc::c_int != 0;
        }
    }
    if !(Some(((*bed).elf_backend_modify_headers).expect("non-null function pointer")))
        .expect("non-null function pointer")(abfd, link_info)
    {
        return 0 as libc::c_int != 0;
    }
    alloc = (*i_ehdrp).e_phnum;
    if alloc != 0 as libc::c_int as libc::c_uint {
        if bfd_seek(abfd, (*i_ehdrp).e_phoff as file_ptr, 0 as libc::c_int)
            != 0 as libc::c_int
            || ((*(*bed).s).write_out_phdrs)
                .expect("non-null function pointer")(abfd, (*tdata).phdr, alloc)
                != 0 as libc::c_int
        {
            return 0 as libc::c_int != 0;
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_init_file_header(
    mut abfd: *mut bfd,
    mut _info: *mut bfd_link_info,
) -> bool {
    let mut i_ehdrp: *mut Elf_Internal_Ehdr = 0 as *mut Elf_Internal_Ehdr;
    let mut shstrtab: *mut elf_strtab_hash = 0 as *mut elf_strtab_hash;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    i_ehdrp = ((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr();
    shstrtab = _bfd_elf_strtab_init();
    if shstrtab.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr = shstrtab;
    (*i_ehdrp).e_ident[0 as libc::c_int as usize] = 0x7f as libc::c_int as libc::c_uchar;
    (*i_ehdrp).e_ident[1 as libc::c_int as usize] = 'E' as i32 as libc::c_uchar;
    (*i_ehdrp).e_ident[2 as libc::c_int as usize] = 'L' as i32 as libc::c_uchar;
    (*i_ehdrp).e_ident[3 as libc::c_int as usize] = 'F' as i32 as libc::c_uchar;
    (*i_ehdrp).e_ident[4 as libc::c_int as usize] = (*(*bed).s).elfclass;
    (*i_ehdrp)
        .e_ident[5 as libc::c_int
        as usize] = (if bfd_big_endian(abfd) as libc::c_int != 0 {
        2 as libc::c_int
    } else {
        1 as libc::c_int
    }) as libc::c_uchar;
    (*i_ehdrp).e_ident[6 as libc::c_int as usize] = (*(*bed).s).ev_current;
    if (*abfd).flags & 0x40 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        (*i_ehdrp).e_type = 3 as libc::c_int as libc::c_ushort;
    } else if (*abfd).flags & 0x2 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        (*i_ehdrp).e_type = 2 as libc::c_int as libc::c_ushort;
    } else if bfd_get_format(abfd) as libc::c_uint
        == bfd_core as libc::c_int as libc::c_uint
    {
        (*i_ehdrp).e_type = 4 as libc::c_int as libc::c_ushort;
    } else {
        (*i_ehdrp).e_type = 1 as libc::c_int as libc::c_ushort;
    }
    match bfd_get_arch(abfd) as libc::c_uint {
        0 => {
            (*i_ehdrp).e_machine = 0 as libc::c_int as libc::c_ushort;
        }
        _ => {
            (*i_ehdrp).e_machine = (*bed).elf_machine_code as libc::c_ushort;
        }
    }
    (*i_ehdrp).e_version = (*(*bed).s).ev_current as libc::c_ulong;
    (*i_ehdrp).e_ehsize = (*(*bed).s).sizeof_ehdr as libc::c_uint;
    (*i_ehdrp).e_phoff = 0 as libc::c_int as bfd_size_type;
    (*i_ehdrp).e_phentsize = 0 as libc::c_int as libc::c_uint;
    (*i_ehdrp).e_phnum = 0 as libc::c_int as libc::c_uint;
    (*i_ehdrp).e_entry = bfd_get_start_address(abfd);
    (*i_ehdrp).e_shentsize = (*(*bed).s).sizeof_shdr as libc::c_uint;
    (*(*abfd).tdata.elf_obj_data)
        .symtab_hdr
        .sh_name = _bfd_elf_strtab_add(
        shstrtab,
        b".symtab\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int != 0,
    ) as libc::c_uint;
    (*(*abfd).tdata.elf_obj_data)
        .strtab_hdr
        .sh_name = _bfd_elf_strtab_add(
        shstrtab,
        b".strtab\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int != 0,
    ) as libc::c_uint;
    (*(*abfd).tdata.elf_obj_data)
        .shstrtab_hdr
        .sh_name = _bfd_elf_strtab_add(
        shstrtab,
        b".shstrtab\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int != 0,
    ) as libc::c_uint;
    if (*(*abfd).tdata.elf_obj_data).symtab_hdr.sh_name
        == -(1 as libc::c_int) as libc::c_uint
        || (*(*abfd).tdata.elf_obj_data).strtab_hdr.sh_name
            == -(1 as libc::c_int) as libc::c_uint
        || (*(*abfd).tdata.elf_obj_data).shstrtab_hdr.sh_name
            == -(1 as libc::c_int) as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_modify_headers(
    mut obfd: *mut bfd,
    mut link_info: *mut bfd_link_info,
) -> bool {
    if !link_info.is_null()
        && (*link_info).type_0() as libc::c_int == type_pie as libc::c_int
    {
        let mut i_ehdrp: *mut Elf_Internal_Ehdr = ((*(*obfd).tdata.elf_obj_data)
            .elf_header)
            .as_mut_ptr();
        let mut num_segments: libc::c_uint = (*i_ehdrp).e_phnum;
        let mut tdata: *mut elf_obj_tdata = (*obfd).tdata.elf_obj_data;
        let mut segment: *mut Elf_Internal_Phdr = (*tdata).phdr;
        let mut end_segment: *mut Elf_Internal_Phdr = &mut *segment
            .offset(num_segments as isize) as *mut Elf_Internal_Phdr;
        let mut p_vaddr: bfd_vma = -(1 as libc::c_int) as bfd_vma;
        while segment < end_segment {
            if (*segment).p_type == 1 as libc::c_int as libc::c_ulong
                && p_vaddr > (*segment).p_vaddr
            {
                p_vaddr = (*segment).p_vaddr;
            }
            segment = segment.offset(1);
            segment;
        }
        if p_vaddr != 0 {
            (*i_ehdrp).e_type = 2 as libc::c_int as libc::c_ushort;
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn _bfd_elf_assign_file_positions_for_non_load(
    mut abfd: *mut bfd,
) -> bool {
    let mut off: file_ptr = 0;
    let mut shdrpp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    let mut end_shdrpp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    let mut shdrp: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut i_ehdrp: *mut Elf_Internal_Ehdr = 0 as *mut Elf_Internal_Ehdr;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    off = (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos;
    shdrpp = (*(*abfd).tdata.elf_obj_data).elf_sect_ptr;
    end_shdrpp = shdrpp.offset((*(*abfd).tdata.elf_obj_data).num_elf_sections as isize);
    shdrpp = shdrpp.offset(1);
    shdrpp;
    while shdrpp < end_shdrpp {
        shdrp = *shdrpp;
        if (*shdrp).sh_offset == -(1 as libc::c_int) as libc::c_long {
            let mut sec: *mut asection = (*shdrp).bfd_section;
            let mut is_rel: bool = (*shdrp).sh_type == 9 as libc::c_int as libc::c_uint
                || (*shdrp).sh_type == 4 as libc::c_int as libc::c_uint;
            let mut is_ctf: bool = !sec.is_null()
                && bfd_section_is_ctf(sec) as libc::c_int != 0;
            if is_rel as libc::c_int != 0 || is_ctf as libc::c_int != 0
                || !sec.is_null()
                    && (*sec).flags & 0x8000000 as libc::c_int as libc::c_uint != 0
            {
                if !is_rel && !is_ctf {
                    let mut name: *const libc::c_char = (*sec).name;
                    let mut d: *mut bfd_elf_section_data = 0
                        as *mut bfd_elf_section_data;
                    if !bfd_compress_section(abfd, sec, (*shdrp).contents) {
                        return 0 as libc::c_int != 0;
                    }
                    if (*sec).compress_status() as libc::c_int == 1 as libc::c_int
                        && (*abfd).flags & 0x20000 as libc::c_int as libc::c_uint
                            == 0 as libc::c_int as libc::c_uint
                    {
                        let mut new_name: *mut libc::c_char = convert_debug_to_zdebug(
                            abfd,
                            name,
                        );
                        if new_name.is_null() {
                            return 0 as libc::c_int != 0;
                        }
                        name = new_name;
                    }
                    if (*shdrp).sh_name != -(1 as libc::c_int) as libc::c_uint {
                        _bfd_abort(
                            b"elf.c\0" as *const u8 as *const libc::c_char,
                            6587 as libc::c_int,
                            (*::core::mem::transmute::<
                                &[u8; 57],
                                &[libc::c_char; 57],
                            >(
                                b"_Bool _bfd_elf_assign_file_positions_for_non_load(bfd *)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                    (*shdrp)
                        .sh_name = _bfd_elf_strtab_add(
                        (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
                        name,
                        0 as libc::c_int != 0,
                    ) as libc::c_uint;
                    d = (*sec).used_by_bfd as *mut bfd_elf_section_data;
                    if !((*d).rel.hdr).is_null()
                        && !_bfd_elf_set_reloc_sh_name(
                            abfd,
                            (*d).rel.hdr,
                            name,
                            0 as libc::c_int != 0,
                        )
                    {
                        return 0 as libc::c_int != 0;
                    }
                    if !((*d).rela.hdr).is_null()
                        && !_bfd_elf_set_reloc_sh_name(
                            abfd,
                            (*d).rela.hdr,
                            name,
                            1 as libc::c_int != 0,
                        )
                    {
                        return 0 as libc::c_int != 0;
                    }
                    (*shdrp).sh_size = (*sec).size;
                    (*shdrp).contents = (*sec).contents;
                    (*(*shdrp).bfd_section).contents = 0 as *mut libc::c_uchar;
                } else if is_ctf {
                    (*shdrp).sh_size = (*sec).size;
                    (*shdrp).contents = (*sec).contents;
                }
                off = _bfd_elf_assign_file_position_for_section(
                    shdrp,
                    off,
                    1 as libc::c_int != 0,
                );
            }
        }
        shdrpp = shdrpp.offset(1);
        shdrpp;
    }
    _bfd_elf_strtab_finalize((*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr);
    shdrp = &mut (*(*abfd).tdata.elf_obj_data).shstrtab_hdr;
    (*shdrp)
        .sh_size = _bfd_elf_strtab_size((*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr);
    off = _bfd_elf_assign_file_position_for_section(shdrp, off, 1 as libc::c_int != 0);
    i_ehdrp = ((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr();
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    off = align_file_position(
        off,
        (1 as libc::c_int) << (*(*bed).s).log_file_align as libc::c_int,
    );
    (*i_ehdrp).e_shoff = off as bfd_size_type;
    off += ((*i_ehdrp).e_shnum).wrapping_mul((*i_ehdrp).e_shentsize) as libc::c_long;
    (*(*(*abfd).tdata.elf_obj_data).o).next_file_pos = off;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_write_object_contents(mut abfd: *mut bfd) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut i_shdrp: *mut *mut Elf_Internal_Shdr = 0 as *mut *mut Elf_Internal_Shdr;
    let mut failed: bool = false;
    let mut count: libc::c_uint = 0;
    let mut num_sec: libc::c_uint = 0;
    let mut t: *mut elf_obj_tdata = 0 as *mut elf_obj_tdata;
    if (*abfd).output_has_begun() == 0
        && !_bfd_elf_compute_section_file_positions(abfd, 0 as *mut bfd_link_info)
    {
        return 0 as libc::c_int != 0
    } else if (*abfd).direction() as libc::c_int == both_direction as libc::c_int {
        if (*abfd).output_has_begun() == 0 {
            bfd_assert(
                b"elf.c\0" as *const u8 as *const libc::c_char,
                6663 as libc::c_int,
            );
        }
        return 1 as libc::c_int != 0;
    }
    i_shdrp = (*(*abfd).tdata.elf_obj_data).elf_sect_ptr;
    failed = 0 as libc::c_int != 0;
    bfd_map_over_sections(
        abfd,
        (*(*bed).s).write_relocs,
        &mut failed as *mut bool as *mut libc::c_void,
    );
    if failed {
        return 0 as libc::c_int != 0;
    }
    if !_bfd_elf_assign_file_positions_for_non_load(abfd) {
        return 0 as libc::c_int != 0;
    }
    num_sec = (*(*abfd).tdata.elf_obj_data).num_elf_sections;
    count = 1 as libc::c_int as libc::c_uint;
    while count < num_sec {
        (**i_shdrp.offset(count as isize))
            .sh_name = _bfd_elf_strtab_offset(
            (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
            (**i_shdrp.offset(count as isize)).sh_name as size_t,
        ) as libc::c_uint;
        if ((*bed).elf_backend_section_processing).is_some() {
            if !(Some(
                ((*bed).elf_backend_section_processing)
                    .expect("non-null function pointer"),
            ))
                .expect(
                    "non-null function pointer",
                )(abfd, *i_shdrp.offset(count as isize))
            {
                return 0 as libc::c_int != 0;
            }
        }
        if !((**i_shdrp.offset(count as isize)).contents).is_null() {
            let mut amt: bfd_size_type = (**i_shdrp.offset(count as isize)).sh_size;
            if bfd_seek(
                abfd,
                (**i_shdrp.offset(count as isize)).sh_offset,
                0 as libc::c_int,
            ) != 0 as libc::c_int
                || bfd_bwrite(
                    (**i_shdrp.offset(count as isize)).contents as *const libc::c_void,
                    amt,
                    abfd,
                ) != amt
            {
                return 0 as libc::c_int != 0;
            }
        }
        count = count.wrapping_add(1);
        count;
    }
    t = (*abfd).tdata.elf_obj_data;
    if !((*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr).is_null()
        && (bfd_seek(abfd, (*t).shstrtab_hdr.sh_offset, 0 as libc::c_int)
            != 0 as libc::c_int
            || !_bfd_elf_strtab_emit(
                abfd,
                (*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr,
            ))
    {
        return 0 as libc::c_int != 0;
    }
    if !(Some(
        ((*bed).elf_backend_final_write_processing).expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(abfd)
    {
        return 0 as libc::c_int != 0;
    }
    if !((*(*bed).s).write_shdrs_and_ehdr).expect("non-null function pointer")(abfd) {
        return 0 as libc::c_int != 0;
    }
    if ((*(*t).o).build_id.after_write_object_contents).is_some() {
        return (Some(
            ((*(*t).o).build_id.after_write_object_contents)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd);
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_write_corefile_contents(mut abfd: *mut bfd) -> bool {
    return _bfd_elf_write_object_contents(abfd);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_section_from_bfd_section(
    mut abfd: *mut bfd,
    mut asect: *mut bfd_section,
) -> libc::c_uint {
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut sec_index: libc::c_uint = 0;
    if !((*asect).used_by_bfd as *mut bfd_elf_section_data).is_null()
        && (*((*asect).used_by_bfd as *mut bfd_elf_section_data)).this_idx
            != 0 as libc::c_int
    {
        return (*((*asect).used_by_bfd as *mut bfd_elf_section_data)).this_idx
            as libc::c_uint;
    }
    if bfd_is_abs_section(asect) {
        sec_index = (0xf as libc::c_uint).wrapping_neg();
    } else if bfd_is_com_section(asect) {
        sec_index = (0xe as libc::c_uint).wrapping_neg();
    } else if bfd_is_und_section(asect) {
        sec_index = 0 as libc::c_int as libc::c_uint;
    } else {
        sec_index = (0x101 as libc::c_uint).wrapping_neg();
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    if ((*bed).elf_backend_section_from_bfd_section).is_some() {
        let mut retval: libc::c_int = sec_index as libc::c_int;
        if (Some(
            ((*bed).elf_backend_section_from_bfd_section)
                .expect("non-null function pointer"),
        ))
            .expect("non-null function pointer")(abfd, asect, &mut retval)
        {
            return retval as libc::c_uint;
        }
    }
    if sec_index == (0x101 as libc::c_uint).wrapping_neg() {
        bfd_set_error(bfd_error_nonrepresentable_section);
    }
    return sec_index;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_symbol_from_bfd_symbol(
    mut abfd: *mut bfd,
    mut asym_ptr_ptr: *mut *mut asymbol,
) -> libc::c_int {
    let mut asym_ptr: *mut asymbol = *asym_ptr_ptr;
    let mut idx: libc::c_int = 0;
    let mut flags: flagword = (*asym_ptr).flags;
    if (*asym_ptr).udata.i == 0 as libc::c_int as libc::c_ulong
        && flags & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint != 0
        && !((*asym_ptr).section).is_null()
    {
        let mut sec: *mut asection = 0 as *mut asection;
        let mut indx: libc::c_int = 0;
        sec = (*asym_ptr).section;
        if (*sec).owner != abfd && !((*sec).output_section).is_null() {
            sec = (*sec).output_section;
        }
        if (*sec).owner == abfd
            && {
                indx = (*sec).index as libc::c_int;
                indx < (*(*(*abfd).tdata.elf_obj_data).o).num_section_syms
            }
            && !(*((*(*(*abfd).tdata.elf_obj_data).o).section_syms)
                .offset(indx as isize))
                .is_null()
        {
            (*asym_ptr)
                .udata
                .i = (**((*(*(*abfd).tdata.elf_obj_data).o).section_syms)
                .offset(indx as isize))
                .udata
                .i;
        }
    }
    idx = (*asym_ptr).udata.i as libc::c_int;
    if idx == 0 as libc::c_int {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: symbol `%s' required but not present\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            bfd_asymbol_name(asym_ptr),
        );
        bfd_set_error(bfd_error_no_symbols);
        return -(1 as libc::c_int);
    }
    return idx;
}
unsafe extern "C" fn rewrite_elf_program_header(
    mut ibfd: *mut bfd,
    mut obfd: *mut bfd,
    mut maxpagesize: bfd_vma,
) -> bool {
    let mut iehdr: *mut Elf_Internal_Ehdr = 0 as *mut Elf_Internal_Ehdr;
    let mut map: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut map_first: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut pointer_to_map: *mut *mut elf_segment_map = 0 as *mut *mut elf_segment_map;
    let mut segment: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut section: *mut asection = 0 as *mut asection;
    let mut i: libc::c_uint = 0;
    let mut num_segments: libc::c_uint = 0;
    let mut phdr_included: bool = 0 as libc::c_int != 0;
    let mut p_paddr_valid: bool = false;
    let mut phdr_adjust_seg: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut phdr_adjust_num: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut opb: libc::c_uint = bfd_octets_per_byte(ibfd, 0 as *const asection);
    bed = (*(*ibfd).xvec).backend_data as *const elf_backend_data;
    iehdr = ((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr();
    map_first = 0 as *mut elf_segment_map;
    pointer_to_map = &mut map_first;
    num_segments = (*((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum;
    section = (*ibfd).sections;
    while !section.is_null() {
        (*section).set_segment_mark(0 as libc::c_int as libc::c_uint);
        section = (*section).next;
    }
    p_paddr_valid = 0 as libc::c_int != 0;
    i = 0 as libc::c_int as libc::c_uint;
    segment = (*(*ibfd).tdata.elf_obj_data).phdr;
    while i < num_segments {
        if (*segment).p_paddr != 0 as libc::c_int as libc::c_ulong {
            p_paddr_valid = 1 as libc::c_int != 0;
            break;
        } else {
            i = i.wrapping_add(1);
            i;
            segment = segment.offset(1);
            segment;
        }
    }
    i = 0 as libc::c_int as libc::c_uint;
    segment = (*(*ibfd).tdata.elf_obj_data).phdr;
    while i < num_segments {
        let mut j: libc::c_uint = 0;
        let mut segment2: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
        if (*segment).p_type == 3 as libc::c_int as libc::c_ulong {
            section = (*ibfd).sections;
            while !section.is_null() {
                if (*segment).p_vaddr == 0 as libc::c_int as libc::c_ulong
                    && (*segment).p_paddr == 0 as libc::c_int as libc::c_ulong
                    && (*segment).p_memsz == 0 as libc::c_int as libc::c_ulong
                    && (*segment).p_filesz > 0 as libc::c_int as libc::c_ulong
                    && (*section).flags & 0x100 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    && (*section).size > 0 as libc::c_int as libc::c_ulong
                    && (*section).filepos as bfd_vma >= (*segment).p_offset
                    && ((*section).filepos as bfd_vma).wrapping_add((*section).size)
                        <= ((*segment).p_offset).wrapping_add((*segment).p_filesz)
                {
                    (*segment)
                        .p_vaddr = ((*section).vma).wrapping_mul(opb as libc::c_ulong);
                    break;
                } else {
                    section = (*section).next;
                }
            }
        }
        if (*segment).p_type != 1 as libc::c_int as libc::c_ulong {
            if (*segment).p_type
                == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                    as libc::c_ulong
            {
                (*segment).p_type = 0 as libc::c_int as libc::c_ulong;
            }
        } else {
            j = 0 as libc::c_int as libc::c_uint;
            segment2 = (*(*ibfd).tdata.elf_obj_data).phdr;
            while j < i {
                let mut extra_length: bfd_signed_vma = 0;
                if !((*segment2).p_type != 1 as libc::c_int as libc::c_ulong
                    || !(!((*segment).p_vaddr
                        >= ((*segment2).p_vaddr)
                            .wrapping_add(
                                if (*segment2).p_memsz > (*segment2).p_filesz {
                                    (*segment2).p_memsz
                                } else {
                                    (*segment2).p_filesz
                                },
                            )
                        || (*segment2).p_vaddr
                            >= ((*segment).p_vaddr)
                                .wrapping_add(
                                    if (*segment).p_memsz > (*segment).p_filesz {
                                        (*segment).p_memsz
                                    } else {
                                        (*segment).p_filesz
                                    },
                                ))
                        && !((*segment).p_paddr
                            >= ((*segment2).p_paddr)
                                .wrapping_add(
                                    if (*segment2).p_memsz > (*segment2).p_filesz {
                                        (*segment2).p_memsz
                                    } else {
                                        (*segment2).p_filesz
                                    },
                                )
                            || (*segment2).p_paddr
                                >= ((*segment).p_paddr)
                                    .wrapping_add(
                                        if (*segment).p_memsz > (*segment).p_filesz {
                                            (*segment).p_memsz
                                        } else {
                                            (*segment).p_filesz
                                        },
                                    ))))
                {
                    if (*segment2).p_vaddr < (*segment).p_vaddr {
                        extra_length = ((*segment).p_vaddr)
                            .wrapping_add(
                                if (*segment).p_memsz > (*segment).p_filesz {
                                    (*segment).p_memsz
                                } else {
                                    (*segment).p_filesz
                                },
                            )
                            .wrapping_sub(
                                ((*segment2).p_vaddr)
                                    .wrapping_add(
                                        if (*segment2).p_memsz > (*segment2).p_filesz {
                                            (*segment2).p_memsz
                                        } else {
                                            (*segment2).p_filesz
                                        },
                                    ),
                            ) as bfd_signed_vma;
                        if extra_length > 0 as libc::c_int as libc::c_long {
                            (*segment2)
                                .p_memsz = ((*segment2).p_memsz as libc::c_ulong)
                                .wrapping_add(extra_length as libc::c_ulong) as bfd_vma
                                as bfd_vma;
                            (*segment2)
                                .p_filesz = ((*segment2).p_filesz as libc::c_ulong)
                                .wrapping_add(extra_length as libc::c_ulong) as bfd_vma
                                as bfd_vma;
                        }
                        (*segment).p_type = 0 as libc::c_int as libc::c_ulong;
                        i = 0 as libc::c_int as libc::c_uint;
                        segment = (*(*ibfd).tdata.elf_obj_data).phdr;
                        break;
                    } else {
                        extra_length = ((*segment2).p_vaddr)
                            .wrapping_add(
                                if (*segment2).p_memsz > (*segment2).p_filesz {
                                    (*segment2).p_memsz
                                } else {
                                    (*segment2).p_filesz
                                },
                            )
                            .wrapping_sub(
                                ((*segment).p_vaddr)
                                    .wrapping_add(
                                        if (*segment).p_memsz > (*segment).p_filesz {
                                            (*segment).p_memsz
                                        } else {
                                            (*segment).p_filesz
                                        },
                                    ),
                            ) as bfd_signed_vma;
                        if extra_length > 0 as libc::c_int as libc::c_long {
                            (*segment)
                                .p_memsz = ((*segment).p_memsz as libc::c_ulong)
                                .wrapping_add(extra_length as libc::c_ulong) as bfd_vma
                                as bfd_vma;
                            (*segment)
                                .p_filesz = ((*segment).p_filesz as libc::c_ulong)
                                .wrapping_add(extra_length as libc::c_ulong) as bfd_vma
                                as bfd_vma;
                        }
                        (*segment2).p_type = 0 as libc::c_int as libc::c_ulong;
                    }
                }
                j = j.wrapping_add(1);
                j;
                segment2 = segment2.offset(1);
                segment2;
            }
        }
        i = i.wrapping_add(1);
        i;
        segment = segment.offset(1);
        segment;
    }
    i = 0 as libc::c_int as libc::c_uint;
    segment = (*(*ibfd).tdata.elf_obj_data).phdr;
    while i < num_segments {
        let mut section_count: libc::c_uint = 0;
        let mut sections: *mut *mut asection = 0 as *mut *mut asection;
        let mut output_section: *mut asection = 0 as *mut asection;
        let mut isec: libc::c_uint = 0;
        let mut matching_lma: *mut asection = 0 as *mut asection;
        let mut suggested_lma: *mut asection = 0 as *mut asection;
        let mut j_0: libc::c_uint = 0;
        let mut amt: size_t = 0;
        let mut first_section: *mut asection = 0 as *mut asection;
        if !((*segment).p_type == 0 as libc::c_int as libc::c_ulong) {
            first_section = 0 as *mut asection;
            section = (*ibfd).sections;
            section_count = 0 as libc::c_int as libc::c_uint;
            while !section.is_null() {
                if ((if (*segment).p_paddr != 0 {
                    (((*section).lma).wrapping_mul(opb as libc::c_ulong)
                        >= (*segment).p_paddr
                        && ((*section).lma)
                            .wrapping_add(
                                (if (*section).flags
                                    & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                        as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                    || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                {
                                    (*section).size
                                } else {
                                    0 as libc::c_int as libc::c_ulong
                                })
                                    .wrapping_div(opb as libc::c_ulong),
                            ) >= (*section).lma
                        && ((*section).lma)
                            .wrapping_mul(opb as libc::c_ulong)
                            .wrapping_add(
                                if (*section).flags
                                    & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                        as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                    || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                {
                                    (*section).size
                                } else {
                                    0 as libc::c_int as libc::c_ulong
                                },
                            )
                            <= ((*segment).p_paddr)
                                .wrapping_add(
                                    if (*segment).p_memsz > (*segment).p_filesz {
                                        (*segment).p_memsz
                                    } else {
                                        (*segment).p_filesz
                                    },
                                )) as libc::c_int
                } else {
                    (((*section).vma).wrapping_mul(opb as libc::c_ulong)
                        >= (*segment).p_vaddr
                        && ((*section).vma)
                            .wrapping_mul(opb as libc::c_ulong)
                            .wrapping_add(
                                if (*section).flags
                                    & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                        as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                    || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                {
                                    (*section).size
                                } else {
                                    0 as libc::c_int as libc::c_ulong
                                },
                            )
                            <= ((*segment).p_vaddr)
                                .wrapping_add(
                                    if (*segment).p_memsz > (*segment).p_filesz {
                                        (*segment).p_memsz
                                    } else {
                                        (*segment).p_filesz
                                    },
                                )) as libc::c_int
                }) != 0
                    && (*section).flags & 0x1 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    || (*segment).p_type == 4 as libc::c_int as libc::c_ulong
                        && (*((*section).used_by_bfd as *mut bfd_elf_section_data))
                            .this_hdr
                            .sh_type == 7 as libc::c_int as libc::c_uint
                        && (*section).filepos as bfd_vma >= (*segment).p_offset
                        && ((*section).filepos as bfd_vma).wrapping_add((*section).size)
                            <= ((*segment).p_offset).wrapping_add((*segment).p_filesz))
                    && (*segment).p_type
                        != (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                            as libc::c_ulong
                    && ((*segment).p_type != 7 as libc::c_int as libc::c_ulong
                        || (*section).flags & 0x400 as libc::c_int as libc::c_uint != 0)
                    && ((*segment).p_type == 1 as libc::c_int as libc::c_ulong
                        || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                        || (*section).flags & 0x400 as libc::c_int as libc::c_uint
                            == 0 as libc::c_int as libc::c_uint)
                    && ((*segment).p_type != 2 as libc::c_int as libc::c_ulong
                        || (if (*section).flags
                            & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                            || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                        {
                            (*section).size
                        } else {
                            0 as libc::c_int as libc::c_ulong
                        }) > 0 as libc::c_int as libc::c_ulong
                        || (if (*segment).p_paddr != 0 {
                            ((*segment).p_paddr
                                != ((*section).lma).wrapping_mul(opb as libc::c_ulong))
                                as libc::c_int
                        } else {
                            ((*segment).p_vaddr
                                != ((*section).vma).wrapping_mul(opb as libc::c_ulong))
                                as libc::c_int
                        }) != 0
                        || strcmp(
                            bfd_section_name(section),
                            b".dynamic\0" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int)
                    && ((*segment).p_type != 1 as libc::c_int as libc::c_ulong
                        || (*section).segment_mark() == 0)
                {
                    if first_section.is_null() {
                        first_section = section;
                    }
                    if !((*section).output_section).is_null() {
                        section_count = section_count.wrapping_add(1);
                        section_count;
                    }
                }
                section = (*section).next;
            }
            amt = (::core::mem::size_of::<elf_segment_map>() as libc::c_ulong)
                .wrapping_sub(::core::mem::size_of::<*mut asection>() as libc::c_ulong);
            amt = (amt as libc::c_ulong)
                .wrapping_add(
                    (section_count as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                        ),
                ) as size_t as size_t;
            map = bfd_zalloc(obfd, amt) as *mut elf_segment_map;
            if map.is_null() {
                return 0 as libc::c_int != 0;
            }
            (*map).next = 0 as *mut elf_segment_map;
            (*map).p_type = (*segment).p_type;
            (*map).p_flags = (*segment).p_flags;
            (*map).set_p_flags_valid(1 as libc::c_int as libc::c_uint);
            if (*map).p_type == 1 as libc::c_int as libc::c_ulong
                && (*ibfd).flags & 0x100 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                && maxpagesize > 1 as libc::c_int as libc::c_ulong
                && (*segment).p_align > 1 as libc::c_int as libc::c_ulong
            {
                (*map).p_align = (*segment).p_align;
                if (*segment).p_align > maxpagesize {
                    (*map).p_align = maxpagesize;
                }
                (*map).set_p_align_valid(1 as libc::c_int as libc::c_uint);
            }
            if first_section.is_null() || !((*first_section).output_section).is_null() {
                (*map).p_paddr = (*segment).p_paddr;
                (*map).set_p_paddr_valid(p_paddr_valid as libc::c_uint);
            }
            (*map)
                .set_includes_filehdr(
                    ((*segment).p_offset == 0 as libc::c_int as libc::c_ulong
                        && (*segment).p_filesz >= (*iehdr).e_ehsize as libc::c_ulong)
                        as libc::c_int as libc::c_uint,
                );
            (*map).set_includes_phdrs(0 as libc::c_int as libc::c_uint);
            if !phdr_included || (*segment).p_type != 1 as libc::c_int as libc::c_ulong {
                (*map)
                    .set_includes_phdrs(
                        ((*segment).p_offset <= (*iehdr).e_phoff
                            && ((*segment).p_offset).wrapping_add((*segment).p_filesz)
                                >= ((*iehdr).e_phoff)
                                    .wrapping_add(
                                        ((*iehdr).e_phnum).wrapping_mul((*iehdr).e_phentsize)
                                            as libc::c_ulong,
                                    )) as libc::c_int as libc::c_uint,
                    );
                if (*segment).p_type == 1 as libc::c_int as libc::c_ulong
                    && (*map).includes_phdrs() as libc::c_int != 0
                {
                    phdr_included = 1 as libc::c_int != 0;
                }
            }
            if section_count == 0 as libc::c_int as libc::c_uint {
                if (*segment).p_type == 1 as libc::c_int as libc::c_ulong
                    && ((*segment).p_filesz > 0 as libc::c_int as libc::c_ulong
                        || (*segment).p_memsz == 0 as libc::c_int as libc::c_ulong)
                {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: warning: empty loadable segment detected at vaddr=%#lx, is this intentional?\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        ibfd,
                        (*segment).p_vaddr,
                    );
                }
                (*map)
                    .p_vaddr_offset = ((*segment).p_vaddr)
                    .wrapping_div(opb as libc::c_ulong);
                (*map).count = 0 as libc::c_int as libc::c_uint;
                *pointer_to_map = map;
                pointer_to_map = &mut (*map).next;
            } else {
                amt = (section_count as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                    );
                sections = bfd_malloc(amt) as *mut *mut asection;
                if sections.is_null() {
                    return 0 as libc::c_int != 0;
                }
                isec = 0 as libc::c_int as libc::c_uint;
                matching_lma = 0 as *mut asection;
                suggested_lma = 0 as *mut asection;
                section = first_section;
                j_0 = 0 as libc::c_int as libc::c_uint;
                while !section.is_null() {
                    if ((if (*segment).p_paddr != 0 {
                        (((*section).lma).wrapping_mul(opb as libc::c_ulong)
                            >= (*segment).p_paddr
                            && ((*section).lma)
                                .wrapping_add(
                                    (if (*section).flags
                                        & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                            as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                        || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                    {
                                        (*section).size
                                    } else {
                                        0 as libc::c_int as libc::c_ulong
                                    })
                                        .wrapping_div(opb as libc::c_ulong),
                                ) >= (*section).lma
                            && ((*section).lma)
                                .wrapping_mul(opb as libc::c_ulong)
                                .wrapping_add(
                                    if (*section).flags
                                        & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                            as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                        || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                    {
                                        (*section).size
                                    } else {
                                        0 as libc::c_int as libc::c_ulong
                                    },
                                )
                                <= ((*segment).p_paddr)
                                    .wrapping_add(
                                        if (*segment).p_memsz > (*segment).p_filesz {
                                            (*segment).p_memsz
                                        } else {
                                            (*segment).p_filesz
                                        },
                                    )) as libc::c_int
                    } else {
                        (((*section).vma).wrapping_mul(opb as libc::c_ulong)
                            >= (*segment).p_vaddr
                            && ((*section).vma)
                                .wrapping_mul(opb as libc::c_ulong)
                                .wrapping_add(
                                    if (*section).flags
                                        & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                            as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                        || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                    {
                                        (*section).size
                                    } else {
                                        0 as libc::c_int as libc::c_ulong
                                    },
                                )
                                <= ((*segment).p_vaddr)
                                    .wrapping_add(
                                        if (*segment).p_memsz > (*segment).p_filesz {
                                            (*segment).p_memsz
                                        } else {
                                            (*segment).p_filesz
                                        },
                                    )) as libc::c_int
                    }) != 0
                        && (*section).flags & 0x1 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        || (*segment).p_type == 4 as libc::c_int as libc::c_ulong
                            && (*((*section).used_by_bfd as *mut bfd_elf_section_data))
                                .this_hdr
                                .sh_type == 7 as libc::c_int as libc::c_uint
                            && (*section).filepos as bfd_vma >= (*segment).p_offset
                            && ((*section).filepos as bfd_vma)
                                .wrapping_add((*section).size)
                                <= ((*segment).p_offset).wrapping_add((*segment).p_filesz))
                        && (*segment).p_type
                            != (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                                as libc::c_ulong
                        && ((*segment).p_type != 7 as libc::c_int as libc::c_ulong
                            || (*section).flags & 0x400 as libc::c_int as libc::c_uint
                                != 0)
                        && ((*segment).p_type == 1 as libc::c_int as libc::c_ulong
                            || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                            || (*section).flags & 0x400 as libc::c_int as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint)
                        && ((*segment).p_type != 2 as libc::c_int as libc::c_ulong
                            || (if (*section).flags
                                & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                    as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                            {
                                (*section).size
                            } else {
                                0 as libc::c_int as libc::c_ulong
                            }) > 0 as libc::c_int as libc::c_ulong
                            || (if (*segment).p_paddr != 0 {
                                ((*segment).p_paddr
                                    != ((*section).lma).wrapping_mul(opb as libc::c_ulong))
                                    as libc::c_int
                            } else {
                                ((*segment).p_vaddr
                                    != ((*section).vma).wrapping_mul(opb as libc::c_ulong))
                                    as libc::c_int
                            }) != 0
                            || strcmp(
                                bfd_section_name(section),
                                b".dynamic\0" as *const u8 as *const libc::c_char,
                            ) == 0 as libc::c_int)
                        && ((*segment).p_type != 1 as libc::c_int as libc::c_ulong
                            || (*section).segment_mark() == 0)
                        && !((*section).output_section).is_null()
                    {
                        output_section = (*section).output_section;
                        let fresh65 = j_0;
                        j_0 = j_0.wrapping_add(1);
                        let ref mut fresh66 = *sections.offset(fresh65 as isize);
                        *fresh66 = section;
                        if !p_paddr_valid
                            && (*segment).p_vaddr != 0 as libc::c_int as libc::c_ulong
                            && (*bed).want_p_paddr_set_to_zero() == 0
                            && isec == 0 as libc::c_int as libc::c_uint
                            && (*output_section).lma != 0 as libc::c_int as libc::c_ulong
                            && ((*segment).p_vaddr)
                                .wrapping_add(
                                    (if (*map).includes_filehdr() as libc::c_int != 0 {
                                        (*iehdr).e_ehsize
                                    } else {
                                        0 as libc::c_int as libc::c_uint
                                    }) as libc::c_ulong,
                                )
                                .wrapping_add(
                                    (if (*map).includes_phdrs() as libc::c_int != 0 {
                                        ((*iehdr).e_phnum).wrapping_mul((*iehdr).e_phentsize)
                                    } else {
                                        0 as libc::c_int as libc::c_uint
                                    }) as libc::c_ulong,
                                )
                                .wrapping_add(
                                    (1 as libc::c_int as bfd_vma)
                                        << ((*output_section).alignment_power).wrapping_mul(opb),
                                )
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                & ((1 as libc::c_int as bfd_vma)
                                    << ((*output_section).alignment_power).wrapping_mul(opb))
                                    .wrapping_neg()
                                == ((*output_section).vma)
                                    .wrapping_mul(opb as libc::c_ulong)
                        {
                            (*map).p_paddr = (*segment).p_vaddr;
                        }
                        if ((*output_section).lma).wrapping_mul(opb as libc::c_ulong)
                            >= (*map).p_paddr
                            && ((*output_section).lma)
                                .wrapping_add(
                                    (if (*output_section).flags
                                        & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                            as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                        || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                    {
                                        (*output_section).size
                                    } else {
                                        0 as libc::c_int as libc::c_ulong
                                    })
                                        .wrapping_div(opb as libc::c_ulong),
                                ) >= (*output_section).lma
                            && ((*output_section).lma)
                                .wrapping_mul(opb as libc::c_ulong)
                                .wrapping_add(
                                    if (*output_section).flags
                                        & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                            as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                        || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                    {
                                        (*output_section).size
                                    } else {
                                        0 as libc::c_int as libc::c_ulong
                                    },
                                )
                                <= ((*map).p_paddr)
                                    .wrapping_add(
                                        if (*segment).p_memsz > (*segment).p_filesz {
                                            (*segment).p_memsz
                                        } else {
                                            (*segment).p_filesz
                                        },
                                    )
                            || (*segment).p_type == 4 as libc::c_int as libc::c_ulong
                                && (*((*section).used_by_bfd as *mut bfd_elf_section_data))
                                    .this_hdr
                                    .sh_type == 7 as libc::c_int as libc::c_uint
                                && (*section).filepos as bfd_vma >= (*segment).p_offset
                                && ((*section).filepos as bfd_vma)
                                    .wrapping_add((*section).size)
                                    <= ((*segment).p_offset).wrapping_add((*segment).p_filesz)
                                && bfd_get_format(ibfd) as libc::c_uint
                                    == bfd_core as libc::c_int as libc::c_uint
                                && (*section).vma == 0 as libc::c_int as libc::c_ulong
                                && (*section).lma == 0 as libc::c_int as libc::c_ulong
                            || (*bed).want_p_paddr_set_to_zero() as libc::c_int != 0
                                && (((*output_section).vma)
                                    .wrapping_mul(opb as libc::c_ulong) >= (*segment).p_vaddr
                                    && ((*output_section).vma)
                                        .wrapping_mul(opb as libc::c_ulong)
                                        .wrapping_add(
                                            if (*output_section).flags
                                                & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                                    as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                                || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                            {
                                                (*output_section).size
                                            } else {
                                                0 as libc::c_int as libc::c_ulong
                                            },
                                        )
                                        <= ((*segment).p_vaddr)
                                            .wrapping_add(
                                                if (*segment).p_memsz > (*segment).p_filesz {
                                                    (*segment).p_memsz
                                                } else {
                                                    (*segment).p_filesz
                                                },
                                            ))
                        {
                            if matching_lma.is_null()
                                || (*output_section).lma < (*matching_lma).lma
                            {
                                matching_lma = output_section;
                            }
                            let fresh67 = isec;
                            isec = isec.wrapping_add(1);
                            let ref mut fresh68 = *((*map).sections)
                                .as_mut_ptr()
                                .offset(fresh67 as isize);
                            *fresh68 = output_section;
                        } else if suggested_lma.is_null() {
                            suggested_lma = output_section;
                        }
                        if j_0 == section_count {
                            break;
                        }
                    }
                    section = (*section).next;
                }
                if !(j_0 == section_count) {
                    bfd_assert(
                        b"elf.c\0" as *const u8 as *const libc::c_char,
                        7260 as libc::c_int,
                    );
                }
                if isec == section_count {
                    (*map).count = section_count;
                    *pointer_to_map = map;
                    pointer_to_map = &mut (*map).next;
                    if p_paddr_valid as libc::c_int != 0
                        && (*bed).want_p_paddr_set_to_zero() == 0
                    {
                        let mut hdr_size: bfd_vma = 0 as libc::c_int as bfd_vma;
                        if (*map).includes_filehdr() != 0 {
                            hdr_size = (*iehdr).e_ehsize as bfd_vma;
                        }
                        if (*map).includes_phdrs() != 0 {
                            hdr_size = (hdr_size as libc::c_ulong)
                                .wrapping_add(
                                    ((*iehdr).e_phnum).wrapping_mul((*iehdr).e_phentsize)
                                        as libc::c_ulong,
                                ) as bfd_vma as bfd_vma;
                        }
                        (*map)
                            .p_vaddr_offset = ((*map).p_paddr)
                            .wrapping_add(hdr_size)
                            .wrapping_div(opb as libc::c_ulong)
                            .wrapping_sub((*matching_lma).lma);
                    }
                    free(sections as *mut libc::c_void);
                } else {
                    if matching_lma.is_null() {
                        matching_lma = suggested_lma;
                    }
                    (*map)
                        .p_paddr = ((*matching_lma).lma)
                        .wrapping_mul(opb as libc::c_ulong);
                    if (*map).includes_phdrs() != 0 {
                        (*map)
                            .p_paddr = ((*map).p_paddr as libc::c_ulong)
                            .wrapping_sub(
                                ((*iehdr).e_phnum).wrapping_mul((*iehdr).e_phentsize)
                                    as libc::c_ulong,
                            ) as bfd_vma as bfd_vma;
                        phdr_adjust_num = (*iehdr).e_phnum;
                        phdr_adjust_seg = map;
                    }
                    if (*map).includes_filehdr() != 0 {
                        let mut align: bfd_vma = (1 as libc::c_int as bfd_vma)
                            << (*matching_lma).alignment_power;
                        (*map)
                            .p_paddr = ((*map).p_paddr as libc::c_ulong)
                            .wrapping_sub((*iehdr).e_ehsize as libc::c_ulong) as bfd_vma
                            as bfd_vma;
                        if (*segment).p_align != 0 as libc::c_int as libc::c_ulong
                            && (*segment).p_align < align
                        {
                            align = (*segment).p_align;
                        }
                        (*map).p_paddr
                            &= align.wrapping_mul(opb as libc::c_ulong).wrapping_neg();
                    }
                    isec = 0 as libc::c_int as libc::c_uint;
                    let mut current_block_171: u64;
                    loop {
                        (*map).count = 0 as libc::c_int as libc::c_uint;
                        suggested_lma = 0 as *mut asection;
                        j_0 = 0 as libc::c_int as libc::c_uint;
                        loop {
                            if !(j_0 < section_count) {
                                current_block_171 = 14358540534591340610;
                                break;
                            }
                            section = *sections.offset(j_0 as isize);
                            if !section.is_null() {
                                output_section = (*section).output_section;
                                if output_section.is_null() {
                                    bfd_assert(
                                        b"elf.c\0" as *const u8 as *const libc::c_char,
                                        7355 as libc::c_int,
                                    );
                                }
                                if ((*output_section).lma)
                                    .wrapping_mul(opb as libc::c_ulong) >= (*map).p_paddr
                                    && ((*output_section).lma)
                                        .wrapping_add(
                                            (if (*output_section).flags
                                                & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                                    as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                                || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                            {
                                                (*output_section).size
                                            } else {
                                                0 as libc::c_int as libc::c_ulong
                                            })
                                                .wrapping_div(opb as libc::c_ulong),
                                        ) >= (*output_section).lma
                                    && ((*output_section).lma)
                                        .wrapping_mul(opb as libc::c_ulong)
                                        .wrapping_add(
                                            if (*output_section).flags
                                                & (0x100 as libc::c_int | 0x400 as libc::c_int)
                                                    as libc::c_uint != 0x400 as libc::c_int as libc::c_uint
                                                || (*segment).p_type == 7 as libc::c_int as libc::c_ulong
                                            {
                                                (*output_section).size
                                            } else {
                                                0 as libc::c_int as libc::c_ulong
                                            },
                                        )
                                        <= ((*map).p_paddr)
                                            .wrapping_add(
                                                if (*segment).p_memsz > (*segment).p_filesz {
                                                    (*segment).p_memsz
                                                } else {
                                                    (*segment).p_filesz
                                                },
                                            )
                                    || (*segment).p_type == 4 as libc::c_int as libc::c_ulong
                                        && (*((*section).used_by_bfd as *mut bfd_elf_section_data))
                                            .this_hdr
                                            .sh_type == 7 as libc::c_int as libc::c_uint
                                        && (*section).filepos as bfd_vma >= (*segment).p_offset
                                        && ((*section).filepos as bfd_vma)
                                            .wrapping_add((*section).size)
                                            <= ((*segment).p_offset).wrapping_add((*segment).p_filesz)
                                        && bfd_get_format(ibfd) as libc::c_uint
                                            == bfd_core as libc::c_int as libc::c_uint
                                        && (*section).vma == 0 as libc::c_int as libc::c_ulong
                                        && (*section).lma == 0 as libc::c_int as libc::c_ulong
                                {
                                    if (*map).count == 0 as libc::c_int as libc::c_uint {
                                        if ((*map).p_paddr)
                                            .wrapping_add(
                                                (if (*map).includes_filehdr() as libc::c_int != 0 {
                                                    (*iehdr).e_ehsize
                                                } else {
                                                    0 as libc::c_int as libc::c_uint
                                                }) as libc::c_ulong,
                                            )
                                            .wrapping_add(
                                                (if (*map).includes_phdrs() as libc::c_int != 0 {
                                                    ((*iehdr).e_phnum).wrapping_mul((*iehdr).e_phentsize)
                                                } else {
                                                    0 as libc::c_int as libc::c_uint
                                                }) as libc::c_ulong,
                                            )
                                            .wrapping_add(
                                                (1 as libc::c_int as bfd_vma)
                                                    << ((*output_section).alignment_power).wrapping_mul(opb),
                                            )
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                            & ((1 as libc::c_int as bfd_vma)
                                                << ((*output_section).alignment_power).wrapping_mul(opb))
                                                .wrapping_neg()
                                            != ((*output_section).lma)
                                                .wrapping_mul(opb as libc::c_ulong)
                                        {
                                            current_block_171 = 13027754535998998722;
                                            break;
                                        }
                                        current_block_171 = 9255187738567101705;
                                    } else {
                                        let mut prev_sec: *mut asection = 0 as *mut asection;
                                        prev_sec = *((*map).sections)
                                            .as_mut_ptr()
                                            .offset(
                                                ((*map).count)
                                                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                                            );
                                        if (if ((*prev_sec).lma)
                                            .wrapping_add((*prev_sec).size)
                                            .wrapping_add(maxpagesize)
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                            >= ((*prev_sec).lma).wrapping_add((*prev_sec).size)
                                        {
                                            ((*prev_sec).lma)
                                                .wrapping_add((*prev_sec).size)
                                                .wrapping_add(
                                                    maxpagesize.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                                )
                                                & !maxpagesize
                                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                        } else {
                                            !(0 as libc::c_int as bfd_vma)
                                        })
                                            < (if ((*output_section).lma)
                                                .wrapping_add(maxpagesize)
                                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                                >= (*output_section).lma
                                            {
                                                ((*output_section).lma)
                                                    .wrapping_add(
                                                        maxpagesize.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                                                    )
                                                    & !maxpagesize
                                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                            } else {
                                                !(0 as libc::c_int as bfd_vma)
                                            })
                                            || ((*prev_sec).lma).wrapping_add((*prev_sec).size)
                                                > (*output_section).lma
                                        {
                                            if suggested_lma.is_null() {
                                                suggested_lma = output_section;
                                            }
                                            current_block_171 = 13932507243822716336;
                                        } else {
                                            current_block_171 = 9255187738567101705;
                                        }
                                    }
                                    match current_block_171 {
                                        13932507243822716336 => {}
                                        _ => {
                                            let fresh69 = (*map).count;
                                            (*map).count = ((*map).count).wrapping_add(1);
                                            let ref mut fresh70 = *((*map).sections)
                                                .as_mut_ptr()
                                                .offset(fresh69 as isize);
                                            *fresh70 = output_section;
                                            isec = isec.wrapping_add(1);
                                            isec;
                                            let ref mut fresh71 = *sections.offset(j_0 as isize);
                                            *fresh71 = 0 as *mut asection;
                                            if (*segment).p_type == 1 as libc::c_int as libc::c_ulong {
                                                (*section)
                                                    .set_segment_mark(1 as libc::c_int as libc::c_uint);
                                            }
                                        }
                                    }
                                } else if suggested_lma.is_null() {
                                    suggested_lma = output_section;
                                }
                            }
                            j_0 = j_0.wrapping_add(1);
                            j_0;
                        }
                        match current_block_171 {
                            13027754535998998722 => {
                                bfd_set_error(bfd_error_sorry);
                                free(sections as *mut libc::c_void);
                                return 0 as libc::c_int != 0;
                            }
                            _ => {
                                *pointer_to_map = map;
                                pointer_to_map = &mut (*map).next;
                                if isec < section_count {
                                    amt = (::core::mem::size_of::<elf_segment_map>()
                                        as libc::c_ulong)
                                        .wrapping_sub(
                                            ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                        );
                                    amt = (amt as libc::c_ulong)
                                        .wrapping_add(
                                            (section_count as libc::c_ulong)
                                                .wrapping_mul(
                                                    ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                                                ),
                                        ) as size_t as size_t;
                                    map = bfd_zalloc(obfd, amt) as *mut elf_segment_map;
                                    if map.is_null() {
                                        free(sections as *mut libc::c_void);
                                        return 0 as libc::c_int != 0;
                                    }
                                    (*map).next = 0 as *mut elf_segment_map;
                                    (*map).p_type = (*segment).p_type;
                                    (*map).p_flags = (*segment).p_flags;
                                    (*map).set_p_flags_valid(1 as libc::c_int as libc::c_uint);
                                    (*map)
                                        .p_paddr = ((*suggested_lma).lma)
                                        .wrapping_mul(opb as libc::c_ulong);
                                    (*map).set_p_paddr_valid(p_paddr_valid as libc::c_uint);
                                    (*map)
                                        .set_includes_filehdr(0 as libc::c_int as libc::c_uint);
                                    (*map).set_includes_phdrs(0 as libc::c_int as libc::c_uint);
                                }
                                if !(isec < section_count) {
                                    break;
                                }
                            }
                        }
                    }
                    free(sections as *mut libc::c_void);
                }
            }
        }
        i = i.wrapping_add(1);
        i;
        segment = segment.offset(1);
        segment;
    }
    (*(*(*obfd).tdata.elf_obj_data).o).seg_map = map_first;
    if !phdr_adjust_seg.is_null() {
        let mut count: libc::c_uint = 0;
        count = 0 as libc::c_int as libc::c_uint;
        map = map_first;
        while !map.is_null() {
            count = count.wrapping_add(1);
            count;
            map = (*map).next;
        }
        if count > phdr_adjust_num {
            (*phdr_adjust_seg)
                .p_paddr = ((*phdr_adjust_seg).p_paddr as libc::c_ulong)
                .wrapping_sub(
                    count
                        .wrapping_sub(phdr_adjust_num)
                        .wrapping_mul((*iehdr).e_phentsize) as libc::c_ulong,
                ) as bfd_vma as bfd_vma;
        }
        map = map_first;
        while !map.is_null() {
            if (*map).p_type == 6 as libc::c_int as libc::c_ulong {
                let mut adjust: bfd_vma = (if (*phdr_adjust_seg).includes_filehdr()
                    as libc::c_int != 0
                {
                    (*iehdr).e_ehsize
                } else {
                    0 as libc::c_int as libc::c_uint
                }) as bfd_vma;
                (*map).p_paddr = ((*phdr_adjust_seg).p_paddr).wrapping_add(adjust);
                break;
            } else {
                map = (*map).next;
            }
        }
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn copy_elf_program_header(
    mut ibfd: *mut bfd,
    mut obfd: *mut bfd,
) -> bool {
    let mut iehdr: *mut Elf_Internal_Ehdr = 0 as *mut Elf_Internal_Ehdr;
    let mut map: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut map_first: *mut elf_segment_map = 0 as *mut elf_segment_map;
    let mut pointer_to_map: *mut *mut elf_segment_map = 0 as *mut *mut elf_segment_map;
    let mut segment: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
    let mut i: libc::c_uint = 0;
    let mut num_segments: libc::c_uint = 0;
    let mut phdr_included: bool = 0 as libc::c_int != 0;
    let mut p_paddr_valid: bool = false;
    let mut opb: libc::c_uint = bfd_octets_per_byte(ibfd, 0 as *const asection);
    iehdr = ((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr();
    map_first = 0 as *mut elf_segment_map;
    pointer_to_map = &mut map_first;
    p_paddr_valid = 0 as libc::c_int != 0;
    num_segments = (*((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum;
    i = 0 as libc::c_int as libc::c_uint;
    segment = (*(*ibfd).tdata.elf_obj_data).phdr;
    while i < num_segments {
        if (*segment).p_paddr != 0 as libc::c_int as libc::c_ulong {
            p_paddr_valid = 1 as libc::c_int != 0;
            break;
        } else {
            i = i.wrapping_add(1);
            i;
            segment = segment.offset(1);
            segment;
        }
    }
    i = 0 as libc::c_int as libc::c_uint;
    segment = (*(*ibfd).tdata.elf_obj_data).phdr;
    while i < num_segments {
        let mut section: *mut asection = 0 as *mut asection;
        let mut section_count: libc::c_uint = 0;
        let mut amt: size_t = 0;
        let mut this_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut first_section: *mut asection = 0 as *mut asection;
        let mut lowest_section: *mut asection = 0 as *mut asection;
        section = (*ibfd).sections;
        section_count = 0 as libc::c_int as libc::c_uint;
        while !section.is_null() {
            this_hdr = &mut (*((*section).used_by_bfd as *mut bfd_elf_section_data))
                .this_hdr;
            if ((*this_hdr).sh_flags
                & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                != 0 as libc::c_int as libc::c_ulong
                && ((*segment).p_type == 7 as libc::c_int as libc::c_ulong
                    || (*segment).p_type
                        == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                            as libc::c_ulong
                    || (*segment).p_type == 1 as libc::c_int as libc::c_ulong)
                || (*this_hdr).sh_flags
                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                    == 0 as libc::c_int as libc::c_ulong
                    && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                    && (*segment).p_type != 6 as libc::c_int as libc::c_ulong)
                && !((*this_hdr).sh_flags
                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                    == 0 as libc::c_int as libc::c_ulong
                    && ((*segment).p_type == 1 as libc::c_int as libc::c_ulong
                        || (*segment).p_type == 2 as libc::c_int as libc::c_ulong
                        || (*segment).p_type
                            == (0x60000000 as libc::c_int + 0x474e550 as libc::c_int)
                                as libc::c_ulong
                        || (*segment).p_type
                            == (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                                as libc::c_ulong
                        || (*segment).p_type
                            == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                as libc::c_ulong
                        || (*segment).p_type
                            >= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int)
                                as libc::c_ulong
                            && (*segment).p_type
                                <= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int
                                    + 4096 as libc::c_int - 1 as libc::c_int) as libc::c_ulong))
                && ((*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                    || (*this_hdr).sh_offset as bfd_vma >= (*segment).p_offset
                        && (0 as libc::c_int == 0
                            || ((*this_hdr).sh_offset as libc::c_ulong)
                                .wrapping_sub((*segment).p_offset)
                                <= ((*segment).p_filesz)
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                        && ((*this_hdr).sh_offset as libc::c_ulong)
                            .wrapping_sub((*segment).p_offset)
                            .wrapping_add(
                                if (*this_hdr).sh_flags
                                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                    && (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                    && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                {
                                    0 as libc::c_int as libc::c_ulong
                                } else {
                                    (*this_hdr).sh_size
                                },
                            ) <= (*segment).p_filesz)
                && (1 as libc::c_int == 0
                    || (*this_hdr).sh_flags
                        & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                        == 0 as libc::c_int as libc::c_ulong
                    || (*this_hdr).sh_addr >= (*segment).p_vaddr
                        && (0 as libc::c_int == 0
                            || ((*this_hdr).sh_addr).wrapping_sub((*segment).p_vaddr)
                                <= ((*segment).p_memsz)
                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                        && ((*this_hdr).sh_addr)
                            .wrapping_sub((*segment).p_vaddr)
                            .wrapping_add(
                                if (*this_hdr).sh_flags
                                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                    != 0 as libc::c_int as libc::c_ulong
                                    && (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                    && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                {
                                    0 as libc::c_int as libc::c_ulong
                                } else {
                                    (*this_hdr).sh_size
                                },
                            ) <= (*segment).p_memsz)
                && ((*segment).p_type != 2 as libc::c_int as libc::c_ulong
                    && (*segment).p_type != 4 as libc::c_int as libc::c_ulong
                    || (*this_hdr).sh_size != 0 as libc::c_int as libc::c_ulong
                    || (*segment).p_memsz == 0 as libc::c_int as libc::c_ulong
                    || ((*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                        || (*this_hdr).sh_offset as bfd_vma > (*segment).p_offset
                            && ((*this_hdr).sh_offset as libc::c_ulong)
                                .wrapping_sub((*segment).p_offset) < (*segment).p_filesz)
                        && ((*this_hdr).sh_flags
                            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                            == 0 as libc::c_int as libc::c_ulong
                            || (*this_hdr).sh_addr > (*segment).p_vaddr
                                && ((*this_hdr).sh_addr).wrapping_sub((*segment).p_vaddr)
                                    < (*segment).p_memsz))
            {
                if first_section.is_null() {
                    first_section = section;
                }
                section_count = section_count.wrapping_add(1);
                section_count;
            }
            section = (*section).next;
        }
        amt = (::core::mem::size_of::<elf_segment_map>() as libc::c_ulong)
            .wrapping_sub(::core::mem::size_of::<*mut asection>() as libc::c_ulong);
        amt = (amt as libc::c_ulong)
            .wrapping_add(
                (section_count as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut asection>() as libc::c_ulong,
                    ),
            ) as size_t as size_t;
        map = bfd_zalloc(obfd, amt) as *mut elf_segment_map;
        if map.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*map).next = 0 as *mut elf_segment_map;
        (*map).p_type = (*segment).p_type;
        (*map).p_flags = (*segment).p_flags;
        (*map).set_p_flags_valid(1 as libc::c_int as libc::c_uint);
        (*map).p_paddr = (*segment).p_paddr;
        (*map).set_p_paddr_valid(p_paddr_valid as libc::c_uint);
        (*map).p_align = (*segment).p_align;
        (*map).set_p_align_valid(1 as libc::c_int as libc::c_uint);
        (*map).p_vaddr_offset = 0 as libc::c_int as bfd_vma;
        if (*map).p_type
            == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int) as libc::c_ulong
            || (*map).p_type
                == (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                    as libc::c_ulong
        {
            (*map).p_size = (*segment).p_memsz;
            (*map).set_p_size_valid(1 as libc::c_int as libc::c_uint);
        }
        (*map)
            .set_includes_filehdr(
                ((*segment).p_offset == 0 as libc::c_int as libc::c_ulong
                    && (*segment).p_filesz >= (*iehdr).e_ehsize as libc::c_ulong)
                    as libc::c_int as libc::c_uint,
            );
        (*map).set_includes_phdrs(0 as libc::c_int as libc::c_uint);
        if !phdr_included || (*segment).p_type != 1 as libc::c_int as libc::c_ulong {
            (*map)
                .set_includes_phdrs(
                    ((*segment).p_offset <= (*iehdr).e_phoff
                        && ((*segment).p_offset).wrapping_add((*segment).p_filesz)
                            >= ((*iehdr).e_phoff)
                                .wrapping_add(
                                    ((*iehdr).e_phnum).wrapping_mul((*iehdr).e_phentsize)
                                        as libc::c_ulong,
                                )) as libc::c_int as libc::c_uint,
                );
            if (*segment).p_type == 1 as libc::c_int as libc::c_ulong
                && (*map).includes_phdrs() as libc::c_int != 0
            {
                phdr_included = 1 as libc::c_int != 0;
            }
        }
        lowest_section = 0 as *mut asection;
        if section_count != 0 as libc::c_int as libc::c_uint {
            let mut isec: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            section = first_section;
            while !section.is_null() {
                this_hdr = &mut (*((*section).used_by_bfd as *mut bfd_elf_section_data))
                    .this_hdr;
                if ((*this_hdr).sh_flags
                    & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                    && ((*segment).p_type == 7 as libc::c_int as libc::c_ulong
                        || (*segment).p_type
                            == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                as libc::c_ulong
                        || (*segment).p_type == 1 as libc::c_int as libc::c_ulong)
                    || (*this_hdr).sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        == 0 as libc::c_int as libc::c_ulong
                        && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                        && (*segment).p_type != 6 as libc::c_int as libc::c_ulong)
                    && !((*this_hdr).sh_flags
                        & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                        == 0 as libc::c_int as libc::c_ulong
                        && ((*segment).p_type == 1 as libc::c_int as libc::c_ulong
                            || (*segment).p_type == 2 as libc::c_int as libc::c_ulong
                            || (*segment).p_type
                                == (0x60000000 as libc::c_int + 0x474e550 as libc::c_int)
                                    as libc::c_ulong
                            || (*segment).p_type
                                == (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                                    as libc::c_ulong
                            || (*segment).p_type
                                == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                    as libc::c_ulong
                            || (*segment).p_type
                                >= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int)
                                    as libc::c_ulong
                                && (*segment).p_type
                                    <= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int
                                        + 4096 as libc::c_int - 1 as libc::c_int) as libc::c_ulong))
                    && ((*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                        || (*this_hdr).sh_offset as bfd_vma >= (*segment).p_offset
                            && (0 as libc::c_int == 0
                                || ((*this_hdr).sh_offset as libc::c_ulong)
                                    .wrapping_sub((*segment).p_offset)
                                    <= ((*segment).p_filesz)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            && ((*this_hdr).sh_offset as libc::c_ulong)
                                .wrapping_sub((*segment).p_offset)
                                .wrapping_add(
                                    if (*this_hdr).sh_flags
                                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                        != 0 as libc::c_int as libc::c_ulong
                                        && (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                        && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                    {
                                        0 as libc::c_int as libc::c_ulong
                                    } else {
                                        (*this_hdr).sh_size
                                    },
                                ) <= (*segment).p_filesz)
                    && (1 as libc::c_int == 0
                        || (*this_hdr).sh_flags
                            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                            == 0 as libc::c_int as libc::c_ulong
                        || (*this_hdr).sh_addr >= (*segment).p_vaddr
                            && (0 as libc::c_int == 0
                                || ((*this_hdr).sh_addr).wrapping_sub((*segment).p_vaddr)
                                    <= ((*segment).p_memsz)
                                        .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                            && ((*this_hdr).sh_addr)
                                .wrapping_sub((*segment).p_vaddr)
                                .wrapping_add(
                                    if (*this_hdr).sh_flags
                                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                        != 0 as libc::c_int as libc::c_ulong
                                        && (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                        && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                    {
                                        0 as libc::c_int as libc::c_ulong
                                    } else {
                                        (*this_hdr).sh_size
                                    },
                                ) <= (*segment).p_memsz)
                    && ((*segment).p_type != 2 as libc::c_int as libc::c_ulong
                        && (*segment).p_type != 4 as libc::c_int as libc::c_ulong
                        || (*this_hdr).sh_size != 0 as libc::c_int as libc::c_ulong
                        || (*segment).p_memsz == 0 as libc::c_int as libc::c_ulong
                        || ((*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                            || (*this_hdr).sh_offset as bfd_vma > (*segment).p_offset
                                && ((*this_hdr).sh_offset as libc::c_ulong)
                                    .wrapping_sub((*segment).p_offset) < (*segment).p_filesz)
                            && ((*this_hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                == 0 as libc::c_int as libc::c_ulong
                                || (*this_hdr).sh_addr > (*segment).p_vaddr
                                    && ((*this_hdr).sh_addr).wrapping_sub((*segment).p_vaddr)
                                        < (*segment).p_memsz))
                {
                    let fresh72 = isec;
                    isec = isec.wrapping_add(1);
                    let ref mut fresh73 = *((*map).sections)
                        .as_mut_ptr()
                        .offset(fresh72 as isize);
                    *fresh73 = (*section).output_section;
                    if (*section).flags & 0x1 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        let mut seg_off: bfd_vma = 0;
                        if lowest_section.is_null()
                            || (*section).lma < (*lowest_section).lma
                        {
                            lowest_section = section;
                        }
                        if (*section).flags & 0x2 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        {
                            seg_off = ((*this_hdr).sh_offset as libc::c_ulong)
                                .wrapping_sub((*segment).p_offset);
                        } else {
                            seg_off = ((*this_hdr).sh_addr)
                                .wrapping_sub((*segment).p_vaddr);
                        }
                        if ((*section).lma)
                            .wrapping_mul(opb as libc::c_ulong)
                            .wrapping_sub((*segment).p_paddr) != seg_off
                        {
                            (*map).set_p_paddr_valid(0 as libc::c_int as libc::c_uint);
                        }
                    }
                    if isec == section_count {
                        break;
                    }
                }
                section = (*section).next;
            }
        }
        if section_count == 0 as libc::c_int as libc::c_uint {
            (*map)
                .p_vaddr_offset = ((*segment).p_vaddr)
                .wrapping_div(opb as libc::c_ulong);
        } else if (*map).p_paddr_valid() != 0 {
            let mut hdr_size: bfd_vma = 0 as libc::c_int as bfd_vma;
            if (*map).includes_filehdr() != 0 {
                hdr_size = (*iehdr).e_ehsize as bfd_vma;
            }
            if (*map).includes_phdrs() != 0 {
                hdr_size = (hdr_size as libc::c_ulong)
                    .wrapping_add(
                        ((*iehdr).e_phnum).wrapping_mul((*iehdr).e_phentsize)
                            as libc::c_ulong,
                    ) as bfd_vma as bfd_vma;
            }
            (*map)
                .p_vaddr_offset = ((*map).p_paddr)
                .wrapping_add(hdr_size)
                .wrapping_div(opb as libc::c_ulong)
                .wrapping_sub(
                    if !lowest_section.is_null() {
                        (*lowest_section).lma
                    } else {
                        0 as libc::c_int as libc::c_ulong
                    },
                );
        }
        (*map).count = section_count;
        *pointer_to_map = map;
        pointer_to_map = &mut (*map).next;
        i = i.wrapping_add(1);
        i;
        segment = segment.offset(1);
        segment;
    }
    (*(*(*obfd).tdata.elf_obj_data).o).seg_map = map_first;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn copy_private_bfd_data(
    mut ibfd: *mut bfd,
    mut obfd: *mut bfd,
) -> bool {
    let mut current_block: u64;
    let mut maxpagesize: bfd_vma = 0;
    if bfd_get_flavour(ibfd) as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || bfd_get_flavour(obfd) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    if ((*(*ibfd).tdata.elf_obj_data).phdr).is_null() {
        return 1 as libc::c_int != 0;
    }
    if (*ibfd).xvec == (*obfd).xvec {
        let mut segment: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
        let mut section: *mut asection = 0 as *mut asection;
        let mut osec: *mut asection = 0 as *mut asection;
        let mut i: libc::c_uint = 0;
        let mut num_segments: libc::c_uint = 0;
        let mut this_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
        bed = (*(*ibfd).xvec).backend_data as *const elf_backend_data;
        if !((*bed).want_p_paddr_set_to_zero() != 0) {
            section = (*obfd).sections;
            while !section.is_null() {
                (*section).set_segment_mark(0 as libc::c_int as libc::c_uint);
                section = (*section).next;
            }
            num_segments = (*((*(*ibfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
                .e_phnum;
            i = 0 as libc::c_int as libc::c_uint;
            segment = (*(*ibfd).tdata.elf_obj_data).phdr;
            's_56: loop {
                if !(i < num_segments) {
                    current_block = 11042950489265723346;
                    break;
                }
                if (*segment).p_paddr == 0 as libc::c_int as libc::c_ulong
                    && (*segment).p_memsz == 0 as libc::c_int as libc::c_ulong
                    && ((*segment).p_type == 3 as libc::c_int as libc::c_ulong
                        || (*segment).p_type == 2 as libc::c_int as libc::c_ulong)
                {
                    current_block = 6589464889165941666;
                    break;
                }
                section = (*ibfd).sections;
                while !section.is_null() {
                    osec = (*section).output_section;
                    if !osec.is_null() {
                        (*osec).set_segment_mark(1 as libc::c_int as libc::c_uint);
                    }
                    this_hdr = &mut (*((*section).used_by_bfd
                        as *mut bfd_elf_section_data))
                        .this_hdr;
                    if ((*this_hdr).sh_flags
                        & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                        != 0 as libc::c_int as libc::c_ulong
                        && ((*segment).p_type == 7 as libc::c_int as libc::c_ulong
                            || (*segment).p_type
                                == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                    as libc::c_ulong
                            || (*segment).p_type == 1 as libc::c_int as libc::c_ulong)
                        || (*this_hdr).sh_flags
                            & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                            == 0 as libc::c_int as libc::c_ulong
                            && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                            && (*segment).p_type != 6 as libc::c_int as libc::c_ulong)
                        && !((*this_hdr).sh_flags
                            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                            == 0 as libc::c_int as libc::c_ulong
                            && ((*segment).p_type == 1 as libc::c_int as libc::c_ulong
                                || (*segment).p_type == 2 as libc::c_int as libc::c_ulong
                                || (*segment).p_type
                                    == (0x60000000 as libc::c_int + 0x474e550 as libc::c_int)
                                        as libc::c_ulong
                                || (*segment).p_type
                                    == (0x60000000 as libc::c_int + 0x474e551 as libc::c_int)
                                        as libc::c_ulong
                                || (*segment).p_type
                                    == (0x60000000 as libc::c_int + 0x474e552 as libc::c_int)
                                        as libc::c_ulong
                                || (*segment).p_type
                                    >= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int)
                                        as libc::c_ulong
                                    && (*segment).p_type
                                        <= (0x60000000 as libc::c_int + 0x474e555 as libc::c_int
                                            + 4096 as libc::c_int - 1 as libc::c_int) as libc::c_ulong))
                        && ((*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                            || (*this_hdr).sh_offset as bfd_vma >= (*segment).p_offset
                                && (0 as libc::c_int == 0
                                    || ((*this_hdr).sh_offset as libc::c_ulong)
                                        .wrapping_sub((*segment).p_offset)
                                        <= ((*segment).p_filesz)
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                                && ((*this_hdr).sh_offset as libc::c_ulong)
                                    .wrapping_sub((*segment).p_offset)
                                    .wrapping_add(
                                        if (*this_hdr).sh_flags
                                            & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                            != 0 as libc::c_int as libc::c_ulong
                                            && (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                            && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                        {
                                            0 as libc::c_int as libc::c_ulong
                                        } else {
                                            (*this_hdr).sh_size
                                        },
                                    ) <= (*segment).p_filesz)
                        && (1 as libc::c_int == 0
                            || (*this_hdr).sh_flags
                                & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                == 0 as libc::c_int as libc::c_ulong
                            || (*this_hdr).sh_addr >= (*segment).p_vaddr
                                && (0 as libc::c_int == 0
                                    || ((*this_hdr).sh_addr).wrapping_sub((*segment).p_vaddr)
                                        <= ((*segment).p_memsz)
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong))
                                && ((*this_hdr).sh_addr)
                                    .wrapping_sub((*segment).p_vaddr)
                                    .wrapping_add(
                                        if (*this_hdr).sh_flags
                                            & ((1 as libc::c_int) << 10 as libc::c_int) as libc::c_ulong
                                            != 0 as libc::c_int as libc::c_ulong
                                            && (*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                            && (*segment).p_type != 7 as libc::c_int as libc::c_ulong
                                        {
                                            0 as libc::c_int as libc::c_ulong
                                        } else {
                                            (*this_hdr).sh_size
                                        },
                                    ) <= (*segment).p_memsz)
                        && ((*segment).p_type != 2 as libc::c_int as libc::c_ulong
                            && (*segment).p_type != 4 as libc::c_int as libc::c_ulong
                            || (*this_hdr).sh_size != 0 as libc::c_int as libc::c_ulong
                            || (*segment).p_memsz == 0 as libc::c_int as libc::c_ulong
                            || ((*this_hdr).sh_type == 8 as libc::c_int as libc::c_uint
                                || (*this_hdr).sh_offset as bfd_vma > (*segment).p_offset
                                    && ((*this_hdr).sh_offset as libc::c_ulong)
                                        .wrapping_sub((*segment).p_offset) < (*segment).p_filesz)
                                && ((*this_hdr).sh_flags
                                    & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_ulong
                                    == 0 as libc::c_int as libc::c_ulong
                                    || (*this_hdr).sh_addr > (*segment).p_vaddr
                                        && ((*this_hdr).sh_addr).wrapping_sub((*segment).p_vaddr)
                                            < (*segment).p_memsz))
                    {
                        if osec.is_null() || (*section).flags != (*osec).flags
                            || (*section).lma != (*osec).lma
                            || (*section).vma != (*osec).vma
                            || (*section).size != (*osec).size
                            || (*section).rawsize != (*osec).rawsize
                            || (*section).alignment_power != (*osec).alignment_power
                        {
                            current_block = 6589464889165941666;
                            break 's_56;
                        }
                    }
                    section = (*section).next;
                }
                i = i.wrapping_add(1);
                i;
                segment = segment.offset(1);
                segment;
            }
            match current_block {
                6589464889165941666 => {}
                _ => {
                    section = (*obfd).sections;
                    loop {
                        if section.is_null() {
                            current_block = 4068382217303356765;
                            break;
                        }
                        if (*section).segment_mark() == 0 {
                            current_block = 6589464889165941666;
                            break;
                        }
                        (*section).set_segment_mark(0 as libc::c_int as libc::c_uint);
                        section = (*section).next;
                    }
                    match current_block {
                        6589464889165941666 => {}
                        _ => return copy_elf_program_header(ibfd, obfd),
                    }
                }
            }
        }
    }
    maxpagesize = 0 as libc::c_int as bfd_vma;
    if (*ibfd).xvec == (*obfd).xvec {
        let mut segment_0: *mut Elf_Internal_Phdr = 0 as *mut Elf_Internal_Phdr;
        let mut i_0: libc::c_uint = 0;
        let mut num_segments_0: libc::c_uint = (*((*(*ibfd).tdata.elf_obj_data)
            .elf_header)
            .as_mut_ptr())
            .e_phnum;
        i_0 = 0 as libc::c_int as libc::c_uint;
        segment_0 = (*(*ibfd).tdata.elf_obj_data).phdr;
        while i_0 < num_segments_0 {
            if (*segment_0).p_type == 1 as libc::c_int as libc::c_ulong
                && maxpagesize < (*segment_0).p_align
            {
                if (*segment_0).p_align
                    > (1 as libc::c_int as bfd_vma)
                        << (::core::mem::size_of::<bfd_vma>() as libc::c_ulong)
                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB: warning: segment alignment of %#lx is too large\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        ibfd,
                        (*segment_0).p_align,
                    );
                } else {
                    maxpagesize = (*segment_0).p_align;
                }
            }
            i_0 = i_0.wrapping_add(1);
            i_0;
            segment_0 = segment_0.offset(1);
            segment_0;
        }
    }
    if maxpagesize == 0 as libc::c_int as libc::c_ulong {
        maxpagesize = (*((*(*obfd).xvec).backend_data as *const elf_backend_data))
            .maxpagesize;
    }
    return rewrite_elf_program_header(ibfd, obfd, maxpagesize);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_init_private_section_data(
    mut ibfd: *mut bfd,
    mut isec: *mut asection,
    mut obfd: *mut bfd,
    mut osec: *mut asection,
    mut link_info: *mut bfd_link_info,
) -> bool {
    let mut ihdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut ohdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut final_link: bool = !link_info.is_null()
        && !((*link_info).type_0() as libc::c_int == type_relocatable as libc::c_int);
    if (*(*ibfd).xvec).flavour as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || (*(*obfd).xvec).flavour as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    if ((*osec).used_by_bfd as *mut bfd_elf_section_data).is_null() {
        bfd_assert(b"elf.c\0" as *const u8 as *const libc::c_char, 7810 as libc::c_int);
    }
    if (*((*osec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
        == 1 as libc::c_int as libc::c_uint
        || (*((*osec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
            == 7 as libc::c_int as libc::c_uint
        || (*((*osec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
            == 8 as libc::c_int as libc::c_uint
    {
        (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_type = 0 as libc::c_int as libc::c_uint;
    }
    if (*((*osec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
        == 0 as libc::c_int as libc::c_uint
        && ((*osec).flags == (*isec).flags
            || final_link as libc::c_int != 0
                && ((*osec).flags ^ (*isec).flags)
                    & !(0x20000 as libc::c_int | 0xc0000 as libc::c_int
                        | 0x4 as libc::c_int) as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint)
    {
        (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_type = (*((*isec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_type;
    }
    (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
        .this_hdr
        .sh_flags = (*((*isec).used_by_bfd as *mut bfd_elf_section_data))
        .this_hdr
        .sh_flags
        & (0xff00000 as libc::c_int as libc::c_uint | 0xf0000000 as libc::c_uint)
            as libc::c_ulong;
    if (*(*ibfd).tdata.elf_obj_data).has_gnu_osabi() as libc::c_int
        & elf_gnu_osabi_mbind as libc::c_int != 0 as libc::c_int
        && (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_flags
            & 0x1000000 as libc::c_int as libc::c_ulong != 0
    {
        (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_info = (*((*isec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_info;
    }
    if (link_info.is_null() || (*link_info).resolve_section_groups() == 0)
        && (((*((*isec).used_by_bfd as *mut bfd_elf_section_data)).sec_group).is_null()
            || (*(*((*isec).used_by_bfd as *mut bfd_elf_section_data)).sec_group).flags
                & 0x100000 as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint)
    {
        if (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_flags
            & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong != 0
        {
            let ref mut fresh74 = (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
                .this_hdr
                .sh_flags;
            *fresh74 |= ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong;
        }
        let ref mut fresh75 = (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
            .next_in_group;
        *fresh75 = (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
        (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
            .group = (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).group;
    }
    if !final_link
        && (*ibfd).flags & 0x8000 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
    {
        let ref mut fresh76 = (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
            .this_hdr
            .sh_flags;
        *fresh76
            |= (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_flags
                & ((1 as libc::c_int) << 11 as libc::c_int) as libc::c_ulong;
    }
    ihdr = &mut (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr;
    if (*ihdr).sh_flags & ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_ulong
        != 0 as libc::c_int as libc::c_ulong
    {
        ohdr = &mut (*((*osec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr;
        (*ohdr).sh_flags |= ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_ulong;
        let ref mut fresh77 = (*((*osec).used_by_bfd as *mut bfd_elf_section_data))
            .linked_to;
        *fresh77 = (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).linked_to;
    }
    (*osec).set_use_rela_p((*isec).use_rela_p());
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_copy_private_section_data(
    mut ibfd: *mut bfd,
    mut isec: *mut asection,
    mut obfd: *mut bfd,
    mut osec: *mut asection,
) -> bool {
    let mut ihdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut ohdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    if (*(*ibfd).xvec).flavour as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || (*(*obfd).xvec).flavour as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    ihdr = &mut (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr;
    ohdr = &mut (*((*osec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr;
    (*ohdr).sh_entsize = (*ihdr).sh_entsize;
    if (*ihdr).sh_type == 2 as libc::c_int as libc::c_uint
        || (*ihdr).sh_type == 11 as libc::c_int as libc::c_uint
        || (*ihdr).sh_type == 0x6ffffffe as libc::c_int as libc::c_uint
        || (*ihdr).sh_type == 0x6ffffffd as libc::c_int as libc::c_uint
    {
        (*ohdr).sh_info = (*ihdr).sh_info;
    }
    return _bfd_elf_init_private_section_data(
        ibfd,
        isec,
        obfd,
        osec,
        0 as *mut bfd_link_info,
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_fixup_group_sections(
    mut ibfd: *mut bfd,
    mut discarded: *mut asection,
) -> bool {
    let mut isec: *mut asection = 0 as *mut asection;
    isec = (*ibfd).sections;
    while !isec.is_null() {
        if (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
            == 17 as libc::c_int as libc::c_uint
        {
            let mut first: *mut asection = (*((*isec).used_by_bfd
                as *mut bfd_elf_section_data))
                .next_in_group;
            let mut s: *mut asection = first;
            let mut removed: bfd_size_type = 0 as libc::c_int as bfd_size_type;
            while !s.is_null() {
                if (*s).output_section != discarded
                    && (*isec).output_section == discarded
                {
                    let ref mut fresh78 = (*((*(*s).output_section).used_by_bfd
                        as *mut bfd_elf_section_data))
                        .this_hdr
                        .sh_flags;
                    *fresh78
                        &= !((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong;
                    let ref mut fresh79 = (*((*(*s).output_section).used_by_bfd
                        as *mut bfd_elf_section_data))
                        .group
                        .name;
                    *fresh79 = 0 as *const libc::c_char;
                } else {
                    let mut elf_sec: *mut bfd_elf_section_data = (*s).used_by_bfd
                        as *mut bfd_elf_section_data;
                    if (*s).output_section == discarded
                        && (*isec).output_section != discarded
                    {
                        removed = (removed as libc::c_ulong)
                            .wrapping_add(4 as libc::c_int as libc::c_ulong)
                            as bfd_size_type as bfd_size_type;
                        if !((*elf_sec).rel.hdr).is_null()
                            && (*(*elf_sec).rel.hdr).sh_flags
                                & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                        {
                            removed = (removed as libc::c_ulong)
                                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                                as bfd_size_type as bfd_size_type;
                        }
                        if !((*elf_sec).rela.hdr).is_null()
                            && (*(*elf_sec).rela.hdr).sh_flags
                                & ((1 as libc::c_int) << 9 as libc::c_int) as libc::c_ulong
                                != 0 as libc::c_int as libc::c_ulong
                        {
                            removed = (removed as libc::c_ulong)
                                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                                as bfd_size_type as bfd_size_type;
                        }
                    } else {
                        if !((*elf_sec).rel.hdr).is_null()
                            && (*(*elf_sec).rel.hdr).sh_size
                                == 0 as libc::c_int as libc::c_ulong
                        {
                            removed = (removed as libc::c_ulong)
                                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                                as bfd_size_type as bfd_size_type;
                        }
                        if !((*elf_sec).rela.hdr).is_null()
                            && (*(*elf_sec).rela.hdr).sh_size
                                == 0 as libc::c_int as libc::c_ulong
                        {
                            removed = (removed as libc::c_ulong)
                                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                                as bfd_size_type as bfd_size_type;
                        }
                    }
                }
                s = (*((*s).used_by_bfd as *mut bfd_elf_section_data)).next_in_group;
                if s == first {
                    break;
                }
            }
            if removed != 0 as libc::c_int as libc::c_ulong {
                if !discarded.is_null() {
                    if (*isec).rawsize == 0 as libc::c_int as libc::c_ulong {
                        (*isec).rawsize = (*isec).size;
                    }
                    (*isec).size = ((*isec).rawsize).wrapping_sub(removed);
                    if (*isec).size <= 4 as libc::c_int as libc::c_ulong {
                        (*isec).size = 0 as libc::c_int as bfd_size_type;
                        (*isec).flags |= 0x8000 as libc::c_int as libc::c_uint;
                    }
                } else {
                    (*(*isec).output_section)
                        .size = ((*(*isec).output_section).size as libc::c_ulong)
                        .wrapping_sub(removed) as bfd_size_type as bfd_size_type;
                    if (*(*isec).output_section).size
                        <= 4 as libc::c_int as libc::c_ulong
                    {
                        (*(*isec).output_section)
                            .size = 0 as libc::c_int as bfd_size_type;
                        (*(*isec).output_section).flags
                            |= 0x8000 as libc::c_int as libc::c_uint;
                    }
                }
            }
        }
        isec = (*isec).next;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_copy_private_header_data(
    mut ibfd: *mut bfd,
    mut obfd: *mut bfd,
) -> bool {
    if bfd_get_flavour(ibfd) as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || bfd_get_flavour(obfd) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    if ((*(*(*obfd).tdata.elf_obj_data).o).seg_map).is_null()
        && !((*(*ibfd).tdata.elf_obj_data).phdr).is_null()
    {
        if !copy_private_bfd_data(ibfd, obfd) {
            return 0 as libc::c_int != 0;
        }
    }
    return _bfd_elf_fixup_group_sections(ibfd, 0 as *mut asection);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_copy_private_symbol_data(
    mut ibfd: *mut bfd,
    mut isymarg: *mut asymbol,
    mut obfd: *mut bfd,
    mut osymarg: *mut asymbol,
) -> bool {
    let mut isym: *mut elf_symbol_type = 0 as *mut elf_symbol_type;
    let mut osym: *mut elf_symbol_type = 0 as *mut elf_symbol_type;
    if bfd_get_flavour(ibfd) as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
        || bfd_get_flavour(obfd) as libc::c_uint
            != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    isym = if (*isymarg).flags
        & ((1 as libc::c_int) << 21 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint && !((*isymarg).the_bfd).is_null()
        && (*(*(*isymarg).the_bfd).xvec).flavour as libc::c_uint
            == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && !((*(*isymarg).the_bfd).tdata.elf_obj_data).is_null()
    {
        isymarg as *mut elf_symbol_type
    } else {
        0 as *mut elf_symbol_type
    };
    osym = if (*osymarg).flags
        & ((1 as libc::c_int) << 21 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint && !((*osymarg).the_bfd).is_null()
        && (*(*(*osymarg).the_bfd).xvec).flavour as libc::c_uint
            == bfd_target_elf_flavour as libc::c_int as libc::c_uint
        && !((*(*osymarg).the_bfd).tdata.elf_obj_data).is_null()
    {
        osymarg as *mut elf_symbol_type
    } else {
        0 as *mut elf_symbol_type
    };
    if !isym.is_null()
        && (*isym).internal_elf_sym.st_shndx != 0 as libc::c_int as libc::c_uint
        && !osym.is_null()
        && bfd_is_abs_section((*isym).symbol.section) as libc::c_int != 0
    {
        let mut shndx: libc::c_uint = 0;
        shndx = (*isym).internal_elf_sym.st_shndx;
        if shndx == (*(*ibfd).tdata.elf_obj_data).symtab_section {
            shndx = (0xc1 as libc::c_uint)
                .wrapping_neg()
                .wrapping_add(1 as libc::c_int as libc::c_uint);
        } else if shndx == (*(*ibfd).tdata.elf_obj_data).dynsymtab_section {
            shndx = (0xc1 as libc::c_uint)
                .wrapping_neg()
                .wrapping_add(2 as libc::c_int as libc::c_uint);
        } else if shndx == (*(*(*ibfd).tdata.elf_obj_data).o).strtab_section {
            shndx = (0xc1 as libc::c_uint)
                .wrapping_neg()
                .wrapping_add(3 as libc::c_int as libc::c_uint);
        } else if shndx == (*(*(*ibfd).tdata.elf_obj_data).o).shstrtab_section {
            shndx = (0xc1 as libc::c_uint)
                .wrapping_neg()
                .wrapping_add(4 as libc::c_int as libc::c_uint);
        } else if !(find_section_in_list(
            shndx,
            (*(*ibfd).tdata.elf_obj_data).symtab_shndx_list,
        ))
            .is_null()
        {
            shndx = (0xc1 as libc::c_uint)
                .wrapping_neg()
                .wrapping_add(5 as libc::c_int as libc::c_uint);
        }
        (*osym).internal_elf_sym.st_shndx = shndx;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn swap_out_syms(
    mut abfd: *mut bfd,
    mut sttp: *mut *mut elf_strtab_hash,
    mut relocatable_p: libc::c_int,
    mut info: *mut bfd_link_info,
) -> bool {
    let mut current_block: u64;
    let mut bed: *const elf_backend_data = 0 as *const elf_backend_data;
    let mut symcount: libc::c_uint = 0;
    let mut syms: *mut *mut asymbol = 0 as *mut *mut asymbol;
    let mut stt: *mut elf_strtab_hash = 0 as *mut elf_strtab_hash;
    let mut symtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symtab_shndx_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symstrtab_hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut symstrtab: *mut elf_sym_strtab = 0 as *mut elf_sym_strtab;
    let mut outbound_syms: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut outbound_shndx: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut outbound_syms_index: libc::c_ulong = 0;
    let mut outbound_shndx_index: libc::c_ulong = 0;
    let mut idx: libc::c_uint = 0;
    let mut num_locals: libc::c_uint = 0;
    let mut amt: size_t = 0;
    let mut name_local_sections: bool = false;
    if !elf_map_symbols(abfd, &mut num_locals) {
        return 0 as libc::c_int != 0;
    }
    stt = _bfd_elf_strtab_init();
    if stt.is_null() {
        return 0 as libc::c_int != 0;
    }
    bed = (*(*abfd).xvec).backend_data as *const elf_backend_data;
    symcount = bfd_get_symcount(abfd);
    symtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    (*symtab_hdr).sh_type = 2 as libc::c_int as libc::c_uint;
    (*symtab_hdr).sh_entsize = (*(*bed).s).sizeof_sym as bfd_size_type;
    (*symtab_hdr)
        .sh_size = ((*symtab_hdr).sh_entsize)
        .wrapping_mul(
            symcount.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,
        );
    (*symtab_hdr).sh_info = num_locals.wrapping_add(1 as libc::c_int as libc::c_uint);
    (*symtab_hdr)
        .sh_addralign = (1 as libc::c_int as bfd_vma)
        << (*(*bed).s).log_file_align as libc::c_int;
    symstrtab_hdr = &mut (*(*abfd).tdata.elf_obj_data).strtab_hdr;
    (*symstrtab_hdr).sh_type = 3 as libc::c_int as libc::c_uint;
    amt = symcount.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t;
    amt = (amt as libc::c_ulong)
        .wrapping_mul(::core::mem::size_of::<elf_sym_strtab>() as libc::c_ulong)
        as size_t as size_t;
    if ::core::mem::size_of::<elf_sym_strtab>() as libc::c_ulong
        != 0 as libc::c_int as libc::c_ulong
        && amt.wrapping_div(::core::mem::size_of::<elf_sym_strtab>() as libc::c_ulong)
            != symcount.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong
        || {
            symstrtab = bfd_malloc(amt) as *mut elf_sym_strtab;
            symstrtab.is_null()
        }
    {
        bfd_set_error(bfd_error_no_memory);
        _bfd_elf_strtab_free(stt);
        return 0 as libc::c_int != 0;
    }
    amt = symcount.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t;
    amt = (amt as libc::c_ulong).wrapping_mul((*(*bed).s).sizeof_sym as libc::c_ulong)
        as size_t as size_t;
    if (*(*bed).s).sizeof_sym as libc::c_int != 0 as libc::c_int
        && amt.wrapping_div((*(*bed).s).sizeof_sym as libc::c_ulong)
            != symcount.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong
        || {
            outbound_syms = bfd_alloc(abfd, amt) as *mut bfd_byte;
            outbound_syms.is_null()
        }
    {
        current_block = 16372929619563452436;
    } else {
        (*symtab_hdr).contents = outbound_syms;
        outbound_syms_index = 0 as libc::c_int as libc::c_ulong;
        outbound_shndx = 0 as *mut bfd_byte;
        outbound_shndx_index = 0 as libc::c_int as libc::c_ulong;
        if !((*(*abfd).tdata.elf_obj_data).symtab_shndx_list).is_null() {
            symtab_shndx_hdr = &mut (*(*(*abfd).tdata.elf_obj_data).symtab_shndx_list)
                .hdr;
            if (*symtab_shndx_hdr).sh_name != 0 as libc::c_int as libc::c_uint {
                amt = symcount.wrapping_add(1 as libc::c_int as libc::c_uint) as size_t;
                amt = (amt as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<Elf_External_Sym_Shndx>() as libc::c_ulong,
                    ) as size_t as size_t;
                if ::core::mem::size_of::<Elf_External_Sym_Shndx>() as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                    && amt
                        .wrapping_div(
                            ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                as libc::c_ulong,
                        )
                        != symcount.wrapping_add(1 as libc::c_int as libc::c_uint)
                            as libc::c_ulong
                {
                    current_block = 16372929619563452436;
                } else {
                    outbound_shndx = bfd_zalloc(abfd, amt) as *mut bfd_byte;
                    if outbound_shndx.is_null() {
                        current_block = 665008807415244226;
                    } else {
                        (*symtab_shndx_hdr).contents = outbound_shndx;
                        (*symtab_shndx_hdr).sh_type = 18 as libc::c_int as libc::c_uint;
                        (*symtab_shndx_hdr).sh_size = amt;
                        (*symtab_shndx_hdr)
                            .sh_addralign = ::core::mem::size_of::<
                            Elf_External_Sym_Shndx,
                        >() as libc::c_ulong;
                        (*symtab_shndx_hdr)
                            .sh_entsize = ::core::mem::size_of::<
                            Elf_External_Sym_Shndx,
                        >() as libc::c_ulong;
                        current_block = 9853141518545631134;
                    }
                }
            } else {
                current_block = 9853141518545631134;
            }
        } else {
            current_block = 9853141518545631134;
        }
        match current_block {
            16372929619563452436 => {}
            665008807415244226 => {}
            _ => {
                let mut sym: Elf_Internal_Sym = Elf_Internal_Sym {
                    st_value: 0,
                    st_size: 0,
                    st_name: 0,
                    st_info: 0,
                    st_other: 0,
                    st_target_internal: 0,
                    st_shndx: 0,
                };
                sym.st_name = 0 as libc::c_int as libc::c_ulong;
                sym.st_value = 0 as libc::c_int as bfd_vma;
                sym.st_size = 0 as libc::c_int as bfd_vma;
                sym.st_info = 0 as libc::c_int as libc::c_uchar;
                sym.st_other = 0 as libc::c_int as libc::c_uchar;
                sym.st_shndx = 0 as libc::c_int as libc::c_uint;
                sym.st_target_internal = 0 as libc::c_int as libc::c_uchar;
                (*symstrtab.offset(0 as libc::c_int as isize)).sym = sym;
                (*symstrtab.offset(0 as libc::c_int as isize))
                    .dest_index = outbound_syms_index;
                (*symstrtab.offset(0 as libc::c_int as isize))
                    .destshndx_index = outbound_shndx_index;
                outbound_syms_index = outbound_syms_index.wrapping_add(1);
                outbound_syms_index;
                if !outbound_shndx.is_null() {
                    outbound_shndx_index = outbound_shndx_index.wrapping_add(1);
                    outbound_shndx_index;
                }
                name_local_sections = ((*bed).elf_backend_name_local_section_symbols)
                    .is_some()
                    && ((*bed).elf_backend_name_local_section_symbols)
                        .expect("non-null function pointer")(abfd) as libc::c_int != 0;
                syms = bfd_get_outsymbols(abfd);
                idx = 0 as libc::c_int as libc::c_uint;
                loop {
                    if !(idx < symcount) {
                        current_block = 5260680050201874961;
                        break;
                    }
                    let mut sym_0: Elf_Internal_Sym = Elf_Internal_Sym {
                        st_value: 0,
                        st_size: 0,
                        st_name: 0,
                        st_info: 0,
                        st_other: 0,
                        st_target_internal: 0,
                        st_shndx: 0,
                    };
                    let mut value: bfd_vma = (**syms.offset(idx as isize)).value;
                    let mut type_ptr: *mut elf_symbol_type = 0 as *mut elf_symbol_type;
                    let mut flags: flagword = (**syms.offset(idx as isize)).flags;
                    let mut type_0: libc::c_int = 0;
                    if !name_local_sections
                        && flags
                            & ((1 as libc::c_int) << 8 as libc::c_int
                                | (1 as libc::c_int) << 1 as libc::c_int) as libc::c_uint
                            == ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint
                    {
                        sym_0.st_name = -(1 as libc::c_int) as libc::c_ulong;
                    } else {
                        sym_0
                            .st_name = _bfd_elf_strtab_add(
                            stt,
                            (**syms.offset(idx as isize)).name,
                            0 as libc::c_int != 0,
                        );
                        if sym_0.st_name == -(1 as libc::c_int) as libc::c_ulong {
                            current_block = 665008807415244226;
                            break;
                        }
                    }
                    type_ptr = if (**syms.offset(idx as isize)).flags
                        & ((1 as libc::c_int) << 21 as libc::c_int) as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                        && !((**syms.offset(idx as isize)).the_bfd).is_null()
                        && (*(*(**syms.offset(idx as isize)).the_bfd).xvec).flavour
                            as libc::c_uint
                            == bfd_target_elf_flavour as libc::c_int as libc::c_uint
                        && !((*(**syms.offset(idx as isize)).the_bfd).tdata.elf_obj_data)
                            .is_null()
                    {
                        *syms.offset(idx as isize) as *mut elf_symbol_type
                    } else {
                        0 as *mut elf_symbol_type
                    };
                    if flags & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                        && bfd_is_com_section((**syms.offset(idx as isize)).section)
                            as libc::c_int != 0
                    {
                        sym_0.st_size = value;
                        if type_ptr.is_null()
                            || (*type_ptr).internal_elf_sym.st_value
                                == 0 as libc::c_int as libc::c_ulong
                        {
                            sym_0
                                .st_value = (if value >= 16 as libc::c_int as libc::c_ulong
                            {
                                16 as libc::c_int
                            } else {
                                (1 as libc::c_int) << bfd_log2(value)
                            }) as bfd_vma;
                        } else {
                            sym_0.st_value = (*type_ptr).internal_elf_sym.st_value;
                        }
                        sym_0
                            .st_shndx = _bfd_elf_section_from_bfd_section(
                            abfd,
                            (**syms.offset(idx as isize)).section,
                        );
                    } else {
                        let mut sec: *mut asection = (**syms.offset(idx as isize))
                            .section;
                        let mut shndx: libc::c_uint = 0;
                        if !((*sec).output_section).is_null() {
                            value = (value as libc::c_ulong)
                                .wrapping_add((*sec).output_offset) as bfd_vma as bfd_vma;
                            sec = (*sec).output_section;
                        }
                        if relocatable_p == 0 {
                            value = (value as libc::c_ulong).wrapping_add((*sec).vma)
                                as bfd_vma as bfd_vma;
                        }
                        sym_0.st_value = value;
                        sym_0
                            .st_size = if !type_ptr.is_null() {
                            (*type_ptr).internal_elf_sym.st_size
                        } else {
                            0 as libc::c_int as libc::c_ulong
                        };
                        if bfd_is_abs_section(sec) as libc::c_int != 0
                            && !type_ptr.is_null()
                            && (*type_ptr).internal_elf_sym.st_shndx
                                != 0 as libc::c_int as libc::c_uint
                        {
                            shndx = (*type_ptr).internal_elf_sym.st_shndx;
                            match shndx {
                                4294967104 => {
                                    shndx = (*(*abfd).tdata.elf_obj_data).symtab_section;
                                }
                                4294967105 => {
                                    shndx = (*(*abfd).tdata.elf_obj_data).dynsymtab_section;
                                }
                                4294967106 => {
                                    shndx = (*(*(*abfd).tdata.elf_obj_data).o).strtab_section;
                                }
                                4294967107 => {
                                    shndx = (*(*(*abfd).tdata.elf_obj_data).o).shstrtab_section;
                                }
                                4294967108 => {
                                    if !((*(*abfd).tdata.elf_obj_data).symtab_shndx_list)
                                        .is_null()
                                    {
                                        shndx = (*(*(*abfd).tdata.elf_obj_data).symtab_shndx_list)
                                            .ndx;
                                    }
                                }
                                4294967282 | 4294967281 => {
                                    shndx = (0xf as libc::c_uint).wrapping_neg();
                                }
                                _ => {
                                    if shndx >= (0x100 as libc::c_uint).wrapping_neg()
                                        && shndx <= (0xc1 as libc::c_uint).wrapping_neg()
                                    {
                                        if ((*bed).symbol_section_index).is_some() {
                                            shndx = ((*bed).symbol_section_index)
                                                .expect("non-null function pointer")(abfd, type_ptr);
                                        }
                                    } else {
                                        if shndx > (0xc1 as libc::c_uint).wrapping_neg()
                                            && shndx < (0x1 as libc::c_uint).wrapping_neg()
                                        {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB: Unable to handle section index %x in ELF symbol.  Using ABS instead.\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                shndx,
                                            );
                                        }
                                        shndx = (0xf as libc::c_uint).wrapping_neg();
                                    }
                                }
                            }
                        } else {
                            shndx = _bfd_elf_section_from_bfd_section(abfd, sec);
                            if shndx == (0x101 as libc::c_uint).wrapping_neg() {
                                let mut sec2: *mut asection = 0 as *mut asection;
                                sec2 = bfd_get_section_by_name(abfd, (*sec).name);
                                if !sec2.is_null() {
                                    shndx = _bfd_elf_section_from_bfd_section(abfd, sec2);
                                }
                                if shndx == (0x101 as libc::c_uint).wrapping_neg() {
                                    _bfd_error_handler(
                                        dcgettext(
                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                            b"unable to find equivalent output section for symbol '%s' from section '%s'\0"
                                                as *const u8 as *const libc::c_char,
                                            5 as libc::c_int,
                                        ),
                                        if !((**syms.offset(idx as isize)).name).is_null() {
                                            (**syms.offset(idx as isize)).name
                                        } else {
                                            b"<Local sym>\0" as *const u8 as *const libc::c_char
                                        },
                                        (*sec).name,
                                    );
                                    bfd_set_error(bfd_error_invalid_operation);
                                    current_block = 665008807415244226;
                                    break;
                                }
                            }
                        }
                        sym_0.st_shndx = shndx;
                    }
                    if flags & ((1 as libc::c_int) << 18 as libc::c_int) as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        type_0 = 6 as libc::c_int;
                    } else if flags
                        & ((1 as libc::c_int) << 22 as libc::c_int) as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        type_0 = 10 as libc::c_int;
                    } else if flags
                        & ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        type_0 = 2 as libc::c_int;
                    } else if flags
                        & ((1 as libc::c_int) << 16 as libc::c_int) as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        type_0 = 1 as libc::c_int;
                    } else if flags
                        & ((1 as libc::c_int) << 19 as libc::c_int) as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        type_0 = 8 as libc::c_int;
                    } else if flags
                        & ((1 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        type_0 = 9 as libc::c_int;
                    } else {
                        type_0 = 0 as libc::c_int;
                    }
                    if (*(**syms.offset(idx as isize)).section).flags
                        & 0x400 as libc::c_int as libc::c_uint != 0
                    {
                        type_0 = 6 as libc::c_int;
                    }
                    if !type_ptr.is_null()
                        && ((*bed).elf_backend_get_symbol_type).is_some()
                    {
                        type_0 = (Some(
                            ((*bed).elf_backend_get_symbol_type)
                                .expect("non-null function pointer"),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(&mut (*type_ptr).internal_elf_sym, type_0);
                    }
                    if flags & ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint
                        != 0
                    {
                        if flags
                            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_uint
                            != 0
                        {
                            sym_0
                                .st_info = (((1 as libc::c_int) << 4 as libc::c_int)
                                + (3 as libc::c_int & 0xf as libc::c_int)) as libc::c_uchar;
                        } else {
                            sym_0
                                .st_info = (((0 as libc::c_int) << 4 as libc::c_int)
                                + (3 as libc::c_int & 0xf as libc::c_int)) as libc::c_uchar;
                        }
                    } else if bfd_is_com_section((**syms.offset(idx as isize)).section) {
                        if type_0 != 6 as libc::c_int {
                            if (*abfd).flags & 0x40000 as libc::c_int as libc::c_uint
                                != 0
                            {
                                type_0 = if (*abfd).flags
                                    & 0x80000 as libc::c_int as libc::c_uint != 0
                                {
                                    5 as libc::c_int
                                } else {
                                    1 as libc::c_int
                                };
                            } else {
                                type_0 = if flags
                                    & ((1 as libc::c_int) << 6 as libc::c_int) as libc::c_uint
                                    != 0 as libc::c_int as libc::c_uint
                                {
                                    5 as libc::c_int
                                } else {
                                    1 as libc::c_int
                                };
                            }
                        }
                        sym_0
                            .st_info = (((1 as libc::c_int) << 4 as libc::c_int)
                            + (type_0 & 0xf as libc::c_int)) as libc::c_uchar;
                    } else if bfd_is_und_section((**syms.offset(idx as isize)).section) {
                        sym_0
                            .st_info = (((if flags
                            & ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint
                            != 0
                        {
                            2 as libc::c_int
                        } else {
                            1 as libc::c_int
                        }) << 4 as libc::c_int) + (type_0 & 0xf as libc::c_int))
                            as libc::c_uchar;
                    } else if flags
                        & ((1 as libc::c_int) << 14 as libc::c_int) as libc::c_uint != 0
                    {
                        sym_0
                            .st_info = (((0 as libc::c_int) << 4 as libc::c_int)
                            + (4 as libc::c_int & 0xf as libc::c_int)) as libc::c_uchar;
                    } else {
                        let mut bind: libc::c_int = 0 as libc::c_int;
                        if flags
                            & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint
                            != 0
                        {
                            bind = 0 as libc::c_int;
                        } else if flags
                            & ((1 as libc::c_int) << 23 as libc::c_int) as libc::c_uint
                            != 0
                        {
                            bind = 10 as libc::c_int;
                        } else if flags
                            & ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint
                            != 0
                        {
                            bind = 2 as libc::c_int;
                        } else if flags
                            & ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_uint
                            != 0
                        {
                            bind = 1 as libc::c_int;
                        }
                        sym_0
                            .st_info = ((bind << 4 as libc::c_int)
                            + (type_0 & 0xf as libc::c_int)) as libc::c_uchar;
                    }
                    if !type_ptr.is_null() {
                        sym_0.st_other = (*type_ptr).internal_elf_sym.st_other;
                        sym_0
                            .st_target_internal = (*type_ptr)
                            .internal_elf_sym
                            .st_target_internal;
                    } else {
                        sym_0.st_other = 0 as libc::c_int as libc::c_uchar;
                        sym_0.st_target_internal = 0 as libc::c_int as libc::c_uchar;
                    }
                    idx = idx.wrapping_add(1);
                    idx;
                    (*symstrtab.offset(idx as isize)).sym = sym_0;
                    (*symstrtab.offset(idx as isize)).dest_index = outbound_syms_index;
                    (*symstrtab.offset(idx as isize))
                        .destshndx_index = outbound_shndx_index;
                    outbound_syms_index = outbound_syms_index.wrapping_add(1);
                    outbound_syms_index;
                    if !outbound_shndx.is_null() {
                        outbound_shndx_index = outbound_shndx_index.wrapping_add(1);
                        outbound_shndx_index;
                    }
                }
                match current_block {
                    665008807415244226 => {}
                    _ => {
                        _bfd_elf_strtab_finalize(stt);
                        idx = 0 as libc::c_int as libc::c_uint;
                        while idx <= symcount {
                            let mut elfsym: *mut elf_sym_strtab = &mut *symstrtab
                                .offset(idx as isize) as *mut elf_sym_strtab;
                            if (*elfsym).sym.st_name
                                == -(1 as libc::c_int) as libc::c_ulong
                            {
                                (*elfsym).sym.st_name = 0 as libc::c_int as libc::c_ulong;
                            } else {
                                (*elfsym)
                                    .sym
                                    .st_name = _bfd_elf_strtab_offset(
                                    stt,
                                    (*elfsym).sym.st_name,
                                );
                            }
                            if !info.is_null()
                                && ((*(*info).callbacks).ctf_new_symbol).is_some()
                            {
                                ((*(*info).callbacks).ctf_new_symbol)
                                    .expect(
                                        "non-null function pointer",
                                    )((*elfsym).dest_index as libc::c_int, &mut (*elfsym).sym);
                            }
                            ((*(*bed).s).swap_symbol_out)
                                .expect(
                                    "non-null function pointer",
                                )(
                                abfd,
                                &mut (*elfsym).sym,
                                outbound_syms
                                    .offset(
                                        ((*elfsym).dest_index)
                                            .wrapping_mul((*(*bed).s).sizeof_sym as libc::c_ulong)
                                            as isize,
                                    ) as *mut libc::c_void,
                                outbound_shndx
                                    .offset(
                                        ((*elfsym).destshndx_index)
                                            .wrapping_mul(
                                                ::core::mem::size_of::<Elf_External_Sym_Shndx>()
                                                    as libc::c_ulong,
                                            ) as isize,
                                    ) as *mut libc::c_void,
                            );
                            idx = idx.wrapping_add(1);
                            idx;
                        }
                        free(symstrtab as *mut libc::c_void);
                        *sttp = stt;
                        (*symstrtab_hdr).sh_size = _bfd_elf_strtab_size(stt);
                        (*symstrtab_hdr).sh_type = 3 as libc::c_int as libc::c_uint;
                        (*symstrtab_hdr).sh_flags = (*bed).elf_strtab_flags;
                        (*symstrtab_hdr).sh_addr = 0 as libc::c_int as bfd_vma;
                        (*symstrtab_hdr).sh_entsize = 0 as libc::c_int as bfd_size_type;
                        (*symstrtab_hdr).sh_link = 0 as libc::c_int as libc::c_uint;
                        (*symstrtab_hdr).sh_info = 0 as libc::c_int as libc::c_uint;
                        (*symstrtab_hdr).sh_addralign = 1 as libc::c_int as bfd_vma;
                        return 1 as libc::c_int != 0;
                    }
                }
            }
        }
    }
    match current_block {
        16372929619563452436 => {
            bfd_set_error(bfd_error_no_memory);
        }
        _ => {}
    }
    free(symstrtab as *mut libc::c_void);
    _bfd_elf_strtab_free(stt);
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_symtab_upper_bound(
    mut abfd: *mut bfd,
) -> libc::c_long {
    let mut symcount: bfd_size_type = 0;
    let mut symtab_size: libc::c_long = 0;
    let mut hdr: *mut Elf_Internal_Shdr = &mut (*(*abfd).tdata.elf_obj_data).symtab_hdr;
    symcount = ((*hdr).sh_size)
        .wrapping_div(
            (*(*((*(*abfd).xvec).backend_data as *const elf_backend_data)).s).sizeof_sym
                as libc::c_ulong,
        );
    if symcount
        > (9223372036854775807 as libc::c_long as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<*mut asymbol>() as libc::c_ulong)
    {
        bfd_set_error(bfd_error_file_too_big);
        return -(1 as libc::c_int) as libc::c_long;
    }
    symtab_size = symcount
        .wrapping_mul(::core::mem::size_of::<*mut asymbol>() as libc::c_ulong)
        as libc::c_long;
    if symcount == 0 as libc::c_int as libc::c_ulong {
        symtab_size = ::core::mem::size_of::<*mut asymbol>() as libc::c_ulong
            as libc::c_long;
    } else if !((*abfd).direction() as libc::c_int == write_direction as libc::c_int
        || (*abfd).direction() as libc::c_int == both_direction as libc::c_int)
    {
        let mut filesize: ufile_ptr = bfd_get_file_size(abfd);
        if filesize != 0 as libc::c_int as libc::c_ulong
            && symtab_size as libc::c_ulong > filesize
        {
            bfd_set_error(bfd_error_file_truncated);
            return -(1 as libc::c_int) as libc::c_long;
        }
    }
    return symtab_size;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_dynamic_symtab_upper_bound(
    mut abfd: *mut bfd,
) -> libc::c_long {
    let mut symcount: bfd_size_type = 0;
    let mut symtab_size: libc::c_long = 0;
    let mut hdr: *mut Elf_Internal_Shdr = &mut (*(*abfd).tdata.elf_obj_data)
        .dynsymtab_hdr;
    if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
        == 0 as libc::c_int as libc::c_uint
    {
        bfd_set_error(bfd_error_invalid_operation);
        return -(1 as libc::c_int) as libc::c_long;
    }
    symcount = ((*hdr).sh_size)
        .wrapping_div(
            (*(*((*(*abfd).xvec).backend_data as *const elf_backend_data)).s).sizeof_sym
                as libc::c_ulong,
        );
    if symcount
        > (9223372036854775807 as libc::c_long as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<*mut asymbol>() as libc::c_ulong)
    {
        bfd_set_error(bfd_error_file_too_big);
        return -(1 as libc::c_int) as libc::c_long;
    }
    symtab_size = symcount
        .wrapping_mul(::core::mem::size_of::<*mut asymbol>() as libc::c_ulong)
        as libc::c_long;
    if symcount == 0 as libc::c_int as libc::c_ulong {
        symtab_size = ::core::mem::size_of::<*mut asymbol>() as libc::c_ulong
            as libc::c_long;
    } else if !((*abfd).direction() as libc::c_int == write_direction as libc::c_int
        || (*abfd).direction() as libc::c_int == both_direction as libc::c_int)
    {
        let mut filesize: ufile_ptr = bfd_get_file_size(abfd);
        if filesize != 0 as libc::c_int as libc::c_ulong
            && symtab_size as libc::c_ulong > filesize
        {
            bfd_set_error(bfd_error_file_truncated);
            return -(1 as libc::c_int) as libc::c_long;
        }
    }
    return symtab_size;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_reloc_upper_bound(
    mut abfd: *mut bfd,
    mut asect: sec_ptr,
) -> libc::c_long {
    if (*asect).reloc_count != 0 as libc::c_int as libc::c_uint
        && !((*abfd).direction() as libc::c_int == write_direction as libc::c_int
            || (*abfd).direction() as libc::c_int == both_direction as libc::c_int)
    {
        let mut d: *mut bfd_elf_section_data = (*asect).used_by_bfd
            as *mut bfd_elf_section_data;
        let mut rel_hdr: *mut Elf_Internal_Shdr = &mut (*d).this_hdr;
        let mut ext_rel_size: bfd_size_type = (*rel_hdr).sh_size;
        let mut filesize: ufile_ptr = bfd_get_file_size(abfd);
        if filesize != 0 as libc::c_int as libc::c_ulong && ext_rel_size > filesize {
            bfd_set_error(bfd_error_file_truncated);
            return -(1 as libc::c_int) as libc::c_long;
        }
    }
    return (((*asect).reloc_count).wrapping_add(1 as libc::c_int as libc::c_uint)
        as libc::c_ulong)
        .wrapping_mul(::core::mem::size_of::<*mut arelent>() as libc::c_ulong)
        as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_canonicalize_reloc(
    mut abfd: *mut bfd,
    mut section: sec_ptr,
    mut relptr: *mut *mut arelent,
    mut symbols: *mut *mut asymbol,
) -> libc::c_long {
    let mut tblptr: *mut arelent = 0 as *mut arelent;
    let mut i: libc::c_uint = 0;
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    if !((*(*bed).s).slurp_reloc_table)
        .expect(
            "non-null function pointer",
        )(abfd, section, symbols, 0 as libc::c_int != 0)
    {
        return -(1 as libc::c_int) as libc::c_long;
    }
    tblptr = (*section).relocation;
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*section).reloc_count {
        let fresh80 = tblptr;
        tblptr = tblptr.offset(1);
        let fresh81 = relptr;
        relptr = relptr.offset(1);
        *fresh81 = fresh80;
        i = i.wrapping_add(1);
        i;
    }
    *relptr = 0 as *mut arelent;
    return (*section).reloc_count as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_canonicalize_symtab(
    mut abfd: *mut bfd,
    mut allocation: *mut *mut asymbol,
) -> libc::c_long {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut symcount: libc::c_long = ((*(*bed).s).slurp_symbol_table)
        .expect("non-null function pointer")(abfd, allocation, 0 as libc::c_int != 0);
    if symcount >= 0 as libc::c_int as libc::c_long {
        (*abfd).symcount = symcount as libc::c_uint;
    }
    return symcount;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_canonicalize_dynamic_symtab(
    mut abfd: *mut bfd,
    mut allocation: *mut *mut asymbol,
) -> libc::c_long {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut symcount: libc::c_long = ((*(*bed).s).slurp_symbol_table)
        .expect("non-null function pointer")(abfd, allocation, 1 as libc::c_int != 0);
    if symcount >= 0 as libc::c_int as libc::c_long {
        (*abfd).dynsymcount = symcount as libc::c_uint;
    }
    return symcount;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_dynamic_reloc_upper_bound(
    mut abfd: *mut bfd,
) -> libc::c_long {
    let mut count: bfd_size_type = 0;
    let mut ext_rel_size: bfd_size_type = 0;
    let mut s: *mut asection = 0 as *mut asection;
    if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
        == 0 as libc::c_int as libc::c_uint
    {
        bfd_set_error(bfd_error_invalid_operation);
        return -(1 as libc::c_int) as libc::c_long;
    }
    count = 1 as libc::c_int as bfd_size_type;
    ext_rel_size = 0 as libc::c_int as bfd_size_type;
    s = (*abfd).sections;
    while !s.is_null() {
        if (*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_link
            == (*(*abfd).tdata.elf_obj_data).dynsymtab_section
            && ((*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
                == 9 as libc::c_int as libc::c_uint
                || (*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
                    == 4 as libc::c_int as libc::c_uint)
        {
            ext_rel_size = (ext_rel_size as libc::c_ulong).wrapping_add((*s).size)
                as bfd_size_type as bfd_size_type;
            if ext_rel_size < (*s).size {
                bfd_set_error(bfd_error_file_truncated);
                return -(1 as libc::c_int) as libc::c_long;
            }
            count = (count as libc::c_ulong)
                .wrapping_add(
                    ((*s).size)
                        .wrapping_div(
                            (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                                .this_hdr
                                .sh_entsize,
                        ),
                ) as bfd_size_type as bfd_size_type;
            if count
                > (9223372036854775807 as libc::c_long as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<*mut arelent>() as libc::c_ulong,
                    )
            {
                bfd_set_error(bfd_error_file_too_big);
                return -(1 as libc::c_int) as libc::c_long;
            }
        }
        s = (*s).next;
    }
    if count > 1 as libc::c_int as libc::c_ulong
        && !((*abfd).direction() as libc::c_int == write_direction as libc::c_int
            || (*abfd).direction() as libc::c_int == both_direction as libc::c_int)
    {
        let mut filesize: ufile_ptr = bfd_get_file_size(abfd);
        if filesize != 0 as libc::c_int as libc::c_ulong && ext_rel_size > filesize {
            bfd_set_error(bfd_error_file_truncated);
            return -(1 as libc::c_int) as libc::c_long;
        }
    }
    return count.wrapping_mul(::core::mem::size_of::<*mut arelent>() as libc::c_ulong)
        as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_canonicalize_dynamic_reloc(
    mut abfd: *mut bfd,
    mut storage: *mut *mut arelent,
    mut syms: *mut *mut asymbol,
) -> libc::c_long {
    let mut slurp_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut *mut asymbol, bool) -> bool,
    > = None;
    let mut s: *mut asection = 0 as *mut asection;
    let mut ret: libc::c_long = 0;
    if (*(*abfd).tdata.elf_obj_data).dynsymtab_section
        == 0 as libc::c_int as libc::c_uint
    {
        bfd_set_error(bfd_error_invalid_operation);
        return -(1 as libc::c_int) as libc::c_long;
    }
    slurp_relocs = (*(*((*(*abfd).xvec).backend_data as *const elf_backend_data)).s)
        .slurp_reloc_table;
    ret = 0 as libc::c_int as libc::c_long;
    s = (*abfd).sections;
    while !s.is_null() {
        if (*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_link
            == (*(*abfd).tdata.elf_obj_data).dynsymtab_section
            && ((*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
                == 9 as libc::c_int as libc::c_uint
                || (*((*s).used_by_bfd as *mut bfd_elf_section_data)).this_hdr.sh_type
                    == 4 as libc::c_int as libc::c_uint)
        {
            let mut p: *mut arelent = 0 as *mut arelent;
            let mut count: libc::c_long = 0;
            let mut i: libc::c_long = 0;
            if !(Some(slurp_relocs.expect("non-null function pointer")))
                .expect(
                    "non-null function pointer",
                )(abfd, s, syms, 1 as libc::c_int != 0)
            {
                return -(1 as libc::c_int) as libc::c_long;
            }
            count = ((*s).size)
                .wrapping_div(
                    (*((*s).used_by_bfd as *mut bfd_elf_section_data))
                        .this_hdr
                        .sh_entsize,
                ) as libc::c_long;
            p = (*s).relocation;
            i = 0 as libc::c_int as libc::c_long;
            while i < count {
                let fresh82 = p;
                p = p.offset(1);
                let fresh83 = storage;
                storage = storage.offset(1);
                *fresh83 = fresh82;
                i += 1;
                i;
            }
            ret += count;
        }
        s = (*s).next;
    }
    *storage = 0 as *mut arelent;
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_slurp_version_tables(
    mut abfd: *mut bfd,
    mut default_imported_symver: bool,
) -> bool {
    let mut hdr_0: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut everdef: *mut Elf_External_Verdef = 0 as *mut Elf_External_Verdef;
    let mut iverdef: *mut Elf_Internal_Verdef = 0 as *mut Elf_Internal_Verdef;
    let mut iverdefarr: *mut Elf_Internal_Verdef = 0 as *mut Elf_Internal_Verdef;
    let mut iverdefmem: Elf_Internal_Verdef = Elf_Internal_Verdef {
        vd_version: 0,
        vd_flags: 0,
        vd_ndx: 0,
        vd_cnt: 0,
        vd_hash: 0,
        vd_aux: 0,
        vd_next: 0,
        vd_bfd: 0 as *mut bfd,
        vd_nodename: 0 as *const libc::c_char,
        vd_nextdef: 0 as *mut elf_internal_verdef,
        vd_auxptr: 0 as *mut elf_internal_verdaux,
        vd_exp_refno: 0,
    };
    let mut i_0: libc::c_uint = 0;
    let mut maxidx: libc::c_uint = 0;
    let mut contents_end_def: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut contents_end_aux: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut current_block: u64;
    let mut contents: *mut bfd_byte = 0 as *mut bfd_byte;
    let mut freeidx: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut amt: size_t = 0;
    if (*(*abfd).tdata.elf_obj_data).dynverref_section
        != 0 as libc::c_int as libc::c_uint
    {
        let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
        let mut everneed: *mut Elf_External_Verneed = 0 as *mut Elf_External_Verneed;
        let mut iverneed: *mut Elf_Internal_Verneed = 0 as *mut Elf_Internal_Verneed;
        let mut i: libc::c_uint = 0;
        let mut contents_end: *mut bfd_byte = 0 as *mut bfd_byte;
        hdr = &mut (*(*abfd).tdata.elf_obj_data).dynverref_hdr;
        if (*hdr).sh_info == 0 as libc::c_int as libc::c_uint
            || (*hdr).sh_info as libc::c_ulong
                > ((*hdr).sh_size)
                    .wrapping_div(
                        ::core::mem::size_of::<Elf_External_Verneed>() as libc::c_ulong,
                    )
        {
            current_block = 15149481298833619604;
        } else if bfd_seek(abfd, (*hdr).sh_offset, 0 as libc::c_int) != 0 as libc::c_int
        {
            current_block = 66793208124429531;
        } else {
            contents = _bfd_malloc_and_read(abfd, (*hdr).sh_size, (*hdr).sh_size);
            if contents.is_null() {
                current_block = 66793208124429531;
            } else {
                amt = (*hdr).sh_info as size_t;
                amt = (amt as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<Elf_Internal_Verneed>() as libc::c_ulong,
                    ) as size_t as size_t;
                if ::core::mem::size_of::<Elf_Internal_Verneed>() as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                    && amt
                        .wrapping_div(
                            ::core::mem::size_of::<Elf_Internal_Verneed>()
                                as libc::c_ulong,
                        ) != (*hdr).sh_info as libc::c_ulong
                {
                    bfd_set_error(bfd_error_file_too_big);
                    current_block = 66793208124429531;
                } else {
                    (*(*abfd).tdata.elf_obj_data)
                        .verref = bfd_alloc(abfd, amt) as *mut Elf_Internal_Verneed;
                    if ((*(*abfd).tdata.elf_obj_data).verref).is_null() {
                        current_block = 66793208124429531;
                    } else {
                        if !(::core::mem::size_of::<Elf_External_Verneed>()
                            as libc::c_ulong
                            == ::core::mem::size_of::<Elf_External_Vernaux>()
                                as libc::c_ulong)
                        {
                            bfd_assert(
                                b"elf.c\0" as *const u8 as *const libc::c_char,
                                8759 as libc::c_int,
                            );
                        }
                        contents_end = contents
                            .offset((*hdr).sh_size as isize)
                            .offset(
                                -(::core::mem::size_of::<Elf_External_Verneed>()
                                    as libc::c_ulong as isize),
                            );
                        everneed = contents as *mut Elf_External_Verneed;
                        iverneed = (*(*abfd).tdata.elf_obj_data).verref;
                        i = 0 as libc::c_int as libc::c_uint;
                        's_105: loop {
                            if !(i < (*hdr).sh_info) {
                                current_block = 12556861819962772176;
                                break;
                            }
                            let mut evernaux: *mut Elf_External_Vernaux = 0
                                as *mut Elf_External_Vernaux;
                            let mut ivernaux: *mut Elf_Internal_Vernaux = 0
                                as *mut Elf_Internal_Vernaux;
                            let mut j: libc::c_uint = 0;
                            _bfd_elf_swap_verneed_in(abfd, everneed, iverneed);
                            (*iverneed).vn_bfd = abfd;
                            (*iverneed)
                                .vn_filename = bfd_elf_string_from_elf_section(
                                abfd,
                                (*hdr).sh_link,
                                (*iverneed).vn_file as libc::c_uint,
                            );
                            if ((*iverneed).vn_filename).is_null() {
                                current_block = 15149481298833619604;
                                break;
                            }
                            if (*iverneed).vn_cnt as libc::c_int == 0 as libc::c_int {
                                (*iverneed).vn_auxptr = 0 as *mut elf_internal_vernaux;
                            } else {
                                amt = (*iverneed).vn_cnt as size_t;
                                amt = (amt as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<Elf_Internal_Vernaux>()
                                            as libc::c_ulong,
                                    ) as size_t as size_t;
                                if ::core::mem::size_of::<Elf_Internal_Vernaux>()
                                    as libc::c_ulong != 0 as libc::c_int as libc::c_ulong
                                    && amt
                                        .wrapping_div(
                                            ::core::mem::size_of::<Elf_Internal_Vernaux>()
                                                as libc::c_ulong,
                                        ) != (*iverneed).vn_cnt as libc::c_ulong
                                {
                                    bfd_set_error(bfd_error_file_too_big);
                                    current_block = 66793208124429531;
                                    break;
                                } else {
                                    (*iverneed)
                                        .vn_auxptr = bfd_alloc(abfd, amt)
                                        as *mut elf_internal_vernaux;
                                    if ((*iverneed).vn_auxptr).is_null() {
                                        current_block = 66793208124429531;
                                        break;
                                    }
                                }
                            }
                            if (*iverneed).vn_aux
                                > contents_end.offset_from(everneed as *mut bfd_byte)
                                    as libc::c_long as size_t
                            {
                                current_block = 15149481298833619604;
                                break;
                            }
                            evernaux = (everneed as *mut bfd_byte)
                                .offset((*iverneed).vn_aux as isize)
                                as *mut Elf_External_Vernaux;
                            ivernaux = (*iverneed).vn_auxptr;
                            j = 0 as libc::c_int as libc::c_uint;
                            while j < (*iverneed).vn_cnt as libc::c_uint {
                                _bfd_elf_swap_vernaux_in(abfd, evernaux, ivernaux);
                                (*ivernaux)
                                    .vna_nodename = bfd_elf_string_from_elf_section(
                                    abfd,
                                    (*hdr).sh_link,
                                    (*ivernaux).vna_name as libc::c_uint,
                                );
                                if ((*ivernaux).vna_nodename).is_null() {
                                    current_block = 15149481298833619604;
                                    break 's_105;
                                }
                                if (*ivernaux).vna_other as libc::c_uint > freeidx {
                                    freeidx = (*ivernaux).vna_other as libc::c_uint;
                                }
                                (*ivernaux).vna_nextptr = 0 as *mut elf_internal_vernaux;
                                if (*ivernaux).vna_next == 0 as libc::c_int as libc::c_ulong
                                {
                                    (*iverneed)
                                        .vn_cnt = j.wrapping_add(1 as libc::c_int as libc::c_uint)
                                        as libc::c_ushort;
                                    break;
                                } else {
                                    if j.wrapping_add(1 as libc::c_int as libc::c_uint)
                                        < (*iverneed).vn_cnt as libc::c_uint
                                    {
                                        (*ivernaux)
                                            .vna_nextptr = ivernaux.offset(1 as libc::c_int as isize);
                                    }
                                    if (*ivernaux).vna_next
                                        > contents_end.offset_from(evernaux as *mut bfd_byte)
                                            as libc::c_long as size_t
                                    {
                                        current_block = 15149481298833619604;
                                        break 's_105;
                                    }
                                    evernaux = (evernaux as *mut bfd_byte)
                                        .offset((*ivernaux).vna_next as isize)
                                        as *mut Elf_External_Vernaux;
                                    j = j.wrapping_add(1);
                                    j;
                                    ivernaux = ivernaux.offset(1);
                                    ivernaux;
                                }
                            }
                            (*iverneed).vn_nextref = 0 as *mut elf_internal_verneed;
                            if (*iverneed).vn_next == 0 as libc::c_int as libc::c_ulong {
                                current_block = 12556861819962772176;
                                break;
                            }
                            if i.wrapping_add(1 as libc::c_int as libc::c_uint)
                                < (*hdr).sh_info
                            {
                                (*iverneed)
                                    .vn_nextref = iverneed.offset(1 as libc::c_int as isize);
                            }
                            if (*iverneed).vn_next
                                > contents_end.offset_from(everneed as *mut bfd_byte)
                                    as libc::c_long as size_t
                            {
                                current_block = 15149481298833619604;
                                break;
                            }
                            everneed = (everneed as *mut bfd_byte)
                                .offset((*iverneed).vn_next as isize)
                                as *mut Elf_External_Verneed;
                            i = i.wrapping_add(1);
                            i;
                            iverneed = iverneed.offset(1);
                            iverneed;
                        }
                        match current_block {
                            15149481298833619604 => {}
                            66793208124429531 => {}
                            _ => {
                                (*(*abfd).tdata.elf_obj_data).cverrefs = i;
                                free(contents as *mut libc::c_void);
                                contents = 0 as *mut bfd_byte;
                                current_block = 1854459640724737493;
                            }
                        }
                    }
                }
            }
        }
        match current_block {
            1854459640724737493 => {}
            _ => {
                match current_block {
                    15149481298833619604 => {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%pB: .gnu.version_r invalid entry\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            abfd,
                        );
                        bfd_set_error(bfd_error_bad_value);
                    }
                    _ => {}
                }
                (*(*abfd).tdata.elf_obj_data).verref = 0 as *mut Elf_Internal_Verneed;
                (*(*abfd).tdata.elf_obj_data)
                    .cverrefs = 0 as libc::c_int as libc::c_uint;
                current_block = 12232566507951731591;
            }
        }
    } else {
        current_block = 1854459640724737493;
    }
    match current_block {
        1854459640724737493 => {
            if (*(*abfd).tdata.elf_obj_data).dynverdef_section
                != 0 as libc::c_int as libc::c_uint
            {
                hdr_0 = 0 as *mut Elf_Internal_Shdr;
                everdef = 0 as *mut Elf_External_Verdef;
                iverdef = 0 as *mut Elf_Internal_Verdef;
                iverdefarr = 0 as *mut Elf_Internal_Verdef;
                iverdefmem = Elf_Internal_Verdef {
                    vd_version: 0,
                    vd_flags: 0,
                    vd_ndx: 0,
                    vd_cnt: 0,
                    vd_hash: 0,
                    vd_aux: 0,
                    vd_next: 0,
                    vd_bfd: 0 as *mut bfd,
                    vd_nodename: 0 as *const libc::c_char,
                    vd_nextdef: 0 as *mut elf_internal_verdef,
                    vd_auxptr: 0 as *mut elf_internal_verdaux,
                    vd_exp_refno: 0,
                };
                i_0 = 0;
                maxidx = 0;
                contents_end_def = 0 as *mut bfd_byte;
                contents_end_aux = 0 as *mut bfd_byte;
                hdr_0 = &mut (*(*abfd).tdata.elf_obj_data).dynverdef_hdr;
                if (*hdr_0).sh_info == 0 as libc::c_int as libc::c_uint
                    || (*hdr_0).sh_size
                        < ::core::mem::size_of::<Elf_External_Verdef>() as libc::c_ulong
                {
                    current_block = 3132699548715661320;
                } else if bfd_seek(abfd, (*hdr_0).sh_offset, 0 as libc::c_int)
                    != 0 as libc::c_int
                {
                    current_block = 7132826034772071206;
                } else {
                    contents = _bfd_malloc_and_read(
                        abfd,
                        (*hdr_0).sh_size,
                        (*hdr_0).sh_size,
                    );
                    if contents.is_null() {
                        current_block = 7132826034772071206;
                    } else {
                        if !(::core::mem::size_of::<Elf_External_Verdef>()
                            as libc::c_ulong
                            >= ::core::mem::size_of::<Elf_External_Verdaux>()
                                as libc::c_ulong)
                        {
                            bfd_assert(
                                b"elf.c\0" as *const u8 as *const libc::c_char,
                                8883 as libc::c_int,
                            );
                        }
                        contents_end_def = contents
                            .offset((*hdr_0).sh_size as isize)
                            .offset(
                                -(::core::mem::size_of::<Elf_External_Verdef>()
                                    as libc::c_ulong as isize),
                            );
                        contents_end_aux = contents
                            .offset((*hdr_0).sh_size as isize)
                            .offset(
                                -(::core::mem::size_of::<Elf_External_Verdaux>()
                                    as libc::c_ulong as isize),
                            );
                        everdef = contents as *mut Elf_External_Verdef;
                        maxidx = 0 as libc::c_int as libc::c_uint;
                        i_0 = 0 as libc::c_int as libc::c_uint;
                        loop {
                            if !(i_0 < (*hdr_0).sh_info) {
                                current_block = 2754258178208450300;
                                break;
                            }
                            _bfd_elf_swap_verdef_in(abfd, everdef, &mut iverdefmem);
                            if iverdefmem.vd_ndx as libc::c_uint
                                & 0x7fff as libc::c_int as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                            {
                                current_block = 3132699548715661320;
                                break;
                            }
                            if iverdefmem.vd_ndx as libc::c_uint
                                & 0x7fff as libc::c_int as libc::c_uint > maxidx
                            {
                                maxidx = iverdefmem.vd_ndx as libc::c_uint
                                    & 0x7fff as libc::c_int as libc::c_uint;
                            }
                            if iverdefmem.vd_next == 0 as libc::c_int as libc::c_ulong {
                                current_block = 2754258178208450300;
                                break;
                            }
                            if iverdefmem.vd_next
                                > contents_end_def.offset_from(everdef as *mut bfd_byte)
                                    as libc::c_long as size_t
                            {
                                current_block = 3132699548715661320;
                                break;
                            }
                            everdef = (everdef as *mut bfd_byte)
                                .offset(iverdefmem.vd_next as isize)
                                as *mut Elf_External_Verdef;
                            i_0 = i_0.wrapping_add(1);
                            i_0;
                        }
                        match current_block {
                            3132699548715661320 => {}
                            _ => {
                                if default_imported_symver {
                                    if freeidx > maxidx {
                                        freeidx = freeidx.wrapping_add(1);
                                        maxidx = freeidx;
                                    } else {
                                        maxidx = maxidx.wrapping_add(1);
                                        freeidx = maxidx;
                                    }
                                }
                                amt = maxidx as size_t;
                                amt = (amt as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<Elf_Internal_Verdef>()
                                            as libc::c_ulong,
                                    ) as size_t as size_t;
                                if ::core::mem::size_of::<Elf_Internal_Verdef>()
                                    as libc::c_ulong != 0 as libc::c_int as libc::c_ulong
                                    && amt
                                        .wrapping_div(
                                            ::core::mem::size_of::<Elf_Internal_Verdef>()
                                                as libc::c_ulong,
                                        ) != maxidx as libc::c_ulong
                                {
                                    bfd_set_error(bfd_error_file_too_big);
                                    current_block = 7132826034772071206;
                                } else {
                                    (*(*abfd).tdata.elf_obj_data)
                                        .verdef = bfd_zalloc(abfd, amt) as *mut Elf_Internal_Verdef;
                                    if ((*(*abfd).tdata.elf_obj_data).verdef).is_null() {
                                        current_block = 7132826034772071206;
                                    } else {
                                        (*(*abfd).tdata.elf_obj_data).cverdefs = maxidx;
                                        everdef = contents as *mut Elf_External_Verdef;
                                        iverdefarr = (*(*abfd).tdata.elf_obj_data).verdef;
                                        i_0 = 0 as libc::c_int as libc::c_uint;
                                        's_455: loop {
                                            if !(i_0 < (*hdr_0).sh_info) {
                                                current_block = 5636883459695696059;
                                                break;
                                            }
                                            let mut everdaux: *mut Elf_External_Verdaux = 0
                                                as *mut Elf_External_Verdaux;
                                            let mut iverdaux: *mut Elf_Internal_Verdaux = 0
                                                as *mut Elf_Internal_Verdaux;
                                            let mut j_0: libc::c_uint = 0;
                                            _bfd_elf_swap_verdef_in(abfd, everdef, &mut iverdefmem);
                                            if iverdefmem.vd_ndx as libc::c_int & 0x7fff as libc::c_int
                                                == 0 as libc::c_int
                                            {
                                                current_block = 3132699548715661320;
                                                break;
                                            }
                                            iverdef = &mut *iverdefarr
                                                .offset(
                                                    ((iverdefmem.vd_ndx as libc::c_int & 0x7fff as libc::c_int)
                                                        - 1 as libc::c_int) as isize,
                                                ) as *mut Elf_Internal_Verdef;
                                            memcpy(
                                                iverdef as *mut libc::c_void,
                                                &mut iverdefmem as *mut Elf_Internal_Verdef
                                                    as *const libc::c_void,
                                                32 as libc::c_ulong,
                                            );
                                            (*iverdef).vd_bfd = abfd;
                                            if (*iverdef).vd_cnt as libc::c_int == 0 as libc::c_int {
                                                (*iverdef).vd_auxptr = 0 as *mut elf_internal_verdaux;
                                            } else {
                                                amt = (*iverdef).vd_cnt as size_t;
                                                amt = (amt as libc::c_ulong)
                                                    .wrapping_mul(
                                                        ::core::mem::size_of::<Elf_Internal_Verdaux>()
                                                            as libc::c_ulong,
                                                    ) as size_t as size_t;
                                                if ::core::mem::size_of::<Elf_Internal_Verdaux>()
                                                    as libc::c_ulong != 0 as libc::c_int as libc::c_ulong
                                                    && amt
                                                        .wrapping_div(
                                                            ::core::mem::size_of::<Elf_Internal_Verdaux>()
                                                                as libc::c_ulong,
                                                        ) != (*iverdef).vd_cnt as libc::c_ulong
                                                {
                                                    bfd_set_error(bfd_error_file_too_big);
                                                    current_block = 7132826034772071206;
                                                    break;
                                                } else {
                                                    (*iverdef)
                                                        .vd_auxptr = bfd_alloc(abfd, amt)
                                                        as *mut elf_internal_verdaux;
                                                    if ((*iverdef).vd_auxptr).is_null() {
                                                        current_block = 7132826034772071206;
                                                        break;
                                                    }
                                                }
                                            }
                                            if (*iverdef).vd_aux
                                                > contents_end_aux.offset_from(everdef as *mut bfd_byte)
                                                    as libc::c_long as size_t
                                            {
                                                current_block = 3132699548715661320;
                                                break;
                                            }
                                            everdaux = (everdef as *mut bfd_byte)
                                                .offset((*iverdef).vd_aux as isize)
                                                as *mut Elf_External_Verdaux;
                                            iverdaux = (*iverdef).vd_auxptr;
                                            j_0 = 0 as libc::c_int as libc::c_uint;
                                            while j_0 < (*iverdef).vd_cnt as libc::c_uint {
                                                _bfd_elf_swap_verdaux_in(abfd, everdaux, iverdaux);
                                                (*iverdaux)
                                                    .vda_nodename = bfd_elf_string_from_elf_section(
                                                    abfd,
                                                    (*hdr_0).sh_link,
                                                    (*iverdaux).vda_name as libc::c_uint,
                                                );
                                                if ((*iverdaux).vda_nodename).is_null() {
                                                    current_block = 3132699548715661320;
                                                    break 's_455;
                                                }
                                                (*iverdaux).vda_nextptr = 0 as *mut elf_internal_verdaux;
                                                if (*iverdaux).vda_next == 0 as libc::c_int as libc::c_ulong
                                                {
                                                    (*iverdef)
                                                        .vd_cnt = j_0.wrapping_add(1 as libc::c_int as libc::c_uint)
                                                        as libc::c_ushort;
                                                    break;
                                                } else {
                                                    if j_0.wrapping_add(1 as libc::c_int as libc::c_uint)
                                                        < (*iverdef).vd_cnt as libc::c_uint
                                                    {
                                                        (*iverdaux)
                                                            .vda_nextptr = iverdaux.offset(1 as libc::c_int as isize);
                                                    }
                                                    if (*iverdaux).vda_next
                                                        > contents_end_aux.offset_from(everdaux as *mut bfd_byte)
                                                            as libc::c_long as size_t
                                                    {
                                                        current_block = 3132699548715661320;
                                                        break 's_455;
                                                    }
                                                    everdaux = (everdaux as *mut bfd_byte)
                                                        .offset((*iverdaux).vda_next as isize)
                                                        as *mut Elf_External_Verdaux;
                                                    j_0 = j_0.wrapping_add(1);
                                                    j_0;
                                                    iverdaux = iverdaux.offset(1);
                                                    iverdaux;
                                                }
                                            }
                                            (*iverdef).vd_nodename = 0 as *const libc::c_char;
                                            if (*iverdef).vd_cnt != 0 {
                                                (*iverdef)
                                                    .vd_nodename = (*(*iverdef).vd_auxptr).vda_nodename;
                                            }
                                            (*iverdef).vd_nextdef = 0 as *mut elf_internal_verdef;
                                            if (*iverdef).vd_next == 0 as libc::c_int as libc::c_ulong {
                                                current_block = 5636883459695696059;
                                                break;
                                            }
                                            if (iverdef.offset_from(iverdefarr) as libc::c_long
                                                as size_t)
                                                .wrapping_add(1 as libc::c_int as libc::c_ulong)
                                                < maxidx as libc::c_ulong
                                            {
                                                (*iverdef)
                                                    .vd_nextdef = iverdef.offset(1 as libc::c_int as isize);
                                            }
                                            everdef = (everdef as *mut bfd_byte)
                                                .offset((*iverdef).vd_next as isize)
                                                as *mut Elf_External_Verdef;
                                            i_0 = i_0.wrapping_add(1);
                                            i_0;
                                        }
                                        match current_block {
                                            3132699548715661320 => {}
                                            7132826034772071206 => {}
                                            _ => {
                                                free(contents as *mut libc::c_void);
                                                contents = 0 as *mut bfd_byte;
                                                current_block = 3921975509081277429;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                match current_block {
                    3921975509081277429 => {}
                    7132826034772071206 => {}
                    _ => {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%pB: .gnu.version_d invalid entry\0" as *const u8
                                    as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            abfd,
                        );
                        bfd_set_error(bfd_error_bad_value);
                        current_block = 7132826034772071206;
                    }
                }
            } else if default_imported_symver {
                if freeidx < 3 as libc::c_int as libc::c_uint {
                    freeidx = 3 as libc::c_int as libc::c_uint;
                } else {
                    freeidx = freeidx.wrapping_add(1);
                    freeidx;
                }
                amt = freeidx as size_t;
                amt = (amt as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<Elf_Internal_Verdef>() as libc::c_ulong,
                    ) as size_t as size_t;
                if ::core::mem::size_of::<Elf_Internal_Verdef>() as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                    && amt
                        .wrapping_div(
                            ::core::mem::size_of::<Elf_Internal_Verdef>()
                                as libc::c_ulong,
                        ) != freeidx as libc::c_ulong
                {
                    bfd_set_error(bfd_error_file_too_big);
                    current_block = 12232566507951731591;
                } else {
                    (*(*abfd).tdata.elf_obj_data)
                        .verdef = bfd_zalloc(abfd, amt) as *mut Elf_Internal_Verdef;
                    if ((*(*abfd).tdata.elf_obj_data).verdef).is_null() {
                        current_block = 12232566507951731591;
                    } else {
                        (*(*abfd).tdata.elf_obj_data).cverdefs = freeidx;
                        current_block = 3921975509081277429;
                    }
                }
            } else {
                current_block = 3921975509081277429;
            }
            match current_block {
                12232566507951731591 => {}
                _ => {
                    match current_block {
                        3921975509081277429 => {
                            if default_imported_symver {
                                let mut iverdef_0: *mut Elf_Internal_Verdef = 0
                                    as *mut Elf_Internal_Verdef;
                                let mut iverdaux_0: *mut Elf_Internal_Verdaux = 0
                                    as *mut Elf_Internal_Verdaux;
                                iverdef_0 = &mut *((*(*abfd).tdata.elf_obj_data).verdef)
                                    .offset(
                                        freeidx.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            as isize,
                                    ) as *mut Elf_Internal_Verdef;
                                (*iverdef_0)
                                    .vd_version = 1 as libc::c_int as libc::c_ushort;
                                (*iverdef_0).vd_flags = 0 as libc::c_int as libc::c_ushort;
                                (*iverdef_0).vd_ndx = freeidx as libc::c_ushort;
                                (*iverdef_0).vd_cnt = 1 as libc::c_int as libc::c_ushort;
                                (*iverdef_0).vd_bfd = abfd;
                                (*iverdef_0).vd_nodename = bfd_elf_get_dt_soname(abfd);
                                if ((*iverdef_0).vd_nodename).is_null() {
                                    current_block = 7132826034772071206;
                                } else {
                                    (*iverdef_0).vd_nextdef = 0 as *mut elf_internal_verdef;
                                    (*iverdef_0)
                                        .vd_auxptr = bfd_zalloc(
                                        abfd,
                                        ::core::mem::size_of::<Elf_Internal_Verdaux>()
                                            as libc::c_ulong,
                                    ) as *mut elf_internal_verdaux;
                                    if ((*iverdef_0).vd_auxptr).is_null() {
                                        current_block = 7132826034772071206;
                                    } else {
                                        iverdaux_0 = (*iverdef_0).vd_auxptr;
                                        (*iverdaux_0).vda_nodename = (*iverdef_0).vd_nodename;
                                        current_block = 14883390358315838856;
                                    }
                                }
                            } else {
                                current_block = 14883390358315838856;
                            }
                            match current_block {
                                7132826034772071206 => {}
                                _ => return 1 as libc::c_int != 0,
                            }
                        }
                        _ => {}
                    }
                    (*(*abfd).tdata.elf_obj_data).verdef = 0 as *mut Elf_Internal_Verdef;
                    (*(*abfd).tdata.elf_obj_data)
                        .cverdefs = 0 as libc::c_int as libc::c_uint;
                }
            }
        }
        _ => {}
    }
    free(contents as *mut libc::c_void);
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_make_empty_symbol(mut abfd: *mut bfd) -> *mut asymbol {
    let mut newsym: *mut elf_symbol_type = 0 as *mut elf_symbol_type;
    newsym = bfd_zalloc(abfd, ::core::mem::size_of::<elf_symbol_type>() as libc::c_ulong)
        as *mut elf_symbol_type;
    if newsym.is_null() {
        return 0 as *mut asymbol;
    }
    (*newsym).symbol.the_bfd = abfd;
    return &mut (*newsym).symbol;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_symbol_info(
    mut _abfd: *mut bfd,
    mut symbol: *mut asymbol,
    mut ret: *mut symbol_info,
) {
    bfd_symbol_info(symbol, ret);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_is_local_label_name(
    mut _abfd: *mut bfd,
    mut name: *const libc::c_char,
) -> bool {
    if *name.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
        && *name.offset(1 as libc::c_int as isize) as libc::c_int == 'L' as i32
    {
        return 1 as libc::c_int != 0;
    }
    if *name.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
        && *name.offset(1 as libc::c_int as isize) as libc::c_int == '.' as i32
    {
        return 1 as libc::c_int != 0;
    }
    if *name.offset(0 as libc::c_int as isize) as libc::c_int == '_' as i32
        && *name.offset(1 as libc::c_int as isize) as libc::c_int == '.' as i32
        && *name.offset(2 as libc::c_int as isize) as libc::c_int == 'L' as i32
        && *name.offset(3 as libc::c_int as isize) as libc::c_int == '_' as i32
    {
        return 1 as libc::c_int != 0;
    }
    if *name.offset(0 as libc::c_int as isize) as libc::c_int == 'L' as i32
        && _sch_istable[(*name.offset(1 as libc::c_int as isize) as libc::c_int
            & 0xff as libc::c_int) as usize] as libc::c_int
            & _sch_isdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        let mut ret: bool = 0 as libc::c_int != 0;
        let mut p: *const libc::c_char = 0 as *const libc::c_char;
        let mut c: libc::c_char = 0;
        p = name.offset(2 as libc::c_int as isize);
        loop {
            c = *p;
            if !(c != 0) {
                break;
            }
            if c as libc::c_int == 1 as libc::c_int
                || c as libc::c_int == 2 as libc::c_int
            {
                if c as libc::c_int == 1 as libc::c_int
                    && p == name.offset(2 as libc::c_int as isize)
                {
                    return 1 as libc::c_int != 0;
                }
                ret = 1 as libc::c_int != 0;
            }
            if _sch_istable[(c as libc::c_int & 0xff as libc::c_int) as usize]
                as libc::c_int
                & _sch_isdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
            {
                ret = 0 as libc::c_int != 0;
                break;
            } else {
                p = p.offset(1);
                p;
            }
        }
        return ret;
    }
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_lineno(
    mut _abfd: *mut bfd,
    mut _symbol: *mut asymbol,
) -> *mut alent {
    _bfd_abort(
        b"elf.c\0" as *const u8 as *const libc::c_char,
        9165 as libc::c_int,
        (*::core::mem::transmute::<
            &[u8; 45],
            &[libc::c_char; 45],
        >(b"alent *_bfd_elf_get_lineno(bfd *, asymbol *)\0"))
            .as_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_set_arch_mach(
    mut abfd: *mut bfd,
    mut arch: bfd_architecture,
    mut machine: libc::c_ulong,
) -> bool {
    if arch as libc::c_uint
        != (*((*(*abfd).xvec).backend_data as *const elf_backend_data)).arch
            as libc::c_uint
        && arch as libc::c_uint != bfd_arch_unknown as libc::c_int as libc::c_uint
        && (*((*(*abfd).xvec).backend_data as *const elf_backend_data)).arch
            as libc::c_uint != bfd_arch_unknown as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int != 0;
    }
    return bfd_default_set_arch_mach(abfd, arch, machine);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_find_nearest_line(
    mut abfd: *mut bfd,
    mut symbols: *mut *mut asymbol,
    mut section: *mut asection,
    mut offset: bfd_vma,
    mut filename_ptr: *mut *const libc::c_char,
    mut functionname_ptr: *mut *const libc::c_char,
    mut line_ptr: *mut libc::c_uint,
    mut discriminator_ptr: *mut libc::c_uint,
) -> bool {
    let mut found: bool = false;
    if _bfd_dwarf2_find_nearest_line(
        abfd,
        symbols,
        0 as *mut asymbol,
        section,
        offset,
        filename_ptr,
        functionname_ptr,
        line_ptr,
        discriminator_ptr,
        dwarf_debug_sections.as_ptr(),
        &mut (*(*abfd).tdata.elf_obj_data).dwarf2_find_line_info,
    ) != 0
    {
        return 1 as libc::c_int != 0;
    }
    if _bfd_dwarf1_find_nearest_line(
        abfd,
        symbols,
        section,
        offset,
        filename_ptr,
        functionname_ptr,
        line_ptr,
    ) {
        if (*functionname_ptr).is_null() {
            _bfd_elf_find_function(
                abfd,
                symbols,
                section,
                offset,
                if !(*filename_ptr).is_null() {
                    0 as *mut *const libc::c_char
                } else {
                    filename_ptr
                },
                functionname_ptr,
            );
        }
        return 1 as libc::c_int != 0;
    }
    if !_bfd_stab_section_find_nearest_line(
        abfd,
        symbols,
        section,
        offset,
        &mut found,
        filename_ptr,
        functionname_ptr,
        line_ptr,
        &mut (*(*abfd).tdata.elf_obj_data).line_info,
    ) {
        return 0 as libc::c_int != 0;
    }
    if found as libc::c_int != 0 && (!(*functionname_ptr).is_null() || *line_ptr != 0) {
        return 1 as libc::c_int != 0;
    }
    if symbols.is_null() {
        return 0 as libc::c_int != 0;
    }
    if (_bfd_elf_find_function(
        abfd,
        symbols,
        section,
        offset,
        filename_ptr,
        functionname_ptr,
    ))
        .is_null()
    {
        return 0 as libc::c_int != 0;
    }
    *line_ptr = 0 as libc::c_int as libc::c_uint;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_find_line(
    mut abfd: *mut bfd,
    mut symbols: *mut *mut asymbol,
    mut symbol: *mut asymbol,
    mut filename_ptr: *mut *const libc::c_char,
    mut line_ptr: *mut libc::c_uint,
) -> bool {
    return _bfd_dwarf2_find_nearest_line(
        abfd,
        symbols,
        symbol,
        0 as *mut asection,
        0 as libc::c_int as bfd_vma,
        filename_ptr,
        0 as *mut *const libc::c_char,
        line_ptr,
        0 as *mut libc::c_uint,
        dwarf_debug_sections.as_ptr(),
        &mut (*(*abfd).tdata.elf_obj_data).dwarf2_find_line_info,
    ) != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_find_inliner_info(
    mut abfd: *mut bfd,
    mut filename_ptr: *mut *const libc::c_char,
    mut functionname_ptr: *mut *const libc::c_char,
    mut line_ptr: *mut libc::c_uint,
) -> bool {
    let mut found: bool = false;
    found = _bfd_dwarf2_find_inliner_info(
        abfd,
        filename_ptr,
        functionname_ptr,
        line_ptr,
        &mut (*(*abfd).tdata.elf_obj_data).dwarf2_find_line_info,
    );
    return found;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_sizeof_headers(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
) -> libc::c_int {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut ret: libc::c_int = (*(*bed).s).sizeof_ehdr as libc::c_int;
    if !((*info).type_0() as libc::c_int == type_relocatable as libc::c_int) {
        let mut phdr_size: bfd_size_type = (*(*(*abfd).tdata.elf_obj_data).o)
            .program_header_size;
        if phdr_size == -(1 as libc::c_int) as bfd_size_type {
            let mut m: *mut elf_segment_map = 0 as *mut elf_segment_map;
            phdr_size = 0 as libc::c_int as bfd_size_type;
            m = (*(*(*abfd).tdata.elf_obj_data).o).seg_map;
            while !m.is_null() {
                phdr_size = (phdr_size as libc::c_ulong)
                    .wrapping_add((*(*bed).s).sizeof_phdr as libc::c_ulong)
                    as bfd_size_type as bfd_size_type;
                m = (*m).next;
            }
            if phdr_size == 0 as libc::c_int as libc::c_ulong {
                phdr_size = get_program_header_size(abfd, info);
            }
        }
        (*(*(*abfd).tdata.elf_obj_data).o).program_header_size = phdr_size;
        ret = (ret as libc::c_ulong).wrapping_add(phdr_size) as libc::c_int
            as libc::c_int;
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_set_section_contents(
    mut abfd: *mut bfd,
    mut section: sec_ptr,
    mut location: *const libc::c_void,
    mut offset: file_ptr,
    mut count: bfd_size_type,
) -> bool {
    let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut pos: file_ptr = 0;
    if (*abfd).output_has_begun() == 0
        && !_bfd_elf_compute_section_file_positions(abfd, 0 as *mut bfd_link_info)
    {
        return 0 as libc::c_int != 0;
    }
    if count == 0 {
        return 1 as libc::c_int != 0;
    }
    hdr = &mut (*((*section).used_by_bfd as *mut bfd_elf_section_data)).this_hdr;
    if (*hdr).sh_offset == -(1 as libc::c_int) as file_ptr {
        let mut contents: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        if bfd_section_is_ctf(section as *const asection) {
            return 1 as libc::c_int != 0;
        }
        if (*section).flags & 0x8000000 as libc::c_int as libc::c_uint
            == 0 as libc::c_int as libc::c_uint
        {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB:%pA: error: attempting to write into an unallocated compressed section\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                section,
            );
            bfd_set_error(bfd_error_invalid_operation);
            return 0 as libc::c_int != 0;
        }
        if (offset as libc::c_ulong).wrapping_add(count) > (*hdr).sh_size {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB:%pA: error: attempting to write over the end of the section\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                section,
            );
            bfd_set_error(bfd_error_invalid_operation);
            return 0 as libc::c_int != 0;
        }
        contents = (*hdr).contents;
        if contents.is_null() {
            _bfd_error_handler(
                dcgettext(
                    b"bfd\0" as *const u8 as *const libc::c_char,
                    b"%pB:%pA: error: attempting to write section into an empty buffer\0"
                        as *const u8 as *const libc::c_char,
                    5 as libc::c_int,
                ),
                abfd,
                section,
            );
            bfd_set_error(bfd_error_invalid_operation);
            return 0 as libc::c_int != 0;
        }
        memcpy(contents.offset(offset as isize) as *mut libc::c_void, location, count);
        return 1 as libc::c_int != 0;
    }
    pos = (*hdr).sh_offset + offset;
    if bfd_seek(abfd, pos, 0 as libc::c_int) != 0 as libc::c_int
        || bfd_bwrite(location, count, abfd) != count
    {
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_no_info_to_howto(
    mut _abfd: *mut bfd,
    mut _cache_ptr: *mut arelent,
    mut _dst: *mut Elf_Internal_Rela,
) -> bool {
    _bfd_abort(
        b"elf.c\0" as *const u8 as *const libc::c_char,
        9369 as libc::c_int,
        (*::core::mem::transmute::<
            &[u8; 71],
            &[libc::c_char; 71],
        >(b"_Bool _bfd_elf_no_info_to_howto(bfd *, arelent *, Elf_Internal_Rela *)\0"))
            .as_ptr(),
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_validate_reloc(
    mut abfd: *mut bfd,
    mut areloc: *mut arelent,
) -> bool {
    let mut current_block: u64;
    if (*(**(*areloc).sym_ptr_ptr).the_bfd).xvec != (*abfd).xvec {
        let mut code: bfd_reloc_code_real_type = _dummy_first_bfd_reloc_code_real;
        let mut howto: *const reloc_howto_type = 0 as *const reloc_howto_type;
        if (*(*areloc).howto).pc_relative() != 0 {
            match (*(*areloc).howto).bitsize() as libc::c_int {
                8 => {
                    current_block = 7904480514598198981;
                    match current_block {
                        17417226077062254578 => {
                            code = BFD_RELOC_64_PCREL;
                        }
                        15895235585495681072 => {
                            code = BFD_RELOC_12_PCREL;
                        }
                        10991634870176667854 => {
                            code = BFD_RELOC_16_PCREL;
                        }
                        13877159138830378881 => {
                            code = BFD_RELOC_24_PCREL;
                        }
                        13718686576662747790 => {
                            code = BFD_RELOC_32_PCREL;
                        }
                        _ => {
                            code = BFD_RELOC_8_PCREL;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    if !howto.is_null()
                        && (*(*areloc).howto).pcrel_offset() as libc::c_int
                            != (*howto).pcrel_offset() as libc::c_int
                    {
                        if (*howto).pcrel_offset() != 0 {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_add((*areloc).address) as bfd_vma as bfd_vma;
                        } else {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_sub((*areloc).address) as bfd_vma as bfd_vma;
                        }
                    }
                    current_block = 14359455889292382949;
                }
                12 => {
                    current_block = 15895235585495681072;
                    match current_block {
                        17417226077062254578 => {
                            code = BFD_RELOC_64_PCREL;
                        }
                        15895235585495681072 => {
                            code = BFD_RELOC_12_PCREL;
                        }
                        10991634870176667854 => {
                            code = BFD_RELOC_16_PCREL;
                        }
                        13877159138830378881 => {
                            code = BFD_RELOC_24_PCREL;
                        }
                        13718686576662747790 => {
                            code = BFD_RELOC_32_PCREL;
                        }
                        _ => {
                            code = BFD_RELOC_8_PCREL;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    if !howto.is_null()
                        && (*(*areloc).howto).pcrel_offset() as libc::c_int
                            != (*howto).pcrel_offset() as libc::c_int
                    {
                        if (*howto).pcrel_offset() != 0 {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_add((*areloc).address) as bfd_vma as bfd_vma;
                        } else {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_sub((*areloc).address) as bfd_vma as bfd_vma;
                        }
                    }
                    current_block = 14359455889292382949;
                }
                16 => {
                    current_block = 10991634870176667854;
                    match current_block {
                        17417226077062254578 => {
                            code = BFD_RELOC_64_PCREL;
                        }
                        15895235585495681072 => {
                            code = BFD_RELOC_12_PCREL;
                        }
                        10991634870176667854 => {
                            code = BFD_RELOC_16_PCREL;
                        }
                        13877159138830378881 => {
                            code = BFD_RELOC_24_PCREL;
                        }
                        13718686576662747790 => {
                            code = BFD_RELOC_32_PCREL;
                        }
                        _ => {
                            code = BFD_RELOC_8_PCREL;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    if !howto.is_null()
                        && (*(*areloc).howto).pcrel_offset() as libc::c_int
                            != (*howto).pcrel_offset() as libc::c_int
                    {
                        if (*howto).pcrel_offset() != 0 {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_add((*areloc).address) as bfd_vma as bfd_vma;
                        } else {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_sub((*areloc).address) as bfd_vma as bfd_vma;
                        }
                    }
                    current_block = 14359455889292382949;
                }
                24 => {
                    current_block = 13877159138830378881;
                    match current_block {
                        17417226077062254578 => {
                            code = BFD_RELOC_64_PCREL;
                        }
                        15895235585495681072 => {
                            code = BFD_RELOC_12_PCREL;
                        }
                        10991634870176667854 => {
                            code = BFD_RELOC_16_PCREL;
                        }
                        13877159138830378881 => {
                            code = BFD_RELOC_24_PCREL;
                        }
                        13718686576662747790 => {
                            code = BFD_RELOC_32_PCREL;
                        }
                        _ => {
                            code = BFD_RELOC_8_PCREL;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    if !howto.is_null()
                        && (*(*areloc).howto).pcrel_offset() as libc::c_int
                            != (*howto).pcrel_offset() as libc::c_int
                    {
                        if (*howto).pcrel_offset() != 0 {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_add((*areloc).address) as bfd_vma as bfd_vma;
                        } else {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_sub((*areloc).address) as bfd_vma as bfd_vma;
                        }
                    }
                    current_block = 14359455889292382949;
                }
                32 => {
                    current_block = 13718686576662747790;
                    match current_block {
                        17417226077062254578 => {
                            code = BFD_RELOC_64_PCREL;
                        }
                        15895235585495681072 => {
                            code = BFD_RELOC_12_PCREL;
                        }
                        10991634870176667854 => {
                            code = BFD_RELOC_16_PCREL;
                        }
                        13877159138830378881 => {
                            code = BFD_RELOC_24_PCREL;
                        }
                        13718686576662747790 => {
                            code = BFD_RELOC_32_PCREL;
                        }
                        _ => {
                            code = BFD_RELOC_8_PCREL;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    if !howto.is_null()
                        && (*(*areloc).howto).pcrel_offset() as libc::c_int
                            != (*howto).pcrel_offset() as libc::c_int
                    {
                        if (*howto).pcrel_offset() != 0 {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_add((*areloc).address) as bfd_vma as bfd_vma;
                        } else {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_sub((*areloc).address) as bfd_vma as bfd_vma;
                        }
                    }
                    current_block = 14359455889292382949;
                }
                64 => {
                    current_block = 17417226077062254578;
                    match current_block {
                        17417226077062254578 => {
                            code = BFD_RELOC_64_PCREL;
                        }
                        15895235585495681072 => {
                            code = BFD_RELOC_12_PCREL;
                        }
                        10991634870176667854 => {
                            code = BFD_RELOC_16_PCREL;
                        }
                        13877159138830378881 => {
                            code = BFD_RELOC_24_PCREL;
                        }
                        13718686576662747790 => {
                            code = BFD_RELOC_32_PCREL;
                        }
                        _ => {
                            code = BFD_RELOC_8_PCREL;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    if !howto.is_null()
                        && (*(*areloc).howto).pcrel_offset() as libc::c_int
                            != (*howto).pcrel_offset() as libc::c_int
                    {
                        if (*howto).pcrel_offset() != 0 {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_add((*areloc).address) as bfd_vma as bfd_vma;
                        } else {
                            (*areloc)
                                .addend = ((*areloc).addend as libc::c_ulong)
                                .wrapping_sub((*areloc).address) as bfd_vma as bfd_vma;
                        }
                    }
                    current_block = 14359455889292382949;
                }
                _ => {
                    current_block = 15948252892851319188;
                }
            }
        } else {
            match (*(*areloc).howto).bitsize() as libc::c_int {
                8 => {
                    current_block = 14722692446458759526;
                    match current_block {
                        5402843490447447146 => {
                            code = BFD_RELOC_64;
                        }
                        15298194854945275850 => {
                            code = BFD_RELOC_14;
                        }
                        14439074117957337527 => {
                            code = BFD_RELOC_16;
                        }
                        15492034479594424188 => {
                            code = BFD_RELOC_26;
                        }
                        7094444480942019451 => {
                            code = BFD_RELOC_32;
                        }
                        _ => {
                            code = BFD_RELOC_8;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    current_block = 14359455889292382949;
                }
                14 => {
                    current_block = 15298194854945275850;
                    match current_block {
                        5402843490447447146 => {
                            code = BFD_RELOC_64;
                        }
                        15298194854945275850 => {
                            code = BFD_RELOC_14;
                        }
                        14439074117957337527 => {
                            code = BFD_RELOC_16;
                        }
                        15492034479594424188 => {
                            code = BFD_RELOC_26;
                        }
                        7094444480942019451 => {
                            code = BFD_RELOC_32;
                        }
                        _ => {
                            code = BFD_RELOC_8;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    current_block = 14359455889292382949;
                }
                16 => {
                    current_block = 14439074117957337527;
                    match current_block {
                        5402843490447447146 => {
                            code = BFD_RELOC_64;
                        }
                        15298194854945275850 => {
                            code = BFD_RELOC_14;
                        }
                        14439074117957337527 => {
                            code = BFD_RELOC_16;
                        }
                        15492034479594424188 => {
                            code = BFD_RELOC_26;
                        }
                        7094444480942019451 => {
                            code = BFD_RELOC_32;
                        }
                        _ => {
                            code = BFD_RELOC_8;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    current_block = 14359455889292382949;
                }
                26 => {
                    current_block = 15492034479594424188;
                    match current_block {
                        5402843490447447146 => {
                            code = BFD_RELOC_64;
                        }
                        15298194854945275850 => {
                            code = BFD_RELOC_14;
                        }
                        14439074117957337527 => {
                            code = BFD_RELOC_16;
                        }
                        15492034479594424188 => {
                            code = BFD_RELOC_26;
                        }
                        7094444480942019451 => {
                            code = BFD_RELOC_32;
                        }
                        _ => {
                            code = BFD_RELOC_8;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    current_block = 14359455889292382949;
                }
                32 => {
                    current_block = 7094444480942019451;
                    match current_block {
                        5402843490447447146 => {
                            code = BFD_RELOC_64;
                        }
                        15298194854945275850 => {
                            code = BFD_RELOC_14;
                        }
                        14439074117957337527 => {
                            code = BFD_RELOC_16;
                        }
                        15492034479594424188 => {
                            code = BFD_RELOC_26;
                        }
                        7094444480942019451 => {
                            code = BFD_RELOC_32;
                        }
                        _ => {
                            code = BFD_RELOC_8;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    current_block = 14359455889292382949;
                }
                64 => {
                    current_block = 5402843490447447146;
                    match current_block {
                        5402843490447447146 => {
                            code = BFD_RELOC_64;
                        }
                        15298194854945275850 => {
                            code = BFD_RELOC_14;
                        }
                        14439074117957337527 => {
                            code = BFD_RELOC_16;
                        }
                        15492034479594424188 => {
                            code = BFD_RELOC_26;
                        }
                        7094444480942019451 => {
                            code = BFD_RELOC_32;
                        }
                        _ => {
                            code = BFD_RELOC_8;
                        }
                    }
                    howto = bfd_reloc_type_lookup(abfd, code);
                    current_block = 14359455889292382949;
                }
                _ => {
                    current_block = 15948252892851319188;
                }
            }
        }
        match current_block {
            14359455889292382949 => {
                if !howto.is_null() {
                    (*areloc).howto = howto;
                    current_block = 17281240262373992796;
                } else {
                    current_block = 15948252892851319188;
                }
            }
            _ => {}
        }
        match current_block {
            17281240262373992796 => {}
            _ => {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB: %s unsupported\0" as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abfd,
                    (*(*areloc).howto).name,
                );
                bfd_set_error(bfd_error_sorry);
                return 0 as libc::c_int != 0;
            }
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_close_and_cleanup(mut abfd: *mut bfd) -> bool {
    let mut tdata: *mut elf_obj_tdata = (*abfd).tdata.elf_obj_data;
    if !tdata.is_null()
        && (bfd_get_format(abfd) as libc::c_uint
            == bfd_object as libc::c_int as libc::c_uint
            || bfd_get_format(abfd) as libc::c_uint
                == bfd_core as libc::c_int as libc::c_uint)
    {
        if !((*(*abfd).tdata.elf_obj_data).o).is_null()
            && !((*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr).is_null()
        {
            _bfd_elf_strtab_free((*(*(*abfd).tdata.elf_obj_data).o).strtab_ptr);
        }
        _bfd_dwarf2_cleanup_debug_info(abfd, &mut (*tdata).dwarf2_find_line_info);
    }
    return _bfd_archive_close_and_cleanup(abfd);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_rel_vtable_reloc_fn(
    mut _abfd: *mut bfd,
    mut _re: *mut arelent,
    mut _symbol: *mut bfd_symbol,
    mut _data: *mut libc::c_void,
    mut _is: *mut asection,
    mut _obfd: *mut bfd,
    mut _errmsg: *mut *mut libc::c_char,
) -> bfd_reloc_status_type {
    return bfd_reloc_ok;
}
unsafe extern "C" fn elfcore_make_pid(mut abfd: *mut bfd) -> libc::c_int {
    let mut pid: libc::c_int = 0;
    pid = (*(*(*abfd).tdata.elf_obj_data).core).lwpid;
    if pid == 0 as libc::c_int {
        pid = (*(*(*abfd).tdata.elf_obj_data).core).pid;
    }
    return pid;
}
unsafe extern "C" fn elfcore_maybe_make_sect(
    mut abfd: *mut bfd,
    mut name: *mut libc::c_char,
    mut sect: *mut asection,
) -> bool {
    let mut sect2: *mut asection = 0 as *mut asection;
    if !(bfd_get_section_by_name(abfd, name)).is_null() {
        return 1 as libc::c_int != 0;
    }
    sect2 = bfd_make_section_with_flags(abfd, name, (*sect).flags);
    if sect2.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*sect2).size = (*sect).size;
    (*sect2).filepos = (*sect).filepos;
    (*sect2).alignment_power = (*sect).alignment_power;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elfcore_make_pseudosection(
    mut abfd: *mut bfd,
    mut name: *mut libc::c_char,
    mut size: size_t,
    mut filepos: ufile_ptr,
) -> bool {
    let mut buf: [libc::c_char; 100] = [0; 100];
    let mut threaded_name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut sect: *mut asection = 0 as *mut asection;
    sprintf(
        buf.as_mut_ptr(),
        b"%s/%d\0" as *const u8 as *const libc::c_char,
        name,
        elfcore_make_pid(abfd),
    );
    len = (strlen(buf.as_mut_ptr())).wrapping_add(1 as libc::c_int as libc::c_ulong);
    threaded_name = bfd_alloc(abfd, len) as *mut libc::c_char;
    if threaded_name.is_null() {
        return 0 as libc::c_int != 0;
    }
    memcpy(
        threaded_name as *mut libc::c_void,
        buf.as_mut_ptr() as *const libc::c_void,
        len,
    );
    sect = bfd_make_section_anyway_with_flags(
        abfd,
        threaded_name,
        0x100 as libc::c_int as flagword,
    );
    if sect.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*sect).size = size;
    (*sect).filepos = filepos as file_ptr;
    (*sect).alignment_power = 2 as libc::c_int as libc::c_uint;
    return elfcore_maybe_make_sect(abfd, name, sect);
}
unsafe extern "C" fn elfcore_make_auxv_note_section(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
    mut offs: size_t,
) -> bool {
    let mut sect: *mut asection = bfd_make_section_anyway_with_flags(
        abfd,
        b".auxv\0" as *const u8 as *const libc::c_char,
        0x100 as libc::c_int as flagword,
    );
    if sect.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*sect).size = ((*note).descsz).wrapping_sub(offs);
    (*sect).filepos = ((*note).descpos).wrapping_add(offs) as file_ptr;
    (*sect)
        .alignment_power = (1 as libc::c_int
        + bfd_get_arch_size(abfd) / 32 as libc::c_int) as libc::c_uint;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_make_memtag_note_section(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
    mut offs: size_t,
) -> bool {
    let mut sect: *mut asection = bfd_make_section_anyway_with_flags(
        abfd,
        b".memtag\0" as *const u8 as *const libc::c_char,
        0x100 as libc::c_int as flagword,
    );
    if sect.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*sect).size = ((*note).descsz).wrapping_sub(offs);
    (*sect).filepos = ((*note).descpos).wrapping_add(offs) as file_ptr;
    (*sect)
        .alignment_power = (1 as libc::c_int
        + bfd_get_arch_size(abfd) / 32 as libc::c_int) as libc::c_uint;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_grok_prstatus(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut size: size_t = 0;
    let mut offset: libc::c_int = 0;
    if (*note).descsz == ::core::mem::size_of::<prstatus_t>() as libc::c_ulong {
        let mut prstat: prstatus_t = prstatus_t {
            pr_info: elf_siginfo {
                si_signo: 0,
                si_code: 0,
                si_errno: 0,
            },
            pr_cursig: 0,
            pr_sigpend: 0,
            pr_sighold: 0,
            pr_pid: 0,
            pr_ppid: 0,
            pr_pgrp: 0,
            pr_sid: 0,
            pr_utime: timeval { tv_sec: 0, tv_usec: 0 },
            pr_stime: timeval { tv_sec: 0, tv_usec: 0 },
            pr_cutime: timeval { tv_sec: 0, tv_usec: 0 },
            pr_cstime: timeval { tv_sec: 0, tv_usec: 0 },
            pr_reg: [0; 27],
            pr_fpvalid: 0,
        };
        size = ::core::mem::size_of::<elf_gregset_t>() as libc::c_ulong;
        offset = 112 as libc::c_ulong as libc::c_int;
        memcpy(
            &mut prstat as *mut prstatus_t as *mut libc::c_void,
            (*note).descdata as *const libc::c_void,
            ::core::mem::size_of::<prstatus_t>() as libc::c_ulong,
        );
        if (*(*(*abfd).tdata.elf_obj_data).core).signal == 0 as libc::c_int {
            (*(*(*abfd).tdata.elf_obj_data).core)
                .signal = prstat.pr_cursig as libc::c_int;
        }
        if (*(*(*abfd).tdata.elf_obj_data).core).pid == 0 as libc::c_int {
            (*(*(*abfd).tdata.elf_obj_data).core).pid = prstat.pr_pid;
        }
        (*(*(*abfd).tdata.elf_obj_data).core).lwpid = prstat.pr_pid;
    } else if (*note).descsz == ::core::mem::size_of::<prstatus32_t>() as libc::c_ulong {
        let mut prstat_0: prstatus32_t = prstatus32_t {
            pr_info: elf_siginfo {
                si_signo: 0,
                si_code: 0,
                si_errno: 0,
            },
            pr_cursig: 0,
            pr_sigpend: 0,
            pr_sighold: 0,
            pr_pid: 0,
            pr_ppid: 0,
            pr_pgrp: 0,
            pr_sid: 0,
            pr_utime: prstatus32_timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            pr_stime: prstatus32_timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            pr_cutime: prstatus32_timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            pr_cstime: prstatus32_timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            pr_reg: [0; 17],
            pr_fpvalid: 0,
        };
        size = ::core::mem::size_of::<elf_gregset32_t>() as libc::c_ulong;
        offset = 72 as libc::c_ulong as libc::c_int;
        memcpy(
            &mut prstat_0 as *mut prstatus32_t as *mut libc::c_void,
            (*note).descdata as *const libc::c_void,
            ::core::mem::size_of::<prstatus32_t>() as libc::c_ulong,
        );
        if (*(*(*abfd).tdata.elf_obj_data).core).signal == 0 as libc::c_int {
            (*(*(*abfd).tdata.elf_obj_data).core)
                .signal = prstat_0.pr_cursig as libc::c_int;
        }
        if (*(*(*abfd).tdata.elf_obj_data).core).pid == 0 as libc::c_int {
            (*(*(*abfd).tdata.elf_obj_data).core).pid = prstat_0.pr_pid;
        }
        (*(*(*abfd).tdata.elf_obj_data).core).lwpid = prstat_0.pr_pid;
    } else {
        return 1 as libc::c_int != 0
    }
    return _bfd_elfcore_make_pseudosection(
        abfd,
        b".reg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        size,
        ((*note).descpos).wrapping_add(offset as libc::c_ulong),
    );
}
unsafe extern "C" fn elfcore_make_note_pseudosection(
    mut abfd: *mut bfd,
    mut name: *mut libc::c_char,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return _bfd_elfcore_make_pseudosection(abfd, name, (*note).descsz, (*note).descpos);
}
unsafe extern "C" fn elfcore_grok_prfpreg(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg2\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_prxfpreg(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-xfp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_xstatereg(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-xstate\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_vmx(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-vmx\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_vsx(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-vsx\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tar(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tar\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_ppr(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-ppr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_dscr(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-dscr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_ebb(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-ebb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_pmu(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-pmu\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tm_cgpr(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tm-cgpr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tm_cfpr(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tm-cfpr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tm_cvmx(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tm-cvmx\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tm_cvsx(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tm-cvsx\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tm_spr(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tm-spr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tm_ctar(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tm-ctar\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tm_cppr(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tm-cppr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_ppc_tm_cdscr(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-ppc-tm-cdscr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_high_gprs(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-high-gprs\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_timer(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-timer\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_todcmp(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-todcmp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_todpreg(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-todpreg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_ctrs(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-ctrs\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_prefix(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-prefix\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_last_break(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-last-break\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_system_call(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-system-call\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_tdb(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-tdb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_vxrs_low(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-vxrs-low\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_vxrs_high(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-vxrs-high\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_gs_cb(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-gs-cb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_s390_gs_bc(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-s390-gs-bc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_arm_vfp(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-arm-vfp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_aarch_tls(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-aarch-tls\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_aarch_hw_break(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-aarch-hw-break\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_aarch_hw_watch(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-aarch-hw-watch\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_aarch_sve(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-aarch-sve\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_aarch_pauth(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-aarch-pauth\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_aarch_mte(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-aarch-mte\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_arc_v2(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-arc-v2\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_riscv_csr(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".reg-riscv-csr\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_gdb_tdesc(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    return elfcore_make_note_pseudosection(
        abfd,
        b".gdb-tdesc\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        note,
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elfcore_strndup(
    mut abfd: *mut bfd,
    mut start: *mut libc::c_char,
    mut max: size_t,
) -> *mut libc::c_char {
    let mut dups: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut end: *mut libc::c_char = memchr(
        start as *const libc::c_void,
        '\0' as i32,
        max,
    ) as *mut libc::c_char;
    let mut len: size_t = 0;
    if end.is_null() {
        len = max;
    } else {
        len = end.offset_from(start) as libc::c_long as size_t;
    }
    dups = bfd_alloc(abfd, len.wrapping_add(1 as libc::c_int as libc::c_ulong))
        as *mut libc::c_char;
    if dups.is_null() {
        return 0 as *mut libc::c_char;
    }
    memcpy(dups as *mut libc::c_void, start as *const libc::c_void, len);
    *dups.offset(len as isize) = '\0' as i32 as libc::c_char;
    return dups;
}
unsafe extern "C" fn elfcore_grok_psinfo(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    if (*note).descsz == ::core::mem::size_of::<elfcore_psinfo_t>() as libc::c_ulong {
        let mut psinfo: elfcore_psinfo_t = elfcore_psinfo_t {
            pr_state: 0,
            pr_sname: 0,
            pr_zomb: 0,
            pr_nice: 0,
            pr_flag: 0,
            pr_uid: 0,
            pr_gid: 0,
            pr_pid: 0,
            pr_ppid: 0,
            pr_pgrp: 0,
            pr_sid: 0,
            pr_fname: [0; 16],
            pr_psargs: [0; 80],
        };
        memcpy(
            &mut psinfo as *mut elfcore_psinfo_t as *mut libc::c_void,
            (*note).descdata as *const libc::c_void,
            ::core::mem::size_of::<elfcore_psinfo_t>() as libc::c_ulong,
        );
        (*(*(*abfd).tdata.elf_obj_data).core).pid = psinfo.pr_pid;
        (*(*(*abfd).tdata.elf_obj_data).core)
            .program = _bfd_elfcore_strndup(
            abfd,
            (psinfo.pr_fname).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        );
        (*(*(*abfd).tdata.elf_obj_data).core)
            .command = _bfd_elfcore_strndup(
            abfd,
            (psinfo.pr_psargs).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
        );
    } else if (*note).descsz
        == ::core::mem::size_of::<elfcore_psinfo32_t>() as libc::c_ulong
    {
        let mut psinfo_0: elfcore_psinfo32_t = elfcore_psinfo32_t {
            pr_state: 0,
            pr_sname: 0,
            pr_zomb: 0,
            pr_nice: 0,
            pr_flag: 0,
            pr_uid: 0,
            pr_gid: 0,
            pr_pid: 0,
            pr_ppid: 0,
            pr_pgrp: 0,
            pr_sid: 0,
            pr_fname: [0; 16],
            pr_psargs: [0; 80],
        };
        memcpy(
            &mut psinfo_0 as *mut elfcore_psinfo32_t as *mut libc::c_void,
            (*note).descdata as *const libc::c_void,
            ::core::mem::size_of::<elfcore_psinfo32_t>() as libc::c_ulong,
        );
        (*(*(*abfd).tdata.elf_obj_data).core).pid = psinfo_0.pr_pid;
        (*(*(*abfd).tdata.elf_obj_data).core)
            .program = _bfd_elfcore_strndup(
            abfd,
            (psinfo_0.pr_fname).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        );
        (*(*(*abfd).tdata.elf_obj_data).core)
            .command = _bfd_elfcore_strndup(
            abfd,
            (psinfo_0.pr_psargs).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
        );
    } else {
        return 1 as libc::c_int != 0
    }
    let mut command: *mut libc::c_char = (*(*(*abfd).tdata.elf_obj_data).core).command;
    let mut n: libc::c_int = strlen(command) as libc::c_int;
    if (0 as libc::c_int) < n
        && *command.offset((n - 1 as libc::c_int) as isize) as libc::c_int == ' ' as i32
    {
        *command.offset((n - 1 as libc::c_int) as isize) = '\0' as i32 as libc::c_char;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_grok_win32pstatus(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut buf: [libc::c_char; 30] = [0; 30];
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut name_size: libc::c_uint = 0;
    let mut sect: *mut asection = 0 as *mut asection;
    let mut type_0: libc::c_uint = 0;
    let mut is_active_thread: libc::c_int = 0;
    let mut base_addr: bfd_vma = 0;
    if (*note).descsz < 4 as libc::c_int as libc::c_ulong {
        return 1 as libc::c_int != 0;
    }
    if !startswith((*note).namedata, b"win32\0" as *const u8 as *const libc::c_char) {
        return 1 as libc::c_int != 0;
    }
    type_0 = (Some(((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer")))
        .expect("non-null function pointer")((*note).descdata as *const libc::c_void)
        as libc::c_uint;
    let mut size_check: [C2RustUnnamed_31; 4] = [
        {
            let mut init = C2RustUnnamed_31 {
                type_name: b"NOTE_INFO_PROCESS\0" as *const u8 as *const libc::c_char,
                min_size: 12 as libc::c_int as libc::c_ulong,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_31 {
                type_name: b"NOTE_INFO_THREAD\0" as *const u8 as *const libc::c_char,
                min_size: 12 as libc::c_int as libc::c_ulong,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_31 {
                type_name: b"NOTE_INFO_MODULE\0" as *const u8 as *const libc::c_char,
                min_size: 12 as libc::c_int as libc::c_ulong,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_31 {
                type_name: b"NOTE_INFO_MODULE64\0" as *const u8 as *const libc::c_char,
                min_size: 16 as libc::c_int as libc::c_ulong,
            };
            init
        },
    ];
    if type_0 == 0 as libc::c_int as libc::c_uint
        || type_0 as libc::c_ulong
            > (::core::mem::size_of::<[C2RustUnnamed_31; 4]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<C2RustUnnamed_31>() as libc::c_ulong,
                )
    {
        return 1 as libc::c_int != 0;
    }
    if (*note).descsz
        < size_check[type_0.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
            .min_size
    {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB: warning: win32pstatus %s of size %lu bytes is too small\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            abfd,
            size_check[type_0.wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                .type_name,
            (*note).descsz,
        );
        return 1 as libc::c_int != 0;
    }
    match type_0 {
        1 => {
            (*(*(*abfd).tdata.elf_obj_data).core)
                .pid = (Some(
                ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
            ))
                .expect(
                    "non-null function pointer",
                )(
                ((*note).descdata).offset(4 as libc::c_int as isize)
                    as *const libc::c_void,
            ) as libc::c_int;
            (*(*(*abfd).tdata.elf_obj_data).core)
                .signal = (Some(
                ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
            ))
                .expect(
                    "non-null function pointer",
                )(
                ((*note).descdata).offset(8 as libc::c_int as isize)
                    as *const libc::c_void,
            ) as libc::c_int;
        }
        2 => {
            sprintf(
                buf.as_mut_ptr(),
                b".reg/%ld\0" as *const u8 as *const libc::c_char,
                (Some(((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer")))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*note).descdata).offset(4 as libc::c_int as isize)
                        as *const libc::c_void,
                ) as libc::c_long,
            );
            len = (strlen(buf.as_mut_ptr()))
                .wrapping_add(1 as libc::c_int as libc::c_ulong);
            name = bfd_alloc(abfd, len) as *mut libc::c_char;
            if name.is_null() {
                return 0 as libc::c_int != 0;
            }
            memcpy(
                name as *mut libc::c_void,
                buf.as_mut_ptr() as *const libc::c_void,
                len,
            );
            sect = bfd_make_section_anyway_with_flags(
                abfd,
                name,
                0x100 as libc::c_int as flagword,
            );
            if sect.is_null() {
                return 0 as libc::c_int != 0;
            }
            (*sect)
                .size = ((*note).descsz)
                .wrapping_sub(12 as libc::c_int as libc::c_ulong);
            (*sect)
                .filepos = ((*note).descpos)
                .wrapping_add(12 as libc::c_int as libc::c_ulong) as file_ptr;
            (*sect).alignment_power = 2 as libc::c_int as libc::c_uint;
            is_active_thread = (Some(
                ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
            ))
                .expect(
                    "non-null function pointer",
                )(
                ((*note).descdata).offset(8 as libc::c_int as isize)
                    as *const libc::c_void,
            ) as libc::c_int;
            if is_active_thread != 0 {
                if !elfcore_maybe_make_sect(
                    abfd,
                    b".reg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    sect,
                ) {
                    return 0 as libc::c_int != 0;
                }
            }
        }
        3 | 4 => {
            if type_0 == 3 as libc::c_int as libc::c_uint {
                base_addr = (Some(
                    ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*note).descdata).offset(4 as libc::c_int as isize)
                        as *const libc::c_void,
                );
                sprintf(
                    buf.as_mut_ptr(),
                    b".module/%08lx\0" as *const u8 as *const libc::c_char,
                    base_addr,
                );
                name_size = (Some(
                    ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*note).descdata).offset(8 as libc::c_int as isize)
                        as *const libc::c_void,
                ) as libc::c_uint;
            } else {
                base_addr = (Some(
                    ((*(*abfd).xvec).bfd_getx64).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*note).descdata).offset(4 as libc::c_int as isize)
                        as *const libc::c_void,
                );
                sprintf(
                    buf.as_mut_ptr(),
                    b".module/%016lx\0" as *const u8 as *const libc::c_char,
                    base_addr,
                );
                name_size = (Some(
                    ((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer"),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    ((*note).descdata).offset(12 as libc::c_int as isize)
                        as *const libc::c_void,
                ) as libc::c_uint;
            }
            len = (strlen(buf.as_mut_ptr()))
                .wrapping_add(1 as libc::c_int as libc::c_ulong);
            name = bfd_alloc(abfd, len) as *mut libc::c_char;
            if name.is_null() {
                return 0 as libc::c_int != 0;
            }
            memcpy(
                name as *mut libc::c_void,
                buf.as_mut_ptr() as *const libc::c_void,
                len,
            );
            sect = bfd_make_section_anyway_with_flags(
                abfd,
                name,
                0x100 as libc::c_int as flagword,
            );
            if sect.is_null() {
                return 0 as libc::c_int != 0;
            }
            if (*note).descsz
                < (12 as libc::c_int as libc::c_uint).wrapping_add(name_size)
                    as libc::c_ulong
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB: win32pstatus NOTE_INFO_MODULE of size %lu is too small to contain a name of size %u\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abfd,
                    (*note).descsz,
                    name_size,
                );
                return 1 as libc::c_int != 0;
            }
            (*sect).size = (*note).descsz;
            (*sect).filepos = (*note).descpos as file_ptr;
            (*sect).alignment_power = 2 as libc::c_int as libc::c_uint;
        }
        _ => return 1 as libc::c_int != 0,
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_grok_note(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    match (*note).type_0 {
        1 => {
            if ((*bed).elf_backend_grok_prstatus).is_some() {
                if (Some(
                    ((*bed).elf_backend_grok_prstatus)
                        .expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(abfd, note)
                {
                    return 1 as libc::c_int != 0;
                }
            }
            return elfcore_grok_prstatus(abfd, note);
        }
        2 => return elfcore_grok_prfpreg(abfd, note),
        18 => return elfcore_grok_win32pstatus(abfd, note),
        1189489535 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_prxfpreg(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        514 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_xstatereg(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        256 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_vmx(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        258 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_vsx(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        259 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tar(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        260 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_ppr(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        261 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_dscr(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        262 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_ebb(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        263 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_pmu(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        264 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tm_cgpr(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        265 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tm_cfpr(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        266 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tm_cvmx(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        267 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tm_cvsx(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        268 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tm_spr(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        269 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tm_ctar(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        270 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tm_cppr(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        271 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_ppc_tm_cdscr(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        768 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_high_gprs(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        769 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_timer(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        770 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_todcmp(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        771 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_todpreg(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        772 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_ctrs(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        773 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_prefix(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        774 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_last_break(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        775 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_system_call(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        776 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_tdb(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        777 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_vxrs_low(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        778 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_vxrs_high(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        779 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_gs_cb(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        780 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_s390_gs_bc(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        1536 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_arc_v2(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        1024 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_arm_vfp(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        1025 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_aarch_tls(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        1026 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_aarch_hw_break(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        1027 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_aarch_hw_watch(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        1029 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_aarch_sve(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        1030 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_aarch_pauth(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        1033 => {
            if (*note).namesz == 6 as libc::c_int as libc::c_ulong
                && strcmp(
                    (*note).namedata,
                    b"LINUX\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                return elfcore_grok_aarch_mte(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        4278190080 => {
            if (*note).namesz == 4 as libc::c_int as libc::c_ulong
                && strcmp((*note).namedata, b"GDB\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
            {
                return elfcore_grok_gdb_tdesc(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        2304 => {
            if (*note).namesz == 4 as libc::c_int as libc::c_ulong
                && strcmp((*note).namedata, b"GDB\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
            {
                return elfcore_grok_riscv_csr(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        3 | 13 => {
            if ((*bed).elf_backend_grok_psinfo).is_some() {
                if (Some(
                    ((*bed).elf_backend_grok_psinfo).expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(abfd, note)
                {
                    return 1 as libc::c_int != 0;
                }
            }
            return elfcore_grok_psinfo(abfd, note);
        }
        6 => {
            return elfcore_make_auxv_note_section(abfd, note, 0 as libc::c_int as size_t);
        }
        1179208773 => {
            return elfcore_make_note_pseudosection(
                abfd,
                b".note.linuxcore.file\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                note,
            );
        }
        1397311305 => {
            return elfcore_make_note_pseudosection(
                abfd,
                b".note.linuxcore.siginfo\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                note,
            );
        }
        4278190081 => {
            return elfcore_make_memtag_note_section(
                abfd,
                note,
                0 as libc::c_int as size_t,
            );
        }
        _ => return 1 as libc::c_int != 0,
    };
}
unsafe extern "C" fn elfobj_grok_gnu_build_id(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut build_id: *mut bfd_build_id = 0 as *mut bfd_build_id;
    if (*note).descsz == 0 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    build_id = bfd_alloc(
        abfd,
        (::core::mem::size_of::<bfd_build_id>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            .wrapping_add((*note).descsz),
    ) as *mut bfd_build_id;
    if build_id.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*build_id).size = (*note).descsz;
    memcpy(
        ((*build_id).data).as_mut_ptr() as *mut libc::c_void,
        (*note).descdata as *const libc::c_void,
        (*note).descsz,
    );
    (*abfd).build_id = build_id;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfobj_grok_gnu_note(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    match (*note).type_0 {
        5 => return _bfd_elf_parse_gnu_properties(abfd, note),
        3 => return elfobj_grok_gnu_build_id(abfd, note),
        _ => return 1 as libc::c_int != 0,
    };
}
unsafe extern "C" fn elfobj_grok_stapsdt_note_1(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut cur: *mut sdt_note = bfd_alloc(
        abfd,
        (::core::mem::size_of::<sdt_note>() as libc::c_ulong)
            .wrapping_add((*note).descsz),
    ) as *mut sdt_note;
    (*cur).next = (*(*abfd).tdata.elf_obj_data).sdt_note_head;
    (*cur).size = (*note).descsz;
    memcpy(
        ((*cur).data).as_mut_ptr() as *mut libc::c_void,
        (*note).descdata as *const libc::c_void,
        (*note).descsz,
    );
    (*(*abfd).tdata.elf_obj_data).sdt_note_head = cur;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfobj_grok_stapsdt_note(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    match (*note).type_0 {
        3 => return elfobj_grok_stapsdt_note_1(abfd, note),
        _ => return 1 as libc::c_int != 0,
    };
}
unsafe extern "C" fn elfcore_grok_freebsd_psinfo(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut offset: size_t = 0;
    match (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[4 as libc::c_int as usize] as libc::c_int
    {
        1 => {
            if (*note).descsz < 108 as libc::c_int as libc::c_ulong {
                return 0 as libc::c_int != 0;
            }
        }
        2 => {
            if (*note).descsz < 120 as libc::c_int as libc::c_ulong {
                return 0 as libc::c_int != 0;
            }
        }
        _ => return 0 as libc::c_int != 0,
    }
    if (Some(((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*note).descdata as *mut bfd_byte as *const libc::c_void)
        != 1 as libc::c_int as libc::c_ulong
    {
        return 0 as libc::c_int != 0;
    }
    offset = 4 as libc::c_int as size_t;
    if (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[4 as libc::c_int as usize] as libc::c_int == 1 as libc::c_int
    {
        offset = (offset as libc::c_ulong)
            .wrapping_add(4 as libc::c_int as libc::c_ulong) as size_t as size_t;
    } else {
        offset = (offset as libc::c_ulong)
            .wrapping_add(4 as libc::c_int as libc::c_ulong) as size_t as size_t;
        offset = (offset as libc::c_ulong)
            .wrapping_add(8 as libc::c_int as libc::c_ulong) as size_t as size_t;
    }
    (*(*(*abfd).tdata.elf_obj_data).core)
        .program = _bfd_elfcore_strndup(
        abfd,
        ((*note).descdata).offset(offset as isize),
        17 as libc::c_int as size_t,
    );
    offset = (offset as libc::c_ulong).wrapping_add(17 as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    (*(*(*abfd).tdata.elf_obj_data).core)
        .command = _bfd_elfcore_strndup(
        abfd,
        ((*note).descdata).offset(offset as isize),
        81 as libc::c_int as size_t,
    );
    offset = (offset as libc::c_ulong).wrapping_add(81 as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    offset = (offset as libc::c_ulong).wrapping_add(2 as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    if (*note).descsz < offset.wrapping_add(4 as libc::c_int as libc::c_ulong) {
        return 1 as libc::c_int != 0;
    }
    (*(*(*abfd).tdata.elf_obj_data).core)
        .pid = (Some(((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        ((*note).descdata as *mut bfd_byte).offset(offset as isize)
            as *const libc::c_void,
    ) as libc::c_int;
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_grok_freebsd_prstatus(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut offset: size_t = 0;
    let mut size: size_t = 0;
    let mut min_size: size_t = 0;
    match (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[4 as libc::c_int as usize] as libc::c_int
    {
        1 => {
            offset = (4 as libc::c_int + 4 as libc::c_int) as size_t;
            min_size = offset
                .wrapping_add((4 as libc::c_int * 2 as libc::c_int) as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong);
        }
        2 => {
            offset = (4 as libc::c_int + 4 as libc::c_int + 8 as libc::c_int) as size_t;
            min_size = offset
                .wrapping_add((8 as libc::c_int * 2 as libc::c_int) as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong)
                .wrapping_add(4 as libc::c_int as libc::c_ulong);
        }
        _ => return 0 as libc::c_int != 0,
    }
    if (*note).descsz < min_size {
        return 0 as libc::c_int != 0;
    }
    if (Some(((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )((*note).descdata as *mut bfd_byte as *const libc::c_void)
        != 1 as libc::c_int as libc::c_ulong
    {
        return 0 as libc::c_int != 0;
    }
    if (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[4 as libc::c_int as usize] as libc::c_int == 1 as libc::c_int
    {
        size = (Some(((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(
            ((*note).descdata as *mut bfd_byte).offset(offset as isize)
                as *const libc::c_void,
        );
        offset = (offset as libc::c_ulong)
            .wrapping_add((4 as libc::c_int * 2 as libc::c_int) as libc::c_ulong)
            as size_t as size_t;
    } else {
        size = (Some(((*(*abfd).xvec).bfd_h_getx64).expect("non-null function pointer")))
            .expect(
                "non-null function pointer",
            )(
            ((*note).descdata as *mut bfd_byte).offset(offset as isize)
                as *const libc::c_void,
        );
        offset = (offset as libc::c_ulong)
            .wrapping_add((8 as libc::c_int * 2 as libc::c_int) as libc::c_ulong)
            as size_t as size_t;
    }
    offset = (offset as libc::c_ulong).wrapping_add(4 as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    if (*(*(*abfd).tdata.elf_obj_data).core).signal == 0 as libc::c_int {
        (*(*(*abfd).tdata.elf_obj_data).core)
            .signal = (Some(
            ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(
            ((*note).descdata as *mut bfd_byte).offset(offset as isize)
                as *const libc::c_void,
        ) as libc::c_int;
    }
    offset = (offset as libc::c_ulong).wrapping_add(4 as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    (*(*(*abfd).tdata.elf_obj_data).core)
        .lwpid = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(
        ((*note).descdata as *mut bfd_byte).offset(offset as isize)
            as *const libc::c_void,
    ) as libc::c_int;
    offset = (offset as libc::c_ulong).wrapping_add(4 as libc::c_int as libc::c_ulong)
        as size_t as size_t;
    if (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr())
        .e_ident[4 as libc::c_int as usize] as libc::c_int == 2 as libc::c_int
    {
        offset = (offset as libc::c_ulong)
            .wrapping_add(4 as libc::c_int as libc::c_ulong) as size_t as size_t;
    }
    if ((*note).descsz).wrapping_sub(offset) < size {
        return 0 as libc::c_int != 0;
    }
    return _bfd_elfcore_make_pseudosection(
        abfd,
        b".reg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        size,
        ((*note).descpos).wrapping_add(offset),
    );
}
unsafe extern "C" fn elfcore_grok_freebsd_note(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    match (*note).type_0 {
        1 => {
            if ((*bed).elf_backend_grok_freebsd_prstatus).is_some() {
                if (Some(
                    ((*bed).elf_backend_grok_freebsd_prstatus)
                        .expect("non-null function pointer"),
                ))
                    .expect("non-null function pointer")(abfd, note)
                {
                    return 1 as libc::c_int != 0;
                }
            }
            return elfcore_grok_freebsd_prstatus(abfd, note);
        }
        2 => return elfcore_grok_prfpreg(abfd, note),
        3 => return elfcore_grok_freebsd_psinfo(abfd, note),
        7 => {
            if (*note).namesz == 8 as libc::c_int as libc::c_ulong {
                return elfcore_make_note_pseudosection(
                    abfd,
                    b".thrmisc\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    note,
                )
            } else {
                return 1 as libc::c_int != 0
            }
        }
        8 => {
            return elfcore_make_note_pseudosection(
                abfd,
                b".note.freebsdcore.proc\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                note,
            );
        }
        9 => {
            return elfcore_make_note_pseudosection(
                abfd,
                b".note.freebsdcore.files\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                note,
            );
        }
        10 => {
            return elfcore_make_note_pseudosection(
                abfd,
                b".note.freebsdcore.vmmap\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                note,
            );
        }
        16 => {
            return elfcore_make_auxv_note_section(abfd, note, 4 as libc::c_int as size_t);
        }
        514 => {
            if (*note).namesz == 8 as libc::c_int as libc::c_ulong {
                return elfcore_grok_xstatereg(abfd, note)
            } else {
                return 1 as libc::c_int != 0
            }
        }
        17 => {
            return elfcore_make_note_pseudosection(
                abfd,
                b".note.freebsdcore.lwpinfo\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                note,
            );
        }
        1024 => return elfcore_grok_arm_vfp(abfd, note),
        _ => return 1 as libc::c_int != 0,
    };
}
unsafe extern "C" fn elfcore_netbsd_get_lwpid(
    mut note: *mut Elf_Internal_Note,
    mut lwpidp: *mut libc::c_int,
) -> bool {
    let mut cp: *mut libc::c_char = 0 as *mut libc::c_char;
    cp = strchr((*note).namedata, '@' as i32);
    if !cp.is_null() {
        *lwpidp = atoi(cp.offset(1 as libc::c_int as isize));
        return 1 as libc::c_int != 0;
    }
    return 0 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_grok_netbsd_procinfo(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    if (*note).descsz <= (0x7c as libc::c_int + 31 as libc::c_int) as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    (*(*(*abfd).tdata.elf_obj_data).core)
        .signal = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(
        ((*note).descdata as *mut bfd_byte).offset(0x8 as libc::c_int as isize)
            as *const libc::c_void,
    ) as libc::c_int;
    (*(*(*abfd).tdata.elf_obj_data).core)
        .pid = (Some(((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        ((*note).descdata as *mut bfd_byte).offset(0x50 as libc::c_int as isize)
            as *const libc::c_void,
    ) as libc::c_int;
    (*(*(*abfd).tdata.elf_obj_data).core)
        .command = _bfd_elfcore_strndup(
        abfd,
        ((*note).descdata).offset(0x7c as libc::c_int as isize),
        31 as libc::c_int as size_t,
    );
    return elfcore_make_note_pseudosection(
        abfd,
        b".note.netbsdcore.procinfo\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        note,
    );
}
unsafe extern "C" fn elfcore_grok_netbsd_note(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut lwp: libc::c_int = 0;
    if elfcore_netbsd_get_lwpid(note, &mut lwp) {
        (*(*(*abfd).tdata.elf_obj_data).core).lwpid = lwp;
    }
    match (*note).type_0 {
        1 => return elfcore_grok_netbsd_procinfo(abfd, note),
        2 => {
            return elfcore_make_auxv_note_section(abfd, note, 4 as libc::c_int as size_t);
        }
        24 => {
            return elfcore_make_note_pseudosection(
                abfd,
                b".note.netbsdcore.lwpstatus\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                note,
            );
        }
        _ => {}
    }
    if (*note).type_0 < 32 as libc::c_int as libc::c_ulong {
        return 1 as libc::c_int != 0;
    }
    match bfd_get_arch(abfd) as libc::c_uint {
        81 | 31 | 5 => {
            match (*note).type_0 {
                32 => {
                    return elfcore_make_note_pseudosection(
                        abfd,
                        b".reg\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        note,
                    );
                }
                34 => {
                    return elfcore_make_note_pseudosection(
                        abfd,
                        b".reg2\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        note,
                    );
                }
                _ => return 1 as libc::c_int != 0,
            }
        }
        30 => {
            match (*note).type_0 {
                35 => {
                    return elfcore_make_note_pseudosection(
                        abfd,
                        b".reg\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        note,
                    );
                }
                37 => {
                    return elfcore_make_note_pseudosection(
                        abfd,
                        b".reg2\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        note,
                    );
                }
                _ => return 1 as libc::c_int != 0,
            }
        }
        _ => {
            match (*note).type_0 {
                33 => {
                    return elfcore_make_note_pseudosection(
                        abfd,
                        b".reg\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        note,
                    );
                }
                35 => {
                    return elfcore_make_note_pseudosection(
                        abfd,
                        b".reg2\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        note,
                    );
                }
                _ => return 1 as libc::c_int != 0,
            }
        }
    };
}
unsafe extern "C" fn elfcore_grok_openbsd_procinfo(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    if (*note).descsz <= (0x48 as libc::c_int + 31 as libc::c_int) as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    (*(*(*abfd).tdata.elf_obj_data).core)
        .signal = (Some(
        ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(
        ((*note).descdata as *mut bfd_byte).offset(0x8 as libc::c_int as isize)
            as *const libc::c_void,
    ) as libc::c_int;
    (*(*(*abfd).tdata.elf_obj_data).core)
        .pid = (Some(((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        ((*note).descdata as *mut bfd_byte).offset(0x20 as libc::c_int as isize)
            as *const libc::c_void,
    ) as libc::c_int;
    (*(*(*abfd).tdata.elf_obj_data).core)
        .command = _bfd_elfcore_strndup(
        abfd,
        ((*note).descdata).offset(0x48 as libc::c_int as isize),
        31 as libc::c_int as size_t,
    );
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_grok_openbsd_note(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    if (*note).type_0 == 10 as libc::c_int as libc::c_ulong {
        return elfcore_grok_openbsd_procinfo(abfd, note);
    }
    if (*note).type_0 == 20 as libc::c_int as libc::c_ulong {
        return elfcore_make_note_pseudosection(
            abfd,
            b".reg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            note,
        );
    }
    if (*note).type_0 == 21 as libc::c_int as libc::c_ulong {
        return elfcore_make_note_pseudosection(
            abfd,
            b".reg2\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            note,
        );
    }
    if (*note).type_0 == 22 as libc::c_int as libc::c_ulong {
        return elfcore_make_note_pseudosection(
            abfd,
            b".reg-xfp\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            note,
        );
    }
    if (*note).type_0 == 11 as libc::c_int as libc::c_ulong {
        return elfcore_make_auxv_note_section(abfd, note, 0 as libc::c_int as size_t);
    }
    if (*note).type_0 == 23 as libc::c_int as libc::c_ulong {
        let mut sect: *mut asection = bfd_make_section_anyway_with_flags(
            abfd,
            b".wcookie\0" as *const u8 as *const libc::c_char,
            0x100 as libc::c_int as flagword,
        );
        if sect.is_null() {
            return 0 as libc::c_int != 0;
        }
        (*sect).size = (*note).descsz;
        (*sect).filepos = (*note).descpos as file_ptr;
        (*sect)
            .alignment_power = (1 as libc::c_int
            + bfd_get_arch_size(abfd) / 32 as libc::c_int) as libc::c_uint;
        return 1 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_grok_nto_status(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
    mut tid: *mut libc::c_long,
) -> bool {
    let mut ddata: *mut libc::c_void = (*note).descdata as *mut libc::c_void;
    let mut buf: [libc::c_char; 100] = [0; 100];
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sect: *mut asection = 0 as *mut asection;
    let mut sig: libc::c_short = 0;
    let mut flags: libc::c_uint = 0;
    if (*note).descsz < 16 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int != 0;
    }
    (*(*(*abfd).tdata.elf_obj_data).core)
        .pid = (Some(((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(ddata as *mut bfd_byte as *const libc::c_void) as libc::c_int;
    *tid = (Some(((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (ddata as *mut bfd_byte).offset(4 as libc::c_int as isize) as *const libc::c_void,
    ) as libc::c_long;
    flags = (Some(((*(*abfd).xvec).bfd_getx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (ddata as *mut bfd_byte).offset(8 as libc::c_int as isize) as *const libc::c_void,
    ) as libc::c_uint;
    sig = (Some(((*(*abfd).xvec).bfd_getx16).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(
        (ddata as *mut bfd_byte).offset(14 as libc::c_int as isize)
            as *const libc::c_void,
    ) as libc::c_short;
    if sig as libc::c_int > 0 as libc::c_int {
        (*(*(*abfd).tdata.elf_obj_data).core).signal = sig as libc::c_int;
        (*(*(*abfd).tdata.elf_obj_data).core).lwpid = *tid as libc::c_int;
    }
    if flags & 0x80 as libc::c_int as libc::c_uint != 0 {
        (*(*(*abfd).tdata.elf_obj_data).core).lwpid = *tid as libc::c_int;
    }
    sprintf(
        buf.as_mut_ptr(),
        b".qnx_core_status/%ld\0" as *const u8 as *const libc::c_char,
        *tid,
    );
    name = bfd_alloc(
        abfd,
        (strlen(buf.as_mut_ptr())).wrapping_add(1 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
    if name.is_null() {
        return 0 as libc::c_int != 0;
    }
    strcpy(name, buf.as_mut_ptr());
    sect = bfd_make_section_anyway_with_flags(
        abfd,
        name,
        0x100 as libc::c_int as flagword,
    );
    if sect.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*sect).size = (*note).descsz;
    (*sect).filepos = (*note).descpos as file_ptr;
    (*sect).alignment_power = 2 as libc::c_int as libc::c_uint;
    return elfcore_maybe_make_sect(
        abfd,
        b".qnx_core_status\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        sect,
    );
}
unsafe extern "C" fn elfcore_grok_nto_regs(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
    mut tid: libc::c_long,
    mut base: *mut libc::c_char,
) -> bool {
    let mut buf: [libc::c_char; 100] = [0; 100];
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sect: *mut asection = 0 as *mut asection;
    sprintf(
        buf.as_mut_ptr(),
        b"%s/%ld\0" as *const u8 as *const libc::c_char,
        base,
        tid,
    );
    name = bfd_alloc(
        abfd,
        (strlen(buf.as_mut_ptr())).wrapping_add(1 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
    if name.is_null() {
        return 0 as libc::c_int != 0;
    }
    strcpy(name, buf.as_mut_ptr());
    sect = bfd_make_section_anyway_with_flags(
        abfd,
        name,
        0x100 as libc::c_int as flagword,
    );
    if sect.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*sect).size = (*note).descsz;
    (*sect).filepos = (*note).descpos as file_ptr;
    (*sect).alignment_power = 2 as libc::c_int as libc::c_uint;
    if (*(*(*abfd).tdata.elf_obj_data).core).lwpid as libc::c_long == tid {
        return elfcore_maybe_make_sect(abfd, base, sect);
    }
    return 1 as libc::c_int != 0;
}
unsafe extern "C" fn elfcore_grok_nto_note(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    static mut tid: libc::c_long = 1 as libc::c_int as libc::c_long;
    match (*note).type_0 {
        7 => {
            return elfcore_make_note_pseudosection(
                abfd,
                b".qnx_core_info\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                note,
            );
        }
        8 => return elfcore_grok_nto_status(abfd, note, &mut tid),
        9 => {
            return elfcore_grok_nto_regs(
                abfd,
                note,
                tid,
                b".reg\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
        }
        10 => {
            return elfcore_grok_nto_regs(
                abfd,
                note,
                tid,
                b".reg2\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
        }
        _ => return 1 as libc::c_int != 0,
    };
}
unsafe extern "C" fn elfcore_grok_spu_note(
    mut abfd: *mut bfd,
    mut note: *mut Elf_Internal_Note,
) -> bool {
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sect: *mut asection = 0 as *mut asection;
    let mut len: size_t = 0;
    len = (*note).namesz;
    name = bfd_alloc(abfd, len) as *mut libc::c_char;
    if name.is_null() {
        return 0 as libc::c_int != 0;
    }
    memcpy(name as *mut libc::c_void, (*note).namedata as *const libc::c_void, len);
    *name
        .offset(
            len.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
        ) = '\0' as i32 as libc::c_char;
    sect = bfd_make_section_anyway_with_flags(
        abfd,
        name,
        0x100 as libc::c_int as flagword,
    );
    if sect.is_null() {
        return 0 as libc::c_int != 0;
    }
    (*sect).size = (*note).descsz;
    (*sect).filepos = (*note).descpos as file_ptr;
    (*sect).alignment_power = 1 as libc::c_int as libc::c_uint;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_note(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut name: *const libc::c_char,
    mut type_0: libc::c_int,
    mut input: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut xnp: *mut Elf_External_Note = 0 as *mut Elf_External_Note;
    let mut namesz: size_t = 0;
    let mut newspace: size_t = 0;
    let mut dest: *mut libc::c_char = 0 as *mut libc::c_char;
    namesz = 0 as libc::c_int as size_t;
    if !name.is_null() {
        namesz = (strlen(name)).wrapping_add(1 as libc::c_int as libc::c_ulong);
    }
    newspace = (12 as libc::c_int as libc::c_ulong)
        .wrapping_add(
            namesz.wrapping_add(3 as libc::c_int as libc::c_ulong)
                & -(4 as libc::c_int) as libc::c_ulong,
        )
        .wrapping_add((size + 3 as libc::c_int & -(4 as libc::c_int)) as libc::c_ulong);
    buf = realloc(
        buf as *mut libc::c_void,
        (*bufsiz as libc::c_ulong).wrapping_add(newspace),
    ) as *mut libc::c_char;
    if buf.is_null() {
        return buf;
    }
    dest = buf.offset(*bufsiz as isize);
    *bufsiz = (*bufsiz as libc::c_ulong).wrapping_add(newspace) as libc::c_int
        as libc::c_int;
    xnp = dest as *mut Elf_External_Note;
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(namesz, ((*xnp).namesz).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(size as bfd_vma, ((*xnp).descsz).as_mut_ptr() as *mut libc::c_void);
    (Some(((*(*abfd).xvec).bfd_h_putx32).expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(type_0 as bfd_vma, ((*xnp).type_0).as_mut_ptr() as *mut libc::c_void);
    dest = ((*xnp).name).as_mut_ptr();
    if !name.is_null() {
        memcpy(dest as *mut libc::c_void, name as *const libc::c_void, namesz);
        dest = dest.offset(namesz as isize);
        while namesz & 3 as libc::c_int as libc::c_ulong != 0 {
            let fresh84 = dest;
            dest = dest.offset(1);
            *fresh84 = '\0' as i32 as libc::c_char;
            namesz = namesz.wrapping_add(1);
            namesz;
        }
    }
    memcpy(dest as *mut libc::c_void, input, size as libc::c_ulong);
    dest = dest.offset(size as isize);
    while size & 3 as libc::c_int != 0 {
        let fresh85 = dest;
        dest = dest.offset(1);
        *fresh85 = '\0' as i32 as libc::c_char;
        size += 1;
        size;
    }
    return buf;
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_prpsinfo(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut fname: *const libc::c_char,
    mut psargs: *const libc::c_char,
) -> *mut libc::c_char {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    if ((*bed).elf_backend_write_core_note).is_some() {
        let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
        ret = (Some(
            ((*bed).elf_backend_write_core_note).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(abfd, buf, bufsiz, 3 as libc::c_int, fname, psargs);
        if !ret.is_null() {
            return ret;
        }
    }
    if (*(*bed).s).elfclass as libc::c_int == 1 as libc::c_int {
        let mut data: prpsinfo32_t = elfcore_psinfo32_t {
            pr_state: 0,
            pr_sname: 0,
            pr_zomb: 0,
            pr_nice: 0,
            pr_flag: 0,
            pr_uid: 0,
            pr_gid: 0,
            pr_pid: 0,
            pr_ppid: 0,
            pr_pgrp: 0,
            pr_sid: 0,
            pr_fname: [0; 16],
            pr_psargs: [0; 80],
        };
        let mut note_type: libc::c_int = 3 as libc::c_int;
        memset(
            &mut data as *mut prpsinfo32_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<prpsinfo32_t>() as libc::c_ulong,
        );
        strncpy(
            (data.pr_fname).as_mut_ptr(),
            fname,
            ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        );
        strncpy(
            (data.pr_psargs).as_mut_ptr(),
            psargs,
            ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
        );
        return elfcore_write_note(
            abfd,
            buf,
            bufsiz,
            b"CORE\0" as *const u8 as *const libc::c_char,
            note_type,
            &mut data as *mut prpsinfo32_t as *const libc::c_void,
            ::core::mem::size_of::<prpsinfo32_t>() as libc::c_ulong as libc::c_int,
        );
    } else {
        let mut data_0: prpsinfo_t = elfcore_psinfo_t {
            pr_state: 0,
            pr_sname: 0,
            pr_zomb: 0,
            pr_nice: 0,
            pr_flag: 0,
            pr_uid: 0,
            pr_gid: 0,
            pr_pid: 0,
            pr_ppid: 0,
            pr_pgrp: 0,
            pr_sid: 0,
            pr_fname: [0; 16],
            pr_psargs: [0; 80],
        };
        let mut note_type_0: libc::c_int = 3 as libc::c_int;
        memset(
            &mut data_0 as *mut prpsinfo_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<prpsinfo_t>() as libc::c_ulong,
        );
        strncpy(
            (data_0.pr_fname).as_mut_ptr(),
            fname,
            ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        );
        strncpy(
            (data_0.pr_psargs).as_mut_ptr(),
            psargs,
            ::core::mem::size_of::<[libc::c_char; 80]>() as libc::c_ulong,
        );
        return elfcore_write_note(
            abfd,
            buf,
            bufsiz,
            b"CORE\0" as *const u8 as *const libc::c_char,
            note_type_0,
            &mut data_0 as *mut prpsinfo_t as *const libc::c_void,
            ::core::mem::size_of::<prpsinfo_t>() as libc::c_ulong as libc::c_int,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_linux_prpsinfo32(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut prpsinfo: *const elf_internal_linux_prpsinfo,
) -> *mut libc::c_char {
    if (*((*(*abfd).xvec).backend_data as *const elf_backend_data))
        .linux_prpsinfo32_ugid16() != 0
    {
        let mut data: elf_external_linux_prpsinfo32_ugid16 = elf_external_linux_prpsinfo32_ugid16 {
            pr_state: 0,
            pr_sname: 0,
            pr_zomb: 0,
            pr_nice: 0,
            pr_flag: [0; 4],
            pr_uid: [0; 2],
            pr_gid: [0; 2],
            pr_pid: [0; 4],
            pr_ppid: [0; 4],
            pr_pgrp: [0; 4],
            pr_sid: [0; 4],
            pr_fname: [0; 16],
            pr_psargs: [0; 80],
        };
        swap_linux_prpsinfo32_ugid16_out(abfd, prpsinfo, &mut data);
        return elfcore_write_note(
            abfd,
            buf,
            bufsiz,
            b"CORE\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
            &mut data as *mut elf_external_linux_prpsinfo32_ugid16
                as *const libc::c_void,
            ::core::mem::size_of::<elf_external_linux_prpsinfo32_ugid16>()
                as libc::c_ulong as libc::c_int,
        );
    } else {
        let mut data_0: elf_external_linux_prpsinfo32_ugid32 = elf_external_linux_prpsinfo32_ugid32 {
            pr_state: 0,
            pr_sname: 0,
            pr_zomb: 0,
            pr_nice: 0,
            pr_flag: [0; 4],
            pr_uid: [0; 4],
            pr_gid: [0; 4],
            pr_pid: [0; 4],
            pr_ppid: [0; 4],
            pr_pgrp: [0; 4],
            pr_sid: [0; 4],
            pr_fname: [0; 16],
            pr_psargs: [0; 80],
        };
        swap_linux_prpsinfo32_ugid32_out(abfd, prpsinfo, &mut data_0);
        return elfcore_write_note(
            abfd,
            buf,
            bufsiz,
            b"CORE\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
            &mut data_0 as *mut elf_external_linux_prpsinfo32_ugid32
                as *const libc::c_void,
            ::core::mem::size_of::<elf_external_linux_prpsinfo32_ugid32>()
                as libc::c_ulong as libc::c_int,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_linux_prpsinfo64(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut prpsinfo: *const elf_internal_linux_prpsinfo,
) -> *mut libc::c_char {
    if (*((*(*abfd).xvec).backend_data as *const elf_backend_data))
        .linux_prpsinfo64_ugid16() != 0
    {
        let mut data: elf_external_linux_prpsinfo64_ugid16 = elf_external_linux_prpsinfo64_ugid16 {
            pr_state: 0,
            pr_sname: 0,
            pr_zomb: 0,
            pr_nice: 0,
            gap: [0; 4],
            pr_flag: [0; 8],
            pr_uid: [0; 2],
            pr_gid: [0; 2],
            pr_pid: [0; 4],
            pr_ppid: [0; 4],
            pr_pgrp: [0; 4],
            pr_sid: [0; 4],
            pr_fname: [0; 16],
            pr_psargs: [0; 80],
        };
        swap_linux_prpsinfo64_ugid16_out(abfd, prpsinfo, &mut data);
        return elfcore_write_note(
            abfd,
            buf,
            bufsiz,
            b"CORE\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
            &mut data as *mut elf_external_linux_prpsinfo64_ugid16
                as *const libc::c_void,
            ::core::mem::size_of::<elf_external_linux_prpsinfo64_ugid16>()
                as libc::c_ulong as libc::c_int,
        );
    } else {
        let mut data_0: elf_external_linux_prpsinfo64_ugid32 = elf_external_linux_prpsinfo64_ugid32 {
            pr_state: 0,
            pr_sname: 0,
            pr_zomb: 0,
            pr_nice: 0,
            gap: [0; 4],
            pr_flag: [0; 8],
            pr_uid: [0; 4],
            pr_gid: [0; 4],
            pr_pid: [0; 4],
            pr_ppid: [0; 4],
            pr_pgrp: [0; 4],
            pr_sid: [0; 4],
            pr_fname: [0; 16],
            pr_psargs: [0; 80],
        };
        swap_linux_prpsinfo64_ugid32_out(abfd, prpsinfo, &mut data_0);
        return elfcore_write_note(
            abfd,
            buf,
            bufsiz,
            b"CORE\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
            &mut data_0 as *mut elf_external_linux_prpsinfo64_ugid32
                as *const libc::c_void,
            ::core::mem::size_of::<elf_external_linux_prpsinfo64_ugid32>()
                as libc::c_ulong as libc::c_int,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_prstatus(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut pid: libc::c_long,
    mut cursig: libc::c_int,
    mut gregs: *const libc::c_void,
) -> *mut libc::c_char {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    if ((*bed).elf_backend_write_core_note).is_some() {
        let mut ret: *mut libc::c_char = 0 as *mut libc::c_char;
        ret = (Some(
            ((*bed).elf_backend_write_core_note).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(abfd, buf, bufsiz, 1 as libc::c_int, pid, cursig, gregs);
        if !ret.is_null() {
            return ret;
        }
    }
    if (*(*bed).s).elfclass as libc::c_int == 1 as libc::c_int {
        let mut prstat: prstatus32_t = prstatus32_t {
            pr_info: elf_siginfo {
                si_signo: 0,
                si_code: 0,
                si_errno: 0,
            },
            pr_cursig: 0,
            pr_sigpend: 0,
            pr_sighold: 0,
            pr_pid: 0,
            pr_ppid: 0,
            pr_pgrp: 0,
            pr_sid: 0,
            pr_utime: prstatus32_timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            pr_stime: prstatus32_timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            pr_cutime: prstatus32_timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            pr_cstime: prstatus32_timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            pr_reg: [0; 17],
            pr_fpvalid: 0,
        };
        memset(
            &mut prstat as *mut prstatus32_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<prstatus32_t>() as libc::c_ulong,
        );
        prstat.pr_pid = pid as pid_t;
        prstat.pr_cursig = cursig as libc::c_short;
        memcpy(
            &mut prstat.pr_reg as *mut elf_gregset32_t as *mut libc::c_void,
            gregs,
            ::core::mem::size_of::<elf_gregset32_t>() as libc::c_ulong,
        );
        return elfcore_write_note(
            abfd,
            buf,
            bufsiz,
            b"CORE\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            &mut prstat as *mut prstatus32_t as *const libc::c_void,
            ::core::mem::size_of::<prstatus32_t>() as libc::c_ulong as libc::c_int,
        );
    } else {
        let mut prstat_0: prstatus_t = prstatus_t {
            pr_info: elf_siginfo {
                si_signo: 0,
                si_code: 0,
                si_errno: 0,
            },
            pr_cursig: 0,
            pr_sigpend: 0,
            pr_sighold: 0,
            pr_pid: 0,
            pr_ppid: 0,
            pr_pgrp: 0,
            pr_sid: 0,
            pr_utime: timeval { tv_sec: 0, tv_usec: 0 },
            pr_stime: timeval { tv_sec: 0, tv_usec: 0 },
            pr_cutime: timeval { tv_sec: 0, tv_usec: 0 },
            pr_cstime: timeval { tv_sec: 0, tv_usec: 0 },
            pr_reg: [0; 27],
            pr_fpvalid: 0,
        };
        memset(
            &mut prstat_0 as *mut prstatus_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<prstatus_t>() as libc::c_ulong,
        );
        prstat_0.pr_pid = pid as __pid_t;
        prstat_0.pr_cursig = cursig as libc::c_short;
        memcpy(
            &mut prstat_0.pr_reg as *mut elf_gregset_t as *mut libc::c_void,
            gregs,
            ::core::mem::size_of::<elf_gregset_t>() as libc::c_ulong,
        );
        return elfcore_write_note(
            abfd,
            buf,
            bufsiz,
            b"CORE\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            &mut prstat_0 as *mut prstatus_t as *const libc::c_void,
            ::core::mem::size_of::<prstatus_t>() as libc::c_ulong as libc::c_int,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_prfpreg(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut fpregs: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *const libc::c_char = b"CORE\0" as *const u8
        as *const libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        2 as libc::c_int,
        fpregs,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_prxfpreg(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut xfpregs: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x46e62b7f as libc::c_int,
        xfpregs,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_xstatereg(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut xfpregs: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = 0 as *mut libc::c_char;
    if (*((*(*abfd).xvec).backend_data as *const elf_backend_data)).elf_osabi
        == 9 as libc::c_int
    {
        note_name = b"FreeBSD\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char;
    } else {
        note_name = b"LINUX\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x202 as libc::c_int,
        xfpregs,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_vmx(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_vmx: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x100 as libc::c_int,
        ppc_vmx,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_vsx(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_vsx: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x102 as libc::c_int,
        ppc_vsx,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tar(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tar: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x103 as libc::c_int,
        ppc_tar,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_ppr(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_ppr: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x104 as libc::c_int,
        ppc_ppr,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_dscr(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_dscr: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x105 as libc::c_int,
        ppc_dscr,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_ebb(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_ebb: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x106 as libc::c_int,
        ppc_ebb,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_pmu(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_pmu: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x107 as libc::c_int,
        ppc_pmu,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tm_cgpr(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tm_cgpr: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x108 as libc::c_int,
        ppc_tm_cgpr,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tm_cfpr(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tm_cfpr: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x109 as libc::c_int,
        ppc_tm_cfpr,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tm_cvmx(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tm_cvmx: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x10a as libc::c_int,
        ppc_tm_cvmx,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tm_cvsx(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tm_cvsx: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x10b as libc::c_int,
        ppc_tm_cvsx,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tm_spr(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tm_spr: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x10c as libc::c_int,
        ppc_tm_spr,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tm_ctar(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tm_ctar: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x10d as libc::c_int,
        ppc_tm_ctar,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tm_cppr(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tm_cppr: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x10e as libc::c_int,
        ppc_tm_cppr,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_ppc_tm_cdscr(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut ppc_tm_cdscr: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x10f as libc::c_int,
        ppc_tm_cdscr,
        size,
    );
}
unsafe extern "C" fn elfcore_write_s390_high_gprs(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_high_gprs: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x300 as libc::c_int,
        s390_high_gprs,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_timer(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_timer: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x301 as libc::c_int,
        s390_timer,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_todcmp(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_todcmp: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x302 as libc::c_int,
        s390_todcmp,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_todpreg(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_todpreg: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x303 as libc::c_int,
        s390_todpreg,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_ctrs(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_ctrs: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x304 as libc::c_int,
        s390_ctrs,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_prefix(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_prefix: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x305 as libc::c_int,
        s390_prefix,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_last_break(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_last_break: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x306 as libc::c_int,
        s390_last_break,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_system_call(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_system_call: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x307 as libc::c_int,
        s390_system_call,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_tdb(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_tdb: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x308 as libc::c_int,
        s390_tdb,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_vxrs_low(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_vxrs_low: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x309 as libc::c_int,
        s390_vxrs_low,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_vxrs_high(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_vxrs_high: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x30a as libc::c_int,
        s390_vxrs_high,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_gs_cb(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_gs_cb: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x30b as libc::c_int,
        s390_gs_cb,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_s390_gs_bc(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut s390_gs_bc: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x30c as libc::c_int,
        s390_gs_bc,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_arm_vfp(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut arm_vfp: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x400 as libc::c_int,
        arm_vfp,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_aarch_tls(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut aarch_tls: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x401 as libc::c_int,
        aarch_tls,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_aarch_hw_break(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut aarch_hw_break: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x402 as libc::c_int,
        aarch_hw_break,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_aarch_hw_watch(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut aarch_hw_watch: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x403 as libc::c_int,
        aarch_hw_watch,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_aarch_sve(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut aarch_sve: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x405 as libc::c_int,
        aarch_sve,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_aarch_pauth(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut aarch_pauth: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x406 as libc::c_int,
        aarch_pauth,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_aarch_mte(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut aarch_mte: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x409 as libc::c_int,
        aarch_mte,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_arc_v2(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut arc_v2: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *mut libc::c_char = b"LINUX\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x600 as libc::c_int,
        arc_v2,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_riscv_csr(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut csrs: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *const libc::c_char = b"GDB\0" as *const u8
        as *const libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0x900 as libc::c_int,
        csrs,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_gdb_tdesc(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut tdesc: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    let mut note_name: *const libc::c_char = b"GDB\0" as *const u8
        as *const libc::c_char;
    return elfcore_write_note(
        abfd,
        buf,
        bufsiz,
        note_name,
        0xff000000 as libc::c_uint as libc::c_int,
        tdesc,
        size,
    );
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_register_note(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut bufsiz: *mut libc::c_int,
    mut section: *const libc::c_char,
    mut data: *const libc::c_void,
    mut size: libc::c_int,
) -> *mut libc::c_char {
    if strcmp(section, b".reg2\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_prfpreg(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-xfp\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_prxfpreg(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-xstate\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_xstatereg(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-vmx\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_vmx(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-vsx\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_vsx(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tar\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tar(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-ppr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_ppr(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-dscr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_dscr(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-ebb\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_ebb(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-pmu\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_pmu(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tm-cgpr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tm_cgpr(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tm-cfpr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tm_cfpr(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tm-cvmx\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tm_cvmx(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tm-cvsx\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tm_cvsx(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tm-spr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tm_spr(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tm-ctar\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tm_ctar(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tm-cppr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tm_cppr(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-ppc-tm-cdscr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_ppc_tm_cdscr(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-high-gprs\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_high_gprs(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-timer\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_timer(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-todcmp\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_todcmp(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-todpreg\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_todpreg(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-ctrs\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_ctrs(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-prefix\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_prefix(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-last-break\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_last_break(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-system-call\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_system_call(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-tdb\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_tdb(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-vxrs-low\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_vxrs_low(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-vxrs-high\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_vxrs_high(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-gs-cb\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_gs_cb(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-s390-gs-bc\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_s390_gs_bc(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-arm-vfp\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_arm_vfp(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-aarch-tls\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_aarch_tls(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-aarch-hw-break\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_aarch_hw_break(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-aarch-hw-watch\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_aarch_hw_watch(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-aarch-sve\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_aarch_sve(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-aarch-pauth\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_aarch_pauth(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-aarch-mte\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_aarch_mte(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-arc-v2\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_arc_v2(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".gdb-tdesc\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_gdb_tdesc(abfd, buf, bufsiz, data, size);
    }
    if strcmp(section, b".reg-riscv-csr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return elfcore_write_riscv_csr(abfd, buf, bufsiz, data, size);
    }
    return 0 as *mut libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn elfcore_write_file_note(
    mut obfd: *mut bfd,
    mut note_data: *mut libc::c_char,
    mut note_size: *mut libc::c_int,
    mut buf: *const libc::c_void,
    mut bufsiz: libc::c_int,
) -> *mut libc::c_char {
    return elfcore_write_note(
        obfd,
        note_data,
        note_size,
        b"CORE\0" as *const u8 as *const libc::c_char,
        0x46494c45 as libc::c_int,
        buf,
        bufsiz,
    );
}
unsafe extern "C" fn elf_parse_notes(
    mut abfd: *mut bfd,
    mut buf: *mut libc::c_char,
    mut size: size_t,
    mut offset: file_ptr,
    mut align: size_t,
) -> bool {
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    if align < 4 as libc::c_int as libc::c_ulong {
        align = 4 as libc::c_int as size_t;
    }
    if align != 4 as libc::c_int as libc::c_ulong
        && align != 8 as libc::c_int as libc::c_ulong
    {
        return 0 as libc::c_int != 0;
    }
    p = buf;
    while p < buf.offset(size as isize) {
        let mut xnp: *mut Elf_External_Note = p as *mut Elf_External_Note;
        let mut in_0: Elf_Internal_Note = Elf_Internal_Note {
            namesz: 0,
            descsz: 0,
            type_0: 0,
            namedata: 0 as *mut libc::c_char,
            descdata: 0 as *mut libc::c_char,
            descpos: 0,
        };
        if 12 as libc::c_ulong
            > (buf.offset_from(p) as libc::c_long as libc::c_ulong).wrapping_add(size)
        {
            return 0 as libc::c_int != 0;
        }
        in_0
            .type_0 = (Some(
            ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(((*xnp).type_0).as_mut_ptr() as *const libc::c_void);
        in_0
            .namesz = (Some(
            ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(((*xnp).namesz).as_mut_ptr() as *const libc::c_void);
        in_0.namedata = ((*xnp).name).as_mut_ptr();
        if in_0.namesz
            > (buf.offset_from(in_0.namedata) as libc::c_long as libc::c_ulong)
                .wrapping_add(size)
        {
            return 0 as libc::c_int != 0;
        }
        in_0
            .descsz = (Some(
            ((*(*abfd).xvec).bfd_h_getx32).expect("non-null function pointer"),
        ))
            .expect(
                "non-null function pointer",
            )(((*xnp).descsz).as_mut_ptr() as *const libc::c_void);
        in_0
            .descdata = p
            .offset(
                ((12 as libc::c_ulong)
                    .wrapping_add(in_0.namesz)
                    .wrapping_add(align.wrapping_sub(1 as libc::c_int as libc::c_ulong))
                    & !align.wrapping_sub(1 as libc::c_int as libc::c_ulong)) as isize,
            );
        in_0
            .descpos = (offset + (in_0.descdata).offset_from(buf) as libc::c_long)
            as bfd_vma;
        if in_0.descsz != 0 as libc::c_int as libc::c_ulong
            && (in_0.descdata >= buf.offset(size as isize)
                || in_0.descsz
                    > (buf.offset_from(in_0.descdata) as libc::c_long as libc::c_ulong)
                        .wrapping_add(size))
        {
            return 0 as libc::c_int != 0;
        }
        match bfd_get_format(abfd) as libc::c_uint {
            3 => {
                let mut grokers: [C2RustUnnamed_30; 7] = [
                    {
                        let mut init = C2RustUnnamed_30 {
                            string: b"\0" as *const u8 as *const libc::c_char,
                            len: (::core::mem::size_of::<[libc::c_char; 1]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            func: Some(
                                elfcore_grok_note
                                    as unsafe extern "C" fn(
                                        *mut bfd,
                                        *mut Elf_Internal_Note,
                                    ) -> bool,
                            ),
                        };
                        init
                    },
                    {
                        let mut init = C2RustUnnamed_30 {
                            string: b"FreeBSD\0" as *const u8 as *const libc::c_char,
                            len: (::core::mem::size_of::<[libc::c_char; 8]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            func: Some(
                                elfcore_grok_freebsd_note
                                    as unsafe extern "C" fn(
                                        *mut bfd,
                                        *mut Elf_Internal_Note,
                                    ) -> bool,
                            ),
                        };
                        init
                    },
                    {
                        let mut init = C2RustUnnamed_30 {
                            string: b"NetBSD-CORE\0" as *const u8 as *const libc::c_char,
                            len: (::core::mem::size_of::<[libc::c_char; 12]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            func: Some(
                                elfcore_grok_netbsd_note
                                    as unsafe extern "C" fn(
                                        *mut bfd,
                                        *mut Elf_Internal_Note,
                                    ) -> bool,
                            ),
                        };
                        init
                    },
                    {
                        let mut init = C2RustUnnamed_30 {
                            string: b"OpenBSD\0" as *const u8 as *const libc::c_char,
                            len: (::core::mem::size_of::<[libc::c_char; 8]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            func: Some(
                                elfcore_grok_openbsd_note
                                    as unsafe extern "C" fn(
                                        *mut bfd,
                                        *mut Elf_Internal_Note,
                                    ) -> bool,
                            ),
                        };
                        init
                    },
                    {
                        let mut init = C2RustUnnamed_30 {
                            string: b"QNX\0" as *const u8 as *const libc::c_char,
                            len: (::core::mem::size_of::<[libc::c_char; 4]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            func: Some(
                                elfcore_grok_nto_note
                                    as unsafe extern "C" fn(
                                        *mut bfd,
                                        *mut Elf_Internal_Note,
                                    ) -> bool,
                            ),
                        };
                        init
                    },
                    {
                        let mut init = C2RustUnnamed_30 {
                            string: b"SPU/\0" as *const u8 as *const libc::c_char,
                            len: (::core::mem::size_of::<[libc::c_char; 5]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            func: Some(
                                elfcore_grok_spu_note
                                    as unsafe extern "C" fn(
                                        *mut bfd,
                                        *mut Elf_Internal_Note,
                                    ) -> bool,
                            ),
                        };
                        init
                    },
                    {
                        let mut init = C2RustUnnamed_30 {
                            string: b"GNU\0" as *const u8 as *const libc::c_char,
                            len: (::core::mem::size_of::<[libc::c_char; 4]>()
                                as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                            func: Some(
                                elfobj_grok_gnu_note
                                    as unsafe extern "C" fn(
                                        *mut bfd,
                                        *mut Elf_Internal_Note,
                                    ) -> bool,
                            ),
                        };
                        init
                    },
                ];
                let mut i: libc::c_int = 0;
                i = (::core::mem::size_of::<[C2RustUnnamed_30; 7]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_30>() as libc::c_ulong,
                    ) as libc::c_int;
                loop {
                    let fresh86 = i;
                    i = i - 1;
                    if !(fresh86 != 0) {
                        break;
                    }
                    if !(in_0.namesz >= grokers[i as usize].len
                        && strncmp(
                            in_0.namedata,
                            grokers[i as usize].string,
                            grokers[i as usize].len,
                        ) == 0 as libc::c_int)
                    {
                        continue;
                    }
                    if !(grokers[i as usize].func)
                        .expect("non-null function pointer")(abfd, &mut in_0)
                    {
                        return 0 as libc::c_int != 0;
                    }
                    break;
                }
            }
            1 => {
                if in_0.namesz
                    == ::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong
                    && strcmp(
                        in_0.namedata,
                        b"GNU\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                {
                    if !elfobj_grok_gnu_note(abfd, &mut in_0) {
                        return 0 as libc::c_int != 0;
                    }
                } else if in_0.namesz
                    == ::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong
                    && strcmp(
                        in_0.namedata,
                        b"stapsdt\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                {
                    if !elfobj_grok_stapsdt_note(abfd, &mut in_0) {
                        return 0 as libc::c_int != 0;
                    }
                }
            }
            _ => return 1 as libc::c_int != 0,
        }
        p = p
            .offset(
                (((12 as libc::c_ulong)
                    .wrapping_add(in_0.namesz)
                    .wrapping_add(align.wrapping_sub(1 as libc::c_int as libc::c_ulong))
                    & !align.wrapping_sub(1 as libc::c_int as libc::c_ulong))
                    .wrapping_add(in_0.descsz)
                    .wrapping_add(align.wrapping_sub(1 as libc::c_int as libc::c_ulong))
                    & !align.wrapping_sub(1 as libc::c_int as libc::c_ulong)) as isize,
            );
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn elf_read_notes(
    mut abfd: *mut bfd,
    mut offset: file_ptr,
    mut size: bfd_size_type,
    mut align: size_t,
) -> bool {
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    if size == 0 as libc::c_int as libc::c_ulong
        || size.wrapping_add(1 as libc::c_int as libc::c_ulong)
            == 0 as libc::c_int as libc::c_ulong
    {
        return 1 as libc::c_int != 0;
    }
    if bfd_seek(abfd, offset, 0 as libc::c_int) != 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    buf = _bfd_malloc_and_read(
        abfd,
        size.wrapping_add(1 as libc::c_int as libc::c_ulong),
        size,
    ) as *mut libc::c_char;
    if buf.is_null() {
        return 0 as libc::c_int != 0;
    }
    *buf.offset(size as isize) = 0 as libc::c_int as libc::c_char;
    if !elf_parse_notes(abfd, buf, size, offset, align) {
        free(buf as *mut libc::c_void);
        return 0 as libc::c_int != 0;
    }
    free(buf as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_get_elf_phdr_upper_bound(
    mut abfd: *mut bfd,
) -> libc::c_long {
    if (*(*abfd).xvec).flavour as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        bfd_set_error(bfd_error_wrong_format);
        return -(1 as libc::c_int) as libc::c_long;
    }
    return ((*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum
        as libc::c_ulong)
        .wrapping_mul(::core::mem::size_of::<Elf_Internal_Phdr>() as libc::c_ulong)
        as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn bfd_get_elf_phdrs(
    mut abfd: *mut bfd,
    mut phdrs: *mut libc::c_void,
) -> libc::c_int {
    let mut num_phdrs: libc::c_int = 0;
    if (*(*abfd).xvec).flavour as libc::c_uint
        != bfd_target_elf_flavour as libc::c_int as libc::c_uint
    {
        bfd_set_error(bfd_error_wrong_format);
        return -(1 as libc::c_int);
    }
    num_phdrs = (*((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr()).e_phnum
        as libc::c_int;
    if num_phdrs != 0 as libc::c_int {
        memcpy(
            phdrs,
            (*(*abfd).tdata.elf_obj_data).phdr as *const libc::c_void,
            (num_phdrs as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<Elf_Internal_Phdr>() as libc::c_ulong,
                ),
        );
    }
    return num_phdrs;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_reloc_type_class(
    mut _info: *const bfd_link_info,
    mut _rel_sec: *const asection,
    mut _rela: *const Elf_Internal_Rela,
) -> elf_reloc_type_class {
    return reloc_class_normal;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_rela_local_sym(
    mut abfd: *mut bfd,
    mut sym: *mut Elf_Internal_Sym,
    mut psec: *mut *mut asection,
    mut rel: *mut Elf_Internal_Rela,
) -> bfd_vma {
    let mut sec: *mut asection = *psec;
    let mut relocation: bfd_vma = 0;
    relocation = ((*(*sec).output_section).vma)
        .wrapping_add((*sec).output_offset)
        .wrapping_add((*sym).st_value);
    if (*sec).flags & 0x800000 as libc::c_int as libc::c_uint != 0
        && (*sym).st_info as libc::c_int & 0xf as libc::c_int == 3 as libc::c_int
        && (*sec).sec_info_type() as libc::c_int == 2 as libc::c_int
    {
        (*rel)
            .r_addend = _bfd_merged_section_offset(
            abfd,
            psec,
            (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).sec_info,
            ((*sym).st_value).wrapping_add((*rel).r_addend),
        );
        if sec != *psec {
            if (*sec).flags & 0x8000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
            {
                (*sec).kept_section = *psec;
            }
            sec = *psec;
        }
        (*rel)
            .r_addend = ((*rel).r_addend as libc::c_ulong).wrapping_sub(relocation)
            as bfd_vma as bfd_vma;
        (*rel)
            .r_addend = ((*rel).r_addend as libc::c_ulong)
            .wrapping_add(
                ((*(*sec).output_section).vma).wrapping_add((*sec).output_offset),
            ) as bfd_vma as bfd_vma;
    }
    return relocation;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_rel_local_sym(
    mut abfd: *mut bfd,
    mut sym: *mut Elf_Internal_Sym,
    mut psec: *mut *mut asection,
    mut addend: bfd_vma,
) -> bfd_vma {
    let mut sec: *mut asection = *psec;
    if (*sec).sec_info_type() as libc::c_int != 2 as libc::c_int {
        return ((*sym).st_value).wrapping_add(addend);
    }
    return _bfd_merged_section_offset(
        abfd,
        psec,
        (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).sec_info,
        ((*sym).st_value).wrapping_add(addend),
    );
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_section_offset(
    mut abfd: *mut bfd,
    mut info: *mut bfd_link_info,
    mut sec: *mut asection,
    mut offset: bfd_vma,
) -> bfd_vma {
    match (*sec).sec_info_type() as libc::c_int {
        1 => {
            return _bfd_stab_section_offset(
                sec,
                (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).sec_info,
                offset,
            );
        }
        3 => return _bfd_elf_eh_frame_section_offset(abfd, info, sec, offset),
        _ => {
            if (*sec).flags & 0x4000000 as libc::c_int as libc::c_uint
                != 0 as libc::c_int as libc::c_uint
            {
                let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
                    as *const elf_backend_data;
                let mut address_size: bfd_size_type = ((*(*bed).s).arch_size
                    as libc::c_int / 8 as libc::c_int) as bfd_size_type;
                offset = ((*sec).size)
                    .wrapping_sub(address_size)
                    .wrapping_div(bfd_octets_per_byte(abfd, sec) as libc::c_ulong)
                    .wrapping_sub(offset);
            }
            return offset;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn bfd_elf_bfd_from_remote_memory(
    mut templ: *mut bfd,
    mut ehdr_vma: bfd_vma,
    mut size: bfd_size_type,
    mut loadbasep: *mut bfd_vma,
    mut target_read_memory: Option::<
        unsafe extern "C" fn(bfd_vma, *mut bfd_byte, bfd_size_type) -> libc::c_int,
    >,
) -> *mut bfd {
    return (Some(
        ((*((*(*templ).xvec).backend_data as *const elf_backend_data))
            .elf_backend_bfd_from_remote_memory)
            .expect("non-null function pointer"),
    ))
        .expect(
            "non-null function pointer",
        )(templ, ehdr_vma, size, loadbasep, target_read_memory);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_get_synthetic_symtab(
    mut abfd: *mut bfd,
    mut _symcount: libc::c_long,
    mut _syms: *mut *mut asymbol,
    mut dynsymcount: libc::c_long,
    mut dynsyms: *mut *mut asymbol,
    mut ret: *mut *mut asymbol,
) -> libc::c_long {
    let mut bed: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut relplt: *mut asection = 0 as *mut asection;
    let mut s: *mut asymbol = 0 as *mut asymbol;
    let mut relplt_name: *const libc::c_char = 0 as *const libc::c_char;
    let mut slurp_relocs: Option::<
        unsafe extern "C" fn(*mut bfd, *mut asection, *mut *mut asymbol, bool) -> bool,
    > = None;
    let mut p: *mut arelent = 0 as *mut arelent;
    let mut count: libc::c_long = 0;
    let mut i: libc::c_long = 0;
    let mut n: libc::c_long = 0;
    let mut size: size_t = 0;
    let mut hdr: *mut Elf_Internal_Shdr = 0 as *mut Elf_Internal_Shdr;
    let mut names: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut plt: *mut asection = 0 as *mut asection;
    *ret = 0 as *mut asymbol;
    if (*abfd).flags & (0x40 as libc::c_int | 0x2 as libc::c_int) as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int as libc::c_long;
    }
    if dynsymcount <= 0 as libc::c_int as libc::c_long {
        return 0 as libc::c_int as libc::c_long;
    }
    if ((*bed).plt_sym_val).is_none() {
        return 0 as libc::c_int as libc::c_long;
    }
    relplt_name = (*bed).relplt_name;
    if relplt_name.is_null() {
        relplt_name = if (*bed).rela_plts_and_copies_p() as libc::c_int != 0 {
            b".rela.plt\0" as *const u8 as *const libc::c_char
        } else {
            b".rel.plt\0" as *const u8 as *const libc::c_char
        };
    }
    relplt = bfd_get_section_by_name(abfd, relplt_name);
    if relplt.is_null() {
        return 0 as libc::c_int as libc::c_long;
    }
    hdr = &mut (*((*relplt).used_by_bfd as *mut bfd_elf_section_data)).this_hdr;
    if (*hdr).sh_link != (*(*abfd).tdata.elf_obj_data).dynsymtab_section
        || (*hdr).sh_type != 9 as libc::c_int as libc::c_uint
            && (*hdr).sh_type != 4 as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int as libc::c_long;
    }
    plt = bfd_get_section_by_name(abfd, b".plt\0" as *const u8 as *const libc::c_char);
    if plt.is_null() {
        return 0 as libc::c_int as libc::c_long;
    }
    slurp_relocs = (*(*((*(*abfd).xvec).backend_data as *const elf_backend_data)).s)
        .slurp_reloc_table;
    if !(Some(slurp_relocs.expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(abfd, relplt, dynsyms, 1 as libc::c_int != 0)
    {
        return -(1 as libc::c_int) as libc::c_long;
    }
    count = ((*relplt).size).wrapping_div((*hdr).sh_entsize) as libc::c_long;
    size = (count as libc::c_ulong)
        .wrapping_mul(::core::mem::size_of::<asymbol>() as libc::c_ulong);
    p = (*relplt).relocation;
    i = 0 as libc::c_int as libc::c_long;
    while i < count {
        size = (size as libc::c_ulong)
            .wrapping_add(
                (strlen((**(*p).sym_ptr_ptr).name))
                    .wrapping_add(
                        ::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong,
                    ),
            ) as size_t as size_t;
        if (*p).addend != 0 as libc::c_int as libc::c_ulong {
            size = (size as libc::c_ulong)
                .wrapping_add(
                    (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                        .wrapping_add(8 as libc::c_int as libc::c_ulong)
                        .wrapping_add(
                            (8 as libc::c_int
                                * ((*(*bed).s).elfclass as libc::c_int == 2 as libc::c_int)
                                    as libc::c_int) as libc::c_ulong,
                        ),
                ) as size_t as size_t;
        }
        i += 1;
        i;
        p = p.offset((*(*bed).s).int_rels_per_ext_rel as libc::c_int as isize);
    }
    *ret = bfd_malloc(size) as *mut asymbol;
    s = *ret;
    if s.is_null() {
        return -(1 as libc::c_int) as libc::c_long;
    }
    names = s.offset(count as isize) as *mut libc::c_char;
    p = (*relplt).relocation;
    n = 0 as libc::c_int as libc::c_long;
    i = 0 as libc::c_int as libc::c_long;
    while i < count {
        let mut len: size_t = 0;
        let mut addr: bfd_vma = 0;
        addr = ((*bed).plt_sym_val)
            .expect("non-null function pointer")(i as bfd_vma, plt, p);
        if !(addr == -(1 as libc::c_int) as bfd_vma) {
            *s = **(*p).sym_ptr_ptr;
            if (*s).flags & ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
            {
                (*s).flags |= ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_uint;
            }
            (*s).flags |= ((1 as libc::c_int) << 21 as libc::c_int) as libc::c_uint;
            (*s).section = plt;
            (*s).value = addr.wrapping_sub((*plt).vma);
            (*s).name = names;
            (*s).udata.p = 0 as *mut libc::c_void;
            len = strlen((**(*p).sym_ptr_ptr).name);
            memcpy(
                names as *mut libc::c_void,
                (**(*p).sym_ptr_ptr).name as *const libc::c_void,
                len,
            );
            names = names.offset(len as isize);
            if (*p).addend != 0 as libc::c_int as libc::c_ulong {
                let mut buf: [libc::c_char; 30] = [0; 30];
                let mut a: *mut libc::c_char = 0 as *mut libc::c_char;
                memcpy(
                    names as *mut libc::c_void,
                    b"+0x\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                );
                names = names
                    .offset(
                        (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                    );
                bfd_sprintf_vma(abfd, buf.as_mut_ptr(), (*p).addend);
                a = buf.as_mut_ptr();
                while *a as libc::c_int == '0' as i32 {
                    a = a.offset(1);
                    a;
                }
                len = strlen(a);
                memcpy(names as *mut libc::c_void, a as *const libc::c_void, len);
                names = names.offset(len as isize);
            }
            memcpy(
                names as *mut libc::c_void,
                b"@plt\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                ::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong,
            );
            names = names
                .offset(
                    ::core::mem::size_of::<[libc::c_char; 5]>() as libc::c_ulong as isize,
                );
            s = s.offset(1);
            s;
            n += 1;
            n;
        }
        i += 1;
        i;
        p = p.offset((*(*bed).s).int_rels_per_ext_rel as libc::c_int as isize);
    }
    return n;
}
static mut lcomm_sym: asymbol = unsafe {
    {
        let mut init = bfd_symbol {
            the_bfd: 0 as *const bfd as *mut bfd,
            name: b"LARGE_COMMON\0" as *const u8 as *const libc::c_char,
            value: 0 as libc::c_int as symvalue,
            flags: ((1 as libc::c_int) << 8 as libc::c_int) as flagword,
            section: &_bfd_elf_large_com_section as *const asection as *mut asection,
            udata: C2RustUnnamed_6 {
                p: 0 as *const libc::c_void as *mut libc::c_void,
            },
        };
        init
    }
};
#[no_mangle]
pub static mut _bfd_elf_large_com_section: asection = asection {
    name: 0 as *const libc::c_char,
    id: 0,
    section_id: 0,
    index: 0,
    next: 0 as *const bfd_section as *mut bfd_section,
    prev: 0 as *const bfd_section as *mut bfd_section,
    flags: 0,
    user_set_vma_linker_mark_linker_has_input_gc_mark_compress_status_segment_mark_sec_info_type_use_rela_p_sec_flg0_sec_flg1_sec_flg2_sec_flg3_sec_flg4_sec_flg5: [0; 3],
    c2rust_padding: [0; 1],
    vma: 0,
    lma: 0,
    size: 0,
    rawsize: 0,
    compressed_size: 0,
    relax: 0 as *const relax_table as *mut relax_table,
    relax_count: 0,
    output_offset: 0,
    output_section: 0 as *const bfd_section as *mut bfd_section,
    alignment_power: 0,
    relocation: 0 as *const reloc_cache_entry as *mut reloc_cache_entry,
    orelocation: 0 as *const *mut reloc_cache_entry as *mut *mut reloc_cache_entry,
    reloc_count: 0,
    filepos: 0,
    rel_filepos: 0,
    line_filepos: 0,
    userdata: 0 as *const libc::c_void as *mut libc::c_void,
    contents: 0 as *const libc::c_uchar as *mut libc::c_uchar,
    lineno: 0 as *const alent as *mut alent,
    lineno_count: 0,
    entsize: 0,
    kept_section: 0 as *const bfd_section as *mut bfd_section,
    moving_line_filepos: 0,
    target_index: 0,
    used_by_bfd: 0 as *const libc::c_void as *mut libc::c_void,
    constructor_chain: 0 as *const relent_chain as *mut relent_chain,
    owner: 0 as *const bfd as *mut bfd,
    symbol: 0 as *const bfd_symbol as *mut bfd_symbol,
    symbol_ptr_ptr: 0 as *const *mut bfd_symbol as *mut *mut bfd_symbol,
    map_head: C2RustUnnamed_0 {
        link_order: 0 as *const bfd_link_order as *mut bfd_link_order,
    },
    map_tail: C2RustUnnamed_0 {
        link_order: 0 as *const bfd_link_order as *mut bfd_link_order,
    },
    already_assigned: 0 as *const bfd_section as *mut bfd_section,
};
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_final_write_processing(mut abfd: *mut bfd) -> bool {
    let mut i_ehdrp: *mut Elf_Internal_Ehdr = 0 as *mut Elf_Internal_Ehdr;
    i_ehdrp = ((*(*abfd).tdata.elf_obj_data).elf_header).as_mut_ptr();
    if (*i_ehdrp).e_ident[7 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
        (*i_ehdrp)
            .e_ident[7 as libc::c_int
            as usize] = (*((*(*abfd).xvec).backend_data as *const elf_backend_data))
            .elf_osabi as libc::c_uchar;
    }
    if (*(*abfd).tdata.elf_obj_data).has_gnu_osabi() as libc::c_int != 0 as libc::c_int {
        if (*i_ehdrp).e_ident[7 as libc::c_int as usize] as libc::c_int
            == 0 as libc::c_int
        {
            (*i_ehdrp)
                .e_ident[7 as libc::c_int as usize] = 3 as libc::c_int as libc::c_uchar;
        } else if (*i_ehdrp).e_ident[7 as libc::c_int as usize] as libc::c_int
            != 3 as libc::c_int
            && (*i_ehdrp).e_ident[7 as libc::c_int as usize] as libc::c_int
                != 9 as libc::c_int
        {
            if (*(*abfd).tdata.elf_obj_data).has_gnu_osabi() as libc::c_int
                & elf_gnu_osabi_mbind as libc::c_int != 0
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"GNU_MBIND section is supported only by GNU and FreeBSD targets\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            if (*(*abfd).tdata.elf_obj_data).has_gnu_osabi() as libc::c_int
                & elf_gnu_osabi_ifunc as libc::c_int != 0
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"symbol type STT_GNU_IFUNC is supported only by GNU and FreeBSD targets\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            if (*(*abfd).tdata.elf_obj_data).has_gnu_osabi() as libc::c_int
                & elf_gnu_osabi_unique as libc::c_int != 0
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"symbol binding STB_GNU_UNIQUE is supported only by GNU and FreeBSD targets\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            if (*(*abfd).tdata.elf_obj_data).has_gnu_osabi() as libc::c_int
                & elf_gnu_osabi_retain as libc::c_int != 0
            {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"GNU_RETAIN section is supported only by GNU and FreeBSD targets\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                );
            }
            bfd_set_error(bfd_error_sorry);
            return 0 as libc::c_int != 0;
        }
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_is_function_type(mut type_0: libc::c_uint) -> bool {
    return type_0 == 2 as libc::c_int as libc::c_uint
        || type_0 == 10 as libc::c_int as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_maybe_function_sym(
    mut sym: *const asymbol,
    mut sec: *mut asection,
    mut code_off: *mut bfd_vma,
) -> bfd_size_type {
    let mut size: bfd_size_type = 0;
    let mut elf_sym: *mut elf_symbol_type = sym as *mut elf_symbol_type;
    if (*sym).flags
        & ((1 as libc::c_int) << 8 as libc::c_int
            | (1 as libc::c_int) << 14 as libc::c_int
            | (1 as libc::c_int) << 16 as libc::c_int
            | (1 as libc::c_int) << 18 as libc::c_int
            | (1 as libc::c_int) << 19 as libc::c_int
            | (1 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
        != 0 as libc::c_int as libc::c_uint || (*sym).section != sec
    {
        return 0 as libc::c_int as bfd_size_type;
    }
    size = if (*sym).flags & ((1 as libc::c_int) << 21 as libc::c_int) as libc::c_uint
        != 0
    {
        0 as libc::c_int as libc::c_ulong
    } else {
        (*elf_sym).internal_elf_sym.st_size
    };
    if size == 0 as libc::c_int as libc::c_ulong
        && (*sym).flags
            & ((1 as libc::c_int) << 21 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint
            == ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_uint
        && (*elf_sym).internal_elf_sym.st_info as libc::c_int & 0xf as libc::c_int
            == 0 as libc::c_int
        && (*elf_sym).internal_elf_sym.st_other as libc::c_int & 0x3 as libc::c_int
            == 2 as libc::c_int
    {
        return 0 as libc::c_int as bfd_size_type;
    }
    *code_off = (*sym).value;
    return if size != 0 { size } else { 1 as libc::c_int as libc::c_ulong };
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_init_secondary_reloc_section(
    mut abfd: *mut bfd,
    mut hdr: *mut Elf_Internal_Shdr,
    mut name: *const libc::c_char,
    mut shindex: libc::c_uint,
) -> bool {
    if (*hdr).sh_type != 4 as libc::c_int as libc::c_uint {
        return 0 as libc::c_int != 0;
    }
    (*hdr).sh_type = (0x60000000 as libc::c_int + 4 as libc::c_int) as libc::c_uint;
    return _bfd_elf_make_section_from_shdr(abfd, hdr, name, shindex as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_slurp_secondary_reloc_section(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
    mut symbols: *mut *mut asymbol,
    mut dynamic: bool,
) -> bool {
    let ebd: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut relsec: *mut asection = 0 as *mut asection;
    let mut result: bool = 1 as libc::c_int != 0;
    let mut r_sym: Option::<unsafe extern "C" fn(bfd_vma) -> bfd_vma> = None;
    if bfd_arch_bits_per_address(abfd) != 32 as libc::c_int as libc::c_uint {
        r_sym = Some(elf64_r_sym as unsafe extern "C" fn(bfd_vma) -> bfd_vma);
    } else {
        r_sym = Some(elf32_r_sym as unsafe extern "C" fn(bfd_vma) -> bfd_vma);
    }
    if !(*((*sec).used_by_bfd as *mut bfd_elf_section_data)).has_secondary_relocs {
        return 1 as libc::c_int != 0;
    }
    relsec = (*abfd).sections;
    while !relsec.is_null() {
        let mut hdr: *mut Elf_Internal_Shdr = &mut (*((*relsec).used_by_bfd
            as *mut bfd_elf_section_data))
            .this_hdr;
        if (*hdr).sh_type
            == (0x60000000 as libc::c_int + 4 as libc::c_int) as libc::c_uint
            && (*hdr).sh_info
                == (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).this_idx
                    as libc::c_uint
            && ((*hdr).sh_entsize == (*(*ebd).s).sizeof_rel as libc::c_ulong
                || (*hdr).sh_entsize == (*(*ebd).s).sizeof_rela as libc::c_ulong)
        {
            let mut native_relocs: *mut bfd_byte = 0 as *mut bfd_byte;
            let mut native_reloc: *mut bfd_byte = 0 as *mut bfd_byte;
            let mut internal_relocs: *mut arelent = 0 as *mut arelent;
            let mut internal_reloc: *mut arelent = 0 as *mut arelent;
            let mut i: libc::c_uint = 0;
            let mut entsize: libc::c_uint = 0;
            let mut symcount: libc::c_uint = 0;
            let mut reloc_count: libc::c_uint = 0;
            let mut amt: size_t = 0;
            if ((*ebd).elf_info_to_howto).is_none() {
                return 0 as libc::c_int != 0;
            }
            entsize = (*hdr).sh_entsize as libc::c_uint;
            native_relocs = bfd_malloc((*hdr).sh_size) as *mut bfd_byte;
            if native_relocs.is_null() {
                result = 0 as libc::c_int != 0;
            } else {
                reloc_count = (if (*hdr).sh_entsize > 0 as libc::c_int as libc::c_ulong {
                    ((*hdr).sh_size).wrapping_div((*hdr).sh_entsize)
                } else {
                    0 as libc::c_int as libc::c_ulong
                }) as libc::c_uint;
                amt = reloc_count as size_t;
                amt = (amt as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<arelent>() as libc::c_ulong)
                    as size_t as size_t;
                if ::core::mem::size_of::<arelent>() as libc::c_ulong
                    != 0 as libc::c_int as libc::c_ulong
                    && amt
                        .wrapping_div(::core::mem::size_of::<arelent>() as libc::c_ulong)
                        != reloc_count as libc::c_ulong
                {
                    free(native_relocs as *mut libc::c_void);
                    bfd_set_error(bfd_error_file_too_big);
                    result = 0 as libc::c_int != 0;
                } else {
                    internal_relocs = bfd_alloc(abfd, amt) as *mut arelent;
                    if internal_relocs.is_null() {
                        free(native_relocs as *mut libc::c_void);
                        result = 0 as libc::c_int != 0;
                    } else if bfd_seek(abfd, (*hdr).sh_offset, 0 as libc::c_int)
                        != 0 as libc::c_int
                        || bfd_bread(
                            native_relocs as *mut libc::c_void,
                            (*hdr).sh_size,
                            abfd,
                        ) != (*hdr).sh_size
                    {
                        free(native_relocs as *mut libc::c_void);
                        result = 0 as libc::c_int != 0;
                    } else {
                        if dynamic {
                            symcount = bfd_get_dynamic_symcount(abfd);
                        } else {
                            symcount = bfd_get_symcount(abfd);
                        }
                        i = 0 as libc::c_int as libc::c_uint;
                        internal_reloc = internal_relocs;
                        native_reloc = native_relocs;
                        while i < reloc_count {
                            let mut res: bool = false;
                            let mut rela: Elf_Internal_Rela = Elf_Internal_Rela {
                                r_offset: 0,
                                r_info: 0,
                                r_addend: 0,
                            };
                            if entsize == (*(*ebd).s).sizeof_rel as libc::c_uint {
                                ((*(*ebd).s).swap_reloc_in)
                                    .expect(
                                        "non-null function pointer",
                                    )(abfd, native_reloc, &mut rela);
                            } else {
                                ((*(*ebd).s).swap_reloca_in)
                                    .expect(
                                        "non-null function pointer",
                                    )(abfd, native_reloc, &mut rela);
                            }
                            if (*abfd).flags
                                & (0x2 as libc::c_int | 0x40 as libc::c_int) as libc::c_uint
                                == 0 as libc::c_int as libc::c_uint
                            {
                                (*internal_reloc).address = rela.r_offset;
                            } else {
                                (*internal_reloc)
                                    .address = (rela.r_offset).wrapping_sub((*sec).vma);
                            }
                            if r_sym.expect("non-null function pointer")(rela.r_info)
                                == 0 as libc::c_int as libc::c_ulong
                            {
                                (*internal_reloc)
                                    .sym_ptr_ptr = _bfd_std_section[2 as libc::c_int as usize]
                                    .symbol_ptr_ptr;
                            } else if r_sym
                                .expect("non-null function pointer")(rela.r_info)
                                > symcount as libc::c_ulong
                            {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB(%pA): relocation %d has invalid symbol index %ld\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    sec,
                                    i,
                                    r_sym.expect("non-null function pointer")(rela.r_info)
                                        as libc::c_long,
                                );
                                bfd_set_error(bfd_error_bad_value);
                                (*internal_reloc)
                                    .sym_ptr_ptr = _bfd_std_section[2 as libc::c_int as usize]
                                    .symbol_ptr_ptr;
                                result = 0 as libc::c_int != 0;
                            } else {
                                let mut ps: *mut *mut asymbol = 0 as *mut *mut asymbol;
                                ps = symbols
                                    .offset(
                                        r_sym.expect("non-null function pointer")(rela.r_info)
                                            as isize,
                                    )
                                    .offset(-(1 as libc::c_int as isize));
                                (*internal_reloc).sym_ptr_ptr = ps;
                                (**ps).flags
                                    |= ((1 as libc::c_int) << 5 as libc::c_int) as libc::c_uint;
                            }
                            (*internal_reloc).addend = rela.r_addend;
                            res = ((*ebd).elf_info_to_howto)
                                .expect(
                                    "non-null function pointer",
                                )(abfd, internal_reloc, &mut rela);
                            if !res || ((*internal_reloc).howto).is_null() {
                                result = 0 as libc::c_int != 0;
                            }
                            i = i.wrapping_add(1);
                            i;
                            internal_reloc = internal_reloc.offset(1);
                            internal_reloc;
                            native_reloc = native_reloc.offset(entsize as isize);
                        }
                        free(native_relocs as *mut libc::c_void);
                        let ref mut fresh87 = (*((*relsec).used_by_bfd
                            as *mut bfd_elf_section_data))
                            .sec_info;
                        *fresh87 = internal_relocs as *mut libc::c_void;
                    }
                }
            }
        }
        relsec = (*relsec).next;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_copy_special_section_fields(
    mut ibfd: *const bfd,
    mut obfd: *mut bfd,
    mut isection: *const Elf_Internal_Shdr,
    mut osection: *mut Elf_Internal_Shdr,
) -> bool {
    let mut isec: *mut asection = 0 as *mut asection;
    let mut osec: *mut asection = 0 as *mut asection;
    let mut esd: *mut bfd_elf_section_data = 0 as *mut bfd_elf_section_data;
    if isection.is_null() {
        return 0 as libc::c_int != 0;
    }
    if (*isection).sh_type
        != (0x60000000 as libc::c_int + 4 as libc::c_int) as libc::c_uint
    {
        return 1 as libc::c_int != 0;
    }
    isec = (*isection).bfd_section;
    if isec.is_null() {
        return 0 as libc::c_int != 0;
    }
    osec = (*osection).bfd_section;
    if osec.is_null() {
        return 0 as libc::c_int != 0;
    }
    esd = (*osec).used_by_bfd as *mut bfd_elf_section_data;
    if !((*esd).sec_info).is_null() {
        bfd_assert(b"elf.c\0" as *const u8 as *const libc::c_char, 12916 as libc::c_int);
    }
    (*esd).sec_info = (*((*isec).used_by_bfd as *mut bfd_elf_section_data)).sec_info;
    (*osection).sh_type = 4 as libc::c_int as libc::c_uint;
    (*osection).sh_link = (*(*obfd).tdata.elf_obj_data).symtab_section;
    if (*osection).sh_link == 0 as libc::c_int as libc::c_uint {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB(%pA): link section cannot be set because the output file does not have a symbol table\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            obfd,
            osec,
        );
        bfd_set_error(bfd_error_bad_value);
        return 0 as libc::c_int != 0;
    }
    if (*isection).sh_info == 0 as libc::c_int as libc::c_uint
        || (*isection).sh_info >= (*(*ibfd).tdata.elf_obj_data).num_elf_sections
    {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB(%pA): info section index is invalid\0" as *const u8
                    as *const libc::c_char,
                5 as libc::c_int,
            ),
            obfd,
            osec,
        );
        bfd_set_error(bfd_error_bad_value);
        return 0 as libc::c_int != 0;
    }
    isection = *((*(*ibfd).tdata.elf_obj_data).elf_sect_ptr)
        .offset((*isection).sh_info as isize);
    if isection.is_null() || ((*isection).bfd_section).is_null()
        || ((*(*isection).bfd_section).output_section).is_null()
    {
        _bfd_error_handler(
            dcgettext(
                b"bfd\0" as *const u8 as *const libc::c_char,
                b"%pB(%pA): info section index cannot be set because the section is not in the output\0"
                    as *const u8 as *const libc::c_char,
                5 as libc::c_int,
            ),
            obfd,
            osec,
        );
        bfd_set_error(bfd_error_bad_value);
        return 0 as libc::c_int != 0;
    }
    esd = (*(*(*isection).bfd_section).output_section).used_by_bfd
        as *mut bfd_elf_section_data;
    if esd.is_null() {
        bfd_assert(b"elf.c\0" as *const u8 as *const libc::c_char, 12958 as libc::c_int);
    }
    (*osection).sh_info = (*esd).this_idx as libc::c_uint;
    (*esd).has_secondary_relocs = 1 as libc::c_int != 0;
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn _bfd_elf_write_secondary_reloc_section(
    mut abfd: *mut bfd,
    mut sec: *mut asection,
) -> bool {
    let ebd: *const elf_backend_data = (*(*abfd).xvec).backend_data
        as *const elf_backend_data;
    let mut addr_offset: bfd_vma = 0;
    let mut relsec: *mut asection = 0 as *mut asection;
    let mut r_info: Option::<unsafe extern "C" fn(bfd_vma, bfd_vma) -> bfd_vma> = None;
    let mut result: bool = 1 as libc::c_int != 0;
    if sec.is_null() {
        return 0 as libc::c_int != 0;
    }
    if bfd_arch_bits_per_address(abfd) != 32 as libc::c_int as libc::c_uint {
        r_info = Some(elf64_r_info as unsafe extern "C" fn(bfd_vma, bfd_vma) -> bfd_vma);
    } else {
        r_info = Some(elf32_r_info as unsafe extern "C" fn(bfd_vma, bfd_vma) -> bfd_vma);
    }
    addr_offset = 0 as libc::c_int as bfd_vma;
    if (*abfd).flags & (0x2 as libc::c_int | 0x40 as libc::c_int) as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        addr_offset = (*sec).vma;
    }
    relsec = (*abfd).sections;
    while !relsec.is_null() {
        let esd: *const bfd_elf_section_data = (*relsec).used_by_bfd
            as *mut bfd_elf_section_data;
        let hdr: *mut Elf_Internal_Shdr = &(*esd).this_hdr as *const Elf_Internal_Shdr
            as *mut Elf_Internal_Shdr;
        if (*hdr).sh_type == 4 as libc::c_int as libc::c_uint
            && (*hdr).sh_info
                == (*((*sec).used_by_bfd as *mut bfd_elf_section_data)).this_idx
                    as libc::c_uint
        {
            let mut last_sym: *mut asymbol = 0 as *mut asymbol;
            let mut last_sym_idx: libc::c_int = 0;
            let mut reloc_count: libc::c_uint = 0;
            let mut idx: libc::c_uint = 0;
            let mut entsize: libc::c_uint = 0;
            let mut src_irel: *mut arelent = 0 as *mut arelent;
            let mut dst_rela: *mut bfd_byte = 0 as *mut bfd_byte;
            if !((*hdr).contents).is_null() {
                _bfd_error_handler(
                    dcgettext(
                        b"bfd\0" as *const u8 as *const libc::c_char,
                        b"%pB(%pA): error: secondary reloc section processed twice\0"
                            as *const u8 as *const libc::c_char,
                        5 as libc::c_int,
                    ),
                    abfd,
                    relsec,
                );
                bfd_set_error(bfd_error_bad_value);
                result = 0 as libc::c_int != 0;
            } else {
                entsize = (*hdr).sh_entsize as libc::c_uint;
                if entsize == 0 as libc::c_int as libc::c_uint {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB(%pA): error: secondary reloc section has zero sized entries\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        relsec,
                    );
                    bfd_set_error(bfd_error_bad_value);
                    result = 0 as libc::c_int != 0;
                } else if entsize != (*(*ebd).s).sizeof_rel as libc::c_uint
                    && entsize != (*(*ebd).s).sizeof_rela as libc::c_uint
                {
                    _bfd_error_handler(
                        dcgettext(
                            b"bfd\0" as *const u8 as *const libc::c_char,
                            b"%pB(%pA): error: secondary reloc section has non-standard sized entries\0"
                                as *const u8 as *const libc::c_char,
                            5 as libc::c_int,
                        ),
                        abfd,
                        relsec,
                    );
                    bfd_set_error(bfd_error_bad_value);
                    result = 0 as libc::c_int != 0;
                } else {
                    reloc_count = ((*hdr).sh_size).wrapping_div(entsize as libc::c_ulong)
                        as libc::c_uint;
                    if reloc_count <= 0 as libc::c_int as libc::c_uint {
                        _bfd_error_handler(
                            dcgettext(
                                b"bfd\0" as *const u8 as *const libc::c_char,
                                b"%pB(%pA): error: secondary reloc section is empty!\0"
                                    as *const u8 as *const libc::c_char,
                                5 as libc::c_int,
                            ),
                            abfd,
                            relsec,
                        );
                        bfd_set_error(bfd_error_bad_value);
                        result = 0 as libc::c_int != 0;
                    } else {
                        (*hdr)
                            .contents = bfd_alloc(abfd, (*hdr).sh_size)
                            as *mut libc::c_uchar;
                        if !((*hdr).contents).is_null() {
                            last_sym = 0 as *mut asymbol;
                            last_sym_idx = 0 as libc::c_int;
                            dst_rela = (*hdr).contents;
                            src_irel = (*esd).sec_info as *mut arelent;
                            if src_irel.is_null() {
                                _bfd_error_handler(
                                    dcgettext(
                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                        b"%pB(%pA): error: internal relocs missing for secondary reloc section\0"
                                            as *const u8 as *const libc::c_char,
                                        5 as libc::c_int,
                                    ),
                                    abfd,
                                    relsec,
                                );
                                bfd_set_error(bfd_error_bad_value);
                                result = 0 as libc::c_int != 0;
                            } else {
                                idx = 0 as libc::c_int as libc::c_uint;
                                while idx < reloc_count {
                                    let mut src_rela: Elf_Internal_Rela = Elf_Internal_Rela {
                                        r_offset: 0,
                                        r_info: 0,
                                        r_addend: 0,
                                    };
                                    let mut ptr: *mut arelent = 0 as *mut arelent;
                                    let mut sym: *mut asymbol = 0 as *mut asymbol;
                                    let mut n: libc::c_int = 0;
                                    ptr = src_irel.offset(idx as isize);
                                    if ptr.is_null() {
                                        _bfd_error_handler(
                                            dcgettext(
                                                b"bfd\0" as *const u8 as *const libc::c_char,
                                                b"%pB(%pA): error: reloc table entry %u is empty\0"
                                                    as *const u8 as *const libc::c_char,
                                                5 as libc::c_int,
                                            ),
                                            abfd,
                                            relsec,
                                            idx,
                                        );
                                        bfd_set_error(bfd_error_bad_value);
                                        result = 0 as libc::c_int != 0;
                                        break;
                                    } else {
                                        if ((*ptr).sym_ptr_ptr).is_null() {
                                            n = 0 as libc::c_int;
                                        } else {
                                            sym = *(*ptr).sym_ptr_ptr;
                                            if sym == last_sym {
                                                n = last_sym_idx;
                                            } else {
                                                n = _bfd_elf_symbol_from_bfd_symbol(abfd, &mut sym);
                                                if n < 0 as libc::c_int {
                                                    _bfd_error_handler(
                                                        dcgettext(
                                                            b"bfd\0" as *const u8 as *const libc::c_char,
                                                            b"%pB(%pA): error: secondary reloc %u references a missing symbol\0"
                                                                as *const u8 as *const libc::c_char,
                                                            5 as libc::c_int,
                                                        ),
                                                        abfd,
                                                        relsec,
                                                        idx,
                                                    );
                                                    bfd_set_error(bfd_error_bad_value);
                                                    result = 0 as libc::c_int != 0;
                                                    n = 0 as libc::c_int;
                                                }
                                                last_sym = sym;
                                                last_sym_idx = n;
                                            }
                                            if !((*sym).the_bfd).is_null()
                                                && (*(*sym).the_bfd).xvec != (*abfd).xvec
                                                && !_bfd_elf_validate_reloc(abfd, ptr)
                                            {
                                                _bfd_error_handler(
                                                    dcgettext(
                                                        b"bfd\0" as *const u8 as *const libc::c_char,
                                                        b"%pB(%pA): error: secondary reloc %u references a deleted symbol\0"
                                                            as *const u8 as *const libc::c_char,
                                                        5 as libc::c_int,
                                                    ),
                                                    abfd,
                                                    relsec,
                                                    idx,
                                                );
                                                bfd_set_error(bfd_error_bad_value);
                                                result = 0 as libc::c_int != 0;
                                                n = 0 as libc::c_int;
                                            }
                                        }
                                        src_rela
                                            .r_offset = ((*ptr).address).wrapping_add(addr_offset);
                                        if ((*ptr).howto).is_null() {
                                            _bfd_error_handler(
                                                dcgettext(
                                                    b"bfd\0" as *const u8 as *const libc::c_char,
                                                    b"%pB(%pA): error: secondary reloc %u is of an unknown type\0"
                                                        as *const u8 as *const libc::c_char,
                                                    5 as libc::c_int,
                                                ),
                                                abfd,
                                                relsec,
                                                idx,
                                            );
                                            bfd_set_error(bfd_error_bad_value);
                                            result = 0 as libc::c_int != 0;
                                            src_rela
                                                .r_info = r_info
                                                .expect(
                                                    "non-null function pointer",
                                                )(0 as libc::c_int as bfd_vma, 0 as libc::c_int as bfd_vma);
                                        } else {
                                            src_rela
                                                .r_info = r_info
                                                .expect(
                                                    "non-null function pointer",
                                                )(n as bfd_vma, (*(*ptr).howto).type_0 as bfd_vma);
                                        }
                                        src_rela.r_addend = (*ptr).addend;
                                        if entsize == (*(*ebd).s).sizeof_rel as libc::c_uint {
                                            ((*(*ebd).s).swap_reloc_out)
                                                .expect(
                                                    "non-null function pointer",
                                                )(abfd, &mut src_rela, dst_rela);
                                        } else {
                                            ((*(*ebd).s).swap_reloca_out)
                                                .expect(
                                                    "non-null function pointer",
                                                )(abfd, &mut src_rela, dst_rela);
                                        }
                                        idx = idx.wrapping_add(1);
                                        idx;
                                        dst_rela = dst_rela.offset(entsize as isize);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        relsec = (*relsec).next;
    }
    return result;
}
unsafe extern "C" fn run_static_initializers() {
    special_sections_b = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".bss\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 5]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 8 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_c = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".comment\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 9]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".ctf\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 5]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_d = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".data\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".data1\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 7]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".debug\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 7]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".debug_line\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 12]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".debug_info\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 12]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".debug_abbrev\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 14]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".debug_aranges\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 15]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".dynamic\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 9]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 6 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".dynstr\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 8]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 3 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".dynsym\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 8]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 11 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_f = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".fini\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 2 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".fini_array\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 12]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 15 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_g = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.linkonce.b\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 16]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 8 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.linkonce.n\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 16]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 8 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.linkonce.p\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 16]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.lto_\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 10]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(1 as libc::c_int),
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0x80000000 as libc::c_uint as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".got\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 5]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.version\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 13]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0x6fffffff as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.version_d\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 15]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0x6ffffffd as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.version_r\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 15]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0x6ffffffe as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.liblist\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 13]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0x6ffffff7 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.conflict\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 14]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 4 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".gnu.hash\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 10]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0x6ffffff6 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_h = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".hash\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 5 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_i = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".init\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 2 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".init_array\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 12]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 14 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".interp\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 8]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_l = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".line\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_n = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".noinit\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 8]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 8 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".note.GNU-stack\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 16]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".note\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(1 as libc::c_int),
                type_0: 7 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_p = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".persistent.bss\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 16]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 8 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".persistent\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 12]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".preinit_array\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 15]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 16 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".plt\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 5]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 2 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_r = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".rodata\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 8]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".rodata1\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 9]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: ((1 as libc::c_int) << 1 as libc::c_int) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".rela\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(1 as libc::c_int),
                type_0: 4 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".rel\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 5]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(1 as libc::c_int),
                type_0: 9 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_s = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".shstrtab\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 10]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 3 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".strtab\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 8]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 3 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".symtab\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 8]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 2 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".stabstr\0" as *const u8 as *const libc::c_char,
                prefix_length: 5 as libc::c_int as libc::c_uint,
                suffix_length: 3 as libc::c_int,
                type_0: 3 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_t = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".text\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 2 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".tbss\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 6]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 8 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)
                    + ((1 as libc::c_int) << 10 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".tdata\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 7]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: -(2 as libc::c_int),
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: (((1 as libc::c_int) << 1 as libc::c_int)
                    + ((1 as libc::c_int) << 0 as libc::c_int)
                    + ((1 as libc::c_int) << 10 as libc::c_int)) as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    special_sections_z = [
        {
            let mut init = bfd_elf_special_section {
                prefix: b".zdebug_line\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 13]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".zdebug_info\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 13]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".zdebug_abbrev\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 15]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: b".zdebug_aranges\0" as *const u8 as *const libc::c_char,
                prefix_length: (::core::mem::size_of::<[libc::c_char; 16]>()
                    as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 1 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
        {
            let mut init = bfd_elf_special_section {
                prefix: 0 as *const libc::c_char,
                prefix_length: 0 as libc::c_int as libc::c_uint,
                suffix_length: 0 as libc::c_int,
                type_0: 0 as libc::c_int as libc::c_uint,
                attr: 0 as libc::c_int as bfd_vma,
            };
            init
        },
    ];
    _bfd_elf_large_com_section = {
        let mut init = bfd_section {
            user_set_vma_linker_mark_linker_has_input_gc_mark_compress_status_segment_mark_sec_info_type_use_rela_p_sec_flg0_sec_flg1_sec_flg2_sec_flg3_sec_flg4_sec_flg5: [0; 3],
            c2rust_padding: [0; 1],
            name: b"LARGE_COMMON\0" as *const u8 as *const libc::c_char,
            id: 0 as libc::c_int as libc::c_uint,
            section_id: 0 as libc::c_int as libc::c_uint,
            index: 0 as libc::c_int as libc::c_uint,
            next: 0 as *mut bfd_section,
            prev: 0 as *mut bfd_section,
            flags: 0x1000 as libc::c_int as flagword,
            vma: 0 as libc::c_int as bfd_vma,
            lma: 0 as libc::c_int as bfd_vma,
            size: 0 as libc::c_int as bfd_size_type,
            rawsize: 0 as libc::c_int as bfd_size_type,
            compressed_size: 0 as libc::c_int as bfd_size_type,
            relax: 0 as *mut relax_table,
            relax_count: 0 as libc::c_int,
            output_offset: 0 as libc::c_int as bfd_vma,
            output_section: &mut _bfd_elf_large_com_section,
            alignment_power: 0 as libc::c_int as libc::c_uint,
            relocation: 0 as *mut reloc_cache_entry,
            orelocation: 0 as *mut *mut reloc_cache_entry,
            reloc_count: 0 as libc::c_int as libc::c_uint,
            filepos: 0 as libc::c_int as file_ptr,
            rel_filepos: 0 as libc::c_int as file_ptr,
            line_filepos: 0 as libc::c_int as file_ptr,
            userdata: 0 as *mut libc::c_void,
            contents: 0 as *mut libc::c_uchar,
            lineno: 0 as *mut alent,
            lineno_count: 0 as libc::c_int as libc::c_uint,
            entsize: 0 as libc::c_int as libc::c_uint,
            kept_section: 0 as *mut bfd_section,
            moving_line_filepos: 0 as libc::c_int as file_ptr,
            target_index: 0 as libc::c_int,
            used_by_bfd: 0 as *mut libc::c_void,
            constructor_chain: 0 as *mut relent_chain,
            owner: 0 as *mut bfd,
            symbol: &lcomm_sym as *const asymbol as *mut bfd_symbol,
            symbol_ptr_ptr: &mut _bfd_elf_large_com_section.symbol,
            map_head: C2RustUnnamed_0 {
                link_order: 0 as *mut bfd_link_order,
            },
            map_tail: C2RustUnnamed_0 {
                link_order: 0 as *mut bfd_link_order,
            },
            already_assigned: 0 as *mut bfd_section,
        };
        init.set_user_set_vma(0 as libc::c_int as libc::c_uint);
        init.set_linker_mark(0 as libc::c_int as libc::c_uint);
        init.set_linker_has_input(0 as libc::c_int as libc::c_uint);
        init.set_gc_mark(1 as libc::c_int as libc::c_uint);
        init.set_compress_status(0 as libc::c_int as libc::c_uint);
        init.set_segment_mark(0 as libc::c_int as libc::c_uint);
        init.set_sec_info_type(0 as libc::c_int as libc::c_uint);
        init.set_use_rela_p(0 as libc::c_int as libc::c_uint);
        init.set_sec_flg0(0 as libc::c_int as libc::c_uint);
        init.set_sec_flg1(0 as libc::c_int as libc::c_uint);
        init.set_sec_flg2(0 as libc::c_int as libc::c_uint);
        init.set_sec_flg3(0 as libc::c_int as libc::c_uint);
        init.set_sec_flg4(0 as libc::c_int as libc::c_uint);
        init.set_sec_flg5(0 as libc::c_int as libc::c_uint);
        init
    };
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
